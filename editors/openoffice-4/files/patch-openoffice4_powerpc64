--- bridges/prj/build.lst.orig
+++ bridges/prj/build.lst
@@ -9,6 +9,8 @@
 br	bridges\source\cpp_uno\gcc3_freebsd_intel	nmake	-	u	br_gcc3fi br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_freebsd_x86-64	nmake	-	u	br_gcc3fx br_cppuno_shared br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_freebsd_powerpc	nmake	-	u	br_gcc3fp br_cppuno_shared br_unotypes br_inc NULL
+br	bridges\source\cpp_uno\gcc3_freebsd_powerpc64	nmake	-	u	br_gcc3fp_64 br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcc3lp br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_powerpc64	nmake	-	u	br_gcc3lp_64 br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_mips		nmake	-	u	br_gcc3lmips br_cppuno_shared br_unotypes br_inc NULL
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc/cpp2uno.cxx
@@ -0,0 +1,791 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <string.h>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
+
+#include "share.hxx"
+// #include <stdio.h>
+
+
+using namespace ::com::sun::star::uno;
+
+namespace
+{
+
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+        int ng = 0; //number of gpr registers used 
+#ifndef __NO_FPRS__
+        int nf = 0; //number of fpr regsiters used
+#endif
+        void ** pCppStack; //temporary stack pointer
+       
+        // gpreg:  [ret *], this, [gpr params]
+        // fpreg:  [fpr params]
+        // ovrflw: [gpr or fpr params (properly aligned)]
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
+		{
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+		}
+		else // complex return via ptr (pCppReturn)
+		{
+			pCppReturn = *(void **)gpreg;
+                        gpreg++;
+                        ng++;
+			
+			pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+	}
+	// pop this
+        gpreg++; 
+        ng++;
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) 
+                // value
+		{
+
+			switch (pParamTypeDescr->eTypeClass)
+			{
+
+			  case typelib_TypeClass_DOUBLE:
+#ifndef __NO_FPRS__
+			   if (nf < 8) {
+			      pCppArgs[nPos] = fpreg;
+			      pUnoArgs[nPos] = fpreg;
+			      nf++;
+			      fpreg += 2;
+#else
+               if (ng & 1) {
+                   ng++;
+                   gpreg++;
+               }
+               if (ng < 8) {
+                   pCppArgs[nPos] = gpreg;
+                   pUnoArgs[nPos] = gpreg;
+                   ng += 2;
+                   gpreg += 2;
+#endif
+			   } else {
+				if (((long)ovrflw) & 4) ovrflw++;
+				pCppArgs[nPos] = ovrflw;
+				pUnoArgs[nPos] = ovrflw;
+			        ovrflw += 2;
+			   }
+			   break;
+
+			   case typelib_TypeClass_FLOAT:
+			    // fpreg are all double values so need to
+			    // modify fpreg to be a single word float value
+#ifndef __NO_FPRS__
+			    if (nf < 8) {
+			       float tmp = (float) (*((double *)fpreg));
+			       (*((float *) fpreg)) = tmp;
+			       pCppArgs[nPos] = fpreg;
+			       pUnoArgs[nPos] = fpreg;
+			       nf++;
+			       fpreg += 2;
+#else
+                if (ng < 8) {
+                   pCppArgs[nPos] = gpreg;
+                   pUnoArgs[nPos] = gpreg;
+                   ng++;
+                   gpreg++;
+#endif
+			    } else {
+#if 0 /* abi is not being followed correctly */
+			      if (((long)ovrflw) & 4) ovrflw++;
+			      float tmp = (float) (*((double *)ovrflw));
+			      (*((float *) ovrflw)) = tmp;
+			      pCppArgs[nPos] = ovrflw;
+			      pUnoArgs[nPos] = ovrflw;
+			      ovrflw += 2;
+#else
+                              pCppArgs[nPos] = ovrflw;
+			      pUnoArgs[nPos] = ovrflw;
+			      ovrflw += 1;
+#endif
+                            }
+			    break;
+
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			 if (ng & 1) {
+			    ng++;
+			    gpreg++;
+			 }  
+			 if (ng < 8) {
+			    pCppArgs[nPos] = gpreg;
+			    pUnoArgs[nPos] = gpreg;
+			    ng += 2;
+			    gpreg += 2;
+			 } else {
+			    if (((long)ovrflw) & 4) ovrflw++;
+			    pCppArgs[nPos] = ovrflw;
+			    pUnoArgs[nPos] = ovrflw;
+			    ovrflw += 2;
+			  }
+			  break;
+
+			case typelib_TypeClass_BYTE:
+			case typelib_TypeClass_BOOLEAN:
+			 if (ng < 8) {
+			      pCppArgs[nPos] = (((char *)gpreg) + 3);
+			      pUnoArgs[nPos] = (((char *)gpreg) + 3);
+			      ng++;
+			      gpreg++;
+			 } else {
+			      pCppArgs[nPos] = (((char *)ovrflw) + 3);
+			      pUnoArgs[nPos] = (((char *)ovrflw) + 3);
+			      ovrflw++;
+			 }
+			 break;
+
+
+		       case typelib_TypeClass_CHAR:
+		       case typelib_TypeClass_SHORT:
+		       case typelib_TypeClass_UNSIGNED_SHORT:
+			if (ng < 8) {
+			      pCppArgs[nPos] = (((char *)gpreg)+ 2);
+			      pUnoArgs[nPos] = (((char *)gpreg)+ 2);
+			      ng++;
+			      gpreg++;
+			} else {
+			      pCppArgs[nPos] = (((char *)ovrflw) + 2);
+			      pUnoArgs[nPos] = (((char *)ovrflw) + 2);
+			      ovrflw++;
+			}
+			break;
+
+
+		      default:
+			if (ng < 8) {
+			      pCppArgs[nPos] = gpreg;
+			      pUnoArgs[nPos] = gpreg;
+			      ng++;
+			      gpreg++;
+			} else {
+			      pCppArgs[nPos] = ovrflw;
+			      pUnoArgs[nPos] = ovrflw;
+			      ovrflw++;
+			}
+                        break;
+
+		        }
+		        // no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+
+		        if (ng < 8) { 
+		          pCppArgs[nPos] = *(void **)gpreg;
+		          pCppStack = gpreg;
+		          ng++;
+		          gpreg++;
+		        } else {
+		          pCppArgs[nPos] = *(void **)ovrflw;
+		          pCppStack = ovrflw;
+		         ovrflw++;
+		        }
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										*(void **)pCppStack, pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = *(void **)pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+	}
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	
+	// in case an exception occured...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); 
+                // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occured...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										pThis->getBridge()->getUno2Cpp() );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										pThis->getBridge()->getUno2Cpp() );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to return reg
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_Int32 nFunctionIndex,
+        sal_Int32 nVtableOffset,
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
+	
+	// gpreg:  [ret *], this, [other gpr params]
+	// fpreg:  [fpr params]
+	// ovrflw: [gpr or fpr params (properly aligned)]
+
+        void * pThis;
+        if (nFunctionIndex & 0x80000000 )
+	{
+		nFunctionIndex &= 0x7fffffff;
+		pThis = gpreg[1];
+	}
+	else
+        {
+		pThis = gpreg[0];
+        }
+    
+        pThis = static_cast< char * >(pThis) - nVtableOffset;
+        bridges::cpp_uno::shared::CppInterfaceProxy * pCppI
+		  = bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy(
+			pThis);
+
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
+	
+	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException(
+            rtl::OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pThis );
+	}
+	
+	// determine called method
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+    
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nFunctionIndex)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
+                    pCppI->getBridge()->getCppEnv(),
+                    (void **)&pInterface, pCppI->getOid().pData, 
+                    (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( gpreg[0] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = gpreg[0];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+			}
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+		throw RuntimeException(
+            rtl::OUString::createFromAscii("no member description found!"),
+            (XInterface *)pThis );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+	return eRet;
+}
+
+//==================================================================================================
+/**
+ * is called on incoming vtable calls
+ * (called by asm snippets)
+ */
+static void cpp_vtable_call( int nFunctionIndex, int nVtableOffset, void** gpregptr, void** fpregptr, void** ovrflw)
+{
+        sal_Int32     gpreg[8];
+        memcpy( gpreg, gpregptr, 32);
+
+#ifndef __NO_FPRS__
+        double        fpreg[8];
+        memcpy( fpreg, fpregptr, 64);
+#endif
+
+	volatile long nRegReturn[2];
+
+        // fprintf(stderr,"in cpp_vtable_call nFunctionIndex is %x\n",nFunctionIndex);
+        // fprintf(stderr,"in cpp_vtable_call nVtableOffset is %x\n",nVtableOffset);
+        // fflush(stderr);
+
+	typelib_TypeClass aType = 
+             cpp_mediate( nFunctionIndex, nVtableOffset, (void**)gpreg,
+#ifndef __NO_FPRS__
+                 (void**)fpreg, 
+#else
+                 NULL,
+#endif
+                 ovrflw, (sal_Int64*)nRegReturn );
+    
+	switch( aType )
+	{
+
+                // move return value into register space
+                // (will be loaded by machine code snippet)
+
+                case typelib_TypeClass_BOOLEAN:
+                case typelib_TypeClass_BYTE:
+                  __asm__( "lbz 3,%0\n\t" : :
+			   "m"(nRegReturn[0]) );
+                  break;
+ 
+                case typelib_TypeClass_CHAR:
+                case typelib_TypeClass_SHORT:
+                case typelib_TypeClass_UNSIGNED_SHORT:
+                  __asm__( "lhz 3,%0\n\t" : :
+			   "m"(nRegReturn[0]) );
+                  break;
+
+		case typelib_TypeClass_FLOAT:
+#ifndef __NO_FPRS__
+                  __asm__( "lfs 1,%0\n\t" : :
+                           "m" (*((float*)nRegReturn)) );
+ #else
+                  __asm__( "lwz 3,%0\n\t" : :
+                           "m"(nRegReturn[0]) );
+#endif
+		  break;
+
+		case typelib_TypeClass_DOUBLE:
+#ifndef __NO_FPRS__
+		  __asm__( "lfd 1,%0\n\t" : :
+                           "m" (*((double*)nRegReturn)) );
+#else
+          __asm__( "lwz 3,%0\n\t" : :
+                           "m"(nRegReturn[0]) );
+          __asm__( "lwz 4,%0\n\t" : :
+                           "m"(nRegReturn[1]) );
+#endif
+		  break;
+
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+		  __asm__( "lwz 4,%0\n\t" : :
+                           "m"(nRegReturn[1]) );  // fall through
+
+		default:
+		  __asm__( "lwz 3,%0\n\t" : :
+                           "m"(nRegReturn[0]) );
+		  break;
+	}
+}
+
+
+int const codeSnippetSize = 108;
+
+unsigned char *  codeSnippet( unsigned char * code, sal_Int32 functionIndex, sal_Int32 vtableOffset, 
+                              bool simpleRetType)
+{
+
+  // fprintf(stderr,"in codeSnippet functionIndex is %x\n", functionIndex);
+  // fprintf(stderr,"in codeSnippet vtableOffset is %x\n", vtableOffset);
+  // fflush(stderr);
+
+    if (! simpleRetType )
+        functionIndex |= 0x80000000;
+
+    unsigned long * p = (unsigned long *) code;
+    
+    // OSL_ASSERT( sizeof (long) == 4 );
+    OSL_ASSERT((((unsigned long)code) & 0x3) == 0 );  //aligned to 4 otherwise a mistake
+
+    /* generate this code */
+    // # so first save gpr 3 to gpr 10 (aligned to 4)
+    //	stw	r3,-2048(r1)
+    //	stw	r4,-2044(r1)
+    //	stw	r5,-2040(r1)
+    //	stw	r6,-2036(r1)
+    //	stw	r7,-2032(r1)
+    //	stw	r8,-2028(r1)
+    //	stw	r9,-2024(r1)
+    //	stw	r10,-2020(r1)
+
+
+    // # next save fpr 1 to fpr 8 (aligned to 8)
+    // if dedicated floating point registers are used
+    //	stfd	f1,-2016(r1)
+    //	stfd	f2,-2008(r1)
+    //	stfd	f3,-2000(r1)
+    //	stfd	f4,-1992(r1)
+    //	stfd	f5,-1984(r1)
+    //	stfd	f6,-1976(r1)
+    //	stfd	f7,-1968(r1)
+    //	stfd	f8,-1960(r1)
+
+    // # now here is where cpp_vtable_call must go
+    //	lis	r3,-8531
+    //	ori	r3,r3,48879
+    //	mtctr	r3
+
+    // # now load up the functionIndex
+    //	lis	r3,-8531
+    //	ori	r3,r3,48879
+
+    // # now load up the vtableOffset 
+    //	lis	r4,-8531
+    //	ori	r4,r4,48879
+
+    // #now load up the pointer to the saved gpr registers
+    //	addi	r5,r1,-2048
+
+    // #now load up the pointer to the saved fpr registers
+    //	addi	r6,r1,-2016
+    // if no dedicated floating point registers are used than we have NULL
+    // pointer there
+    //  li      r6, 0
+    //
+
+    // #now load up the pointer to the overflow call stack
+    //	addi	r7,r1,8
+    //	bctr
+
+      * p++ = 0x9061f800;
+      * p++ = 0x9081f804;
+      * p++ = 0x90a1f808;
+      * p++ = 0x90c1f80c;
+      * p++ = 0x90e1f810;
+      * p++ = 0x9101f814;
+      * p++ = 0x9121f818;
+      * p++ = 0x9141f81c;
+#ifndef __NO_FPRS__
+      * p++ = 0xd821f820;
+      * p++ = 0xd841f828;
+      * p++ = 0xd861f830;
+      * p++ = 0xd881f838;
+      * p++ = 0xd8a1f840;
+      * p++ = 0xd8c1f848;
+      * p++ = 0xd8e1f850;
+      * p++ = 0xd901f858;
+#else
+      /* these nops could be replaced with a smaller codeSnippetSize - 8 * 4 */
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+      * p++ = 0x60000000;
+#endif
+      * p++ = 0x3c600000 | (((unsigned long)cpp_vtable_call) >> 16);
+      * p++ = 0x60630000 | (((unsigned long)cpp_vtable_call) & 0x0000FFFF);
+      * p++ = 0x7c6903a6;
+      * p++ = 0x3c600000 | (((unsigned long)functionIndex) >> 16);
+      * p++ = 0x60630000 | (((unsigned long)functionIndex) & 0x0000FFFF);
+      * p++ = 0x3c800000 | (((unsigned long)vtableOffset) >> 16);
+      * p++ = 0x60840000 | (((unsigned long)vtableOffset) & 0x0000FFFF);
+      * p++ = 0x38a1f800;
+#ifndef __NO_FPRS__
+      * p++ = 0x38c1f820;
+#else
+      * p++ = 0x38c00000;
+#endif
+      * p++ = 0x38e10008;
+      * p++ = 0x4e800420;
+      return (code + codeSnippetSize);
+
+}
+
+
+}
+
+void bridges::cpp_uno::shared::VtableFactory::flushCode(unsigned char const * bptr, unsigned char const * eptr)
+{
+    int const lineSize = 32;
+    for (unsigned char const * p = bptr; p < eptr + lineSize; p += lineSize) {
+        __asm__ volatile ("dcbst 0, %0" : : "r"(p) : "memory");
+    }
+    __asm__ volatile ("sync" : : : "memory");
+    for (unsigned char const * p = bptr; p < eptr + lineSize; p += lineSize) {
+        __asm__ volatile ("icbi 0, %0" : : "r"(p) : "memory");
+    }
+    __asm__ volatile ("isync" : : : "memory");
+}
+
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+{
+    return static_cast< Slot * >(block) + 2;
+}
+
+sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
+    sal_Int32 slotCount)
+{
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
+}
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
+}
+
+unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
+    Slot ** slots, unsigned char * code, sal_PtrDiff writetoexecdiff,
+    typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
+{
+     (*slots) -= functionCount;
+     Slot * s = *slots;
+  // fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
+  // fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
+  // fflush(stderr);
+
+    for (sal_Int32 i = 0; i < type->nMembers; ++i) {
+        typelib_TypeDescription * member = 0;
+        TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
+        OSL_ASSERT(member != 0);
+        switch (member->eTypeClass) {
+        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+            // Getter:
+            (s++)->fn = code + writetoexecdiff;
+            code = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription * >(
+                        member)->pAttributeTypeRef));
+
+            // Setter:
+            if (!reinterpret_cast<
+                typelib_InterfaceAttributeTypeDescription * >(
+                    member)->bReadOnly)
+            {
+                (s++)->fn = code + writetoexecdiff;
+                code = codeSnippet(code, functionOffset++, vtableOffset, true);
+            }
+            break;
+
+        case typelib_TypeClass_INTERFACE_METHOD:
+            (s++)->fn = code + writetoexecdiff;
+            code = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription * >(
+                        member)->pReturnTypeRef));
+            break;
+
+        default:
+            OSL_ASSERT(false);
+            break;
+        }
+        TYPELIB_DANGER_RELEASE(member);
+    }
+    return code;
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc/except.cxx
@@ -0,0 +1,283 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <stdio.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#if OSL_DEBUG_LEVEL > 1
+    char const * start = p;
+#endif
+
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+
+	OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+
+#if OSL_DEBUG_LEVEL > 1
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+
+    Mutex m_mutex;
+	t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
+    if (iRttiFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iRttiFind->second;
+    }
+
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+		::uno_destructData( pExc, pTD, cpp_release );
+		::typelib_typedescription_release( pTD );
+	}
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+        terminate();
+
+	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+
+	// destruct uno exception
+	::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+        terminate();
+    }
+
+	__cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+{
+    OSL_ENSURE( header, "### no exception header!!!" );
+    if (! header)
+        terminate();
+
+	typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
+    if (! pExcTypeDescr)
+        terminate();
+
+    // construct uno exception any
+    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+    ::typelib_typedescription_release( pExcTypeDescr );
+}
+
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc/makefile.mk
@@ -0,0 +1,76 @@
+#**************************************************************
+#  
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#  
+#    http://www.apache.org/licenses/LICENSE-2.0
+#  
+#  Unless required by applicable law or agreed to in writing,
+#  software distributed under the License is distributed on an
+#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+#  KIND, either express or implied.  See the License for the
+#  specific language governing permissions and limitations
+#  under the License.
+#  
+#**************************************************************
+
+
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)$(CPUNAME)" == "GCCFREEBSDPgcc3POWERPC"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+# In case someone enabled the non-standard -fomit-frame-pointer which does not
+# work with the .cxx sources in this directory:
+CFLAGSCXX += -fno-omit-frame-pointer
+
+NOOPTFILES= \
+	$(SLO)$/uno2cpp.obj
+
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+SHL1RPATH=URELIB
+
+SHL1OBJS= $(SLOFILES)
+SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
+
+SHL1STDLIBS= \
+	$(CPPULIB)			\
+	$(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc/share.hxx
@@ -0,0 +1,87 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+#include "uno/mapping.h"
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+  void dummy_can_throw_anything( char const * );
+
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc/uno2cpp.cxx
@@ -0,0 +1,668 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <stdlib.h>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/vtables.hxx"
+
+#include "share.hxx"
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace
+{
+
+
+//==================================================================================================
+static void callVirtualMethod(
+    void * pAdjustedThisPtr,
+    sal_Int32 nVtableIndex,
+    void * pRegisterReturn,
+    typelib_TypeClass eReturnType,
+    char * pPT,
+    sal_Int32 * pStackLongs,
+    sal_Int32 nStackLongs)
+{
+
+  // parameter list is mixed list of * and values
+  // reference parameters are pointers
+
+  // the basic idea here is to use gpr[8] as a storage area for
+  // the future values of registers r3 to r10 needed for the call, 
+  // and similarly fpr[8] as a storage area for the future values
+  // of floating point registers f1 to f8
+
+     unsigned long * mfunc;        // actual function to be invoked
+     void (*ptr)();
+     int gpr[8];                   // storage for gpregisters, map to r3-r10
+     int off;                      // offset used to find function
+#ifndef __NO_FPRS__
+     double fpr[8];                // storage for fpregisters, map to f1-f8
+     int f;                        // number of fprs mapped so far
+     double dret;                  // temporary function return values
+#endif
+     int n;                        // number of gprs mapped so far
+     long *p;                      // pointer to parameter overflow area
+     int c;                        // character of parameter type being decoded
+     int iret, iret2;
+
+     // Because of the Power PC calling conventions we could be passing
+     // parameters in both register types and on the stack. To create the
+     // stack parameter area we need we now simply allocate local
+     // variable storage param[] that is at least the size of the parameter stack
+     // (more than enough space) which we can overwrite the parameters into.
+
+     // Note: This keeps us from having to decode the signature twice and
+     // prevents problems with later local variables.
+
+     // Note: could require up to  2*nStackLongs words of parameter stack area 
+     // if the call has many float parameters (i.e. floats take up only 1 
+     // word on the stack but double takes 2 words in parameter area in the
+     // stack frame .
+
+     // Update! floats on the outgoing parameter stack only take up 1 word
+     // (stfs is used) which is not correct according to the ABI but we
+     // will match what the compiler does until this is figured out 
+
+     // this grows the current stack to the appropriate size
+     // and sets the outgoing stack pointer p to the right place
+     __asm__ __volatile__ (
+          "rlwinm %0,%0,3,3,28\n\t"
+          "addi %0,%0,22\n\t"
+          "rlwinm %0,%0,0,4,28\n\t"
+          "lwz 0,0(1)\n\t"
+          "subf 1,%0,1\n\t"
+          "stw 0,0(1)\n\t"
+          : : "r" (nStackLongs) : "0" );
+
+     __asm__ __volatile__ ( "addi %0,1,8" : "=r" (p) : );
+
+     // never called
+     // if (! pAdjustedThisPtr ) dummy_can_throw_anything("xxx"); // address something
+
+
+     // now begin to load the C++ function arguments into storage
+     n = 0;
+#ifndef __NO_FPRS__
+     f = 0;
+#endif
+
+     // now we need to parse the entire signature string */
+     // until we get the END indicator */
+
+     // treat complex return pointer like any other parameter //
+
+#if 0
+     /* Let's figure out what is really going on here*/
+     fprintf(stderr,"callVirtualMethod paramters string is %s\n",pPT);
+     int k = nStackLongs;
+     long * q = (long *)pStackLongs;
+     while (k > 0) {
+       fprintf(stderr,"uno stack is: %x\n",*q);
+       k--;
+       q++;
+     }
+#endif
+
+     /* parse the argument list up to the ending ) */
+     while (*pPT != 'X') {
+       c = *pPT;
+       switch (c) {
+       case 'D':                   /* type is double */
+#ifndef __NO_FPRS__
+            if (f < 8) {
+               fpr[f++] = *((double *)pStackLongs);   /* store in register */
+#else
+            if (n & 1)
+               n++;
+            if (n < 8) {
+               gpr[n++] = *pStackLongs;
+               gpr[n++] = *(pStackLongs+1);
+#endif
+	    } else {
+	       if (((long) p) & 4)          
+	          p++;
+               *p++ = *pStackLongs;       /* or on the parameter stack */
+               *p++ = *(pStackLongs + 1);
+	    }
+            pStackLongs += 2;
+            break;
+
+       case 'F':                   /* type is float */
+	 /* this assumes that floats are stored as 1 32 bit word on param
+	    stack and that if passed in parameter stack to C, should be
+	    as double word.
+
+            Whoops: the abi is not actually followed by gcc, need to 
+            store floats as a *single* word on outgoing parameter stack
+            to match what gcc actually does
+	 */
+#ifndef __NO_FPRS__
+            if (f < 8) {
+               fpr[f++] = *((float *)pStackLongs);
+#else
+            if (n < 8) {
+               gpr[n++] = *pStackLongs;
+#endif
+	    } else {
+#if 0 /* if abi were followed */
+	       if (((long) p) & 4)          
+	          p++;
+	       *((double *)p) = *((float *)pStackLongs);
+               p += 2;
+#else
+	       *((float *)p) = *((float *)pStackLongs);
+               p += 1;
+#endif
+	    }
+            pStackLongs += 1;
+            break;
+
+       case 'H':                /* type is long long */
+            if (n & 1) n++; 	/* note even elements gpr[] will map to
+                                   odd registers*/
+            if (n <= 6) {
+               gpr[n++] = *pStackLongs;
+               gpr[n++] = *(pStackLongs+1);
+	    } else {
+	       if (((long) p) & 4)          
+	          p++;
+               *p++ = *pStackLongs;
+               *p++ = *(pStackLongs+1);
+	    }
+            pStackLongs += 2;
+            break;
+
+       case 'S':
+            if (n < 8) {
+               gpr[n++] = *((unsigned short*)pStackLongs);
+	    } else {
+               *p++ = *((unsigned short *)pStackLongs);
+	    }
+            pStackLongs += 1;
+            break;
+
+       case 'B':
+            if (n < 8) {
+               gpr[n++] = *((char *)pStackLongs);
+	    } else {
+               *p++ = *((char *)pStackLongs);
+	    }
+            pStackLongs += 1;
+            break;
+
+       default:
+            if (n < 8) {
+               gpr[n++] = *pStackLongs;
+	    } else {
+               *p++ = *pStackLongs;
+	    }
+            pStackLongs += 1;
+            break;
+       }
+       pPT++;
+     }
+
+     /* figure out the address of the function we need to invoke */
+     off = nVtableIndex; 
+     off = off * 4;                         // 4 bytes per slot
+     mfunc = *((unsigned long **)pAdjustedThisPtr);    // get the address of the vtable
+     mfunc = (unsigned long *)((char *)mfunc + off); // get the address from the vtable entry at offset 
+     mfunc = *((unsigned long **)mfunc);                 // the function is stored at the address
+     ptr = (void (*)())mfunc;   
+
+    /* Set up the machine registers and invoke the function */
+
+    __asm__ __volatile__ (
+		"lwz	3,	0(%0)\n\t"
+		"lwz	4,	4(%0)\n\t"
+		"lwz	5,	8(%0)\n\t"
+		"lwz	6,	12(%0)\n\t"
+		"lwz	7,	16(%0)\n\t"
+		"lwz	8,	20(%0)\n\t"
+		"lwz	9,	24(%0)\n\t"
+		"lwz	10,	28(%0)\n\t"
+#ifndef __NO_FPRS__
+		"lfd	1,	0(%1)\n\t"
+		"lfd	2,	8(%1)\n\t"
+		"lfd	3,	16(%1)\n\t"
+		"lfd	4,	24(%1)\n\t"
+		"lfd	5,	32(%1)\n\t"
+		"lfd	6,	40(%1)\n\t"
+		"lfd	7,	48(%1)\n\t"
+		"lfd	8,	56(%1)\n\t"
+	        : : "r" (gpr), "r" (fpr)
+#else
+	        : : "r" (gpr)
+#endif
+		: "0", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
+    );
+
+    (*ptr)();
+
+    __asm__ __volatile__ (
+       "mr     %0,     3\n\t"
+       "mr     %1,     4\n\t"
+#ifndef __NO_FPRS__
+       "fmr    %2,     1\n\t"
+       : "=r" (iret), "=r" (iret2), "=f" (dret)
+#else
+       : "=r" (iret), "=r" (iret2)
+#endif
+       : );
+
+    switch( eReturnType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+		        ((long*)pRegisterReturn)[0] = iret;
+			((long*)pRegisterReturn)[1] = iret2;
+		case typelib_TypeClass_LONG:
+		case typelib_TypeClass_UNSIGNED_LONG:
+		case typelib_TypeClass_ENUM:
+			((long*)pRegisterReturn)[0] = iret;
+			break;
+		case typelib_TypeClass_CHAR:
+		case typelib_TypeClass_SHORT:
+		case typelib_TypeClass_UNSIGNED_SHORT:
+		        *(unsigned short*)pRegisterReturn = (unsigned short)iret;
+			break;
+		case typelib_TypeClass_BOOLEAN:
+		case typelib_TypeClass_BYTE:
+		        *(unsigned char*)pRegisterReturn = (unsigned char)iret;
+			break;
+		case typelib_TypeClass_FLOAT:
+#ifndef __NO_FPRS__
+		        *(float*)pRegisterReturn = (float)dret;
+#else
+		        ((unsigned int*)pRegisterReturn)[0] = iret;
+#endif
+			break;
+		case typelib_TypeClass_DOUBLE:
+#ifndef __NO_FPRS__
+			*(double*)pRegisterReturn = dret;
+#else
+			((unsigned int*)pRegisterReturn)[0] = iret;
+			((unsigned int*)pRegisterReturn)[1] = iret2;
+#endif
+			break;
+		default:
+			break;
+	}
+}
+
+
+//================================================================================================== 
+static void cpp_call(
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::VtableSlot  aVtableSlot,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	char * pCppStack		=
+  		(char *)alloca( sizeof(sal_Int32) + ((nParams+2) * sizeof(sal_Int64)) );
+  	char * pCppStackStart	= pCppStack;
+	
+        // need to know parameter types for callVirtualMethod so generate a signature string
+        char * pParamType = (char *) alloca(nParams+2);
+        char * pPT = pParamType;
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	// OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+	
+	if (pReturnTypeDescr)
+	{
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = *(void **)pCppStack = 
+                              (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+			       ? alloca( pReturnTypeDescr->nSize ): pUnoReturn); // direct way
+                        *pPT++ = 'I'; //signify that a complex return type on stack
+			pCppStack += sizeof(void *);
+		}
+	}
+	// push this
+        void* pAdjustedThisPtr = reinterpret_cast< void **>(pThis->getCppI()) + aVtableSlot.offset;
+	*(void**)pCppStack = pAdjustedThisPtr;
+	pCppStack += sizeof( void* );
+        *pPT++ = 'I';
+
+	// stack space
+	// OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// args
+	void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+		
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
+		{
+			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
+									pThis->getBridge()->getUno2Cpp() );
+			
+			switch (pParamTypeDescr->eTypeClass)
+			{
+
+                          // we need to know type of each param so that we know whether to use
+                          // gpr or fpr to pass in parameters:
+                          // Key: I - int, long, pointer, etc means pass in gpr
+                          //      B - byte value passed in gpr
+                          //      S - short value passed in gpr
+                          //      F - float value pass in fpr
+                          //      D - double value pass in fpr
+                          //      H - long long int pass in proper pairs of gpr (3,4) (5,6), etc
+                          //      X - indicates end of parameter description string
+
+		          case typelib_TypeClass_LONG:
+		          case typelib_TypeClass_UNSIGNED_LONG:
+		          case typelib_TypeClass_ENUM:
+			    *pPT++ = 'I';
+			    break;
+ 		          case typelib_TypeClass_SHORT:
+		          case typelib_TypeClass_CHAR:
+		          case typelib_TypeClass_UNSIGNED_SHORT:
+                            *pPT++ = 'S';
+                            break;
+		          case typelib_TypeClass_BOOLEAN:
+		          case typelib_TypeClass_BYTE:
+                            *pPT++ = 'B';
+                            break;
+		          case typelib_TypeClass_FLOAT:
+                            *pPT++ = 'F';
+			    break;
+		        case typelib_TypeClass_DOUBLE:
+			    *pPT++ = 'D';
+			    pCppStack += sizeof(sal_Int32); // extra long
+			    break;
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			    *pPT++ = 'H';
+			    pCppStack += sizeof(sal_Int32); // extra long
+			default:
+			    break;
+			}
+
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			if (! rParam.bIn) // is pure out
+			{
+				// cpp out is constructed mem, uno out is not!
+				uno_constructData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pParamTypeDescr );
+				pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pUnoArgs[nPos], pParamTypeDescr, 
+                                        pThis->getBridge()->getUno2Cpp() );
+				
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				*(void **)pCppStack = pCppArgs[nPos] = pUnoArgs[nPos];
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+                        // KBH: FIXME: is this the right way to pass these
+                        *pPT++='I';
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+  
+        // terminate the signature string
+        *pPT++='X';
+        *pPT=0;
+
+	try
+	{
+		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 3), "UNALIGNED STACK !!! (Please DO panic)" );
+		callVirtualMethod(
+			pAdjustedThisPtr, aVtableSlot.index,
+			pCppReturn, pReturnTypeDescr->eTypeClass, pParamType,
+			(sal_Int32 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_Int32) );
+		// NO exception occured...
+		*ppUnoExc = 0;
+		
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											pThis->getBridge()->getCpp2Uno() );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									pThis->getBridge()->getCpp2Uno() );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch (...)
+ 	{
+  		// fill uno exception
+		fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, 
+                                  *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
+        
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+}
+
+namespace bridges { namespace cpp_uno { namespace shared {
+
+void unoInterfaceProxyDispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException )
+{
+	// is my surrogate
+        bridges::cpp_uno::shared::UnoInterfaceProxy * pThis 
+            = static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy *> (pUnoI);
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription const * >(
+                        pMemberDescr)));
+
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, aVtableSlot,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+                        aVtableSlot.index += 1; //get then set method
+			cpp_call(
+				pThis, aVtableSlot,
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription const * >(
+                        pMemberDescr)));
+		switch (aVtableSlot.index)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->getUnoEnv()->getRegisteredInterface)(
+                    pThis->pBridge->getUnoEnv(),
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, aVtableSlot,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+} } }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc64/cpp2uno.cxx
@@ -0,0 +1,718 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
+
+#include "share.hxx"
+#include <stdio.h>
+#include <string.h>
+
+
+using namespace ::com::sun::star::uno;
+
+namespace
+{
+
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+#ifdef CMC_DEBUG
+    fprintf(stderr, "as far as cpp2uno_call\n");
+#endif
+
+    int ng = 0; //number of gpr registers used 
+    int nf = 0; //number of fpr regsiters used
+       
+    // gpreg:  [ret *], this, [gpr params]
+    // fpreg:  [fpr params]
+    // ovrflw: [gpr or fpr params (properly aligned)]
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
+		{
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+		}
+		else // complex return via ptr (pCppReturn)
+		{
+			pCppReturn = *(void **)gpreg;
+            gpreg++;
+            ng++;
+			
+			pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+	}
+	// pop this
+    gpreg++; 
+    ng++;
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int64), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes = 0;
+	bool bOverFlowUsed = false;
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+#ifdef CMC_DEBUG
+		fprintf(stderr, "arg %d of %d\n", nPos, nParams);
+#endif
+
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) 
+		{
+#ifdef CMC_DEBUG
+			fprintf(stderr, "simple\n");
+#endif
+
+			switch (pParamTypeDescr->eTypeClass)
+			{
+				case typelib_TypeClass_FLOAT:
+				case typelib_TypeClass_DOUBLE:
+					if (nf < ppc64::MAX_SSE_REGS)
+					{
+						if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT)
+						{
+                        	float tmp = (float) (*((double *)fpreg));
+                        	(*((float *) fpreg)) = tmp;
+						}
+						pCppArgs[nPos] = pUnoArgs[nPos] = fpreg++;
+						nf++;
+					}
+					else
+                    {
+						pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+					break;
+                case typelib_TypeClass_BYTE:
+                case typelib_TypeClass_BOOLEAN:
+                    if (ng < ppc64::MAX_GPR_REGS)
+					{
+                        pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)gpreg) + (sizeof(void*)-1));
+                        ng++;
+                        gpreg++;
+                    }
+                    else
+					{
+                        pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)ovrflw) + (sizeof(void*)-1));
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+                    break;
+                case typelib_TypeClass_CHAR:
+                case typelib_TypeClass_SHORT:
+                case typelib_TypeClass_UNSIGNED_SHORT:
+                    if (ng < ppc64::MAX_GPR_REGS)
+					{
+                        pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)gpreg) + (sizeof(void*)-2));
+                        ng++;
+                        gpreg++;
+                    }
+                    else
+					{
+                        pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)ovrflw) + (sizeof(void*)-2));
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+                    break;
+		case typelib_TypeClass_ENUM:
+                case typelib_TypeClass_LONG:
+                case typelib_TypeClass_UNSIGNED_LONG:
+                    if (ng < ppc64::MAX_GPR_REGS)
+					{
+                        pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)gpreg) + (sizeof(void*)-4));
+                        ng++;
+                        gpreg++;
+                    }
+                    else
+					{
+                        pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)ovrflw) + (sizeof(void*)-4));
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+                    break;
+				default:
+					if (ng < ppc64::MAX_GPR_REGS) 
+					{
+						pCppArgs[nPos] = pUnoArgs[nPos] = gpreg++;
+						ng++;
+					}
+					else
+                    {
+						pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+					break;
+		        }
+
+		        // no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+#ifdef CMC_DEBUG
+			fprintf(stderr, "complex, ng is %d\n", ng);
+#endif
+            void *pCppStack; //temporary stack pointer
+
+			if (ng < ppc64::MAX_GPR_REGS)
+			{ 
+		        pCppArgs[nPos] = pCppStack = *gpreg++;
+			    ng++;
+			}
+			else
+            {
+			    pCppArgs[nPos] = pCppStack = *ovrflw;
+                bOverFlowUsed = true;
+            }
+            if (bOverFlowUsed) ovrflw++;
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										pCppStack, pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+	}
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "end of params\n");
+#endif
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	
+	// in case an exception occurred...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); 
+                // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occurred...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										pThis->getBridge()->getUno2Cpp() );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										pThis->getBridge()->getUno2Cpp() );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to return reg
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_uInt64 nOffsetAndIndex,
+        void ** gpreg, void ** fpreg, long sp,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+    OSL_ENSURE( sizeof(sal_Int64)==sizeof(void *), "### unexpected!" );
+
+    sal_Int32 nVtableOffset = (nOffsetAndIndex >> 32);
+    sal_Int32 nFunctionIndex = (nOffsetAndIndex & 0xFFFFFFFF);
+
+    long sf = *(long*)sp;
+    void ** ovrflw = (void**)(sf + 112);
+	
+    // gpreg:  [ret *], this, [other gpr params]
+    // fpreg:  [fpr params]
+    // ovrflw: [gpr or fpr params (properly aligned)]
+
+    void * pThis;
+    if (nFunctionIndex & 0x80000000 )
+    {
+	nFunctionIndex &= 0x7fffffff;
+	pThis = gpreg[1];
+#ifdef CMC_DEBUG
+	fprintf(stderr, "pThis is gpreg[1]\n");
+#endif
+    }
+    else
+    {
+	pThis = gpreg[0];
+#ifdef CMC_DEBUG
+	fprintf(stderr, "pThis is gpreg[0]\n");
+#endif
+    }
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "pThis is %lx\n", pThis);
+#endif
+    
+    pThis = static_cast< char * >(pThis) - nVtableOffset;
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "pThis is now %lx\n", pThis);
+#endif
+
+    bridges::cpp_uno::shared::CppInterfaceProxy * pCppI
+	    = bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy(
+			pThis);
+
+    typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "indexes are %d %d\n", nFunctionIndex, pTypeDescr->nMapFunctionIndexToMemberIndex);
+#endif
+	
+	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException(
+            rtl::OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pThis );
+	}
+	
+	// determine called method
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "members are %d %d\n", nMemberPos, pTypeDescr->nAllMembers);
+#endif
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+    
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nFunctionIndex)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
+                    pCppI->getBridge()->getCppEnv(),
+                    (void **)&pInterface, pCppI->getOid().pData, 
+                    (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( gpreg[0] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = gpreg[0];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+			}
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+#ifdef CMC_DEBUG
+	    fprintf(stderr, "screwed\n");
+#endif
+
+		throw RuntimeException(
+            rtl::OUString::createFromAscii("no member description found!"),
+            (XInterface *)pThis );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+#ifdef CMC_DEBUG
+        fprintf(stderr, "end of cpp_mediate\n");
+#endif
+	return eRet;
+}
+
+extern "C" void privateSnippetExecutor( ... )
+{
+    volatile long nOffsetAndIndex;
+
+    //mr %r3, %r11            # move into arg1 the 64bit value passed from OOo
+    __asm__ __volatile__ (
+                "mr     %0,    11\n\t"
+                : "=r" (nOffsetAndIndex) : );
+
+    sal_uInt64 gpreg[ppc64::MAX_GPR_REGS];
+    double fpreg[ppc64::MAX_SSE_REGS];
+
+    __asm__ __volatile__ (
+        "std 3,   0(%0)\t\n"
+        "std 4,   8(%0)\t\n"
+        "std 5,  16(%0)\t\n"
+        "std 6,  24(%0)\t\n"
+        "std 7,  32(%0)\t\n"
+        "std 8,  40(%0)\t\n"
+        "std 9,  48(%0)\t\n"
+        "std 10, 56(%0)\t\n"
+        "stfd 1,   0(%1)\t\n"
+        "stfd 2,   8(%1)\t\n"
+        "stfd 3,  16(%1)\t\n"
+        "stfd 4,  24(%1)\t\n"
+        "stfd 5,  32(%1)\t\n"
+        "stfd 6,  40(%1)\t\n"
+        "stfd 7,  48(%1)\t\n"
+        "stfd 8,  56(%1)\t\n"
+        "stfd 9,  64(%1)\t\n"
+        "stfd 10, 72(%1)\t\n"
+        "stfd 11, 80(%1)\t\n"
+        "stfd 12, 88(%1)\t\n"
+        "stfd 13, 96(%1)\t\n"
+	: : "r" (gpreg), "r" (fpreg) 
+        : "r0", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10",
+          "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7", "fr8", "fr9",
+          "fr10", "fr11", "fr12", "fr13"
+    );
+
+    volatile long sp;
+
+    //stack pointer
+    __asm__ __volatile__ (
+                "mr     %0,    1\n\t"
+                : "=r" (sp) : );
+
+    volatile long nRegReturn[1];
+
+    typelib_TypeClass aType =
+        cpp_mediate( nOffsetAndIndex, (void**)gpreg, (void**)fpreg, sp, (sal_Int64*)nRegReturn);
+
+    switch( aType )
+    {
+        case typelib_TypeClass_VOID:
+	    break;
+        case typelib_TypeClass_BOOLEAN:
+        case typelib_TypeClass_BYTE:
+            __asm__( "lbz 3,%0\n\t" 
+                : : "m" (nRegReturn[0]) );
+            break;
+        case typelib_TypeClass_CHAR:
+        case typelib_TypeClass_UNSIGNED_SHORT:
+            __asm__( "lhz 3,%0\n\t"
+                : : "m" (nRegReturn[0]) );
+            break;
+        case typelib_TypeClass_SHORT:
+            __asm__( "lha 3,%0\n\t"
+                : : "m" (nRegReturn[0]) );
+            break;
+        case typelib_TypeClass_ENUM:
+        case typelib_TypeClass_UNSIGNED_LONG:
+            __asm__( "lwz 3,%0\n\t"
+                : : "m"(nRegReturn[0]) );
+            break;
+        case typelib_TypeClass_LONG:
+            __asm__( "lwa 3,%0\n\t"
+                : : "m"(nRegReturn[0]) );
+            break;
+        case typelib_TypeClass_FLOAT:
+            __asm__( "lfs 1,%0\n\t" 
+                : : "m" (*((float*)nRegReturn)) );
+            break;
+        case typelib_TypeClass_DOUBLE:
+            __asm__( "lfd 1,%0\n\t" 
+                : : "m" (*((double*)nRegReturn)) );
+            break;
+        default:
+            __asm__( "ld 3,%0\n\t" 
+                : : "m" (nRegReturn[0]) );
+            break;
+    }
+}
+
+const int codeSnippetSize = 24;
+
+unsigned char *  codeSnippet( unsigned char * code, sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset, 
+                              bool simpleRetType)
+{
+#ifdef CMC_DEBUG
+    fprintf(stderr,"in codeSnippet functionIndex is %x\n", nFunctionIndex);
+    fprintf(stderr,"in codeSnippet vtableOffset is %x\n", nVtableOffset);
+#endif
+
+    sal_uInt64 nOffsetAndIndex = ( ( (sal_uInt64) nVtableOffset ) << 32 ) | ( (sal_uInt64) nFunctionIndex );
+
+    if ( !simpleRetType )
+        nOffsetAndIndex |= 0x80000000;
+
+    void ** raw = (void **)&code[0];
+    memcpy(raw, (char*) privateSnippetExecutor, 16);
+    raw[2] = (void*) nOffsetAndIndex;
+#ifdef CMC_DEBUG
+    fprintf(stderr, "in: offset/index is %x %x %d, %lx\n", 
+	nFunctionIndex, nVtableOffset, !simpleRetType, raw[2]);
+#endif
+    return (code + codeSnippetSize);
+}
+
+}
+
+void bridges::cpp_uno::shared::VtableFactory::flushCode(unsigned char const * bptr, unsigned char const * eptr)
+{
+    int const lineSize = 32;
+    for (unsigned char const * p = bptr; p < eptr + lineSize; p += lineSize) {
+        __asm__ volatile ("dcbst 0, %0" : : "r"(p) : "memory");
+    }
+    __asm__ volatile ("sync" : : : "memory");
+    for (unsigned char const * p = bptr; p < eptr + lineSize; p += lineSize) {
+        __asm__ volatile ("icbi 0, %0" : : "r"(p) : "memory");
+    }
+    __asm__ volatile ("isync" : : : "memory");
+}
+
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+{
+    return static_cast< Slot * >(block) + 2;
+}
+
+sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
+    sal_Int32 slotCount)
+{
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
+}
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
+}
+
+unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
+    Slot ** slots, unsigned char * code, sal_PtrDiff writetoexecdiff,
+    typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
+{
+     (*slots) -= functionCount;
+     Slot * s = *slots;
+#ifdef CMC_DEBUG
+    fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
+    fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
+#endif
+
+    for (sal_Int32 i = 0; i < type->nMembers; ++i) {
+        typelib_TypeDescription * member = 0;
+        TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
+        OSL_ASSERT(member != 0);
+        switch (member->eTypeClass) {
+        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+            // Getter:
+            (s++)->fn = code + writetoexecdiff;
+            code = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription * >(
+                        member)->pAttributeTypeRef));
+
+            // Setter:
+            if (!reinterpret_cast<
+                typelib_InterfaceAttributeTypeDescription * >(
+                    member)->bReadOnly)
+            {
+                (s++)->fn = code + writetoexecdiff;
+                code = codeSnippet(code, functionOffset++, vtableOffset, true);
+            }
+            break;
+
+        case typelib_TypeClass_INTERFACE_METHOD:
+            (s++)->fn = code + writetoexecdiff;
+            code = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription * >(
+                        member)->pReturnTypeRef));
+            break;
+
+        default:
+            OSL_ASSERT(false);
+            break;
+        }
+        TYPELIB_DANGER_RELEASE(member);
+    }
+    return code;
+}
+
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc64/except.cxx
@@ -0,0 +1,283 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <stdio.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#if OSL_DEBUG_LEVEL > 1
+    char const * start = p;
+#endif
+
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+
+	OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+
+#if OSL_DEBUG_LEVEL > 1
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+
+    Mutex m_mutex;
+	t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
+    if (iRttiFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iRttiFind->second;
+    }
+
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+		::uno_destructData( pExc, pTD, cpp_release );
+		::typelib_typedescription_release( pTD );
+	}
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+        terminate();
+
+	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+
+	// destruct uno exception
+	::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+        terminate();
+    }
+
+	__cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+{
+    OSL_ENSURE( header, "### no exception header!!!" );
+    if (! header)
+        terminate();
+
+	typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
+    if (! pExcTypeDescr)
+        terminate();
+
+    // construct uno exception any
+    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+    ::typelib_typedescription_release( pExcTypeDescr );
+}
+
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc64/makefile.mk
@@ -0,0 +1,75 @@
+#**************************************************************
+#  
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#  
+#    http://www.apache.org/licenses/LICENSE-2.0
+#  
+#  Unless required by applicable law or agreed to in writing,
+#  software distributed under the License is distributed on an
+#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+#  KIND, either express or implied.  See the License for the
+#  specific language governing permissions and limitations
+#  under the License.
+#  
+#**************************************************************
+
+
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)$(CPUNAME)" == "GCCFREEBSDPgcc3POWERPC64"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+# In case someone enabled the non-standard -fomit-frame-pointer which does not
+# work with the .cxx sources in this directory:
+CFLAGSCXX += -fno-omit-frame-pointer
+
+NOOPTFILES= \
+	$(SLO)$/uno2cpp.obj \
+	$(SLO)$/cpp2uno.obj
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+
+SHL1OBJS= $(SLOFILES)
+SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
+
+SHL1STDLIBS= \
+	$(CPPULIB)			\
+	$(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc64/share.hxx
@@ -0,0 +1,92 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+#include "uno/mapping.h"
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+  void dummy_can_throw_anything( char const * );
+
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
+
+namespace ppc64
+{
+	enum ppclimits { MAX_GPR_REGS = 8, MAX_SSE_REGS = 13 };
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ bridges/source/cpp_uno/gcc3_freebsd_powerpc64/uno2cpp.cxx
@@ -0,0 +1,596 @@
+/**************************************************************
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ *************************************************************/
+
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <stdlib.h>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/vtables.hxx"
+
+#include "share.hxx"
+
+#include <stdio.h>
+#include <string.h>
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+void MapReturn(long r3, double dret, typelib_TypeClass eTypeClass, void *pRegisterReturn)
+{
+    switch (eTypeClass)
+    {
+    case typelib_TypeClass_HYPER:
+    case typelib_TypeClass_UNSIGNED_HYPER:
+            *reinterpret_cast<sal_uInt64 *>( pRegisterReturn ) = r3;
+            break;
+    case typelib_TypeClass_LONG:
+    case typelib_TypeClass_UNSIGNED_LONG:
+    case typelib_TypeClass_ENUM:
+            *reinterpret_cast<sal_uInt32 *>( pRegisterReturn ) = r3;
+            break;
+    case typelib_TypeClass_CHAR:
+    case typelib_TypeClass_SHORT:
+    case typelib_TypeClass_UNSIGNED_SHORT:
+            *reinterpret_cast<sal_uInt16 *>( pRegisterReturn ) = (unsigned short)r3;
+            break;
+    case typelib_TypeClass_BOOLEAN:
+    case typelib_TypeClass_BYTE:
+            *reinterpret_cast<sal_uInt8 *>( pRegisterReturn ) = (unsigned char)r3;
+            break;
+    case typelib_TypeClass_FLOAT:
+            *reinterpret_cast<float *>( pRegisterReturn ) = dret;
+	    break;
+    case typelib_TypeClass_DOUBLE:
+            *reinterpret_cast<double *>( pRegisterReturn ) = dret;
+            break;
+    default:
+            break;
+    }
+}
+
+namespace
+{
+//==================================================================================================
+static void callVirtualMethod(void * pThis, sal_uInt32 nVtableIndex, 
+	void * pRegisterReturn, typelib_TypeDescription * pReturnTypeDescr, 
+        sal_uInt64 *pStack, sal_uInt32 nStack,
+        sal_uInt64 *pGPR, sal_uInt32 nGPR,
+        double *pFPR, sal_uInt32 nFPR)
+{
+    // Stack, if used, must be 16-bytes aligned
+    if ( nStack )
+        nStack = ( nStack + 1 ) & ~1;
+
+    // Should not happen, but...
+    if ( nFPR > ppc64::MAX_SSE_REGS )
+        nFPR = ppc64::MAX_SSE_REGS;
+    if ( nGPR > ppc64::MAX_GPR_REGS )
+        nGPR = ppc64::MAX_GPR_REGS;
+
+#ifdef CMC_DEBUG
+        // Let's figure out what is really going on here
+        {
+                fprintf( stderr, "= callVirtualMethod() =\nGPR's (%d): ", nGPR );
+                for ( int i = 0; i < nGPR; ++i )
+                        fprintf( stderr, "0x%lx, ", pGPR[i] );
+                fprintf( stderr, "\nFPR's (%d): ", nFPR );
+                for ( int i = 0; i < nFPR; ++i ) 
+                        fprintf( stderr, "0x%lx (%f), ", pFPR[i], pFPR[i] );
+                fprintf( stderr, "\nStack (%d): ", nStack );
+                for ( int i = 0; i < nStack; ++i )
+                        fprintf( stderr, "0x%lx, ", pStack[i] );
+                fprintf( stderr, "\n" );
+        }
+#endif
+
+    // Load parameters to stack, if necessary
+    sal_uInt64 *stack = (sal_uInt64 *) __builtin_alloca( nStack * 8 );
+    memcpy( stack, pStack, nStack * 8 );
+
+    // Get pointer to method
+    sal_uInt64 pMethod = *((sal_uInt64 *)pThis);
+    pMethod += 8 * nVtableIndex;
+    pMethod = *((sal_uInt64 *)pMethod);
+
+    typedef void (* FunctionCall )( sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64 );
+    FunctionCall pFunc = (FunctionCall)pMethod;
+
+    volatile double dret;
+
+    //  fill registers
+    __asm__ __volatile__ (
+                "ld   3,  0(%0)\n\t"
+                "ld   4,  8(%0)\n\t"
+                "ld   5, 16(%0)\n\t"
+                "ld   6, 24(%0)\n\t"
+                "ld   7, 32(%0)\n\t"
+                "ld   8, 40(%0)\n\t"
+                "ld   9, 48(%0)\n\t"
+                "ld  10, 56(%0)\n\t"
+                "lfd  1,  0(%1)\n\t"
+                "lfd  2,  8(%1)\n\t"
+                "lfd  3, 16(%1)\n\t"
+                "lfd  4, 24(%1)\n\t"
+                "lfd  5, 32(%1)\n\t"
+                "lfd  6, 40(%1)\n\t"
+                "lfd  7, 48(%1)\n\t"
+                "lfd  8, 56(%1)\n\t"
+                "lfd  9, 64(%1)\n\t"
+                "lfd 10, 72(%1)\n\t"
+                "lfd 11, 80(%1)\n\t"
+                "lfd 12, 88(%1)\n\t"
+                "lfd 13, 96(%1)\n\t"
+                : : "r" (pGPR), "r" (pFPR)
+          	: "r0", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10",
+                  "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7", "fr8", "fr9",
+                  "fr10", "fr11", "fr12", "fr13"
+    );
+
+    // tell gcc that r3 to r11 are not available to it for doing the TOC and exception munge on the func call
+    register sal_uInt64 r3 asm("r3");
+    register sal_uInt64 r4 asm("r4");
+    register sal_uInt64 r5 asm("r5");
+    register sal_uInt64 r6 asm("r6");
+    register sal_uInt64 r7 asm("r7");
+    register sal_uInt64 r8 asm("r8");
+    register sal_uInt64 r9 asm("r9");
+    register sal_uInt64 r10 asm("r10");
+    register sal_uInt64 r11 asm("r11");
+
+    (*pFunc)(r3, r4, r5, r6, r7, r8, r9, r10);
+
+    // get return value
+    __asm__ __volatile__ (
+                "mr     %1,     3\n\t"
+                "mr     %2,     4\n\t"
+                "fmr    %0,     1\n\t"
+                : "=f" (dret), "=r" (r3), "=r" (r4) : );
+
+    MapReturn(r3, dret, pReturnTypeDescr->eTypeClass, pRegisterReturn);
+}
+
+// Macros for easier insertion of values to registers or stack
+// pSV - pointer to the source
+// nr - order of the value [will be increased if stored to register]
+// pFPR, pGPR - pointer to the registers
+// pDS - pointer to the stack [will be increased if stored here]
+
+// The value in %xmm register is already prepared to be retrieved as a float,
+// thus we treat float and double the same
+#define INSERT_FLOAT( pSV, nr, pFPR, pDS, bOverflow ) \
+        if ( nr < ppc64::MAX_SSE_REGS ) \
+                pFPR[nr++] = *reinterpret_cast<float *>( pSV ); \
+        else \
+        	bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); // verbatim!
+
+#define INSERT_DOUBLE( pSV, nr, pFPR, pDS, bOverflow ) \
+        if ( nr < ppc64::MAX_SSE_REGS ) \
+                pFPR[nr++] = *reinterpret_cast<double *>( pSV ); \
+        else \
+        	bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); // verbatim!
+
+#define INSERT_INT64( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ppc64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt64 *>( pSV ); \
+        else \
+		bOverFlow = true; \
+	if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV );
+
+#define INSERT_INT32( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ppc64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
+        else \
+                bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV );
+
+#define INSERT_INT16( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ppc64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt16 *>( pSV ); \
+        else \
+                bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV );
+
+#define INSERT_INT8( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ppc64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt8 *>( pSV ); \
+        else \
+                bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV );
+
+//================================================================================================== 
+static void cpp_call(
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::VtableSlot  aVtableSlot,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	sal_uInt64 * pStack = (sal_uInt64 *)alloca( (nParams+3) * sizeof(sal_Int64) );
+  	sal_uInt64 * pStackStart = pStack;
+
+	sal_uInt64 pGPR[ppc64::MAX_GPR_REGS];
+	sal_uInt32 nGPR = 0;
+
+	double pFPR[ppc64::MAX_SSE_REGS];
+	sal_uInt32 nFPR = 0;
+	
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+
+        bool bOverFlow = false;
+
+	if (pReturnTypeDescr)
+	{
+#ifdef CMC_DEBUG
+		fprintf(stderr, "return type is %d\n", pReturnTypeDescr->eTypeClass);
+#endif
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+#ifdef CMC_DEBUG
+			fprintf(stderr, "simple return\n");
+#endif
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+			       ? alloca( pReturnTypeDescr->nSize ) : pUnoReturn);
+#ifdef CMC_DEBUG
+			fprintf(stderr, "pCppReturn/pUnoReturn is %lx/%lx", pCppReturn, pUnoReturn);
+#endif
+			INSERT_INT64( &pCppReturn, nGPR, pGPR, pStack, bOverFlow );
+		}
+	}
+	// push "this" pointer
+        void * pAdjustedThisPtr = reinterpret_cast< void ** >( pThis->getCppI() ) + aVtableSlot.offset;
+#ifdef CMC_DEBUG
+	fprintf(stderr, "this pointer is %p\n", pAdjustedThisPtr);
+#endif
+	INSERT_INT64( &pAdjustedThisPtr, nGPR, pGPR, pStack, bOverFlow );
+
+        // Args 
+        void ** pCppArgs = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "n params is %d\n", nParams);
+#endif
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+#ifdef CMC_DEBUG
+		fprintf(stderr, "param %d is %d %d %d\n", nPos, rParam.bOut, bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ),
+			pParamTypeDescr->eTypeClass);
+#endif
+		
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
+		{
+//			uno_copyAndConvertData( pCppArgs[nPos] = alloca( 8 ), pUnoArgs[nPos], pParamTypeDescr,
+			uno_copyAndConvertData( pCppArgs[nPos] = pStack, pUnoArgs[nPos], pParamTypeDescr,
+									pThis->getBridge()->getUno2Cpp() );
+		        switch (pParamTypeDescr->eTypeClass)
+                        {
+                        case typelib_TypeClass_HYPER:
+                        case typelib_TypeClass_UNSIGNED_HYPER:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "hyper is %lx\n", pCppArgs[nPos]);
+#endif
+                                INSERT_INT64( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_LONG:
+                        case typelib_TypeClass_UNSIGNED_LONG:
+                        case typelib_TypeClass_ENUM:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "long is %x\n", pCppArgs[nPos]);
+#endif
+                                INSERT_INT32( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_SHORT:
+                        case typelib_TypeClass_CHAR:
+                        case typelib_TypeClass_UNSIGNED_SHORT:
+                                INSERT_INT16( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_BOOLEAN:
+                        case typelib_TypeClass_BYTE:
+                                INSERT_INT8( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_FLOAT:
+                                INSERT_FLOAT( pCppArgs[nPos], nFPR, pFPR, pStack, bOverFlow );
+				break;
+                        case typelib_TypeClass_DOUBLE:
+                                INSERT_DOUBLE( pCppArgs[nPos], nFPR, pFPR, pStack, bOverFlow );
+                                break;
+                        }
+
+                        // no longer needed
+                        TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+	
+		}
+		else // ptr to complex value | ref
+		{
+#ifdef CMC_DEBUG
+			fprintf(stderr, "complex type again %d\n", rParam.bIn);
+#endif
+                        if (! rParam.bIn) // is pure out
+                        {
+#ifdef CMC_DEBUG
+				fprintf(stderr, "complex size is %d\n", pParamTypeDescr->nSize );
+#endif
+                                // cpp out is constructed mem, uno out is not!
+                                uno_constructData(
+                                        pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                                        pParamTypeDescr ); 
+                                pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+                                // will be released at reconversion
+                                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+                        }
+                        // is in/inout
+                        else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+                        {
+#ifdef CMC_DEBUG
+				fprintf(stderr, "this one\n");
+#endif
+                                uno_copyAndConvertData(
+                                        pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                                        pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
+
+                                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+                                // will be released at reconversion
+                                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+                        }
+                        else // direct way
+                        {
+#ifdef CMC_DEBUG
+				fprintf(stderr, "that one, passing %lx through\n", pUnoArgs[nPos]);
+#endif
+                                pCppArgs[nPos] = pUnoArgs[nPos];
+                                // no longer needed
+                                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+                        }
+                        INSERT_INT64( &(pCppArgs[nPos]), nGPR, pGPR, pStack, bOverFlow );
+		}
+	}
+  
+	try
+	{
+               callVirtualMethod(
+                        pAdjustedThisPtr, aVtableSlot.index,
+                        pCppReturn, pReturnTypeDescr, 
+                        pStackStart, ( pStack - pStackStart ),
+                        pGPR, nGPR,
+                        pFPR, nFPR );
+		// NO exception occurred...
+		*ppUnoExc = 0;
+		
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											pThis->getBridge()->getCpp2Uno() );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									pThis->getBridge()->getCpp2Uno() );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch (...)
+ 	{
+  		// fill uno exception
+		fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, 
+                                  *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
+        
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+}
+
+namespace bridges { namespace cpp_uno { namespace shared {
+
+void unoInterfaceProxyDispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException )
+{
+	// is my surrogate
+        bridges::cpp_uno::shared::UnoInterfaceProxy * pThis 
+            = static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy *> (pUnoI);
+	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription const * >(
+                        pMemberDescr)));
+
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, aVtableSlot,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+                        aVtableSlot.index += 1; //get then set method
+			cpp_call(
+				pThis, aVtableSlot,
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription const * >(
+                        pMemberDescr)));
+		switch (aVtableSlot.index)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->getUnoEnv()->getRegisteredInterface)(
+                    pThis->pBridge->getUnoEnv(),
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, aVtableSlot,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+} } }
--- desktop/source/deployment/misc/dp_platform.cxx.orig
+++ desktop/source/deployment/misc/dp_platform.cxx
@@ -56,6 +56,8 @@
 #define PLATFORM_SOLARIS_SPARC      "solaris_sparc"
 #define PLATFORM_SOLARIS_SPARC64    "solaris_sparc64"
 #define PLATFORM_SOLARIS_X86        "solaris_x86"
+#define PLATFORM_FREEBSD_POWERPC    "freebsd_powerpc"
+#define PLATFORM_FREEBSD_POWERPC64  "freebsd_powerpc64"
 #define PLATFORM_FREEBSD_X86        "freebsd_x86"
 #define PLATFORM_FREEBSD_X86_64     "freebsd_x86_64"
 #define PLATFORM_MACOSX_X86         "macosx_x86"
@@ -164,6 +166,10 @@
             ret = checkOSandCPU(OUSTR("Solaris"), OUSTR("SPARC64"));
         else if (token.equals(OUSTR(PLATFORM_SOLARIS_X86)))
             ret = checkOSandCPU(OUSTR("Solaris"), OUSTR("x86"));
+        else if (token.equals(OUSTR(PLATFORM_FREEBSD_POWERPC)))
+            ret = checkOSandCPU(OUSTR("FreeBSD"), OUSTR("PowerPC"));
+        else if (token.equals(OUSTR(PLATFORM_FREEBSD_POWERPC64)))
+            ret = checkOSandCPU(OUSTR("FreeBSD"), OUSTR("PowerPC64"));
         else if (token.equals(OUSTR(PLATFORM_FREEBSD_X86)))
             ret = checkOSandCPU(OUSTR("FreeBSD"), OUSTR("x86"));
         else if (token.equals(OUSTR(PLATFORM_FREEBSD_X86_64)))
--- odk/settings/platform.mk.orig
+++ odk/settings/platform.mk
@@ -34,6 +34,9 @@
 	ifeq "$(UNOPKG_PLATFORM)" "Linux_PowerPC"
 		EXTENSION_PLATFORM=linux_powerpc
 	else
+	ifeq "$(UNOPKG_PLATFORM)" "FreeBSD_PowerPC64"
+		EXTENSION_PLATFORM=freebsd_powerpc64
+	else
 	ifeq "$(UNOPKG_PLATFORM)" "Linux_x86"
 		EXTENSION_PLATFORM=linux_x86
 	else
--- odk/settings/settings.mk.orig
+++ odk/settings/settings.mk
@@ -507,12 +507,19 @@
 else
 UNOPKG_PLATFORM=FreeBSD_x86
 endif
+ifeq "$(PROCTYPE)" "powerpc"
+UNOPKG_PLATFORM=FreeBSD_ppc
+endif
 endif
 
 ifeq "$(PROCTYPE)" "x86_64"
 JAVA_PROC_TYPE=amd64
 else
 JAVA_PROC_TYPE=i386
+endif
+
+ifeq "$(PROCTYPE)" "powerpc64"
+JAVA_PROC_TYPE=ppc64
 endif
 
 ifeq (kfreebsd,$(findstring kfreebsd,$(PLATFORM)))
--- sal/inc/osl/endian.h.orig
+++ sal/inc/osl/endian.h
@@ -73,15 +73,13 @@
 #ifdef FREEBSD
 #   include <sys/param.h>
 #   include <machine/endian.h>
-#if __FreeBSD_version < 500000
-#   if BYTE_ORDER == LITTLE_ENDIAN
-#   	define _LITTLE_ENDIAN
-#   elif BYTE_ORDER == BIG_ENDIAN
-#   	define _BIG_ENDIAN
-#   elif BYTE_ORDER == PDP_ENDIAN
-#   	define _PDP_ENDIAN
-#   endif
-#endif
+#   if BYTE_ORDER == LITTLE_ENDIAN
+#   	undef _BIG_ENDIAN
+#   elif BYTE_ORDER == BIG_ENDIAN
+#   	undef _LITTLE_ENDIAN
+#   elif BYTE_ORDER == PDP_ENDIAN
+#   	define _PDP_ENDIAN
+#   endif
 #endif
 
 #ifdef SCO
--- sal/osl/unx/system.h.orig
+++ sal/osl/unx/system.h
@@ -39,6 +39,7 @@
 
 #include <pwd.h>
 
+#include <osl/endian.h>
 #include <netdb.h>
 
 #include <sys/stat.h>
@@ -176,15 +177,13 @@
 #   include <netinet/tcp.h>
 #	define 	IORESOURCE_TRANSFER_BSD 
 #   include <machine/endian.h>
-#if __FreeBSD_version < 500000
 #   if BYTE_ORDER == LITTLE_ENDIAN
-#   	define _LITTLE_ENDIAN
+#   	undef _BIG_ENDIAN
 #   elif BYTE_ORDER == BIG_ENDIAN
-#   	define _BIG_ENDIAN
+#   	undef _LITTLE_ENDIAN
 #   elif BYTE_ORDER == PDP_ENDIAN
 #   	define _PDP_ENDIAN
 #   endif
-#endif
 #	define  NO_PTHREAD_RTL
 #endif
 
--- set_soenv.in
+++ set_soenv.in
@@ -396,6 +396,26 @@
       $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386";
       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386".$ds."client";
       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."i386".$ds."native_threads";
+   }
+   elsif (($platform =~ m/^powerpc64/) && ('@SIZEOF_LONG@' eq '8'))
+   {  print "Setting FreeBSD PPC64 specific values... ";
+      $outfile        = "FreeBSDPPC64Env.Set"; 
+      $CPU            = "P";
+      $CPUNAME        = "POWERPC64";
+      $OUTPATH        = "unxfbsdp";
+      $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc64";
+      $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc64".$ds."server";
+      $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc64".$ds."native_threads";
+   }
+   elsif ($platform =~ m/powerpc/)
+   {  print "Setting FreeBSD PPC specific values... ";
+      $outfile        = "FreeBSDPPCEnv.Set"; 
+      $CPU            = "P";
+      $CPUNAME        = "POWERPC";
+      $OUTPATH        = "unxfbsdp";
+      $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc";
+      $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc".$ds."server";
+      $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc".$ds."native_threads";
    }
    else
    {  print "Unsupported FreeBSD architecture: $platform \n";
--- solenv/gbuild/platform/freebsd.mk.orig
+++ solenv/gbuild/platform/freebsd.mk
@@ -36,6 +36,10 @@
 CPUNAME := X86_64
 endif
 
+ifeq ($(CPU),P)
+CPUNAME := POWERPC64
+endif
+
 # use CC/CXX if they are nondefaults
 ifneq ($(origin CC),default)
 gb_CC := $(CC)
@@ -66,6 +70,12 @@
 gb_CPUDEFS := -D$(CPUNAME)
 else
 gb_CPUDEFS := -DX86
+endif
+
+ifeq ($(CPUNAME),POWERPC64)
+gb_CPUDEFS := -D$(CPUNAME)
+else
+gb_CPUDEFS := -DPOWERPC64
 endif
 
 gb_CFLAGS := \
--- solenv/inc/libs.mk.orig
+++ solenv/inc/libs.mk
@@ -236,6 +236,9 @@
 NEON3RDLIB=$(SOLARLIBDIR)/libneon.dylib
 .ELSE
 NEON3RDLIB=-lneon
+.ENDIF
+.IF "$(OS)" == "FREEBSD" && "$(CPUNAME)" == "POWERPC64"
+JPEG3RDLIB=/usr/local/lib/libjpeg.so
 .ENDIF
 CURLLIB=-lcurl
 SFX2LIB=-lsfx$(DLLPOSTFIX)
--- solenv/inc/unx.mk.orig
+++ solenv/inc/unx.mk
@@ -93,6 +93,10 @@
 
 .IF "$(COM)$(OS)$(CPU)$(CPUNAME)" == "GCCLINUXPPOWERPC64"
 .INCLUDE : unxlngppc64.mk
+.ENDIF
+
+.IF "$(COM)$(OS)$(CPU)$(CPUNAME)" == "GCCFREEBSDPPOWERPC64"
+.INCLUDE : unxfbsdp.mk
 .ENDIF
 
 .IF "$(COM)$(OS)$(CPU)$(CPUNAME)" == "GCCLINUX3S390"
--- solenv/inc/unxfbsd.mk.orig
+++ solenv/inc/unxfbsd.mk
@@ -36,6 +36,9 @@
 .ENDIF
 .IF "$(CPUNAME)" == "X86_64"
 .INCLUDE : unxfbsdx.mk
+.ENDIF
+.IF "$(CPUNAME)" == "POWERPC64"
+.INCLUDE : unxfbsdp.mk
 .ENDIF
 
 # filter for supressing verbose messages from linker
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ solenv/inc/unxfbsdp.mk
@@ -0,0 +1,42 @@
+#**************************************************************
+#  
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#  
+#    http://www.apache.org/licenses/LICENSE-2.0
+#  
+#  Unless required by applicable law or agreed to in writing,
+#  software distributed under the License is distributed on an
+#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+#  KIND, either express or implied.  See the License for the
+#  specific language governing permissions and limitations
+#  under the License.
+#  
+#**************************************************************
+
+
+
+#
+# FreeBSD/ppc64 specific defines
+#
+
+DEFAULTOPT=-Os
+PICSWITCH:=-fPIC
+CDEFS+=-DPOWERPC64 -DPOWERPC -DPPC
+CFLAGSCXX+=-mminimal-toc
+
+# Compiler flags for enabling optimizations
+.IF "$(PRODUCT)"!=""
+CFLAGSOPT=-O2 -fno-strict-aliasing		# optimizing for products
+.ELSE 	# "$(PRODUCT)"!=""
+CFLAGSOPT=   					# no optimizing for non products
+.ENDIF	# "$(PRODUCT)"!=""
+
+# platform specific identifier for shared libs
+DLLPOSTFIX=
+BUILD64=1
--- testtools/source/bridgetest/makefile.mk.orig
+++ testtools/source/bridgetest/makefile.mk
@@ -134,7 +134,7 @@
 
 runtest : $(DLLDEST)$/uno_types.rdb $(DLLDEST)$/uno_services.rdb makefile.mk \
         $(SHL1TARGETN) $(SHL2TARGETN) $(SHL3TARGETN)
-.IF "$(COM)$(OS)$(CPU)" == "GCCMACOSXP" || "$(OS)$(CPU)"=="SOLARISS"
+.IF "$(COM)$(OS)$(CPU)" == "GCCMACOSXP" || "$(OS)$(CPU)"=="SOLARISS" || "$(COM)$(OS)$(CPU)"=="GCCFREEBSDP"
 	@echo "Mac OSX PPC GCC and Solaris fails this test! likely broken UNO bridge. Fix me."
 .ELSE
         cd $(DLLDEST) && $(AUGMENT_LIBRARY_PATH) $(SOLARBINDIR)/uno \
