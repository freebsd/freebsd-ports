--- /dev/null	Mon Mar  4 21:33:00 2002
+++ bridges/source/cpp_uno/gcc3_freebsd_intel/cpp2uno.cxx	Mon Mar  4 21:23:27 2002
@@ -0,0 +1,594 @@
+/*************************************************************************
+ *
+ *  $RCSfile: cpp2uno.cxx,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: dbo $ $Date: 2001/10/26 07:22:57 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <stdlib.h>
+#include <hash_map>
+
+#include <rtl/alloc.h>
+#include <osl/mutex.hxx>
+
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include <bridges/cpp_uno/bridge.hxx>
+#include <bridges/cpp_uno/type_misc.hxx>
+
+#include "share.hxx"
+
+
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+//==================================================================================================
+rtl_StandardModuleCount g_moduleCount = MODULE_COUNT_INIT;
+
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	cppu_cppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	// pCallStack: ret, [return ptr], this, params
+	char * pCppStack = (char *)(pCallStack +1);
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+		}
+		else // complex return via ptr (pCppReturn)
+		{
+			pCppReturn = *(void **)pCppStack;
+			pCppStack += sizeof(void *);
+			
+			pUnoReturn = (cppu_relatesToInterface( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+	}
+	// pop this
+	pCppStack += sizeof( void* );
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr )) // value
+		{
+			pCppArgs[nPos] = pCppStack;
+			pUnoArgs[nPos] = pCppStack;
+			switch (pParamTypeDescr->eTypeClass)
+			{
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			case typelib_TypeClass_DOUBLE:
+				pCppStack += sizeof(sal_Int32); // extra long
+			}
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			pCppArgs[nPos] = *(void **)pCppStack;
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										*(void **)pCppStack, pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = *(void **)pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->pUnoI->pDispatcher)( pThis->pUnoI, pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	
+	// in case an exception occured...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		raiseException( &aUnoExc, &pThis->pBridge->aUno2Cpp ); // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occured...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to eax
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_Int32 nVtableCall,
+	void ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
+	
+	// pCallStack: ret adr, [ret *], this, params
+	// _this_ ptr is patched cppu_XInterfaceProxy object
+	cppu_cppInterfaceProxy * pCppI = NULL;
+	if( nVtableCall & 0x80000000 )
+	{
+		nVtableCall &= 0x7fffffff;
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(pCallStack +2);
+	}
+	else
+    {
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(pCallStack +1);
+    }
+    
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->pTypeDescr;
+	
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	if (nVtableCall >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException(
+            OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pCppI );
+	}
+	
+	// determine called method
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nVtableCall];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+    
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nVtableCall)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				pCallStack, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				pCallStack, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nVtableCall)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pCallStack[3] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->pBridge->pCppEnv->getRegisteredInterface)(
+                    pCppI->pBridge->pCppEnv,
+                    (void **)&pInterface, pCppI->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pCallStack[1] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = pCallStack[1];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				pCallStack, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+		throw RuntimeException(
+            OUString::createFromAscii("no member description found!"),
+            (XInterface *)pCppI );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+	return eRet;
+}
+
+//==================================================================================================
+/**
+ * is called on incoming vtable calls
+ * (called by asm snippets)
+ */
+static void cpp_vtable_call( int nTableEntry, void** pCallStack ) __attribute__((regparm(2)));
+
+void cpp_vtable_call( int nTableEntry, void** pCallStack )
+{
+	volatile long nRegReturn[2];
+	typelib_TypeClass aType = cpp_mediate( nTableEntry, pCallStack, (sal_Int64*)nRegReturn );
+    
+	switch( aType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+			__asm__( "movl %1, %%edx\n\t"
+					 "movl %0, %%eax\n"
+					 : : "m"(nRegReturn[0]), "m"(nRegReturn[1]) );
+			break;
+		case typelib_TypeClass_FLOAT:
+			__asm__( "flds %0\n\t"
+					 "fstp %%st(0)\n\t"
+					 "flds %0\n"
+					 : : "m"(*(float *)nRegReturn) );
+			break;
+		case typelib_TypeClass_DOUBLE:
+			__asm__( "fldl %0\n\t"
+					 "fstp %%st(0)\n\t"
+					 "fldl %0\n"
+					 : : "m"(*(double *)nRegReturn) );
+			break;
+// 		case typelib_TypeClass_UNSIGNED_SHORT:
+// 		case typelib_TypeClass_SHORT:
+// 			__asm__( "movswl %0, %%eax\n"
+// 					 : : "m"(nRegReturn) );
+// 		break;
+		default:
+			__asm__( "movl %0, %%eax\n"
+					 : : "m"(nRegReturn[0]) );
+			break;
+	}
+}
+
+
+//==================================================================================================
+class MediateClassData
+{
+    typedef ::std::hash_map< OUString, void *, OUStringHash > t_classdata_map;
+	t_classdata_map m_map;
+	Mutex m_mutex;
+    
+public:
+	void const * get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () );
+    
+	inline MediateClassData() SAL_THROW( () )
+        {}
+	~MediateClassData() SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+MediateClassData::~MediateClassData() SAL_THROW( () )
+{
+	OSL_TRACE( "> calling ~MediateClassData(): freeing mediate vtables." );
+	
+	for ( t_classdata_map::const_iterator iPos( m_map.begin() ); iPos != m_map.end(); ++iPos )
+	{
+		::rtl_freeMemory( iPos->second );
+	}
+}
+//--------------------------------------------------------------------------------------------------
+static inline void codeSnippet( char * code, sal_uInt32 vtable_pos, bool simple_ret_type ) SAL_THROW( () )
+{
+    if (! simple_ret_type)
+        vtable_pos |= 0x80000000;
+    OSL_ASSERT( sizeof (long) == 4 );
+    // mov $nPos, %eax
+    *code++ = 0xb8;
+    *(long *)code = vtable_pos;
+    code += sizeof (long);
+    // mov %esp, %edx
+    *code++ = 0x89;
+    *code++ = 0xe2;
+    // jmp cpp_vtable_call
+    *code++ = 0xe9;
+    *(long *)code = ((char *)cpp_vtable_call) - code - sizeof (long);
+}
+//__________________________________________________________________________________________________
+void const * MediateClassData::get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () )
+{
+    void * buffer;
+    
+    // avoiding locked counts
+    OUString const & unoName = *(OUString const *)&((typelib_TypeDescription *)pTD)->pTypeName;
+    {
+	MutexGuard aGuard( m_mutex );
+	t_classdata_map::const_iterator iFind( m_map.find( unoName ) );
+	if (iFind == m_map.end())
+    {
+        // create new vtable
+        sal_Int32 nSlots = pTD->nMapFunctionIndexToMemberIndex;
+        buffer = ::rtl_allocateMemory( ((2+ nSlots) * sizeof (void *)) + (nSlots *20) );
+        
+        ::std::pair< t_classdata_map::iterator, bool > insertion(
+            m_map.insert( t_classdata_map::value_type( unoName, buffer ) ) );
+        OSL_ENSURE( insertion.second, "### inserting new vtable buffer failed?!" );
+        
+        void ** slots = (void **)buffer;
+        *slots++ = 0;
+        *slots++ = 0; // rtti
+        char * code = (char *)(slots + nSlots);
+        
+        sal_uInt32 vtable_pos = 0;
+        sal_Int32 nAllMembers = pTD->nAllMembers;
+        typelib_TypeDescriptionReference ** ppAllMembers = pTD->ppAllMembers;
+        for ( sal_Int32 nPos = 0; nPos < nAllMembers; ++nPos )
+        {
+            typelib_TypeDescription * pTD = 0;
+            TYPELIB_DANGER_GET( &pTD, ppAllMembers[ nPos ] );
+            OSL_ASSERT( pTD );
+            if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
+            {
+                bool simple_ret = cppu_isSimpleType(
+                    ((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
+                // get method
+                *slots++ = code;
+                codeSnippet( code, vtable_pos++, simple_ret );
+                code += 20;
+                if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
+                {
+                    // set method
+                    *slots++ = code;
+                    codeSnippet( code, vtable_pos++, true );
+                    code += 20;
+                }
+            }
+            else
+            {
+                bool simple_ret = cppu_isSimpleType(
+                    ((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
+                *slots++ = code;
+                codeSnippet( code, vtable_pos++, simple_ret );
+                code += 20;
+            }
+            TYPELIB_DANGER_RELEASE( pTD );
+        }
+        OSL_ASSERT( vtable_pos == nSlots );
+    }
+    else
+    {
+        buffer = iFind->second;
+    }
+    }
+    
+    return ((void **)buffer +2);
+}
+
+//==================================================================================================
+void SAL_CALL cppu_cppInterfaceProxy_patchVtable(
+	XInterface * pCppI, typelib_InterfaceTypeDescription * pTypeDescr ) throw ()
+{
+	static MediateClassData * s_pMediateClassData = 0;
+	if (! s_pMediateClassData)
+	{
+		MutexGuard aGuard( Mutex::getGlobalMutex() );
+		if (! s_pMediateClassData)
+		{
+#ifdef LEAK_STATIC_DATA
+			s_pMediateClassData = new MediateClassData();
+#else
+			static MediateClassData s_aMediateClassData;
+			s_pMediateClassData = &s_aMediateClassData;
+#endif
+		}
+	}
+	*(void const **)pCppI = s_pMediateClassData->get_vtable( pTypeDescr );
+}
+
+}
+
+extern "C"
+{
+//##################################################################################################
+sal_Bool SAL_CALL component_canUnload( TimeValue * pTime )
+	SAL_THROW_EXTERN_C()
+{
+	return CPPU_CURRENT_NAMESPACE::g_moduleCount.canUnload(
+        &CPPU_CURRENT_NAMESPACE::g_moduleCount, pTime );
+}
+//##################################################################################################
+void SAL_CALL uno_initEnvironment( uno_Environment * pCppEnv )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_cppenv_initEnvironment(
+        pCppEnv );
+}
+//##################################################################################################
+void SAL_CALL uno_ext_getMapping(
+	uno_Mapping ** ppMapping, uno_Environment * pFrom, uno_Environment * pTo )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_ext_getMapping(
+        ppMapping, pFrom, pTo );
+}
+}
--- /dev/null	Mon Mar  4 21:33:00 2002
+++ bridges/source/cpp_uno/gcc3_freebsd_intel/except.cxx	Mon Mar  4 21:23:27 2002
@@ -0,0 +1,317 @@
+/*************************************************************************
+ *
+ *  $RCSfile: except.cxx,v $
+ *
+ *  $Revision: 1.6 $
+ *
+ *  last change: $Author: dbo $ $Date: 2001/11/08 12:35:28 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <bridges/cpp_uno/bridge.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+    
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#ifdef DEBUG
+    char const * start = p;
+#endif
+    
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+    
+	OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+    
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+    
+#ifdef DEBUG
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+    
+    Mutex m_mutex;
+	t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+    
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+    
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+    
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+    
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iFind( m_rttis.find( unoName ) );
+    if (iFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+        
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#ifdef DEBUG
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+                
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iFind->second;
+    }
+    
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+		::uno_destructData( pExc, pTD, cpp_release );
+		::typelib_typedescription_release( pTD );
+	}
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+        terminate();
+    
+	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+	
+	// destruct uno exception
+	::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+        terminate();
+    }
+    
+	__cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+{
+    OSL_ENSURE( header, "### no exception header!!!" );
+    if (! header)
+        terminate();
+    
+	typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
+    if (! pExcTypeDescr)
+        terminate();
+    
+    // construct uno exception any
+    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+    ::typelib_typedescription_release( pExcTypeDescr );
+}
+
+}
+
--- /dev/null	Mon Mar  4 21:33:00 2002
+++ bridges/source/cpp_uno/gcc3_freebsd_intel/makefile.mk	Mon Mar  4 21:24:53 2002
@@ -0,0 +1,112 @@
+#*************************************************************************
+#
+#   $RCSfile: makefile.mk,v $
+#
+#   $Revision: 1.2 $
+#
+#   last change: $Author: dbo $ $Date: 2001/10/26 14:23:30 $
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+NO_BSYMBOLIC=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)" == "GCCFREEBSDIgcc3"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+
+SHL1OBJS= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1STDLIBS= \
+	$(CPPULIB)			\
+	$(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
--- /dev/null	Mon Mar  4 21:33:00 2002
+++ bridges/source/cpp_uno/gcc3_freebsd_intel/share.hxx	Mon Mar  4 21:23:27 2002
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ *  $RCSfile: share.hxx,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: dbo $ $Date: 2001/10/19 13:32:39 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
--- /dev/null	Mon Mar  4 21:33:00 2002
+++ bridges/source/cpp_uno/gcc3_freebsd_intel/uno2cpp.cxx	Mon Mar  4 21:23:27 2002
@@ -0,0 +1,450 @@
+/*************************************************************************
+ *
+ *  $RCSfile: uno2cpp.cxx,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: hr $ $Date: 2001/10/31 14:46:47 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <stdlib.h>
+#include <rtl/alloc.h>
+
+#include <uno/data.h>
+#include <bridges/cpp_uno/bridge.hxx>
+#include <bridges/cpp_uno/type_misc.hxx>
+
+#include "share.hxx"
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * );
+
+//==================================================================================================
+static void callVirtualMethod(
+    void * pThis,
+    sal_Int32 nVtableIndex,
+    void * pRegisterReturn,
+    typelib_TypeClass eReturnType,
+    sal_Int32 * pStackLongs,
+    sal_Int32 nStackLongs )
+{
+	// parameter list is mixed list of * and values
+	// reference parameters are pointers
+    
+	OSL_ENSURE( pStackLongs && pThis, "### null ptr!" );
+	OSL_ENSURE( (sizeof(void *) == 4) && (sizeof(sal_Int32) == 4), "### unexpected size of int!" );
+	OSL_ENSURE( nStackLongs && pStackLongs, "### no stack in callVirtualMethod !" );
+    
+    // never called
+    if (! pThis) dummy_can_throw_anything("xxx"); // address something
+    
+	volatile long edx = 0, eax = 0; // for register returns
+	asm volatile (
+		// copy values
+		"mov   %0, %%eax\n\t"
+		"mov   %%eax, %%edx\n\t"
+		"dec   %%edx\n\t"
+		"shl   $2, %%edx\n\t"
+		"add   %1, %%edx\n"
+		"Lcopy:\n\t"
+		"pushl 0(%%edx)\n\t"
+		"sub   $4, %%edx\n\t"
+		"dec   %%eax\n\t"
+		"jne   Lcopy\n\t"
+		// do the actual call
+		"mov   %2, %%edx\n\t"
+		"mov   0(%%edx), %%edx\n\t"
+		"mov   %3, %%eax\n\t"
+		"shl   $2, %%eax\n\t"
+		"add   %%eax, %%edx\n\t"
+		"mov   0(%%edx), %%edx\n\t"
+		"call  *%%edx\n\t"
+		// save return registers
+ 		"mov   %%eax, %4\n\t"
+ 		"mov   %%edx, %5\n\t"
+		// cleanup stack
+ 		"mov   %0, %%eax\n\t"
+ 		"shl   $2, %%eax\n\t"
+ 		"add   %%eax, %%esp\n\t"
+		:
+        : "m"(nStackLongs), "m"(pStackLongs), "m"(pThis), "m"(nVtableIndex), "m"(eax), "m"(edx)
+        : "eax", "edx" );
+    
+	switch( eReturnType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+			((long*)pRegisterReturn)[1] = edx;
+		case typelib_TypeClass_LONG:
+		case typelib_TypeClass_UNSIGNED_LONG:
+		case typelib_TypeClass_CHAR:
+		case typelib_TypeClass_ENUM:
+			((long*)pRegisterReturn)[0] = eax;
+			break;
+		case typelib_TypeClass_SHORT:
+		case typelib_TypeClass_UNSIGNED_SHORT:
+			*(unsigned short*)pRegisterReturn = eax;
+			break;
+		case typelib_TypeClass_BOOLEAN:
+		case typelib_TypeClass_BYTE:
+			*(unsigned char*)pRegisterReturn = eax;
+			break;
+		case typelib_TypeClass_FLOAT:
+			asm ( "fstps %0" : : "m"(*(char *)pRegisterReturn) );
+			break;
+		case typelib_TypeClass_DOUBLE:
+			asm ( "fstpl %0\n\t" : : "m"(*(char *)pRegisterReturn) );
+			break;
+	}
+}
+
+//================================================================================================== 
+static void cpp_call(
+	cppu_unoInterfaceProxy * pThis,
+	sal_Int32 nVtableCall,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	char * pCppStack		=
+  		(char *)alloca( sizeof(sal_Int32) + ((nParams+2) * sizeof(sal_Int64)) );
+  	char * pCppStackStart	= pCppStack;
+	
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = *(void **)pCppStack = (cppu_relatesToInterface( pReturnTypeDescr )
+												? alloca( pReturnTypeDescr->nSize )
+												: pUnoReturn); // direct way
+			pCppStack += sizeof(void *);
+		}
+	}
+	// push this
+	*(void**)pCppStack = pThis->pCppI;
+	pCppStack += sizeof( void* );
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// args
+	void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+		
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr ))
+		{
+			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
+									&pThis->pBridge->aUno2Cpp );
+			
+			switch (pParamTypeDescr->eTypeClass)
+			{
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			case typelib_TypeClass_DOUBLE:
+				pCppStack += sizeof(sal_Int32); // extra long
+			}
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			if (! rParam.bIn) // is pure out
+			{
+				// cpp out is constructed mem, uno out is not!
+				uno_constructData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pParamTypeDescr );
+				pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pUnoArgs[nPos], pParamTypeDescr, &pThis->pBridge->aUno2Cpp );
+				
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				*(void **)pCppStack = pCppArgs[nPos] = pUnoArgs[nPos];
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+
+	try
+	{
+		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 3), "UNALIGNED STACK !!! (Please DO panic)" );
+		callVirtualMethod(
+			pThis->pCppI, nVtableCall,
+			pCppReturn, pReturnTypeDescr->eTypeClass,
+			(sal_Int32 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_Int32) );
+		// NO exception occured...
+		*ppUnoExc = 0;
+		
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											&pThis->pBridge->aCpp2Uno );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									&pThis->pBridge->aCpp2Uno );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch (...)
+ 	{
+  		// fill uno exception
+		fillUnoException( __cxa_get_globals()->caughtExceptions, *ppUnoExc, &pThis->pBridge->aCpp2Uno );
+        
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+
+//==================================================================================================
+void SAL_CALL cppu_unoInterfaceProxy_dispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException ) throw ()
+{
+	// is my surrogate
+	cppu_unoInterfaceProxy * pThis = (cppu_unoInterfaceProxy *)pUnoI;
+	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall +1, // get, then set method
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		switch (nVtableCall)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->pUnoEnv->getRegisteredInterface)(
+                    pThis->pBridge->pUnoEnv,
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+}
+
