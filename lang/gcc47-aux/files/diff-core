--- gcc/DEV-PHASE.orig
+++ gcc/DEV-PHASE
@@ -0,0 +1 @@
+release
--- gcc/config.gcc.orig
+++ gcc/config.gcc
@@ -581,6 +581,9 @@
     "" | yes | posix)
       thread_file='posix'
       ;;
+    gnat | single)
+      # Let these non-posix thread selections fall through if requested
+      ;;
     *)
       echo 'Unknown thread configuration for FreeBSD'
       exit 1
@@ -597,6 +600,26 @@
   # need_64bit_hwint=yes # system compiler has this for all arch!
   use_gcc_stdint=wrap
   ;;
+*-*-dragonfly*)
+  gas=yes
+  gnu_ld=yes
+  tmake_file="t-slibgcc"
+  case ${enable_threads} in
+    "" | yes | posix)
+      thread_file='posix'
+      ;;
+    no | gnat | single)
+      # Let these non-posix thread selections fall through if requested
+      ;;
+    *)
+      echo 'Unknown thread configuration for DragonFly BSD'
+      exit 1
+      ;;
+  esac
+  extra_options="$extra_options rpath.opt dragonfly.opt"
+  default_use_cxa_atexit=yes
+  use_gcc_stdint=wrap
+  ;;
 *-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu)
   extra_options="$extra_options gnu-user.opt"
   gas=yes
@@ -652,6 +675,7 @@
   esac
   ;;
 *-*-netbsd*)
+  use_gcc_stdint=wrap
   tmake_file="t-slibgcc"
   gas=yes
   gnu_ld=yes
@@ -903,7 +927,35 @@
 	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/rtems-elf.h rtems.h newlib-stdint.h"
 	tmake_file="arm/t-arm arm/t-arm-elf t-rtems arm/t-rtems"
 	;;
-arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-rtems*)
+arm*-android-eabi*)
+	gas=yes
+	gnu_ld=yes
+	case ${enable_threads} in
+	  "" | yes | posix) thread_file='posix' ;;
+	esac
+	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h"
+	tm_file="$tm_file arm/elf.h arm/linux-gas.h arm/linux-elf.h"
+	tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h arm/aout.h arm/arm.h"
+
+	tmake_file="${tmake_file} arm/t-arm arm/t-arm-elf"
+	tmake_file="$tmake_file arm/t-bpabi arm/t-linux-eabi"
+
+	tm_defines="$tm_defines DEFAULT_LIBC=LIBC_BIONIC ANDROID_DEFAULT=1"
+	case $target in
+	arm*b-*)
+	    tm_defines="$tm_defines TARGET_BIG_ENDIAN_DEFAULT=1"
+	    ;;
+	esac
+	extra_options="$extra_options linux.opt linux-android.opt"
+	default_use_cxa_atexit=yes
+	use_gcc_tgmath=no
+	use_gcc_stdint=wrap
+
+	# The BPABI long long divmod functions return a 128-bit value in registers r0-r3.
+	# Correctly modeling that requires the use of TImode.
+	need_64bit_hwint=yes
+	;;
+arm*-*-symbianelf* | arm*-*-rtems*)
 	# The BPABI long long divmod functions return a 128-bit value in
 	# registers r0-r3.  Correctly modeling that requires the use of
 	# TImode.
@@ -912,11 +964,6 @@
 	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/bpabi.h"
 	tmake_file="arm/t-arm arm/t-arm-elf"
 	case ${target} in
-	arm*-*-eabi*)
-	  tm_file="$tm_file newlib-stdint.h"
-	  tmake_file="${tmake_file} arm/t-bpabi"
-	  use_gcc_stdint=wrap
-	  ;;
 	arm*-*-rtems*)
 	  tm_file="${tm_file} rtems.h arm/rtems-eabi.h newlib-stdint.h"
 	  tmake_file="${tmake_file} arm/t-bpabi t-rtems arm/t-rtems-eabi"
@@ -1216,19 +1263,31 @@
 x86_64-*-elf*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
 	;;
+i[34567]86-*-dragonfly*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h dragonfly.h dragonfly-stdint.h i386/dragonfly.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
+x86_64-*-dragonfly*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h dragonfly.h dragonfly-stdint.h i386/x86-64.h i386/dragonfly.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
 i[34567]86-*-freebsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 x86_64-*-freebsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/x86-64.h i386/freebsd.h i386/freebsd64.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 i[34567]86-*-netbsdelf*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h netbsd-stdint.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 x86_64-*-netbsd*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h netbsd-stdint.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])
 	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
@@ -3577,6 +3636,8 @@
 		;;
 	i[34567]86-*-cygwin* | i[34567]86-*-mingw* | x86_64-*-mingw*)
 		;;
+	i[34567]86-*-dragonfly* | x86_64-*-dragonfly*)
+		;;
 	i[34567]86-*-freebsd* | x86_64-*-freebsd*)
 		;;
 	ia64*-*-linux*)
--- /dev/null
+++ gcc/config/dragonfly-stdint.h
@@ -0,0 +1,56 @@
+/* Definitions for <stdint.h> types for DragonFly systems.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Contributed by Gerald Pfeifer <gerald@pfeifer.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE   "int"
+
+#define INT8_TYPE         "signed char"
+#define INT16_TYPE        "short int"
+#define INT32_TYPE        "int"
+#define INT64_TYPE        (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT8_TYPE        "unsigned char"
+#define UINT16_TYPE       "short unsigned int"
+#define UINT32_TYPE       "unsigned int"
+#define UINT64_TYPE       (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_LEAST8_TYPE   INT8_TYPE
+#define INT_LEAST16_TYPE  INT16_TYPE
+#define INT_LEAST32_TYPE  INT32_TYPE
+#define INT_LEAST64_TYPE  INT64_TYPE
+#define UINT_LEAST8_TYPE  UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE    INT32_TYPE
+#define INT_FAST16_TYPE   INT32_TYPE
+#define INT_FAST32_TYPE   INT32_TYPE
+#define INT_FAST64_TYPE   INT64_TYPE
+#define UINT_FAST8_TYPE   UINT32_TYPE
+#define UINT_FAST16_TYPE  UINT32_TYPE
+#define UINT_FAST32_TYPE  UINT32_TYPE
+#define UINT_FAST64_TYPE  UINT64_TYPE
+
+#define INTPTR_TYPE       (LONG_TYPE_SIZE == 64 ?  INT64_TYPE :  INT32_TYPE)
+#define UINTPTR_TYPE      (LONG_TYPE_SIZE == 64 ? UINT64_TYPE : UINT32_TYPE)
--- /dev/null
+++ gcc/config/dragonfly.h
@@ -0,0 +1,136 @@
+/* Base configuration file for all DragonFly targets.
+   Copyright (C) 1999, 2000, 2001, 2007, 2008 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Common DragonFly configuration.
+   All DragonFly architectures should include this file, which will specify
+   their commonalities.
+   Adapted from gcc/config/i386/freebsd-elf.h by
+   David O'Brien <obrien@FreeBSD.org>.
+   Further work by David O'Brien <obrien@FreeBSD.org> and
+   Loren J. Rittle <ljrittle@acm.org>.  */
+
+#undef  TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()            \
+  do                                        \
+    {                                       \
+       builtin_define_std ("unix");         \
+       builtin_define ("__DragonFly__");    \
+       builtin_assert ("system=unix");      \
+       builtin_assert ("system=bsd");       \
+       builtin_assert ("system=DragonFly"); \
+    }                                       \
+  while (0)
+
+#undef  CPP_SPEC
+#define CPP_SPEC \
+ "%(cpp_cpu) %(cpp_arch) %{posix:-D_POSIX_SOURCE}"
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	\
+  "%{!shared: \
+     %{pg:gcrt1.o%s} \
+     %{!pg: \
+       %{p:gcrt1.o%s} \
+       %{!p: \
+         %{profile: gcrt1.o%s} \
+         %{!profile: \
+           %{pie: Scrt1.o%s;:crt1.o%s}}}}} \
+   crti.o%s \
+   %{shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef  LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} -lc"
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "--eh-frame-hdr"
+#endif
+
+/* Provide a LINK_SPEC appropriate for DragonFly.  Here we provide support
+   for the special GCC options -static and -shared, which allow us to
+   link things in one of these three modes by applying the appropriate
+   combinations of options at link-time.
+
+   When the -shared link option is used a final link is not being
+   done.  */
+
+#define DFBSD_LINK_SPEC \
+ "%{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
+  %{v:-V} \
+  %{assert*} %{R*} %{rpath*} %{defsym*} \
+  %{shared:-Bshareable %{h*} %{soname*}} \
+  %{!shared: \
+   %{!static: \
+    %{rdynamic:-export-dynamic} \
+    -dynamic-linker %(dfbsd_dynamic_linker) \
+   } \
+   %{static:-Bstatic} \
+  } \
+  %{!static:--hash-style=both -rpath @PREFIX@/gcc-aux/lib} \
+  %{symbolic:-Bsymbolic}"
+
+#undef  LINK_SPEC
+#define LINK_SPEC DFBSD_LINK_SPEC
+
+#define DFBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.2"
+
+
+/* Use --as-needed -lgcc_s for eh support.  */
+#ifdef HAVE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 1
+#endif
+
+/************************[  Target stuff  ]***********************************/
+
+/* All DragonFly Architectures support the ELF object file format.  */
+#undef  OBJECT_FORMAT_ELF
+#define OBJECT_FORMAT_ELF
+
+/* Don't assume anything about the header files.  */
+#undef  NO_IMPLICIT_EXTERN_C
+#define NO_IMPLICIT_EXTERN_C	1
+
+/* Follow DragonFly's standard headers (<machine/stdint.h>, etc...).  */
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef  WINT_TYPE
+#define WINT_TYPE "int"
+
+/* 
+ * Profile libraries are found at /usr/lib/profile with standard names
+ * #define MATH_LIBRARY_PROFILE    "m_p" 
+ */
+
+/* Code generation parameters.  */
+
+/* Use periods rather than dollar signs in special g++ assembler names.
+   This ensures the configuration knows our system correctly so we can link
+   with libraries compiled with the native cc.  */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Used by libgcc2.c.  We support file locking with fcntl / F_SETLKW.
+   This enables the test coverage code to use file locking when exiting a
+   program, which avoids race conditions if the program has forked.  */
+#define TARGET_POSIX_IO
--- /dev/null
+++ gcc/config/dragonfly.opt
@@ -0,0 +1,65 @@
+; DragonFlyBSD options.
+
+; Copyright (C) 2010, 2011
+; Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+; See the GCC internals manual (options.texi) for a description of this file's format.
+
+; Please try to keep this file in ASCII collating order.
+
+assert
+Driver Separate
+
+assert=
+Driver JoinedOrMissing
+
+defsym
+Driver Separate
+
+defsym=
+Driver JoinedOrMissing
+
+posix
+Driver
+
+profile
+Driver
+
+pthread
+Driver
+
+rdynamic
+Driver
+
+rpath-link
+Driver Separate
+
+rpath-link=
+Driver JoinedOrMissing
+
+rpath=
+Driver JoinedOrMissing
+
+soname
+Driver Separate
+
+soname=
+Driver JoinedOrMissing
+
+; This comment is to ensure we retain the blank line above.
--- /dev/null
+++ gcc/config/netbsd-stdint.h
@@ -0,0 +1,56 @@
+/* Definitions for <stdint.h> types for NetBSD systems.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Contributed by Gerald Pfeifer <gerald@pfeifer.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE   "int"
+
+#define INT8_TYPE         "signed char"
+#define INT16_TYPE        "short int"
+#define INT32_TYPE        "int"
+#define INT64_TYPE        (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT8_TYPE        "unsigned char"
+#define UINT16_TYPE       "short unsigned int"
+#define UINT32_TYPE       "unsigned int"
+#define UINT64_TYPE       (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_LEAST8_TYPE   "signed char"
+#define INT_LEAST16_TYPE  "short int"
+#define INT_LEAST32_TYPE  "int"
+#define INT_LEAST64_TYPE  (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT_LEAST8_TYPE  "unsigned char"
+#define UINT_LEAST16_TYPE "short unsigned int"
+#define UINT_LEAST32_TYPE "unsigned int"
+#define UINT_LEAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_FAST8_TYPE    "int"
+#define INT_FAST16_TYPE   "int"
+#define INT_FAST32_TYPE   "int"
+#define INT_FAST64_TYPE   (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT_FAST8_TYPE   "unsigned int"
+#define UINT_FAST16_TYPE  "unsigned int"
+#define UINT_FAST32_TYPE  "unsigned int"
+#define UINT_FAST64_TYPE  (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INTPTR_TYPE       (LONG_TYPE_SIZE == 64 ? "long int" : "int")
+#define UINTPTR_TYPE      (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "unsigned int")
--- /dev/null
+++ gcc/config/i386/dragonfly.h
@@ -0,0 +1,105 @@
+/* Definitions for Intel 386 running DragonFly with ELF format
+   Copyright (C) 1996, 2000, 2002, 2004, 2007, 2010, 2011
+   Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+   Adapted from GNU/Linux version by John Polstra.
+   Continued development by David O'Brien <obrien@freebsd.org>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* Override the default comment-starter of "/".  */
+#undef  ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+#undef  ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef  ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef  DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+  (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])
+
+#undef  NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS	1
+
+/* Tell final.c that we don't need a label passed to mcount.  */
+
+#undef  MCOUNT_NAME
+#define MCOUNT_NAME ".mcount"
+
+/* Make gcc agree with <machine/ansi.h>.  */
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE	(TARGET_64BIT ? "long unsigned int" : "unsigned int")
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE	(TARGET_64BIT ? "long int" : "int")
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE	(TARGET_64BIT ? 32 : BITS_PER_WORD)
+
+#undef  SUBTARGET_EXTRA_SPECS	/* i386.h bogusly defines it.  */
+#define SUBTARGET_EXTRA_SPECS \
+  { "dfbsd_dynamic_linker", DFBSD_DYNAMIC_LINKER }
+
+
+/* A C statement to output to the stdio stream FILE an assembler
+   command to advance the location counter to a multiple of 1<<LOG
+   bytes if it is within MAX_SKIP bytes.
+
+   This is used to align code labels according to Intel recommendations.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#undef  ASM_OUTPUT_MAX_SKIP_ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE, LOG, MAX_SKIP)					\
+  if ((LOG) != 0) {														\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG));	\
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
+  }
+#endif
+
+/* Don't default to pcc-struct-return, we want to retain compatibility with
+   older gcc versions AND pcc-struct-return is nonreentrant.
+   (even though the SVR4 ABI for the i386 says that records and unions are
+   returned in memory).  */
+
+#undef  DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* DragonFly sets the rounding precision of the FPU to 53 bits.  Let the
+   compiler get the contents of <float.h> and std::numeric_limits correct.  */
+#undef TARGET_96_ROUND_53_LONG_DOUBLE
+#define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)
+
+/* Put all *tf routines in libgcc.  */
+#undef LIBGCC2_HAS_TF_MODE
+#define LIBGCC2_HAS_TF_MODE 1
+#define LIBGCC2_TF_CEXT q
+#define TF_SIZE 113
+
+/* Static stack checking is supported by means of probes.  */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Support for i386 has been removed from DragonFly for several releases  */
+#define SUBTARGET32_DEFAULT_CPU "i486"
+
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
--- gcc/config/i386/freebsd.h.orig
+++ gcc/config/i386/freebsd.h
@@ -91,6 +91,12 @@
    When the -shared link option is used a final link is not being
    done.  */
 
+#if FBSD_MAJOR < 9
+#define ELF_HASH_STYLE ""
+#else
+#define ELF_HASH_STYLE "--hash-style=both "
+#endif
+
 #undef	LINK_SPEC
 #define LINK_SPEC "\
   %{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
@@ -102,6 +108,7 @@
         %{rdynamic:-export-dynamic} \
         -dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
+  %{!static:" ELF_HASH_STYLE "-rpath @PREFIX@/gcc-aux/lib} \
   %{symbolic:-Bsymbolic}"
 
 /* A C statement to output to the stdio stream FILE an assembler
@@ -148,3 +155,5 @@
 
 #define TARGET_ASM_FILE_END file_end_indicate_exec_stack
 
+/* Compile in __enable_execute_stack (void *) (see config.host) */
+#define HAVE_ENABLE_EXECUTE_STACK
--- gcc/config/i386/freebsd64.h.orig
+++ gcc/config/i386/freebsd64.h
@@ -41,4 +41,5 @@
         %{rdynamic:-export-dynamic} \
 	-dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
+  %{!static:" ELF_HASH_STYLE "-rpath @PREFIX@/gcc-aux/lib} \
   %{symbolic:-Bsymbolic}"
--- gcc/config/i386/netbsd-elf.h.orig
+++ gcc/config/i386/netbsd-elf.h
@@ -38,7 +38,8 @@
 /* Provide a LINK_SPEC appropriate for a NetBSD/i386 ELF target.  */
 
 #undef LINK_SPEC
-#define LINK_SPEC NETBSD_LINK_SPEC_ELF
+#define LINK_SPEC NETBSD_LINK_SPEC_ELF \
+"%{!static:-rpath @PREFIX@/gcc-aux/lib}"
 
 #define NETBSD_ENTRY_POINT "__start"
 
@@ -119,3 +120,9 @@
 #define DEFAULT_PCC_STRUCT_RETURN 1
 
 #define HAVE_ENABLE_EXECUTE_STACK
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
--- gcc/config/i386/netbsd64.h.orig
+++ gcc/config/i386/netbsd64.h
@@ -67,3 +67,10 @@
 }
 
 #define HAVE_ENABLE_EXECUTE_STACK
+
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
--- gcc/ginclude/stddef.h.orig
+++ gcc/ginclude/stddef.h
@@ -53,12 +53,21 @@
    one less case to deal with in the following.  */
 #if defined (__BSD_NET2__) || defined (____386BSD____) || (defined (__FreeBSD__) && (__FreeBSD__ < 5)) || defined(__NetBSD__)
 #include <machine/ansi.h>
+#if !defined(_MACHINE_ANSI_H_)
+#if defined(_I386_ANSI_H_) || defined(_X86_64_ANSI_H_)
+#define _MACHINE_ANSI_H_
+#endif
+#endif
 #endif
 /* On FreeBSD 5, machine/ansi.h does not exist anymore... */
 #if defined (__FreeBSD__) && (__FreeBSD__ >= 5)
 #include <sys/_types.h>
 #endif
 
+#if defined(__DragonFly__)
+#include <sys/types.h>
+#endif
+
 /* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
    defined if the corresponding type is *not* defined.
    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
@@ -136,6 +145,7 @@
 #ifndef _BSD_PTRDIFF_T_
 #ifndef ___int_ptrdiff_t_h
 #ifndef _GCC_PTRDIFF_T
+#ifndef _PTRDIFF_T_DECLARED /* DragonFly */
 #define _PTRDIFF_T
 #define _T_PTRDIFF_
 #define _T_PTRDIFF
@@ -144,10 +154,12 @@
 #define _BSD_PTRDIFF_T_
 #define ___int_ptrdiff_t_h
 #define _GCC_PTRDIFF_T
+#define _PTRDIFF_T_DECLARED
 #ifndef __PTRDIFF_TYPE__
 #define __PTRDIFF_TYPE__ long int
 #endif
 typedef __PTRDIFF_TYPE__ ptrdiff_t;
+#endif /* _PTRDIFF_T_DECLARED */
 #endif /* _GCC_PTRDIFF_T */
 #endif /* ___int_ptrdiff_t_h */
 #endif /* _BSD_PTRDIFF_T_ */
@@ -201,6 +213,7 @@
 #define _GCC_SIZE_T
 #define _SIZET_
 #if (defined (__FreeBSD__) && (__FreeBSD__ >= 5)) \
+  || defined(__DragonFly__) \
   || defined(__FreeBSD_kernel__)
 /* __size_t is a typedef on FreeBSD 5, must not trash it. */
 #else
@@ -307,7 +320,7 @@
 /* FreeBSD 5 can't be handled well using "traditional" logic above
    since it no longer defines _BSD_RUNE_T_ yet still desires to export
    rune_t in some cases... */
-#if defined (__FreeBSD__) && (__FreeBSD__ >= 5)
+#if defined (__DragonFly__) || (defined (__FreeBSD__) && (__FreeBSD__ >= 5))
 #if !defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)
 #if __BSD_VISIBLE
 #ifndef _RUNE_T_DECLARED
--- include/libiberty.h.orig
+++ include/libiberty.h
@@ -106,7 +106,16 @@
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__ ) \
+ || defined (__linux__) \
+ || defined (__DragonFly__) \
+ || defined (__FreeBSD__) \
+ || defined (__OpenBSD__) \
+ || defined (__NetBSD__) \
+ || defined (__CYGWIN__) \
+ || defined (__CYGWIN32__) \
+ || defined (__MINGW32__) \
+ || defined (HAVE_DECL_BASENAME)
 extern char *basename (const char *);
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
--- libgcc/config.host.orig
+++ libgcc/config.host
@@ -174,6 +174,11 @@
   tmake_file="$tmake_file t-darwin ${cpu_type}/t-darwin t-libgcc-pic t-slibgcc-darwin"
   extra_parts="crt3.o crttms.o crttme.o"
   ;;
+*-*-dragonfly*)
+  tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-eh-dw2-dip"
+  tmake_file="$tmake_file t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+  ;;
 *-*-freebsd*)
   # This is the generic ELF configuration of FreeBSD.  Later
   # machine-specific sections may refine and add to this
@@ -202,7 +207,8 @@
   extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
   ;;
 *-*-netbsd*)
-  tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
+  tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-eh-dw2-dip"
+  tmake_file="$tmake_file t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
   # NetBSD 1.7 and later are set up to use GCC's crtstuff for
   # ELF configurations.  We will clear extra_parts in the
   # a.out configurations.
@@ -266,8 +272,10 @@
 esac
 
 case ${host} in
-*-*-darwin* | *-*-freebsd* | *-*-netbsd* | *-*-openbsd* | *-*-solaris2* | \
-  alpha*-dec-osf5.1*)
+*-*-freebsd* | *-*-dragonfly* | *-*-netbsd* | *-*-openbsd*)
+  enable_execute_stack=enable-execute-stack-freebsd.c
+  ;;
+*-*-darwin* | *-*-solaris2* | alpha*-dec-osf5.1*)
   enable_execute_stack=enable-execute-stack-mprotect.c
   ;;
 i[34567]86-*-mingw* | x86_64-*-mingw*)
@@ -318,6 +326,17 @@
 	tmake_file="$tmake_file arm/t-arm arm/t-vxworks t-fdpbit"
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
+arm*-android-eabi*)
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+
+	tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-eh-dw2-dip t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
+	tmake_file="$tmake_file arm/t-arm t-fixedpoint-gnu-prefix"
+	tmake_file="$tmake_file arm/t-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
+	tmake_file="$tmake_file t-softfp-sfdf t-softfp-excl arm/t-softfp t-softfp"
+
+	tm_file="$tm_file arm/bpabi-lib.h"
+	unwind_header=config/arm/unwind-arm.h
+	;;
 arm*-*-freebsd*)
 	tmake_file="$tmake_file arm/t-arm arm/t-strongarm-elf t-fdpbit"
 	;;
@@ -358,11 +377,11 @@
 	tmake_file="$tmake_file arm/t-arm arm/t-elf t-softfp-sfdf t-softfp-excl arm/t-softfp t-softfp"
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
-arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-rtems*)
+arm*-*-symbianelf* | arm*-*-rtems*)
 	tmake_file="${tmake_file} arm/t-arm arm/t-elf t-fixedpoint-gnu-prefix"
 	tm_file="$tm_file arm/bpabi-lib.h"
 	case ${host} in
-	arm*-*-eabi* | arm*-*-rtems*)
+	arm*-*-rtems*)
 	  tmake_file="${tmake_file} arm/t-bpabi"
 	  extra_parts="crtbegin.o crtend.o crti.o crtn.o"
 	  ;;
@@ -526,16 +545,29 @@
 x86_64-*-elf*)
 	tmake_file="$tmake_file i386/t-crtstuff t-crtstuff-pic t-libgcc-pic"
 	;;
+i[34567]86-*-dragonfly*)
+	tmake_file="${tmake_file} i386/t-dragonfly i386/t-crtstuff"
+	md_unwind_header=i386/dragonfly-unwind.h
+	;;
+x86_64-*-dragonfly*)
+	tmake_file="${tmake_file} i386/t-dragonfly i386/t-crtstuff"
+	md_unwind_header=i386/dragonfly-unwind.h
+	;;
 i[34567]86-*-freebsd*)
 	tmake_file="${tmake_file} i386/t-freebsd i386/t-crtstuff"
+	md_unwind_header=i386/freebsd-unwind.h
 	;;
 x86_64-*-freebsd*)
 	tmake_file="${tmake_file} i386/t-freebsd i386/t-crtstuff"
+	md_unwind_header=i386/freebsd-unwind.h
 	;;
 i[34567]86-*-netbsdelf*)
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	md_unwind_header=i386/netbsd-unwind.h
 	;;
 x86_64-*-netbsd*)
 	tmake_file="${tmake_file} i386/t-crtstuff"
+	md_unwind_header=i386/netbsd-unwind.h
 	;;
 i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])
 	;;
@@ -1167,6 +1199,7 @@
   i[34567]86-*-gnu* | \
   i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]* | \
   i[34567]86-*-cygwin* | i[34567]86-*-mingw* | x86_64-*-mingw* | \
+  i[34567]86-*-dragonfly* | x86_64-*-dragonfly* | \
   i[34567]86-*-freebsd* | x86_64-*-freebsd*)
   	tmake_file="${tmake_file} t-softfp-tf"
 	if test "${host_address}" = 32; then
--- libgcc/crtstuff.c.orig
+++ libgcc/crtstuff.c
@@ -81,11 +81,19 @@
 }
 #endif
 
+#if defined(TARGET_DL_ITERATE_PHDR) && \
+   ( defined(__FreeBSD__)              \
+  || defined(__OpenBSD__)              \
+  || defined(__NetBSD__)               \
+  || defined(__DragonFly__))
+#define BSD_DL_ITERATE_PHDR_AVAILABLE
+#endif
+
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
     && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
-    && defined(__FreeBSD__) && __FreeBSD__ >= 7
+    && defined(BSD_DL_ITERATE_PHDR_AVAILABLE)
 #include <link.h>
 # define USE_PT_GNU_EH_FRAME
 #endif
--- /dev/null
+++ libgcc/enable-execute-stack-freebsd.c
@@ -0,0 +1,58 @@
+/* Implement __enable_execute_stack using mprotect(2).
+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3, or (at your option) any later
+   version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/mman.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#define STACK_PROT_RWX (PROT_READ | PROT_WRITE | PROT_EXEC)
+
+extern void __enable_execute_stack (void *);
+
+void
+__enable_execute_stack (void *addr)
+{
+  static int size;
+  static long mask;
+  char *page, *ends;
+  long page_addr, ends_addr;
+
+  if (size == 0)
+  {
+    size = getpagesize ();
+    mask = ~((long) size - 1);
+  }
+  page_addr = (long) addr;
+  ends_addr = (long) (addr + __LIBGCC_TRAMPOLINE_SIZE__);
+
+  page = (char *) (page_addr & mask);
+  ends = (char *) ((ends_addr & mask) + size);
+
+  /*
+   * Note that no errors should be emitted by mprotect; it is considered
+   * dangerous for library calls to send messages to stdout/stderr.
+   */
+  if (mprotect (page, ends - page, STACK_PROT_RWX) < 0)
+    abort ();
+}
--- libgcc/unwind-dw2-fde-dip.c.orig
+++ libgcc/unwind-dw2-fde-dip.c
@@ -54,11 +54,19 @@
 #endif
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
-    && defined(__FreeBSD__) && __FreeBSD__ >= 7
+    && defined(TARGET_DL_ITERATE_PHDR) \
+    && (defined(__FreeBSD__) || defined(__DragonFly__))
 # define ElfW __ElfN
 # define USE_PT_GNU_EH_FRAME
 #endif
 
+#if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
+    && defined(TARGET_DL_ITERATE_PHDR) \
+    && (defined(__OpenBSD__) || defined(__NetBSD__))
+# define ElfW(n) Elf_##n
+# define USE_PT_GNU_EH_FRAME
+#endif
+
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
     && defined(__OpenBSD__)
 # define ElfW(type) Elf_##type
--- /dev/null
+++ libgcc/config/i386/dragonfly-unwind.h
@@ -0,0 +1,158 @@
+/* DWARF2 EH unwinding support for DragonFly BSD: AMD x86-64 and x86.
+   Copyright (C) 2010 John Marino <draco@marino.st> */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <machine/sigframe.h>
+
+
+#define REG_NAME(reg)	sf_uc.uc_mcontext.mc_## reg
+
+#ifdef __x86_64__
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_dragonfly_fallback_frame_state
+
+
+static void
+x86_64_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 32;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_64_dragonfly_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_64_sigtramp_range(&sigtramp_start, &sigtramp_end);
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(rsp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  /* Register 7 is rsp  */
+  fs->regs.cfa_reg = 7;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;
+  fs->regs.reg[4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;
+  fs->regs.reg[9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+#else /* Next section is for i386  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_dragonfly_fallback_frame_state
+
+
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 128;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_dragonfly_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_sigtramp_range(&sigtramp_start, &sigtramp_end);
+
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+#endif /* ifdef __x86_64__  */
--- /dev/null
+++ libgcc/config/i386/freebsd-unwind.h
@@ -0,0 +1,179 @@
+/* DWARF2 EH unwinding support for FreeBSD: AMD x86-64 and x86.
+   Copyright (C) 2010, 2012 John Marino <draco@marino.st>
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/types.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <machine/sigframe.h>
+
+#define REG_NAME(reg)	sf_uc.uc_mcontext.mc_## reg
+
+#ifdef __x86_64__
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_freebsd_fallback_frame_state
+
+#if (__FreeBSD__ < 9)
+#include <sys/sysctl.h>
+static void
+x86_64_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 32;
+  *end   = (unsigned char *)ps_strings;
+}
+#endif
+
+
+static _Unwind_Reason_Code
+x86_64_freebsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+#if (__FreeBSD__ < 9)
+  x86_64_sigtramp_range(&sigtramp_start, &sigtramp_end);
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+#else
+  /* Prior to FreeBSD 9, the signal trampoline was located immediately
+     before the ps_strings.  To support non-executable stacks on AMD64,
+     the sigtramp was moved to a shared page for FreeBSD 9.  We are
+     stuck looking for frame patterns again (sys/amd64/amd64/sigtramp.S):
+
+     <pc + 00>:  lea     0x10(%rsp),%rdi
+     <pc + 05>:  pushq   $0x0
+     <pc + 17>:  mov     $0x1a1,%rax
+     <pc + 14>:  syscall
+
+     If we can't find this pattern, we're at the end of the stack.
+  */
+
+  if (!(   *(unsigned int *)(context->ra)      == 0x247c8d48
+        && *(unsigned int *)(context->ra +  4) == 0x48006a10
+        && *(unsigned int *)(context->ra +  8) == 0x01a1c0c7
+        && *(unsigned int *)(context->ra + 12) == 0x050f0000 ))
+    return _URC_END_OF_STACK;
+#endif
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(rsp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  /* Register 7 is rsp  */
+  fs->regs.cfa_reg = 7;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;
+  fs->regs.reg[4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;
+  fs->regs.reg[9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+#else /* Next section is for i386  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_freebsd_fallback_frame_state
+
+#include <sys/sysctl.h>
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 128;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_freebsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_sigtramp_range(&sigtramp_start, &sigtramp_end);
+
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+#endif /* ifdef __x86_64__  */
--- /dev/null
+++ libgcc/config/i386/netbsd-unwind.h
@@ -0,0 +1,169 @@
+/* DWARF2 EH unwinding support for x86 NetBSD
+   Copyright (C) 2010 John Marino (www.dragonlace.net) */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/ucontext.h>
+#include <machine/frame.h>
+
+#define REG_NAME(reg)   sf_uc.uc_mcontext.__gregs[_REG_## reg]
+
+#ifdef __x86_64__
+
+
+
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_netbsd_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_64_netbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  /* signal_frame is sigframe_siginfo minus sf_ra handler return address */
+  struct signal_frame {
+         siginfo_t    sf_si;   /* actual saved siginfo  */
+         ucontext_t   sf_uc;   /* actual saved ucontext */
+  };
+  struct signal_frame *sf;
+  long new_cfa;
+
+  /*  We are looking for the following signal trampoline pattern. If we don't
+      find it, we are at the end of the stack and can't unwind.
+
+      <__sigtramp_siginfo_2+12>:  mov     $0xffffffffffffffff,%rdi
+      <__sigtramp_siginfo_2+19>:  mov     $0x1,%rax
+      <__sigtramp_siginfo_2+26>:  syscall
+  */
+
+  if (   *(unsigned int   *) (context->ra + 12) == 0xffc7c748
+      && *(unsigned int   *) (context->ra + 16) == 0x48ffffff
+      && *(unsigned int   *) (context->ra + 20) == 0x0001c0c7
+      && *(unsigned int   *) (context->ra + 24) == 0x050f0000 )
+  {
+    sf = (struct signal_frame *) context->cfa;
+    new_cfa = sf->REG_NAME(RSP);
+    fs->regs.cfa_how = CFA_REG_OFFSET;
+    fs->regs.cfa_reg = 7;
+    fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  }
+  else
+  {
+    return _URC_END_OF_STACK;
+  }
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[ 0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 0].loc.offset = (long)&sf->REG_NAME(RAX) - new_cfa;
+  fs->regs.reg[ 1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 1].loc.offset = (long)&sf->REG_NAME(RDX) - new_cfa;
+  fs->regs.reg[ 2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 2].loc.offset = (long)&sf->REG_NAME(RCX) - new_cfa;
+  fs->regs.reg[ 3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 3].loc.offset = (long)&sf->REG_NAME(RBX) - new_cfa;
+  fs->regs.reg[ 4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 4].loc.offset = (long)&sf->REG_NAME(RSI) - new_cfa;
+  fs->regs.reg[ 5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 5].loc.offset = (long)&sf->REG_NAME(RDI) - new_cfa;
+  fs->regs.reg[ 6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 6].loc.offset = (long)&sf->REG_NAME(RBP) - new_cfa;
+  fs->regs.reg[ 8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 8].loc.offset = (long)&sf->REG_NAME(R8)  - new_cfa;
+  fs->regs.reg[ 9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 9].loc.offset = (long)&sf->REG_NAME(R9)  - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(R10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(R11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(R12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(R13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(R14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(R15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(RIP) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+
+
+
+#else /* Next section is for i386  */
+
+
+
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_netbsd_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_netbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  /* signal_frame is sigframe_siginfo minus sf_ra handler return address */
+  struct signal_frame {
+         int          sf_signum;  /* "signum" argument for handler" */
+         siginfo_t   *sf_sip;     /* "sip"    argument for handler" */
+         ucontext_t  *sf_ucp;     /* "ucp"    argument for handler" */
+         siginfo_t    sf_si;      /* actual saved siginfo  */
+         ucontext_t   sf_uc;      /* actual saved ucontext */
+  };
+  struct signal_frame *sf;
+  long new_cfa;
+
+  /*  We are looking for the following signal trampoline pattern. If we don't
+      find it, we are at the end of the stack and can't unwind.
+
+      <__sigtramp_siginfo_2+18>:  movl   $0xffffffff,0x4(%esp)
+      <__sigtramp_siginfo_2+26>:  mov    $0x1,%eax
+      <__sigtramp_siginfo_2+31>:  int    $0x80
+  */
+
+  if (   *(unsigned int   *) (context->ra + 18) == 0x042444c7
+      && *(unsigned int   *) (context->ra + 22) == 0xffffffff
+      && *(unsigned char  *) (context->ra + 26) == 0xb8
+      && *(unsigned int   *) (context->ra + 27) == 0x00000001
+      && *(unsigned short *) (context->ra + 31) == 0x80cd     )
+  {
+    sf = (struct signal_frame *) context->cfa;
+    new_cfa = sf->REG_NAME(ESP);
+    fs->regs.cfa_how = CFA_REG_OFFSET;
+    fs->regs.cfa_reg = 4;
+    fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  }
+  else
+  {
+    return _URC_END_OF_STACK;
+  }
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(EAX) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(EBX) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ECX) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(EDX) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(ESI) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(EDI) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(EBP) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(EIP) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+
+
+
+#endif /* ifdef __x86_64__  */
+
--- libiberty/getpagesize.c.orig
+++ libiberty/getpagesize.c
@@ -20,6 +20,7 @@
 
 */
 
+#ifndef __ANDROID__
 #ifndef VMS
 
 #include "config.h"
@@ -88,3 +89,4 @@
 }
 
 #endif /* VMS */
+#endif /* __ANDROID__ */
--- libiberty/setproctitle.c.orig
+++ libiberty/setproctitle.c
@@ -40,9 +40,11 @@
 void
 setproctitle (const char *name ATTRIBUTE_UNUSED, ...)
 {
+#ifndef __ANDROID__
 #ifdef PR_SET_NAME
   /* On GNU/Linux this sets the top visible "comm", but not
      necessarily the name visible in ps. */
   prctl (PR_SET_NAME, name);
 #endif
+#endif
 }
--- gcc/configure.orig
+++ gcc/configure
@@ -26902,6 +26902,20 @@
       gcc_cv_target_dl_iterate_phdr=no
     fi
     ;;
+  *-*-dragonfly* | *-*-freebsd*)
+  if grep dl_iterate_phdr $target_header_dir/sys/link_elf.h > /dev/null 2>&1; then
+      gcc_cv_target_dl_iterate_phdr=yes
+    else
+      gcc_cv_target_dl_iterate_phdr=no
+    fi
+  ;;
+  *-*-netbsd*)
+  if grep dl_iterate_phdr $target_header_dir/link_elf.h > /dev/null 2>&1; then
+      gcc_cv_target_dl_iterate_phdr=yes
+    else
+      gcc_cv_target_dl_iterate_phdr=no
+    fi
+  ;;
 esac
 
 if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
--- gcc/Makefile.in.orig
+++ gcc/Makefile.in
@@ -1165,7 +1165,6 @@
 	insn-automata.o \
 	insn-emit.o \
 	insn-extract.o \
-	insn-modes.o \
 	insn-opinit.o \
 	insn-output.o \
 	insn-peep.o \
@@ -1484,13 +1483,18 @@
 ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \
   $(OBJS-libcommon-target) @TREEBROWSER@ main.o gccspec.o cppspec.o \
   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) mips-tfile.o mips-tdump.o \
-  $(GCOV_OBJS) $(GCOV_DUMP_OBJS)
+  $(GCOV_OBJS) $(GCOV_DUMP_OBJS) insn-modes.o insn-modes-ada.o
 
 # This lists all host object files, whether they are included in this
 # compilation or not.
 ALL_HOST_OBJS = $(ALL_HOST_FRONTEND_OBJS) $(ALL_HOST_BACKEND_OBJS)
 
-BACKEND = main.o @TREEBROWSER@ libbackend.a libcommon-target.a libcommon.a \
+BACKEND = main.o @TREEBROWSER@ insn-modes.o libbackend.a \
+	libcommon-target.a libcommon.a \
+	$(CPPLIB) $(LIBDECNUMBER)
+
+BACKEND2 = main.o @TREEBROWSER@ insn-modes-ada.o libbackend.a \
+	libcommon-target.a libcommon.a \
 	$(CPPLIB) $(LIBDECNUMBER)
 
 MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \
@@ -3522,6 +3526,8 @@
   $(TM_H) $(RTL_H) $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H)
 insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	$(TM_H) \
   $(MACHMODE_H)
+insn-modes-ada.o : insn-modes-ada.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(MACHMODE_H)
 insn-opinit.o : insn-opinit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	\
   $(TM_H) $(RTL_H) $(TM_P_H) insn-config.h $(FLAGS_H) $(RECOG_H)	\
   $(EXPR_H) $(OPTABS_H) reload.h
@@ -3615,6 +3621,7 @@
 
 insn-modes.c: s-modes; @true
 insn-modes.h: s-modes-h; @true
+insn-modes-ada.c: s-modes-ada; @true
 min-insn-modes.c: s-modes-m; @true
 
 s-modes: build/genmodes$(build_exeext)
@@ -3632,6 +3639,12 @@
 	$(SHELL) $(srcdir)/../move-if-change tmp-min-modes.c min-insn-modes.c
 	$(STAMP) s-modes-m
 
+s-modes-ada: s-modes
+	$(shell sed -e 's/: TARGET_96_ROUND_53_LONG_DOUBLE \? &ieee_extended_intel_96_round_53_format //'  \
+		< insn-modes.c > tmp-modes-ada.c)
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes-ada.c insn-modes-ada.c
+	$(STAMP) s-modes-ada
+
 insn-preds.c: s-preds; @true
 tm-preds.h: s-preds-h; @true
 tm-constrs.h: s-constrs-h; @true
@@ -4394,7 +4407,7 @@
 	DESTDIR=$(@D) \
 	$(SHELL) $(srcdir)/doc/install.texi2html
 
-MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 doc/fsf-funding.7
+MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1
 
 generated-manpages: man
 
@@ -4546,7 +4559,7 @@
 # Install the driver last so that the window when things are
 # broken is small.
 install: install-common $(INSTALL_HEADERS) \
-    install-cpp install-man install-info install-@POSUB@ \
+    install-cpp install-man install-@POSUB@ \
     install-driver install-lto-wrapper install-gcc-ar
 
 ifeq ($(enable_plugin),yes)
@@ -4671,6 +4684,9 @@
 	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)$(exeext)
 	-( cd $(DESTDIR)$(bindir) && \
 	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) )
+	-if [ -f gnat1$(exeext) ] ; then \
+	  ( cd $(DESTDIR)$(bindir) && $(LN) $(GCC_INSTALL_NAME)$(exeext) ada$(exeext) ) \
+	fi
 	-if [ -f gcc-cross$(exeext) ] ; then \
 	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
 	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
@@ -4744,10 +4760,7 @@
 install-man: lang.install-man \
 	$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext) \
 	$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext) \
-	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext) \
-	$(DESTDIR)$(man7dir)/fsf-funding$(man7ext) \
-	$(DESTDIR)$(man7dir)/gfdl$(man7ext) \
-	$(DESTDIR)$(man7dir)/gpl$(man7ext)
+	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext)
 
 $(DESTDIR)$(man7dir)/%$(man7ext): doc/%.7 installdirs
 	-rm -f $@
--- configure.orig
+++ configure
@@ -14419,7 +14419,7 @@
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }; stage1_cflags="$stage1_cflags -fkeep-inline-functions"
+$as_echo "yes" >&6; };
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
