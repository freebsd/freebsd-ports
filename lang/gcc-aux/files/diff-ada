--- /dev/null
+++ gcc/ada/a-intnam-dragonfly.ads
@@ -0,0 +1,136 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the DragonFly BSD THREADS version of this package
+
+with System.OS_Interface;
+
+package Ada.Interrupts.Names is
+
+   --  All identifiers in this unit are implementation defined
+
+   pragma Implementation_Defined;
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on
+   --  the current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+end Ada.Interrupts.Names;
--- gcc/ada/adaint.c.orig
+++ gcc/ada/adaint.c
@@ -577,8 +577,8 @@
   GNAT_STRUCT_STAT stat_result;
   int fd;
 
-  sprintf (full_path, "%s%c%s", dir, DIR_SEPARATOR, file);
-  sprintf (temp_file, "%s%cTMP-%ld-%ld",
+  snprintf (full_path, 256, "%s%c%s", dir, DIR_SEPARATOR, file);
+  snprintf (temp_file, 256, "%s%cTMP-%ld-%ld",
            dir, DIR_SEPARATOR, (long)getpid(), (long)getppid ());
 
   /* Create the temporary file and write the process number.  */
@@ -745,7 +745,8 @@
   strcpy (encoding, "encoding=utf8");
   *e_length = strlen (encoding);
 #else
-  strcpy (os_name, filename);
+  /* o_length is initialized with max os_name size (2x filename size) */
+  strncpy (os_name, filename, *o_length);
   *o_length = strlen (filename);
   *e_length = 0;
 #endif
@@ -1141,9 +1142,10 @@
   int fd;
   int o_fmode = O_BINARY;
 
-  strcpy (path, "GNAT-XXXXXX");
+  strncpy (path, "GNAT-XXXXXX", 12);
 
 #if (defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
+  || defined (__DragonFly__) \
   || defined (linux) || defined(__GLIBC__)) && !defined (__vxworks)
   return mkstemp (path);
 #elif defined (__Lynx__)
@@ -1310,7 +1312,49 @@
     free (pname);
   }
 
+#elif defined (__ANDROID__)
+
+  /*
+   * ext2 /ext3/ext4/fat16/fat32 have no path limits
+   * /data/local/tmp normally requires rooted devices, if it even exists
+   * /sdcard is the standard location for external storage.  Nativeactivity
+   * manifest needs to authorize its use, otherwise it might not have the
+   * proper permissions.
+   */
+
+  int testfd;
+  char *datadir = getenv ("ANDROID_DATA");
+
+  if (datadir == NULL)
+    strncpy (tmp_filename, "/data/local/tmp/gnat-XXXXXX", L_tmpnam);
+  else
+    snprintf (tmp_filename, L_tmpnam, "%s/local/tmp/gnat-XXXXXX", datadir);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  char *sdcard = getenv ("EXTERNAL_STORAGE");
+
+  if (sdcard == NULL)
+    strncpy (tmp_filename, "/sdcard/gnat-XXXXXX", L_tmpnam);
+  else
+    snprintf (tmp_filename, L_tmpnam, "%s/gnat-XXXXXX", sdcard);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  tmpnam (tmp_filename);
+
 #elif defined (linux) || defined (__FreeBSD__) || defined (__NetBSD__) \
+  || defined (__DragonFly__) \
   || defined (__OpenBSD__) || defined(__GLIBC__)
 #define MAX_SAFE_PATH 1000
   char *tmpdir = getenv ("TMPDIR");
@@ -1318,9 +1362,9 @@
   /* If tmpdir is longer than MAX_SAFE_PATH, revert to default value to avoid
      a buffer overflow.  */
   if (tmpdir == NULL || strlen (tmpdir) > MAX_SAFE_PATH)
-    strcpy (tmp_filename, "/tmp/gnat-XXXXXX");
+    strncpy (tmp_filename, "/tmp/gnat-XXXXXX", L_tmpnam);
   else
-    sprintf (tmp_filename, "%s/gnat-XXXXXX", tmpdir);
+    snprintf (tmp_filename, L_tmpnam, "%s/gnat-XXXXXX", tmpdir);
 
   close (mkstemp(tmp_filename));
 #elif defined (__vxworks) && !(defined (__RTP__) || defined (VTHREADS))
@@ -2562,7 +2606,9 @@
 {
   int cores = 1;
 
-#if defined (linux) || defined (sun) || defined (AIX) || defined (__APPLE__)
+#if defined (linux) || defined (sun) || defined (AIX) \
+ || defined (__APPLE__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+ || defined (__DragonFly__) || defined (__NetBSD__)
   cores = (int) sysconf (_SC_NPROCESSORS_ONLN);
 
 #elif defined (__hpux__)
@@ -3608,35 +3654,6 @@
 }
 #endif
 
-#if defined (IS_CROSS)  \
-  || (! ((defined (sparc) || defined (i386)) && defined (sun) \
-      && defined (__SVR4)) \
-      && ! (defined (linux) && (defined (i386) || defined (__x86_64__))) \
-      && ! (defined (linux) && defined (__ia64__)) \
-      && ! (defined (linux) && defined (powerpc)) \
-      && ! defined (__FreeBSD__) \
-      && ! defined (__Lynx__) \
-      && ! defined (__hpux__) \
-      && ! defined (__APPLE__) \
-      && ! defined (_AIX) \
-      && ! defined (VMS) \
-      && ! defined (__MINGW32__))
-
-/* Dummy function to satisfy g-trasym.o. See the preprocessor conditional
-   just above for a list of native platforms that provide a non-dummy
-   version of this procedure in libaddr2line.a.  */
-
-void
-convert_addresses (const char *file_name ATTRIBUTE_UNUSED,
-		   void *addrs ATTRIBUTE_UNUSED,
-		   int n_addr ATTRIBUTE_UNUSED,
-		   void *buf ATTRIBUTE_UNUSED,
-		   int *len ATTRIBUTE_UNUSED)
-{
-  *len = 0;
-}
-#endif
-
 #if defined (_WIN32)
 int __gnat_argument_needs_quote = 1;
 #else
--- gcc/ada/cio.c.orig
+++ gcc/ada/cio.c
@@ -49,7 +49,8 @@
 
 /* Don't use macros on GNU/Linux since they cause incompatible changes between
    glibc 2.0 and 2.1 */
-#ifdef linux
+/* Android is The exception because it uses the BIONIC library */
+#if defined(linux) && !defined(__ANDROID__)
 #undef putchar
 #undef getchar
 #undef fputc
--- gcc/ada/cstreams.c.orig
+++ gcc/ada/cstreams.c
@@ -54,9 +54,10 @@
 #include <unixlib.h>
 #endif
 
-#ifdef linux
+#if defined(linux) && !defined(__ANDROID__)
 /* Don't use macros on GNU/Linux since they cause incompatible changes between
    glibc 2.0 and 2.1 */
+/* Android is The exception because it uses the BIONIC library */
 
 #ifdef stderr
 #  undef stderr
@@ -187,7 +188,9 @@
 	  *p = '\\';
     }
 
-#elif defined (__FreeBSD__)
+#elif defined (__FreeBSD__) \
+   || defined (__DragonFly__) \
+   || defined (__OpenBSD__)
 
   /* Use realpath function which resolves links and references to . and ..
      on those Unix systems that support it. Note that GNU/Linux provides it but
--- gcc/ada/env.c.orig
+++ gcc/ada/env.c
@@ -180,7 +180,9 @@
       LIB$SIGNAL (status);
   }
 
-#elif (defined (__vxworks) && defined (__RTP__)) || defined (__APPLE__)
+#elif (defined (__vxworks) && defined (__RTP__)) \
+  || defined (__APPLE__) \
+  || defined (__OpenBSD__)
   setenv (name, value, 1);
 
 #else
@@ -301,6 +303,7 @@
   }
 #elif defined (__MINGW32__) || defined (__FreeBSD__) || defined (__APPLE__) \
    || (defined (__vxworks) && defined (__RTP__)) || defined (__CYGWIN__) \
+   || defined (__DragonFly__) \
    || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__rtems__)
   /* On Windows, FreeBSD and MacOS there is no function to clean all the
      environment but there is a "clean" way to unset a variable. So go
--- gcc/ada/g-comlin.adb.orig
+++ gcc/ada/g-comlin.adb
@@ -525,6 +525,7 @@
    begin
       Index_In_Switches := 0;
       Switch_Length     := 0;
+      Param             := Parameter_None;
 
       --  Remove all leading spaces first to make sure that Index points
       --  at the start of the first switch.
--- gcc/ada/g-expect.adb.orig
+++ gcc/ada/g-expect.adb
@@ -1335,15 +1335,20 @@
 
       --  The following commands are not executed on Unix systems, and are only
       --  required for Windows systems. We are now in the parent process.
+      --  Although the if-statement is redundant, it's here so the compiler
+      --  doesn't complain about uninitialized variables.
 
-      --  Restore the old descriptors
+      if No_Fork_On_Target then
 
-      Dup2 (Input,  GNAT.OS_Lib.Standin);
-      Dup2 (Output, GNAT.OS_Lib.Standout);
-      Dup2 (Error,  GNAT.OS_Lib.Standerr);
-      Close (Input);
-      Close (Output);
-      Close (Error);
+         --  Restore the old descriptors
+
+         Dup2 (Input,  GNAT.OS_Lib.Standin);
+         Dup2 (Output, GNAT.OS_Lib.Standout);
+         Dup2 (Error,  GNAT.OS_Lib.Standerr);
+         Close (Input);
+         Close (Output);
+         Close (Error);
+      end if;
    end Set_Up_Child_Communications;
 
    ---------------------------
--- /dev/null
+++ gcc/ada/g-socthi-bsd.adb
@@ -0,0 +1,356 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    G N A T . S O C K E T S . T H I N                     --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 2001-2013, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides a target dependent thin interface to the sockets
+--  layer for use by the GNAT.Sockets package (g-socket.ads). This package
+--  should not be directly with'ed by an applications program.
+
+--  This is the *BSD version which uses fcntl rather than ioctl
+--  The constant SCON.Thread_Blocking_IO is always true (for all platforms, not
+--  just *BSD), so this binding is significantly simpler than the standard
+--  one it replaces.
+
+with GNAT.OS_Lib; use GNAT.OS_Lib;
+
+with Interfaces.C; use Interfaces.C;
+
+package body GNAT.Sockets.Thin is
+
+   function Syscall_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Accept, "accept");
+   --  The accept() function accepts a connection on a socket.  An incoming
+   --  connection is acknowledged and associated with an immediately created
+   --  socket.  The original socket is returned to the listening state.
+
+   function Syscall_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int;
+   pragma Import (C, Syscall_Connect, "connect");
+   --  The connect() system call initiates a connection on a socket.  If the
+   --  parameter S is of type SOCK_DGRAM then connect() permanently specifies
+   --  the peer to which datagrams are to be sent.  If S is type SOCK_STREAM
+   --  then connect() attempts to make a connection with another socket, which
+   --  is identified by the parameter Name.
+
+   function Syscall_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int;
+   pragma Import (C, Syscall_Recv, "recv");
+   --  The recv() function receives a message from a socket.  The call can be
+   --  used on a connection mode socket or a bound, connectionless socket.  If
+   --  no messages are available at the socket, the recv() call waits for a
+   --  message to arrive unless the socket is non-blocking.  If a socket is
+   --  non-blocking, the call returns a -1 and ERRNO is set to EWOULDBLOCK.
+
+   function Syscall_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Recvfrom, "recvfrom");
+   --  The recvfrom() system call receives a message from a socket and captures
+   --  the address from which the data was sent.  It can be used to receive
+   --  data on an unconnected socket as well.  If no messages are available,
+   --  the call waits for a message to arrive on blocking sockets.  For
+   --  non-blocking sockets without messages, -1 is returned and ERRNO is set
+   --  to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Recvmsg, "recvmsg");
+   --  The recvmsg call receives a message from a socket, and can be used to
+   --  receive data on an unconnected socket as well.  If no messages are
+   --  available, the call waits for a message to arrive on blocking sockets.
+   --  For non-blocking sockets without messages, -1 is returned and ERRNO is
+   --  set to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Sendmsg, "sendmsg");
+   --  The sendmsg() function sends a message to a socket, and can be used with
+   --  unconnected sockets as well (the msg is ignored in this case).  The
+   --  function returns the number of bytes sent when successful, otherwise it
+   --  returns -1 and ERRNO is set (many possible values).
+
+   function Syscall_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int;
+   pragma Import (C, Syscall_Sendto, "sendto");
+   --  The sendto() function only works for connected sockets and it initiates
+   --  the transmission of a message.  A successful call returns the numbers of
+   --  bytes sent, and a failure returns a -1 and ERRNO is set.
+
+   function Syscall_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int;
+   pragma Import (C, Syscall_Socket, "socket");
+   --  The socket() function is used to create an unbound socket and returns a
+   --  file descriptor that can be used with other socket functions.  Upon
+   --  failure, a -1 is returned and ERRNO is set.
+
+   procedure Disable_SIGPIPE (S : C.int);
+   pragma Import (C, Disable_SIGPIPE, "__gnat_disable_sigpipe");
+
+   procedure Disable_All_SIGPIPEs;
+   pragma Import (C, Disable_All_SIGPIPEs, "__gnat_disable_all_sigpipes");
+   --  Sets the process to ignore all SIGPIPE signals on platforms that
+   --  don't support Disable_SIGPIPE for particular streams.
+
+   function C_Fcntl
+     (Fd  : C.int;
+      Cmd : C.int;
+      Val : C.int) return C.int;
+   pragma Import (C, C_Fcntl, "fcntl");
+   --  The ioctl of 64-bit DragonFlyBSD, OpenBSD, and NetBSD does not support
+   --  setting a socket in non-blocking mode.  fcntl must be used instead.
+
+   --------------
+   -- C_Accept --
+   --------------
+
+   function C_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int
+   is
+      R : constant C.int := Syscall_Accept (S, Addr, Addrlen);
+   begin
+
+      Disable_SIGPIPE (R);
+      return R;
+   end C_Accept;
+
+   ---------------
+   -- C_Connect --
+   ---------------
+
+   function C_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int
+   is
+   begin
+      return Syscall_Connect (S, Name, Namelen);
+   end C_Connect;
+
+   ------------------
+   -- Socket_Ioctl --
+   ------------------
+
+   function Socket_Ioctl
+     (S   : C.int;
+      Req : SOSC.IOCTL_Req_T;
+      Arg : access C.int) return C.int
+   is
+   begin
+      if Req = SOSC.FIONBIO then
+         declare
+            use Interfaces;
+            flags    : constant Unsigned_32 :=
+                                Unsigned_32 (C_Fcntl (S, SOSC.F_GETFL, 0));
+            nonblock : constant Unsigned_32 := Unsigned_32 (SOSC.O_NDELAY);
+            enabled  : constant Boolean := Arg.all = 1;
+            newval   : C.int := C.int (flags);
+         begin
+            if enabled then
+               newval := C.int (flags or nonblock);
+            elsif (flags and nonblock) > 0 then
+               newval := C.int (flags - nonblock);
+            end if;
+            return C_Fcntl (Fd => S, Cmd => SOSC.F_SETFL, Val => newval);
+         end;
+      end if;
+
+      return C_Ioctl (S, Req, Arg);
+   end Socket_Ioctl;
+
+   ------------
+   -- C_Recv --
+   ------------
+
+   function C_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int
+   is
+   begin
+      return Syscall_Recv (S, Msg, Len, Flags);
+   end C_Recv;
+
+   ----------------
+   -- C_Recvfrom --
+   ----------------
+
+   function C_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int
+   is
+   begin
+      return Syscall_Recvfrom (S, Msg, Len, Flags, From, Fromlen);
+   end C_Recvfrom;
+
+   ---------------
+   -- C_Recvmsg --
+   ---------------
+
+   function C_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+      return  Syscall_Recvmsg (S, Msg, Flags);
+   end C_Recvmsg;
+
+   ---------------
+   -- C_Sendmsg --
+   ---------------
+
+   function C_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+      return Syscall_Sendmsg (S, Msg, Flags);
+   end C_Sendmsg;
+
+   --------------
+   -- C_Sendto --
+   --------------
+
+   function C_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int
+   is
+   begin
+      return Syscall_Sendto (S, Msg, Len, Flags, To, Tolen);
+   end C_Sendto;
+
+   --------------
+   -- C_Socket --
+   --------------
+
+   function C_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int
+   is
+      R : constant C.int := Syscall_Socket (Domain, Typ, Protocol);
+   begin
+      Disable_SIGPIPE (R);
+      return R;
+   end C_Socket;
+
+   --------------
+   -- Finalize --
+   --------------
+
+   procedure Finalize is
+   begin
+      null;
+   end Finalize;
+
+   -------------------------
+   -- Host_Error_Messages --
+   -------------------------
+
+   package body Host_Error_Messages is separate;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      Disable_All_SIGPIPEs;
+   end Initialize;
+
+   --------------------
+   -- Signalling_Fds --
+   --------------------
+
+   package body Signalling_Fds is
+
+      --  In this default implementation, we use a C version of these
+      --  subprograms provided by socket.c.
+
+      function C_Create (Fds : not null access Fd_Pair) return C.int;
+      function C_Read (Rsig : C.int) return C.int;
+      function C_Write (Wsig : C.int) return C.int;
+      procedure C_Close (Sig : C.int);
+
+      pragma Import (C, C_Create, "__gnat_create_signalling_fds");
+      pragma Import (C, C_Read,   "__gnat_read_signalling_fd");
+      pragma Import (C, C_Write,  "__gnat_write_signalling_fd");
+      pragma Import (C, C_Close,  "__gnat_close_signalling_fd");
+
+      function Create
+        (Fds : not null access Fd_Pair) return C.int renames C_Create;
+      function Read (Rsig : C.int) return C.int renames C_Read;
+      function Write (Wsig : C.int) return C.int renames C_Write;
+      procedure Close (Sig : C.int) renames C_Close;
+
+   end Signalling_Fds;
+
+   --------------------------
+   -- Socket_Error_Message --
+   --------------------------
+
+   function Socket_Error_Message (Errno : Integer) return String is separate;
+
+end GNAT.Sockets.Thin;
--- /dev/null
+++ gcc/ada/g-trasym-bsd.adb
@@ -0,0 +1,150 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT RUN-TIME COMPONENTS                         --
+--                                                                          --
+--             G N A T . T R A C E B A C K . S Y M B O L I C                --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1999-2009, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  Run-time symbolic traceback support
+--  This file is based on the work by Juergen Pfiefer which is still used
+--  today to provide symbolic traceback support for gnu/kFreeBSD.
+--  Incorporated in GNAT-AUX by John Marino <http://www.dragonlace.net>
+
+with System.Soft_Links;
+with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;
+
+package body GNAT.Traceback.Symbolic is
+
+   package TSL renames System.Soft_Links;
+
+   --  To perform the raw addresses to symbolic form translation we rely on a
+   --  libaddr2line symbolizer which examines debug info from a provided
+   --  executable file name, and an absolute path is needed to ensure the file
+   --  is always found. This is "__gnat_locate_exec_on_path (gnat_argv [0])"
+   --  for our executable file, a fairly heavy operation so we cache the
+   --  result.
+
+   Exename : System.Address;
+   --  Pointer to the name of the executable file to be used on all
+   --  invocations of the libaddr2line symbolization service.
+
+   Exename_Resolved : Boolean := False;
+   --  Flag to indicate whether we have performed the executable file name
+   --  resolution already. Relying on a not null Exename for this purpose
+   --  would be potentially inefficient as this is what we will get if the
+   --  resolution attempt fails.
+
+   ------------------------
+   -- Symbolic_Traceback --
+   ------------------------
+
+   function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is
+
+      procedure convert_addresses
+        (filename : System.Address;
+         addrs    : System.Address;
+         n_addrs  : Integer;
+         buf      : System.Address;
+         len      : System.Address);
+      pragma Import (C, convert_addresses, "convert_addresses");
+      --  This is the procedure version of the Ada-aware addr2line. It places
+      --  in BUF a string representing the symbolic translation of the N_ADDRS
+      --  raw addresses provided in ADDRS, looked up in debug information from
+      --  FILENAME. LEN points to an integer which contains the size of the
+      --  BUF buffer at input and the result length at output.
+      --
+      --  Note that this procedure is *not* thread-safe.
+
+      type Argv_Array is array (0 .. 0) of System.Address;
+      gnat_argv : access Argv_Array;
+      pragma Import (C, gnat_argv, "gnat_argv");
+
+      function locate_exec_on_path
+        (c_exename : System.Address) return System.Address;
+      pragma Import (C, locate_exec_on_path, "__gnat_locate_exec_on_path");
+
+      B_Size : constant Integer := 256 * Traceback'Length;
+      Len    : Integer := B_Size;
+      Res    : String (1 .. B_Size);
+
+      use type System.Address;
+
+   begin
+      --  The symbolic translation of an empty set of addresses is an empty
+      --  string.
+
+      if Traceback'Length = 0 then
+         return "";
+      end if;
+
+      --  If our input set of raw addresses is not empty, resort to the
+      --  libaddr2line service to symbolize it all.
+
+      --  Compute, cache and provide the absolute path to our executable file
+      --  name as the binary file where the relevant debug information is to be
+      --  found. If the executable file name resolution fails, we have no
+      --  sensible basis to invoke the symbolizer at all.
+
+      --  Protect all this against concurrent accesses explicitly, as the
+      --  underlying services are potentially thread unsafe.
+
+      TSL.Lock_Task.all;
+
+      if not Exename_Resolved then
+         Exename := locate_exec_on_path (gnat_argv (0));
+         Exename_Resolved := True;
+      end if;
+
+      if Exename /= System.Null_Address then
+         Len := Res'Length;
+         convert_addresses
+           (Exename, Traceback'Address, Traceback'Length,
+            Res (1)'Address, Len'Address);
+      end if;
+
+      TSL.Unlock_Task.all;
+
+      --  Return what the addr2line symbolizer has produced if we have called
+      --  it (the executable name resolution succeeded), or an empty string
+      --  otherwise.
+
+      if Exename /= System.Null_Address then
+         return Res (1 .. Len);
+      else
+         return "";
+      end if;
+
+   end Symbolic_Traceback;
+
+   function Symbolic_Traceback (E : Exception_Occurrence) return String is
+   begin
+      return Symbolic_Traceback (Tracebacks (E));
+   end Symbolic_Traceback;
+
+end GNAT.Traceback.Symbolic;
--- gcc/ada/gnatchop.adb.orig
+++ gcc/ada/gnatchop.adb
@@ -45,7 +45,7 @@
    Config_File_Name : constant String_Access := new String'("gnat.adc");
    --  The name of the file holding the GNAT configuration pragmas
 
-   Gcc : String_Access := new String'("gcc");
+   Gcc : String_Access := new String'("ada");
    --  May be modified by switch --GCC=
 
    Gcc_Set : Boolean := False;
--- gcc/ada/gnatlink.adb.orig
+++ gcc/ada/gnatlink.adb
@@ -137,7 +137,7 @@
    --  This table collects the arguments to be passed to compile the binder
    --  generated file.
 
-   Gcc : String_Access := Program_Name ("gcc", "gnatlink");
+   Gcc : String_Access := Program_Name ("ada", "gnatlink");
 
    Read_Mode : constant String := "r" & ASCII.NUL;
 
--- gcc/ada/gsocket.h.orig
+++ gcc/ada/gsocket.h
@@ -29,7 +29,7 @@
  *                                                                          *
  ****************************************************************************/
 
-#if defined(__nucleus__) || defined(VTHREADS) || defined(__ANDROID__)
+#if defined(__nucleus__) || defined(VTHREADS)
 
 #warning Sockets not supported on these platforms
 #undef HAVE_SOCKETS
@@ -203,8 +203,19 @@
 #include <netdb.h>
 #endif
 
-#if defined (_AIX) || defined (__FreeBSD__) || defined (__hpux__) || \
-    defined (_WIN32) || defined (__APPLE__)
+#if defined(__ANDROID__)
+#include <sys/select.h>
+#endif
+
+#if defined (_AIX) \
+ || defined (__FreeBSD__) \
+ || defined (__DragonFly__) \
+ || defined (__NetBSD__) \
+ || defined (__OpenBSD__) \
+ || defined (__ANDROID__) \
+ || defined (__hpux__) \
+ || defined (_WIN32) \
+ || defined (__APPLE__)
 # define HAVE_THREAD_SAFE_GETxxxBYyyy 1
 
 #elif defined (linux) || defined (__GLIBC__) || \
@@ -236,7 +247,13 @@
 # endif
 #endif
 
-#if defined (__FreeBSD__) || defined (__vxworks) || defined(__rtems__)
+#if defined (__FreeBSD__) \
+ || defined (__DragonFly__) \
+ || defined (__OpenBSD__) \
+ || defined (__NetBSD__) \
+ || defined (__ANDROID__) \
+ || defined (__vxworks) \
+ || defined(__rtems__)
 # define Has_Sockaddr_Len 1
 #else
 # define Has_Sockaddr_Len 0
--- gcc/ada/init.c.orig
+++ gcc/ada/init.c
@@ -1628,7 +1628,7 @@
 /* FreeBSD Section */
 /*******************/
 
-#elif defined (__FreeBSD__)
+#elif defined (__FreeBSD__) || defined (__DragonFly__)
 
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -1673,7 +1673,7 @@
 }
 
 void
-__gnat_install_handler ()
+__gnat_install_handler (void)
 {
   struct sigaction act;
 
@@ -2466,9 +2466,13 @@
    initialization of the FP processor.  This version is used under INTERIX
    and WIN32.  */
 
-#if defined (_WIN32) || defined (__INTERIX) \
-  || defined (__Lynx__) || defined(__NetBSD__) || defined(__FreeBSD__) \
-  || defined (__OpenBSD__)
+#if defined (_WIN32) \
+ || defined (__INTERIX) \
+ || defined (__Lynx__) \
+ || defined (__NetBSD__) \
+ || defined (__FreeBSD__) \
+ || defined (__DragonFly__) \
+ || defined (__OpenBSD__)
 
 #define HAVE_GNAT_INIT_FLOAT
 
--- gcc/ada/initialize.c.orig
+++ gcc/ada/initialize.c
@@ -258,8 +258,11 @@
 /* __gnat_initialize (init_float version) */
 /******************************************/
 
-#elif defined (__Lynx__) || defined (__FreeBSD__) || defined(__NetBSD__) \
-  || defined (__OpenBSD__)
+#elif defined (__Lynx__) \
+   || defined (__FreeBSD__) \
+   || defined (__DragonFly__) \
+   || defined (__NetBSD__) \
+   || defined (__OpenBSD__)
 
 extern void __gnat_init_float (void);
 
--- gcc/ada/link.c.orig
+++ gcc/ada/link.c
@@ -103,7 +103,10 @@
 unsigned char __gnat_separate_run_path_options = 0;
 const char *__gnat_default_libgcc_subdir = "lib";
 
-#elif defined (__FreeBSD__)
+#elif defined (__FreeBSD__) \
+   || defined (__DragonFly__) \
+   || defined (__OpenBSD__) \
+   || defined (__NetBSD__)
 const char *__gnat_object_file_option = "-Wl,@";
 const char *__gnat_run_path_option = "-Wl,-rpath,";
 char __gnat_shared_libgnat_default = STATIC;
--- gcc/ada/make.adb.orig
+++ gcc/ada/make.adb
@@ -670,7 +670,7 @@
    -- Compiler, Binder & Linker Data and Subprograms --
    ----------------------------------------------------
 
-   Gcc          : String_Access := Program_Name ("gcc", "gnatmake");
+   Gcc          : String_Access := Program_Name ("ada", "gnatmake");
    Original_Gcc : constant String_Access := Gcc;
    --  Original_Gcc is used to check if Gcc has been modified by a switch
    --  --GCC=, so that for VM platforms, it is not modified again, as it can
--- gcc/ada/mlib-prj.adb.orig
+++ gcc/ada/mlib-prj.adb
@@ -339,6 +339,11 @@
 
       Foreign_Sources : Boolean;
 
+      Rpath_Disabled : Boolean := False;
+      --  If -R is passed through the library options for the linker, it will
+      --  prevent the implemented libraries portion of the rpath switch from
+      --  being built, even if the linker is capable of supporting rpath.
+
       Rpath : String_Access := null;
       --  Allocated only if Path Option is supported
 
@@ -782,7 +787,7 @@
             Opts.Table (Opts.Last) :=
               new String'("-L" & Name_Buffer (1 .. Name_Len));
 
-            if Path_Option /= null then
+            if not Rpath_Disabled and then Path_Option /= null then
                Add_Rpath (Name_Buffer (1 .. Name_Len));
             end if;
 
@@ -1323,9 +1328,13 @@
                   Get_Name_String (Element.Value);
 
                   if Name_Len /= 0 then
-                     Opts.Increment_Last;
-                     Opts.Table (Opts.Last) :=
-                       new String'(Name_Buffer (1 .. Name_Len));
+                     if Name_Buffer (1 .. Name_Len) = "-R" then
+                        Rpath_Disabled := True;
+                     else
+                        Opts.Increment_Last;
+                        Opts.Table (Opts.Last) :=
+                          new String'(Name_Buffer (1 .. Name_Len));
+                     end if;
                   end if;
 
                   Current := Element.Next;
--- gcc/ada/mlib-utl.adb.orig
+++ gcc/ada/mlib-utl.adb
@@ -282,10 +282,6 @@
          if not Opt.Quiet_Output then
             Write_Str  (Ranlib_Name.all);
             Write_Char (' ');
-            for J in Ranlib_Options'Range loop
-               Write_Str  (Ranlib_Options (J).all);
-               Write_Char (' ');
-            end loop;
             Write_Line (Arguments (Ar_Options'Length + 1).all);
          end if;
 
@@ -444,7 +440,7 @@
       if Driver_Name = No_Name then
          if Gcc_Exec = null then
             if Gcc_Name = null then
-               Gcc_Name := Osint.Program_Name ("gcc", "gnatmake");
+               Gcc_Name := Osint.Program_Name ("ada", "gnatmake");
             end if;
 
             Gcc_Exec := Locate_Exec_On_Path (Gcc_Name.all);
--- gcc/ada/prj-makr.adb.orig
+++ gcc/ada/prj-makr.adb
@@ -116,7 +116,7 @@
 
    procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);
 
-   Gcc      : constant String := "gcc";
+   Gcc      : constant String := "ada";
    Gcc_Path : String_Access := null;
 
    Non_Empty_Node : constant Project_Node_Id := 1;
--- /dev/null
+++ gcc/ada/s-osinte-dragonfly.adb
@@ -0,0 +1,116 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   B o d y                                --
+--                                                                          --
+--          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the DragonFly THREADS version of this package
+
+with Interfaces.C; use Interfaces.C;
+
+package body System.OS_Interface is
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int is
+      type int_ptr is access all int;
+
+      function internal_errno return int_ptr;
+      pragma Import (C, internal_errno, "__get_errno");
+
+   begin
+      return (internal_errno.all);
+   end Errno;
+
+   --------------------
+   -- Get_Stack_Base --
+   --------------------
+
+   function Get_Stack_Base (thread : pthread_t) return Address is
+      pragma Unreferenced (thread);
+   begin
+      return Null_Address;
+   end Get_Stack_Base;
+
+   ------------------
+   -- pthread_init --
+   ------------------
+
+   procedure pthread_init is
+   begin
+      null;
+   end pthread_init;
+
+   -----------------
+   -- To_Duration --
+   -----------------
+
+   function To_Duration (TS : timespec) return Duration is
+   begin
+      return Duration (TS.ts_sec) + Duration (TS.ts_nsec) / 10#1#E9;
+   end To_Duration;
+
+   ------------------------
+   -- To_Target_Priority --
+   ------------------------
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int
+   is
+   begin
+      return Interfaces.C.int (Prio);
+   end To_Target_Priority;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return timespec'(ts_sec => S,
+                       ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-dragonfly.ads
@@ -0,0 +1,648 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the DragonFly BSD PTHREADS version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  DragonFlyBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  DragonFlyBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is new unsigned_long;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on DragonFly. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  DragonFlyBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "pthread_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In DragonFlyBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new long;
+
+   type timespec is record
+      ts_sec  : time_t;
+      ts_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is new System.Address;
+   type pthread_mutex_t     is new System.Address;
+   type pthread_mutexattr_t is new System.Address;
+   type pthread_cond_t      is new System.Address;
+   type pthread_condattr_t  is new System.Address;
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- gcc/ada/s-osinte-freebsd.adb.orig
+++ gcc/ada/s-osinte-freebsd.adb
@@ -44,7 +44,7 @@
       type int_ptr is access all int;
 
       function internal_errno return int_ptr;
-      pragma Import (C, internal_errno, "__error");
+      pragma Import (C, internal_errno, "__get_errno");
 
    begin
       return (internal_errno.all);
@@ -57,7 +57,7 @@
    function Get_Stack_Base (thread : pthread_t) return Address is
       pragma Unreferenced (thread);
    begin
-      return (0);
+      return Null_Address;
    end Get_Stack_Base;
 
    ------------------
--- gcc/ada/socket.c.orig
+++ gcc/ada/socket.c
@@ -65,7 +65,10 @@
   int                  s_port;
   __netdb_char_ptr     s_proto;
 };
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) \
+   || defined(__DragonFly__) \
+   || defined(__OpenBSD__) \
+   || defined(__NetBSD__)
 typedef unsigned int IOCTL_Req_T;
 #else
 typedef int IOCTL_Req_T;
--- gcc/ada/sysdep.c.orig
+++ gcc/ada/sysdep.c
@@ -263,6 +263,7 @@
   || defined (__MACHTEN__) || defined (__hpux__) || defined (_AIX) \
   || (defined (__svr4__) && defined (i386)) || defined (__Lynx__) \
   || defined (__CYGWIN__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+  || defined (__DragonFly__) \
   || defined (__GLIBC__) || defined (__APPLE__)
 
 # ifdef __MINGW32__
@@ -320,6 +321,7 @@
     || defined (__CYGWIN32__) || defined (__MACHTEN__) || defined (__hpux__) \
     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+    || defined (__DragonFly__) \
     || defined (__GLIBC__) || defined (__APPLE__)
   char c;
   int nread;
@@ -340,6 +342,7 @@
     || defined (__MACHTEN__) || defined (__hpux__) \
     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+    || defined (__DragonFly__) \
     || defined (__GLIBC__) || defined (__APPLE__)
       eof_ch = termios_rec.c_cc[VEOF];
 
@@ -853,8 +856,12 @@
 /* Darwin, Free BSD, Linux, where component tm_gmtoff is present in
    struct tm */
 
-#elif defined (__APPLE__) || defined (__FreeBSD__) || defined (linux) ||\
-     defined (__GLIBC__)
+#elif defined (__APPLE__) \
+  || defined (__DragonFly__) \
+  || defined (__FreeBSD__) \
+  || defined (__OpenBSD__) \
+  || defined (linux) \
+  || defined (__GLIBC__)
 {
   localtime_r (timer, &tp);
   *off = tp.tm_gmtoff;
--- /dev/null
+++ gcc/ada/system-dragonfly-x86_64.ads
@@ -0,0 +1,144 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                     (DragonFly BSD/x86_64 Version)                       --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 64;
+   Memory_Size  : constant := 2 ** 64;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Atomic_Primitives : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+
+end System;
--- gcc/ada/terminals.c.orig
+++ gcc/ada/terminals.c
@@ -31,8 +31,7 @@
 
 /* First all usupported platforms. Add stubs for exported routines. */
 
-#if defined (VMS) || defined (__vxworks) || defined (__Lynx__) || \
-    defined (__ANDROID__)
+#if defined (VMS) || defined (__vxworks) || defined (__Lynx__)
 
 void * __gnat_new_tty (void) { return (void*)0; }
 char * __gnat_tty_name (void* t) { return (char*)0; }
@@ -1010,7 +1009,11 @@
 #   include <sys/stropts.h>
 #endif
 
+#ifdef __ANDROID__
+#define CDISABLE _PC_VDISABLE
+#else
 #define CDISABLE _POSIX_VDISABLE
+#endif
 
 /* On HP-UX and Sun system, there is a bzero function but with a different
    signature. Use memset instead */
--- /dev/null
+++ gcc/ada/traceback_symbolic.c
@@ -0,0 +1,201 @@
+/*
+  Copyright (C) 1999 by Juergen Pfeifer <juergen.pfeifer@gmx.net>
+  Ada for Linux Team (ALT)
+  Heavily modified by John Marino <http://www.dragonlace.net>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, distribute with modifications, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+  IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  Except as contained in this notice, the name(s) of the above copyright
+  holders shall not be used in advertising or otherwise to promote the
+  sale, use or other dealings in this Software without prior written
+  authorization.
+*/
+
+#ifdef IS_CROSS
+
+
+/*
+ * Running addr2line doesn't make sense for cross-compiled objects.
+ * Create a dummy function to satisfy g-trasym.o
+ */
+
+void
+convert_addresses (const char *file_name ATTRIBUTE_UNUSED,
+                   void *addrs ATTRIBUTE_UNUSED,
+                   int n_addr ATTRIBUTE_UNUSED,
+                   void *buf ATTRIBUTE_UNUSED,
+                   int *len ATTRIBUTE_UNUSED)
+{
+  *len = 0;
+}
+
+#else
+
+
+/*
+ * use the external program /usr/bin/addr2line to convert addresses
+ * into file names and line numbers
+ */
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+
+#define CLOSE_SENDPIPE close(sendpipe[0]); close(sendpipe[1])
+#define CLOSE_READPIPE close(readpipe[0]); close(readpipe[1])
+#define DUP2CLOSE(oldfd, newfd) dup2(oldfd, newfd); close(oldfd);
+#define RESTSIG sigaction(SIGPIPE,&oact,NULL)
+
+#define MAX_LINE     1024
+#define PARENT_READ  readpipe[0]
+#define CHILD_WRITE  readpipe[1]
+#define CHILD_READ   sendpipe[0]
+#define PARENT_WRITE sendpipe[1]
+
+#if defined (__sun__)
+#define ADDR2LINE_PROG        "/usr/gnu/bin/addr2line"
+#else
+#define ADDR2LINE_PROG        "/usr/bin/addr2line"
+#endif
+
+void
+convert_addresses (const char *file_name,
+                   void *addrs,
+                   int   n_addr,
+                   void *buf,
+                   int  *len)
+{
+  int max_len = *len;
+  pid_t childpid;
+
+  struct sigaction act, oact;
+
+  int sendpipe[2] = {-1,-1},        /* parent -> child */
+      readpipe[2] = {-1,-1};        /* parent <- child */
+
+  *len = 0;
+  act.sa_handler = SIG_IGN;
+  sigemptyset(&act.sa_mask);
+  act.sa_flags = 0;
+  if (sigaction(SIGPIPE,&act,&oact) < 0)
+    return;
+
+  if (pipe(sendpipe) < 0) { RESTSIG; return; }
+  if (pipe(readpipe) < 0) { CLOSE_SENDPIPE; RESTSIG; return; }
+  if ((childpid = fork()) < 0) {
+    CLOSE_READPIPE;
+    CLOSE_SENDPIPE;
+    RESTSIG;
+    return;
+  }
+
+  if (childpid == 0) {    /* child process */
+    close(PARENT_WRITE);
+    close(PARENT_READ);
+    if ((CHILD_READ != STDIN_FILENO) && (CHILD_WRITE != STDOUT_FILENO)) {
+      if ((CHILD_READ == STDOUT_FILENO) && (CHILD_WRITE == STDIN_FILENO)) {
+        const int temp_fd = dup(CHILD_WRITE);
+        close (CHILD_WRITE);
+        DUP2CLOSE (CHILD_READ, STDIN_FILENO);
+        DUP2CLOSE (temp_fd,    STDOUT_FILENO);
+      }
+      else if ((CHILD_READ == STDIN_FILENO) && (CHILD_WRITE > 1)) {
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+      }
+      else if ((CHILD_READ > 1) && (CHILD_WRITE == STDOUT_FILENO)) {
+        DUP2CLOSE (CHILD_READ, STDIN_FILENO);
+      }
+      else if ((CHILD_READ > 1) && (CHILD_WRITE == STDIN_FILENO)) {
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+        DUP2CLOSE (CHILD_READ,  STDIN_FILENO);
+      }
+      else {
+        /* CHILD_READ >= 1 and CHILD_WRITE > 1 */
+        DUP2CLOSE (CHILD_READ,  STDIN_FILENO);
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+      }
+    }
+    /* As pointed out by Florian Weimer to JP, it is a security threat to call
+       the script with a user defined environment and using the path. That
+       would be Trojans pleasure.  Therefore the absolute path to addr2line
+       and an empty environment is used. That should be safe.
+    */
+    char *const argv[] = { "addr2line",
+                           "-e", file_name,
+                           "--demangle=gnat",
+                           "--functions",
+                           "--basenames",
+                           NULL };
+    char *const envp[] = { NULL };
+    if (execve(ADDR2LINE_PROG, argv, envp) < 0) {
+      close (CHILD_WRITE);
+      close (CHILD_READ);
+      RESTSIG;
+      exit (1);
+    }
+  }
+
+  /* Below this line is parent process */
+  int i, n;
+  char hex[16];
+  char line[MAX_LINE + 1];
+  char *p;
+  char *s = buf;
+  long *trace_address = addrs;
+
+  close(CHILD_WRITE);
+  close(CHILD_READ);
+
+  for(i=0; i < n_addr; i++) {
+    snprintf(hex,sizeof(hex),"%#lx\n",*trace_address);
+    write(PARENT_WRITE,hex,strlen(hex));
+    n = read(PARENT_READ,line,MAX_LINE);
+    if (n<=0)
+      break;
+
+    line[n]=0;
+    /* We have approx. 16 additional chars for "%#lx in " clause.
+       We use this info to prevent a buffer overrun. */
+    if (n + 16 + (*len) > max_len)
+      break;
+
+    p = strchr(line,'\n');
+    if (p) {
+      if (*(p+1)) {
+        *p = 0;
+        *len += snprintf(s, (max_len - (*len)), "%#lx in %s at %s",
+                         *trace_address, line, p+1);
+      }
+      else {
+        *len += snprintf(s, (max_len - (*len)), "%#lx at %s",
+                         *trace_address, line);
+      }
+      s = buf + (*len);
+    }
+    trace_address += 1;
+  }
+  close (PARENT_WRITE);
+  close (PARENT_READ);
+  RESTSIG;
+}
+
+#endif
--- gcc/ada/tracebak.c.orig
+++ gcc/ada/tracebak.c
@@ -288,6 +288,23 @@
 #error Unhandled darwin architecture.
 #endif
 
+/*---------------------------- x86 *BSD --------------------------------*/
+
+#elif defined (__i386__) &&   \
+    ( defined (__NetBSD__)    \
+   || defined (__FreeBSD__)   \
+   || defined (__OpenBSD__)   \
+   || defined (__DragonFly__) )
+
+#define USE_GCC_UNWINDER
+/* The generic unwinder is not used for this target because the default
+   implementation doesn't unwind on the BSD platforms.  AMD64 targets use the
+   gcc unwinder for all platforms, so let's keep i386 consistent with that.
+*/
+
+#define PC_ADJUST -2
+/* The minimum size of call instructions on this architecture is 2 bytes */
+
 /*---------------------- PPC AIX/PPC Lynx 178/Older Darwin ------------------*/
 #elif ((defined (_POWER) && defined (_AIX)) || \
        (defined (__powerpc__) && defined (__Lynx__) && !defined(__ELF__)) || \
--- gcc/ada/gcc-interface/Makefile.in.orig
+++ gcc/ada/gcc-interface/Makefile.in
@@ -1044,6 +1044,7 @@
 ifeq ($(strip $(filter-out arm% linux-androideabi,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS = \
   a-intnam.ads<a-intnam-linux.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-android.adb \
   s-linux.ads<s-linux-android.ads \
@@ -1056,13 +1057,11 @@
   system.ads<system-linux-armel.ads \
   a-exexpr.adb<a-exexpr-gcc.adb \
   s-excmac.ads<s-excmac-arm.ads \
-  $(DUMMY_SOCKETS_TARGET_PAIRS)
 
   TOOLS_TARGET_PAIRS =  \
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
     indepsw.adb<indepsw-gnu.adb
 
-  GNATRTL_SOCKETS_OBJS =
   EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
   EXTRA_LIBGNAT_OBJS+=raise-gcc.o sigtramp-armdroid.o
   EXTRA_GNATRTL_NONTASKING_OBJS+=g-cppexc.o s-excmac.o
@@ -1076,6 +1075,7 @@
 ifeq ($(strip $(filter-out sparc% sun solaris%,$(target_cpu) $(target_vendor) $(target_os))),)
   LIBGNAT_TARGET_PAIRS_COMMON = \
   a-intnam.ads<a-intnam-solaris.ads \
+  g-trasym.adb<g-trasym-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-solaris.adb \
   s-mudido.adb<s-mudido-affinity.adb \
@@ -1118,6 +1118,8 @@
   TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb
 
   EH_MECHANISM=-gcc
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
   THREADSLIB = -lposix4 -lthread
   MISCLIB = -lposix4 -lnsl -lsocket
   SO_OPTS = -Wl,-h,
@@ -1266,6 +1268,39 @@
   LIBRARY_VERSION := $(LIB_VERSION)
 endif
 
+# x86 android
+ifeq ($(strip $(filter-out %86 linux-android,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-linux.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-linux.ads<s-linux-android.ads \
+  s-osinte.adb<s-osinte-android.adb \
+  s-osinte.ads<s-osinte-android.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_TARGET_PAIRS) \
+  system.ads<system-linux-x86.ads
+
+  TOOLS_TARGET_PAIRS =  \
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb
+
+  EXTRA_LIBGNAT_OBJS=
+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
+  EXTRA_GNATRTL_NONTASKING_OBJS=
+  EH_MECHANISM=-gcc
+  THREADSLIB=
+  MISCLIB=
+  GMEM_LIB=
+  GNATLIB_SHARED = gnatlib-shared-dual
+  LIBRARY_VERSION := $(LIB_VERSION)
+endif
+
 # x86 kfreebsd
 ifeq ($(strip $(filter-out %86 kfreebsd%,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS = \
@@ -1330,8 +1365,11 @@
 ifeq ($(strip $(filter-out %86 freebsd%,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS = \
   a-intnam.ads<a-intnam-freebsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
   s-osinte.adb<s-osinte-freebsd.adb \
   s-osinte.ads<s-osinte-freebsd.ads \
   s-osprim.adb<s-osprim-posix.adb \
@@ -1346,6 +1384,8 @@
   mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
   GNATLIB_SHARED = gnatlib-shared-dual
 
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
   EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
 
   EH_MECHANISM=-gcc
@@ -1359,8 +1399,11 @@
 ifeq ($(strip $(filter-out %86_64 freebsd%,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS = \
   a-intnam.ads<a-intnam-freebsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
   s-osinte.adb<s-osinte-freebsd.adb \
   s-osinte.ads<s-osinte-freebsd.ads \
   s-osprim.adb<s-osprim-posix.adb \
@@ -1375,6 +1418,181 @@
   mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
   GNATLIB_SHARED = gnatlib-shared-dual
 
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+# x86_64 DragonFly
+ifeq ($(strip $(filter-out x86_64 dragonfly%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-dragonfly.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-dragonfly.adb \
+  s-osinte.ads<s-osinte-dragonfly.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  system.ads<system-dragonfly-x86_64.ads
+
+  TOOLS_TARGET_PAIRS = \
+  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+# x86 OpenBSD
+ifeq ($(strip $(filter-out %86 openbsd%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-openbsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-openbsd.adb \
+  s-osinte.ads<s-osinte-openbsd.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_TARGET_PAIRS) \
+  system.ads<system-openbsd-x86.ads
+
+  TOOLS_TARGET_PAIRS = \
+  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+
+  EH_MECHANISM=
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+# x86_64 OpenBSD
+ifeq ($(strip $(filter-out x86_64 openbsd%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-openbsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-openbsd.adb \
+  s-osinte.ads<s-osinte-openbsd.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  system.ads<system-openbsd-x86_64.ads
+
+  TOOLS_TARGET_PAIRS = \
+  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+# x86 NetBSD
+ifeq ($(strip $(filter-out %86 netbsd%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-netbsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-netbsd.adb \
+  s-osinte.ads<s-osinte-netbsd.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_TARGET_PAIRS) \
+  system.ads<system-netbsd-x86.ads
+
+  TOOLS_TARGET_PAIRS = \
+  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+# x86_64 NetBSD
+ifeq ($(strip $(filter-out x86_64 netbsd%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-netbsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-netbsd.adb \
+  s-osinte.ads<s-osinte-netbsd.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  system.ads<system-netbsd-x86_64.ads
+
+  TOOLS_TARGET_PAIRS = \
+  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
   EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
 
   EH_MECHANISM=-gcc
--- gcc/ada/gcc-interface/Make-lang.in.orig
+++ gcc/ada/gcc-interface/Make-lang.in
@@ -584,7 +584,7 @@
  ada/widechar.o
 
 # Language-independent object files.
-ADA_BACKEND = $(BACKEND) attribs.o
+ADA_BACKEND = $(BACKEND2) attribs.o
 
 # List of target dependent sources, overridden below as necessary
 TARGET_ADA_SRCS =
--- gnattools/configure.ac.orig
+++ gnattools/configure.ac
@@ -79,11 +79,27 @@
     mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb \
     indepsw.adb<indepsw-darwin.adb"
     ;;
+  *-*-dragonfly*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
   *-*-freebsd*)
     TOOLS_TARGET_PAIRS="\
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
     indepsw.adb<indepsw-gnu.adb"
     ;;
+  *-*-netbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *-*-openbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  # Next line covers arm*-*-linux-androideabi
   *-*-linux*)
     TOOLS_TARGET_PAIRS="\
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
--- gnattools/configure.orig
+++ gnattools/configure
@@ -2039,11 +2039,27 @@
     mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb \
     indepsw.adb<indepsw-darwin.adb"
     ;;
+  *-*-dragonfly*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
   *-*-freebsd*)
     TOOLS_TARGET_PAIRS="\
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
     indepsw.adb<indepsw-gnu.adb"
     ;;
+  *-*-netbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *-*-openbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  # Next line covers arm*-*-linux-androideabi
   *-*-linux*)
     TOOLS_TARGET_PAIRS="\
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
