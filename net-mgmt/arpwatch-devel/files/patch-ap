--- util.c.orig	Fri Oct 13 18:49:03 2000
+++ util.c	Fri Jun 11 12:35:32 2004
@@ -39,6 +39,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <syslog.h>
+#include <dirent.h>

 #include "gnuc.h"
 #ifdef HAVE_OS_PROTO_H
@@ -53,8 +54,11 @@

 char *arpdir = ARPDIR;
 char *arpfile = ARPFILE;
+char *etherfile = ETHERFILE;
 char *ethercodes = ETHERCODES;

+struct ifdesc *if_desc = NULL;
+
 /* Broadcast ethernet addresses */
 u_char zero[6] = { 0, 0, 0, 0, 0, 0 };
 u_char allones[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@@ -105,7 +109,7 @@
 dump(void)
 {
 	register int fd;
-	char oldarpfile[256], newarpfile[256];
+	char oldarpfile[256], newarpfile[256], *oldetherfile, *newetherfile;

 	(void)sprintf(oldarpfile, "%s-", arpfile);
 	(void)sprintf(newarpfile, "%s.new", arpfile);
@@ -130,6 +134,32 @@
 		syslog(LOG_ERR, "rename %s -> %s: %m", newarpfile, arpfile);
 		return(0);
 	}
+
+	/* ether info */
+	(void)asprintf(&oldetherfile, "%s-", etherfile);
+	(void)asprintf(&newetherfile, "%s.new", etherfile);
+
+	if ((fd = creat(newetherfile, 0644)) < 0) {
+		syslog(LOG_ERR, "creat(%s): %m", newetherfile);
+		return(0);
+	}
+	if ((dumpf = fdopen(fd, "w")) == NULL) {
+		syslog(LOG_ERR, "fdopen(%s): %m", newetherfile);
+		return(0);
+	}
+
+	fwrite(einfo_table, sizeof(struct einfo), et_cnt, dumpf);
+
+	(void)fclose(dumpf);
+	if (rename(etherfile, oldetherfile) < 0) {
+		syslog(LOG_ERR, "rename %s -> %s: %m", etherfile, oldetherfile);
+		return(0);
+	}
+	if (rename(newetherfile, etherfile) < 0) {
+		syslog(LOG_ERR, "rename %s -> %s: %m", newetherfile, etherfile);
+		return(0);
+	}
+
 	return(1);
 }

@@ -138,7 +168,64 @@
 readdata(void)
 {
 	register FILE *f;
+	char line[1024];
+	char buf[MAXNAMLEN];
+	char path[MAXNAMLEN + 1];
+	int len, i;
+	DIR *dirp;
+	struct dirent *dp;
+	struct ifdesc *idp;
+
+	/* interface descriptions */
+	if ((dirp = opendir(arpdir)) == NULL)
+	  {
+	    syslog(LOG_ERR, "opendir(%s)", arpdir);
+	    return(0);
+	  }
+
+	idp = if_desc = (struct ifdesc *) malloc(sizeof(struct ifdesc));
+	idp->name = idp->desc = NULL;
+	idp->next = NULL;
+
+	while ((dp = readdir(dirp)) != NULL)
+	  {
+	    if (dp->d_type == DT_LNK)
+	      {
+		for (i=0; i < dp->d_namlen; i++)
+		  path[i] = dp->d_name[i];
+
+		path[dp->d_namlen] = '\0';
+
+		if ((len = readlink(path, buf, MAXNAMLEN)) == -1)
+		  {
+		    syslog(LOG_ERR, "readlink(path) failed");
+		    return(0);
+		  }
+
+		buf[len] = '\0';
+
+		idp->next = (struct ifdesc *) malloc(sizeof(struct ifdesc));
+		idp = idp->next;
+		idp->next = NULL;
+		asprintf(&idp->name, "%s", path);
+		asprintf(&idp->desc, "%s", buf);
+	      }
+	  }
+
+	if (if_desc->next == NULL)
+	  {
+	    free(if_desc);
+	    idp = if_desc = NULL;
+	  }
+	else
+	  {
+	    idp = if_desc;
+	    if_desc = if_desc->next;
+	    free(idp);
+	    idp = NULL;
+	  }

+	/* arp.dat */
 	if ((f = fopen(arpfile, "r")) == NULL) {
 		syslog(LOG_ERR, "fopen(%s): %m", arpfile);
 		return(0);
@@ -147,6 +234,15 @@
 		(void)fclose(f);
 		return(0);
 	}
+	(void)fclose(f);
+
+	/* ether.dat */
+	if ((f = fopen(etherfile, "r")) == NULL) {
+	        syslog(LOG_ERR, "fopen(%s): %m", etherfile);
+		return(0);
+	}
+
+	et_cnt = fread(einfo_table, sizeof(struct einfo), HASHSIZE, f);
 	(void)fclose(f);

 	/* It's not fatal if we can't open the ethercodes file */
