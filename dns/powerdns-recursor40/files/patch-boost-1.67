https://github.com/PowerDNS/pdns/commit/e6a9dde524b5

--- arguments.cc.orig	2018-11-06 14:56:58 UTC
+++ arguments.cc
@@ -443,7 +443,7 @@ bool ArgvMap::file(const char *fname, bo
     set("include-dir","Directory to include configuration files from");
 
   if(!parseFile(fname, "", lax)) {
-    L << Logger::Warning << "Unable to open " << fname << std::endl;
+    g_log << Logger::Warning << "Unable to open " << fname << std::endl;
     return false;
   }
 
@@ -453,7 +453,7 @@ bool ArgvMap::file(const char *fname, bo
     gatherIncludes(extraConfigs); 
     for(const std::string& fn :  extraConfigs) {
       if (!file(fn.c_str(), lax, true)) {
-        L << Logger::Error << fn << " could not be parsed" << std::endl;
+        g_log << Logger::Error << fn << " could not be parsed" << std::endl;
         throw ArgException(fn + " could not be parsed");
       }
     }
@@ -471,18 +471,18 @@ void ArgvMap::gatherIncludes(std::vector
 
     // stat
     if (stat(params["include-dir"].c_str(), &st)) {
-       L << Logger::Error << params["include-dir"] << " does not exist!" << std::endl;
+       g_log << Logger::Error << params["include-dir"] << " does not exist!" << std::endl;
        throw ArgException(params["include-dir"] + " does not exist!");
     }
 
     // wonder if it's accessible directory
     if (!S_ISDIR(st.st_mode)) {
-       L << Logger::Error << params["include-dir"] << " is not a directory" << std::endl;
+       g_log << Logger::Error << params["include-dir"] << " is not a directory" << std::endl;
        throw ArgException(params["include-dir"] + " is not a directory");
     }
 
     if (!(dir = opendir(params["include-dir"].c_str()))) {
-       L << Logger::Error << params["include-dir"] << " is not accessible" << std::endl;
+       g_log << Logger::Error << params["include-dir"] << " is not accessible" << std::endl;
        throw ArgException(params["include-dir"] + " is not accessible");
     }
 
@@ -494,7 +494,7 @@ void ArgvMap::gatherIncludes(std::vector
         namebuf << params["include-dir"].c_str() << "/" << ent->d_name; // FIXME: Use some path separator
         // ensure it's readable file
         if (stat(namebuf.str().c_str(), &st) || !S_ISREG(st.st_mode)) {
-          L << Logger::Error << namebuf.str() << " is not a file" << std::endl;
+          g_log << Logger::Error << namebuf.str() << " is not a file" << std::endl;
           closedir(dir);
           throw ArgException(namebuf.str() + " does not exist!");
         }
--- dns.hh.orig	2018-11-06 14:56:58 UTC
+++ dns.hh
@@ -241,7 +241,6 @@ inline uint16_t * getFlagsFromDNSHeader(
 #define FLAGS_CD_OFFSET (12)
 #endif
 
-#define L theL()
 extern time_t s_starttime;
 
 uint32_t hashQuestion(const char* packet, uint16_t len, uint32_t init);
--- gss_context.cc.orig	2018-11-06 14:56:58 UTC
+++ gss_context.cc
@@ -456,17 +456,17 @@ bool gss_add_signature(const DNSName& co
   string tmp_mac;
   GssContext gssctx(context);
   if (!gssctx.valid()) {
-    L<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
+    g_log<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
 
   if (!gssctx.sign(message, tmp_mac)) {
-    L<<Logger::Error<<"Could not sign message using GSS context '"<<context<<"'"<<endl;
+    g_log<<Logger::Error<<"Could not sign message using GSS context '"<<context<<"'"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
@@ -477,17 +477,17 @@ bool gss_add_signature(const DNSName& co
 bool gss_verify_signature(const DNSName& context, const std::string& message, const std::string& mac) {
   GssContext gssctx(context);
   if (!gssctx.valid()) {
-    L<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
+    g_log<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
 
   if (!gssctx.verify(message, mac)) {
-    L<<Logger::Error<<"Could not verify message using GSS context '"<<context<<"'"<<endl;
+    g_log<<Logger::Error<<"Could not verify message using GSS context '"<<context<<"'"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
--- logger.cc.orig	2018-11-06 14:56:58 UTC
+++ logger.cc
@@ -32,15 +32,9 @@ extern StatBag S;
 #include "namespaces.hh"
 
 pthread_once_t Logger::s_once;
-pthread_key_t Logger::s_loggerKey;
+pthread_key_t Logger::g_loggerKey;
 
-Logger &theL(const string &pname)
-{
-  static Logger l("", LOG_DAEMON);
-  if(!pname.empty())
-    l.setName(pname);
-  return l;
-}
+Logger g_log("", LOG_DAEMON);
 
 void Logger::log(const string &msg, Urgency u)
 {
@@ -102,7 +96,7 @@ void Logger::setName(const string &_name
 
 void Logger::initKey()
 {
-  if(pthread_key_create(&s_loggerKey, perThreadDestructor))
+  if(pthread_key_create(&g_loggerKey, perThreadDestructor))
     unixDie("Creating thread key for logger");
 }
 
@@ -137,13 +131,13 @@ void Logger::perThreadDestructor(void* b
 
 Logger::PerThread* Logger::getPerThread()
 {
-  void *buf=pthread_getspecific(s_loggerKey);
+  void *buf=pthread_getspecific(g_loggerKey);
   PerThread* ret;
   if(buf)
     ret = (PerThread*) buf;
   else {
     ret = new PerThread();
-    pthread_setspecific(s_loggerKey, (void*)ret);
+    pthread_setspecific(g_loggerKey, (void*)ret);
   }
   return ret;
 }
--- logger.hh.orig	2018-11-06 14:56:58 UTC
+++ logger.hh
@@ -66,9 +66,9 @@ public:
   void resetFlags(){flags=0;open();} //!< zero the flags
   /** Use this to stream to your log, like this:
       \code
-      L<<"This is an informational message"<<endl; // logged at default loglevel (Info)
-      L<<Logger::Warning<<"Out of diskspace"<<endl; // Logged as a warning 
-      L<<"This is an informational message"<<endl; // logged AGAIN at default loglevel (Info)
+      g_log<<"This is an informational message"<<endl; // logged at default loglevel (Info)
+      g_log<<Logger::Warning<<"Out of diskspace"<<endl; // Logged as a warning 
+      g_log<<"This is an informational message"<<endl; // logged AGAIN at default loglevel (Info)
       \endcode
   */
   Logger& operator<<(const char *s);
@@ -108,10 +108,10 @@ private:
   bool opened;
   bool d_disableSyslog;
   static pthread_once_t s_once;
-  static pthread_key_t s_loggerKey;
+  static pthread_key_t g_loggerKey;
 };
 
-extern Logger &theL(const string &pname="");
+extern Logger g_log;
 
 #ifdef VERBOSELOG
 #define DLOG(x) x
--- lua-recursor4.cc.orig	2018-11-06 14:56:58 UTC
+++ lua-recursor4.cc
@@ -78,7 +78,6 @@ int RecursorLua4::gettag(const ComboAddr
 
 
 #else
-#undef L
 #include "ext/luawrapper/include/LuaContext.hpp"
 
 static int followCNAMERecords(vector<DNSRecord>& ret, const QType& qtype)
@@ -309,7 +308,7 @@ RecursorLua4::RecursorLua4(const std::st
           cas.insert(boost::get<ComboAddress>(in));
         }
       }
-      catch(std::exception& e) { theL() <<Logger::Error<<e.what()<<endl; }
+      catch(std::exception& e) { g_log <<Logger::Error<<e.what()<<endl; }
     });
 
   d_lw->registerFunction<bool(cas_t::*)(const ComboAddress&)>("check",[](const cas_t& cas, const ComboAddress&ca) {
@@ -463,7 +462,7 @@ RecursorLua4::RecursorLua4(const std::st
         }
       }
       catch(std::exception& e) {
-        theL() <<Logger::Error<<e.what()<<endl;
+        g_log <<Logger::Error<<e.what()<<endl;
       }
     }
   );
@@ -473,7 +472,7 @@ RecursorLua4::RecursorLua4(const std::st
 
 
   d_lw->writeFunction("pdnslog", [](const std::string& msg, boost::optional<int> loglevel) {
-      theL() << (Logger::Urgency)loglevel.get_value_or(Logger::Warning) << msg<<endl;
+      g_log << (Logger::Urgency)loglevel.get_value_or(Logger::Warning) << msg<<endl;
     });
   typedef vector<pair<string, int> > in_t;
   vector<pair<string, boost::variant<int, in_t, struct timeval* > > >  pd{
@@ -649,7 +648,7 @@ loop:;
         dq->udpAnswer = GenUDPQueryResponse(dq->udpQueryDest, dq->udpQuery);
         auto cbFunc = d_lw->readVariable<boost::optional<luacall_t>>(dq->udpCallback).get_value_or(0);
         if(!cbFunc) {
-          theL()<<Logger::Error<<"Attempted callback for Lua UDP Query/Response which could not be found"<<endl;
+          g_log<<Logger::Error<<"Attempted callback for Lua UDP Query/Response which could not be found"<<endl;
           return false;
         }
         bool result=cbFunc(dq);
--- lwres.cc.orig	2018-11-06 14:56:58 UTC
+++ lwres.cc
@@ -236,7 +236,7 @@ int asyncresolve(const ComboAddress& ip,
 
     if(domain != mdp.d_qname) { 
       if(!mdp.d_qname.empty() && domain.toString().find((char)0) == string::npos /* ugly */) {// embedded nulls are too noisy, plus empty domains are too
-        L<<Logger::Notice<<"Packet purporting to come from remote server "<<ip.toString()<<" contained wrong answer: '" << domain << "' != '" << mdp.d_qname << "'" << endl;
+        g_log<<Logger::Notice<<"Packet purporting to come from remote server "<<ip.toString()<<" contained wrong answer: '" << domain << "' != '" << mdp.d_qname << "'" << endl;
       }
       // unexpected count has already been done @ pdns_recursor.cc
       goto out;
@@ -276,7 +276,7 @@ int asyncresolve(const ComboAddress& ip,
   }
   catch(std::exception &mde) {
     if(::arg().mustDo("log-common-errors"))
-      L<<Logger::Notice<<"Unable to parse packet from remote server "<<ip.toString()<<": "<<mde.what()<<endl;
+      g_log<<Logger::Notice<<"Unable to parse packet from remote server "<<ip.toString()<<": "<<mde.what()<<endl;
     lwr->d_rcode = RCode::FormErr;
     g_stats.serverParseError++;
 #ifdef HAVE_PROTOBUF
@@ -287,7 +287,7 @@ int asyncresolve(const ComboAddress& ip,
     return 1; // success - oddly enough
   }
   catch(...) {
-    L<<Logger::Notice<<"Unknown error parsing packet from remote server"<<endl;
+    g_log<<Logger::Notice<<"Unknown error parsing packet from remote server"<<endl;
   }
   
   g_stats.serverParseError++; 
--- pdns_recursor.cc.orig	2018-11-06 14:56:58 UTC
+++ pdns_recursor.cc
@@ -347,12 +347,12 @@ void setSocketBuffer(int fd, int optname
   socklen_t len=sizeof(psize);
 
   if(!getsockopt(fd, SOL_SOCKET, optname, (char*)&psize, &len) && psize > size) {
-    L<<Logger::Error<<"Not decreasing socket buffer size from "<<psize<<" to "<<size<<endl;
+    g_log<<Logger::Error<<"Not decreasing socket buffer size from "<<psize<<" to "<<size<<endl;
     return;
   }
 
   if (setsockopt(fd, SOL_SOCKET, optname, (char*)&size, sizeof(size)) < 0 )
-    L<<Logger::Error<<"Unable to raise socket buffer size to "<<size<<": "<<strerror(errno)<<endl;
+    g_log<<Logger::Error<<"Unable to raise socket buffer size to "<<size<<": "<<strerror(errno)<<endl;
 }
 
 
@@ -395,7 +395,7 @@ public:
         closesocket(*fd);
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing UDP socket after connect() failed: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing UDP socket after connect() failed: "<<e.reason<<endl;
       }
 
       if(err==ENETUNREACH) // Seth "My Interfaces Are Like A Yo Yo" Arnold special
@@ -433,7 +433,7 @@ public:
       closesocket(*i);
     }
     catch(const PDNSException& e) {
-      L<<Logger::Error<<"Error closing returned UDP socket: "<<e.reason<<endl;
+      g_log<<Logger::Error<<"Error closing returned UDP socket: "<<e.reason<<endl;
     }
 
     d_socks.erase(i++);
@@ -549,7 +549,7 @@ int arecvfrom(char *data, size_t len, in
     *d_len=packet.size();
     memcpy(data,packet.c_str(),min(len,*d_len));
     if(*nearMissLimit && pident.nearMisses > *nearMissLimit) {
-      L<<Logger::Error<<"Too many ("<<pident.nearMisses<<" > "<<*nearMissLimit<<") bogus answers for '"<<domain<<"' from "<<fromaddr.toString()<<", assuming spoof attempt."<<endl;
+      g_log<<Logger::Error<<"Too many ("<<pident.nearMisses<<" > "<<*nearMissLimit<<") bogus answers for '"<<domain<<"' from "<<fromaddr.toString()<<", assuming spoof attempt."<<endl;
       g_stats.spoofCount++;
       return -1;
     }
@@ -571,7 +571,7 @@ static void writePid(void)
   if(of)
     of<< Utility::getpid() <<endl;
   else
-    L<<Logger::Error<<"Writing pid for "<<Utility::getpid()<<" to "<<s_pidfname<<" failed: "<<strerror(errno)<<endl;
+    g_log<<Logger::Error<<"Writing pid for "<<Utility::getpid()<<" to "<<s_pidfname<<" failed: "<<strerror(errno)<<endl;
 }
 
 typedef map<ComboAddress, uint32_t, ComboAddress::addressOnlyLessThan> tcpClientCounts_t;
@@ -587,10 +587,10 @@ TCPConnection::~TCPConnection()
 {
   try {
     if(closesocket(d_fd) < 0)
-      L<<Logger::Error<<"Error closing socket for TCPConnection"<<endl;
+      g_log<<Logger::Error<<"Error closing socket for TCPConnection"<<endl;
   }
   catch(const PDNSException& e) {
-    L<<Logger::Error<<"Error closing TCPConnection socket: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Error closing TCPConnection socket: "<<e.reason<<endl;
   }
 
   if(t_tcpClientCounts->count(d_remote) && !(*t_tcpClientCounts)[d_remote]--)
@@ -798,12 +798,12 @@ void startDoResolve(void *p)
 
 
     if(!g_quiet || tracedQuery) {
-      L<<Logger::Warning<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] " << (dc->d_tcp ? "TCP " : "") << "question for '"<<dc->d_mdp.d_qname<<"|"
+      g_log<<Logger::Warning<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] " << (dc->d_tcp ? "TCP " : "") << "question for '"<<dc->d_mdp.d_qname<<"|"
        <<DNSRecordContent::NumberToType(dc->d_mdp.d_qtype)<<"' from "<<dc->getRemote();
       if(!dc->d_ednssubnet.source.empty()) {
-        L<<" (ecs "<<dc->d_ednssubnet.source.toString()<<")";
+        g_log<<" (ecs "<<dc->d_ednssubnet.source.toString()<<")";
       }
-      L<<endl;
+      g_log<<endl;
     }
 
     sr.setId(MT->getTid());
@@ -866,7 +866,7 @@ void startDoResolve(void *p)
       }
       catch(ImmediateServFailException &e) {
         if(g_logCommonErrors)
-          L<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during resolve of '"<<dc->d_mdp.d_qname<<"' because: "<<e.reason<<endl;
+          g_log<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during resolve of '"<<dc->d_mdp.d_qname<<"' because: "<<e.reason<<endl;
         res = RCode::ServFail;
       }
 
@@ -986,7 +986,7 @@ void startDoResolve(void *p)
         boost::split(lines, trace, boost::is_any_of("\n"));
         for(const string& line : lines) {
           if(!line.empty())
-            L<<Logger::Warning<< line << endl;
+            g_log<<Logger::Warning<< line << endl;
         }
       }
     }
@@ -1003,7 +1003,7 @@ void startDoResolve(void *p)
       if(!shouldNotValidate && (g_dnssecmode == DNSSECMode::ValidateAll || g_dnssecmode==DNSSECMode::ValidateForLog || ((dc->d_mdp.d_header.ad || DNSSECOK) && g_dnssecmode==DNSSECMode::Process))) {
         try {
           if(sr.doLog()) {
-            L<<Logger::Warning<<"Starting validation of answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<endl;
+            g_log<<Logger::Warning<<"Starting validation of answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<endl;
           }
           
           ResolveContext ctx;
@@ -1013,7 +1013,7 @@ void startDoResolve(void *p)
           auto state=validateRecords(ctx, ret);
           if(state == Secure) {
             if(sr.doLog()) {
-              L<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates correctly"<<endl;
+              g_log<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates correctly"<<endl;
             }
             
             // Is the query source interested in the value of the ad-bit?
@@ -1022,34 +1022,34 @@ void startDoResolve(void *p)
           }
           else if(state == Insecure) {
             if(sr.doLog()) {
-              L<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Insecure"<<endl;
+              g_log<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Insecure"<<endl;
             }
             
             pw.getHeader()->ad=0;
           }
           else if(state == Bogus) {
             if(g_dnssecLogBogus || sr.doLog() || g_dnssecmode == DNSSECMode::ValidateForLog) {
-              L<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Bogus"<<endl;
+              g_log<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Bogus"<<endl;
             }
             
             // Does the query or validation mode sending out a SERVFAIL on validation errors?
             if(!pw.getHeader()->cd && (g_dnssecmode == DNSSECMode::ValidateAll || dc->d_mdp.d_header.ad || DNSSECOK)) {
               if(sr.doLog()) {
-                L<<Logger::Warning<<"Sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" because recursor or query demands it for Bogus results"<<endl;
+                g_log<<Logger::Warning<<"Sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" because recursor or query demands it for Bogus results"<<endl;
               }
               
               pw.getHeader()->rcode=RCode::ServFail;
               goto sendit;
             } else {
               if(sr.doLog()) {
-                L<<Logger::Warning<<"Not sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" Bogus validation since neither config nor query demands this"<<endl;
+                g_log<<Logger::Warning<<"Not sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" Bogus validation since neither config nor query demands this"<<endl;
               }
             }
           }
         }
         catch(ImmediateServFailException &e) {
           if(g_logCommonErrors)
-            L<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during validation of '"<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<"' because: "<<e.reason<<endl;
+            g_log<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during validation of '"<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<"' because: "<<e.reason<<endl;
           pw.getHeader()->rcode=RCode::ServFail;
           goto sendit;
         }
@@ -1132,7 +1132,7 @@ void startDoResolve(void *p)
 	addCMsgSrcAddr(&msgh, cbuf, &dc->d_local, 0);
       }
       if(sendmsg(dc->d_socket, &msgh, 0) < 0 && g_logCommonErrors) 
-        L<<Logger::Warning<<"Sending UDP reply to client "<<dc->d_remote.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
+        g_log<<Logger::Warning<<"Sending UDP reply to client "<<dc->d_remote.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
       if(!SyncRes::s_nopacketcache && !variableAnswer && !sr.wasVariable() ) {
         t_packetCache->insertResponsePacket(dc->d_tag, dc->d_mdp.d_qname, dc->d_mdp.d_qtype, dc->d_mdp.d_qclass, dc->d_query,
                                             string((const char*)&*packet.begin(), packet.size()),
@@ -1157,11 +1157,11 @@ void startDoResolve(void *p)
       bool hadError=true;
 
       if(wret == 0)
-        L<<Logger::Error<<"EOF writing TCP answer to "<<dc->getRemote()<<endl;
+        g_log<<Logger::Error<<"EOF writing TCP answer to "<<dc->getRemote()<<endl;
       else if(wret < 0 )
-        L<<Logger::Error<<"Error writing TCP answer to "<<dc->getRemote()<<": "<< strerror(errno) <<endl;
+        g_log<<Logger::Error<<"Error writing TCP answer to "<<dc->getRemote()<<": "<< strerror(errno) <<endl;
       else if((unsigned int)wret != 2 + packet.size())
-        L<<Logger::Error<<"Oops, partial answer sent to "<<dc->getRemote()<<" for "<<dc->d_mdp.d_qname<<" (size="<< (2 + packet.size()) <<", sent "<<wret<<")"<<endl;
+        g_log<<Logger::Error<<"Oops, partial answer sent to "<<dc->getRemote()<<" for "<<dc->d_mdp.d_qname<<" (size="<< (2 + packet.size()) <<", sent "<<wret<<")"<<endl;
       else
         hadError=false;
 
@@ -1180,8 +1180,8 @@ void startDoResolve(void *p)
     }
 
     if(!g_quiet) {
-      L<<Logger::Error<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] answer to "<<(dc->d_mdp.d_header.rd?"":"non-rd ")<<"question '"<<dc->d_mdp.d_qname<<"|"<<DNSRecordContent::NumberToType(dc->d_mdp.d_qtype);
-      L<<"': "<<ntohs(pw.getHeader()->ancount)<<" answers, "<<ntohs(pw.getHeader()->arcount)<<" additional, took "<<sr.d_outqueries<<" packets, "<<
+      g_log<<Logger::Error<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] answer to "<<(dc->d_mdp.d_header.rd?"":"non-rd ")<<"question '"<<dc->d_mdp.d_qname<<"|"<<DNSRecordContent::NumberToType(dc->d_mdp.d_qtype);
+      g_log<<"': "<<ntohs(pw.getHeader()->ancount)<<" answers, "<<ntohs(pw.getHeader()->arcount)<<" additional, took "<<sr.d_outqueries<<" packets, "<<
 	sr.d_totUsec/1000.0<<" ms, "<<
 	sr.d_throttledqueries<<" throttled, "<<sr.d_timeouts<<" timeouts, "<<sr.d_tcpoutqueries<<" tcp connections, rcode="<<res<<endl;
     }
@@ -1208,28 +1208,28 @@ void startDoResolve(void *p)
     dc=0;
   }
   catch(PDNSException &ae) {
-    L<<Logger::Error<<"startDoResolve problem "<<makeLoginfo(dc)<<": "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"startDoResolve problem "<<makeLoginfo(dc)<<": "<<ae.reason<<endl;
     delete dc;
   }
   catch(MOADNSException& e) {
-    L<<Logger::Error<<"DNS parser error "<<makeLoginfo(dc) <<": "<<dc->d_mdp.d_qname<<", "<<e.what()<<endl;
+    g_log<<Logger::Error<<"DNS parser error "<<makeLoginfo(dc) <<": "<<dc->d_mdp.d_qname<<", "<<e.what()<<endl;
     delete dc;
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"STL error "<< makeLoginfo(dc)<<": "<<e.what();
+    g_log<<Logger::Error<<"STL error "<< makeLoginfo(dc)<<": "<<e.what();
 
     // Luawrapper nests the exception from Lua, so we unnest it here
     try {
         std::rethrow_if_nested(e);
     } catch(const std::exception& e) {
-        L<<". Extra info: "<<e.what();
+        g_log<<". Extra info: "<<e.what();
     } catch(...) {}
 
-    L<<endl;
+    g_log<<endl;
     delete dc;
   }
   catch(...) {
-    L<<Logger::Error<<"Any other exception in a resolver context "<< makeLoginfo(dc) <<endl;
+    g_log<<Logger::Error<<"Any other exception in a resolver context "<< makeLoginfo(dc) <<endl;
   }
 
   g_stats.maxMThreadStackUsage = max(MT->getMaxStackUsage(), g_stats.maxMThreadStackUsage);
@@ -1322,7 +1322,7 @@ void handleRunningTCPQuestion(int fd, FD
     }
     if(!bytes || bytes < 0) {
       if(g_logCommonErrors)
-        L<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected after first byte"<<endl;
+        g_log<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected after first byte"<<endl;
       t_fdm->removeReadFD(fd);
       return;
     }
@@ -1330,7 +1330,7 @@ void handleRunningTCPQuestion(int fd, FD
   else if(conn->state==TCPConnection::GETQUESTION) {
     ssize_t bytes=recv(conn->getFD(), conn->data + conn->bytesread, conn->qlen - conn->bytesread, 0);
     if(!bytes || bytes < 0 || bytes > std::numeric_limits<std::uint16_t>::max()) {
-      L<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected while reading question body"<<endl;
+      g_log<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected while reading question body"<<endl;
       t_fdm->removeReadFD(fd);
       return;
     }
@@ -1345,7 +1345,7 @@ void handleRunningTCPQuestion(int fd, FD
       catch(MOADNSException &mde) {
         g_stats.clientParseError++;
         if(g_logCommonErrors)
-          L<<Logger::Error<<"Unable to parse packet from TCP client "<< conn->d_remote.toString() <<endl;
+          g_log<<Logger::Error<<"Unable to parse packet from TCP client "<< conn->d_remote.toString() <<endl;
         return;
       }
       dc->d_tcpConnection = conn; // carry the torch
@@ -1381,14 +1381,14 @@ void handleRunningTCPQuestion(int fd, FD
             }
             catch(std::exception& e)  {
               if(g_logCommonErrors)
-                L<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
+                g_log<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
             }
           }
         }
         catch(std::exception& e)
         {
           if(g_logCommonErrors)
-            L<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
+            g_log<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
         }
       }
 #ifdef HAVE_PROTOBUF
@@ -1404,20 +1404,20 @@ void handleRunningTCPQuestion(int fd, FD
         }
         catch(std::exception& e) {
           if(g_logCommonErrors)
-            L<<Logger::Warning<<"Error parsing a TCP query packet for edns subnet: "<<e.what()<<endl;
+            g_log<<Logger::Warning<<"Error parsing a TCP query packet for edns subnet: "<<e.what()<<endl;
         }
       }
 #endif
       if(dc->d_mdp.d_header.qr) {
         delete dc;
         g_stats.ignoredCount++;
-        L<<Logger::Error<<"Ignoring answer from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
+        g_log<<Logger::Error<<"Ignoring answer from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
         return;
       }
       if(dc->d_mdp.d_header.opcode) {
         delete dc;
         g_stats.ignoredCount++;
-        L<<Logger::Error<<"Ignoring non-query opcode from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
+        g_log<<Logger::Error<<"Ignoring non-query opcode from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
         return;
       }
       else {
@@ -1443,7 +1443,7 @@ void handleNewTCPQuestion(int fd, FDMult
         closesocket(newsock);
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing TCP socket after an over capacity drop: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing TCP socket after an over capacity drop: "<<e.reason<<endl;
       }
       return;
     }
@@ -1452,14 +1452,14 @@ void handleNewTCPQuestion(int fd, FDMult
       t_remotes->push_back(addr);
     if(t_allowFrom && !t_allowFrom->match(&addr)) {
       if(!g_quiet)
-        L<<Logger::Error<<"["<<MT->getTid()<<"] dropping TCP query from "<<addr.toString()<<", address not matched by allow-from"<<endl;
+        g_log<<Logger::Error<<"["<<MT->getTid()<<"] dropping TCP query from "<<addr.toString()<<", address not matched by allow-from"<<endl;
 
       g_stats.unauthorizedTCP++;
       try {
         closesocket(newsock);
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing TCP socket after an ACL drop: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing TCP socket after an ACL drop: "<<e.reason<<endl;
       }
       return;
     }
@@ -1469,7 +1469,7 @@ void handleNewTCPQuestion(int fd, FDMult
         closesocket(newsock); // don't call TCPConnection::closeAndCleanup here - did not enter it in the counts yet!
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing TCP socket after an overflow drop: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing TCP socket after an overflow drop: "<<e.reason<<endl;
       }
       return;
     }
@@ -1547,14 +1547,14 @@ string* doProcessUDPQuestion(const std::
           }
           catch(std::exception& e)  {
             if(g_logCommonErrors)
-              L<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
+              g_log<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
           }
         }
       }
       catch(std::exception& e)
       {
         if(g_logCommonErrors)
-          L<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
+          g_log<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
       }
     }
 
@@ -1579,7 +1579,7 @@ string* doProcessUDPQuestion(const std::
       }
 #endif /* HAVE_PROTOBUF */
       if(!g_quiet)
-        L<<Logger::Notice<<t_id<< " question answered from packet cache tag="<<ctag<<" from "<<fromaddr.toString()<<endl;
+        g_log<<Logger::Notice<<t_id<< " question answered from packet cache tag="<<ctag<<" from "<<fromaddr.toString()<<endl;
 
       g_stats.packetCacheHits++;
       SyncRes::s_queries++;
@@ -1594,7 +1594,7 @@ string* doProcessUDPQuestion(const std::
 	addCMsgSrcAddr(&msgh, cbuf, &destaddr, 0);
       }
       if(sendmsg(fd, &msgh, 0) < 0 && g_logCommonErrors)
-        L<<Logger::Warning<<"Sending UDP reply to client "<<fromaddr.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
+        g_log<<Logger::Warning<<"Sending UDP reply to client "<<fromaddr.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
 
       if(response.length() >= sizeof(struct dnsheader)) {
         struct dnsheader tmpdh;
@@ -1606,14 +1606,14 @@ string* doProcessUDPQuestion(const std::
     }
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Error processing or aging answer packet: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Error processing or aging answer packet: "<<e.what()<<endl;
     return 0;
   }
 
   if(t_pdl->get()) {
     if((*t_pdl)->ipfilter(fromaddr, destaddr, *dh)) {
       if(!g_quiet)
-	L<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<" based on policy"<<endl;
+	g_log<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<" based on policy"<<endl;
       g_stats.policyDrops++;
       return 0;
     }
@@ -1621,7 +1621,7 @@ string* doProcessUDPQuestion(const std::
 
   if(MT->numProcesses() > g_maxMThreads) {
     if(!g_quiet)
-      L<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<", over capacity"<<endl;
+      g_log<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<", over capacity"<<endl;
 
     g_stats.overCapacityDrops++;
     return 0;
@@ -1672,7 +1672,7 @@ void handleNewUDPQuestion(int fd, FDMult
 
     if(t_allowFrom && !t_allowFrom->match(&fromaddr)) {
       if(!g_quiet)
-        L<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toString()<<", address not matched by allow-from"<<endl;
+        g_log<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toString()<<", address not matched by allow-from"<<endl;
 
       g_stats.unauthorizedUDP++;
       return;
@@ -1680,7 +1680,7 @@ void handleNewUDPQuestion(int fd, FDMult
     BOOST_STATIC_ASSERT(offsetof(sockaddr_in, sin_port) == offsetof(sockaddr_in6, sin6_port));
     if(!fromaddr.sin4.sin_port) { // also works for IPv6
      if(!g_quiet)
-        L<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toStringWithPort()<<", can't deal with port 0"<<endl;
+        g_log<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toStringWithPort()<<", can't deal with port 0"<<endl;
 
       g_stats.clientParseError++; // not quite the best place to put it, but needs to go somewhere
       return;
@@ -1691,12 +1691,12 @@ void handleNewUDPQuestion(int fd, FDMult
       if(dh->qr) {
         g_stats.ignoredCount++;
         if(g_logCommonErrors)
-          L<<Logger::Error<<"Ignoring answer from "<<fromaddr.toString()<<" on server socket!"<<endl;
+          g_log<<Logger::Error<<"Ignoring answer from "<<fromaddr.toString()<<" on server socket!"<<endl;
       }
       else if(dh->opcode) {
         g_stats.ignoredCount++;
         if(g_logCommonErrors)
-          L<<Logger::Error<<"Ignoring non-query opcode "<<dh->opcode<<" from "<<fromaddr.toString()<<" on server socket!"<<endl;
+          g_log<<Logger::Error<<"Ignoring non-query opcode "<<dh->opcode<<" from "<<fromaddr.toString()<<" on server socket!"<<endl;
       }
       else {
         string question(data, (size_t)len);
@@ -1729,12 +1729,12 @@ void handleNewUDPQuestion(int fd, FDMult
     catch(MOADNSException& mde) {
       g_stats.clientParseError++;
       if(g_logCommonErrors)
-        L<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<mde.what()<<endl;
+        g_log<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<mde.what()<<endl;
     }
     catch(std::runtime_error& e) {
       g_stats.clientParseError++;
       if(g_logCommonErrors)
-        L<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<e.what()<<endl;
+        g_log<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<e.what()<<endl;
     }
   }
   else {
@@ -1782,17 +1782,17 @@ void makeTCPServerSockets()
 
     int tmp=1;
     if(setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,(char*)&tmp,sizeof tmp)<0) {
-      L<<Logger::Error<<"Setsockopt failed for TCP listening socket"<<endl;
+      g_log<<Logger::Error<<"Setsockopt failed for TCP listening socket"<<endl;
       exit(1);
     }
     if(sin.sin6.sin6_family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &tmp, sizeof(tmp)) < 0) {
-      L<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
+      g_log<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
     }
 
 #ifdef TCP_DEFER_ACCEPT
     if(setsockopt(fd, SOL_TCP,TCP_DEFER_ACCEPT,(char*)&tmp,sizeof tmp) >= 0) {
       if(i==locals.begin())
-        L<<Logger::Error<<"Enabled TCP data-ready filter for (slight) DoS protection"<<endl;
+        g_log<<Logger::Error<<"Enabled TCP data-ready filter for (slight) DoS protection"<<endl;
     }
 #endif
 
@@ -1820,9 +1820,9 @@ void makeTCPServerSockets()
     // we don't need to update g_listenSocketsAddresses since it doesn't work for TCP/IP:
     //  - fd is not that which we know here, but returned from accept()
     if(sin.sin4.sin_family == AF_INET)
-      L<<Logger::Error<<"Listening for TCP queries on "<< sin.toString() <<":"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for TCP queries on "<< sin.toString() <<":"<<st.port<<endl;
     else
-      L<<Logger::Error<<"Listening for TCP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for TCP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
   }
 }
 
@@ -1855,7 +1855,7 @@ void makeUDPServerSockets()
       throw PDNSException("Making a UDP server socket for resolver: "+netstringerror());
     }
     if (!setSocketTimestamps(fd))
-      L<<Logger::Warning<<"Unable to enable timestamp reporting for socket"<<endl;
+      g_log<<Logger::Warning<<"Unable to enable timestamp reporting for socket"<<endl;
 
     if(IsAnyAddress(sin)) {
       if(sin.sin4.sin_family == AF_INET)
@@ -1867,7 +1867,7 @@ void makeUDPServerSockets()
           g_fromtosockets.insert(fd);
 #endif
       if(sin.sin6.sin6_family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) < 0) {
-	L<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
+	g_log<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
       }
     }
     if( ::arg().mustDo("non-local-bind") )
@@ -1894,9 +1894,9 @@ void makeUDPServerSockets()
     deferredAdd.push_back(make_pair(fd, handleNewUDPQuestion));
     g_listenSocketsAddresses[fd]=sin;  // this is written to only from the startup thread, not from the workers
     if(sin.sin4.sin_family == AF_INET)
-      L<<Logger::Error<<"Listening for UDP queries on "<< sin.toString() <<":"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for UDP queries on "<< sin.toString() <<":"<<st.port<<endl;
     else
-      L<<Logger::Error<<"Listening for UDP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for UDP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
   }
 }
 
@@ -1910,7 +1910,7 @@ void daemonize(void)
 
   int i=open("/dev/null",O_RDWR); /* open stdin */
   if(i < 0)
-    L<<Logger::Critical<<"Unable to open /dev/null: "<<stringerror()<<endl;
+    g_log<<Logger::Critical<<"Unable to open /dev/null: "<<stringerror()<<endl;
   else {
     dup2(i,0); /* stdin */
     dup2(i,1); /* stderr */
@@ -1943,35 +1943,35 @@ void doStats(void)
   uint64_t cacheMisses = broadcastAccFunction<uint64_t>(pleaseGetCacheMisses);
 
   if(g_stats.qcounter && (cacheHits + cacheMisses) && SyncRes::s_queries && SyncRes::s_outqueries) {
-    L<<Logger::Notice<<"stats: "<<g_stats.qcounter<<" questions, "<<
+    g_log<<Logger::Notice<<"stats: "<<g_stats.qcounter<<" questions, "<<
       broadcastAccFunction<uint64_t>(pleaseGetCacheSize)<< " cache entries, "<<
       broadcastAccFunction<uint64_t>(pleaseGetNegCacheSize)<<" negative entries, "<<
       (int)((cacheHits*100.0)/(cacheHits+cacheMisses))<<"% cache hits"<<endl;
 
-    L<<Logger::Notice<<"stats: throttle map: "
+    g_log<<Logger::Notice<<"stats: throttle map: "
       << broadcastAccFunction<uint64_t>(pleaseGetThrottleSize) <<", ns speeds: "
       << broadcastAccFunction<uint64_t>(pleaseGetNsSpeedsSize)<<endl;
-    L<<Logger::Notice<<"stats: outpacket/query ratio "<<(int)(SyncRes::s_outqueries*100.0/SyncRes::s_queries)<<"%";
-    L<<Logger::Notice<<", "<<(int)(SyncRes::s_throttledqueries*100.0/(SyncRes::s_outqueries+SyncRes::s_throttledqueries))<<"% throttled, "
+    g_log<<Logger::Notice<<"stats: outpacket/query ratio "<<(int)(SyncRes::s_outqueries*100.0/SyncRes::s_queries)<<"%";
+    g_log<<Logger::Notice<<", "<<(int)(SyncRes::s_throttledqueries*100.0/(SyncRes::s_outqueries+SyncRes::s_throttledqueries))<<"% throttled, "
      <<SyncRes::s_nodelegated<<" no-delegation drops"<<endl;
-    L<<Logger::Notice<<"stats: "<<SyncRes::s_tcpoutqueries<<" outgoing tcp connections, "<<
+    g_log<<Logger::Notice<<"stats: "<<SyncRes::s_tcpoutqueries<<" outgoing tcp connections, "<<
       broadcastAccFunction<uint64_t>(pleaseGetConcurrentQueries)<<" queries running, "<<SyncRes::s_outgoingtimeouts<<" outgoing timeouts"<<endl;
 
-    //L<<Logger::Notice<<"stats: "<<g_stats.ednsPingMatches<<" ping matches, "<<g_stats.ednsPingMismatches<<" mismatches, "<<
+    //g_log<<Logger::Notice<<"stats: "<<g_stats.ednsPingMatches<<" ping matches, "<<g_stats.ednsPingMismatches<<" mismatches, "<<
       //g_stats.noPingOutQueries<<" outqueries w/o ping, "<< g_stats.noEdnsOutQueries<<" w/o EDNS"<<endl;
 
-    L<<Logger::Notice<<"stats: " <<  broadcastAccFunction<uint64_t>(pleaseGetPacketCacheSize) <<
+    g_log<<Logger::Notice<<"stats: " <<  broadcastAccFunction<uint64_t>(pleaseGetPacketCacheSize) <<
     " packet cache entries, "<<(int)(100.0*broadcastAccFunction<uint64_t>(pleaseGetPacketCacheHits)/SyncRes::s_queries) << "% packet cache hits"<<endl;
 
     time_t now = time(0);
     if(lastOutputTime && lastQueryCount && now != lastOutputTime) {
-      L<<Logger::Notice<<"stats: "<< (SyncRes::s_queries - lastQueryCount) / (now - lastOutputTime) <<" qps (average over "<< (now - lastOutputTime) << " seconds)"<<endl;
+      g_log<<Logger::Notice<<"stats: "<< (SyncRes::s_queries - lastQueryCount) / (now - lastOutputTime) <<" qps (average over "<< (now - lastOutputTime) << " seconds)"<<endl;
     }
     lastOutputTime = now;
     lastQueryCount = SyncRes::s_queries;
   }
   else if(statsWanted)
-    L<<Logger::Notice<<"stats: no stats yet!"<<endl;
+    g_log<<Logger::Notice<<"stats: no stats yet!"<<endl;
 
   statsWanted=false;
 }
@@ -2026,15 +2026,15 @@ static void houseKeeping(void *)
 	}
 	catch(std::exception& e)
         {
-          L<<Logger::Error<<"Exception while performing security poll: "<<e.what()<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll: "<<e.what()<<endl;
         }
         catch(PDNSException& e)
         {
-          L<<Logger::Error<<"Exception while performing security poll: "<<e.reason<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll: "<<e.reason<<endl;
         }
         catch(...)
         {
-          L<<Logger::Error<<"Exception while performing security poll"<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll"<<endl;
         }
 
       }
@@ -2044,7 +2044,7 @@ static void houseKeeping(void *)
   catch(PDNSException& ae)
     {
       s_running=false;
-      L<<Logger::Error<<"Fatal error in housekeeping thread: "<<ae.reason<<endl;
+      g_log<<Logger::Error<<"Fatal error in housekeeping thread: "<<ae.reason<<endl;
       throw;
     }
 }
@@ -2140,11 +2140,11 @@ void handlePipeRequest(int fd, FDMultipl
   }
   catch(std::exception& e) {
     if(g_logCommonErrors)
-      L<<Logger::Error<<"PIPE function we executed created exception: "<<e.what()<<endl; // but what if they wanted an answer.. we send 0
+      g_log<<Logger::Error<<"PIPE function we executed created exception: "<<e.what()<<endl; // but what if they wanted an answer.. we send 0
   }
   catch(PDNSException& e) {
     if(g_logCommonErrors)
-      L<<Logger::Error<<"PIPE function we executed created PDNS exception: "<<e.reason<<endl; // but what if they wanted an answer.. we send 0
+      g_log<<Logger::Error<<"PIPE function we executed created PDNS exception: "<<e.reason<<endl; // but what if they wanted an answer.. we send 0
   }
   if(tmsg->wantAnswer) {
     if(write(g_pipes[t_id].writeFromThread, &resp, sizeof(resp)) != sizeof(resp)) {
@@ -2245,10 +2245,10 @@ void handleRCC(int fd, FDMultiplexer::fu
     command();
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Error dealing with control socket request: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Error dealing with control socket request: "<<e.what()<<endl;
   }
   catch(PDNSException& ae) {
-    L<<Logger::Error<<"Error dealing with control socket request: "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"Error dealing with control socket request: "<<ae.reason<<endl;
   }
 }
 
@@ -2335,7 +2335,7 @@ void handleUDPServerResponse(int fd, FDM
     else {
       g_stats.serverParseError++;
       if(g_logCommonErrors)
-        L<<Logger::Error<<"Unable to parse packet from remote UDP server "<< fromaddr.toString() <<
+        g_log<<Logger::Error<<"Unable to parse packet from remote UDP server "<< fromaddr.toString() <<
           ": packet smaller than DNS header"<<endl;
     }
 
@@ -2359,7 +2359,7 @@ void handleUDPServerResponse(int fd, FDM
   pident.fd=fd;
 
   if(!dh.qr && g_logCommonErrors) {
-    L<<Logger::Notice<<"Not taking data from question on outgoing socket from "<< fromaddr.toStringWithPort()  <<endl;
+    g_log<<Logger::Notice<<"Not taking data from question on outgoing socket from "<< fromaddr.toStringWithPort()  <<endl;
   }
 
   if(!dh.qdcount || // UPC, Nominum, very old BIND on FormErr, NSD
@@ -2374,7 +2374,7 @@ void handleUDPServerResponse(int fd, FDM
     }
     catch(std::exception& e) {
       g_stats.serverParseError++; // won't be fed to lwres.cc, so we have to increment
-      L<<Logger::Warning<<"Error in packet from remote nameserver "<< fromaddr.toStringWithPort() << ": "<<e.what() << endl;
+      g_log<<Logger::Warning<<"Error in packet from remote nameserver "<< fromaddr.toStringWithPort() << ": "<<e.what() << endl;
       return;
     }
   }
@@ -2407,7 +2407,7 @@ retryWithName:
     }
     g_stats.unexpectedCount++; // if we made it here, it really is an unexpected answer
     if(g_logCommonErrors) {
-      L<<Logger::Warning<<"Discarding unexpected packet from "<<fromaddr.toStringWithPort()<<": "<< (pident.domain.empty() ? "<empty>" : pident.domain.toString())<<", "<<pident.type<<", "<<MT->d_waiters.size()<<" waiters"<<endl;
+      g_log<<Logger::Warning<<"Discarding unexpected packet from "<<fromaddr.toStringWithPort()<<": "<< (pident.domain.empty() ? "<empty>" : pident.domain.toString())<<", "<<pident.type<<", "<<MT->d_waiters.size()<<" waiters"<<endl;
     }
   }
   else if(fd >= 0) {
@@ -2425,13 +2425,13 @@ FDMultiplexer* getMultiplexer()
       return ret;
     }
     catch(FDMultiplexerException &fe) {
-      L<<Logger::Error<<"Non-fatal error initializing possible multiplexer ("<<fe.what()<<"), falling back"<<endl;
+      g_log<<Logger::Error<<"Non-fatal error initializing possible multiplexer ("<<fe.what()<<"), falling back"<<endl;
     }
     catch(...) {
-      L<<Logger::Error<<"Non-fatal error initializing possible multiplexer"<<endl;
+      g_log<<Logger::Error<<"Non-fatal error initializing possible multiplexer"<<endl;
     }
   }
-  L<<Logger::Error<<"No working multiplexer found!"<<endl;
+  g_log<<Logger::Error<<"No working multiplexer found!"<<endl;
   exit(1);
 }
 
@@ -2442,7 +2442,7 @@ string* doReloadLuaScript()
   try {
     if(fname.empty()) {
       t_pdl->reset();
-      L<<Logger::Error<<t_id<<" Unloaded current lua script"<<endl;
+      g_log<<Logger::Error<<t_id<<" Unloaded current lua script"<<endl;
       return new string("unloaded\n");
     }
     else {
@@ -2450,11 +2450,11 @@ string* doReloadLuaScript()
     }
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<t_id<<" Retaining current script, error from '"<<fname<<"': "<< e.what() <<endl;
+    g_log<<Logger::Error<<t_id<<" Retaining current script, error from '"<<fname<<"': "<< e.what() <<endl;
     return new string("retaining current script, error from '"+fname+"': "+e.what()+"\n");
   }
 
-  L<<Logger::Warning<<t_id<<" (Re)loaded lua script from '"<<fname<<"'"<<endl;
+  g_log<<Logger::Warning<<t_id<<" (Re)loaded lua script from '"<<fname<<"'"<<endl;
   return new string("(re)loaded '"+fname+"'\n");
 }
 
@@ -2495,7 +2495,7 @@ static void checkLinuxIPv6Limits()
   if(readFileIfThere("/proc/sys/net/ipv6/route/max_size", &line)) {
     int lim=std::stoi(line);
     if(lim < 16384) {
-      L<<Logger::Error<<"If using IPv6, please raise sysctl net.ipv6.route.max_size, currently set to "<<lim<<" which is < 16384"<<endl;
+      g_log<<Logger::Error<<"If using IPv6, please raise sysctl net.ipv6.route.max_size, currently set to "<<lim<<" which is < 16384"<<endl;
     }
   }
 #endif
@@ -2509,11 +2509,11 @@ static void checkOrFixFDS()
     unsigned int hardlimit= getFilenumLimit(true);
     if(hardlimit >= wantFDs) {
       setFilenumLimit(wantFDs);
-      L<<Logger::Warning<<"Raised soft limit on number of filedescriptors to "<<wantFDs<<" to match max-mthreads and threads settings"<<endl;
+      g_log<<Logger::Warning<<"Raised soft limit on number of filedescriptors to "<<wantFDs<<" to match max-mthreads and threads settings"<<endl;
     }
     else {
       int newval = (hardlimit - 25) / g_numWorkerThreads;
-      L<<Logger::Warning<<"Insufficient number of filedescriptors available for max-mthreads*threads setting! ("<<hardlimit<<" < "<<wantFDs<<"), reducing max-mthreads to "<<newval<<endl;
+      g_log<<Logger::Warning<<"Insufficient number of filedescriptors available for max-mthreads*threads setting! ("<<hardlimit<<" < "<<wantFDs<<"), reducing max-mthreads to "<<newval<<endl;
       g_maxMThreads = newval;
       setFilenumLimit(hardlimit);
     }
@@ -2584,24 +2584,24 @@ void parseACLs()
 
       allowFrom->addMask(line);
     }
-    L<<Logger::Warning<<"Done parsing " << allowFrom->size() <<" allow-from ranges from file '"<<::arg()["allow-from-file"]<<"' - overriding 'allow-from' setting"<<endl;
+    g_log<<Logger::Warning<<"Done parsing " << allowFrom->size() <<" allow-from ranges from file '"<<::arg()["allow-from-file"]<<"' - overriding 'allow-from' setting"<<endl;
   }
   else if(!::arg()["allow-from"].empty()) {
     vector<string> ips;
     stringtok(ips, ::arg()["allow-from"], ", ");
 
-    L<<Logger::Warning<<"Only allowing queries from: ";
+    g_log<<Logger::Warning<<"Only allowing queries from: ";
     for(vector<string>::const_iterator i = ips.begin(); i!= ips.end(); ++i) {
       allowFrom->addMask(*i);
       if(i!=ips.begin())
-        L<<Logger::Warning<<", ";
-      L<<Logger::Warning<<*i;
+        g_log<<Logger::Warning<<", ";
+      g_log<<Logger::Warning<<*i;
     }
-    L<<Logger::Warning<<endl;
+    g_log<<Logger::Warning<<endl;
   }
   else {
     if(::arg()["local-address"]!="127.0.0.1" && ::arg().asNum("local-port")==53)
-      L<<Logger::Error<<"WARNING: Allowing queries from all IP addresses - this can be a security risk!"<<endl;
+      g_log<<Logger::Error<<"WARNING: Allowing queries from all IP addresses - this can be a security risk!"<<endl;
     delete allowFrom;
     allowFrom = 0;
   }
@@ -2626,16 +2626,16 @@ static void setupDelegationOnly()
 
 int serviceMain(int argc, char*argv[])
 {
-  L.setName(s_programname);
-  L.setLoglevel((Logger::Urgency)(6)); // info and up
-  L.disableSyslog(::arg().mustDo("disable-syslog"));
+  g_log.setName(s_programname);
+  g_log.setLoglevel((Logger::Urgency)(6)); // info and up
+  g_log.disableSyslog(::arg().mustDo("disable-syslog"));
 
   if(!::arg()["logging-facility"].empty()) {
     int val=logFacilityToLOG(::arg().asNum("logging-facility") );
     if(val >= 0)
-      theL().setFacility(val);
+      g_log.setFacility(val);
     else
-      L<<Logger::Error<<"Unknown logging facility "<<::arg().asNum("logging-facility") <<endl;
+      g_log<<Logger::Error<<"Unknown logging facility "<<::arg().asNum("logging-facility") <<endl;
   }
 
   showProductVersion();
@@ -2648,7 +2648,7 @@ int serviceMain(int argc, char*argv[])
     vector<string> addrs;
     if(!::arg()["query-local-address6"].empty()) {
       SyncRes::s_doIPv6=true;
-      L<<Logger::Warning<<"Enabling IPv6 transport for outgoing queries"<<endl;
+      g_log<<Logger::Warning<<"Enabling IPv6 transport for outgoing queries"<<endl;
 
       stringtok(addrs, ::arg()["query-local-address6"], ", ;");
       for(const string& addr : addrs) {
@@ -2656,7 +2656,7 @@ int serviceMain(int argc, char*argv[])
       }
     }
     else {
-      L<<Logger::Warning<<"NOT using IPv6 for outgoing queries - set 'query-local-address6=::' to enable"<<endl;
+      g_log<<Logger::Warning<<"NOT using IPv6 for outgoing queries - set 'query-local-address6=::' to enable"<<endl;
     }
     addrs.clear();
     stringtok(addrs, ::arg()["query-local-address"], ", ;");
@@ -2665,7 +2665,7 @@ int serviceMain(int argc, char*argv[])
     }
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Assigning local query addresses: "<<e.what();
+    g_log<<Logger::Error<<"Assigning local query addresses: "<<e.what();
     exit(99);
   }
 
@@ -2681,7 +2681,7 @@ int serviceMain(int argc, char*argv[])
   else if(::arg()["dnssec"]=="log-fail")
     g_dnssecmode=DNSSECMode::ValidateForLog;
   else {
-    L<<Logger::Error<<"Unknown DNSSEC mode "<<::arg()["dnssec"]<<endl;
+    g_log<<Logger::Error<<"Unknown DNSSEC mode "<<::arg()["dnssec"]<<endl;
     exit(1);
   }
 
@@ -2691,7 +2691,7 @@ int serviceMain(int argc, char*argv[])
     loadRecursorLuaConfig(::arg()["lua-config-file"], ::arg().mustDo("daemon"));
   }
   catch (PDNSException &e) {
-    L<<Logger::Error<<"Cannot load Lua configuration: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Cannot load Lua configuration: "<<e.reason<<endl;
     exit(1);
   }
 
@@ -2705,21 +2705,21 @@ int serviceMain(int argc, char*argv[])
     ips.push_back("0.0.0.0");
     ips.push_back("::");
 
-    L<<Logger::Warning<<"Will not send queries to: ";
+    g_log<<Logger::Warning<<"Will not send queries to: ";
     for(vector<string>::const_iterator i = ips.begin(); i!= ips.end(); ++i) {
       g_dontQuery->addMask(*i);
       if(i!=ips.begin())
-        L<<Logger::Warning<<", ";
-      L<<Logger::Warning<<*i;
+        g_log<<Logger::Warning<<", ";
+      g_log<<Logger::Warning<<*i;
     }
-    L<<Logger::Warning<<endl;
+    g_log<<Logger::Warning<<endl;
   }
 
   g_quiet=::arg().mustDo("quiet");
 
   g_weDistributeQueries = ::arg().mustDo("pdns-distributes-queries");
   if(g_weDistributeQueries) {
-      L<<Logger::Warning<<"PowerDNS Recursor itself will distribute queries over threads"<<endl;
+      g_log<<Logger::Warning<<"PowerDNS Recursor itself will distribute queries over threads"<<endl;
   }
 
   setupDelegationOnly();
@@ -2736,7 +2736,7 @@ int serviceMain(int argc, char*argv[])
   else if(::arg()["dnssec"]=="log-fail")
     g_dnssecmode=DNSSECMode::ValidateForLog;
   else {
-    L<<Logger::Error<<"Unknown DNSSEC mode "<<::arg()["dnssec"]<<endl;
+    g_log<<Logger::Error<<"Unknown DNSSEC mode "<<::arg()["dnssec"]<<endl;
     exit(1);
   }
 
@@ -2801,8 +2801,8 @@ int serviceMain(int argc, char*argv[])
   }
 
   if(::arg().mustDo("daemon")) {
-    L<<Logger::Warning<<"Calling daemonize, going to background"<<endl;
-    L.toConsole(Logger::Critical);
+    g_log<<Logger::Warning<<"Calling daemonize, going to background"<<endl;
+    g_log.toConsole(Logger::Critical);
     daemonize();
     loadRecursorLuaConfig(::arg()["lua-config-file"], false);
   }
@@ -2816,7 +2816,7 @@ int serviceMain(int argc, char*argv[])
 
 #ifdef HAVE_LIBSODIUM
   if (sodium_init() == -1) {
-    L<<Logger::Error<<"Unable to initialize sodium crypto library"<<endl;
+    g_log<<Logger::Error<<"Unable to initialize sodium crypto library"<<endl;
     exit(99);
   }
 #endif
@@ -2838,16 +2838,16 @@ int serviceMain(int argc, char*argv[])
      char *ns;
      ns = getenv("NOTIFY_SOCKET");
      if (ns != nullptr) {
-       L<<Logger::Error<<"Unable to chroot when running from systemd. Please disable chroot= or set the 'Type' for this service to 'simple'"<<endl;
+       g_log<<Logger::Error<<"Unable to chroot when running from systemd. Please disable chroot= or set the 'Type' for this service to 'simple'"<<endl;
        exit(1);
      }
 #endif
     if (chroot(::arg()["chroot"].c_str())<0 || chdir("/") < 0) {
-      L<<Logger::Error<<"Unable to chroot to '"+::arg()["chroot"]+"': "<<strerror (errno)<<", exiting"<<endl;
+      g_log<<Logger::Error<<"Unable to chroot to '"+::arg()["chroot"]+"': "<<strerror (errno)<<", exiting"<<endl;
       exit(1);
     }
     else
-      L<<Logger::Error<<"Chrooted to '"<<::arg()["chroot"]<<"'"<<endl;
+      g_log<<Logger::Error<<"Chrooted to '"<<::arg()["chroot"]<<"'"<<endl;
   }
 
   s_pidfname=::arg()["socket-dir"]+"/"+s_programname+".pid";
@@ -2865,7 +2865,7 @@ int serviceMain(int argc, char*argv[])
   g_maxTCPPerClient=::arg().asNum("max-tcp-per-client");
 
   if(g_numThreads == 1) {
-    L<<Logger::Warning<<"Operating unthreaded"<<endl;
+    g_log<<Logger::Warning<<"Operating unthreaded"<<endl;
 #ifdef HAVE_SYSTEMD
     sd_notify(0, "READY=1");
 #endif
@@ -2873,7 +2873,7 @@ int serviceMain(int argc, char*argv[])
   }
   else {
     pthread_t tid;
-    L<<Logger::Warning<<"Launching "<< g_numThreads <<" threads"<<endl;
+    g_log<<Logger::Warning<<"Launching "<< g_numThreads <<" threads"<<endl;
     for(unsigned int n=0; n < g_numThreads; ++n) {
       pthread_create(&tid, 0, recursorThread, (void*)(long)n);
     }
@@ -2902,18 +2902,18 @@ try
 #ifdef HAVE_PROTOBUF
   t_uuidGenerator = new boost::uuids::random_generator();
 #endif
-  L<<Logger::Warning<<"Done priming cache with root hints"<<endl;
+  g_log<<Logger::Warning<<"Done priming cache with root hints"<<endl;
 
   t_pdl = new shared_ptr<RecursorLua4>();
 
   try {
     if(!::arg()["lua-dns-script"].empty()) {
       *t_pdl = shared_ptr<RecursorLua4>(new RecursorLua4(::arg()["lua-dns-script"]));
-      L<<Logger::Warning<<"Loaded 'lua' script from '"<<::arg()["lua-dns-script"]<<"'"<<endl;
+      g_log<<Logger::Warning<<"Loaded 'lua' script from '"<<::arg()["lua-dns-script"]<<"'"<<endl;
     }
   }
   catch(std::exception &e) {
-    L<<Logger::Error<<"Failed to load 'lua' script from '"<<::arg()["lua-dns-script"]<<"': "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Failed to load 'lua' script from '"<<::arg()["lua-dns-script"]<<"': "<<e.what()<<endl;
     _exit(99);
   }
 
@@ -2943,16 +2943,16 @@ try
   t_fdm=getMultiplexer();
   if(!t_id) {
     if(::arg().mustDo("webserver")) {
-      L<<Logger::Warning << "Enabling web server" << endl;
+      g_log<<Logger::Warning << "Enabling web server" << endl;
       try {
         new RecursorWebServer(t_fdm);
       }
       catch(PDNSException &e) {
-        L<<Logger::Error<<"Exception: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Exception: "<<e.reason<<endl;
         exit(99);
       }
     }
-    L<<Logger::Error<<"Enabled '"<< t_fdm->getName() << "' multiplexer"<<endl;
+    g_log<<Logger::Error<<"Enabled '"<< t_fdm->getName() << "' multiplexer"<<endl;
   }
 
   t_fdm->addReadFD(g_pipes[t_id].readToThread, handlePipeRequest);
@@ -2986,7 +2986,7 @@ try
       for(expired_t::iterator i=expired.begin() ; i != expired.end(); ++i) {
         shared_ptr<TCPConnection> conn=any_cast<shared_ptr<TCPConnection> >(i->second);
         if(g_logCommonErrors)
-          L<<Logger::Warning<<"Timeout from remote TCP client "<< conn->d_remote.toString() <<endl;
+          g_log<<Logger::Warning<<"Timeout from remote TCP client "<< conn->d_remote.toString() <<endl;
         t_fdm->removeReadFD(i->first);
       }
     }
@@ -3026,15 +3026,15 @@ try
   }
 }
 catch(PDNSException &ae) {
-  L<<Logger::Error<<"Exception: "<<ae.reason<<endl;
+  g_log<<Logger::Error<<"Exception: "<<ae.reason<<endl;
   return 0;
 }
 catch(std::exception &e) {
-   L<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
+   g_log<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
    return 0;
 }
 catch(...) {
-   L<<Logger::Error<<"any other exception in main: "<<endl;
+   g_log<<Logger::Error<<"any other exception in main: "<<endl;
    return 0;
 }
 
@@ -3153,7 +3153,7 @@ int main(int argc, char **argv)
     ::arg().setCmd("help","Provide a helpful message");
     ::arg().setCmd("version","Print version string");
     ::arg().setCmd("config","Output blank configuration");
-    L.toConsole(Logger::Info);
+    g_log.toConsole(Logger::Info);
     ::arg().laxParse(argc,argv); // do a lax parse
 
     string configname=::arg()["config-dir"]+"/recursor.conf";
@@ -3169,12 +3169,12 @@ int main(int argc, char **argv)
     }
 
     if(!::arg().file(configname.c_str()))
-      L<<Logger::Warning<<"Unable to parse configuration file '"<<configname<<"'"<<endl;
+      g_log<<Logger::Warning<<"Unable to parse configuration file '"<<configname<<"'"<<endl;
 
     ::arg().parse(argc,argv);
 
     if( !::arg()["chroot"].empty() && !::arg()["api-config-dir"].empty() && !::arg().mustDo("api-readonly") )  {
-      L<<Logger::Error<<"Using chroot and a writable API is not possible"<<endl;
+      g_log<<Logger::Error<<"Using chroot and a writable API is not possible"<<endl;
       exit(EXIT_FAILURE);
     }
 
@@ -3208,21 +3208,21 @@ int main(int argc, char **argv)
     if(!g_quiet && logUrgency < Logger::Info) { // Logger::Info=6, Logger::Debug=7
       logUrgency = Logger::Info;                // if you do --quiet=no, you need Info to also see the query log
     }
-    L.setLoglevel(logUrgency);
-    L.toConsole(logUrgency);
+    g_log.setLoglevel(logUrgency);
+    g_log.toConsole(logUrgency);
 
     serviceMain(argc, argv);
   }
   catch(PDNSException &ae) {
-    L<<Logger::Error<<"Exception: "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"Exception: "<<ae.reason<<endl;
     ret=EXIT_FAILURE;
   }
   catch(std::exception &e) {
-    L<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
     ret=EXIT_FAILURE;
   }
   catch(...) {
-    L<<Logger::Error<<"any other exception in main: "<<endl;
+    g_log<<Logger::Error<<"any other exception in main: "<<endl;
     ret=EXIT_FAILURE;
   }
 
@@ -3249,22 +3249,22 @@ int getRootNS(void) {
   }
   catch(PDNSException& e)
   {
-    L<<Logger::Error<<"Failed to update . records, got an exception: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception: "<<e.reason<<endl;
   }
 
   catch(std::exception& e)
   {
-    L<<Logger::Error<<"Failed to update . records, got an exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception: "<<e.what()<<endl;
   }
 
   catch(...)
   {
-    L<<Logger::Error<<"Failed to update . records, got an exception"<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception"<<endl;
   }
   if(!res) {
-    L<<Logger::Notice<<"Refreshed . records"<<endl;
+    g_log<<Logger::Notice<<"Refreshed . records"<<endl;
   }
   else
-    L<<Logger::Error<<"Failed to update . records, RCODE="<<res<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, RCODE="<<res<<endl;
   return res;
 }
--- randomhelper.cc.orig	2018-11-06 14:56:58 UTC
+++ randomhelper.cc
@@ -11,11 +11,11 @@
 
 void seedRandom(const string& source)
 {
-  L<<Logger::Warning<<"Reading random entropy from '"<<source<<"'"<<endl;
+  g_log<<Logger::Warning<<"Reading random entropy from '"<<source<<"'"<<endl;
 
   int fd=open(source.c_str(), O_RDONLY);
   if(fd < 0) {
-    L<<Logger::Error<<"Unable to open source of random '"<<source<<"': "<<stringerror()<<endl;
+    g_log<<Logger::Error<<"Unable to open source of random '"<<source<<"': "<<stringerror()<<endl;
     exit(EXIT_FAILURE);
   }
   char seed[16];
@@ -24,12 +24,12 @@ void seedRandom(const string& source)
   while(pos!=sizeof(seed)) {
     ret = read(fd, seed+pos, sizeof(seed)-pos);
     if(ret < 0) { 
-      L<<Logger::Error<<"Unable to read random seed from "<<source<<": "<<stringerror()<<endl;
+      g_log<<Logger::Error<<"Unable to read random seed from "<<source<<": "<<stringerror()<<endl;
       close(fd);
       exit(EXIT_FAILURE);
     }
     if(!ret) {
-      L<<Logger::Error<<"Unable to read random seed from "<<source<<": end of file"<<endl;
+      g_log<<Logger::Error<<"Unable to read random seed from "<<source<<": end of file"<<endl;
       close(fd);
       exit(EXIT_FAILURE);
     }
--- rec-carbon.cc.orig	2018-11-06 14:56:58 UTC
+++ rec-carbon.cc
@@ -60,16 +60,16 @@ try
 
     int ret=asendtcp(msg, &s);     // this will actually do the right thing waiting on the connect
     if(ret < 0)
-      L<<Logger::Warning<<"Error writing carbon data to "<<remote.toStringWithPort()<<": "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Error writing carbon data to "<<remote.toStringWithPort()<<": "<<strerror(errno)<<endl;
     if(ret==0)
-      L<<Logger::Warning<<"Timeout connecting/writing carbon data to "<<remote.toStringWithPort()<<endl;
+      g_log<<Logger::Warning<<"Timeout connecting/writing carbon data to "<<remote.toStringWithPort()<<endl;
   }
  }
 catch(PDNSException& e)
 {
-  L<<Logger::Error<<"Error in carbon thread: "<<e.reason<<endl;
+  g_log<<Logger::Error<<"Error in carbon thread: "<<e.reason<<endl;
 }
 catch(std::exception& e)
 {
-  L<<Logger::Error<<"Error in carbon thread: "<<e.what()<<endl;
+  g_log<<Logger::Error<<"Error in carbon thread: "<<e.what()<<endl;
 }
--- rec-lua-conf.cc.orig	2018-11-06 14:56:58 UTC
+++ rec-lua-conf.cc
@@ -119,13 +119,13 @@ void loadRecursorLuaConfig(const std::st
             lci.dfe.reserve(zoneIdx, static_cast<size_t>(boost::get<int>(constGet(have, "zoneSizeHint"))));
           }
 	}
-        theL()<<Logger::Warning<<"Loading RPZ from file '"<<filename<<"'"<<endl;
+        g_log<<Logger::Warning<<"Loading RPZ from file '"<<filename<<"'"<<endl;
         lci.dfe.setPolicyName(zoneIdx, polName);
         loadRPZFromFile(filename, lci.dfe, defpol, zoneIdx);
-        theL()<<Logger::Warning<<"Done loading RPZ from file '"<<filename<<"'"<<endl;
+        g_log<<Logger::Warning<<"Done loading RPZ from file '"<<filename<<"'"<<endl;
       }
       catch(std::exception& e) {
-	theL()<<Logger::Error<<"Unable to load RPZ zone from '"<<filename<<"': "<<e.what()<<endl;
+	g_log<<Logger::Error<<"Unable to load RPZ zone from '"<<filename<<"': "<<e.what()<<endl;
       }
     });
 
@@ -198,10 +198,10 @@ void loadRecursorLuaConfig(const std::st
         }
       }
       catch(std::exception& e) {
-	theL()<<Logger::Error<<"Unable to load RPZ zone '"<<zone_<<"' from '"<<master_<<"': "<<e.what()<<endl;
+	g_log<<Logger::Error<<"Unable to load RPZ zone '"<<zone_<<"' from '"<<master_<<"': "<<e.what()<<endl;
       }
       catch(PDNSException& e) {
-	theL()<<Logger::Error<<"Unable to load RPZ zone '"<<zone_<<"' from '"<<master_<<"': "<<e.reason<<endl;
+	g_log<<Logger::Error<<"Unable to load RPZ zone '"<<zone_<<"' from '"<<master_<<"': "<<e.reason<<endl;
       }
 
     });
@@ -234,7 +234,7 @@ void loadRecursorLuaConfig(const std::st
 			}
 		      }
 		      catch(std::exception& e) {
-			theL()<<Logger::Error<<"Error in addSortList: "<<e.what()<<endl;
+			g_log<<Logger::Error<<"Error in addSortList: "<<e.what()<<endl;
 		      }
 		    });
 
@@ -282,14 +282,14 @@ void loadRecursorLuaConfig(const std::st
           }
         }
         else {
-          theL()<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
+          g_log<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
         }
       }
       catch(std::exception& e) {
-	theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
+	g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
       }
       catch(PDNSException& e) {
-        theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
       }
     });
 
@@ -302,14 +302,14 @@ void loadRecursorLuaConfig(const std::st
           }
         }
         else {
-          theL()<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
+          g_log<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
         }
       }
       catch(std::exception& e) {
-	theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
+	g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
       }
       catch(PDNSException& e) {
-        theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
       }
     });
 #endif
@@ -319,22 +319,22 @@ void loadRecursorLuaConfig(const std::st
     g_luaconfs.setState(lci);
   }
   catch(const LuaContext::ExecutionErrorException& e) {
-    theL()<<Logger::Error<<"Unable to load Lua script from '"+fname+"': ";
+    g_log<<Logger::Error<<"Unable to load Lua script from '"+fname+"': ";
     try {
       std::rethrow_if_nested(e);
     } catch(const std::exception& exp) {
       // exp is the exception that was thrown from inside the lambda
-      theL() << exp.what() << std::endl;
+      g_log << exp.what() << std::endl;
     }
     catch(const PDNSException& exp) {
       // exp is the exception that was thrown from inside the lambda
-      theL() << exp.reason << std::endl;
+      g_log << exp.reason << std::endl;
     }
     throw;
 
   }
   catch(std::exception& err) {
-    theL()<<Logger::Error<<"Unable to load Lua script from '"+fname+"': "<<err.what()<<endl;
+    g_log<<Logger::Error<<"Unable to load Lua script from '"+fname+"': "<<err.what()<<endl;
     throw;
   }
 
--- rec_channel_rec.cc.orig	2018-11-06 14:56:58 UTC
+++ rec_channel_rec.cc
@@ -354,7 +354,7 @@ string doSetDnssecLogBogus(T begin, T en
 
   if (pdns_iequals(*begin, "on") || pdns_iequals(*begin, "yes")) {
     if (!g_dnssecLogBogus) {
-      L<<Logger::Warning<<"Enabeling DNSSEC Bogus logging, requested via control channel"<<endl;
+      g_log<<Logger::Warning<<"Enabeling DNSSEC Bogus logging, requested via control channel"<<endl;
       g_dnssecLogBogus = true;
       return "DNSSEC Bogus logging enabled\n";
     }
@@ -363,7 +363,7 @@ string doSetDnssecLogBogus(T begin, T en
 
   if (pdns_iequals(*begin, "off") || pdns_iequals(*begin, "no")) {
     if (g_dnssecLogBogus) {
-      L<<Logger::Warning<<"Disabeling DNSSEC Bogus logging, requested via control channel"<<endl;
+      g_log<<Logger::Warning<<"Disabeling DNSSEC Bogus logging, requested via control channel"<<endl;
       g_dnssecLogBogus = false;
       return "DNSSEC Bogus logging disabled\n";
     }
@@ -398,7 +398,7 @@ string doAddNTA(T begin, T end)
     if (begin != end)
       why += " ";
   }
-  L<<Logger::Warning<<"Adding Negative Trust Anchor for "<<who<<" with reason '"<<why<<"', requested via control channel"<<endl;
+  g_log<<Logger::Warning<<"Adding Negative Trust Anchor for "<<who<<" with reason '"<<why<<"', requested via control channel"<<endl;
   g_luaconfs.modify([who, why](LuaConfigItems& lci) {
       lci.negAnchors[who] = why;
       });
@@ -413,7 +413,7 @@ string doClearNTA(T begin, T end)
     return "No Negative Trust Anchor specified, doing nothing.\n";
 
   if (begin + 1 == end && *begin == "*"){
-    L<<Logger::Warning<<"Clearing all Negative Trust Anchors, requested via control channel"<<endl;
+    g_log<<Logger::Warning<<"Clearing all Negative Trust Anchors, requested via control channel"<<endl;
     g_luaconfs.modify([](LuaConfigItems& lci) {
         lci.negAnchors.clear();
       });
@@ -441,7 +441,7 @@ string doClearNTA(T begin, T end)
   string removed("");
   bool first(true);
   for (auto const &entry : toRemove) {
-    L<<Logger::Warning<<"Clearing Negative Trust Anchor for "<<entry<<", requested via control channel"<<endl;
+    g_log<<Logger::Warning<<"Clearing Negative Trust Anchor for "<<entry<<", requested via control channel"<<endl;
     g_luaconfs.modify([entry](LuaConfigItems& lci) {
         lci.negAnchors.erase(entry);
       });
@@ -489,17 +489,17 @@ string doAddTA(T begin, T end)
   }
 
   try {
-    L<<Logger::Warning<<"Adding Trust Anchor for "<<who<<" with data '"<<what<<"', requested via control channel";
+    g_log<<Logger::Warning<<"Adding Trust Anchor for "<<who<<" with data '"<<what<<"', requested via control channel";
     g_luaconfs.modify([who, what](LuaConfigItems& lci) {
       auto ds=std::dynamic_pointer_cast<DSRecordContent>(DSRecordContent::make(what));
       lci.dsAnchors[who].insert(*ds);
       });
     broadcastAccFunction<uint64_t>(boost::bind(pleaseWipePacketCache, who, true));
-    L<<Logger::Warning<<endl;
+    g_log<<Logger::Warning<<endl;
     return "Added Trust Anchor for " + who.toStringRootDot() + " with data " + what + "\n";
   }
   catch(std::exception &e) {
-    L<<Logger::Warning<<", failed: "<<e.what()<<endl;
+    g_log<<Logger::Warning<<", failed: "<<e.what()<<endl;
     return "Unable to add Trust Anchor for " + who.toStringRootDot() + ": " + e.what() + "\n";
   }
 }
@@ -531,7 +531,7 @@ string doClearTA(T begin, T end)
   string removed("");
   bool first(true);
   for (auto const &entry : toRemove) {
-    L<<Logger::Warning<<"Removing Trust Anchor for "<<entry<<", requested via control channel"<<endl;
+    g_log<<Logger::Warning<<"Removing Trust Anchor for "<<entry<<", requested via control channel"<<endl;
     g_luaconfs.modify([entry](LuaConfigItems& lci) {
         lci.dsAnchors.erase(entry);
       });
@@ -901,7 +901,7 @@ RecursorControlParser::RecursorControlPa
 
 static void doExitGeneric(bool nicely)
 {
-  L<<Logger::Error<<"Exiting on user request"<<endl;
+  g_log<<Logger::Error<<"Exiting on user request"<<endl;
   extern RecursorControlChannel s_rcc;
   s_rcc.~RecursorControlChannel(); 
 
@@ -1215,7 +1215,7 @@ string RecursorControlParser::getAnswer(
 
     try {
       loadRecursorLuaConfig(::arg()["lua-config-file"], false);
-      L<<Logger::Warning<<"Reloaded Lua configuration file '"<<::arg()["lua-config-file"]<<"', requested via control channel"<<endl;
+      g_log<<Logger::Warning<<"Reloaded Lua configuration file '"<<::arg()["lua-config-file"]<<"', requested via control channel"<<endl;
       return "Reloaded Lua configuration file '"+::arg()["lua-config-file"]+"'\n";
     }
     catch(std::exception& e) {
@@ -1240,7 +1240,7 @@ string RecursorControlParser::getAnswer(
 
   if(cmd=="reload-acls") {
     if(!::arg()["chroot"].empty()) {
-      L<<Logger::Error<<"Unable to reload ACL when chroot()'ed, requested via control channel"<<endl;
+      g_log<<Logger::Error<<"Unable to reload ACL when chroot()'ed, requested via control channel"<<endl;
       return "Unable to reload ACL when chroot()'ed, please restart\n";
     }
 
@@ -1249,12 +1249,12 @@ string RecursorControlParser::getAnswer(
     } 
     catch(std::exception& e) 
     {
-      L<<Logger::Error<<"Reloading ACLs failed (Exception: "<<e.what()<<")"<<endl;
+      g_log<<Logger::Error<<"Reloading ACLs failed (Exception: "<<e.what()<<")"<<endl;
       return e.what() + string("\n");
     }
     catch(PDNSException& ae)
     {
-      L<<Logger::Error<<"Reloading ACLs failed (PDNSException: "<<ae.reason<<")"<<endl;
+      g_log<<Logger::Error<<"Reloading ACLs failed (PDNSException: "<<ae.reason<<")"<<endl;
       return ae.reason + string("\n");
     }
     return "ok\n";
@@ -1293,7 +1293,7 @@ string RecursorControlParser::getAnswer(
 
   if(cmd=="reload-zones") {
     if(!::arg()["chroot"].empty()) {
-      L<<Logger::Error<<"Unable to reload zones and forwards when chroot()'ed, requested via control channel"<<endl;
+      g_log<<Logger::Error<<"Unable to reload zones and forwards when chroot()'ed, requested via control channel"<<endl;
       return "Unable to reload zones and forwards when chroot()'ed, please restart\n";
     }
     return reloadAuthAndForwards();
--- recursor_cache.hh.orig	2018-11-06 14:56:58 UTC
+++ recursor_cache.hh
@@ -30,7 +30,6 @@
 #include <iostream>
 #include "dnsrecords.hh"
 #include <boost/utility.hpp>
-#undef L
 #include <boost/multi_index_container.hpp>
 #include <boost/multi_index/ordered_index.hpp>
 #include <boost/tuple/tuple_comparison.hpp>
@@ -40,7 +39,6 @@
 #include "iputils.hh"
 #undef max
 
-#define L theL()
 #include "namespaces.hh"
 using namespace ::boost::multi_index;
 
--- reczones.cc.orig	2018-11-06 14:56:58 UTC
+++ reczones.cc
@@ -124,10 +124,10 @@ static void makeNameToIPZone(SyncRes::do
   ad.d_records.insert(dr);
   
   if(newMap->count(dr.d_name)) {  
-    L<<Logger::Warning<<"Hosts file will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
+    g_log<<Logger::Warning<<"Hosts file will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
   }
   else {
-    L<<Logger::Warning<<"Inserting forward zone '"<<dr.d_name<<"' based on hosts file"<<endl;
+    g_log<<Logger::Warning<<"Inserting forward zone '"<<dr.d_name<<"' based on hosts file"<<endl;
     (*newMap)[dr.d_name]=ad;
   }
 }
@@ -169,11 +169,11 @@ static void makeIPToNamesZone(SyncRes::d
     }
 
   if(newMap->count(dr.d_name)) {  
-    L<<Logger::Warning<<"Will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
+    g_log<<Logger::Warning<<"Will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
   }
   else {
     if(ipparts.size()==4)
-      L<<Logger::Warning<<"Inserting reverse zone '"<<dr.d_name<<"' based on hosts file"<<endl;
+      g_log<<Logger::Warning<<"Inserting reverse zone '"<<dr.d_name<<"' based on hosts file"<<endl;
     (*newMap)[dr.d_name]=ad;
   }
 }
@@ -218,15 +218,15 @@ void convertServersForAD(const std::stri
 
   for(vector<string>::const_iterator iter = servers.begin(); iter != servers.end(); ++iter) {
     if(verbose && iter != servers.begin()) 
-      L<<", ";
+      g_log<<", ";
 
     ComboAddress addr=parseIPAndPort(*iter, 53);
     if(verbose)
-      L<<addr.toStringWithPort();
+      g_log<<addr.toStringWithPort();
     ad.d_servers.push_back(addr);
   }
   if(verbose)
-    L<<endl;
+    g_log<<endl;
 }
 
 void* pleaseWipeNegCache()
@@ -246,7 +246,7 @@ string reloadAuthAndForwards()
   SyncRes::domainmap_t* original=t_sstorage->domainmap;  
   
   try {
-    L<<Logger::Warning<<"Reloading zones, purging data from cache"<<endl;
+    g_log<<Logger::Warning<<"Reloading zones, purging data from cache"<<endl;
   
     for(SyncRes::domainmap_t::const_iterator i = t_sstorage->domainmap->begin(); i != t_sstorage->domainmap->end(); ++i) {
       for(SyncRes::AuthDomain::records_t::const_iterator j = i->second.d_records.begin(); j != i->second.d_records.end(); ++j) 
@@ -304,13 +304,13 @@ string reloadAuthAndForwards()
     return "ok\n";
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<e.what()<<endl;
   }
   catch(PDNSException& ae) {
-    L<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<ae.reason<<endl;
   }
   catch(...) {
-    L<<Logger::Error<<"Encountered unknown error reloading zones, keeping original data"<<endl;
+    g_log<<Logger::Error<<"Encountered unknown error reloading zones, keeping original data"<<endl;
   }
   return "reloading failed, see log\n";
 }
@@ -325,7 +325,7 @@ void RPZIXFRTracker(const ComboAddress& 
 
     sleep(refresh);
     
-    L<<Logger::Info<<"Getting IXFR deltas for "<<zone<<" from "<<master.toStringWithPort()<<", our serial: "<<getRR<SOARecordContent>(dr)->d_st.serial<<endl;
+    g_log<<Logger::Info<<"Getting IXFR deltas for "<<zone<<" from "<<master.toStringWithPort()<<", our serial: "<<getRR<SOARecordContent>(dr)->d_st.serial<<endl;
     vector<pair<vector<DNSRecord>, vector<DNSRecord> > > deltas;
 
     ComboAddress local(localAddress);
@@ -335,12 +335,12 @@ void RPZIXFRTracker(const ComboAddress& 
     try {
       deltas = getIXFRDeltas(master, zone, dr, tt, &local, maxReceivedBytes);
     } catch(std::runtime_error& e ){
-      L<<Logger::Warning<<e.what()<<endl;
+      g_log<<Logger::Warning<<e.what()<<endl;
       continue;
     }
     if(deltas.empty())
       continue;
-    L<<Logger::Info<<"Processing "<<deltas.size()<<" delta"<<addS(deltas)<<" for RPZ "<<zone<<endl;
+    g_log<<Logger::Info<<"Processing "<<deltas.size()<<" delta"<<addS(deltas)<<" for RPZ "<<zone<<endl;
 
     auto luaconfsCopy = g_luaconfs.getCopy();
     int totremove=0, totadd=0;
@@ -348,7 +348,7 @@ void RPZIXFRTracker(const ComboAddress& 
       const auto& remove = delta.first;
       const auto& add = delta.second;
       if(remove.empty()) {
-        L<<Logger::Warning<<"IXFR update is a whole new zone"<<endl;
+        g_log<<Logger::Warning<<"IXFR update is a whole new zone"<<endl;
         luaconfsCopy.dfe.clear(polZone);
       }
       for(const auto& rr : remove) { // should always contain the SOA
@@ -360,11 +360,11 @@ void RPZIXFRTracker(const ComboAddress& 
 	    //	    cout<<"Got good removal of SOA serial "<<oldsr->d_st.serial<<endl;
 	  }
 	  else
-	    L<<Logger::Error<<"GOT WRONG SOA SERIAL REMOVAL, SHOULD TRIGGER WHOLE RELOAD"<<endl;
+	    g_log<<Logger::Error<<"GOT WRONG SOA SERIAL REMOVAL, SHOULD TRIGGER WHOLE RELOAD"<<endl;
 	}
 	else {
           totremove++;
-	  L<<Logger::Debug<<"Had removal of "<<rr.d_name<<endl;
+	  g_log<<Logger::Debug<<"Had removal of "<<rr.d_name<<endl;
 	  RPZRecordToPolicy(rr, luaconfsCopy.dfe, false, defpol, polZone);
 	}
       }
@@ -374,19 +374,19 @@ void RPZIXFRTracker(const ComboAddress& 
           continue;
 	if(rr.d_type == QType::SOA) {
 	  auto newsr = getRR<SOARecordContent>(rr);
-	  //	  L<<Logger::Info<<"New SOA serial for "<<zone<<": "<<newsr->d_st.serial<<endl;
+	  //	  g_log<<Logger::Info<<"New SOA serial for "<<zone<<": "<<newsr->d_st.serial<<endl;
 	  if (newsr) {
 	    oursr = newsr;
 	  }
 	}
 	else {
           totadd++;
-	  L<<Logger::Debug<<"Had addition of "<<rr.d_name<<endl;
+	  g_log<<Logger::Debug<<"Had addition of "<<rr.d_name<<endl;
 	  RPZRecordToPolicy(rr, luaconfsCopy.dfe, true, defpol, polZone);
 	}
       }
     }
-    L<<Logger::Info<<"Had "<<totremove<<" RPZ removal"<<addS(totremove)<<", "<<totadd<<" addition"<<addS(totadd)<<" for "<<zone<<" New serial: "<<oursr->d_st.serial<<endl;
+    g_log<<Logger::Info<<"Had "<<totremove<<" RPZ removal"<<addS(totremove)<<", "<<totadd<<" addition"<<addS(totadd)<<" for "<<zone<<" New serial: "<<oursr->d_st.serial<<endl;
     g_luaconfs.setState(luaconfsCopy);
   }
 }
@@ -414,7 +414,7 @@ SyncRes::domainmap_t* parseAuthAndForwar
       // headers.first=toCanonic("", headers.first);
       if(n==0) {
         ad.d_rdForward = false;
-        L<<Logger::Error<<"Parsing authoritative data for zone '"<<headers.first<<"' from file '"<<headers.second<<"'"<<endl;
+        g_log<<Logger::Error<<"Parsing authoritative data for zone '"<<headers.first<<"' from file '"<<headers.second<<"'"<<endl;
         ZoneParserTNG zpt(headers.second, DNSName(headers.first));
         DNSResourceRecord rr;
 	DNSRecord dr;
@@ -436,13 +436,13 @@ SyncRes::domainmap_t* parseAuthAndForwar
         }
       }
       else {
-        L<<Logger::Error<<"Redirecting queries for zone '"<<headers.first<<"' ";
+        g_log<<Logger::Error<<"Redirecting queries for zone '"<<headers.first<<"' ";
         if(n == 2) {
-          L<<"with recursion ";
+          g_log<<"with recursion ";
           ad.d_rdForward = true;
         }
         else ad.d_rdForward = false;
-        L<<"to: ";
+        g_log<<"to: ";
         
         convertServersForAD(headers.second, ad, ";");
         if(n == 2) {
@@ -455,7 +455,7 @@ SyncRes::domainmap_t* parseAuthAndForwar
   }
   
   if(!::arg()["forward-zones-file"].empty()) {
-    L<<Logger::Warning<<"Reading zone forwarding information from '"<<::arg()["forward-zones-file"]<<"'"<<endl;
+    g_log<<Logger::Warning<<"Reading zone forwarding information from '"<<::arg()["forward-zones-file"]<<"'"<<endl;
     SyncRes::AuthDomain ad;
     FILE *rfp=fopen(::arg()["forward-zones-file"].c_str(), "r");
 
@@ -502,7 +502,7 @@ SyncRes::domainmap_t* parseAuthAndForwar
 
       (*newMap)[DNSName(domain)]=ad;
     }
-    L<<Logger::Warning<<"Done parsing " << newMap->size() - before<<" forwarding instructions from file '"<<::arg()["forward-zones-file"]<<"'"<<endl;
+    g_log<<Logger::Warning<<"Done parsing " << newMap->size() - before<<" forwarding instructions from file '"<<::arg()["forward-zones-file"]<<"'"<<endl;
   }
 
   if(::arg().mustDo("export-etc-hosts")) {
@@ -511,7 +511,7 @@ SyncRes::domainmap_t* parseAuthAndForwar
     
     ifstream ifs(fname.c_str());
     if(!ifs) {
-      L<<Logger::Warning<<"Could not open /etc/hosts for reading"<<endl;
+      g_log<<Logger::Warning<<"Could not open /etc/hosts for reading"<<endl;
     }
     else {
       string searchSuffix = ::arg()["export-etc-hosts-search-suffix"];
@@ -543,7 +543,7 @@ SyncRes::domainmap_t* parseAuthAndForwar
     }
   }
   if(::arg().mustDo("serve-rfc1918")) {
-    L<<Logger::Warning<<"Inserting rfc 1918 private space zones"<<endl;
+    g_log<<Logger::Warning<<"Inserting rfc 1918 private space zones"<<endl;
     parts.clear();
     parts.push_back("127");
     makeIPToNamesZone(newMap, parts);
--- remote_logger.cc.orig	2018-11-06 14:56:58 UTC
+++ remote_logger.cc
@@ -21,7 +21,7 @@ bool RemoteLogger::reconnect()
   }
   catch(const std::exception& e) {
 #ifdef WE_ARE_RECURSOR
-    L<<Logger::Warning<<"Error connecting to remote logger "<<d_remote.toStringWithPort()<<": "<<e.what()<<std::endl;
+    g_log<<Logger::Warning<<"Error connecting to remote logger "<<d_remote.toStringWithPort()<<": "<<e.what()<<std::endl;
 #else
     warnlog("Error connecting to remote logger %s: %s", d_remote.toStringWithPort(), e.what());
 #endif
@@ -56,7 +56,7 @@ void RemoteLogger::worker()
     }
     catch(const std::runtime_error& e) {
 #ifdef WE_ARE_RECURSOR
-      L<<Logger::Info<<"Error sending data to remote logger "<<d_remote.toStringWithPort()<<": "<< e.what()<<endl;
+      g_log<<Logger::Info<<"Error sending data to remote logger "<<d_remote.toStringWithPort()<<": "<< e.what()<<endl;
 #else
       vinfolog("Error sending data to remote logger (%s): %s", d_remote.toStringWithPort(), e.what());
 #endif
--- rpzloader.cc.orig	2018-11-06 14:56:58 UTC
+++ rpzloader.cc
@@ -159,9 +159,9 @@ void RPZRecordToPolicy(const DNSRecord& 
 
 shared_ptr<SOARecordContent> loadRPZFromServer(const ComboAddress& master, const DNSName& zone, DNSFilterEngine& target, boost::optional<DNSFilterEngine::Policy> defpol, size_t place, const TSIGTriplet& tt, size_t maxReceivedBytes, const ComboAddress& localAddress)
 {
-  L<<Logger::Warning<<"Loading RPZ zone '"<<zone<<"' from "<<master.toStringWithPort()<<endl;
+  g_log<<Logger::Warning<<"Loading RPZ zone '"<<zone<<"' from "<<master.toStringWithPort()<<endl;
   if(!tt.name.empty())
-    L<<Logger::Warning<<"With TSIG key '"<<tt.name<<"' of algorithm '"<<tt.algo<<"'"<<endl;
+    g_log<<Logger::Warning<<"With TSIG key '"<<tt.name<<"' of algorithm '"<<tt.algo<<"'"<<endl;
 
   ComboAddress local(localAddress);
   if (local == ComboAddress())
@@ -189,11 +189,11 @@ shared_ptr<SOARecordContent> loadRPZFrom
       nrecords++;
     } 
     if(last != time(0)) {
-      L<<Logger::Info<<"Loaded & indexed "<<nrecords<<" policy records so far"<<endl;
+      g_log<<Logger::Info<<"Loaded & indexed "<<nrecords<<" policy records so far"<<endl;
       last=time(0);
     }
   }
-  L<<Logger::Info<<"Done: "<<nrecords<<" policy records active, SOA: "<<sr->getZoneRepresentation()<<endl;
+  g_log<<Logger::Info<<"Done: "<<nrecords<<" policy records active, SOA: "<<sr->getZoneRepresentation()<<endl;
   return sr;
 }
 
--- secpoll-recursor.cc.orig	2018-11-06 14:56:58 UTC
+++ secpoll-recursor.cc
@@ -53,7 +53,7 @@ void doSecPoll(time_t* last_secpoll)
   }
 
   if(state == Bogus) {
-    L<<Logger::Error<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', DNSSEC validation result was Bogus!"<<endl;
+    g_log<<Logger::Error<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', DNSSEC validation result was Bogus!"<<endl;
     if(g_security_status == 1) // If we were OK, go to unknown
       g_security_status = 0;
     return;
@@ -77,18 +77,18 @@ void doSecPoll(time_t* last_secpoll)
   }
   else {
     if(pkgv.find("0.0."))
-      L<<Logger::Warning<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', RCODE = "<< RCode::to_s(res)<<endl;
+      g_log<<Logger::Warning<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', RCODE = "<< RCode::to_s(res)<<endl;
     else
-      L<<Logger::Warning<<"Ignoring response for security status update, this is a non-release version."<<endl;
+      g_log<<Logger::Warning<<"Ignoring response for security status update, this is a non-release version."<<endl;
 
     if(g_security_status == 1) // it was ok, now it is unknown
       g_security_status = 0;
   }
 
   if(g_security_status == 2) {
-    L<<Logger::Error<<"PowerDNS Security Update Recommended: "<<g_security_message<<endl;
+    g_log<<Logger::Error<<"PowerDNS Security Update Recommended: "<<g_security_message<<endl;
   }
   else if(g_security_status == 3) {
-    L<<Logger::Error<<"PowerDNS Security Update Mandatory: "<<g_security_message<<endl;
+    g_log<<Logger::Error<<"PowerDNS Security Update Mandatory: "<<g_security_message<<endl;
   }
 }
--- syncres.cc.orig	2018-11-06 14:56:58 UTC
+++ syncres.cc
@@ -78,7 +78,7 @@ unsigned int SyncRes::s_maxdepth;
 string SyncRes::s_serverID;
 SyncRes::LogMode SyncRes::s_lm;
 
-#define LOG(x) if(d_lm == Log) { L <<Logger::Warning << x; } else if(d_lm == Store) { d_trace << x; }
+#define LOG(x) if(d_lm == Log) { g_log <<Logger::Warning << x; } else if(d_lm == Store) { d_trace << x; }
 
 bool SyncRes::s_noEDNS;
 
--- unix_utility.cc.orig	2018-11-06 14:56:58 UTC
+++ unix_utility.cc
@@ -85,22 +85,22 @@ void Utility::setBindAny(int af, sock_t 
   (void) one; // avoids 'unused var' warning on systems that have none of the defines checked below
 #ifdef IP_FREEBIND
   if (setsockopt(sock, IPPROTO_IP, IP_FREEBIND, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: IP_FREEBIND setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: IP_FREEBIND setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 
 #ifdef IP_BINDANY
   if (af == AF_INET)
     if (setsockopt(sock, IPPROTO_IP, IP_BINDANY, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: IP_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: IP_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 #ifdef IPV6_BINDANY
   if (af == AF_INET6)
     if (setsockopt(sock, IPPROTO_IPV6, IPV6_BINDANY, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: IPV6_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: IPV6_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 #ifdef SO_BINDANY
   if (setsockopt(sock, SOL_SOCKET, SO_BINDANY, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: SO_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: SO_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 }
 
@@ -129,22 +129,22 @@ void Utility::dropGroupPrivs( int uid, i
 {
   if(gid) {
     if(setgid(gid)<0) {
-      theL()<<Logger::Critical<<"Unable to set effective group id to "<<gid<<": "<<stringerror()<<endl;
+      g_log<<Logger::Critical<<"Unable to set effective group id to "<<gid<<": "<<stringerror()<<endl;
       exit(1);
     }
     else
-      theL()<<Logger::Info<<"Set effective group id to "<<gid<<endl;
+      g_log<<Logger::Info<<"Set effective group id to "<<gid<<endl;
 
     struct passwd *pw=getpwuid(uid);
     if(!pw) {
-      theL()<<Logger::Warning<<"Unable to determine user name for uid "<<uid<<endl;
+      g_log<<Logger::Warning<<"Unable to determine user name for uid "<<uid<<endl;
       if (setgroups(0, NULL)<0) {
-        theL()<<Logger::Critical<<"Unable to drop supplementary gids: "<<stringerror()<<endl;
+        g_log<<Logger::Critical<<"Unable to drop supplementary gids: "<<stringerror()<<endl;
         exit(1);
       }
     } else {
       if (initgroups(pw->pw_name, gid)<0) {
-        theL()<<Logger::Critical<<"Unable to set supplementary groups: "<<stringerror()<<endl;
+        g_log<<Logger::Critical<<"Unable to set supplementary groups: "<<stringerror()<<endl;
         exit(1);
       }
     }
@@ -157,11 +157,11 @@ void Utility::dropUserPrivs( int uid )
 {
   if(uid) {
     if(setuid(uid)<0) {
-      theL()<<Logger::Critical<<"Unable to set effective user id to "<<uid<<":  "<<stringerror()<<endl;
+      g_log<<Logger::Critical<<"Unable to set effective user id to "<<uid<<":  "<<stringerror()<<endl;
       exit(1);
     }
     else
-      theL()<<Logger::Info<<"Set effective user id to "<<uid<<endl;
+      g_log<<Logger::Info<<"Set effective user id to "<<uid<<endl;
   }
 }
 
@@ -189,7 +189,7 @@ int Utility::makeGidNumeric(const string
     errno=0;
     struct group *gr=getgrnam(group.c_str());
     if(!gr) {
-      theL()<<Logger::Critical<<"Unable to look up gid of group '"<<group<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
+      g_log<<Logger::Critical<<"Unable to look up gid of group '"<<group<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
       exit(1);
     }
     newgid=gr->gr_gid;
@@ -205,7 +205,7 @@ int Utility::makeUidNumeric(const string
   if(!(newuid=atoi(username.c_str()))) {
     struct passwd *pw=getpwnam(username.c_str());
     if(!pw) {
-      theL()<<Logger::Critical<<"Unable to look up uid of user '"<<username<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
+      g_log<<Logger::Critical<<"Unable to look up uid of user '"<<username<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
       exit(1);
     }
     newuid=pw->pw_uid;
--- validate-recursor.cc.orig	2018-11-06 14:56:58 UTC
+++ validate-recursor.cc
@@ -6,7 +6,7 @@
 DNSSECMode g_dnssecmode{DNSSECMode::ProcessNoValidate};
 bool g_dnssecLogBogus;
 
-#define LOG(x) if(g_dnssecLOG) { L <<Logger::Warning << x; }
+#define LOG(x) if(g_dnssecLOG) { g_log <<Logger::Warning << x; }
 
 class SRRecordOracle : public DNSRecordOracle
 {
--- validate.cc.orig	2018-11-06 14:56:58 UTC
+++ validate.cc
@@ -6,7 +6,7 @@
 #include "logger.hh"
 bool g_dnssecLOG{false};
 
-#define LOG(x) if(g_dnssecLOG) { L <<Logger::Warning << x; }
+#define LOG(x) if(g_dnssecLOG) { g_log <<Logger::Warning << x; }
 void dotEdge(DNSName zone, string type1, DNSName name1, string tag1, string type2, DNSName name2, string tag2, string color="");
 void dotNode(string type, DNSName name, string tag, string content);
 string dotName(string type, DNSName name, string tag);
--- version.cc.orig	2018-11-06 14:56:58 UTC
+++ version.cc
@@ -72,22 +72,22 @@ string productTypeApiType() {
 
 void showProductVersion()
 {
-  theL()<<Logger::Warning<<productName()<<" "<< VERSION << " (C) 2001-2017 "
+  g_log<<Logger::Warning<<productName()<<" "<< VERSION << " (C) 2001-2017 "
     "PowerDNS.COM BV" << endl;
-  theL()<<Logger::Warning<<"Using "<<(sizeof(unsigned long)*8)<<"-bits mode. "
+  g_log<<Logger::Warning<<"Using "<<(sizeof(unsigned long)*8)<<"-bits mode. "
     "Built using " << compilerVersion()
 #ifndef REPRODUCIBLE
     <<" on " __DATE__ " " __TIME__ " by " BUILD_HOST
 #endif
     <<"."<< endl;
-  theL()<<Logger::Warning<<"PowerDNS comes with ABSOLUTELY NO WARRANTY. "
+  g_log<<Logger::Warning<<"PowerDNS comes with ABSOLUTELY NO WARRANTY. "
     "This is free software, and you are welcome to redistribute it "
     "according to the terms of the GPL version 2." << endl;
 }
 
 void showBuildConfiguration()
 {
-  theL()<<Logger::Warning<<"Features: "<<
+  g_log<<Logger::Warning<<"Features: "<<
 #ifdef HAVE_BOTAN
     "botan" << BOTAN_VERSION_MAJOR << "." << BOTAN_VERSION_MINOR  << " " <<
 #endif
@@ -113,12 +113,12 @@ void showBuildConfiguration()
     endl;
 #ifdef PDNS_MODULES
   // Auth only
-  theL()<<Logger::Warning<<"Built-in modules: "<<PDNS_MODULES<<endl;
+  g_log<<Logger::Warning<<"Built-in modules: "<<PDNS_MODULES<<endl;
 #endif
 #ifdef PDNS_CONFIG_ARGS
 #define double_escape(s) #s
 #define escape_quotes(s) double_escape(s)
-  theL()<<Logger::Warning<<"Configured with: "<<escape_quotes(PDNS_CONFIG_ARGS)<<endl;
+  g_log<<Logger::Warning<<"Configured with: "<<escape_quotes(PDNS_CONFIG_ARGS)<<endl;
 #undef escape_quotes
 #undef double_escape
 #endif
--- webserver.cc.orig	2018-11-06 14:56:58 UTC
+++ webserver.cc
@@ -43,12 +43,12 @@ json11::Json HttpRequest::json()
 {
   string err;
   if(this->body.empty()) {
-    L<<Logger::Debug<<"HTTP: JSON document expected in request body, but body was empty" << endl;
+    g_log<<Logger::Debug<<"HTTP: JSON document expected in request body, but body was empty" << endl;
     throw HttpBadRequestException();
   }
   json11::Json doc = json11::Json::parse(this->body, err);
   if (doc.is_null()) {
-    L<<Logger::Debug<<"HTTP: parsing of JSON document failed:" << err << endl;
+    g_log<<Logger::Debug<<"HTTP: parsing of JSON document failed:" << err << endl;
     throw HttpBadRequestException();
   }
   return doc;
@@ -136,13 +136,13 @@ static void apiWrapper(WebServer::Handle
   resp->headers["access-control-allow-origin"] = "*";
 
   if (api_key.empty()) {
-    L<<Logger::Error<<"HTTP API Request \"" << req->url.path << "\": Authentication failed, API Key missing in config" << endl;
+    g_log<<Logger::Error<<"HTTP API Request \"" << req->url.path << "\": Authentication failed, API Key missing in config" << endl;
     throw HttpUnauthorizedException("X-API-Key");
   }
   bool auth_ok = req->compareHeader("x-api-key", api_key) || req->getvars["api-key"]==api_key;
   
   if (!auth_ok) {
-    L<<Logger::Error<<"HTTP Request \"" << req->url.path << "\": Authentication by API Key failed" << endl;
+    g_log<<Logger::Error<<"HTTP Request \"" << req->url.path << "\": Authentication by API Key failed" << endl;
     throw HttpUnauthorizedException("X-API-Key");
   }
 
@@ -185,7 +185,7 @@ static void webWrapper(WebServer::Handle
   if (!web_password.empty()) {
     bool auth_ok = req->compareAuthorization(web_password);
     if (!auth_ok) {
-      L<<Logger::Debug<<"HTTP Request \"" << req->url.path << "\": Web Authentication failed" << endl;
+      g_log<<Logger::Debug<<"HTTP Request \"" << req->url.path << "\": Web Authentication failed" << endl;
       throw HttpUnauthorizedException("Basic");
     }
   }
@@ -216,11 +216,11 @@ void WebServer::handleRequest(HttpReques
 
   try {
     if (!req.complete) {
-      L<<Logger::Debug<<"HTTP: Incomplete request" << endl;
+      g_log<<Logger::Debug<<"HTTP: Incomplete request" << endl;
       throw HttpBadRequestException();
     }
 
-    L<<Logger::Debug<<"HTTP: Handling request \"" << req.url.path << "\"" << endl;
+    g_log<<Logger::Debug<<"HTTP: Handling request \"" << req.url.path << "\"" << endl;
 
     YaHTTP::strstr_map_t::iterator header;
 
@@ -235,33 +235,33 @@ void WebServer::handleRequest(HttpReques
 
     YaHTTP::THandlerFunction handler;
     if (!YaHTTP::Router::Route(&req, handler)) {
-      L<<Logger::Debug<<"HTTP: No route found for \"" << req.url.path << "\"" << endl;
+      g_log<<Logger::Debug<<"HTTP: No route found for \"" << req.url.path << "\"" << endl;
       throw HttpNotFoundException();
     }
 
     try {
       handler(&req, &resp);
-      L<<Logger::Debug<<"HTTP: Result for \"" << req.url.path << "\": " << resp.status << ", body length: " << resp.body.size() << endl;
+      g_log<<Logger::Debug<<"HTTP: Result for \"" << req.url.path << "\": " << resp.status << ", body length: " << resp.body.size() << endl;
     }
     catch(HttpException&) {
       throw;
     }
     catch(PDNSException &e) {
-      L<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Exception: " << e.reason << endl;
+      g_log<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Exception: " << e.reason << endl;
       throw HttpInternalServerErrorException();
     }
     catch(std::exception &e) {
-      L<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": STL Exception: " << e.what() << endl;
+      g_log<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": STL Exception: " << e.what() << endl;
       throw HttpInternalServerErrorException();
     }
     catch(...) {
-      L<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Unknown Exception" << endl;
+      g_log<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Unknown Exception" << endl;
       throw HttpInternalServerErrorException();
     }
   }
   catch(HttpException &e) {
     resp = e.response();
-    L<<Logger::Debug<<"HTTP: Error result for \"" << req.url.path << "\": " << resp.status << endl;
+    g_log<<Logger::Debug<<"HTTP: Error result for \"" << req.url.path << "\": " << resp.status << endl;
     string what = YaHTTP::Utility::status2text(resp.status);
     if(req.accept_html) {
       resp.headers["Content-Type"] = "text/html; charset=utf-8";
@@ -321,14 +321,14 @@ try {
   client->writenWithTimeout(reply.c_str(), reply.size(), timeout);
 }
 catch(PDNSException &e) {
-  L<<Logger::Error<<"HTTP Exception: "<<e.reason<<endl;
+  g_log<<Logger::Error<<"HTTP Exception: "<<e.reason<<endl;
 }
 catch(std::exception &e) {
   if(strstr(e.what(), "timeout")==0)
-    L<<Logger::Error<<"HTTP STL Exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"HTTP STL Exception: "<<e.what()<<endl;
 }
 catch(...) {
-  L<<Logger::Error<<"HTTP: Unknown exception"<<endl;
+  g_log<<Logger::Error<<"HTTP: Unknown exception"<<endl;
 }
 
 WebServer::WebServer(const string &listenaddress, int port) : d_server(NULL)
@@ -341,10 +341,10 @@ void WebServer::bind()
 {
   try {
     d_server = createServer();
-    L<<Logger::Warning<<"Listening for HTTP requests on "<<d_server->d_local.toStringWithPort()<<endl;
+    g_log<<Logger::Warning<<"Listening for HTTP requests on "<<d_server->d_local.toStringWithPort()<<endl;
   }
   catch(NetworkError &e) {
-    L<<Logger::Error<<"Listening on HTTP socket failed: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Listening on HTTP socket failed: "<<e.what()<<endl;
     d_server = NULL;
   }
 }
@@ -369,20 +369,20 @@ void WebServer::go()
       } else {
         ComboAddress remote;
         if (data->client->getRemote(remote))
-          L<<Logger::Error<<"Webserver closing socket: remote ("<< remote.toString() <<") does not match 'webserver-allow-from'"<<endl;
+          g_log<<Logger::Error<<"Webserver closing socket: remote ("<< remote.toString() <<") does not match 'webserver-allow-from'"<<endl;
         delete data->client; // close socket
         delete data;
       }
     }
   }
   catch(PDNSException &e) {
-    L<<Logger::Error<<"PDNSException in main webserver thread: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"PDNSException in main webserver thread: "<<e.reason<<endl;
   }
   catch(std::exception &e) {
-    L<<Logger::Error<<"STL Exception in main webserver thread: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"STL Exception in main webserver thread: "<<e.what()<<endl;
   }
   catch(...) {
-    L<<Logger::Error<<"Unknown exception in main webserver thread"<<endl;
+    g_log<<Logger::Error<<"Unknown exception in main webserver thread"<<endl;
   }
   exit(1);
 }
--- ws-recursor.cc.orig	2018-11-06 14:56:58 UTC
+++ ws-recursor.cc
@@ -597,7 +597,7 @@ void AsyncWebServer::serveConnection(Soc
 
   // now send the reply
   if (asendtcp(data, client) == -1 || data.empty()) {
-    L<<Logger::Error<<"Failed sending reply to HTTP client"<<endl;
+    g_log<<Logger::Error<<"Failed sending reply to HTTP client"<<endl;
   }
 }
 
