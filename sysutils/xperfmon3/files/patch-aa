diff -cd -N ../xperfmon++/freebsd_system.c ./freebsd_system.c
*** ../xperfmon++/freebsd_system.c	Thu Jan  1 01:00:00 1970
--- ./freebsd_system.c	Mon May  6 18:39:46 1996
***************
*** 0 ****
--- 1,580 ----
+ /*
+  * Perfmon Performance Monitor
+  *
+  * Copyright 1985, Massachusetts Institute of Technology
+  * Copyright 1989, PCS Computer Systeme GmbH, West Germany
+  * Copyright 1994, Sterling Software @ NASA-Ames Research Center
+  * Copyright 1995, Regents of the University of California,
+  *                 Lars Köller <Lars_Koeller@odie.physik2.uni-rostock.de
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+  * documentation for any purpose is hereby granted without fee, provided that
+  * the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of PCS and Sterling Software not be used in advertising or
+  * publicity pertaining to distribution of the software without specific,
+  * written prior permission.  PCS and Sterling Software makes no representations about the
+  * suitability of this software for any purpose.  It is provided "as is"
+  * without express or implied warranty.
+  *
+  * PCS & STERLING SOFTWARE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL PCS & STERLING SOFTWARE
+  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * Original Author:  Emanuel Jay Berkenbilt, MIT Project Athena
+  * Author:           Thomas A. Baghli, PCS Computer Systeme GmbH, West Germany
+  *                   tom@meepmeep.pcs.com
+  * 1994 Revision
+  * Author:           Roger Smith, Sterling Software @ NASA-Ames Research Center
+  *                   Moffett Field, California, rsmith@proteus.arc.nasa.gov
+  * 1995 FreeBSD 2.x Version
+  * Author:           Lars Koeller, Univerity of Rostock, Germany
+  *                   Lars_Koeller@odie.physik2.uni-rostock.de
+  */
+ 
+ /* This file contains only system functions - that is the functions that
+  * get the information the performance monitor is monitoring.  No calls
+  * to any X routines should be made here.  The reason for doing this is
+  * so that as the X toolkit becomes available and the X window system 
+  * improves no changes will have to be made to this file, and as this
+  * program is made available for a new type of machine, only this file
+  * will need to be changed.
+  */
+ 
+ #ifdef _HAVE_PARAM_H
+ #include <sys/param.h>
+ #endif
+ 
+ #if (defined(BSD) && (BSD >= 199306))
+ # include <osreldate.h>
+ #else
+ # error You have to use at least a FreeBSD 2.X system
+ #endif
+ 
+ #include <X11/IntrinsicP.h>
+ 
+ #include "system.h"
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <strings.h>
+ #include <unistd.h>
+ #include <paths.h>
+ #include <kvm.h>
+ #include <nlist.h>
+ #include <limits.h>
+ #include <errno.h>
+ #include <err.h>
+ 
+ #include <sys/file.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ #include <sys/sysctl.h>
+ #include <sys/dkstat.h>
+ #include <sys/buf.h>
+ #include <sys/vmmeter.h>
+ #include <vm/vm.h>
+ #include <net/if.h>
+ #include <netinet/in.h>
+ #include <sys/stat.h>
+ #include <sys/conf.h>
+ #include <sys/rlist.h>
+ #include <sys/mount.h>
+ #include <nfs/nfsv2.h>
+ #include <nfs/nfs.h>
+ 
+ #ifndef CTL_FS
+ #define CTL_FS CTL_VFS		/* compatibility w/ Lite1 */
+ #endif
+ 
+ /*
+  * XXX temporary hack: FreeBSD-2.2-current has been floating around
+  * with 199508 for some time; FreeBSD-2.1 will be 199511 however (so
+  * 2.2-current has been bumped to 199512 recently).  Recognize the old
+  * 2.2-current as NFSv3 for a grace period.
+  * FreeBSD 2.0.5 was 199504, btw.  Both, 2.0.5 and 2.1 don't have
+  * NFSv3.
+  */
+ #if __FreeBSD_version > 199511 || __FreeBSD_version == 199508
+ # define HAS_NFS_V3
+ #endif /* FreeBSD_version */
+ 
+ #include "is.h"
+ 
+ #ifndef TRUE
+ #define TRUE 1
+ #define FALSE 0
+ #endif
+ 
+ #define WANT_STAT(x) (poss_stats[(x)] != NO_STAT)
+ 
+ /*
+     Function Prototypes
+ */
+ static int get_namelist(const char *kernel_name, const char *memory_name);
+ static void kread(int nlx, void *addr, size_t size);
+ static void collect_stats(void);
+ static int total_disk_transfers(void);
+ static int get_swapspace(void);
+ 
+ /*
+     Variables & Structs
+ */
+ static unsigned long *intrcnt;
+ static int nintr, hz;
+ static kvm_t *kd;
+ static char errbuf[_POSIX2_LINE_MAX];
+ static char dr_name[DK_NDRIVE][DK_NAMELEN];
+ static double etime;
+ 
+ int current_values[NUM_GRAPHS];
+ stat_type stats;
+ 
+ extern Widget perfmon[NUM_GRAPHS];
+ 
+ static struct packet {
+     int input, output, collisions;
+ } packets, old_packets;
+ 
+ static struct nfsstats nfsstats;
+ static struct _nfsStats {
+     int nfsServer, nfsClient;
+ } nfsStats, old_nfsStats;
+ 
+ struct nlist nl[] = {
+ #define X_CPTIME	0
+ 	{ "_cp_time" },
+ #define X_SUM	   	1
+ 	{ "_cnt" },
+ #define X_BOOTTIME      2
+ 	{ "_boottime" },
+ #define X_DKXFER	3
+ 	{ "_dk_xfer" },
+ #define X_HZ	    	4
+ 	{ "_hz" },
+ #define N_IFNET       	5
+ 	{ "_ifnet" },
+ #define X_INTRCNT 	6
+         { "_intrcnt" },
+ #define X_EINTRCNT 	7
+         { "_eintrcnt" },
+ #define VM_NSWAP        8
+         { "_nswap" },   /* size of largest swap device */
+ #define VM_NSWDEV       9
+         { "_nswdev" },  /* number of swap devices */
+ #define VM_DMMAX        10
+         { "_dmmax" },   /* maximum size of a swap block */
+ #define VM_SWAPLIST     11
+         { "_swaplist" },/* list of free swap areas */
+ #define VM_SWDEVT       12
+         { "_swdevt" },  /* list of swap devices and sizes */
+         { "" },
+ };
+ 
+ struct {
+ 	long    time[CPUSTATES];
+ 	long    xfer[DK_NDRIVE];
+ 	struct  vmmeter Sum;
+ 	struct  vmmeter Rate;
+ 	int interrupts;
+ } s, s1;
+ 
+ int first_time_getswap;
+ 
+ #define rate s.Rate
+ #define sum  s.Sum
+ 
+ /*
+     This routine does all necessary setting up of structures
+     that will handle system calls.
+ */
+ void sys_setup()
+ {
+     get_namelist(getbootfile(), _PATH_KMEM);
+     collect_stats();
+     /* hack to enforce a resize of the 'Free Swap' graph
+        without this the left border always displays the first drawn line
+        cause this field isn't resized very often due to slow change of
+        the free swapspace! */
+     first_time_getswap = 1;
+     etime = 1.0;
+ }
+ 
+ 
+ /*
+     Update the data structures
+ */
+ void update_stats()
+ {
+     int state;
+     double pct, tot;;
+ 
+     collect_stats();
+ 
+     tot = 0;
+     for (state = 0; state < CPUSTATES; ++state)
+         tot += s.time[state];
+     if (tot)
+         pct = 100 / tot;
+     else
+         pct = 0;
+     current_values[USER_CPU_PERCENTAGE] = (s.time[CP_USER] + s.time[CP_NICE]) * pct;
+     current_values[SYSTEM_CPU_PERCENTAGE] = (s.time[CP_SYS] + s.time[CP_INTR]) * pct;;
+     current_values[IDLE_CPU_PERCENTAGE] = s.time[CP_IDLE] * pct;
+ 
+     if (perfmon[FREE_MEM]) {
+ 	if(!first_time_getswap)
+ 	  current_values[FREE_MEM] = get_swapspace();
+ 	else {
+ 	  current_values[FREE_MEM] = 100;
+ 	  first_time_getswap = 0;
+ 	}
+     }
+     if (perfmon[DISK_TRANSFERS])
+ 	current_values[DISK_TRANSFERS] = total_disk_transfers();
+     if (perfmon[INTERRUPTS])
+       current_values[INTERRUPTS] = (s.interrupts - s1.interrupts)/etime;
+     if (perfmon[INPUT_PACKETS])
+ 	current_values[INPUT_PACKETS] = (packets.input - old_packets.input)/etime;
+     if (perfmon[OUTPUT_PACKETS])
+ 	current_values[OUTPUT_PACKETS] = (packets.output - old_packets.output)/etime;
+     if (perfmon[COLLISION_PACKETS])
+ 	current_values[COLLISION_PACKETS] = (packets.collisions - old_packets.collisions)/etime;
+     if (perfmon[NFS_CLIENT_CALLS])
+ 	current_values[NFS_CLIENT_CALLS] = (nfsStats.nfsClient - old_nfsStats.nfsClient)/etime;
+     if (perfmon[NFS_SERVER_CALLS])
+ 	current_values[NFS_SERVER_CALLS] = (nfsStats.nfsServer - old_nfsStats.nfsServer)/etime;
+ }
+ 
+ 
+ /*
+     Collect the overall disk transfer rates
+ */
+ int
+ total_disk_transfers()
+ {
+     register int i, total_xfers = 0;
+ 
+     for(i=0; i < DK_NDRIVE; i++)
+ 	total_xfers += s.xfer[i];
+     return(total_xfers/etime);
+ }
+ 
+ 
+ /*
+     Collect all the data
+ */
+ void
+ collect_stats()
+ {
+     off_t ifnetaddr;
+     register int i, tmp;
+     int mib[3], size;
+ 
+     kread(X_CPTIME, s.time, sizeof(s.time));
+     kread(X_DKXFER, s.xfer, sizeof(s.xfer));
+     kread(X_SUM, &sum, sizeof(sum) );
+ 
+     nintr = nl[X_EINTRCNT].n_value - nl[X_INTRCNT].n_value;
+     if ((intrcnt = (unsigned long *) malloc((size_t) nintr)) == NULL)
+       err(1, "xperfmon++ malloc in collect_stats");
+     nintr /= sizeof(long);    
+     kread(X_INTRCNT, intrcnt, (size_t) nintr*sizeof(long));
+     s1.interrupts = s.interrupts;
+     s.interrupts = 0;
+     for (i = 0; i < nintr; i++)
+         s.interrupts += *(intrcnt + i);
+ 
+     free(intrcnt);
+     etime = 0;
+     for (i=0; i < DK_NDRIVE; i++) {
+ 	tmp = s.xfer[i];
+ 	s.xfer[i] -= s1.xfer[i];
+ 	s1.xfer[i] = tmp;
+     }
+     for (i=0; i < CPUSTATES; i++) {
+ 	tmp = s.time[i];
+ 	s.time[i] -= s1.time[i];
+ 	s1.time[i] = tmp;
+ 	etime += s.time[i];
+     }
+     if(etime == 0.)
+ 	etime = 1.;
+     etime /= hz;
+ 
+ /*
+     Collect the Network-Traffic
+ */
+ 
+     if (nl[N_IFNET].n_value != 0) {
+ 	struct ifnet ifnet;
+ 	kread(N_IFNET, &ifnetaddr, sizeof(ifnetaddr));
+ 	old_packets = packets;
+ 	packets.input = packets.output = packets.collisions = 0;
+ 	while (ifnetaddr) {
+ 	    kvm_read(kd, ifnetaddr, &ifnet, sizeof ifnet );
+ 	    packets.input += ifnet.if_ipackets;
+ 	    packets.output += ifnet.if_opackets;
+ 	    packets.collisions += ifnet.if_collisions;
+ 	    ifnetaddr = (u_long) ifnet.if_next;
+ 	}
+     }
+ 
+ /*
+     Collect the NFS and RPC Calls
+ */
+ 
+     size = sizeof(nfsstats);
+     mib[0] = CTL_FS;
+     mib[1] = MOUNT_NFS;
+     mib[2] = NFS_NFSSTATS;
+ 
+     if (sysctl( mib, 3, &nfsstats, &size, NULL, 0) < 0)
+         return;
+     else {
+         old_nfsStats = nfsStats;
+ 
+         nfsStats.nfsClient = nfsstats.rpccnt[NFSPROC_GETATTR] + 
+                              nfsstats.rpccnt[NFSPROC_SETATTR] +
+                              nfsstats.rpccnt[NFSPROC_LOOKUP] +
+                              nfsstats.rpccnt[NFSPROC_READLINK] +
+                              nfsstats.rpccnt[NFSPROC_READ] +
+                              nfsstats.rpccnt[NFSPROC_WRITE] +
+                              nfsstats.rpccnt[NFSPROC_CREATE] +
+                              nfsstats.rpccnt[NFSPROC_REMOVE] +
+                              nfsstats.rpccnt[NFSPROC_RENAME] +
+                              nfsstats.rpccnt[NFSPROC_LINK] +
+                              nfsstats.rpccnt[NFSPROC_SYMLINK] +
+                              nfsstats.rpccnt[NFSPROC_MKDIR] +
+                              nfsstats.rpccnt[NFSPROC_RMDIR] + 
+                              nfsstats.rpccnt[NFSPROC_READDIR] +
+ #ifndef HAS_NFS_V3
+                              nfsstats.rpccnt[NFSPROC_STATFS] +
+                              nfsstats.rpccnt[NQNFSPROC_READDIRLOOK] +
+ #else /* HAS_NFS_V3 */
+                              nfsstats.rpccnt[NFSPROC_READDIRPLUS] +
+                              nfsstats.rpccnt[NFSPROC_FSSTAT] +
+                              nfsstats.rpccnt[NFSPROC_FSINFO] +
+                              nfsstats.rpccnt[NFSPROC_PATHCONF] +
+                              nfsstats.rpccnt[NFSPROC_COMMIT] +
+ #endif /* HAS_NFS_V3 */
+                              nfsstats.rpccnt[NQNFSPROC_GETLEASE] +
+                              nfsstats.rpccnt[NQNFSPROC_VACATED] +
+                              nfsstats.rpccnt[NQNFSPROC_EVICTED];
+ 
+         nfsStats.nfsServer = nfsstats.srvrpccnt[NFSPROC_GETATTR] + 
+                              nfsstats.srvrpccnt[NFSPROC_SETATTR] +
+                              nfsstats.srvrpccnt[NFSPROC_LOOKUP] +
+                              nfsstats.srvrpccnt[NFSPROC_READLINK] +
+                              nfsstats.srvrpccnt[NFSPROC_READ] +
+                              nfsstats.srvrpccnt[NFSPROC_WRITE] +
+                              nfsstats.srvrpccnt[NFSPROC_CREATE] +
+                              nfsstats.srvrpccnt[NFSPROC_REMOVE] +
+                              nfsstats.srvrpccnt[NFSPROC_RENAME] +
+                              nfsstats.srvrpccnt[NFSPROC_LINK] +
+                              nfsstats.srvrpccnt[NFSPROC_SYMLINK] +
+                              nfsstats.srvrpccnt[NFSPROC_MKDIR] +
+                              nfsstats.srvrpccnt[NFSPROC_RMDIR] + 
+                              nfsstats.srvrpccnt[NFSPROC_READDIR] +
+ #ifndef HAS_NFS_V3
+                              nfsstats.srvrpccnt[NFSPROC_STATFS] +
+                              nfsstats.srvrpccnt[NQNFSPROC_READDIRLOOK] +
+ #else /* HAS_NFS_V3 */
+                              nfsstats.srvrpccnt[NFSPROC_READDIRPLUS] +
+                              nfsstats.srvrpccnt[NFSPROC_FSSTAT] +
+                              nfsstats.srvrpccnt[NFSPROC_FSINFO] +
+                              nfsstats.srvrpccnt[NFSPROC_PATHCONF] +
+                              nfsstats.srvrpccnt[NFSPROC_COMMIT] +
+ #endif /* HAS_NFS_V3 */
+                              nfsstats.srvrpccnt[NQNFSPROC_GETLEASE] +
+                              nfsstats.srvrpccnt[NQNFSPROC_VACATED] +
+                              nfsstats.srvrpccnt[NQNFSPROC_EVICTED];
+     }
+ }
+ 
+ 
+ /*
+     Reads the nlist from the kernel
+ */
+ int
+ get_namelist(kernel_name, memory_name)
+     const char *kernel_name, *memory_name;
+ {
+     time_t now;
+     time_t boottime;
+     register int i, c;
+     int nintv;
+ 
+     kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
+     if (kd == 0) {
+         (void)fprintf(stderr, "xperfmon++: kvm_openfiles: %s\n", errbuf);
+         exit(1);
+     }
+ 
+     if ((c = kvm_nlist(kd, nl)) != 0) {
+         if (c > 0) {
+             (void)fprintf(stderr,"xperfmon++: undefined symbols:");
+             for (c = 0; c < sizeof(nl)/sizeof(nl[0]); c++)
+                 if (nl[c].n_type == 0)
+                     fprintf(stderr, " %s", nl[c].n_name);
+             (void)fputc('\n', stderr);
+         } else
+             (void)fprintf(stderr, "xperfmon++: kvm_nlist: %s\n", kvm_geterr(kd));            exit(1);
+     }
+ 
+     kread(X_BOOTTIME, &boottime, sizeof(boottime));
+     kread(X_HZ, &hz, sizeof(hz));
+     for (i = 0; i < DK_NDRIVE; i++) {
+ 	strcpy(dr_name[i], "xx");
+     }
+     time(&now);
+     nintv = now - boottime;
+     if (nintv <= 0 || nintv > 60*60*24*365*10) {
+ 	fprintf(stderr,
+ 	    "Time makes no sense... namelist must be wrong.\n");
+ 	exit(1);
+     }
+     return(nintv);
+ }
+ 
+ 
+ /*
+     Kread reads something from the kernel, given its nlist index.
+ */
+ static void
+ kread(nlx, addr, size)
+         int nlx;
+         void *addr;
+         size_t size;
+ {
+         char *sym;
+         
+         if (nl[nlx].n_type == 0 || nl[nlx].n_value == 0) {
+                 sym = nl[nlx].n_name;
+                 if (*sym == '_')
+                         ++sym;
+                 (void)fprintf(stderr,
+                     "xpermon++: symbol %s not defined\n", sym);
+                 exit(1);
+         }
+         if (kvm_read(kd, nl[nlx].n_value, addr, size) != size) {
+                 sym = nl[nlx].n_name;
+                 if (*sym == '_')
+                        ++sym;
+                 (void)fprintf(stderr, "xperfmon++: %s: %s\n", sym, kvm_geterr(kd));
+                 exit(1);
+         }
+ }
+ 
+ /*
+  * get_swapspace is based on a program called swapinfo written
+  * by Kevin Lahey <kml@rokkaku.atl.ga.us>.
+  */
+ int
+ get_swapspace()
+ {
+ 	char *header;
+ 	int hlen, nswap, nswdev, dmmax;
+ 	int i, div, avail, nfree, npfree, used;
+ 	struct swdevt *sw;
+ 	long blocksize, *perdev;
+ 	struct rlist head;
+ #if __FreeBSD_version > 199511 || __FreeBSD_version == 199508
+         struct rlisthdr swaplist;
+         struct rlist *swapptr;
+ #else
+ 	struct rlist *swaplist;
+ #endif
+ 	u_long ptr;
+ 	kread(VM_NSWAP, &nswap, sizeof(nswap));
+ 	kread(VM_NSWDEV, &nswdev, sizeof(nswdev));
+ 	kread(VM_DMMAX, &dmmax, sizeof(dmmax));
+ 	kread(VM_SWAPLIST, &swaplist, sizeof(swaplist));
+ 	if ((sw = malloc(nswdev * sizeof(*sw))) == NULL ||
+ 	    (perdev = malloc(nswdev * sizeof(*perdev))) == NULL)
+ 		err(1, "xperfmon++ malloc in get_swapspace");
+ 	kread(VM_SWDEVT, &ptr, sizeof(ptr));
+ 	kvm_read(kd, ptr, sw, nswdev * sizeof(*sw));
+ 	/* Count up swap space. */
+ 	nfree = 0;
+ 	memset(perdev, 0, nswdev * sizeof(*perdev));
+ #if __FreeBSD_version > 199511 || __FreeBSD_version == 199508
+ 	swapptr = swaplist.rlh_list;
+ 	while (swapptr) {
+ #else
+ 	while (swaplist) {
+ #endif
+ 		int	top, bottom, next_block;
+ #if __FreeBSD_version > 199511 || __FreeBSD_version == 199508
+ 		kvm_read(kd, (u_long)swapptr, &head, sizeof(struct rlist));
+ #else
+ 		kvm_read(kd, (u_long)swaplist, &head, sizeof(struct rlist));
+ #endif
+ 		top = head.rl_end;
+ 		bottom = head.rl_start;
+ 
+ 		nfree += top - bottom + 1;
+ 
+ 		/*
+ 		 * Swap space is split up among the configured disks.
+ 		 *
+ 		 * For interleaved swap devices, the first dmmax blocks
+ 		 * of swap space some from the first disk, the next dmmax
+ 		 * blocks from the next, and so on up to nswap blocks.
+ 		 *
+ 		 * The list of free space joins adjacent free blocks,
+ 		 * ignoring device boundries.  If we want to keep track
+ 		 * of this information per device, we'll just have to
+ 		 * extract it ourselves.
+ 		 */
+ 		while (top / dmmax != bottom / dmmax) {
+ 			next_block = ((bottom + dmmax) / dmmax);
+ 			perdev[(bottom / dmmax) % nswdev] +=
+ 				next_block * dmmax - bottom;
+ 			bottom = next_block * dmmax;
+ 		}
+ 		perdev[(bottom / dmmax) % nswdev] +=
+ 			top - bottom + 1;
+ #if __FreeBSD_version > 199511 || __FreeBSD_version == 199508
+ 		swapptr = head.rl_next;
+ #else
+ 		swaplist = head.rl_next;
+ #endif
+         }
+ 
+ 	header = getbsize(&hlen, &blocksize);
+ 	div = blocksize / 512;
+ 	avail = npfree = 0;
+ 	for (i = 0; i < nswdev; i++) {
+ 		int xsize, xfree;
+ 
+ 		/*
+ 		 * Don't report statistics for partitions which have not
+ 		 * yet been activated via swapon(8).
+ 		 */
+ 		if (!(sw[i].sw_flags & SW_FREED))
+ 			continue;
+ 
+ 		/* The first dmmax is never allocated to avoid trashing of
+ 		 * disklabels
+ 		 */
+ 		xsize = sw[i].sw_nblks - dmmax;
+ 		xfree = perdev[i];
+ 		used = xsize - xfree;
+ 		npfree++;
+ 		avail += xsize;
+ 	}
+ 
+ 	/*
+ 	 * If only one partition has been set up via swapon(8), we don't
+ 	 * need to bother with totals.
+ 	 */
+ 	used = avail - nfree;
+ 
+ 	free(perdev);
+ 	free(sw);
+ 	return((100*nfree)/avail);   /* return free swap in percent */
+ }
diff -cd ../xperfmon++/StripCharP.h ./StripCharP.h
*** ../xperfmon++/StripCharP.h	Wed Jul 27 22:29:30 1994
--- ./StripCharP.h	Tue Dec  5 09:31:56 1995
***************
*** 62,71 ****
  #define HIGHLIGHT  1 << 1
  #define ALL_GCS (FOREGROUND | HIGHLIGHT)
  
  /* New fields for the PerfChart widget instance record */
  
  typedef struct {
!     double valuedata[2048];	/* record of data points */
      Pixel	fgpixel;	/* color index for graph */
      Pixel	hipixel;	/* color index for lines */
      Pixel       warnColor;
--- 62,73 ----
  #define HIGHLIGHT  1 << 1
  #define ALL_GCS (FOREGROUND | HIGHLIGHT)
  
+ #define NUM_VALUES 2048
+ 
  /* New fields for the PerfChart widget instance record */
  
  typedef struct {
!     double valuedata[NUM_VALUES]; /* record of data points */
      Pixel	fgpixel;	/* color index for graph */
      Pixel	hipixel;	/* color index for lines */
      Pixel       warnColor;
diff -cd ../xperfmon++/StripChart.c ./StripChart.c
*** ../xperfmon++/StripChart.c	Wed Jul 27 22:29:30 1994
--- ./StripChart.c	Mon May  6 18:26:41 1996
***************
*** 53,58 ****
--- 53,70 ----
  #include <X11/StringDefs.h>
  #include <X11/Xaw/XawInit.h>
  #include "StripCharP.h"
+ 
+ #ifdef _HAVE_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if (defined(BSD) && (BSD >= 199306))
+ # include <osreldate.h>
+ # include "system.h"
+ #else
+ # error You have to use at least a FreeBSD 2.X system
+ #endif
+ 
  #include <X11/Xfuncs.h>
  
  #define MS_PER_SEC 100
***************
*** 108,114 ****
  };
  
  #undef offset
! #define LABEL_ROOM 100
  static void Initialize(), Destroy(), Redisplay(), MoveChart(), SetPoints();
  static Boolean SetValues();
  static int repaint_window();
--- 120,130 ----
  };
  
  #undef offset
! #if (defined(BSD) && (BSD >= 199306))
! # define LABEL_ROOM 80
! #else
! # define LABEL_ROOM 100
! #endif
  static void Initialize(), Destroy(), Redisplay(), MoveChart(), SetPoints();
  static Boolean SetValues();
  static int repaint_window();
***************
*** 215,222 ****
--- 231,253 ----
  static void Initialize (greq, gnew)
      Widget greq, gnew;
  {
+     int i;
+ 
      PerfChartWidget w = (PerfChartWidget)gnew;
  
+     /*
+      * XXX The missing initializations have been made obvious by FreeBSD 2.2's
+      * new (`phk') malloc that doesn't initialize the malloc'ed areas to 0.
+      * Perhaps more bogons will lurk around, but the floating arithmetic ones
+      * have been the most annoying ones since they most likely cause a trap
+      * at startup time.
+      *
+      * Strange that people in the 90's still rely on malloc()
+      * returning an initialized region.
+      */
+     for ( i = 0; i < NUM_VALUES; i++ )
+         w->strip_chart.valuedata[i] = 0.0;
+ 
  /* if we are working with a mono screen then turn off all warnings and alarms */
  
      if ( mono_screen ) {
***************
*** 323,330 ****
  	   w->strip_chart.interval = repaint_window(w, 0, (int) w->core.width);
         }
     }
!    if (value < w->strip_chart.min_value) 
!        w->strip_chart.min_value = value;
  
     w->strip_chart.valuedata[w->strip_chart.interval] = value;
     if (XtIsRealized((Widget)w)) {
--- 354,361 ----
  	   w->strip_chart.interval = repaint_window(w, 0, (int) w->core.width);
         }
     }
!    if (value < w->strip_chart.min_value)
!      w->strip_chart.min_value = value;
  
     w->strip_chart.valuedata[w->strip_chart.interval] = value;
     if (XtIsRealized((Widget)w)) {
***************
*** 343,361 ****
  
  	   if ( checkValue >= w->strip_chart.highAlarm ) { /* check for high alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue >= w->strip_chart.highWarn ) { /* check for high warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
--- 374,392 ----
  
  	   if ( checkValue >= w->strip_chart.highAlarm ) { /* check for high alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue >= w->strip_chart.highWarn ) { /* check for high warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
***************
*** 373,391 ****
  
  	   if ( checkValue <= w->strip_chart.lowAlarm ) { /* check for low alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue <= w->strip_chart.lowWarn ) { /* check for low warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
--- 404,422 ----
  
  	   if ( checkValue <= w->strip_chart.lowAlarm ) { /* check for low alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue <= w->strip_chart.lowWarn ) { /* check for low warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
***************
*** 448,455 ****
  
      /* Compute the minimum scale required to graph the data, but don't go
         lower than min_scale. */
!     if (w->strip_chart.interval != 0 || scale <= (int)w->strip_chart.max_value)
!       scale = ((int) (w->strip_chart.max_value)) + 1;
      if (scale < w->strip_chart.min_scale)
        scale = w->strip_chart.min_scale;
  
--- 479,493 ----
  
      /* Compute the minimum scale required to graph the data, but don't go
         lower than min_scale. */
! 
!     if (w->strip_chart.interval != 0 || scale <= (int)w->strip_chart.max_value) {
! #if (defined(BSD) && (BSD >= 199306))
!       if (strcmp(w->strip_chart.botLabel, botNames[FREE_MEM]) != 0 || w->strip_chart.max_value == 100)
! 	scale = ((int) (w->strip_chart.max_value)) + 1;
! #else
!       scale = ((int) (w->strip_chart.max_value)) + 1;      
! #endif
!     }
      if (scale < w->strip_chart.min_scale)
        scale = w->strip_chart.min_scale;
  
***************
*** 479,490 ****
  /* draw titles */
  
  	if ( w->strip_chart.topLabel ) {
! 	    y = w->core.height/2;
  	    x = 4;
  	    XDS(w->strip_chart.topLabel);
  	}
  	if ( w->strip_chart.botLabel ) {
! 	    y = (w->core.height/2) + w->strip_chart.font_height;
  	    x = 4;
  	    XDS(w->strip_chart.botLabel);
  	}
--- 517,528 ----
  /* draw titles */
  
  	if ( w->strip_chart.topLabel ) {
! 	    y = w->core.height/2 - 2;
  	    x = 4;
  	    XDS(w->strip_chart.topLabel);
  	}
  	if ( w->strip_chart.botLabel ) {
! 	    y = (w->core.height/2 - 2) + w->strip_chart.font_height;
  	    x = 4;
  	    XDS(w->strip_chart.botLabel);
  	}
diff -cd ../xperfmon++/TimeChart.c ./TimeChart.c
*** ../xperfmon++/TimeChart.c	Wed Jul 27 22:29:31 1994
--- ./TimeChart.c	Mon May  6 18:31:06 1996
***************
*** 47,52 ****
--- 47,62 ----
   *                   Moffett Field, California, rsmith@proteus.arc.nasa.gov
  ******************************************************************/
  
+ #ifdef _HAVE_PARAM_H
+ #include <sys/param.h>
+ #endif
+ 
+ #if (defined(BSD) && (BSD >= 199306))
+ # include <osreldate.h>
+ #else
+ # error You have to use at least a FreeBSD 2.X system
+ #endif
+ 
  #include <stdio.h>
  #include <X11/IntrinsicP.h>
  #include <X11/StringDefs.h>
diff -cd ../xperfmon++/TimeChart.h ./TimeChart.h
*** ../xperfmon++/TimeChart.h	Wed Jul 27 22:29:31 1994
--- ./TimeChart.h	Mon Oct 30 12:53:59 1995
***************
*** 88,99 ****
  #define XtCFillRect "FillRect"
  
  #define XtNgetValue "getValue"
! #define XtNhighlight "highlight"
  #define XtNjumpScroll "jumpScroll"
  #define XtNminScale "minScale"
  #define XtNscale "scale"
  #define XtNfillRect "fillRect"
! #define XtNupdate "update"
  #define XtNvmunix "vmunix"
   
  typedef struct _TimeChartRec *TimeChartWidget;
--- 88,99 ----
  #define XtCFillRect "FillRect"
  
  #define XtNgetValue "getValue"
! /* #define XtNhighlight "highlight" */
  #define XtNjumpScroll "jumpScroll"
  #define XtNminScale "minScale"
  #define XtNscale "scale"
  #define XtNfillRect "fillRect"
! /* #define XtNupdate "update" */
  #define XtNvmunix "vmunix"
   
  typedef struct _TimeChartRec *TimeChartWidget;
diff -cd ../xperfmon++/misc.c ./misc.c
*** ../xperfmon++/misc.c	Wed Jul 27 22:29:33 1994
--- ./misc.c	Mon May  6 18:31:27 1996
***************
*** 22,27 ****
--- 22,38 ----
   * Author:           Roger Smith, Sterling Software @ NASA-Ames Research Center
   *                   Moffett Field, California, rsmith@proteus.arc.nasa.gov
   */
+ 
+ #ifdef _HAVE_PARAM_H
+ #include <sys/param.h>
+ #endif
+ 
+ #if (defined(BSD) && (BSD >= 199306))
+ # include <osreldate.h>
+ #else
+ # error You have to use at least a FreeBSD 2.X system
+ #endif
+ 
  #include <stdio.h>
  
  #include <X11/IntrinsicP.h>
***************
*** 58,64 ****
      int i, keycode, length = 0;
  /*    PerfmonWidget pw = (PerfmonWidget) w;*/
  
!     length = XLookupString(event, strbuf, STRBUFSIZE, &keycode, NULL);
      switch (keycode) {
      case 'Q':
      case 'q':
--- 69,75 ----
      int i, keycode, length = 0;
  /*    PerfmonWidget pw = (PerfmonWidget) w;*/
  
!     length = XLookupString((XKeyEvent *)event, strbuf, STRBUFSIZE, (KeySym *)&keycode, NULL);
      switch (keycode) {
      case 'Q':
      case 'q':
Only in ../xperfmon++: nfs.c.old
diff -cd ../xperfmon++/system.h ./system.h
*** ../xperfmon++/system.h	Wed Jul 27 22:29:34 1994
--- ./system.h	Mon May  6 18:28:27 1996
***************
*** 151,168 ****
--- 151,182 ----
      "Idle",
      "Free",
      "Disk",
+ #if (defined(BSD) && (BSD >= 199306))
+     "Inter-",
+ #else
      "Interrupts",
+ #endif
      "Input",
      "Output",
+ #if (defined(BSD) && (BSD >= 199306))
+     "Collis",
+     "NFS Clt",
+     "NFS Srv",
+ #else
      "Collision",
      "NFS Client",
      "NFS Server",
+ #endif
  };
  static char *widgetLabels[] = {
      "User",
      "System",
      "Idle",
+ #if (defined(BSD) && (BSD >= 199306))
+     "Swap",
+ #else
      "Free",
+ #endif
      "Disk",
      "Intrpts",
      "Input",
***************
*** 171,177 ****
--- 185,205 ----
      "NFSClient",
      "NFSServer",
  };
+ 
  static char *botNames[] = {
+ #if (defined(BSD) && (BSD >= 199306))
+     "CPU (%)",
+     "CPU (%)",
+     "CPU (%)",
+     "Swap (%)",
+     "Trsf/s",
+     "rupts/s",
+     "Pkts/s",
+     "Pkts/s",
+     "Pkts/s",
+     "Calls/s",
+     "Calls/s",
+ #else
      "CPU",
      "CPU",
      "CPU",
***************
*** 183,186 ****
--- 211,215 ----
      "Packets",
      "Calls",
      "Calls",
+ #endif
  };
diff -cd ../xperfmon++/xperfmon.c ./xperfmon.c
*** ../xperfmon++/xperfmon.c	Wed Jul 27 22:29:39 1994
--- ./xperfmon.c	Mon May  6 18:27:07 1996
***************
*** 58,63 ****
--- 58,73 ----
   *
   */
  
+ #ifdef _HAVE_PARAM_H
+ #include <sys/param.h>
+ #endif
+ 
+ #if (defined(BSD) && (BSD >= 199306))
+ # include <osreldate.h>
+ #else
+ # error You have to use at least a FreeBSD 2.X system
+ #endif
+ 
  #include <stdio.h>
  #include <X11/IntrinsicP.h>
  #include <X11/StringDefs.h>
***************
*** 94,99 ****
--- 104,114 ----
       { NULL,           NULL      },
  };
  
+ /* LK!!! */
+ int  MIN_HEIGHT=420;
+ #define MIN_WIDTH 185
+ #define GRAPH_MIN_HEIGHT 28
+ 
  #define XtNinterval "interval"
  #define XtNcount "count"
  #define XtCCount "Count"
***************
*** 101,110 ****
  #define XtCFill "Fill"
  #define XtNfast "fast"
  #define XtCFast "Fast"
- #define XtNstufAdd "stufAdd"
- #define XtCStufAdd "StufAdd"
- #define XtNstufSub "stufSub"
- #define XtCStufSub "StufSub"
  #define XtNdebug "debug"
  #define XtCDebug "Debug"
  #define XtNusercpuAdd "usercpuAdd"
--- 116,121 ----
***************
*** 171,181 ****
  static XrmOptionDescRec optionDescList[] = {
      { "-interval",  ".interval",    XrmoptionSepArg,    (caddr_t) NULL},
      { "-immediate", "*PerfChart.immediate", XrmoptionNoArg, "True" },
! 
      { "-lowmemAlarm", "*perfChartFree.lowAlarm", XrmoptionSepArg, NULL },
      { "-lowmemWarn", "*perfChartFree.lowWarn", XrmoptionSepArg, NULL },
      { "-highmemAlarm", "*perfChartFree.highAlarm", XrmoptionSepArg, NULL },
      { "-highmemWarn", "*perfChartFree.highWarn", XrmoptionSepArg, NULL },
  
      { "-lowuserAlarm", "*perfChartUser.lowAlarm", XrmoptionSepArg, NULL },
      { "-lowuserWarn", "*perfChartUser.lowWarn", XrmoptionSepArg, NULL },
--- 182,198 ----
  static XrmOptionDescRec optionDescList[] = {
      { "-interval",  ".interval",    XrmoptionSepArg,    (caddr_t) NULL},
      { "-immediate", "*PerfChart.immediate", XrmoptionNoArg, "True" },
! #if (defined(BSD) && (BSD >= 199306))
!     { "-lowswapAlarm", "*perfChartFree.lowAlarm", XrmoptionSepArg, NULL },
!     { "-lowswapWarn", "*perfChartFree.lowWarn", XrmoptionSepArg, NULL },
!     { "-highswapAlarm", "*perfChartFree.highAlarm", XrmoptionSepArg, NULL },
!     { "-highswapWarn", "*perfChartFree.highWarn", XrmoptionSepArg, NULL },
! #else
      { "-lowmemAlarm", "*perfChartFree.lowAlarm", XrmoptionSepArg, NULL },
      { "-lowmemWarn", "*perfChartFree.lowWarn", XrmoptionSepArg, NULL },
      { "-highmemAlarm", "*perfChartFree.highAlarm", XrmoptionSepArg, NULL },
      { "-highmemWarn", "*perfChartFree.highWarn", XrmoptionSepArg, NULL },
+ #endif
  
      { "-lowuserAlarm", "*perfChartUser.lowAlarm", XrmoptionSepArg, NULL },
      { "-lowuserWarn", "*perfChartUser.lowWarn", XrmoptionSepArg, NULL },
***************
*** 237,244 ****
--- 254,266 ----
      { "+systemcpu", XtNsystemcpuAdd,     XrmoptionNoArg,     "TRUE" },
      { "-idlecpu",   XtNidlecpuSub,     XrmoptionNoArg,     "True" },
      { "+idlecpu",   XtNidlecpuAdd,     XrmoptionNoArg,     "TRUE" },
+ #if __FreeBSD_version >= 199504
+     { "-freeswap",  XtNfreememSub,     XrmoptionNoArg,     "True" },
+     { "+freeswap",  XtNfreememAdd,     XrmoptionNoArg,     "TRUE" },
+ #else
      { "-freemem",   XtNfreememSub,     XrmoptionNoArg,     "True" },
      { "+freemem",   XtNfreememAdd,     XrmoptionNoArg,     "TRUE" },
+ #endif
      { "-diskxfr",   XtNdiskxfrSub,     XrmoptionNoArg,     "True" },
      { "+diskxfr",   XtNdiskxfrAdd,     XrmoptionNoArg,     "TRUE" },
      { "-interrupts",  XtNinterruptsSub ,     XrmoptionNoArg,     "True" },
***************
*** 253,269 ****
      { "+nfsclient",   XtNnfsclientAdd,     XrmoptionNoArg,     "TRUE" },
      { "-nfsserver",   XtNnfsserverSub,     XrmoptionNoArg,     "True" },
      { "+nfsserver",   XtNnfsserverAdd,     XrmoptionNoArg,     "TRUE" },
-     { "-stuf",      XtNstufAdd,        XrmoptionNoArg,     (XtPointer)"True" },
-     { "+stuf",      XtNstufSub,        XrmoptionNoArg,     (XtPointer)"True" },
  };
  
  /* Application Resource List - no particular widget */
  
  static XtResource resources[] = {
-     { XtNstufAdd, XtCStufAdd, XtRBool, sizeof(Bool),
- 	  XtOffsetOf(AppData, addG[1]), XtRImmediate, (XtPointer) NULL },
-     { XtNstufSub, XtCStufSub, XtRBool, sizeof(Bool),
- 	  XtOffsetOf(AppData, subG[0]), XtRImmediate, (XtPointer) NULL },
      { XtNinterval, XtCInterval, XtRInt, sizeof(int),
  	  XtOffsetOf(AppData, interval), XtRImmediate, (caddr_t) DEF_INTERVAL },
      { XtNcount, XtCCount, XtRInt, sizeof(int),
--- 275,285 ----
***************
*** 324,329 ****
--- 340,348 ----
  void
  usage()
  {
+ #if (defined(BSD) && (BSD >= 199306))
+     fprintf(stderr, "\nxperfmon++ V1.33 for FreeBSD-2.X\n");
+ #endif
      fprintf(stderr, "\nusage: xperfmon++ option option option .....\n");
      fprintf(stderr, "options:\n");
      fprintf(stderr, "    [-display [{host}]:[{vs}]]\n");
***************
*** 344,350 ****
--- 363,373 ----
      fprintf(stderr, "    [{-+}usercpu]          ({remove|add} usercpu to list of graphs\n");
      fprintf(stderr, "    [{-+}systemcpu]        ({remove|add} systemcpu to list of graphs\n");
      fprintf(stderr, "    [{-+}idlecpu]          ({remove|add} idlecpu to list of graphs\n");
+ #if (defined(BSD) && (BSD >= 199306))
+     fprintf(stderr, "    [{-+}freeswap]         ({remove|add} freeswap to list of graphs\n");
+ #else
      fprintf(stderr, "    [{-+}freemem]          ({remove|add} freemem to list of graphs\n");
+ #endif
      fprintf(stderr, "    [{-+}diskxfr]          ({remove|add} disk transfers to list of graphs\n");
      fprintf(stderr, "    [{-+}interrupts]       ({remove|add} interrupts to list of graphs\n");
      fprintf(stderr, "    [{-+}inputpkts]        ({remove|add} input packets to list of graphs\n");
***************
*** 361,370 ****
--- 384,401 ----
      fprintf(stderr, "    [-high*Alarm {value}]     ( Set High Alarm value for *)\n");
      fprintf(stderr, "    [-high*Warn {value}]      ( Set High Warning value for *)\n");
      fprintf(stderr, "  Where \"*\" is one of the following:\n");
+ #if (defined(BSD) && (BSD >= 199306))
+     fprintf(stderr, "    [swap | user | sys | idle | disk | intrpts |\n");
+ #else
      fprintf(stderr, "    [mem | user | sys | idle | disk | intrpts |\n");
+ #endif
      fprintf(stderr, "     input | output | collision | nfsclient | nfsserver]\n");
      fprintf(stderr, "  For Example:\n");
+ #if (defined(BSD) && (BSD >= 199306))
+     fprintf(stderr, "    [-lowswapAlarm {value}]   ( Set low Free Swap Alarm Value)\n");
+ #else
      fprintf(stderr, "    [-lowmemAlarm {value}]    ( Set low Free Memory Alarm Value)\n");
+ #endif
      fprintf(stderr, "WARNING: It is an error condition to set both a high, and a low, limit warning or alarm.\n");
      exit(1);
  }
***************
*** 386,391 ****
--- 417,423 ----
      time(&timeStamp);
      return;
  }
+ 
  /*ARGSUSED*/
  void handleResize( w, unused, event, contin2disp )
  Widget w;
***************
*** 394,400 ****
  Boolean *contin2disp;
  {
      Dimension neww, newh;
!     int i;
      char eventString[60];
      switch (event->type) {
      case Expose:
--- 426,433 ----
  Boolean *contin2disp;
  {
      Dimension neww, newh;
!     Dimension hOverHead, boxH, timeH, newWidgetH;
!     int i, window_size_changed;
      char eventString[60];
      switch (event->type) {
      case Expose:
***************
*** 403,415 ****
  	strcpy(eventString,"expose");
  	break;
      case MapNotify:
! 	neww=0;
! 	newh=0;
  	strcpy(eventString,"map notify");
  	break;
      case ReparentNotify:
! 	neww=0;
! 	newh=0;
  	strcpy(eventString,"reparent");
  	break;
      case ConfigureNotify:
--- 436,453 ----
  	strcpy(eventString,"expose");
  	break;
      case MapNotify:
! 	neww=w->core.width;
! 	newh=oldHeight;
  	strcpy(eventString,"map notify");
  	break;
+     case UnmapNotify:
+ 	neww=w->core.width;
+ 	newh=oldHeight;
+ 	strcpy(eventString,"unmap notify");
+ 	break;
      case ReparentNotify:
! 	neww=w->core.width;
! 	newh=oldHeight;
  	strcpy(eventString,"reparent");
  	break;
      case ConfigureNotify:
***************
*** 417,429 ****
  	newh=event->xconfigure.height;
  	strcpy(eventString,"configure");
  	break;
  
      }
!     if ( neww < 250 + 10 ) {
! 	neww = 250 + 10;
! 	w->core.width = 250 + 10;
! 	XtResizeWindow(w);
      }
      if ( appData.debug )
  	printf("Resize Request: type=%d %s, oldw=%hu, oldh=%hu, neww=%hu, newh=%hu\n",
  	       (int)event->type, eventString,
--- 455,489 ----
  	newh=event->xconfigure.height;
  	strcpy(eventString,"configure");
  	break;
+     }
  
+     if ( neww < MIN_WIDTH ) {
+ 	neww = MIN_WIDTH;
+ 	w->core.width = MIN_WIDTH;
+ 	window_size_changed = TRUE;
+     } else {
+         w->core.width = neww;
      }
! 
!     if ( newh < MIN_HEIGHT ) {
! 	newh = MIN_HEIGHT;
! 	w->core.height = MIN_HEIGHT;
! 	window_size_changed = TRUE;
      }
+ 
+     /* Now the graphs fit perfect into the window! */
+     hOverHead = (5.6 * appData.numGraphsOn) - (6 / appData.numGraphsOn);
+     boxH = labelBox->core.height;
+     timeH = timechart->core.height;
+     newWidgetH = (newh - (boxH+7) - (timeH+10) - hOverHead) / appData.numGraphsOn;
+     w->core.height = newWidgetH * appData.numGraphsOn + hOverHead + (boxH+7) + (timeH+10);
+     if(w->core.height != newh) {
+       newh = w->core.height;
+     }
+ 
+     if( neww != oldWidth || newh != oldHeight || window_size_changed == TRUE )
+       XtResizeWindow(w);
+ 
      if ( appData.debug )
  	printf("Resize Request: type=%d %s, oldw=%hu, oldh=%hu, neww=%hu, newh=%hu\n",
  	       (int)event->type, eventString,
***************
*** 431,448 ****
  	       neww, newh);
  
      if ( event->type == ConfigureNotify ) {
! /*	Dimension h = perfmon[0]->core.height;*/
! 	Dimension hOverHead = 5 * appData.numGraphsOn;
! 	Dimension boxH = labelBox->core.height;
! 	Dimension timeH = timechart->core.height;
! 	Dimension newWidgetH = (newh - (boxH+8) - (timeH+10) - hOverHead) / appData.numGraphsOn;
  	if ( oldWidth == neww && oldHeight == newh ) return;
  
  	if ( appData.debug )
  	    printf("BoxH=%hu, timeH=%hu, numGraphOn=%hu, newWidgetH=%hu\n",
  		   boxH, timeH, appData.numGraphsOn, newWidgetH);
  
! 	neww -= 10;			/* allow for spacing and borders */
  
  	for ( i=0; i<NUM_GRAPHS; i++ ) {
  	    if ( appData.graphOn[i] ) {
--- 491,504 ----
  	       neww, newh);
  
      if ( event->type == ConfigureNotify ) {
! 
  	if ( oldWidth == neww && oldHeight == newh ) return;
  
  	if ( appData.debug )
  	    printf("BoxH=%hu, timeH=%hu, numGraphOn=%hu, newWidgetH=%hu\n",
  		   boxH, timeH, appData.numGraphsOn, newWidgetH);
  
! 	neww -= 10;			/* allow for spacing and borders */ 
  
  	for ( i=0; i<NUM_GRAPHS; i++ ) {
  	    if ( appData.graphOn[i] ) {
***************
*** 455,460 ****
--- 511,517 ----
  	XFlush(XtDisplay(w));
  
      }
+ 
      oldWidth = neww+=10, oldHeight = newh;
      return;
  }
***************
*** 464,472 ****
      int argc;
      char **argv;
  {
      Arg arg;
      Pixmap icon_pixmap = None;
!     Widget  loadParent, pappaBox;
  
      char *progname = argv[0];
      Bool foundAnAdd = FALSE;
--- 521,533 ----
      int argc;
      char **argv;
  {
+     /* LK!!! */
+     Dimension timeH, newWidgetW, newWidgetH, hOverHead, boxH;
+     unsigned int w, h;
+ 
      Arg arg;
      Pixmap icon_pixmap = None;
!     Widget pappaBox;
  
      char *progname = argv[0];
      Bool foundAnAdd = FALSE;
***************
*** 540,561 ****
  		xperfmon_width, xperfmon_height));
  	XtSetValues(appData.toplevel, &arg, 1);
      }
- 
  /* create windows */
  
      pappaBox = XtVaCreateManagedWidget("PappaBox", boxWidgetClass, appData.toplevel, 
  				       XtNborderWidth, 0,
  				       NULL);
- 
      XtOverrideTranslations(pappaBox, XtParseTranslationTable(defaultTranslations));
  
      (void)gethostname(hostname, sizeof(hostname));
      c = (char *) ((long) &hostname[0] + (int) strlen(hostname));
      sprintf(c, "\nUpdate Interval = %5.1f secs", (float)(appData.interval*appData.ms_per_sec)/1000.0);
  
      labelBox = XtVaCreateManagedWidget("LabelBox", labelWidgetClass, pappaBox,
! 					 XtNwidth, 250,
! /*					 XtNheight, 16,*/
  				         XtNjustify, XtJustifyLeft,
  				         XtNinternalHeight, 0,
  					 XtNtop, XtChainTop,
--- 601,652 ----
  		xperfmon_width, xperfmon_height));
  	XtSetValues(appData.toplevel, &arg, 1);
      }
  /* create windows */
  
      pappaBox = XtVaCreateManagedWidget("PappaBox", boxWidgetClass, appData.toplevel, 
  				       XtNborderWidth, 0,
  				       NULL);
      XtOverrideTranslations(pappaBox, XtParseTranslationTable(defaultTranslations));
  
      (void)gethostname(hostname, sizeof(hostname));
      c = (char *) ((long) &hostname[0] + (int) strlen(hostname));
      sprintf(c, "\nUpdate Interval = %5.1f secs", (float)(appData.interval*appData.ms_per_sec)/1000.0);
  
+     { /* LK!!! handle -geometry option correct, also small changes in handleResize */
+       Window rwin;
+       int x,y,px,py;
+       unsigned int pw,ph,bw,d;
+ 
+       XtRealizeWidget(appData.toplevel);
+ 
+       XGetGeometry(XtDisplay(appData.toplevel),XtWindow(appData.toplevel),
+ 		   &rwin,&x,&y,&w,&h,&bw,&d);
+ 
+       if ( w > MIN_WIDTH) {
+ 	newWidgetW = w - 10;
+ 	appData.toplevel->core.width = w;
+       } else {
+ 	appData.toplevel->core.width = MIN_WIDTH;
+ 	newWidgetW = MIN_WIDTH - 10;
+       }
+ 
+       hOverHead = (5.6 * appData.numGraphsOn) - (6 / appData.numGraphsOn);
+       boxH = 22;
+       timeH = 12;
+       if (h > GRAPH_MIN_HEIGHT * appData.numGraphsOn + hOverHead + (boxH+7) + (timeH+10))
+ 	newWidgetH = (h - hOverHead - (boxH+7) - (timeH+10)) / appData.numGraphsOn;
+       else
+ 	newWidgetH = GRAPH_MIN_HEIGHT;
+ 
+       MIN_HEIGHT = newWidgetH * appData.numGraphsOn + hOverHead + (boxH+7) + (timeH+10);
+       appData.toplevel->core.height = MIN_HEIGHT;
+ 
+       XtResizeWindow(appData.toplevel);
+     }
+ 
      labelBox = XtVaCreateManagedWidget("LabelBox", labelWidgetClass, pappaBox,
! 					 XtNwidth, newWidgetW,
! 					 XtNheight, boxH,
  				         XtNjustify, XtJustifyLeft,
  				         XtNinternalHeight, 0,
  					 XtNtop, XtChainTop,
***************
*** 570,577 ****
  	    perfmon[i] = XtVaCreateManagedWidget(hostname, perfChartWidgetClass, pappaBox, 
  						 XtNtopLabel, topNames[i],
  						 XtNbotLabel, botNames[i],
! 						 XtNwidth, 250,
! 						 XtNheight, 36,
  						 XtNupdate, appData.interval*appData.ms_per_sec,
  						 XtNfillRect, (int)appData.fill,
  						 XtNjumpScroll, 1,
--- 661,668 ----
  	    perfmon[i] = XtVaCreateManagedWidget(hostname, perfChartWidgetClass, pappaBox, 
  						 XtNtopLabel, topNames[i],
  						 XtNbotLabel, botNames[i],
! 						 XtNwidth, newWidgetW,
! 						 XtNheight, newWidgetH,
  						 XtNupdate, appData.interval*appData.ms_per_sec,
  						 XtNfillRect, (int)appData.fill,
  						 XtNjumpScroll, 1,
***************
*** 580,600 ****
      }
      timechart = XtVaCreateManagedWidget("timeChart", timeChartWidgetClass, pappaBox, 
  					 XtNfromVert, perfmon[1], 
! 					 XtNwidth, 250,
! 					 XtNheight, 18,
  					 XtNupdate, appData.interval*appData.ms_per_sec,
  					 XtNjumpScroll, 1,
  					 NULL);
      sys_setup();
      XtAddCallback(timechart, XtNgetValue, update_time_stat, NULL);
  
      for ( i=0; i<NUM_GRAPHS; i++ ) 
  	if ( appData.graphOn[i] ) 
! 	    XtAddCallback(perfmon[i], XtNgetValue, update_stat, i);
  
      appData.interval_id = XtAppAddTimeOut(appData.app_context,
  		    appData.interval*appData.ms_per_sec, start_graphs, (caddr_t) appData.toplevel);
  
-     XtRealizeWidget(appData.toplevel);
      XtAppMainLoop(appData.app_context);
  }
--- 671,692 ----
      }
      timechart = XtVaCreateManagedWidget("timeChart", timeChartWidgetClass, pappaBox, 
  					 XtNfromVert, perfmon[1], 
! 					 XtNwidth, newWidgetW,
! 					 XtNheight, timeH,
  					 XtNupdate, appData.interval*appData.ms_per_sec,
  					 XtNjumpScroll, 1,
  					 NULL);
+ 
      sys_setup();
      XtAddCallback(timechart, XtNgetValue, update_time_stat, NULL);
  
      for ( i=0; i<NUM_GRAPHS; i++ ) 
  	if ( appData.graphOn[i] ) 
! 	    XtAddCallback(perfmon[i], XtNgetValue, update_stat, (XtPointer)i);
  
      appData.interval_id = XtAppAddTimeOut(appData.app_context,
  		    appData.interval*appData.ms_per_sec, start_graphs, (caddr_t) appData.toplevel);
  
      XtAppMainLoop(appData.app_context);
  }
+ 
