#!/bin/sh

# Local version: 1.77
# $FreeBSD$

# Copyright (c) 2005-2006 Douglas Barton, All rights reserved
# Please see detailed copyright below

# %%LOCALBASE%% and %%X11BASE%% are needed in path for make
PATH=/bin:/usr/bin:/sbin:/usr/sbin:%%LOCALBASE%%/bin:%%X11BASE%%/bin
if [ -n "$CCACHE_PATH" ]; then
	if [ -z "$NOCCACHE" ]; then
		PATH="%%LOCALBASE%%/libexec/ccache:$PATH"
	fi
fi
export PATH

umask 022

usage () {
	VERSION_NUMBER=`grep "[$]FreeBSD:" $0 | cut -d ' ' -f 4`
	echo "portmaster version $VERSION_NUMBER"
	echo ''
	echo 'Usage:'
	echo "Common flags: [-CGbgnv uf|i D|d] [-m <arguments for make>]"
	echo "${0##*/} [Common flags] <full name of port directory in $pdb>"
	echo "${0##*/} [Common flags] <glob pattern of directory in $pdb>"
	echo "${0##*/} [Common flags] -p <port directory in $pd>"
	echo "${0##*/} [Common flags] <full path to $pd/foo/bar>"
	echo "${0##*/} [Common flags] -o <new port dir in $pd> <installed port>"
	echo "${0##*/} [Common flags] -r <name/glob of port directory in $pdb>"
	echo "${0##*/} -a [Common flags]"
	echo "${0##*/} -l"
	echo "${0##*/} -s"
	echo "${0##*/} -h"
	echo ''
	echo "-C prevents 'make clean' being run in port directory"
	echo "-G prevents recursive 'make config'"
	echo '-b create a backup package of the installed port (if any)'
	echo '-g create a package of the new port'
	echo '-n do not actually make or install any ports'
	echo '-v verbose output'
	echo "-u unattended mode -- accept defaults for all but 'make config'"
	echo '-f always rebuild ports (overrides -i)'
	echo '-i interactive update mode'
	echo '-D prevents cleaning of distfiles'
	echo '-d always clean distfiles'
	echo "-m <arguments for the 'make' command line>"
	echo ''
	echo '-o Replace the installed port with a port from a different origin'
	echo '-r rebuild port, and all ports that depend on it'
	echo '-a check all ports, update as necessary'
	echo ''
	echo '-l list installed ports by category'
	echo '-s clean out stale ports that used to be depended on'
	echo ''
	echo '-h display this help file'
	echo ''
	exit 1
}

fail () {
	echo ''
	echo "===>>> $1"
	echo "===>>> Aborting update"
	exit 1
}

safe_exit () {
	echo ''
	rm -f $grep_deps $req_deps
	test -n "$FORCE_PARENT" && rm -f $UPDATES_DONE_LIST
	test -n "$CONFIG_PARENT" && rm -f $CONFIG_SEEN_LIST
	exit 0
}

update_contents () {
	local tempfile

	tempfile=`mktemp -t tempfile-${new_port}`

	sed "s/@pkgdep $1/@pkgdep $2/" $dep_port_contents > $tempfile &&
	    mv $tempfile $pdb/$dep_port/+CONTENTS
	    chmod 644 $pdb/$dep_port/+CONTENTS

	if [ -n "$oldportdir" ]; then
		sed "s%N:${oldportdir}\$%N:${newportdir}%" $dep_port_contents > $tempfile &&
		    mv $tempfile $pdb/$dep_port/+CONTENTS
		    chmod 644 $pdb/$dep_port/+CONTENTS
		
	fi
}

dep_warn () {
	local num_ports1

	echo ''
	echo "===>>> Warning! Potential unrecorded dependencies on $new_port"
	echo "===>>> From existing +CONTENTS files:"
	grep -B1 DEPORIGIN:$upg_origin$ $pdb/*/+CONTENTS |
	    sort -u | sed -e "s#$pdb/##" -e 1d
	num_ports1=`grep DEPORIGIN:$upg_origin$ $pdb/*/+CONTENTS |
	    sort -u | wc -l | awk '{print $1}'`
	echo "===>>> $num_ports1 ports"
	echo ''
}

update_reqfile () {
	local num_ports2 sdiff_deps

	dep_warn
	num_ports2=`wc -l $req_deps | awk '{print $1}'`
	echo "===>>> From $pdb/$upg_port/+REQUIRED_BY:"
	cat $req_deps
	echo "===>>> $num_ports2 ports"
	echo ''
	echo "===>>> Use dependencies from existing +CONTENTS files	[c]"
	echo "===>>> Use dependencies from existing +REQUIRED_BY file	[r]"
	echo "===>>> Use sdiff to edit both files into a new file	[s]"
	echo ''
	if [ -z "$UNATTENDED" ]; then
		echo -n "===>>> Update dependency list? [r] "
		read DEPUPDATE

		case "$DEPUPDATE" in
		[cC])	mv $grep_deps $req_deps ;;
		[sS])	sdiff_deps=`mktemp -t sdiff-deps-${short_port}`
			sdiff -o $sdiff_deps --text --suppress-common-lines \
			    --width=`tput columns` $req_deps $grep_deps
			mv $sdiff_deps $req_deps
			;;
		esac
	else
		echo "===>>> Default (use +REQUIRED_BY file) in unattended mode"
	fi
}

update_port () {
	local upd

	case "$1" in
	-p)	upd=$2 ;;
	*)	upd=$1 ;;
	esac

	echo "===>>> Launching child to update $upd"
	echo ''
	if [ -z "$NO_ACTION" ]; then
		($0 $ARGS $@) || fail "Update for $upd failed"
	else
		test -n "$VERBOSE" &&
		    echo "===>>> Build canceled due to -n flag"
	fi

	if [ -n "$UPDATE_ALL" ]; then
		echo "===>>> Returning to update check of installed ports"
	elif [ -n "$UPDATE_REQ_BYS" ]; then
		return 0
	elif [ -n "$CONFIG_ONLY" ]; then
		echo "===>>> Continuing 'make config' dependency check for $portdir"
	else
		echo "===>>> Returning to dependency check for $portdir"
	fi

	return 0
}

check_interactive () {
	local UPD_OR_NOT

	if [ -n "$INTERACTIVE_UPDATE" ]; then
		echo -n "===>>> Update ${1}? [y] "
		read UPD_OR_NOT
		case "$UPD_OR_NOT" in
		[nN]*)	return 1 ;;
		esac
	fi
	return 0
}

iport_from_origin () {
	local dir

	dir=`grep -l "@comment ORIGIN:${1}$" $pdb/*/+CONTENTS`
	dir="${dir%/+CONTENTS}"
	dir="${dir#$pdb/}"

	echo $dir
}

origin_from_pdb () {
	grep '@comment ORIGIN' ${1}/+CONTENTS | cut -f2 -d':'
}

check_for_updates () {
	local upd_port port_ver do_update

	upd_port=`origin_from_pdb $pdb/$1`
	if [ -z "$upd_port" ]; then
		if [ -n "$VERBOSE" ]; then
			echo "===>>> No ORIGIN in $pdb/$1/+CONTENTS"
			echo ''
		fi
		return 0
	fi

	if [ -d "$pd/$upd_port" ]; then
		cd $pd/$upd_port ||
		    fail "Cannot cd to port directory: $pd/$upd_port"
		port_ver=`make $MAKE_ARGS -V PKGNAME`

		test "$1" = "$port_ver" && return 0

		case `pkg_version -t $1 $port_ver` in
		\<)	do_update=yes ;;
		*)	if [ -n "$VERBOSE" ]; then
				echo ''
				echo "===>>> Port version $port_ver does not"
				echo "===>>> seem newer than installed $1"
				echo ''
			fi
			;;
		esac
	else
		# This will fail if it doesn't exist anymore
		# It will return 1 if we know nothing about the port
		find_moved_port $upd_port || return 0

		# If the port has moved, we have to update it
		do_update=yes
	fi

	if [ -n "$do_update" ]; then
		if ! check_interactive $1 ; then
			return 0
		fi

		update_port $1 || return 1
	fi

	return 0
}

find_moved_port () {
	# newportdir and oldportdir are used globally
	local m

	newportdir=`sed -ne "s#^${1}|\([^|]*\)|.*#\1#p" $pd/MOVED`
	if [ ! -n "$newportdir" ]; then
		m=`sed -ne "s#^${1}||.*|\(.*\)#\1#p" $pd/MOVED`
		if [ -n "$m" ]; then
			fail "The $1 port has been deleted: $m"
		else
			echo ''
			echo "===>>> No $pd/$1 exists, and no information"
			echo "===>>> about $1 can be found in $pd/MOVED"
			echo ''
			return 1
		fi
	fi

	m=`sed -ne "s#^${1}|.*|.*|\(.*\)#\1#p" $pd/MOVED`
	oldportdir=$1
	# Just in case there was more than one match, use the last one
	newportdir=`echo $newportdir | sed 's/.* //'`
	echo ''
	echo "===>>> The $1 port has moved to $newportdir"
	echo "===>>> Reason: $m"
	echo ''

	return 0
}

ports_by_category () {
	local pkg

	for pkg in $pdb/*; do
		# Handle regular files, such as portupgrade's pkgdb.db
		test -d "$pkg" || continue

		if [ -s "$pkg/+REQUIRED_BY" ]; then
			if grep '^@pkgdep ' $pkg/+CONTENTS >/dev/null; then
				branches="$branches $pkg"
			else
				trunks="$trunks $pkg"
			fi
		else
			if grep '^@pkgdep ' $pkg/+CONTENTS >/dev/null; then
				leaves="$leaves $pkg"
			else
				roots="$roots $pkg"
			fi
		fi
	done
}

dependency_check () {
	local dep_port_list dep_port cur_p upd_args p op old_p

	# Print a message here because sometimes all-depends-list takes
	# a long time to return.
	if [ -n "$CONFIG_ONLY" ]; then
		echo "===>>> Checking $portdir dependencies for recursive 'make config'"
	else
		echo "===>>> Checking if dependencies of $portdir are up to date"
	fi

	dep_port_list=`make $MAKE_ARGS all-depends-list`
	if [ -z "$dep_port_list" ]; then
		echo "===>>> No dependencies for $portdir"
		return 0
	fi

	for dep_port in $dep_port_list; do
		test -n "$VERBOSE" &&
		    echo "===>>> Checking dependency: $dep_port"

		if [ -n "$CONFIG_SEEN_LIST" ]; then
			if [ `grep "${dep_port}$" $CONFIG_SEEN_LIST` ]; then
				continue
			else
				echo "$dep_port" >> $CONFIG_SEEN_LIST
			fi
		fi

		if [ -n "$UPDATES_DONE_LIST" ]; then
			if [ `grep "${dep_port}$" $UPDATES_DONE_LIST` ]; then
				continue
			fi
		fi

		cur_p=`iport_from_origin ${dep_port#$pd/}`
		if [ -n "$cur_p" ]; then
			upd_args=$cur_p
		else
			upd_args="-p $dep_port"		# Sensible default
			# Check to see if the dependency has moved because
			# if so, we need to update the old port to fix it
			p=${dep_port#$pd/}
			op=`sed -ne "s#\([^|]*\)|$p|.*#\1#p" $pd/MOVED`
			# In case there is more than one match, use the latest
			op=`echo $op | sed 's/.* //'`

			if [ -n "$op" ]; then
				old_p=`iport_from_origin ${op}`
				if [ -n "$old_p" ]; then
					upd_args=$old_p
				fi
			fi
		fi

		if [ -n "$FORCE" ]; then
			echo "===>>> Forcing update for $dep_port"
			update_port $upd_args
			continue
		fi

		# If not forcing the update
		if [ -n "$cur_p" ]; then
			check_for_updates $cur_p
		elif [ -n "$old_p" ]; then
			check_for_updates $old_p
		else
			if ! check_interactive $dep_port ; then
				continue
			fi

			update_port -p $dep_port
		fi
	done
	if [ -n "$CONFIG_ONLY" ]; then
		echo "===>>> Recursive 'make config' check complete for $portdir"
	else
		echo "===>>> Dependency check complete for $portdir"
	fi
}

unset_recursive_config () {
	rm -f $CONFIG_SEEN_LIST
	unset CONFIG_ONLY CONFIG_SEEN_LIST

	# Overload this variable to simplify the code
	NO_RECURSIVE_CONFIG=yes
	export NO_RECURSIVE_CONFIG
}

req_by_error () {
	local DISCARD

	echo "===>>> WARNING! $pdb/$1/+REQUIRED_BY "
	echo "===>>> shows that $2 requires $1, but "
	echo "===>>> $2 does not seem to be installed"
	echo -n "===>>> Press Enter to proceed "
	read DISCARD
}

pd=`make $MAKE_ARGS -f/dev/null -V PORTSDIR 2>/dev/null`
pdb=`make $MAKE_ARGS -f/dev/null -V PKG_DBDIR 2>/dev/null`

# Read a global rc file first
if [ -r /etc/portmaster.rc ]; then
	. /etc/portmaster.rc
fi

# Read a local one next, and allow the command line to override
if [ -r "$HOME/.portmasterrc" ]; then
	. $HOME/.portmasterrc
fi

# Set default values here so that they can be overriden above
: ${pd:=/usr/ports}
: ${pdb:=/var/db/pkg}

# Save switches for potential child processes
while getopts 'CDGabdfghilm:nop:r:suv' COMMAND_LINE_ARGUMENT ; do
	case "${COMMAND_LINE_ARGUMENT}" in
	C)	DONT_PRE_CLEAN=yes; ARGS="-C $ARGS" ;;
	D)	DONT_SCRUB_DISTFILES=yes; ARGS="-D $ARGS" ;;
	G)	NO_RECURSIVE_CONFIG=yes; ARGS="-G $ARGS" ;;
	a)	UPDATE_ALL=yes ;;
	b)	BACKUP=yes; ARGS="-b $ARGS" ;;
	d)	ALWAYS_SCRUB_DISTFILES=yes; ARGS="-d $ARGS" ;;
	f)	FORCE_PARENT=yes
		FORCE=yes
		UPDATES_DONE_LIST=`mktemp -t updates_done_list`
		export FORCE UPDATES_DONE_LIST
		;;
	g)	MAKE_PACKAGE=yes; ARGS="-g $ARGS" ;;
	h)	usage ; exit 0 ;;
	i)	INTERACTIVE_UPDATE=yes; ARGS="-i $ARGS" ;;
	l)	LIST=yes ;;
	m)	MAKE_ARGS=$OPTARG; ARGS="-m $MAKE_ARGS $ARGS" ;;
	n)	NO_ACTION=yes ;;
	o)	REPLACE_ORIGIN=yes ;;
	p)	portdir="${OPTARG#$pd/}" ;;
	r)	UPDATE_REQ_BYS=yes; upg_port=$OPTARG ;;
	s)	CLEAN_STALE=yes ;;
	u)	UNATTENDED=yes; ARGS="-u $ARGS" ;;
	v)	VERBOSE=yes; ARGS="-v $ARGS" ;;
	esac
done
shift $(( $OPTIND - 1 ))

if [ -n "$LIST" ]; then
	ports_by_category

	num_roots=0
	num_trunks=0
	num_branches=0
	num_leaves=0

	echo "===>>> Root ports (No dependencies, not depended on)"
	for port in $roots; do
		echo "===>>> ${port##*/}"
		num_roots=$(( $num_roots + 1 ))
	done
	echo "===>>> $num_roots root ports"
	echo ''
	echo "===>>> Trunk ports (No dependencies, are depended on)"
	for port in $trunks; do
		echo "===>>> ${port##*/}"
		num_trunks=$(( $num_trunks + 1 ))
	done
	echo "===>>> $num_trunks trunk ports"
	echo ''
	echo "===>>> Branch ports (Have dependencies, are depended on)"
	for port in $branches; do
		echo "===>>> ${port##*/}"
		num_branches=$(( $num_branches + 1 ))
	done
	echo "===>>> $num_branches branch ports"
	echo ''
	echo "===>>> Leaf ports (Have dependencies, not depended on)"
	for port in $leaves; do
		echo "===>>> ${port##*/}"
		num_leaves=$(( $num_leaves + 1 ))
	done
	echo "===>>> $num_leaves leaf ports"
	echo ''
	num_ports=$(( $num_roots + $num_trunks + $num_branches + $num_leaves ))
	echo "===>>> $num_ports total installed ports"
	exit 0
fi

if [ -n "$CLEAN_STALE" ]; then
	for file in `find $pdb/ -name \+REQUIRED_BY -empty` ; do
		dir="${file%/+REQUIRED_BY}"
		origin=`origin_from_pdb $dir`

		deplist=`grep DEPORIGIN:$origin$ $pdb/*/+CONTENTS`
		if [ -z "$deplist" ]; then
			echo -n "===>>> ${dir#$pdb/} is no longer depended on, delete? [n] "
			read YESNO

			case "$YESNO" in
			[yY])	pkg_delete ${dir#$pdb/} ;;
			esac
		else
			echo "===>>> Warning: unrecorded dependencies on ${dir#$pdb/}:"
			echo $deplist
		fi
	done

	exit 0
fi

test -n "$FORCE" && unset INTERACTIVE_UPDATE
if [ -n "$UNATTENDED" ]; then
	unset INTERACTIVE_UPDATE

	if [ -z "$DONT_SCRUB_DISTFILES" -a -z "$ALWAYS_SCRUB_DISTFILES" ]; then
		ALWAYS_SCRUB_DISTFILES=yes
		ARGS="-d $ARGS"
	fi
fi

if [ -z "$CONFIG_ONLY" -a -z "$NO_RECURSIVE_CONFIG" ]; then
	CONFIG_SEEN_LIST=`mktemp -t config_seen_list`
	CONFIG_ONLY=yes
	export CONFIG_SEEN_LIST CONFIG_ONLY

	CONFIG_PARENT=yes
fi

if [ -n "$UPDATE_ALL" ]; then
	echo "===>>> Starting check of installed ports for available updates"
	ports_by_category

	if [ -n "$CONFIG_SEEN_LIST" ]; then
		echo "===>>> Checking ports for recursive 'make config'"
		for pkg in $roots $trunks $branches $leaves; do
			p=`origin_from_pdb $pkg`
			if [ `grep "${pd}/${p}$" $CONFIG_SEEN_LIST` ]; then
				continue
			else
				echo "${pd}/${p}" >> $CONFIG_SEEN_LIST
				check_for_updates ${pkg##*/} ||
				    fail 'Update failed'
			fi
		done
		unset_recursive_config
		echo ''
		echo "===>>> Starting build for ports that need updating <<<==="
		echo ''
	fi

	for pkg in $roots $trunks $branches $leaves; do
		if [ ! -d "$pkg" ]; then
			# This port probably got updated as a dependency
			# for something else
			continue
		fi
		if [ -n "$FORCE" ]; then
			p=`origin_from_pdb $pkg`
			if [ ! `grep "${pd}/${p}$" $UPDATES_DONE_LIST` ]; then
				echo "===>>> Forcing update for ${pkg##*/}"
				update_port ${pkg##*/}
				continue
			else
				test -n "$VERBOSE" &&
				    echo "===>>> Update for $p already done"
			fi
		else
			test -n "$VERBOSE" &&
			    echo "===>>> Checking installed port: ${pkg##*/}"
		fi
		check_for_updates ${pkg##*/} || fail 'Update failed'
	done
	echo "===>>> Update check of installed ports complete"
	safe_exit
fi

if [ -n "$REPLACE_ORIGIN" ]; then
	portdir="${1#$pd/}"
	newportdir=$portdir

	if [ -d "$pdb/$2" ]; then
		# Handle the portmaster'ish way to specify the port
		upg_port=$2
	else
		# Handle existing portupgrade syntax
		upg_port=`grep -l " ORIGIN:[^\/]*/${2}$" $pdb/*/+CONTENTS`
		[ -n "$upg_port" ] ||
		    upg_port=`grep -l " ORIGIN:[^\/]*/${2}" $pdb/*/+CONTENTS`
		[ -n "$upg_port" ] ||
		    fail "Cannot find an installed port with ORIGIN $2"
		upg_port="${upg_port%/+CONTENTS}"
		upg_port="${upg_port#$pdb/}"
	fi

	oldportdir=`origin_from_pdb $pdb/$upg_port`
fi

# Exercised in the common case of not using -p option
case "$portdir" in
'')	case "$1" in
	'')	test -z "$UPDATE_REQ_BYS" && usage ;;
	${pd}/*)	portdir="${1#$pd/}" ;;
	/*)	upg_port="${1##*/}" ;;
	*)	upg_port=$1 ;;
	esac
esac

case "$upg_port" in
'')	test -n "$portdir" || usage
	old_port_dir=`iport_from_origin ${portdir}`
	if [ -n "$old_port_dir" ]; then
		upg_port="${old_port_dir}"
	fi
	;;
*)	if [ ! -d "$pdb/$upg_port" ]; then
		glob_dirs=`find $pdb -type d -name ${upg_port}\*`
		case "$glob_dirs" in
		*\*)	fail "$upg_port did not match an installed port" ;;
		*)	for dir in $glob_dirs; do
				echo -n "===>>> Update ${dir#$pdb/}? [n] "
				read GLOB_DIR
				case "$GLOB_DIR" in
				[yY])	upg_port=${dir#$pdb/}
					selected=yes
					break
					;;
				esac
			done
			test -n "$selected" || usage
			;;
		esac
	fi
	echo "===>>> Port to upgrade: $upg_port"
	if [ -z "$portdir" ]; then
		portdir=`origin_from_pdb $pdb/$upg_port`
		[ -n "$portdir" ] ||
		    fail "No ORIGIN in $pdb/$upg_port/+CONTENTS"
	fi
	;;
esac

if [ -d "$pd/$portdir" ]; then
	echo "===>>> Port directory: $pd/$portdir"
else
	find_moved_port $portdir
	portdir=$newportdir
fi

cd $pd/$portdir || usage

echo "===>>> Launching 'make checksum' for $portdir in background"
fetchlog=`mktemp -t fetchlog-${portdir##*/}`
(make $MAKE_ARGS checksum >$fetchlog 2>&1 ; rm $fetchlog)&

# Do this here so that the dependency list is accurate
# But only if we have not done it recursively first
test -z "$NO_RECURSIVE_CONFIG" && make $MAKE_ARGS config

if [ -n "$CONFIG_ONLY" ]; then
	dependency_check

	if [ -z "$CONFIG_PARENT" ]; then
		safe_exit
	else
		if [ -n "$UPDATE_REQ_BYS" -a \
		    -s "$pdb/$upg_port/+REQUIRED_BY" ]; then
			echo "$pd/$portdir" >> $CONFIG_SEEN_LIST

			echo ''
			echo "===>>> Checking ports that depend on $upg_port"
			for req_by in `cat $pdb/$upg_port/+REQUIRED_BY`; do
				test -n "$VERBOSE" &&
				  echo "===>>> $req_by is required by $upg_port"
				if [ ! -d "$pdb/$req_by" ]; then
					req_by_error $upg_port $req_by
					continue
				fi
				if ! check_interactive ${req_by} ; then
					continue
				fi

				update_port $req_by
			done
			echo "===>>> Done checking ports that depend on $upg_port"
		fi

		unset_recursive_config
	fi
	echo ''
	echo "===>>> Starting build for $portdir <<<==="
	echo ''
fi

cd $pd/$portdir
dependency_check

if [ -n "$NO_ACTION" ]; then
	test -n "$VERBOSE" &&
	    echo "===>>> Build canceled due to -n flag"
	safe_exit
fi

case "$DONT_PRE_CLEAN" in
'')	make $MAKE_ARGS clean || fail 'make clean failed' ;;
esac

# In case we went elsewhere in the dependency check
cd $pd/$portdir

while [ -f "$fetchlog" ]; do
	echo ''
	echo "===>>> Waiting on fetch to complete for $portdir <<<==="
	tail -10 $fetchlog 2>/dev/null | grep -v '^$'
	echo ''
	echo "===>>> Waiting on fetch to complete for $portdir <<<==="
	sleep 5
done

make $MAKE_ARGS || fail "make failed for $portdir"

new_port=`make $MAKE_ARGS -V PKGNAME`
prefix=`make $MAKE_ARGS -V PKGNAMEPREFIX`
portname=`make $MAKE_ARGS -V PORTNAME`
suffix=`make $MAKE_ARGS -V PKGNAMESUFFIX`
short_port="${prefix}${portname}${suffix}"

# Check for dependencies here in case +REQUIRED_BY is not up to date or missing
grep_deps=`mktemp -t grep-deps-${short_port}`

if [ -n "$upg_port" ]; then
	upg_origin=`origin_from_pdb $pdb/$upg_port`
	grep -l DEPORIGIN:$upg_origin$ $pdb/*/+CONTENTS | cut -f 5 -d '/' |
	    sort -u > $grep_deps
fi

if [ -s "$pdb/$upg_port/+REQUIRED_BY" ]; then
	req_deps=`mktemp -t req-deps-${short_port}`
	sort -u $pdb/$upg_port/+REQUIRED_BY > $req_deps
fi

if [ ! -s "$grep_deps" -a ! -s "$req_deps" ]; then
	if [ -n "$upg_port" ]; then
		echo "===>>> $upg_port is not depended on by any other ports"
	fi
elif [ -s "$grep_deps" -a -s "$req_deps" ]; then
	if ! cmp -s $grep_deps $req_deps; then
		update_reqfile
	fi
elif [ -s "$grep_deps" -a ! -s "$req_deps" ]; then
	dep_warn
	echo -n "===>>> Install these as the new +REQUIRED_BY file? [n] "
	if [ -z "$UNATTENDED" ]; then
		read INSTALLDEPS

		case "$INSTALLDEPS" in
		[yY])	req_deps=`mktemp -t req-deps-${short_port}`
			mv $grep_deps $req_deps
			;;
		esac
	else
		echo "===>>> Default (no) in unattended mode"
	fi
else
	# It should not happen that req_deps exist but grep_deps does not
	fail "$pdb/$upg_port/+REQUIRED_BY indicates a dependency on this port, but no other ports have this dependency recorded"
fi

# Ignore if no old port exists
if [ -n "$upg_port" ]; then
	if [ -n "$BACKUP" ]; then
		echo "===>>> Creating a backup package for $upg_port in $HOME"
		pkg_create -b $upg_port ||
		    fail "Backup package creation failed for $upg_port"
		mv ${upg_port}.* $HOME/
	fi
	pkg_delete -f $upg_port || fail 'pkg_delete failed'
fi

aw=install
fw=Installation
if [ -n "$MAKE_PACKAGE" ]; then
	aw=package
	fw=Packaging
	echo "===>>> Creating a package for $new_port in $HOME"
fi
make $MAKE_ARGS $aw clean || fail "$fw of new port failed"

if [ -n "$MAKE_PACKAGE" ]; then
	mv ${new_port}.* $HOME/
fi

# By now, if this file exists, it should be authoritative
if [ -s "$req_deps" ]; then
	echo "===>>> Updating package dependency entry for each dependent port"
	while read dep_port; do
		dep_port_contents="$pdb/$dep_port/+CONTENTS"
		if grep -q "@pkgdep $upg_port" $dep_port_contents; then
			update_contents $upg_port $new_port
		else
			echo -n "===>>> In ${dep_port}"
			echo " no entry for $upg_port, trying $short_port"
			update_contents "$short_port.*" $new_port
		fi
	done < $req_deps

	mv $req_deps $pdb/$new_port/+REQUIRED_BY
	chmod 644 $pdb/$new_port/+REQUIRED_BY
fi

echo ''
test -z "$upg_port" && upg_port=$portdir
echo "===>>> Upgrade for $upg_port to $new_port succeeded"

test -n "$UPDATES_DONE_LIST" && echo "$pd/$portdir" >> $UPDATES_DONE_LIST

find_distdir () {
	distdir=`make $MAKE_ARGS -V DISTDIR`
	dist_subdir=`make $MAKE_ARGS -V DIST_SUBDIR`
	test -n "$dist_subdir" && distdir="${distdir}/${dist_subdir}"
}

delete_stale_distfiles () {
	# distfiles is used below
	local distfile file DELORNOT

	find_distdir

	distfiles=`make $MAKE_ARGS -V DISTFILES`
	cd $distdir || fail "cd to $distdir failed!"
	for distfile in $distfiles; do
		for file in ${distfile%%[_-]*}*; do
			# This generally means the pattern did not match
			case "$file" in
			*\*)	continue ;;
			esac

			case "$distfiles" in
			*${file}*)
				test -n "$VERBOSE" &&
				    echo "===>>> Keeping new distfile: $file"
				continue	# Do not delete current version
				;;
			*)	if [ -n "$ALWAYS_SCRUB_DISTFILES" ]; then
					echo "===>>> Deleting stale distfile: $file"
					rm -f $file
					continue
				fi

				echo -n "===>>> Delete $file? [n] "
				read DELORNOT
				case "$DELORNOT" in
				[yY])	rm -f $file ;;
				esac
				;;
			esac
		done
	done
}

if [ -z "$DONT_SCRUB_DISTFILES" ]; then
	if [ -z "$oldportdir" ]; then
		delete_stale_distfiles
	else
		if ! cd $pd/$oldportdir; then
			echo "===>>> No $oldportdir to cd to in order to delete"
			echo "       old distfiles, remove by hand if desired"
		else
		echo -n "===>>> Delete all distfiles for ${oldportdir#*/}? [n] "
			read DELORNOT
			case "$DELORNOT" in
			[yY])	find_distdir
				if [ -n "$dist_subdir" ]; then
					cd $distdir && rm -r *
				else
					delete_stale_distfiles
					rm $distfiles
				fi
				;;
			echo "===>>> Deleting empty directories (if any)"
				find $pd/distfiles -type d -empty -print -delete
				;;
			*)	delete_stale_distfiles ;;
			esac
		fi

		cd $pd/$newportdir && delete_stale_distfiles
	fi
fi

if [ -n "$UPDATE_REQ_BYS" -a -s "$pdb/$new_port/+REQUIRED_BY" ]; then
	echo ''
	echo "===>>> Updating ports that depend on $new_port"
	for req_by in `cat $pdb/$new_port/+REQUIRED_BY`; do
		test -n "$VERBOSE" &&
		    echo "===>>> $req_by is required by $new_port"
		if [ ! -d "$pdb/$req_by" ]; then
			req_by_error $new_port $req_by
			continue
		fi
		if ! check_interactive ${req_by} ; then
			continue
		fi

		update_port $req_by
	done
	echo "===>>> Done updating ports that depend on $new_port"
fi

safe_exit

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#  Copyright (c) 2005-2006 Douglas Barton
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.
