#!/bin/sh -T

# $FreeBSD$

# Copyright (c) 2003 Cyrille Lefevre. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
# 3. The name of the authors and contributors may not be used to
#    endorse or promote products derived from this software without
#    specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

setistart () { # dir
	local dir
	dir=$1

	# goto the startup dir
	cd ${dir} || return

	# don't start a dying client
	[ -f stop_after_send.txt ] && return

	# fire up a setiathome client
	${program_path} ${program_args} > /dev/null &

	# memorize the startup dir
	eval pid_$!=${dir}
	# and the client process ID
	setipids="${setipids} $!"
}

setikill () { # SIGTERM handler
	local pids pid

	# save pids to kill
	pids="${sleeppid} ${setipids}"
	# avoid futher setiathome startup
	unset setipids

	# kill'em all if any
	for pid in ${pids}; do
		ps p ${pid} > /dev/null && kill ${pid}
	done
}

setirestart () { # SIGCHLD handler
	local pids pid dir

	# killing in progress
	[ -n "${setipids}" ] || return
	# restart in process
	[ -n "${sleeppids}" ] && return

	# wait for setiathome servers to come up
	sleep ${seti_sleep_time} &

	# wait even if more than one setiathome client dies
	sleeppid=$!
	while ps p ${sleeppid} > /dev/null; do
		wait ${sleeppid}
	done
	unset sleeppid

	# killing while sleeping
	[ -n "${setipids}" ] || return

	# save pids to restart
	pids=${setipids}
	# reset the process ID list
	unset setipids

	for pid in ${pids}; do
		if ps p ${pid} > /dev/null; then
			# still alive
			setipids="${setipids} ${pid}"
		else
			# backup the startup dir
			eval dir=\${pid_${pid}}
			# clean the old one
			unset pid_${pid}
			# launch the dead client
			eval setistart ${dir}
		fi
	done
}

if [ -z "${program_path}" ]; then
	case $0 in
	/*) rc_dir=${0%/*} ;;
	 *) rc_dir=${PWD:-$(pwd)} ;;
	esac
	rc_file=${0##*/}
	rc_path=${rc_dir}/${rc_file}

	if ! PREFIX=$(expr ${rc_path} : "\(/.*\)/libexec/${rc_file}\$"); then
		echo "${rc_file}: Cannot determine PREFIX." >&2
		echo "Please use the complete pathname." >&2
		exit 64
	fi

	echo "Don't use this script directly, uses the following one instead :" >&2
	echo "        ${PREFIX}/etc/rc.d/${rc_file%.bin}.sh start" >&2
	exit 1
fi

# save this shell process ID
echo $$ > ${seti_wrkdir}/shpid.sah

# setup handlers
trap setikill TERM
trap setirestart CHLD

# startup setiathome client(s)
for dir in ${seti_wrksuff}; do
	setistart ${seti_wrkdir}/${dir}
done

# wait for them until death
while [ -n "${setipids}" ]; do
	wait
done
