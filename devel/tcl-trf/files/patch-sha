--- generic/sha.c	Wed Aug  9 15:13:18 2000
+++ generic/sha.c	Sat Jul 10 16:49:48 2004
@@ -34,5 +34,5 @@
 #endif
 
-#include "sha/sha.h"
+#include <openssl/sha.h>
 
 /*
@@ -44,28 +44,9 @@
  */
 
-#define DIGEST_SIZE               (SHA_DIGESTSIZE)
-#define CTX_TYPE                  sha_trf_info
-#define CHUNK_SIZE                256
-
-/* We cannot use SHA_INFO directly as context cause 'sha_update' handles
- * a chunk smaller then CHUNK_SIZE bytes correct if and only if it is
- * the last chunk. This forces us to buffer the incoming bytes till a chunk
- * is complete before doing an update.
- */
-
-typedef struct _sha_trf_info {
-  SHA_INFO       s;
-  unsigned short count;
-  unsigned char  buf [CHUNK_SIZE]; /* SHA block */
-} sha_trf_info;
-
-
 /*
  * Declarations of internal procedures.
  */
 
-static void MDsha_Start     _ANSI_ARGS_ ((VOID* context));
 static void MDsha_Update    _ANSI_ARGS_ ((VOID* context, unsigned int character));
-static void MDsha_UpdateBuf _ANSI_ARGS_ ((VOID* context, unsigned char* buffer, int bufLen));
 static void MDsha_Final     _ANSI_ARGS_ ((VOID* context, VOID* digest));
 
@@ -76,9 +57,9 @@
 static Trf_MessageDigestDescription mdDescription = { /* THREADING: constant, read-only => safe */
   "sha",
-  sizeof (CTX_TYPE),
-  DIGEST_SIZE,
-  MDsha_Start,
+  sizeof (SHA_CTX),
+  SHA_DIGEST_LENGTH,
+  (Trf_MDStart *)SHA_Init,
   MDsha_Update,
-  MDsha_UpdateBuf,
+  (Trf_MDUpdateBuf *)SHA_Update,
   MDsha_Final,
   NULL
@@ -113,33 +94,4 @@
  *------------------------------------------------------*
  *
- *	MDsha_Start --
- *
- *	------------------------------------------------*
- *	Initialize the internal state of the message
- *	digest generator.
- *	------------------------------------------------*
- *
- *	Sideeffects:
- *		As of the called procedure.
- *
- *	Result:
- *		None.
- *
- *------------------------------------------------------*
- */
-
-static void
-MDsha_Start (context)
-VOID* context;
-{
-  sha_trf_info* s = (sha_trf_info*) context;
-
-  memset (s, '\0', sizeof (sha_trf_info));
-  sha_init (&s->s);
-}
-
-/*
- *------------------------------------------------------*
- *
  *	MDsha_Update --
  *
@@ -163,79 +115,7 @@
 unsigned int   character;
 {
-  sha_trf_info* s = (sha_trf_info*) context;
-
-  s->buf [s->count] = character;
-  s->count ++;
+  unsigned char buf = character;
 
-  if (s->count == CHUNK_SIZE) {
-    sha_update (&s->s, s->buf, s->count);
-    s->count = 0;
-  }
-}
-
-/*
- *------------------------------------------------------*
- *
- *	MDsha_UpdateBuf --
- *
- *	------------------------------------------------*
- *	Update the internal state of the message digest
- *	generator for a character buffer.
- *	------------------------------------------------*
- *
- *	Sideeffects:
- *		As of the called procedure.
- *
- *	Result:
- *		None.
- *
- *------------------------------------------------------*
- */
-
-static void
-MDsha_UpdateBuf (context, buffer, bufLen)
-VOID* context;
-unsigned char* buffer;
-int   bufLen;
-{
-  sha_trf_info* s = (sha_trf_info*) context;
-
-  if ((s->count + bufLen) < CHUNK_SIZE) {
-    /*
-     * Not enough for full chunk. Remember incoming
-     * data and wait for another call containing more data.
-     */
-
-    memcpy ((VOID*) (s->buf + s->count), (VOID*) buffer, bufLen);
-    s->count += bufLen;
-  } else {
-    /*
-     * Complete chunk with incoming data, update digest,
-     * then use all chunks contained in the buffer. Remember
-     * an incomplete chunk and wait for further calls.
-     */
-
-    int k = CHUNK_SIZE - s->count;
-
-    if (k < CHUNK_SIZE) {
-      memcpy ((VOID*) (s->buf + s->count), (VOID*) buffer, k);
-
-      sha_update (&s->s, s->buf, CHUNK_SIZE);
-
-      buffer += k;
-      bufLen -= k;
-    } /* k == CHUNK_SIZE => internal buffer was empty, so skip it entirely */
-
-    while (bufLen > CHUNK_SIZE) {
-      sha_update (&s->s, buffer, CHUNK_SIZE);
-
-      buffer += CHUNK_SIZE;
-      bufLen -= CHUNK_SIZE;
-    }
-
-    s->count = bufLen;
-    if (bufLen > 0)
-      memcpy ((VOID*) s->buf, (VOID*) buffer, bufLen);
-  }
+  SHA_Update ((SHA_CTX*)context, &buf, 1);
 }
 
@@ -264,26 +144,4 @@
 VOID* digest;
 {
-  sha_trf_info* s = (sha_trf_info*) context;
-
-  if (s->count > 0) {
-    sha_update (&s->s, s->buf, s->count);
-  }
-
-  sha_final  (&s->s);
-
-#ifndef WORDS_BIGENDIAN
-  Trf_FlipRegisterLong (s->s.digest, SHA_DIGESTSIZE);
-#endif
-
-  memcpy (digest, s->s.digest, SHA_DIGESTSIZE);
+  SHA_Final(digest, context);
 }
-
-/*
- * External code from here on.
- *
- * To make smaller object code, but run a little slower, don't use UNROLL_LOOPS.
- * To use NIST's modified SHA of 7/11/94, define USE_MODIFIED_SHA
- */
-
-#define UNROLL_LOOPS
-#include "sha/sha.c"
