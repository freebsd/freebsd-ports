diff -ruN buildtools/lib/parsers/qmake.orig/FlexLexer.h buildtools/lib/parsers/qmake/FlexLexer.h
--- buildtools/lib/parsers/qmake.orig/FlexLexer.h	Thu Jan  1 01:00:00 1970
+++ buildtools/lib/parsers/qmake/FlexLexer.h	Thu Mar 22 21:48:49 2007
@@ -0,0 +1,205 @@
+
+// -*-C++-*-
+// FlexLexer.h -- define interfaces for lexical analyzer classes generated
+// by flex
+
+// Copyright (c) 1993 The Regents of the University of California.
+// All rights reserved.
+//
+// This code is derived from software contributed to Berkeley by
+// Kent Williams and Tom Epperly.
+//
+//  Redistribution and use in source and binary forms, with or without
+//  modification, are permitted provided that the following conditions
+//  are met:
+
+//  1. Redistributions of source code must retain the above copyright
+//  notice, this list of conditions and the following disclaimer.
+//  2. Redistributions in binary form must reproduce the above copyright
+//  notice, this list of conditions and the following disclaimer in the
+//  documentation and/or other materials provided with the distribution.
+
+//  Neither the name of the University nor the names of its contributors
+//  may be used to endorse or promote products derived from this software
+//  without specific prior written permission.
+
+//  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+//  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//  PURPOSE.
+
+// This file defines FlexLexer, an abstract class which specifies the
+// external interface provided to flex C++ lexer objects, and yyFlexLexer,
+// which defines a particular lexer class.
+//
+// If you want to create multiple lexer classes, you use the -P flag
+// to rename each yyFlexLexer to some other xxFlexLexer.  You then
+// include <FlexLexer.h> in your other sources once per lexer class:
+//
+//	#undef yyFlexLexer
+//	#define yyFlexLexer xxFlexLexer
+//	#include <FlexLexer.h>
+//
+//	#undef yyFlexLexer
+//	#define yyFlexLexer zzFlexLexer
+//	#include <FlexLexer.h>
+//	...
+
+#ifndef __FLEX_LEXER_H
+// Never included before - need to define base class.
+#define __FLEX_LEXER_H
+
+#include <iostream>
+#  ifndef FLEX_STD
+#    define FLEX_STD std::
+#  endif
+
+extern "C++" {
+
+struct yy_buffer_state;
+typedef int yy_state_type;
+
+class FlexLexer {
+public:
+	virtual ~FlexLexer()	{ }
+
+	const char* YYText() const	{ return yytext; }
+	int YYLeng()	const	{ return yyleng; }
+
+	virtual void
+		yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
+	virtual struct yy_buffer_state*
+		yy_create_buffer( FLEX_STD istream* s, int size ) = 0;
+	virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
+	virtual void yyrestart( FLEX_STD istream* s ) = 0;
+
+	virtual int yylex() = 0;
+
+	// Call yylex with new input/output sources.
+	int yylex( FLEX_STD istream* new_in, FLEX_STD ostream* new_out = 0 )
+		{
+		switch_streams( new_in, new_out );
+		return yylex();
+		}
+
+	// Switch to new input/output streams.  A nil stream pointer
+	// indicates "keep the current one".
+	virtual void switch_streams( FLEX_STD istream* new_in = 0,
+					FLEX_STD ostream* new_out = 0 ) = 0;
+
+	int lineno() const		{ return yylineno; }
+
+	int debug() const		{ return yy_flex_debug; }
+	void set_debug( int flag )	{ yy_flex_debug = flag; }
+
+protected:
+	char* yytext;
+	int yyleng;
+	int yylineno;		// only maintained if you use %option yylineno
+	int yy_flex_debug;	// only has effect with -d or "%option debug"
+};
+
+}
+#endif
+
+#if defined(yyFlexLexer) || ! defined(yyFlexLexerOnce)
+// Either this is the first time through (yyFlexLexerOnce not defined),
+// or this is a repeated include to define a different flavor of
+// yyFlexLexer, as discussed in the flex man page.
+#define yyFlexLexerOnce
+
+extern "C++" {
+
+class yyFlexLexer : public FlexLexer {
+public:
+	// arg_yyin and arg_yyout default to the cin and cout, but we
+	// only make that assignment when initializing in yylex().
+	yyFlexLexer( FLEX_STD istream* arg_yyin = 0, FLEX_STD ostream* arg_yyout = 0 );
+
+	virtual ~yyFlexLexer();
+
+	void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
+	struct yy_buffer_state* yy_create_buffer( FLEX_STD istream* s, int size );
+	void yy_delete_buffer( struct yy_buffer_state* b );
+	void yyrestart( FLEX_STD istream* s );
+
+    void yypush_buffer_state( struct yy_buffer_state* new_buffer );
+    void yypop_buffer_state(void);
+
+	virtual int yylex();
+	virtual void switch_streams( FLEX_STD istream* new_in, FLEX_STD ostream* new_out );
+
+protected:
+	virtual int LexerInput( char* buf, int max_size );
+	virtual void LexerOutput( const char* buf, int size );
+	virtual void LexerError( const char* msg );
+
+	void yyunput( int c, char* buf_ptr );
+	int yyinput();
+
+	void yy_load_buffer_state();
+	void yy_init_buffer( struct yy_buffer_state* b, FLEX_STD istream* s );
+	void yy_flush_buffer( struct yy_buffer_state* b );
+
+	int yy_start_stack_ptr;
+	int yy_start_stack_depth;
+	int* yy_start_stack;
+
+	void yy_push_state( int new_state );
+	void yy_pop_state();
+	int yy_top_state();
+
+	yy_state_type yy_get_previous_state();
+	yy_state_type yy_try_NUL_trans( yy_state_type current_state );
+	int yy_get_next_buffer();
+
+	FLEX_STD istream* yyin;	// input source for default LexerInput
+	FLEX_STD ostream* yyout;	// output sink for default LexerOutput
+
+	// yy_hold_char holds the character lost when yytext is formed.
+	char yy_hold_char;
+
+	// Number of characters read into yy_ch_buf.
+	int yy_n_chars;
+
+	// Points to current character in buffer.
+	char* yy_c_buf_p;
+
+	int yy_init;		// whether we need to initialize
+	int yy_start;		// start state number
+
+	// Flag which is used to allow yywrap()'s to do buffer switches
+	// instead of setting up a fresh yyin.  A bit of a hack ...
+	int yy_did_buffer_switch_on_eof;
+
+
+    size_t yy_buffer_stack_top; /**< index of top of stack. */
+    size_t yy_buffer_stack_max; /**< capacity of stack. */
+    struct yy_buffer_state ** yy_buffer_stack; /**< Stack as an array. */
+    void yyensure_buffer_stack(void);
+
+	// The following are not always needed, but may be depending
+	// on use of certain flex features (like REJECT or yymore()).
+
+	yy_state_type yy_last_accepting_state;
+	char* yy_last_accepting_cpos;
+
+	yy_state_type* yy_state_buf;
+	yy_state_type* yy_state_ptr;
+
+	char* yy_full_match;
+	int* yy_full_state;
+	int yy_full_lp;
+
+	int yy_lp;
+	int yy_looking_for_trail_begin;
+
+	int yy_more_flag;
+	int yy_more_len;
+	int yy_more_offset;
+	int yy_prev_more_offset;
+};
+
+}
+
+#endif
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/location.hh kdev_3.4.0/buildtools/lib/parsers/qmake/location.hh
--- buildtools/lib/parsers/qmake/location.hh	1970-01-01 01:00:00.000000000 +0100
+++ buildtools/lib/parsers/qmake/location.hh	2007-02-07 20:35:17.000000000 +0100
@@ -0,0 +1,145 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Locations for Bison parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/**
+ ** \file location.hh
+ ** Define the QMake::location class.
+ */
+
+#ifndef BISON_LOCATION_HH
+# define BISON_LOCATION_HH
+
+# include <iostream>
+# include <string>
+# include "position.hh"
+
+namespace QMake
+{
+
+  /// Abstract a location.
+  class location
+  {
+  public:
+
+    /// Construct a location.
+    location ()
+      : begin (), end ()
+    {
+    }
+
+
+    /// Initialization.
+    inline void initialize (std::string* fn)
+    {
+      begin.initialize (fn);
+      end = begin;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+  public:
+    /// Reset initial location to final location.
+    inline void step ()
+    {
+      begin = end;
+    }
+
+    /// Extend the current location to the COUNT next columns.
+    inline void columns (unsigned int count = 1)
+    {
+      end += count;
+    }
+
+    /// Extend the current location to the COUNT next lines.
+    inline void lines (unsigned int count = 1)
+    {
+      end.lines (count);
+    }
+    /** \} */
+
+
+  public:
+    /// Beginning of the located region.
+    position begin;
+    /// End of the located region.
+    position end;
+  };
+
+  /// Join two location objects to create a location.
+  inline const location operator+ (const location& begin, const location& end)
+  {
+    location res = begin;
+    res.end = end.end;
+    return res;
+  }
+
+  /// Add two location objects.
+  inline const location operator+ (const location& begin, unsigned int width)
+  {
+    location res = begin;
+    res.columns (width);
+    return res;
+  }
+
+  /// Add and assign a location.
+  inline location& operator+= (location& res, unsigned int width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param loc a reference to the location to redirect
+   **
+   ** Avoid duplicate information.
+   */
+  inline std::ostream& operator<< (std::ostream& ostr, const location& loc)
+  {
+    position last = loc.end - 1;
+    ostr << loc.begin;
+    if (last.filename
+	&& (!loc.begin.filename
+	    || *loc.begin.filename != *last.filename))
+      ostr << '-' << last;
+    else if (loc.begin.line != last.line)
+      ostr << '-' << last.line  << '.' << last.column;
+    else if (loc.begin.column != last.column)
+      ostr << '-' << last.column;
+    return ostr;
+  }
+
+}
+
+#endif // not BISON_LOCATION_HH
diff -ruN buildtools/lib/parsers/qmake.orig/Makefile.in buildtools/lib/parsers/qmake/Makefile.in
--- buildtools/lib/parsers/qmake.orig/Makefile.in	Thu Jan 25 15:48:03 2007
+++ buildtools/lib/parsers/qmake/Makefile.in	Thu Mar 22 21:48:26 2007
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # KDE tags expanded automatically by am_edit - $Revision: 483858 $ 
 # @configure_input@
 
@@ -22,8 +22,6 @@
 #SUBDIRS = tests
 
 
-SOURCES = $(libkdevqmakeparser_la_SOURCES)
-
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
@@ -47,7 +45,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-DIST_COMMON = $(kdevelopbuildtoolsinclude_HEADERS) \
+DIST_COMMON = $(kdevelopbuildtoolsinclude_HEADERS) $(noinst_HEADERS) \
 	$(srcdir)/../../../../Doxyfile.am $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in
 subdir = buildtools/lib/parsers/qmake
@@ -70,13 +68,13 @@
 libLTLIBRARIES_INSTALL = $(INSTALL)
 LTLIBRARIES = $(lib_LTLIBRARIES)
 libkdevqmakeparser_la_LIBADD =
-am_libkdevqmakeparser_la_OBJECTS = qmakeast.lo qmakedriver.lo \
-	qmake_yacc.lo qmakeastvisitor.lo
+am_libkdevqmakeparser_la_OBJECTS = qmake_lex.lo qmake_yacc.lo \
+	qmakeast.lo qmakeastvisitor.lo qmakedriver.lo
 #>- libkdevqmakeparser_la_OBJECTS = $(am_libkdevqmakeparser_la_OBJECTS)
 #>+ 5
 libkdevqmakeparser_la_final_OBJECTS = libkdevqmakeparser_la.all_cpp.lo 
-libkdevqmakeparser_la_nofinal_OBJECTS = qmakeast.lo qmakedriver.lo \
-	qmake_yacc.lo qmakeastvisitor.lo
+libkdevqmakeparser_la_nofinal_OBJECTS = qmake_lex.lo qmake_yacc.lo \
+	qmakeast.lo qmakeastvisitor.lo qmakedriver.lo
 @KDE_USE_FINAL_FALSE@libkdevqmakeparser_la_OBJECTS = $(libkdevqmakeparser_la_nofinal_OBJECTS)
 @KDE_USE_FINAL_TRUE@libkdevqmakeparser_la_OBJECTS = $(libkdevqmakeparser_la_final_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
@@ -103,7 +101,7 @@
 SOURCES = $(libkdevqmakeparser_la_SOURCES)
 DIST_SOURCES = $(libkdevqmakeparser_la_SOURCES)
 kdevelopbuildtoolsincludeHEADERS_INSTALL = $(INSTALL_HEADER)
-HEADERS = $(kdevelopbuildtoolsinclude_HEADERS)
+HEADERS = $(kdevelopbuildtoolsinclude_HEADERS) $(noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
 #>- DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -131,9 +129,6 @@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
-DB3INCLUDES = @DB3INCLUDES@
-DB3LDFLAGS = @DB3LDFLAGS@
-DB3LIB = @DB3LIB@
 DCOPIDL = @DCOPIDL@
 DCOPIDL2CPP = @DCOPIDL2CPP@
 DCOPIDLNG = @DCOPIDLNG@
@@ -300,7 +295,15 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
+buildtools_SUBDIR_included_FALSE = @buildtools_SUBDIR_included_FALSE@
+buildtools_SUBDIR_included_TRUE = @buildtools_SUBDIR_included_TRUE@
 datadir = @datadir@
+doc_SUBDIR_included_FALSE = @doc_SUBDIR_included_FALSE@
+doc_SUBDIR_included_TRUE = @doc_SUBDIR_included_TRUE@
+editors_SUBDIR_included_FALSE = @editors_SUBDIR_included_FALSE@
+editors_SUBDIR_included_TRUE = @editors_SUBDIR_included_TRUE@
+embedded_SUBDIR_included_FALSE = @embedded_SUBDIR_included_FALSE@
+embedded_SUBDIR_included_TRUE = @embedded_SUBDIR_included_TRUE@
 exec_prefix = @exec_prefix@
 gmake_prog = @gmake_prog@
 host = @host@
@@ -384,19 +387,32 @@
 kde_wallpaperdir = @kde_wallpaperdir@
 kde_widgetdir = @kde_widgetdir@
 kdeinitdir = @kdeinitdir@
-kdelibs_doxydir = @kdelibs_doxydir@
+kdevdesigner_SUBDIR_included_FALSE = @kdevdesigner_SUBDIR_included_FALSE@
+kdevdesigner_SUBDIR_included_TRUE = @kdevdesigner_SUBDIR_included_TRUE@
+languages_SUBDIR_included_FALSE = @languages_SUBDIR_included_FALSE@
+languages_SUBDIR_included_TRUE = @languages_SUBDIR_included_TRUE@
+lib_SUBDIR_included_FALSE = @lib_SUBDIR_included_FALSE@
+lib_SUBDIR_included_TRUE = @lib_SUBDIR_included_TRUE@
 libdir = @libdir@
 libexecdir = @libexecdir@
 localstatedir = @localstatedir@
 mandir = @mandir@
+mimetypes_SUBDIR_included_FALSE = @mimetypes_SUBDIR_included_FALSE@
+mimetypes_SUBDIR_included_TRUE = @mimetypes_SUBDIR_included_TRUE@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
+parts_SUBDIR_included_FALSE = @parts_SUBDIR_included_FALSE@
+parts_SUBDIR_included_TRUE = @parts_SUBDIR_included_TRUE@
+pics_SUBDIR_included_FALSE = @pics_SUBDIR_included_FALSE@
+pics_SUBDIR_included_TRUE = @pics_SUBDIR_included_TRUE@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 qt_includes = @qt_includes@
 qt_libraries = @qt_libraries@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
+src_SUBDIR_included_FALSE = @src_SUBDIR_included_FALSE@
+src_SUBDIR_included_TRUE = @src_SUBDIR_included_TRUE@
 sysconfdir = @sysconfdir@
 tar = @tar@
 target = @target@
@@ -406,6 +422,8 @@
 target_vendor = @target_vendor@
 unsermake_enable_pch_FALSE = @unsermake_enable_pch_FALSE@
 unsermake_enable_pch_TRUE = @unsermake_enable_pch_TRUE@
+vcs_SUBDIR_included_FALSE = @vcs_SUBDIR_included_FALSE@
+vcs_SUBDIR_included_TRUE = @vcs_SUBDIR_included_TRUE@
 x_includes = @x_includes@
 x_libraries = @x_libraries@
 xdg_appsdir = @xdg_appsdir@
@@ -420,8 +438,8 @@
 #>- libkdevqmakeparser_la_LDFLAGS = -no-undefined $(all_libraries) $(LIB_KIO)
 #>+ 1
 libkdevqmakeparser_la_LDFLAGS = -no-undefined $(KDE_NO_UNDEFINED) $(all_libraries) $(LIB_KIO)
-libkdevqmakeparser_la_SOURCES = qmakeast.cpp qmakedriver.cpp qmake_yacc.cpp \
-	qmakeastvisitor.cpp
+libkdevqmakeparser_la_SOURCES = qmake_lex.cpp qmake_yacc.cpp qmakeast.cpp \
+	qmakeastvisitor.cpp qmakedriver.cpp
 
 kdevelopbuildtoolsincludedir = $(includedir)/kdevelop/buildtools/parsers/qmake
 kdevelopbuildtoolsinclude_HEADERS = qmakeast.h qmakedriver.h qmakeastvisitor.h
@@ -429,6 +447,7 @@
 DOXYGEN_REFERENCES = dcop interfaces kdecore kdefx kdeui khtml kmdi kio kjs kparts kutils
 DOXYGEN_PROJECTNAME = KDevelop QMake parser
 DOXYGEN_DOCDIRPREFIX = kdevparser
+noinst_HEADERS = qmake_lex.h
 #>- all: all-am
 #>+ 1
 all: docs-am  all-am
@@ -444,9 +463,9 @@
 #>- 	      exit 1;; \
 #>- 	  esac; \
 #>- 	done; \
-#>- 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  buildtools/lib/parsers/qmake/Makefile'; \
+#>- 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  buildtools/lib/parsers/qmake/Makefile'; \
 #>- 	cd $(top_srcdir) && \
-#>- 	  $(AUTOMAKE) --foreign  buildtools/lib/parsers/qmake/Makefile
+#>- 	  $(AUTOMAKE) --gnu  buildtools/lib/parsers/qmake/Makefile
 #>+ 12
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
@@ -456,9 +475,9 @@
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  buildtools/lib/parsers/qmake/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  buildtools/lib/parsers/qmake/Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign  buildtools/lib/parsers/qmake/Makefile
+	  $(AUTOMAKE) --gnu  buildtools/lib/parsers/qmake/Makefile
 	cd $(top_srcdir) && perl admin/am_edit buildtools/lib/parsers/qmake/Makefile.in
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
@@ -516,6 +535,7 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/qmake_lex.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/qmake_yacc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/qmakeast.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/qmakeastvisitor.Plo@am__quote@
@@ -753,14 +773,12 @@
 
 parser:
 	cd $(srcdir) ; \
-	bison -d qmake.yy -o qmake_yacc.cpp ; \
-	mv -f qmake_yacc.hpp qmake_yacc.h ; \
+	bison -d qmake.yy -oqmake_yacc.cpp ; \
 	flex -oqmake_lex.cpp qmake.ll
 
 parser_dbg:
 	cd $(srcdir) ; \
-	bison -d qmake.yy -r all -k -t -o qmake_yacc.cpp ; \
-	mv -f qmake_yacc.hpp qmake_yacc.h ; \
+	bison -d qmake.yy -r all -k -t -oqmake_yacc.cpp ; \
 	flex -d -oqmake_lex.cpp qmake.ll
 apidox-am-yes:
 	@if test -z "$(DOXYGEN_EMPTY)"; then \
@@ -958,7 +976,7 @@
 
 
 #>+ 2
-KDE_DIST=qmake_lex.cpp Mainpage.dox qmake_yacc.h Makefile.in Makefile.am 
+KDE_DIST=location.hh qmake_yacc.hpp position.hh Mainpage.dox stack.hh Makefile.in Makefile.am 
 
 #>+ 3
 clean-closures:
@@ -977,9 +995,9 @@
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  buildtools/lib/parsers/qmake/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  buildtools/lib/parsers/qmake/Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign  buildtools/lib/parsers/qmake/Makefile
+	  $(AUTOMAKE) --gnu  buildtools/lib/parsers/qmake/Makefile
 	cd $(top_srcdir) && perl admin/am_edit buildtools/lib/parsers/qmake/Makefile.in
 
 
@@ -990,7 +1008,7 @@
 bcheck: bcheck-am
 
 bcheck-am:
-	@for i in $(kdevelopbuildtoolsinclude_HEADERS); do \
+	@for i in $(kdevelopbuildtoolsinclude_HEADERS) ; do \
 	    if test $(srcdir)/$$i -nt $$i.bchecktest.cc; then \
 	        echo "int main() {return 0;}" > $$i.bchecktest.cc ; \
 	        echo "#include \"$$i\"" >> $$i.bchecktest.cc ; \
@@ -1006,11 +1024,11 @@
 
 
 #>+ 11
-libkdevqmakeparser_la.all_cpp.cpp: $(srcdir)/Makefile.in $(srcdir)/qmakeast.cpp $(srcdir)/qmakedriver.cpp $(srcdir)/qmake_yacc.cpp $(srcdir)/qmakeastvisitor.cpp 
+libkdevqmakeparser_la.all_cpp.cpp: $(srcdir)/Makefile.in $(srcdir)/qmake_lex.cpp $(srcdir)/qmake_yacc.cpp $(srcdir)/qmakeast.cpp $(srcdir)/qmakeastvisitor.cpp $(srcdir)/qmakedriver.cpp 
 	@echo 'creating libkdevqmakeparser_la.all_cpp.cpp ...'; \
 	rm -f libkdevqmakeparser_la.all_cpp.files libkdevqmakeparser_la.all_cpp.final; \
 	echo "#define KDE_USE_FINAL 1" >> libkdevqmakeparser_la.all_cpp.final; \
-	for file in qmakeast.cpp qmakedriver.cpp qmake_yacc.cpp qmakeastvisitor.cpp ; do \
+	for file in qmake_lex.cpp qmake_yacc.cpp qmakeast.cpp qmakeastvisitor.cpp qmakedriver.cpp ; do \
 	  echo "#include \"$$file\"" >> libkdevqmakeparser_la.all_cpp.files; \
 	  test ! -f $(srcdir)/$$file || egrep '^#pragma +implementation' $(srcdir)/$$file >> libkdevqmakeparser_la.all_cpp.final; \
 	done; \
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/position.hh kdev_3.4.0/buildtools/lib/parsers/qmake/position.hh
--- buildtools/lib/parsers/qmake/position.hh	1970-01-01 01:00:00.000000000 +0100
+++ buildtools/lib/parsers/qmake/position.hh	2007-02-07 20:35:14.000000000 +0100
@@ -0,0 +1,142 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Positions for Bison parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/**
+ ** \file position.hh
+ ** Define the QMake::position class.
+ */
+
+#ifndef BISON_POSITION_HH
+# define BISON_POSITION_HH
+
+# include <iostream>
+# include <string>
+
+namespace QMake
+{
+  /// Abstract a position.
+  class position
+  {
+  public:
+
+    /// Construct a position.
+    position ()
+      : filename (0), line (1), column (0)
+    {
+    }
+
+
+    /// Initialization.
+    inline void initialize (std::string* fn)
+    {
+      filename = fn;
+      line = 1;
+      column = 0;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+  public:
+    /// (line related) Advance to the COUNT next lines.
+    inline void lines (int count = 1)
+    {
+      column = 0;
+      line += count;
+    }
+
+    /// (column related) Advance to the COUNT next columns.
+    inline void columns (int count = 1)
+    {
+      int leftmost = 0;
+      int current  = column;
+      if (leftmost <= current + count)
+	column += count;
+      else
+	column = 0;
+    }
+    /** \} */
+
+  public:
+    /// File name to which this position refers.
+    std::string* filename;
+    /// Current line number.
+    unsigned int line;
+    /// Current column number.
+    unsigned int column;
+  };
+
+  /// Add and assign a position.
+  inline const position&
+  operator+= (position& res, const int width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /// Add two position objects.
+  inline const position
+  operator+ (const position& begin, const int width)
+  {
+    position res = begin;
+    return res += width;
+  }
+
+  /// Add and assign a position.
+  inline const position&
+  operator-= (position& res, const int width)
+  {
+    return res += -width;
+  }
+
+  /// Add two position objects.
+  inline const position
+  operator- (const position& begin, const int width)
+  {
+    return begin + -width;
+  }
+
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param pos a reference to the position to redirect
+   */
+  inline std::ostream&
+  operator<< (std::ostream& ostr, const position& pos)
+  {
+    if (pos.filename)
+      ostr << *pos.filename << ':';
+    return ostr << pos.line << '.' << pos.column;
+  }
+
+}
+#endif // not BISON_POSITION_HH
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmakedriver.cpp kdev_3.4.0/buildtools/lib/parsers/qmake/qmakedriver.cpp
--- buildtools/lib/parsers/qmake/qmakedriver.cpp	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmakedriver.cpp	2007-02-07 20:49:28.000000000 +0100
@@ -20,57 +20,67 @@
 #include "qmakedriver.h"
 #include "qmakeast.h"
 
-#include <stdio.h>
 #include <qvaluestack.h>
 #include <kio/netaccess.h>
 
-extern FILE *yyin, *yyout;
-extern int yyparse();
-extern int yydebug;
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-extern YY_BUFFER_STATE yy_scan_string(const char*);
-extern void yy_delete_buffer(YY_BUFFER_STATE);
-extern QValueStack<QMake::ProjectAST *> projects;
+#include <iostream>
+#include <fstream>
+#include <sstream>
+
+#include "qmake_lex.h"
+#include "qmake_yacc.hpp"
 
 namespace QMake {
 
-int Driver::parseFile(const char *fileName, ProjectAST **ast)
+int Driver::parseFile(const char *fileName, ProjectAST **ast, int debug)
 {
-    yyin = fopen(fileName, "r");
-    if (yyin == 0)
+    std::ifstream inf( fileName, std::ios::in );
+    if ( !inf.is_open() )
     {
         *ast = 0;
         return 1;
     }
 //     yydebug = 1;
-    int ret = yyparse();
-    *ast = projects.top();
+    Lexer l(&inf);
+    l.set_debug(debug);
+    int depth = 0;
+    QValueStack<ProjectAST*> stack;
+    Parser p(&l, stack, depth);
+    p.set_debug_level(debug);
+    int ret = p.parse();
+    *ast = stack.top();
     (*ast)->setFileName(fileName);
     return ret;
 }
 
-int Driver::parseFile(QString fileName, ProjectAST **ast)
+int Driver::parseFile(QString fileName, ProjectAST **ast, int debug)
 {
-    return parseFile(fileName.ascii(), ast);
+    return parseFile(fileName.ascii(), ast, debug);
 }
 
-int Driver::parseFile(KURL fileName, ProjectAST **ast)
+int Driver::parseFile(KURL fileName, ProjectAST **ast, int debug)
 {
     QString tmpFile;
     int ret = 0;
     if (KIO::NetAccess::download(fileName, tmpFile, 0))
-        ret = parseFile(tmpFile, ast);
+        ret = parseFile(tmpFile, ast, debug);
     KIO::NetAccess::removeTempFile(tmpFile);
     return ret;
 }
 
-int Driver::parseString( const char* string, ProjectAST **ast )
+int Driver::parseString( const char* string, ProjectAST **ast, int debug )
 {
-    YY_BUFFER_STATE state = yy_scan_string( string );
-    int ret = yyparse();
-    *ast = projects.top();
+    std::istringstream ins;
+    ins.str(string);
+    Lexer l(&ins);
+    l.set_debug(debug);
+    int depth = 0;
+    QValueStack<ProjectAST*> stack;
+    Parser p(&l, stack, depth);
+    p.set_debug_level(debug);
+    int ret = p.parse();
+    *ast = stack.top();
     (*ast)->setFileName("");
-    yy_delete_buffer( state );
     return ret;
 }
 
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmakedriver.h kdev_3.4.0/buildtools/lib/parsers/qmake/qmakedriver.h
--- buildtools/lib/parsers/qmake/qmakedriver.h	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmakedriver.h	2007-02-07 20:35:13.000000000 +0100
@@ -20,10 +20,8 @@
 #ifndef QMAKEQMAKEDRIVER_H
 #define QMAKEQMAKEDRIVER_H
 
-#include "qmakeast.h"
-
-#include <qvaluelist.h>
-#include <kurl.h>
+class QString;
+class KURL;
 
 namespace QMake {
 
@@ -45,26 +43,11 @@
     initialize it on its own.
     @return The result of parsing. Result is 0 on success and <> 0 on failure.
     */
-    static int parseFile(const char *fileName, ProjectAST **ast);
-    static int parseFile(QString fileName, ProjectAST **ast);
-    static int parseFile(KURL fileName, ProjectAST **ast);
-    static int parseString(const char* string, ProjectAST **ast);
-
-/*    template<class Op>
-    static void walkAST(Op &op, const ProjectAST *ast)
-    {
-//         op(ast);
-        for (QValueList<QMake::AST*>::const_iterator it = ast->statements.constBegin();
-                it != ast->statements.constEnd(); ++it)
-        {
-            const AST *child = *it;
-            if (child->nodeType() == AST::ProjectAST)
-                walkAST<Op>(op, static_cast<const QMake::ProjectAST*>(child));
-            else
-                op(child);
-        }
-    }
-*/
+    static int parseFile(const char *fileName, ProjectAST **ast, int debug);
+    static int parseFile(QString fileName, ProjectAST **ast, int debug);
+    static int parseFile(KURL fileName, ProjectAST **ast, int debug);
+    static int parseString(const char* string, ProjectAST **ast, int debug);
+
 };
 
 }
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake_lex.cpp kdev_3.4.0/buildtools/lib/parsers/qmake/qmake_lex.cpp
--- buildtools/lib/parsers/qmake/qmake_lex.cpp	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake_lex.cpp	2007-02-07 20:35:11.000000000 +0100
@@ -14,13 +14,17 @@
 #define FLEX_BETA
 #endif
 
+    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
+     * following macro. This is required in order to pass the c++-multiple-scanners
+     * test in the regression suite. We get reports that it breaks inheritance.
+     * We will address this in a future release of flex, or omit the C++ scanner
+     * altogether.
+     */
+    #define yyFlexLexer yyFlexLexer
+
 /* First, we deal with  platform-specific or compiler-specific issues. */
 
 /* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
 
 /* end standard C headers. */
 
@@ -87,6 +91,13 @@
 
 #endif /* ! FLEXINT_H */
 
+/* begin standard C++ headers. */
+#include <iostream> 
+#include <errno.h>
+#include <cstdlib>
+#include <cstring>
+/* end standard C++ headers. */
+
 #ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
@@ -134,7 +145,7 @@
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
+#define YY_NEW_FILE yyrestart( yyin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
@@ -154,13 +165,24 @@
 
 extern int yyleng;
 
-extern FILE *yyin, *yyout;
-
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-    #define YY_LESS_LINENO(n)
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -192,7 +214,8 @@
 #define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
-	FILE *yy_input_file;
+
+	std::istream* yy_input_file;
 
 	char *yy_ch_buf;		/* input buffer */
 	char *yy_buf_pos;		/* current position in input buffer */
@@ -253,11 +276,6 @@
 	};
 #endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
-
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
@@ -273,39 +291,6 @@
  */
 #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
-
 void *yyalloc (yy_size_t  );
 void *yyrealloc (void *,yy_size_t  );
 void yyfree (void *  );
@@ -317,7 +302,7 @@
 	if ( ! YY_CURRENT_BUFFER ){ \
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
@@ -327,7 +312,7 @@
 	if ( ! YY_CURRENT_BUFFER ){\
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
@@ -341,21 +326,17 @@
 
 typedef unsigned char YY_CHAR;
 
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
 #define yytext_ptr yytext
+#define YY_INTERACTIVE
 
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
+#include <FlexLexer.h>
+int yyFlexLexer::yylex()
+	{
+	LexerError( "yyFlexLexer::yylex invoked but %option yyclass used" );
+	return 0;
+	}
+
+#define YY_DECL int QMake::Lexer::yylex()
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
@@ -376,24 +357,25 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[79] =
+static yyconst flex_int16_t yy_accept[83] =
     {   0,
         0,    0,    0,    0,    0,    0,    0,    0,   25,   24,
         1,   22,    5,   23,   19,   20,    5,   24,    5,   21,
        11,   24,   16,   18,   24,    9,    2,    9,    9,   24,
         2,    2,    6,    2,   24,    8,    1,    5,    5,   23,
-       14,   12,   13,    0,   17,    0,    4,   15,    9,    0,
-        2,    0,    9,    0,    9,    0,    7,    0,    3,    2,
-        3,    2,    6,    6,    6,    6,    2,    3,    0,    8,
-        9,    0,    9,    0,    0,   10,    0,    0
+       14,   12,   13,    0,   17,    0,    4,    4,   15,    9,
+        0,    2,    0,    9,    0,    0,    9,    0,    7,    7,
+        0,    3,    2,    3,    2,    6,    6,    6,    6,    2,
+        3,    0,    8,    9,    0,    9,    0,    0,   10,    0,
+        7,    0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    5,    6,    7,    8,    1,    1,    1,    9,
+        1,    2,    5,    6,    7,    8,    1,    1,    1,    9,
        10,   11,   12,    1,   13,   14,    1,   15,   15,   15,
        15,   15,   15,   15,   15,   15,   15,   16,    1,    1,
        17,    1,    1,    1,   18,   18,   18,   18,   18,   18,
@@ -422,122 +404,104 @@
 
 static yyconst flex_int32_t yy_meta[25] =
     {   0,
-        1,    2,    3,    2,    1,    1,    1,    1,    1,    1,
+        1,    2,    3,    4,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1
     } ;
 
-static yyconst flex_int16_t yy_base[92] =
+static yyconst flex_int16_t yy_base[96] =
     {   0,
-        0,    0,   23,   41,   29,   30,   25,   36,  144,  285,
-       36,  285,   56,    0,  285,  285,  125,  124,  123,   51,
-      285,   47,  285,  285,  122,  119,   50,  118,   77,   95,
-       80,   81,   54,   87,  126,  120,   61,    0,    0,    0,
-      285,  285,  285,   88,  285,   98,  285,  285,  106,   93,
-      101,  104,  113,   67,  131,   74,  285,  149,  285,  109,
-       72,  116,    0,   91,    0,  102,  120,    0,   56,   52,
-      167,  185,  203,  124,  221,  239,  127,  285,  258,  261,
-      264,   58,   40,  266,  269,  271,  273,  275,  278,  280,
-      282
+        0,    0,   23,   41,   26,   29,   31,   36,  158,  202,
+      155,  202,   56,    0,  202,  202,  139,  138,  137,   30,
+      202,   50,  202,  202,  135,  130,   48,   47,   77,   95,
+       55,   56,   71,   70,  137,  131,  131,    0,    0,    0,
+      202,  202,  202,   35,  202,   80,  202,  128,  202,   82,
+       76,   84,   84,   83,   98,   90,  116,   90,  202,  102,
+      134,  202,  101,  107,  105,    0,  111,    0,  120,  114,
+        0,   55,   49,  121,  123,  126,  124,  142,  144,  132,
+      202,  202,  163,  167,  171,   37,  175,  177,  181,  183,
+      187,  189,  193,  195,  197
 
     } ;
 
-static yyconst flex_int16_t yy_def[92] =
+static yyconst flex_int16_t yy_def[96] =
     {   0,
-       78,    1,   79,   79,    4,    4,   80,   80,   78,   78,
-       78,   78,   78,   81,   78,   78,   13,   78,   13,   78,
-       78,   78,   78,   78,   78,   82,   78,   83,   84,   82,
-       85,   78,   86,   85,   87,   87,   78,   13,   13,   81,
-       78,   78,   78,   78,   78,   78,   78,   78,   82,   82,
-       78,   88,   89,   83,   84,   88,   78,   84,   78,   85,
-       88,   78,   90,   86,   90,   86,   85,   90,   87,   87,
-       89,   91,   89,   89,   91,   91,   91,    0,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-       78
+       82,    1,   83,   83,    4,    4,   84,   84,   82,   82,
+       82,   82,   82,   85,   82,   82,   13,   82,   13,   82,
+       82,   82,   82,   82,   82,   86,   82,   87,   88,   86,
+       89,   82,   90,   89,   91,   91,   82,   13,   13,   85,
+       82,   82,   82,   82,   82,   82,   82,   82,   82,   86,
+       86,   82,   92,   93,   94,   87,   88,   92,   82,   92,
+       88,   82,   89,   92,   82,   95,   90,   95,   90,   89,
+       95,   91,   91,   93,   94,   93,   93,   94,   94,   94,
+       82,    0,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82
 
     } ;
 
-static yyconst flex_int16_t yy_nxt[310] =
+static yyconst flex_int16_t yy_nxt[227] =
     {   0,
-       10,   11,   12,   11,   13,   10,   14,   13,   15,   16,
+       10,   11,   12,   10,   13,   10,   14,   13,   15,   16,
        17,   18,   19,   10,   13,   20,   21,   13,   22,   13,
-       23,   10,   24,   25,   27,   12,   27,   10,   28,   29,
-       32,   34,   32,   34,   36,   33,   33,   37,   10,   37,
-       53,   30,   31,   12,   31,   36,   28,   29,   46,   47,
-       46,   51,   44,   51,   44,   65,   52,   65,   49,   30,
-       38,   70,   37,   38,   37,   70,   38,   38,   39,   38,
-       38,   45,   66,   38,   57,   38,   57,   38,   56,   57,
-       56,   60,   62,   60,   62,   54,   61,   63,   67,   44,
-       67,   44,   65,   68,   65,   58,   46,   47,   46,   46,
-
-       47,   46,   51,   65,   51,   65,   57,   52,   45,   66,
-       60,   50,   60,   50,   72,   61,   72,   62,   73,   62,
-       66,   67,   63,   67,   50,   78,   68,   78,   78,   70,
-       78,   74,   56,   57,   56,   70,   54,   50,   48,   43,
-       42,   41,   74,   78,   78,   77,   78,   78,   78,   58,
-       56,   57,   56,   78,   78,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   58,   72,   78,
-       72,   78,   73,   78,   78,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   74,   72,   78,   72,   78,
-       76,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-
-       78,   78,   78,   77,   72,   78,   72,   78,   73,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-       78,   74,   72,   78,   72,   78,   76,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   77,
-       72,   78,   72,   78,   76,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   77,   26,   26,
-       26,   35,   35,   35,   40,   40,   55,   55,   55,   59,
-       59,   64,   64,   69,   69,   56,   56,   56,   71,   71,
-       65,   65,   75,   75,    9,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-
-       78,   78,   78,   78,   78,   78,   78,   78,   78
+       23,   10,   24,   25,   27,   12,   10,   32,   28,   29,
+       34,   44,   33,   10,   10,   33,   44,   50,   10,   10,
+       36,   30,   31,   12,   10,   36,   28,   29,   55,   52,
+       45,   46,   47,   48,   53,   45,   63,   65,   73,   30,
+       38,   64,   66,   38,   73,   56,   38,   38,   39,   38,
+       38,   70,   68,   38,   68,   38,   71,   38,   58,   59,
+       60,   46,   47,   48,   75,   52,   59,   60,   76,   69,
+       53,   82,   59,   60,   51,   61,   46,   47,   48,   75,
+
+       51,   77,   63,   79,   81,   60,   65,   64,   56,   59,
+       60,   66,   68,   51,   68,   70,   80,   58,   59,   60,
+       71,   68,   75,   68,   75,   82,   76,   75,   79,   69,
+       47,   76,   37,   82,   61,   58,   59,   60,   69,   77,
+       73,   80,   77,   75,   77,   75,   73,   79,   51,   79,
+       80,   49,   61,   43,   42,   41,   37,   82,   82,   82,
+       80,   82,   80,   26,   26,   26,   26,   35,   35,   35,
+       35,   40,   40,   82,   40,   54,   54,   57,   57,   57,
+       57,   62,   62,   67,   67,   82,   67,   72,   72,   58,
+       58,   58,   58,   74,   74,   78,   78,   68,   68,   82,
+
+       68,    9,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82
     } ;
 
-static yyconst flex_int16_t yy_chk[310] =
+static yyconst flex_int16_t yy_chk[227] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    3,    3,    3,    7,    3,    3,
-        5,    6,    5,    6,    7,    5,    6,   11,    8,   11,
-       83,    3,    4,    4,    4,    8,    4,    4,   22,   22,
-       22,   27,   20,   27,   20,   33,   27,   33,   82,    4,
-       13,   70,   37,   13,   37,   69,   13,   13,   13,   13,
-       13,   20,   33,   13,   61,   13,   56,   13,   29,   29,
-       29,   31,   32,   31,   32,   54,   31,   32,   34,   44,
-       34,   44,   64,   34,   64,   29,   30,   30,   30,   46,
-
-       46,   46,   51,   66,   51,   66,   52,   51,   44,   64,
-       60,   50,   60,   30,   53,   60,   53,   62,   53,   62,
-       66,   67,   62,   67,   49,   74,   67,   74,   77,   36,
-       77,   53,   55,   55,   55,   35,   28,   26,   25,   19,
-       18,   17,   74,    9,    0,   77,    0,    0,    0,   55,
-       58,   58,   58,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   58,   71,    0,
-       71,    0,   71,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   71,   72,    0,   72,    0,
-       72,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,   72,   73,    0,   73,    0,   73,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   73,   75,    0,   75,    0,   75,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   75,
-       76,    0,   76,    0,   76,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   76,   79,   79,
-       79,   80,   80,   80,   81,   81,   84,   84,   84,   85,
-       85,   86,   86,   87,   87,   88,   88,   88,   89,   89,
-       90,   90,   91,   91,   78,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-
-       78,   78,   78,   78,   78,   78,   78,   78,   78
+        1,    1,    1,    1,    3,    3,    3,    5,    3,    3,
+        6,   20,    5,    7,    7,    6,   44,   86,    8,    8,
+        7,    3,    4,    4,    4,    8,    4,    4,   28,   27,
+       20,   22,   22,   22,   27,   44,   31,   32,   73,    4,
+       13,   31,   32,   13,   72,   28,   13,   13,   13,   13,
+       13,   34,   33,   13,   33,   13,   34,   13,   29,   29,
+       29,   46,   46,   46,   54,   52,   53,   53,   54,   33,
+       52,   56,   58,   58,   51,   29,   30,   30,   30,   55,
+
+       50,   54,   63,   55,   60,   60,   65,   63,   56,   64,
+       64,   65,   67,   30,   67,   70,   55,   57,   57,   57,
+       70,   69,   74,   69,   75,   77,   74,   76,   75,   67,
+       48,   76,   37,   80,   57,   61,   61,   61,   69,   74,
+       36,   75,   77,   78,   76,   79,   35,   78,   26,   79,
+       80,   25,   61,   19,   18,   17,   11,    9,    0,    0,
+       78,    0,   79,   83,   83,   83,   83,   84,   84,   84,
+       84,   85,   85,    0,   85,   87,   87,   88,   88,   88,
+       88,   89,   89,   90,   90,    0,   90,   91,   91,   92,
+       92,   92,   92,   93,   93,   94,   94,   95,   95,    0,
+
+       95,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82
     } ;
 
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[25] =
+    {   0,
+0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 1, 0, 0,     };
 
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
@@ -546,7 +510,6 @@
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
 #line 1 "qmake.ll"
 #line 2 "qmake.ll"
 /***************************************************************************
@@ -569,9 +532,12 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#include <qmake_yacc.h>
 #include <stdlib.h>
 
+#define DONT_INCLUDE_FLEXLEXER
+
+#include "qmake_lex.h"
+
 /**
 @file qmake.ll
 QMake Lexer
@@ -598,7 +564,7 @@
 
 
 
-#line 602 "qmake_lex.cpp"
+#line 568 "qmake_lex.cpp"
 
 #define INITIAL 0
 #define list 1
@@ -617,22 +583,6 @@
 #define YY_EXTRA_TYPE void *
 #endif
 
-static int yy_init_globals (void );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-    static void yyunput (int c,char *buf_ptr  );
-    
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
@@ -643,12 +593,6 @@
 
 #ifndef YY_NO_INPUT
 
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -658,10 +602,7 @@
 
 /* Copy whatever the last rule matched to the standard output. */
 #ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO LexerOutput( yytext, yyleng )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -669,34 +610,9 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
 \
+	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
 
 #endif
 
@@ -715,7 +631,7 @@
 
 /* Report a fatal error. */
 #ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#define YY_FATAL_ERROR(msg) LexerError( msg )
 #endif
 
 /* end tables serialization structures and prototypes */
@@ -725,10 +641,7 @@
  */
 #ifndef YY_DECL
 #define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
+#define YY_DECL int yyFlexLexer::yylex()
 #endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
@@ -757,9 +670,9 @@
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
     
-#line 72 "qmake.ll"
+#line 78 "qmake.ll"
 
-#line 763 "qmake_lex.cpp"
+#line 676 "qmake_lex.cpp"
 
 	if ( !(yy_init) )
 		{
@@ -773,18 +686,18 @@
 			(yy_start) = 1;	/* first start state */
 
 		if ( ! yyin )
-			yyin = stdin;
+			yyin = & std::cin;
 
 		if ( ! yyout )
-			yyout = stdout;
+			yyout = & std::cout;
 
 		if ( ! YY_CURRENT_BUFFER ) {
 			yyensure_buffer_stack ();
 			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
+				yy_create_buffer( yyin, YY_BUF_SIZE );
 		}
 
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
@@ -813,13 +726,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 79 )
+				if ( yy_current_state >= 83 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 285 );
+		while ( yy_base[yy_current_state] != 202 );
 
 yy_find_action:
 		yy_act = yy_accept[yy_current_state];
@@ -832,6 +745,16 @@
 
 		YY_DO_BEFORE_ACTION;
 
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					   
+    yylineno++;
+;
+			}
+
 do_action:	/* This label is used only to access EOF actions. */
 
 		switch ( yy_act )
@@ -845,147 +768,205 @@
 
 case 1:
 YY_RULE_SETUP
-#line 73 "qmake.ll"
+#line 79 "qmake.ll"
 {}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 74 "qmake.ll"
-{ yylval.value = yytext; return LIST_WS; }
+#line 81 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::LIST_WS;
+}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 75 "qmake.ll"
-{ 
-    yylval.value = yytext;
-    unput(char(yylval.value.at(yylval.value.length()-1).latin1()));
-    yylval.value = yylval.value.mid(0, yylval.value.length()-1);
-    return INDENT;
+#line 86 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    unput(char(mylval->value.at(mylval->value.length()-1).latin1()));
+    mylval->value = mylval->value.mid(0, mylval->value.length()-1);
+    return Parser::token::token::INDENT;
 }
 	YY_BREAK
 case 4:
 /* rule 4 can match eol */
 YY_RULE_SETUP
-#line 82 "qmake.ll"
-{ BEGIN(list); return CONT; }
+#line 93 "qmake.ll"
+{
+    BEGIN(list);
+    return Parser::token::token::CONT;
+}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 83 "qmake.ll"
-{ yylval.value = yytext; return (ID_SIMPLE); }
+#line 97 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return (Parser::token::token::ID_SIMPLE);
+}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 85 "qmake.ll"
+#line 102 "qmake.ll"
 {
-    yylval.value = yytext;
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
     BEGIN(list);
-    return (LIST_COMMENT_WITHOUT_NEWLINE);
+    return (Parser::token::token::LIST_COMMENT_WITHOUT_NEWLINE);
 }
 	YY_BREAK
 case 7:
 /* rule 7 can match eol */
 YY_RULE_SETUP
-#line 91 "qmake.ll"
+#line 108 "qmake.ll"
 {
-    yylval.value = yytext;
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
     BEGIN(list);
-    return (LIST_COMMENT);
+    return (Parser::token::token::LIST_COMMENT);
     }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 97 "qmake.ll"
+#line 114 "qmake.ll"
 {
-    yylval.value = yytext;
-    yylval.value = yylval.value.mid(0, yylval.value.length()-1);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    mylval->value = mylval->value.mid(0, mylval->value.length()-1);
     unput(')');
     BEGIN(INITIAL);
-    return (ID_ARGS);
+    return (Parser::token::token::ID_ARGS);
     }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 105 "qmake.ll"
-{ BEGIN(list_with_comment); yylval.value = yytext; return VARIABLE_VALUE; }
+#line 122 "qmake.ll"
+{
+    BEGIN(list_with_comment);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::VARIABLE_VALUE;
+}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 106 "qmake.ll"
-{ BEGIN(list_with_comment); yylval.value = yytext; return QUOTED_VARIABLE_VALUE; }
+#line 128 "qmake.ll"
+{
+    BEGIN(list_with_comment);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::QUOTED_VARIABLE_VALUE;
+}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 108 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return EQ; }
+#line 134 "qmake.ll"
+{
+BEGIN(list);
+mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+return Parser::token::token::EQ;
+}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 109 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return PLUSEQ; }
+#line 140 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::PLUSEQ;
+}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 110 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return MINUSQE; }
+#line 146 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::MINUSEQ;
+}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 111 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return STAREQ; }
+#line 152 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::STAREQ;
+}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 112 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return TILDEEQ; }
+#line 158 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::TILDEEQ;
+}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 113 "qmake.ll"
-{ return LCURLY; }
+#line 164 "qmake.ll"
+{
+    return Parser::token::token::LCURLY;
+}
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 114 "qmake.ll"
-{ return LCURLY; }
+#line 168 "qmake.ll"
+{
+    return Parser::token::token::LCURLY;
+}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 115 "qmake.ll"
-{ return RCURLY; }
+#line 172 "qmake.ll"
+{
+    return Parser::token::token::RCURLY;
+}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 116 "qmake.ll"
-{ BEGIN(funcargs); return LBRACE; }
+#line 176 "qmake.ll"
+{
+    BEGIN(funcargs);
+    return Parser::token::token::LBRACE;
+}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 117 "qmake.ll"
-{ BEGIN(INITIAL); return RBRACE; }
+#line 181 "qmake.ll"
+{
+    BEGIN(INITIAL);
+    return Parser::token::token::RBRACE;
+}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 118 "qmake.ll"
-{ yylval.value = yytext; return COLON; }
+#line 186 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::COLON;
+}
 	YY_BREAK
 case 22:
 /* rule 22 can match eol */
 YY_RULE_SETUP
-#line 119 "qmake.ll"
-{ BEGIN(INITIAL); return NEWLINE; }
+#line 191 "qmake.ll"
+{
+    BEGIN(INITIAL);
+    return Parser::token::token::NEWLINE;
+}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 121 "qmake.ll"
-{ yylval.value = yytext; return (COMMENT); }
+#line 196 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return (Parser::token::token::COMMENT);
+}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 123 "qmake.ll"
+#line 201 "qmake.ll"
 ECHO;
 	YY_BREAK
-#line 989 "qmake_lex.cpp"
+#line 970 "qmake_lex.cpp"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(list):
 case YY_STATE_EOF(list_with_comment):
@@ -1066,7 +1047,7 @@
 				{
 				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap( ) )
+				if ( yywrap(  ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -1121,6 +1102,81 @@
 		} /* end of scanning one token */
 } /* end of yylex */
 
+yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout )
+{
+	yyin = arg_yyin;
+	yyout = arg_yyout;
+	yy_c_buf_p = 0;
+	yy_init = 0;
+	yy_start = 0;
+	yy_flex_debug = 0;
+	yylineno = 1;	// this will only get updated if %option yylineno
+
+	yy_did_buffer_switch_on_eof = 0;
+
+	yy_looking_for_trail_begin = 0;
+	yy_more_flag = 0;
+	yy_more_len = 0;
+	yy_more_offset = yy_prev_more_offset = 0;
+
+	yy_start_stack_ptr = yy_start_stack_depth = 0;
+	yy_start_stack = NULL;
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+
+	yy_state_buf = 0;
+
+}
+
+void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )
+{
+	if ( new_in )
+		{
+		yy_delete_buffer( YY_CURRENT_BUFFER );
+		yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  ) );
+		}
+
+	if ( new_out )
+		yyout = new_out;
+}
+
+#ifdef YY_INTERACTIVE
+int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )
+#else
+int yyFlexLexer::LexerInput( char* buf, int max_size )
+#endif
+{
+	if ( yyin->eof() || yyin->fail() )
+		return 0;
+
+#ifdef YY_INTERACTIVE
+	yyin->get( buf[0] );
+
+	if ( yyin->eof() )
+		return 0;
+
+	if ( yyin->bad() )
+		return -1;
+
+	return 1;
+
+#else
+	(void) yyin->read( buf, max_size );
+
+	if ( yyin->bad() )
+		return -1;
+	else
+		return yyin->gcount();
+#endif
+}
+
+void yyFlexLexer::LexerOutput( const char* buf, int size )
+{
+	(void) yyout->write( buf, size );
+}
+
 /* yy_get_next_buffer - try to read in a new buffer
  *
  * Returns a code representing an action:
@@ -1128,7 +1184,7 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-static int yy_get_next_buffer (void)
+int yyFlexLexer::yy_get_next_buffer()
 {
     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
 	register char *source = (yytext_ptr);
@@ -1229,7 +1285,7 @@
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
+			yyrestart( yyin  );
 			}
 
 		else
@@ -1254,7 +1310,7 @@
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-    static yy_state_type yy_get_previous_state (void)
+    yy_state_type yyFlexLexer::yy_get_previous_state()
 {
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
@@ -1273,7 +1329,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 79 )
+			if ( yy_current_state >= 83 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -1287,7 +1343,7 @@
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )
 {
 	register int yy_is_jam;
     	register char *yy_cp = (yy_c_buf_p);
@@ -1301,16 +1357,16 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 79 )
+		if ( yy_current_state >= 83 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 78);
+	yy_is_jam = (yy_current_state == 82);
 
 	return yy_is_jam ? 0 : yy_current_state;
 }
 
-    static void yyunput (int c, register char * yy_bp )
+    void yyFlexLexer::yyunput( int c, register char* yy_bp)
 {
 	register char *yy_cp;
     
@@ -1342,18 +1398,16 @@
 
 	*--yy_cp = (char) c;
 
+    if ( c == '\n' ){
+        --yylineno;
+    }
+
 	(yytext_ptr) = yy_bp;
 	(yy_hold_char) = *yy_cp;
 	(yy_c_buf_p) = yy_cp;
 }
 
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
+    int yyFlexLexer::yyinput()
 {
 	int c;
     
@@ -1388,13 +1442,13 @@
 					 */
 
 					/* Reset buffer status. */
-					yyrestart(yyin );
+					yyrestart( yyin );
 
 					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap( ) )
+					if ( yywrap(  ) )
 						return EOF;
 
 					if ( ! (yy_did_buffer_switch_on_eof) )
@@ -1418,34 +1472,37 @@
 	(yy_hold_char) = *++(yy_c_buf_p);
 
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )
+		   
+    yylineno++;
+;
 
 	return c;
 }
-#endif	/* ifndef YY_NO_INPUT */
 
 /** Immediately switch to a different input stream.
  * @param input_file A readable stream.
  * 
  * @note This function does not reset the start condition to @c INITIAL .
  */
-    void yyrestart  (FILE * input_file )
+    void yyFlexLexer::yyrestart( std::istream* input_file )
 {
     
 	if ( ! YY_CURRENT_BUFFER ){
         yyensure_buffer_stack ();
 		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
+            yy_create_buffer( yyin, YY_BUF_SIZE );
 	}
 
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
 }
 
 /** Switch to a different input buffer.
  * @param new_buffer The new input buffer.
  * 
  */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
 {
     
 	/* TODO. We should be able to replace this entire function body
@@ -1466,7 +1523,7 @@
 		}
 
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
@@ -1476,7 +1533,7 @@
 	(yy_did_buffer_switch_on_eof) = 1;
 }
 
-static void yy_load_buffer_state  (void)
+    void yyFlexLexer::yy_load_buffer_state()
 {
     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
@@ -1490,7 +1547,7 @@
  * 
  * @return the allocated buffer state.
  */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )
 {
 	YY_BUFFER_STATE b;
     
@@ -1509,7 +1566,7 @@
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer(b,file );
+	yy_init_buffer( b, file );
 
 	return b;
 }
@@ -1518,7 +1575,7 @@
  * @param b a buffer created with yy_create_buffer()
  * 
  */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
+    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )
 {
     
 	if ( ! b )
@@ -1533,20 +1590,18 @@
 	yyfree((void *) b  );
 }
 
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
+extern "C" int isatty (int );
+
 /* Initializes or reinitializes a buffer.
  * This function is sometimes called more than once on the same buffer,
  * such as during a yyrestart() or at EOF.
  */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream* file )
 
 {
 	int oerrno = errno;
     
-	yy_flush_buffer(b );
+	yy_flush_buffer( b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
@@ -1560,8 +1615,7 @@
         b->yy_bs_column = 0;
     }
 
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
+	b->yy_is_interactive = 0;
 	errno = oerrno;
 }
 
@@ -1569,7 +1623,7 @@
  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
  * 
  */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
+    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )
 {
     	if ( ! b )
 		return;
@@ -1589,7 +1643,7 @@
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
 	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 }
 
 /** Pushes the new state onto the stack. The new state becomes
@@ -1598,7 +1652,7 @@
  *  @param new_buffer The new state.
  *  
  */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+void yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)
 {
     	if (new_buffer == NULL)
 		return;
@@ -1620,7 +1674,7 @@
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
 
 	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 	(yy_did_buffer_switch_on_eof) = 1;
 }
 
@@ -1628,7 +1682,7 @@
  *  The next element becomes the new top.
  *  
  */
-void yypop_buffer_state (void)
+void yyFlexLexer::yypop_buffer_state (void)
 {
     	if (!YY_CURRENT_BUFFER)
 		return;
@@ -1639,7 +1693,7 @@
 		--(yy_buffer_stack_top);
 
 	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		(yy_did_buffer_switch_on_eof) = 1;
 	}
 }
@@ -1647,7 +1701,7 @@
 /* Allocates the stack if it does not exist.
  *  Guarantees space for at least one push.
  */
-static void yyensure_buffer_stack (void)
+void yyFlexLexer::yyensure_buffer_stack(void)
 {
 	int num_to_alloc;
     
@@ -1686,99 +1740,51 @@
 	}
 }
 
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+    void yyFlexLexer::yy_push_state( int new_state )
 {
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
+    	if ( (yy_start_stack_ptr) >= (yy_start_stack_depth) )
+		{
+		yy_size_t new_size;
 
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+		(yy_start_stack_depth) += YY_START_STACK_INCR;
+		new_size = (yy_start_stack_depth) * sizeof( int );
 
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
+		if ( ! (yy_start_stack) )
+			(yy_start_stack) = (int *) yyalloc(new_size  );
 
-	yy_switch_to_buffer(b  );
+		else
+			(yy_start_stack) = (int *) yyrealloc((void *) (yy_start_stack),new_size  );
 
-	return b;
-}
+		if ( ! (yy_start_stack) )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
 
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,strlen(yystr) );
+	(yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;
+
+	BEGIN(new_state);
 }
 
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+    void yyFlexLexer::yy_pop_state()
 {
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
+    	if ( --(yy_start_stack_ptr) < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
 
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
+	BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
+}
 
-	return b;
+    int yyFlexLexer::yy_top_state()
+{
+    	return (yy_start_stack)[(yy_start_stack_ptr) - 1];
 }
 
 #ifndef YY_EXIT_FAILURE
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yy_fatal_error (yyconst char* msg )
+void yyFlexLexer::LexerError( yyconst char msg[] )
 {
-    	(void) fprintf( stderr, "%s\n", msg );
+    	std::cerr << msg << std::endl;
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -1801,119 +1807,12 @@
 
 /* Accessor  methods (get/set functions) to struct members. */
 
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
-
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
+yyFlexLexer::~yyFlexLexer()
 {
     
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
 		YY_CURRENT_BUFFER_LVALUE = NULL;
 		yypop_buffer_state();
 	}
@@ -1922,11 +1821,9 @@
 	yyfree((yy_buffer_stack) );
 	(yy_buffer_stack) = NULL;
 
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
+	delete [] (yy_state_buf);
+	yyfree((yy_start_stack)  );
 
-    return 0;
 }
 
 /*
@@ -1977,7 +1874,26 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 123 "qmake.ll"
+#line 201 "qmake.ll"
 
 
+namespace QMake
+{
+    Lexer::Lexer( std::istream* argin, std::ostream* argout )
+        : yyFlexLexer(argin, argout), mylval(0)
+    {
+    }
+
+    int Lexer::yylex( QMake::Parser::semantic_type* yylval )
+    {
+        mylval = yylval;
+        return yylex();
+    }
+}
+
+int QMakelex( QMake::Parser::semantic_type* yylval, QMake::Lexer* lexer)
+{
+    return lexer->yylex( yylval );
+}
+
 
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake_lex.h kdev_3.4.0/buildtools/lib/parsers/qmake/qmake_lex.h
--- buildtools/lib/parsers/qmake/qmake_lex.h	1970-01-01 01:00:00.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake_lex.h	2007-02-07 20:35:12.000000000 +0100
@@ -0,0 +1,45 @@
+/* KDevelop QMake Support
+ *
+ * Copyright 2007 Andreas Pakulat <apaku@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ */
+#ifndef QMAKE_LEX_H
+#define QMAKE_LEX_H
+
+#include "qmake_yacc.hpp"
+#include <iostream>
+
+#ifndef DONT_INCLUDE_FLEXLEXER
+#include "FlexLexer.h"
+#endif
+
+namespace QMake
+{
+    class Lexer : public yyFlexLexer
+    {
+        public:
+            Lexer( std::istream* argin = 0, std::ostream* argout = 0 );
+            int yylex( QMake::Parser::semantic_type* yylval );
+            int yylex();
+        private:
+            QMake::Parser::semantic_type* mylval;
+    };
+}
+
+#endif
+
+// kate: space-indent on; indent-width 4; tab-width: 4; replace-tabs on; auto-insert-doxygen on
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake.ll kdev_3.4.0/buildtools/lib/parsers/qmake/qmake.ll
--- buildtools/lib/parsers/qmake/qmake.ll	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake.ll	2007-02-07 20:35:16.000000000 +0100
@@ -19,9 +19,12 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#include <qmake_yacc.h>
 #include <stdlib.h>
 
+#define DONT_INCLUDE_FLEXLEXER
+
+#include "qmake_lex.h"
+
 /**
 @file qmake.ll
 QMake Lexer
@@ -48,6 +51,9 @@
 %}
 
 %option noyywrap
+%option yylineno
+%option c++
+%option yyclass="QMake::Lexer"
 
 %x list
 %x list_with_comment
@@ -55,69 +61,160 @@
 
 delim             [ \t]
 ws                {delim}+
-begin_ws          ^{delim}+[^\n\t ]
+begin_ws          ^{delim}+[^\r\n\t ]
 quote             "\""
-var_value         [^\n\t ]*[^\n\t \\]
+var_value         [^\r\n\t ]*[^\r\n\t \\]
 quoted_var_value  {quote}({var_value}|[\t ])({var_value}|[\t ])*{quote}
 letter            [A-Za-z]
 digit             [0-9]
 id_simple         ({digit}|{letter}|\!|-|_|\*|\$)({letter}|{digit}|\||\!|-|_|\*|\$|\.|\+|\-)*
-id_args           [^\n]*\)
+id_args           [^\r\n]*\)
 number            {digit}+
 comment           #.*
-comment_cont      {ws}*#.*\n
+comment_cont      {ws}*#.*(\n|\r|\r\n)
 comment_cont_nn   {ws}*#.*
-cont              \\{ws}*\n
+cont              \\{ws}*(\n|\r|\r\n)
 
 %%
-<INITIAL>{ws}  {}
-<list,list_with_comment>{ws}     { yylval.value = yytext; return LIST_WS; }
-<list,list_with_comment>{begin_ws}       { 
-    yylval.value = yytext;
-    unput(char(yylval.value.at(yylval.value.length()-1).latin1()));
-    yylval.value = yylval.value.mid(0, yylval.value.length()-1);
-    return INDENT;
+<INITIAL>{ws} {}
+
+<list,list_with_comment>{ws} {
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::LIST_WS;
 }
 
-<list,list_with_comment,INITIAL>{cont}   { BEGIN(list); return CONT; }
-{id_simple}            { yylval.value = yytext; return (ID_SIMPLE); }
+<list,list_with_comment>{begin_ws} {
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    unput(char(mylval->value.at(mylval->value.length()-1).latin1()));
+    mylval->value = mylval->value.mid(0, mylval->value.length()-1);
+    return Parser::token::token::INDENT;
+}
+
+<list,list_with_comment,INITIAL>{cont} {
+    BEGIN(list);
+    return Parser::token::token::CONT;
+}
+{id_simple} {
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return (Parser::token::token::ID_SIMPLE);
+}
 
 <list_with_comment>{comment_cont_nn} {
-    yylval.value = yytext;
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
     BEGIN(list);
-    return (LIST_COMMENT_WITHOUT_NEWLINE);
+    return (Parser::token::token::LIST_COMMENT_WITHOUT_NEWLINE);
 }
 
 <list>{comment_cont} {
-    yylval.value = yytext;
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
     BEGIN(list);
-    return (LIST_COMMENT);
+    return (Parser::token::token::LIST_COMMENT);
     }
 
 <funcargs>{id_args} {
-    yylval.value = yytext;
-    yylval.value = yylval.value.mid(0, yylval.value.length()-1);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    mylval->value = mylval->value.mid(0, mylval->value.length()-1);
     unput(')');
     BEGIN(INITIAL);
-    return (ID_ARGS);
+    return (Parser::token::token::ID_ARGS);
     }
 
-<list,list_with_comment>{var_value}        { BEGIN(list_with_comment); yylval.value = yytext; return VARIABLE_VALUE; }
-<list,list_with_comment>{quoted_var_value} { BEGIN(list_with_comment); yylval.value = yytext; return QUOTED_VARIABLE_VALUE; }
+<list,list_with_comment>{var_value} {
+    BEGIN(list_with_comment);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::VARIABLE_VALUE;
+}
+
+<list,list_with_comment>{quoted_var_value} {
+    BEGIN(list_with_comment);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::QUOTED_VARIABLE_VALUE;
+}
+
+"=" {
+BEGIN(list);
+mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+return Parser::token::token::EQ;
+}
+
+"+=" {
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::PLUSEQ;
+}
+
+"-=" {
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::MINUSEQ;
+}
+
+"*=" {
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::STAREQ;
+}
+
+"~=" {
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::TILDEEQ;
+}
+
+"{" {
+    return Parser::token::token::LCURLY;
+}
+
+":"{delim}*"{" {
+    return Parser::token::token::LCURLY;
+}
+
+"}" {
+    return Parser::token::token::RCURLY;
+}
+
+"(" {
+    BEGIN(funcargs);
+    return Parser::token::token::LBRACE;
+}
+
+<funcargs,INITIAL>")" {
+    BEGIN(INITIAL);
+    return Parser::token::token::RBRACE;
+}
+
+":" {
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::COLON;
+}
 
-"="                      { BEGIN(list); yylval.value = yytext; return EQ; }
-"+="                     { BEGIN(list); yylval.value = yytext; return PLUSEQ; }
-"-="                     { BEGIN(list); yylval.value = yytext; return MINUSQE; }
-"*="                     { BEGIN(list); yylval.value = yytext; return STAREQ; }
-"~="                     { BEGIN(list); yylval.value = yytext; return TILDEEQ; }
-"{"                      { return LCURLY; }
-":"{delim}*"{"                      { return LCURLY; }
-"}"                      { return RCURLY; }
-"("                      { BEGIN(funcargs); return LBRACE; }
-<funcargs,INITIAL>")"    { BEGIN(INITIAL); return RBRACE; }
-":"                      { yylval.value = yytext; return COLON; }
-<list,list_with_comment,INITIAL>"\n"       { BEGIN(INITIAL); return NEWLINE; }
+<list,list_with_comment,INITIAL>"\n" {
+    BEGIN(INITIAL);
+    return Parser::token::token::NEWLINE;
+}
 
-{comment}                { yylval.value = yytext; return (COMMENT); }
+{comment} {
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return (Parser::token::token::COMMENT);
+}
 
 %%
+namespace QMake
+{
+    Lexer::Lexer( std::istream* argin, std::ostream* argout )
+        : yyFlexLexer(argin, argout), mylval(0)
+    {
+    }
+
+    int Lexer::yylex( QMake::Parser::semantic_type* yylval )
+    {
+        mylval = yylval;
+        return yylex();
+    }
+}
+
+int QMakelex( QMake::Parser::semantic_type* yylval, QMake::Lexer* lexer)
+{
+    return lexer->yylex( yylval );
+}
+
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake_yacc.cpp kdev_3.4.0/buildtools/lib/parsers/qmake/qmake_yacc.cpp
--- buildtools/lib/parsers/qmake/qmake_yacc.cpp	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake_yacc.cpp	2007-02-07 20:35:19.000000000 +0100
@@ -1,9 +1,8 @@
 /* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton implementation for Bison's Yacc-like parsers in C
+/* Skeleton implementation for Bison LALR(1) parsers in C++
 
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -33,1476 +32,363 @@
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
+// Take the name prefix into account.
+#define yylex   QMakelex
 
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "2.3"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
+#include "qmake_yacc.hpp"
 
+/* User implementation prologue.  */
 
 
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     ID_SIMPLE = 258,
-     EQ = 259,
-     PLUSEQ = 260,
-     MINUSQE = 261,
-     STAREQ = 262,
-     TILDEEQ = 263,
-     LBRACE = 264,
-     RBRACE = 265,
-     COLON = 266,
-     NUMSIGN = 267,
-     NEWLINE = 268,
-     NUMBER = 269,
-     COMMENT = 270,
-     CONT = 271,
-     RCURLY = 272,
-     LCURLY = 273,
-     ID_ARGS = 274,
-     LIST_COMMENT = 275,
-     LIST_COMMENT_WITHOUT_NEWLINE = 276,
-     QUOTED_VARIABLE_VALUE = 277,
-     VARIABLE_VALUE = 278,
-     INDENT = 279,
-     LIST_WS = 280
-   };
-#endif
-/* Tokens.  */
-#define ID_SIMPLE 258
-#define EQ 259
-#define PLUSEQ 260
-#define MINUSQE 261
-#define STAREQ 262
-#define TILDEEQ 263
-#define LBRACE 264
-#define RBRACE 265
-#define COLON 266
-#define NUMSIGN 267
-#define NEWLINE 268
-#define NUMBER 269
-#define COMMENT 270
-#define CONT 271
-#define RCURLY 272
-#define LCURLY 273
-#define ID_ARGS 274
-#define LIST_COMMENT 275
-#define LIST_COMMENT_WITHOUT_NEWLINE 276
-#define QUOTED_VARIABLE_VALUE 277
-#define VARIABLE_VALUE 278
-#define INDENT 279
-#define LIST_WS 280
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "qmake.yy"
-
-/***************************************************************************
- *   Copyright (C) 2005 by Alexander Dymo                                  *
- *   adymo@kdevelop.org                                                    *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU Library General Public License as       *
- *   published by the Free Software Foundation; either version 2 of the    *
- *   License, or (at your option) any later version.                       *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU Library General Public     *
- *   License along with this program; if not, write to the                 *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/**
-@file qmake.yy
-QMake Parser
-
-Simple LALR parser which builds the syntax tree (see @ref QMake::AST).
-
-@todo Recognize comments after statements like:
-SOURCES = foo #regognize me
-
-@fixme Parser fails on files that do not end with a newline
-@fixme 1 shift/reduce conflict in "line_body" rule
-*/
-
-#include <qvaluestack.h>
-#include "qmakeast.h"
-#include <qregexp.h>
-
-#define YYSTYPE_IS_DECLARED
-
-using namespace QMake;
-
-/**
-The yylval type.
-*/
-struct Result {
-    Result(): node(0) {}
-
-    /**Type of semantic value for simple grammar rules.*/
-    QString value;
-    /**Type of semantic value for grammar rules which are parts of AST.*/
-    AST *node;
-    /**Type of semantic value for "multiline_values" grammar rule.
-    Each line of multiline value is stored as a string in the list.
-
-    For example we have in .pro file:
-    @code
-    SOURCE = foo1.cpp \
-        foo2.cpp \
-        foo3.cpp foo4.cpp
-    @endcode
-    The string list will be populated with three strings:
-    <pre>
-    foo1.cpp
-    foo2.cpp
-    foo3.cpp foo4.cpp
-    </pre>
-    */
-    QStringList values;
-    QString indent;
-};
-
-typedef Result YYSTYPE;
-
-void yyerror(const char *str) {
-    printf("%s\n", str);
-}
-
-int yylex();
-
-/**
-The stack to store ProjectAST pointers when a new child
-ProjectAST is created and filled with statements.
-
-Parser creates root ProjectAST for a .pro file, pushes it onto the stack and starts
-adding statements. Each statement is added as a child StatementAST to the ProjectAST
-currently on the top in the stack.
-
-When a scope or function scope statement is parsed, the child ProjectAST is created
-and pushed onto the stack. Therefore all statements which belong to the scope
-or function scope are added as childs to their direct parent (scope or function scope).
-*/
-QValueStack<ProjectAST*> projects;
-
-/**
-The current depth of AST node is stored here.
-AST depth is important to know because automatic indentation can
-be easily implemented (the parser itself looses all information
-about indentation).
-*/
-int depth = 0;
-
-/*
-To debug this parser, put the line below into the next bison file section.
-Don't forget to uncomment "yydebug = 1" line in qmakedriver.cpp.
-%debug
-*/
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef int YYSTYPE;
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 216 of yacc.c.  */
-#line 265 "qmake_yacc.cpp"
-
-#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#elif (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-typedef signed char yytype_int8;
-#else
-typedef short int yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short int yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short int yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned int
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+/* Line 317 of lalr1.cc.  */
+#line 45 "qmake_yacc.cpp"
 
 #ifndef YY_
 # if YYENABLE_NLS
 #  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   include <libintl.h> /* FIXME: INFRINGES ON USER NAME SPACE */
 #   define YY_(msgid) dgettext ("bison-runtime", msgid)
 #  endif
 # endif
 # ifndef YY_
 #  define YY_(msgid) msgid
 # endif
-#endif
-
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(e) ((void) (e))
-#else
-# define YYUSE(e) /* empty */
-#endif
-
-/* Identity function, used to suppress warnings about constant conditions.  */
-#ifndef lint
-# define YYID(n) (n)
-#else
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static int
-YYID (int i)
-#else
-static int
-YYID (i)
-    int i;
-#endif
-{
-  return i;
-}
-#endif
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef _STDLIB_H
-#      define _STDLIB_H 1
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined _STDLIB_H \
-       && ! ((defined YYMALLOC || defined malloc) \
-	     && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef _STDLIB_H
-#    define _STDLIB_H 1
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (YYID (0))
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  3
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   37
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  27
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  21
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  44
-/* YYNRULES -- Number of states.  */
-#define YYNSTATES  54
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   281
-
-#define YYTRANSLATE(YYX)						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const yytype_uint8 yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const yytype_uint8 yyprhs[] =
-{
-       0,     0,     3,     4,     7,    10,    11,    13,    15,    17,
-      19,    21,    25,    29,    30,    33,    35,    37,    39,    41,
-      43,    45,    47,    49,    50,    52,    54,    56,    58,    60,
-      62,    64,    65,    69,    70,    78,    80,    81,    85,    88,
-      89,    90,    96,    97,   100
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
-static const yytype_int8 yyrhs[] =
-{
-      28,     0,    -1,    -1,    29,    30,    -1,    30,    31,    -1,
-      -1,    32,    -1,    38,    -1,    40,    -1,    46,    -1,    47,
-      -1,     3,    37,    33,    -1,    33,    34,    35,    -1,    -1,
-      34,    36,    -1,    36,    -1,    16,    -1,    13,    -1,    25,
-      -1,    24,    -1,    20,    -1,    10,    -1,    21,    -1,    -1,
-      23,    -1,    22,    -1,     4,    -1,     5,    -1,     6,    -1,
-       7,    -1,     8,    -1,    -1,     3,    39,    43,    -1,    -1,
-       3,     9,    42,    10,    41,    43,    44,    -1,    19,    -1,
-      -1,    18,    30,    17,    -1,    11,    31,    -1,    -1,    -1,
-      26,    18,    45,    43,    17,    -1,    -1,    15,    13,    -1,
-      13,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
-{
-       0,   136,   136,   136,   143,   148,   151,   155,   159,   163,
-     167,   173,   185,   193,   200,   201,   202,   203,   204,   205,
-     211,   212,   215,   222,   227,   228,   231,   231,   231,   231,
-     231,   235,   234,   249,   248,   273,   274,   277,   278,   283,
-     287,   286,   300,   305,   313
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "ID_SIMPLE", "EQ", "PLUSEQ", "MINUSQE",
-  "STAREQ", "TILDEEQ", "LBRACE", "RBRACE", "COLON", "NUMSIGN", "NEWLINE",
-  "NUMBER", "COMMENT", "CONT", "RCURLY", "LCURLY", "ID_ARGS",
-  "LIST_COMMENT", "LIST_COMMENT_WITHOUT_NEWLINE", "QUOTED_VARIABLE_VALUE",
-  "VARIABLE_VALUE", "INDENT", "LIST_WS", "\"else\"", "$accept", "project",
-  "@1", "statements", "statement", "variable_assignment",
-  "multiline_values", "line_body", "opt_comment", "variable_value",
-  "operator", "scope", "@2", "function_call", "@3", "function_args",
-  "scope_body", "else_statement", "@4", "comment", "emptyline", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const yytype_uint16 yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    27,    29,    28,    30,    30,    31,    31,    31,    31,
-      31,    32,    33,    33,    34,    34,    34,    34,    34,    34,
-      34,    34,    35,    35,    36,    36,    37,    37,    37,    37,
-      37,    39,    38,    41,    40,    42,    42,    43,    43,    43,
-      45,    44,    44,    46,    47
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
-{
-       0,     2,     0,     2,     2,     0,     1,     1,     1,     1,
-       1,     3,     3,     0,     2,     1,     1,     1,     1,     1,
-       1,     1,     1,     0,     1,     1,     1,     1,     1,     1,
-       1,     0,     3,     0,     7,     1,     0,     3,     2,     0,
-       0,     5,     0,     2,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const yytype_uint8 yydefact[] =
-{
-       2,     0,     5,     1,     3,    31,    44,     0,     4,     6,
-       7,     8,     9,    10,    26,    27,    28,    29,    30,    36,
-      13,    39,    43,    35,     0,    11,     0,     5,    32,    33,
-      21,    17,    16,    20,    25,    24,    19,    18,    23,    15,
-      38,     0,    39,    22,    12,    14,    37,    42,     0,    34,
-      40,    39,     0,    41
-};
-
-/* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int8 yydefgoto[] =
-{
-      -1,     1,     2,     4,     8,     9,    25,    38,    44,    39,
-      20,    10,    21,    11,    42,    24,    28,    49,    51,    12,
-      13
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -41
-static const yytype_int8 yypact[] =
-{
-     -41,     1,   -41,   -41,     5,    18,   -41,    -9,   -41,   -41,
-     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -14,
-     -41,    -2,   -41,   -41,    21,   -10,     5,   -41,   -41,   -41,
-     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,     7,   -41,
-     -41,     4,    -2,   -41,   -41,   -41,   -41,     6,    15,   -41,
-     -41,    -2,    17,   -41
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
-{
-     -41,   -41,   -41,     8,    10,   -41,   -41,   -41,   -41,    -1,
-     -41,   -41,   -41,   -41,   -41,   -41,   -40,   -41,   -41,   -41,
-     -41
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1
-static const yytype_uint8 yytable[] =
-{
-      30,     3,    47,    31,    22,    23,    32,     5,     5,    26,
-      33,    52,    34,    35,    36,    37,    27,     6,     6,     7,
-       7,    46,    14,    15,    16,    17,    18,    19,    43,    34,
-      35,    29,    48,    50,    53,    41,    40,    45
-};
-
-static const yytype_uint8 yycheck[] =
-{
-      10,     0,    42,    13,    13,    19,    16,     3,     3,    11,
-      20,    51,    22,    23,    24,    25,    18,    13,    13,    15,
-      15,    17,     4,     5,     6,     7,     8,     9,    21,    22,
-      23,    10,    26,    18,    17,    27,    26,    38
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
-{
-       0,    28,    29,     0,    30,     3,    13,    15,    31,    32,
-      38,    40,    46,    47,     4,     5,     6,     7,     8,     9,
-      37,    39,    13,    19,    42,    33,    11,    18,    43,    10,
-      10,    13,    16,    20,    22,    23,    24,    25,    34,    36,
-      31,    30,    41,    21,    35,    36,    17,    43,    26,    44,
-      18,    45,    43,    17
-};
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK (1);						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (YYID (0))
-
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (YYID (N))                                                    \
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
-    while (YYID (0))
-#endif
-
-
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
-
-#ifndef YY_LOCATION_PRINT
-# if YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-	      (Loc).first_line, (Loc).first_column,	\
-	      (Loc).last_line,  (Loc).last_column)
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (YYID (0))
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
-do {									  \
-  if (yydebug)								  \
-    {									  \
-      YYFPRINTF (stderr, "%s ", Title);					  \
-      yy_symbol_print (stderr,						  \
-		  Type, Value); \
-      YYFPRINTF (stderr, "\n");						  \
-    }									  \
-} while (YYID (0))
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_value_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# else
-  YYUSE (yyoutput);
-# endif
-  switch (yytype)
-    {
-      default:
-	break;
-    }
-}
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
-}
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (YYID (0))
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
-#else
-static void
-yy_reduce_print (yyvsp, yyrule)
-    YYSTYPE *yyvsp;
-    int yyrule;
-#endif
-{
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-	     yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      fprintf (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
-		       &(yyvsp[(yyi + 1) - (yynrhs)])
-		       		       );
-      fprintf (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (yyvsp, Rule); \
-} while (YYID (0))
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static YYSIZE_T
-yystrlen (const char *yystr)
-#else
-static YYSIZE_T
-yystrlen (yystr)
-    const char *yystr;
-#endif
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-#else
-static char *
-yystpcpy (yydest, yysrc)
-    char *yydest;
-    const char *yysrc;
-#endif
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into YYRESULT an error message about the unexpected token
-   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
-   including the terminating null byte.  If YYRESULT is null, do not
-   copy anything; just return the number of bytes that would be
-   copied.  As a special case, return 0 if an ordinary "syntax error"
-   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
-   size calculation.  */
-static YYSIZE_T
-yysyntax_error (char *yyresult, int yystate, int yychar)
-{
-  int yyn = yypact[yystate];
-
-  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
-    return 0;
-  else
-    {
-      int yytype = YYTRANSLATE (yychar);
-      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-      YYSIZE_T yysize = yysize0;
-      YYSIZE_T yysize1;
-      int yysize_overflow = 0;
-      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-      int yyx;
-
-# if 0
-      /* This is so xgettext sees the translatable formats that are
-	 constructed on the fly.  */
-      YY_("syntax error, unexpected %s");
-      YY_("syntax error, unexpected %s, expecting %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-# endif
-      char *yyfmt;
-      char const *yyf;
-      static char const yyunexpected[] = "syntax error, unexpected %s";
-      static char const yyexpecting[] = ", expecting %s";
-      static char const yyor[] = " or %s";
-      char yyformat[sizeof yyunexpected
-		    + sizeof yyexpecting - 1
-		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-		       * (sizeof yyor - 1))];
-      char const *yyprefix = yyexpecting;
-
-      /* Start YYX at -YYN if negative to avoid negative indexes in
-	 YYCHECK.  */
-      int yyxbegin = yyn < 0 ? -yyn : 0;
-
-      /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn + 1;
-      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-      int yycount = 1;
-
-      yyarg[0] = yytname[yytype];
-      yyfmt = yystpcpy (yyformat, yyunexpected);
-
-      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	  {
-	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-	      {
-		yycount = 1;
-		yysize = yysize0;
-		yyformat[sizeof yyunexpected - 1] = '\0';
-		break;
-	      }
-	    yyarg[yycount++] = yytname[yyx];
-	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-	    yysize_overflow |= (yysize1 < yysize);
-	    yysize = yysize1;
-	    yyfmt = yystpcpy (yyfmt, yyprefix);
-	    yyprefix = yyor;
-	  }
-
-      yyf = YY_(yyformat);
-      yysize1 = yysize + yystrlen (yyf);
-      yysize_overflow |= (yysize1 < yysize);
-      yysize = yysize1;
-
-      if (yysize_overflow)
-	return YYSIZE_MAXIMUM;
-
-      if (yyresult)
-	{
-	  /* Avoid sprintf, as that infringes on the user's name space.
-	     Don't have undefined behavior even if the translation
-	     produced a string with the wrong number of "%s"s.  */
-	  char *yyp = yyresult;
-	  int yyi = 0;
-	  while ((*yyp = *yyf) != '\0')
-	    {
-	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		{
-		  yyp += yytnamerr (yyp, yyarg[yyi++]);
-		  yyf += 2;
-		}
-	      else
-		{
-		  yyp++;
-		  yyf++;
-		}
-	    }
-	}
-      return yysize;
-    }
-}
-#endif /* YYERROR_VERBOSE */
-
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  YYUSE (yyvaluep);
-
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  switch (yytype)
-    {
-
-      default:
-	break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void *YYPARSE_PARAM);
-#else
-int yyparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The look-ahead symbol.  */
-int yychar;
-
-/* The semantic value of the look-ahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
+#endif
 
+/* Suppress unused-variable warnings by "using" E.  */
+#define YYUSE(e) ((void) (e))
 
-/*----------.
-| yyparse.  |
-`----------*/
+/* A pseudo ostream that takes yydebug_ into account.  */
+# define YYCDEBUG							\
+  for (bool yydebugcond_ = yydebug_; yydebugcond_; yydebugcond_ = false)	\
+    (*yycdebug_)
 
-#ifdef YYPARSE_PARAM
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void *YYPARSE_PARAM)
-#else
-int
-yyparse (YYPARSE_PARAM)
-    void *YYPARSE_PARAM;
-#endif
-#else /* ! YYPARSE_PARAM */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void)
-#else
-int
-yyparse ()
+/* Enable debugging if requested.  */
+#if YYDEBUG
 
-#endif
-#endif
-{
-  
-  int yystate;
-  int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)	\
+do {							\
+  if (yydebug_)						\
+    {							\
+      *yycdebug_ << Title << ' ';			\
+      yy_symbol_print_ ((Type), (Value), (Location));	\
+      *yycdebug_ << std::endl;				\
+    }							\
+} while (false)
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug_)				\
+    yy_reduce_print_ (Rule);		\
+} while (false)
 
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
+# define YY_STACK_PRINT()		\
+do {					\
+  if (yydebug_)				\
+    yystack_print_ ();			\
+} while (false)
 
-  /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
+#else /* !YYDEBUG */
 
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_REDUCE_PRINT(Rule)
+# define YY_STACK_PRINT()
 
+#endif /* !YYDEBUG */
 
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
 
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+namespace QMake
+{
+#if YYERROR_VERBOSE
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+  /* Return YYSTR after stripping away unnecessary quotes and
+     backslashes, so that it's suitable for yyerror.  The heuristic is
+     that double-quoting is unnecessary unless the string contains an
+     apostrophe, a comma, or backslash (other than backslash-backslash).
+     YYSTR is taken from yytname.  */
+  std::string
+  Parser::yytnamerr_ (const char *yystr)
+  {
+    if (*yystr == '"')
+      {
+        std::string yyr = "";
+        char const *yyp = yystr;
 
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
+        for (;;)
+          switch (*++yyp)
+            {
+            case '\'':
+            case ',':
+              goto do_not_strip_quotes;
+
+            case '\\':
+              if (*++yyp != '\\')
+                goto do_not_strip_quotes;
+              /* Fall through.  */
+            default:
+              yyr += *yyp;
+              break;
 
+            case '"':
+              return yyr;
+            }
+      do_not_strip_quotes: ;
+      }
 
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
+    return yystr;
+  }
 
-  YYDPRINTF ((stderr, "Starting parse\n"));
+#endif
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  /// Build a parser object.
+  Parser::Parser (QMake::Lexer* lexer_yyarg, QValueStack<ProjectAST*>& projects_yyarg, int depth_yyarg)
+    : yydebug_ (false),
+      yycdebug_ (&std::cerr),
+      lexer (lexer_yyarg),
+      projects (projects_yyarg),
+      depth (depth_yyarg)
+  {
+  }
+
+  Parser::~Parser ()
+  {
+  }
 
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
+#if YYDEBUG
+  /*--------------------------------.
+  | Print this symbol on YYOUTPUT.  |
+  `--------------------------------*/
+
+  inline void
+  Parser::yy_symbol_value_print_ (int yytype,
+			   const semantic_type* yyvaluep, const location_type* yylocationp)
+  {
+    YYUSE (yylocationp);
+    YYUSE (yyvaluep);
+    switch (yytype)
+      {
+         default:
+	  break;
+      }
+  }
 
-  yyssp = yyss;
-  yyvsp = yyvs;
 
-  goto yysetstate;
+  void
+  Parser::yy_symbol_print_ (int yytype,
+			   const semantic_type* yyvaluep, const location_type* yylocationp)
+  {
+    *yycdebug_ << (yytype < yyntokens_ ? "token" : "nterm")
+	       << ' ' << yytname_[yytype] << " ("
+	       << *yylocationp << ": ";
+    yy_symbol_value_print_ (yytype, yyvaluep, yylocationp);
+    *yycdebug_ << ')';
+  }
+#endif /* ! YYDEBUG */
+
+  void
+  Parser::yydestruct_ (const char* yymsg,
+			   int yytype, semantic_type* yyvaluep, location_type* yylocationp)
+  {
+    YYUSE (yylocationp);
+    YYUSE (yymsg);
+    YYUSE (yyvaluep);
 
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
+    YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
- yysetstate:
-  *yyssp = yystate;
+    switch (yytype)
+      {
+  
+	default:
+	  break;
+      }
+  }
 
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+  void
+  Parser::yypop_ (unsigned int n)
+  {
+    yystate_stack_.pop (n);
+    yysemantic_stack_.pop (n);
+    yylocation_stack_.pop (n);
+  }
+
+  std::ostream&
+  Parser::debug_stream () const
+  {
+    return *yycdebug_;
+  }
+
+  void
+  Parser::set_debug_stream (std::ostream& o)
+  {
+    yycdebug_ = &o;
+  }
+
+
+  Parser::debug_level_type
+  Parser::debug_level () const
+  {
+    return yydebug_;
+  }
+
+  void
+  Parser::set_debug_level (debug_level_type l)
+  {
+    yydebug_ = l;
+  }
+
+
+  int
+  Parser::parse ()
+  {
+    /// Look-ahead and look-ahead in internal form.
+    int yychar = yyempty_;
+    int yytoken = 0;
+
+    /* State.  */
+    int yyn;
+    int yylen = 0;
+    int yystate = 0;
+
+    /* Error handling.  */
+    int yynerrs_ = 0;
+    int yyerrstatus_ = 0;
+
+    /// Semantic value of the look-ahead.
+    semantic_type yylval;
+    /// Location of the look-ahead.
+    location_type yylloc;
+    /// The locations where the error started and ended.
+    location yyerror_range[2];
+
+    /// $$.
+    semantic_type yyval;
+    /// @$.
+    location_type yyloc;
+
+    int yyresult;
+
+    YYCDEBUG << "Starting parse" << std::endl;
+
+
+    /* Initialize the stacks.  The initial state will be pushed in
+       yynewstate, since the latter expects the semantical and the
+       location values to have been already stored, initialize these
+       stacks with a primary value.  */
+    yystate_stack_ = state_stack_type (0);
+    yysemantic_stack_ = semantic_stack_type (0);
+    yylocation_stack_ = location_stack_type (0);
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yylloc);
+
+    /* New state.  */
+  yynewstate:
+    yystate_stack_.push (yystate);
+    YYCDEBUG << "Entering state " << yystate << std::endl;
+    goto yybackup;
+
+    /* Backup.  */
+  yybackup:
+
+    /* Try to take a decision without look-ahead.  */
+    yyn = yypact_[yystate];
+    if (yyn == yypact_ninf_)
+      goto yydefault;
 
-#ifdef yyoverflow
+    /* Read a look-ahead token.  */
+    if (yychar == yyempty_)
       {
-	/* Give user a chance to reallocate the stack.  Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	yytype_int16 *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
+	YYCDEBUG << "Reading a token: ";
+	yychar = yylex (&yylval, lexer);
+      }
 
-		    &yystacksize);
 
-	yyss = yyss1;
-	yyvs = yyvs1;
+    /* Convert token to internal form.  */
+    if (yychar <= yyeof_)
+      {
+	yychar = yytoken = yyeof_;
+	YYCDEBUG << "Now at end of input." << std::endl;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
+    else
       {
-	yytype_int16 *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
+	yytoken = yytranslate_ (yychar);
+	YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
       }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
 
-  /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to look-ahead token.  */
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a look-ahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
+    /* If the proper action on seeing token YYTOKEN is to reduce or to
+       detect an error, take that action.  */
+    yyn += yytoken;
+    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yytoken)
+      goto yydefault;
+
+    /* Reduce or error.  */
+    yyn = yytable_[yyn];
+    if (yyn <= 0)
+      {
+	if (yyn == 0 || yyn == yytable_ninf_)
 	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the look-ahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  yystate = yyn;
-  *++yyvsp = yylval;
-
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
+	yyn = -yyn;
+	goto yyreduce;
+      }
 
+    /* Accept?  */
+    if (yyn == yyfinal_)
+      goto yyacceptlab;
+
+    /* Shift the look-ahead token.  */
+    YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+    /* Discard the token being shifted unless it is eof.  */
+    if (yychar != yyeof_)
+      yychar = yyempty_;
+
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yylloc);
+
+    /* Count tokens shifted since error; after three, turn off error
+       status.  */
+    if (yyerrstatus_)
+      --yyerrstatus_;
+
+    yystate = yyn;
+    goto yynewstate;
+
+  /*-----------------------------------------------------------.
+  | yydefault -- do the default action for the current state.  |
+  `-----------------------------------------------------------*/
+  yydefault:
+    yyn = yydefact_[yystate];
+    if (yyn == 0)
+      goto yyerrlab;
+    goto yyreduce;
+
+  /*-----------------------------.
+  | yyreduce -- Do a reduction.  |
+  `-----------------------------*/
+  yyreduce:
+    yylen = yyr2_[yyn];
+    /* If YYLEN is nonzero, implement the default value of the action:
+       `$$ = $1'.  Otherwise, use the top of the stack.
+
+       Otherwise, the following line sets YYVAL to garbage.
+       This behavior is undocumented and Bison
+       users should not rely upon it.  */
+    if (yylen)
+      yyval = yysemantic_stack_[yylen - 1];
+    else
+      yyval = yysemantic_stack_[0];
 
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
     {
-        case 2:
-#line 136 "qmake.yy"
+      slice<location_type, location_stack_type> slice (yylocation_stack_, yylen);
+      YYLLOC_DEFAULT (yyloc, slice, yylen);
+    }
+    YY_REDUCE_PRINT (yyn);
+    switch (yyn)
+      {
+	  case 2:
+#line 147 "qmake.yy"
     {
         ProjectAST *projectAST = new ProjectAST();
         projects.push(projectAST);
@@ -1510,73 +396,73 @@
     break;
 
   case 4:
-#line 144 "qmake.yy"
+#line 155 "qmake.yy"
     {
-            projects.top()->addChildAST((yyvsp[(2) - (2)].node));
-            (yyvsp[(2) - (2)].node)->setDepth(depth);
+            projects.top()->addChildAST((yysemantic_stack_[(2) - (2)].node));
+            (yysemantic_stack_[(2) - (2)].node)->setDepth(depth);
         ;}
     break;
 
   case 6:
-#line 152 "qmake.yy"
+#line 163 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 7:
-#line 156 "qmake.yy"
+#line 167 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 8:
-#line 160 "qmake.yy"
+#line 171 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 9:
-#line 164 "qmake.yy"
+#line 175 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 10:
-#line 168 "qmake.yy"
+#line 179 "qmake.yy"
     {
             (yyval.node) = new NewLineAST();
         ;}
     break;
 
   case 11:
-#line 174 "qmake.yy"
+#line 185 "qmake.yy"
     {
             AssignmentAST *node = new AssignmentAST();
-            node->scopedID = (yyvsp[(1) - (3)].value);
-            node->op = (yyvsp[(2) - (3)].value);
-            node->values = (yyvsp[(3) - (3)].values);
-            node->indent = (yyvsp[(3) - (3)].indent);
-	        node->commentnode = (yyvsp[(3) - (3)].node);
+            node->scopedID = (yysemantic_stack_[(3) - (1)].value);
+            node->op = (yysemantic_stack_[(3) - (2)].value);
+            node->values = (yysemantic_stack_[(3) - (3)].values);
+            node->indent = (yysemantic_stack_[(3) - (3)].indent);
+	        node->commentnode = (yysemantic_stack_[(3) - (3)].node);
             (yyval.node) = node;
         ;}
     break;
 
   case 12:
-#line 186 "qmake.yy"
+#line 197 "qmake.yy"
     {
-            (yyval.values) += (yyvsp[(2) - (3)].values);
-            if( (yyvsp[(2) - (3)].indent) != "" && (yyval.indent) == "" )
-                (yyval.indent) = (yyvsp[(2) - (3)].indent);
-            (yyval.node) = (yyvsp[(3) - (3)].node);
+            (yyval.values) += (yysemantic_stack_[(3) - (2)].values);
+            if( (yysemantic_stack_[(3) - (2)].indent) != "" && (yyval.indent) == "" )
+                (yyval.indent) = (yysemantic_stack_[(3) - (2)].indent);
+            (yyval.node) = (yysemantic_stack_[(3) - (3)].node);
         ;}
     break;
 
   case 13:
-#line 193 "qmake.yy"
+#line 204 "qmake.yy"
     {
             (yyval.values).clear();
             (yyval.indent) = "";
@@ -1585,77 +471,77 @@
     break;
 
   case 14:
-#line 200 "qmake.yy"
-    { (yyval.values).append( (yyvsp[(2) - (2)].value) ); ;}
+#line 211 "qmake.yy"
+    { (yyval.values).append( (yysemantic_stack_[(2) - (2)].value) ); ;}
     break;
 
   case 15:
-#line 201 "qmake.yy"
-    { (yyval.values).append( (yyvsp[(1) - (1)].value) ); ;}
+#line 212 "qmake.yy"
+    { (yyval.values).append( (yysemantic_stack_[(1) - (1)].value) ); ;}
     break;
 
   case 16:
-#line 202 "qmake.yy"
+#line 213 "qmake.yy"
     { (yyval.values).append("\\\n"); ;}
     break;
 
   case 17:
-#line 203 "qmake.yy"
+#line 214 "qmake.yy"
     { (yyval.values).append("\n"); ;}
     break;
 
   case 18:
-#line 204 "qmake.yy"
-    { (yyval.values).append((yyvsp[(1) - (1)].value)); ;}
+#line 215 "qmake.yy"
+    { (yyval.values).append((yysemantic_stack_[(1) - (1)].value)); ;}
     break;
 
   case 19:
-#line 206 "qmake.yy"
+#line 217 "qmake.yy"
     {
-            (yyval.values).append((yyvsp[(1) - (1)].value));
-            if( (yyval.indent) == "" && (yyvsp[(1) - (1)].value) != "" )
-                (yyval.indent) = (yyvsp[(1) - (1)].value);
+            (yyval.values).append((yysemantic_stack_[(1) - (1)].value));
+            if( (yyval.indent) == "" && (yysemantic_stack_[(1) - (1)].value) != "" )
+                (yyval.indent) = (yysemantic_stack_[(1) - (1)].value);
         ;}
     break;
 
   case 22:
-#line 216 "qmake.yy"
+#line 227 "qmake.yy"
     {
             CommentAST* node = new CommentAST();
-            node->comment = (yyvsp[(1) - (1)].value) + "\n";
+            node->comment = (yysemantic_stack_[(1) - (1)].value) + "\n";
 	        (yyval.node) = node;
         ;}
     break;
 
   case 23:
-#line 222 "qmake.yy"
+#line 233 "qmake.yy"
     {
             (yyval.node) = 0;
         ;}
     break;
 
   case 24:
-#line 227 "qmake.yy"
-    { (yyval.value) = (yyvsp[(1) - (1)].value); ;}
+#line 238 "qmake.yy"
+    { (yyval.value) = (yysemantic_stack_[(1) - (1)].value); ;}
     break;
 
   case 25:
-#line 228 "qmake.yy"
-    { (yyval.value) = (yyvsp[(1) - (1)].value); ;}
+#line 239 "qmake.yy"
+    { (yyval.value) = (yysemantic_stack_[(1) - (1)].value); ;}
     break;
 
   case 31:
-#line 235 "qmake.yy"
+#line 246 "qmake.yy"
     {
             ProjectAST *projectAST = new ProjectAST(ProjectAST::Scope);
             projects.push(projectAST);
-            projects.top()->scopedID = (yyvsp[(1) - (1)].value);
+            projects.top()->scopedID = (yysemantic_stack_[(1) - (1)].value);
             depth++;
         ;}
     break;
 
   case 32:
-#line 242 "qmake.yy"
+#line 253 "qmake.yy"
     {
             (yyval.node) = projects.pop();
             depth--;
@@ -1663,19 +549,19 @@
     break;
 
   case 33:
-#line 249 "qmake.yy"
+#line 260 "qmake.yy"
     {
             ProjectAST *projectAST = new ProjectAST(ProjectAST::FunctionScope);
             projects.push(projectAST);
-            projects.top()->scopedID = (yyvsp[(1) - (4)].value);
-            projects.top()->args = (yyvsp[(3) - (4)].value);
+            projects.top()->scopedID = (yysemantic_stack_[(4) - (1)].value);
+            projects.top()->args = (yysemantic_stack_[(4) - (3)].value);
             depth++;
 
             //qWarning("%s", $<value>1.ascii());
-            if ((yyvsp[(1) - (4)].value).contains("include"))
+            if ((yysemantic_stack_[(4) - (1)].value).contains("include"))
             {
                 IncludeAST *includeAST = new IncludeAST();
-                includeAST->projectName = (yyvsp[(3) - (4)].value);
+                includeAST->projectName = (yysemantic_stack_[(4) - (3)].value);
                 projects.top()->addChildAST(includeAST);
                 includeAST->setDepth(depth);
             }
@@ -1683,7 +569,7 @@
     break;
 
   case 34:
-#line 267 "qmake.yy"
+#line 278 "qmake.yy"
     {
             (yyval.node) = projects.pop();
             depth--;
@@ -1691,25 +577,25 @@
     break;
 
   case 35:
-#line 273 "qmake.yy"
-    { (yyval.value) = (yyvsp[(1) - (1)].value); ;}
+#line 284 "qmake.yy"
+    { (yyval.value) = (yysemantic_stack_[(1) - (1)].value); ;}
     break;
 
   case 36:
-#line 274 "qmake.yy"
+#line 285 "qmake.yy"
     { (yyval.value) = ""; ;}
     break;
 
   case 38:
-#line 279 "qmake.yy"
+#line 290 "qmake.yy"
     {
-            projects.top()->addChildAST((yyvsp[(2) - (2)].node));
-            (yyvsp[(2) - (2)].node)->setDepth(depth);
+            projects.top()->addChildAST((yysemantic_stack_[(2) - (2)].node));
+            (yysemantic_stack_[(2) - (2)].node)->setDepth(depth);
         ;}
     break;
 
   case 40:
-#line 287 "qmake.yy"
+#line 298 "qmake.yy"
     {
             ProjectAST *projectAST = new ProjectAST(ProjectAST::FunctionScope);
             projects.push(projectAST);
@@ -1720,7 +606,7 @@
     break;
 
   case 41:
-#line 295 "qmake.yy"
+#line 306 "qmake.yy"
     {
             (yyval.node) = projects.pop();
             depth--;
@@ -1728,239 +614,499 @@
     break;
 
   case 42:
-#line 300 "qmake.yy"
+#line 311 "qmake.yy"
     {
             (yyval.node) = new ProjectAST();
         ;}
     break;
 
   case 43:
-#line 306 "qmake.yy"
+#line 317 "qmake.yy"
     {
             CommentAST *node = new CommentAST();
-            node->comment = (yyvsp[(1) - (2)].value) + "\n";
+            node->comment = (yysemantic_stack_[(2) - (1)].value) + "\n";
             (yyval.node) = node;
         ;}
     break;
 
 
-/* Line 1267 of yacc.c.  */
-#line 1749 "qmake_yacc.cpp"
-      default: break;
-    }
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
+    /* Line 675 of lalr1.cc.  */
+#line 635 "qmake_yacc.cpp"
+	default: break;
+      }
+    YY_SYMBOL_PRINT ("-> $$ =", yyr1_[yyn], &yyval, &yyloc);
 
+    yypop_ (yylen);
+    yylen = 0;
+    YY_STACK_PRINT ();
+
+    yysemantic_stack_.push (yyval);
+    yylocation_stack_.push (yyloc);
+
+    /* Shift the result of the reduction.  */
+    yyn = yyr1_[yyn];
+    yystate = yypgoto_[yyn - yyntokens_] + yystate_stack_[0];
+    if (0 <= yystate && yystate <= yylast_
+	&& yycheck_[yystate] == yystate_stack_[0])
+      yystate = yytable_[yystate];
+    else
+      yystate = yydefgoto_[yyn - yyntokens_];
+    goto yynewstate;
+
+  /*------------------------------------.
+  | yyerrlab -- here on detecting error |
+  `------------------------------------*/
+  yyerrlab:
+    /* If not already recovering from an error, report this error.  */
+    if (!yyerrstatus_)
+      {
+	++yynerrs_;
+	error (yylloc, yysyntax_error_ (yystate));
+      }
 
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
-#else
+    yyerror_range[0] = yylloc;
+    if (yyerrstatus_ == 3)
       {
-	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
-	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
-	  {
-	    YYSIZE_T yyalloc = 2 * yysize;
-	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
-	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
-	    if (yymsg != yymsgbuf)
-	      YYSTACK_FREE (yymsg);
-	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
-	    if (yymsg)
-	      yymsg_alloc = yyalloc;
-	    else
-	      {
-		yymsg = yymsgbuf;
-		yymsg_alloc = sizeof yymsgbuf;
-	      }
-	  }
+	/* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
 
-	if (0 < yysize && yysize <= yymsg_alloc)
+	if (yychar <= yyeof_)
 	  {
-	    (void) yysyntax_error (yymsg, yystate, yychar);
-	    yyerror (yymsg);
+	  /* Return failure if at end of input.  */
+	  if (yychar == yyeof_)
+	    YYABORT;
 	  }
 	else
 	  {
-	    yyerror (YY_("syntax error"));
-	    if (yysize != 0)
-	      goto yyexhaustedlab;
+	    yydestruct_ ("Error: discarding", yytoken, &yylval, &yylloc);
+	    yychar = yyempty_;
 	  }
       }
-#endif
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse look-ahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-	{
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
-	}
-      else
-	{
-	  yydestruct ("Error: discarding",
-		      yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
-    }
 
-  /* Else will try to reuse look-ahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
-
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+    /* Else will try to reuse look-ahead token after shifting the error
+       token.  */
+    goto yyerrlab1;
+
+
+  /*---------------------------------------------------.
+  | yyerrorlab -- error raised explicitly by YYERROR.  |
+  `---------------------------------------------------*/
+  yyerrorlab:
+
+    /* Pacify compilers like GCC when the user code never invokes
+       YYERROR and the label yyerrorlab therefore never appears in user
+       code.  */
+    if (false)
+      goto yyerrorlab;
+
+    yyerror_range[0] = yylocation_stack_[yylen - 1];
+    /* Do not reclaim the symbols of the rule which action triggered
+       this YYERROR.  */
+    yypop_ (yylen);
+    yylen = 0;
+    yystate = yystate_stack_[0];
+    goto yyerrlab1;
+
+  /*-------------------------------------------------------------.
+  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+  `-------------------------------------------------------------*/
+  yyerrlab1:
+    yyerrstatus_ = 3;	/* Each real token shifted decrements this.  */
 
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
+    for (;;)
+      {
+	yyn = yypact_[yystate];
+	if (yyn != yypact_ninf_)
 	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	  yyn += yyterror_;
+	  if (0 <= yyn && yyn <= yylast_ && yycheck_[yyn] == yyterror_)
 	    {
-	      yyn = yytable[yyn];
+	      yyn = yytable_[yyn];
 	      if (0 < yyn)
 		break;
 	    }
 	}
 
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
+	/* Pop the current state because it cannot handle the error token.  */
+	if (yystate_stack_.height () == 1)
 	YYABORT;
 
+	yyerror_range[0] = yylocation_stack_[0];
+	yydestruct_ ("Error: popping",
+		     yystos_[yystate],
+		     &yysemantic_stack_[0], &yylocation_stack_[0]);
+	yypop_ ();
+	yystate = yystate_stack_[0];
+	YY_STACK_PRINT ();
+      }
+
+    if (yyn == yyfinal_)
+      goto yyacceptlab;
 
-      yydestruct ("Error: popping",
-		  yystos[yystate], yyvsp);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
+    yyerror_range[1] = yylloc;
+    // Using YYLLOC is tempting, but would change the location of
+    // the look-ahead.  YYLOC is available though.
+    YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yyloc);
+
+    /* Shift the error token.  */
+    YY_SYMBOL_PRINT ("Shifting", yystos_[yyn],
+		   &yysemantic_stack_[0], &yylocation_stack_[0]);
+
+    yystate = yyn;
+    goto yynewstate;
+
+    /* Accept.  */
+  yyacceptlab:
+    yyresult = 0;
+    goto yyreturn;
+
+    /* Abort.  */
+  yyabortlab:
+    yyresult = 1;
+    goto yyreturn;
+
+  yyreturn:
+    if (yychar != yyeof_ && yychar != yyempty_)
+      yydestruct_ ("Cleanup: discarding lookahead", yytoken, &yylval, &yylloc);
+
+    /* Do not reclaim the symbols of the rule which action triggered
+       this YYABORT or YYACCEPT.  */
+    yypop_ (yylen);
+    while (yystate_stack_.height () != 1)
+      {
+	yydestruct_ ("Cleanup: popping",
+		   yystos_[yystate_stack_[0]],
+		   &yysemantic_stack_[0],
+		   &yylocation_stack_[0]);
+	yypop_ ();
+      }
+
+    return yyresult;
+  }
+
+  // Generate an error message.
+  std::string
+  Parser::yysyntax_error_ (int yystate)
+  {
+    std::string res;
+    YYUSE (yystate);
+#if YYERROR_VERBOSE
+    int yyn = yypact_[yystate];
+    if (yypact_ninf_ < yyn && yyn <= yylast_)
+      {
+	/* Start YYX at -YYN if negative to avoid negative indexes in
+	   YYCHECK.  */
+	int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	/* Stay within bounds of both yycheck and yytname.  */
+	int yychecklim = yylast_ - yyn + 1;
+	int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_;
+	int count = 0;
+	for (int x = yyxbegin; x < yyxend; ++x)
+	  if (yycheck_[x + yyn] == x && x != yyterror_)
+	    ++count;
+
+	// FIXME: This method of building the message is not compatible
+	// with internationalization.  It should work like yacc.c does it.
+	// That is, first build a string that looks like this:
+	// "syntax error, unexpected %s or %s or %s"
+	// Then, invoke YY_ on this string.
+	// Finally, use the string as a format to output
+	// yytname_[tok], etc.
+	// Until this gets fixed, this message appears in English only.
+	res = "syntax error, unexpected ";
+	res += yytnamerr_ (yytname_[tok]);
+	if (count < 5)
+	  {
+	    count = 0;
+	    for (int x = yyxbegin; x < yyxend; ++x)
+	      if (yycheck_[x + yyn] == x && x != yyterror_)
+		{
+		  res += (!count++) ? ", expecting " : " or ";
+		  res += yytnamerr_ (yytname_[x]);
+		}
+	  }
+      }
+    else
+#endif
+      res = YY_("syntax error");
+    return res;
+  }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
 
-  *++yyvsp = yylval;
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+  const signed char Parser::yypact_ninf_ = -41;
+  const signed char
+  Parser::yypact_[] =
+  {
+       -41,     1,   -41,   -41,     5,    18,   -41,    -9,   -41,   -41,
+     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -14,
+     -41,    -2,   -41,   -41,    21,   -10,     5,   -41,   -41,   -41,
+     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,     7,   -41,
+     -41,     4,    -2,   -41,   -41,   -41,   -41,     6,    15,   -41,
+     -41,    -2,    17,   -41
+  };
+
+  /* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+     doesn't specify something else to do.  Zero means the default is an
+     error.  */
+  const unsigned char
+  Parser::yydefact_[] =
+  {
+         2,     0,     5,     1,     3,    31,    44,     0,     4,     6,
+       7,     8,     9,    10,    26,    27,    28,    29,    30,    36,
+      13,    39,    43,    35,     0,    11,     0,     5,    32,    33,
+      21,    17,    16,    20,    25,    24,    19,    18,    23,    15,
+      38,     0,    39,    22,    12,    14,    37,    42,     0,    34,
+      40,    39,     0,    41
+  };
 
+  /* YYPGOTO[NTERM-NUM].  */
+  const signed char
+  Parser::yypgoto_[] =
+  {
+       -41,   -41,   -41,     8,    10,   -41,   -41,   -41,   -41,    -1,
+     -41,   -41,   -41,   -41,   -41,   -41,   -40,   -41,   -41,   -41,
+     -41
+  };
 
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  /* YYDEFGOTO[NTERM-NUM].  */
+  const signed char
+  Parser::yydefgoto_[] =
+  {
+        -1,     1,     2,     4,     8,     9,    25,    38,    44,    39,
+      20,    10,    21,    11,    42,    24,    28,    49,    51,    12,
+      13
+  };
 
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
+  /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule which
+     number is the opposite.  If zero, do what YYDEFACT says.  */
+  const signed char Parser::yytable_ninf_ = -1;
+  const unsigned char
+  Parser::yytable_[] =
+  {
+        30,     3,    47,    31,    22,    23,    32,     5,     5,    26,
+      33,    52,    34,    35,    36,    37,    27,     6,     6,     7,
+       7,    46,    14,    15,    16,    17,    18,    19,    43,    34,
+      35,    29,    48,    50,    53,    41,    40,    45
+  };
 
-yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval);
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
+  /* YYCHECK.  */
+  const unsigned char
+  Parser::yycheck_[] =
+  {
+        10,     0,    42,    13,    13,    19,    16,     3,     3,    11,
+      20,    51,    22,    23,    24,    25,    18,    13,    13,    15,
+      15,    17,     4,     5,     6,     7,     8,     9,    21,    22,
+      23,    10,    26,    18,    17,    27,    26,    38
+  };
+
+  /* STOS_[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+  const unsigned char
+  Parser::yystos_[] =
+  {
+         0,    28,    29,     0,    30,     3,    13,    15,    31,    32,
+      38,    40,    46,    47,     4,     5,     6,     7,     8,     9,
+      37,    39,    13,    19,    42,    33,    11,    18,    43,    10,
+      10,    13,    16,    20,    22,    23,    24,    25,    34,    36,
+      31,    30,    41,    21,    35,    36,    17,    43,    26,    44,
+      18,    45,    43,    17
+  };
+
+#if YYDEBUG
+  /* TOKEN_NUMBER_[YYLEX-NUM] -- Internal symbol number corresponding
+     to YYLEX-NUM.  */
+  const unsigned short int
+  Parser::yytoken_number_[] =
+  {
+         0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281
+  };
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+  const unsigned char
+  Parser::yyr1_[] =
+  {
+         0,    27,    29,    28,    30,    30,    31,    31,    31,    31,
+      31,    32,    33,    33,    34,    34,    34,    34,    34,    34,
+      34,    34,    35,    35,    36,    36,    37,    37,    37,    37,
+      37,    39,    38,    41,    40,    42,    42,    43,    43,    43,
+      45,    44,    44,    46,    47
+  };
+
+  /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+  const unsigned char
+  Parser::yyr2_[] =
+  {
+         0,     2,     0,     2,     2,     0,     1,     1,     1,     1,
+       1,     3,     3,     0,     2,     1,     1,     1,     1,     1,
+       1,     1,     1,     0,     1,     1,     1,     1,     1,     1,
+       1,     0,     3,     0,     7,     1,     0,     3,     2,     0,
+       0,     5,     0,     2,     1
+  };
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+  /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+     First, the terminals, then, starting at \a yyntokens_, nonterminals.  */
+  const char*
+  const Parser::yytname_[] =
+  {
+    "$end", "error", "$undefined", "ID_SIMPLE", "EQ", "PLUSEQ", "MINUSEQ",
+  "STAREQ", "TILDEEQ", "LBRACE", "RBRACE", "COLON", "NUMSIGN", "NEWLINE",
+  "NUMBER", "COMMENT", "CONT", "RCURLY", "LCURLY", "ID_ARGS",
+  "LIST_COMMENT", "LIST_COMMENT_WITHOUT_NEWLINE", "QUOTED_VARIABLE_VALUE",
+  "VARIABLE_VALUE", "INDENT", "LIST_WS", "\"else\"", "$accept", "project",
+  "@1", "statements", "statement", "variable_assignment",
+  "multiline_values", "line_body", "opt_comment", "variable_value",
+  "operator", "scope", "@2", "function_call", "@3", "function_args",
+  "scope_body", "else_statement", "@4", "comment", "emptyline", 0
+  };
 #endif
-  /* Make sure YYID is used.  */
-  return YYID (yyresult);
-}
 
+#if YYDEBUG
+  /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+  const Parser::rhs_number_type
+  Parser::yyrhs_[] =
+  {
+        28,     0,    -1,    -1,    29,    30,    -1,    30,    31,    -1,
+      -1,    32,    -1,    38,    -1,    40,    -1,    46,    -1,    47,
+      -1,     3,    37,    33,    -1,    33,    34,    35,    -1,    -1,
+      34,    36,    -1,    36,    -1,    16,    -1,    13,    -1,    25,
+      -1,    24,    -1,    20,    -1,    10,    -1,    21,    -1,    -1,
+      23,    -1,    22,    -1,     4,    -1,     5,    -1,     6,    -1,
+       7,    -1,     8,    -1,    -1,     3,    39,    43,    -1,    -1,
+       3,     9,    42,    10,    41,    43,    44,    -1,    19,    -1,
+      -1,    18,    30,    17,    -1,    11,    31,    -1,    -1,    -1,
+      26,    18,    45,    43,    17,    -1,    -1,    15,    13,    -1,
+      13,    -1
+  };
+
+  /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+     YYRHS.  */
+  const unsigned char
+  Parser::yyprhs_[] =
+  {
+         0,     0,     3,     4,     7,    10,    11,    13,    15,    17,
+      19,    21,    25,    29,    30,    33,    35,    37,    39,    41,
+      43,    45,    47,    49,    50,    52,    54,    56,    58,    60,
+      62,    64,    65,    69,    70,    78,    80,    81,    85,    88,
+      89,    90,    96,    97,   100
+  };
+
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+  const unsigned short int
+  Parser::yyrline_[] =
+  {
+         0,   147,   147,   147,   154,   159,   162,   166,   170,   174,
+     178,   184,   196,   204,   211,   212,   213,   214,   215,   216,
+     222,   223,   226,   233,   238,   239,   242,   242,   242,   242,
+     242,   246,   245,   260,   259,   284,   285,   288,   289,   294,
+     298,   297,   311,   316,   324
+  };
+
+  // Print the state stack on the debug stream.
+  void
+  Parser::yystack_print_ ()
+  {
+    *yycdebug_ << "Stack now";
+    for (state_stack_type::const_iterator i = yystate_stack_.begin ();
+	 i != yystate_stack_.end (); ++i)
+      *yycdebug_ << ' ' << *i;
+    *yycdebug_ << std::endl;
+  }
+
+  // Report on the debug stream that the rule \a yyrule is going to be reduced.
+  void
+  Parser::yy_reduce_print_ (int yyrule)
+  {
+    unsigned int yylno = yyrline_[yyrule];
+    int yynrhs = yyr2_[yyrule];
+    /* Print the symbols being reduced, and their result.  */
+    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
+	       << " (line " << yylno << "), ";
+    /* The symbols being reduced.  */
+    for (int yyi = 0; yyi < yynrhs; yyi++)
+      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
+		       yyrhs_[yyprhs_[yyrule] + yyi],
+		       &(yysemantic_stack_[(yynrhs) - (yyi + 1)]),
+		       &(yylocation_stack_[(yynrhs) - (yyi + 1)]));
+  }
+#endif // YYDEBUG
+
+  /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+  Parser::token_number_type
+  Parser::yytranslate_ (int t)
+  {
+    static
+    const token_number_type
+    translate_table[] =
+    {
+           0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26
+    };
+    if ((unsigned int) t <= yyuser_token_number_max_)
+      return translate_table[t];
+    else
+      return yyundef_token_;
+  }
+
+  const int Parser::yyeof_ = 0;
+  const int Parser::yylast_ = 37;
+  const int Parser::yynnts_ = 21;
+  const int Parser::yyempty_ = -2;
+  const int Parser::yyfinal_ = 3;
+  const int Parser::yyterror_ = 1;
+  const int Parser::yyerrcode_ = 256;
+  const int Parser::yyntokens_ = 27;
+
+  const unsigned int Parser::yyuser_token_number_max_ = 281;
+  const Parser::token_number_type Parser::yyundef_token_ = 2;
+
+} // namespace QMake
+
+#line 327 "qmake.yy"
 
-#line 316 "qmake.yy"
 
 
-#include "qmake_lex.cpp"
+namespace QMake
+{
+    void Parser::error(const location_type& /*l*/, const std::string& m)
+    {
+        std::cerr << m << std::endl;
+    }
+}
 
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake_yacc.h kdev_3.4.0/buildtools/lib/parsers/qmake/qmake_yacc.h
--- buildtools/lib/parsers/qmake/qmake_yacc.h	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake_yacc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,103 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
-
-/* Skeleton interface for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     ID_SIMPLE = 258,
-     EQ = 259,
-     PLUSEQ = 260,
-     MINUSQE = 261,
-     STAREQ = 262,
-     TILDEEQ = 263,
-     LBRACE = 264,
-     RBRACE = 265,
-     COLON = 266,
-     NUMSIGN = 267,
-     NEWLINE = 268,
-     NUMBER = 269,
-     COMMENT = 270,
-     CONT = 271,
-     RCURLY = 272,
-     LCURLY = 273,
-     ID_ARGS = 274,
-     LIST_COMMENT = 275,
-     LIST_COMMENT_WITHOUT_NEWLINE = 276,
-     QUOTED_VARIABLE_VALUE = 277,
-     VARIABLE_VALUE = 278,
-     INDENT = 279,
-     LIST_WS = 280
-   };
-#endif
-/* Tokens.  */
-#define ID_SIMPLE 258
-#define EQ 259
-#define PLUSEQ 260
-#define MINUSQE 261
-#define STAREQ 262
-#define TILDEEQ 263
-#define LBRACE 264
-#define RBRACE 265
-#define COLON 266
-#define NUMSIGN 267
-#define NEWLINE 268
-#define NUMBER 269
-#define COMMENT 270
-#define CONT 271
-#define RCURLY 272
-#define LCURLY 273
-#define ID_ARGS 274
-#define LIST_COMMENT 275
-#define LIST_COMMENT_WITHOUT_NEWLINE 276
-#define QUOTED_VARIABLE_VALUE 277
-#define VARIABLE_VALUE 278
-#define INDENT 279
-#define LIST_WS 280
-
-
-
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef int YYSTYPE;
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-extern YYSTYPE yylval;
-
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake_yacc.hpp kdev_3.4.0/buildtools/lib/parsers/qmake/qmake_yacc.hpp
--- buildtools/lib/parsers/qmake/qmake_yacc.hpp	1970-01-01 01:00:00.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake_yacc.hpp	2007-02-07 20:35:10.000000000 +0100
@@ -0,0 +1,421 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison LALR(1) parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C++ LALR(1) parser skeleton written by Akim Demaille.  */
+
+#ifndef PARSER_HEADER_H
+# define PARSER_HEADER_H
+
+#include <string>
+#include <iostream>
+#include "stack.hh"
+
+namespace QMake
+{
+  class position;
+  class location;
+}
+
+/* First part of user declarations.  */
+#line 1 "qmake.yy"
+
+/***************************************************************************
+ *   Copyright (C) 2005 by Alexander Dymo                                  *
+ *   adymo@kdevelop.org                                                    *
+ *   Copyright (C) 2006 by Andreas Pakulat                                 *
+ *   apaku@gmx.de                                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU Library General Public License as       *
+ *   published by the Free Software Foundation; either version 2 of the    *
+ *   License, or (at your option) any later version.                       *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU Library General Public     *
+ *   License along with this program; if not, write to the                 *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/**
+@file qmake.yy
+QMake Parser
+
+Simple LALR parser which builds the syntax tree (see @ref QMake::AST).
+
+@todo Recognize comments after statements like:
+SOURCES = foo #regognize me
+
+@fixme Parser fails on files that do not end with a newline
+@fixme 1 shift/reduce conflict in "line_body" rule
+*/
+
+#include <qvaluestack.h>
+#include "qmakeast.h"
+#include <qregexp.h>
+
+#define YYSTYPE_IS_DECLARED
+
+namespace QMake
+{
+    class Lexer;
+
+/**
+The yylval type.
+*/
+struct Result {
+    Result(): node(0) {}
+
+    /**Type of semantic value for simple grammar rules.*/
+    QString value;
+    /**Type of semantic value for grammar rules which are parts of AST.*/
+    AST *node;
+    /**Type of semantic value for "multiline_values" grammar rule.
+    Each line of multiline value is stored as a string in the list.
+
+    For example we have in .pro file:
+    @code
+    SOURCE = foo1.cpp \
+        foo2.cpp \
+        foo3.cpp foo4.cpp
+    @endcode
+    The string list will be populated with three strings:
+    <pre>
+    foo1.cpp
+    foo2.cpp
+    foo3.cpp foo4.cpp
+    </pre>
+    */
+    QStringList values;
+    QString indent;
+};
+
+#define YYSTYPE Result
+typedef Result YYSTYPE;
+}
+
+extern int QMakelex( QMake::Result* yylval, QMake::Lexer* lexer );
+
+/**
+The stack to store ProjectAST pointers when a new child
+ProjectAST is created and filled with statements.
+
+Parser creates root ProjectAST for a .pro file, pushes it onto the stack and starts
+adding statements. Each statement is added as a child StatementAST to the ProjectAST
+currently on the top in the stack.
+
+When a scope or function scope statement is parsed, the child ProjectAST is created
+and pushed onto the stack. Therefore all statements which belong to the scope
+or function scope are added as childs to their direct parent (scope or function scope).
+*/
+//QValueStack<ProjectAST*> projects;
+
+/**
+The current depth of AST node is stored here.
+AST depth is important to know because automatic indentation can
+be easily implemented (the parser itself looses all information
+about indentation).
+*/
+// int depth = 0;
+
+/*
+To debug this parser, put the line below into the next bison file section.
+Don't forget to uncomment "yydebug = 1" line in qmakedriver.cpp.
+%debug
+*/
+
+
+/* Line 35 of lalr1.cc.  */
+#line 165 "qmake_yacc.hpp"
+
+#include "location.hh"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)		\
+do {							\
+  if (N)						\
+    {							\
+      (Current).begin = (Rhs)[1].begin;			\
+      (Current).end   = (Rhs)[N].end;			\
+    }							\
+  else							\
+    {							\
+      (Current).begin = (Current).end = (Rhs)[0].end;	\
+    }							\
+} while (false)
+#endif
+
+namespace QMake
+{
+
+  /// A Bison parser.
+  class Parser
+  {
+  public:
+    /// Symbol semantic values.
+#ifndef YYSTYPE
+    typedef int semantic_type;
+#else
+    typedef YYSTYPE semantic_type;
+#endif
+    /// Symbol locations.
+    typedef location location_type;
+    /// Tokens.
+    struct token
+    {
+      /* Tokens.  */
+   enum yytokentype {
+     ID_SIMPLE = 258,
+     EQ = 259,
+     PLUSEQ = 260,
+     MINUSEQ = 261,
+     STAREQ = 262,
+     TILDEEQ = 263,
+     LBRACE = 264,
+     RBRACE = 265,
+     COLON = 266,
+     NUMSIGN = 267,
+     NEWLINE = 268,
+     NUMBER = 269,
+     COMMENT = 270,
+     CONT = 271,
+     RCURLY = 272,
+     LCURLY = 273,
+     ID_ARGS = 274,
+     LIST_COMMENT = 275,
+     LIST_COMMENT_WITHOUT_NEWLINE = 276,
+     QUOTED_VARIABLE_VALUE = 277,
+     VARIABLE_VALUE = 278,
+     INDENT = 279,
+     LIST_WS = 280
+   };
+
+    };
+    /// Token type.
+    typedef token::yytokentype token_type;
+
+    /// Build a parser object.
+    Parser (QMake::Lexer* lexer_yyarg, QValueStack<ProjectAST*>& projects_yyarg, int depth_yyarg);
+    virtual ~Parser ();
+
+    /// Parse.
+    /// \returns  0 iff parsing succeeded.
+    virtual int parse ();
+
+    /// The current debugging stream.
+    std::ostream& debug_stream () const;
+    /// Set the current debugging stream.
+    void set_debug_stream (std::ostream &);
+
+    /// Type for debugging levels.
+    typedef int debug_level_type;
+    /// The current debugging level.
+    debug_level_type debug_level () const;
+    /// Set the current debugging level.
+    void set_debug_level (debug_level_type l);
+
+  private:
+    /// Report a syntax error.
+    /// \param loc    where the syntax error is found.
+    /// \param msg    a description of the syntax error.
+    virtual void error (const location_type& loc, const std::string& msg);
+
+    /// Generate an error message.
+    /// \param state   the state where the error occurred.
+    /// \param tok     the look-ahead token.
+    virtual std::string yysyntax_error_ (int yystate);
+
+#if YYDEBUG
+    /// \brief Report a symbol value on the debug stream.
+    /// \param yytype       The token type.
+    /// \param yyvaluep     Its semantic value.
+    /// \param yylocationp  Its location.
+    virtual void yy_symbol_value_print_ (int yytype,
+					 const semantic_type* yyvaluep,
+					 const location_type* yylocationp);
+    /// \brief Report a symbol on the debug stream.
+    /// \param yytype       The token type.
+    /// \param yyvaluep     Its semantic value.
+    /// \param yylocationp  Its location.
+    virtual void yy_symbol_print_ (int yytype,
+				   const semantic_type* yyvaluep,
+				   const location_type* yylocationp);
+#endif /* ! YYDEBUG */
+
+
+    /// State numbers.
+    typedef int state_type;
+    /// State stack type.
+    typedef stack<state_type>    state_stack_type;
+    /// Semantic value stack type.
+    typedef stack<semantic_type> semantic_stack_type;
+    /// location stack type.
+    typedef stack<location_type> location_stack_type;
+
+    /// The state stack.
+    state_stack_type yystate_stack_;
+    /// The semantic value stack.
+    semantic_stack_type yysemantic_stack_;
+    /// The location stack.
+    location_stack_type yylocation_stack_;
+
+    /// Internal symbol numbers.
+    typedef unsigned char token_number_type;
+    /* Tables.  */
+    /// For a state, the index in \a yytable_ of its portion.
+    static const signed char yypact_[];
+    static const signed char yypact_ninf_;
+
+    /// For a state, default rule to reduce.
+    /// Unless\a  yytable_ specifies something else to do.
+    /// Zero means the default is an error.
+    static const unsigned char yydefact_[];
+
+    static const signed char yypgoto_[];
+    static const signed char yydefgoto_[];
+
+    /// What to do in a state.
+    /// \a yytable_[yypact_[s]]: what to do in state \a s.
+    /// - if positive, shift that token.
+    /// - if negative, reduce the rule which number is the opposite.
+    /// - if zero, do what YYDEFACT says.
+    static const unsigned char yytable_[];
+    static const signed char yytable_ninf_;
+
+    static const unsigned char yycheck_[];
+
+    /// For a state, its accessing symbol.
+    static const unsigned char yystos_[];
+
+    /// For a rule, its LHS.
+    static const unsigned char yyr1_[];
+    /// For a rule, its RHS length.
+    static const unsigned char yyr2_[];
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+    /// For a symbol, its name in clear.
+    static const char* const yytname_[];
+#endif
+
+#if YYERROR_VERBOSE
+    /// Convert the symbol name \a n to a form suitable for a diagnostic.
+    virtual std::string yytnamerr_ (const char *n);
+#endif
+
+#if YYDEBUG
+    /// A type to store symbol numbers and -1.
+    typedef signed char rhs_number_type;
+    /// A `-1'-separated list of the rules' RHS.
+    static const rhs_number_type yyrhs_[];
+    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
+    static const unsigned char yyprhs_[];
+    /// For each rule, its source line number.
+    static const unsigned short int yyrline_[];
+    /// For each scanner token number, its symbol number.
+    static const unsigned short int yytoken_number_[];
+    /// Report on the debug stream that the rule \a r is going to be reduced.
+    virtual void yy_reduce_print_ (int r);
+    /// Print the state stack on the debug stream.
+    virtual void yystack_print_ ();
+#endif
+
+    /// Convert a scanner token number \a t to a symbol number.
+    token_number_type yytranslate_ (int t);
+
+    /// \brief Reclaim the memory associated to a symbol.
+    /// \param yymsg        Why this token is reclaimed.
+    /// \param yytype       The symbol type.
+    /// \param yyvaluep     Its semantic value.
+    /// \param yylocationp  Its location.
+    inline void yydestruct_ (const char* yymsg,
+			     int yytype,
+			     semantic_type* yyvaluep,
+			     location_type* yylocationp);
+
+    /// Pop \a n symbols the three stacks.
+    inline void yypop_ (unsigned int n = 1);
+
+    /* Constants.  */
+    static const int yyeof_;
+    /* LAST_ -- Last index in TABLE_.  */
+    static const int yylast_;
+    static const int yynnts_;
+    static const int yyempty_;
+    static const int yyfinal_;
+    static const int yyterror_;
+    static const int yyerrcode_;
+    static const int yyntokens_;
+    static const unsigned int yyuser_token_number_max_;
+    static const token_number_type yyundef_token_;
+
+    /* Debugging.  */
+    int yydebug_;
+    std::ostream* yycdebug_;
+
+
+    /* User arguments.  */
+    QMake::Lexer* lexer;
+    QValueStack<ProjectAST*>& projects;
+    int depth;
+  };
+}
+
+
+#endif /* ! defined PARSER_HEADER_H */
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/qmake.yy kdev_3.4.0/buildtools/lib/parsers/qmake/qmake.yy
--- buildtools/lib/parsers/qmake/qmake.yy	2007-02-07 21:15:37.000000000 +0100
+++ buildtools/lib/parsers/qmake/qmake.yy	2007-02-07 20:35:13.000000000 +0100
@@ -2,6 +2,8 @@
 /***************************************************************************
  *   Copyright (C) 2005 by Alexander Dymo                                  *
  *   adymo@kdevelop.org                                                    *
+ *   Copyright (C) 2006 by Andreas Pakulat                                 *
+ *   apaku@gmx.de                                                          *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU Library General Public License as       *
@@ -38,7 +40,9 @@
 
 #define YYSTYPE_IS_DECLARED
 
-using namespace QMake;
+namespace QMake
+{
+    class Lexer;
 
 /**
 The yylval type.
@@ -70,13 +74,11 @@
     QString indent;
 };
 
+#define YYSTYPE Result
 typedef Result YYSTYPE;
-
-void yyerror(const char *str) {
-    printf("%s\n", str);
 }
 
-int yylex();
+extern int QMakelex( QMake::Result* yylval, QMake::Lexer* lexer );
 
 /**
 The stack to store ProjectAST pointers when a new child
@@ -90,7 +92,7 @@
 and pushed onto the stack. Therefore all statements which belong to the scope
 or function scope are added as childs to their direct parent (scope or function scope).
 */
-QValueStack<ProjectAST*> projects;
+//QValueStack<ProjectAST*> projects;
 
 /**
 The current depth of AST node is stored here.
@@ -98,7 +100,7 @@
 be easily implemented (the parser itself looses all information
 about indentation).
 */
-int depth = 0;
+// int depth = 0;
 
 /*
 To debug this parser, put the line below into the next bison file section.
@@ -107,10 +109,19 @@
 */
 %}
 
+%skeleton "lalr1.cc"
+%define "parser_class_name" "Parser"
+%name-prefix="QMake"
+%parse-param { QMake::Lexer* lexer }
+%parse-param { QValueStack<ProjectAST*>& projects }
+%parse-param { int depth }
+%lex-param   { QMake::Lexer* lexer }
+%start project
+
 %token ID_SIMPLE
 %token EQ
 %token PLUSEQ
-%token MINUSQE
+%token MINUSEQ
 %token STAREQ
 %token TILDEEQ
 %token LBRACE
@@ -228,7 +239,7 @@
     | QUOTED_VARIABLE_VALUE  { $<value>$ = $<value>1; }
     ;
 
-operator : EQ | PLUSEQ | MINUSQE | STAREQ | TILDEEQ
+operator : EQ | PLUSEQ | MINUSEQ | STAREQ | TILDEEQ
     ;
 
 scope : ID_SIMPLE
@@ -315,4 +326,11 @@
 
 %%
 
-#include "qmake_lex.cpp"
+
+namespace QMake
+{
+    void Parser::error(const location_type& /*l*/, const std::string& m)
+    {
+        std::cerr << m << std::endl;
+    }
+}
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/stack.hh kdev_3.4.0/buildtools/lib/parsers/qmake/stack.hh
--- buildtools/lib/parsers/qmake/stack.hh	1970-01-01 01:00:00.000000000 +0100
+++ buildtools/lib/parsers/qmake/stack.hh	2007-02-07 20:35:16.000000000 +0100
@@ -0,0 +1,129 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Stack handling for Bison parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef BISON_STACK_HH
+# define BISON_STACK_HH
+
+#include <deque>
+
+namespace QMake
+{
+  template <class T, class S = std::deque<T> >
+  class stack
+  {
+  public:
+
+    // Hide our reversed order.
+    typedef typename S::reverse_iterator iterator;
+    typedef typename S::const_reverse_iterator const_iterator;
+
+    stack () : seq_ ()
+    {
+    }
+
+    stack (unsigned int n) : seq_ (n)
+    {
+    }
+
+    inline
+    T&
+    operator [] (unsigned int i)
+    {
+      return seq_[i];
+    }
+
+    inline
+    const T&
+    operator [] (unsigned int i) const
+    {
+      return seq_[i];
+    }
+
+    inline
+    void
+    push (const T& t)
+    {
+      seq_.push_front (t);
+    }
+
+    inline
+    void
+    pop (unsigned int n = 1)
+    {
+      for (; n; --n)
+	seq_.pop_front ();
+    }
+
+    inline
+    unsigned int
+    height () const
+    {
+      return seq_.size ();
+    }
+
+    inline const_iterator begin () const { return seq_.rbegin (); }
+    inline const_iterator end () const { return seq_.rend (); }
+
+  private:
+
+    S seq_;
+  };
+
+  /// Present a slice of the top of a stack.
+  template <class T, class S = stack<T> >
+  class slice
+  {
+  public:
+
+    slice (const S& stack,
+	   unsigned int range) : stack_ (stack),
+				 range_ (range)
+    {
+    }
+
+    inline
+    const T&
+    operator [] (unsigned int i) const
+    {
+      return stack_[range_ - i];
+    }
+
+  private:
+
+    const S& stack_;
+    unsigned int range_;
+  };
+}
+
+#endif // not BISON_STACK_HH
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/tests/runner.cpp kdev_3.4.0/buildtools/lib/parsers/qmake/tests/runner.cpp
--- buildtools/lib/parsers/qmake/tests/runner.cpp	2007-02-07 21:15:35.000000000 +0100
+++ buildtools/lib/parsers/qmake/tests/runner.cpp	2007-02-07 20:35:15.000000000 +0100
@@ -17,10 +17,26 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-#include <qmakeast.h>
-#include <qmakeastvisitor.h>
-#include <qmakedriver.h>
+
+#include <cstdlib>
+#include <iostream>
+#include <stdio.h>
+#include "qmakedriver.h"
+#include "qmakeastvisitor.h"
+
+#include <qstring.h>
+
 #include <kdebug.h>
+#include <kcmdlineargs.h>
+#include <kurl.h>
+
+static const KCmdLineOptions options[] =
+{
+    {"silent", "Enable Parser debug output", 0},
+    {"!debug", "Disable output of the generated AST", 0},
+    {"!+files", "QMake project files", 0}
+};
+
 
 class PrintAST : QMake::ASTVisitor
 {
@@ -120,14 +136,30 @@
 };
 int main(int argc, char *argv[])
 {
-    QMake::ProjectAST *projectAST;
-    int ret;
-    if (argc > 1)
+  KCmdLineArgs::init( argc, argv, "QMake Parser", "qmake-parser", "Parse QMake project files", "1.0.0");
+    KCmdLineArgs::addCmdLineOptions(options);
+
+    KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
+
+    if( args->count() < 1 )
+    {
+        KCmdLineArgs::usage(0);
+    }
+
+    int debug = 0;
+    bool silent = false;
+
+    if( args->isSet("silent") )
+        silent = true;
+    if( args->isSet("debug") )
+        debug = 1;
+    for( int i = 0 ; i < args->count() ; i++ )
     {
-        ret = QMake::Driver::parseFile(argv[1], &projectAST);
+        QMake::ProjectAST *projectAST;
+        int ret = QMake::Driver::parseFile(argv[1], &projectAST, debug);
         PrintAST pa;
         if ( ret == 0 )
-            if ((argc < 3) || ((argc == 3) && (strcmp(argv[2], "--silent") != 0)))
+            if ( !silent )
             {
                 pa.processProject(projectAST);
                 QString profile;
@@ -136,6 +168,5 @@
             }
         return ret;
     }
-    else
-        return 0;
+    return 0;
 }
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/lib/parsers/qmake/tests/viewer.cpp kdev_3.4.0/buildtools/lib/parsers/qmake/tests/viewer.cpp
--- buildtools/lib/parsers/qmake/tests/viewer.cpp	2007-02-07 21:15:35.000000000 +0100
+++ buildtools/lib/parsers/qmake/tests/viewer.cpp	2007-02-07 20:35:15.000000000 +0100
@@ -78,7 +78,7 @@
     source->setText(str.read());
     f.close();
 
-    int result = QMake::Driver::parseFile(item->text().ascii(), &projectAST);
+    int result = QMake::Driver::parseFile(item->text().ascii(), &projectAST, 0);
     if (projectAST && (result == 0))
     {
         processAST(projectAST);
diff -u --exclude=.svn -Nur kdev_3.4.0.org/buildtools/qmake/scope.cpp kdev_3.4.0/buildtools/qmake/scope.cpp
--- buildtools/qmake/scope.cpp	2007-02-07 21:15:44.000000000 +0100
+++ buildtools/qmake/scope.cpp	2007-02-07 20:57:21.000000000 +0100
@@ -147,7 +147,7 @@
 
 bool Scope::loadFromFile( const QString& filename )
 {
-    if ( !QFileInfo(filename).exists() || QMake::Driver::parseFile( filename, &m_root ) != 0 )
+    if ( !QFileInfo(filename).exists() || QMake::Driver::parseFile( filename, &m_root, 0 ) != 0 )
     {
         kdDebug( 9024 ) << "Couldn't parse project: " << filename << endl;
         m_root = 0;
