diff -ur --unidirectional-new-file skipsrc-1.0.orig/skip/freebsd/skip_es.c skipsrc-1.0/skip/freebsd/skip_es.c
--- skipsrc-1.0.orig/skip/freebsd/skip_es.c	Fri Oct 25 13:12:42 1996
+++ skipsrc-1.0/skip/freebsd/skip_es.c	Sun Apr 12 15:51:32 1998
@@ -81,6 +81,11 @@
 static unsigned short	skip_pktid;
 static skip_softc_t	skip_softc[SKIP_MAX_OPENS];
 
+#ifdef NEW_TIMEOUT_INTERFACE
+static struct callout_handle
+	skip_timeout_handle = CALLOUT_HANDLE_INITIALIZER(&skip_timeout_handle);
+#endif
+
 /*
  * statistics
  */
@@ -252,7 +257,10 @@
 		for (pr = inetdomain.dom_protosw;
 			pr < inetdomain.dom_protoswNPROTOSW; pr++) {
 
-			pr->pr_input = skip_ifinput;
+			if (pr->pr_protocol == IPPROTO_DIVERT)
+				continue;
+			pr->pr_input =
+				(void (*)(struct mbuf *, int)) skip_ifinput;
 		}
 		splx(s);
 	}
@@ -788,7 +796,11 @@
 static void
 skip_inittimers()
 {
+#ifdef NEW_TIMEOUT_INTERFACE
+	skip_timeout_handle = timeout(skip_timer, NULL, skip_key_tick * hz);
+#else
 	timeout(skip_timer, NULL, skip_key_tick * hz);
+#endif
 }
  
 /* skip_uninittimers()
@@ -800,7 +812,12 @@
 static void
 skip_uninittimers()
 {
+#ifdef NEW_TIMEOUT_INTERFACE
+	untimeout(skip_timer, NULL, skip_timeout_handle);
+	callout_handle_init(&skip_timeout_handle);
+#else
 	untimeout(skip_timer, NULL);
+#endif
 }
  
 /* skip_timer()
@@ -819,7 +836,11 @@
 	 * run through the key store
 	 */
 	skip_key_iterate(skip_key_check, NULL);
+#ifdef NEW_TIMEOUT_INTERFACE
+	skip_timeout_handle = timeout(skip_timer, NULL, skip_key_tick * hz);
+#else
 	timeout(skip_timer, NULL, skip_key_tick * hz);
+#endif
 }
 
 #ifdef notdef
@@ -1718,7 +1739,7 @@
 		 */
 		decryptbuf->m_data += iphlen;
 	
-                SKIP_DEBUG2("skip_ifinput: decryptbuf m_len=%d m_data=%d\n",
+                SKIP_DEBUG2("skip_ifinput: decryptbuf m_len=%d m_data=%p\n",
                                         decryptbuf->m_len, decryptbuf->m_data);
 
 	} 
@@ -1910,6 +1931,13 @@
 		 */
                 IPADDRCOPY(&params.tunnel_addr, &newip->ip_dst);
 
+		/* 
+		 * insert different source address if specified 
+		 */
+
+		if(params.source != 0)
+			(&newip->ip_src)->s_addr = params.source;
+
 		encryptbuf->m_len += sizeof (struct ip);
 
 		/*
@@ -2005,7 +2033,7 @@
 			if (params.kp_alg) {
 				newip->ip_p = SKIP_NEXT_ESP;
 			} else {
-				newip->ip_p = IPPROTO_ENCAP;
+				newip->ip_p = IPPROTO_IPIP;
 			}
 		}
 		skip_if->stats.skip_if_raw_out++;
@@ -2028,6 +2056,13 @@
 		 * insert tunnel address as destination
 		 */
 		IPADDRCOPY(&params.tunnel_addr, &newip->ip_dst);
+
+		/* 
+		 * insert different source address if specified 
+		 */
+
+		if(params.source != 0) 
+			(&newip->ip_src)->s_addr = params.source;
 	}
 
 	if (params.s_nsid == 0) {
@@ -2097,7 +2132,7 @@
 	register skip_param_t   *params = &res->params;
 	register struct ip      *ip = mtod(original, struct ip *);
 	int                     rc, s, iphlen;
-	struct mbuf             *outbuf, *new_hdr;
+	struct mbuf             *outbuf;
 
 	SKIP_PRINT("skip_decrypt_done", params);
 
@@ -2125,7 +2160,7 @@
 	 */
 	outbuf = (res->modes & SKIP_CRYPT_ON) ? m : original;
 
-	if (res->proto != IPPROTO_ENCAP) {
+	if (res->proto != IPPROTO_IPIP) {
 		/*
 		 * transport mode, need to copy original IP header
 		 */
