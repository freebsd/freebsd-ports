--- pico/composer.c.orig	Fri Jun 11 06:55:22 1999
+++ pico/composer.c	Thu Oct 14 10:53:41 1999
@@ -133,12 +133,12 @@
 
 
 static KEYMENU menu_header[] = {
-    {"^G", "Get Help", KS_SCREENHELP},	{"^X", "Send", KS_SEND},
-    {"^R", "Rich Hdr", KS_RICHHDR},	{"^Y", "PrvPg/Top", KS_PREVPAGE},
-    {"^K", "Cut Line", KS_CURPOSITION},	{"^O", "Postpone", KS_POSTPONE},
-    {"^C", "Cancel", KS_CANCEL},	{"^D", "Del Char", KS_NONE},
-    {"^J", "Attach", KS_ATTACH},	{"^V", "NxtPg/End", KS_NEXTPAGE},
-    {"^U", "UnDel Line", KS_NONE},	{NULL, NULL}
+    {"^G", "輔助說明", KS_SCREENHELP},	{"^X", "送出", KS_SEND},
+    {"^R", "完整標頭", KS_RICHHDR},	{"^Y", "上一頁", KS_PREVPAGE},
+    {"^K", "剪下一行", KS_CURPOSITION},	{"^O", "暫緩寫信", KS_POSTPONE},
+    {"^C", "取消", KS_CANCEL},	{"^D", "刪除字元", KS_NONE},
+    {"^J", "夾附件", KS_ATTACH},	{"^V", "下一頁", KS_NEXTPAGE},
+    {"^U", "復原刪除行", KS_NONE},	{NULL, NULL}
 };
 #define	SEND_KEY	1
 #define	RICH_KEY	2
@@ -262,7 +262,7 @@
 		     if(strlen(addrbuf) + strlen(buf) >= addrbuflen){
 			 addrbuflen += NLINE * 4;
 			 if(!(addrbuf = (char *)realloc(addrbuf, addrbuflen))){
-			     emlwrite("\007Can't realloc addrbuf to %d bytes",
+			     emlwrite("\007無法更改 addrbuf 的記憶體配置至 %d bytes",
 				      (void *) addrbuflen);
 			     return(ABORT);
 			 }
@@ -329,7 +329,7 @@
      * get first chunk of memory, and tie it to structure...
      */
     if((curline = HALLOC()) == NULL){
-        emlwrite("Unable to make room for full Header.", NULL);
+        emlwrite("無法配置空間給完整標頭。", NULL);
         return(FALSE);
     }
     longest = term.t_ncol - e->prlen - 1;
@@ -711,7 +711,7 @@
 	    }
 	    else{
 		(*term.t_beep)();
-		emlwrite("Unknown Command: ^Z", NULL);
+		emlwrite("未知的命令：^Z", NULL);
 	    }
 	    break;
 
@@ -724,12 +724,12 @@
 	    err = NULL;
 	    if(headents[ods.cur_e].is_attach){
 		if(SyncAttach() < 0){
-		    if(mlyesno("Problem with attachments. Postpone anyway?",
+		    if(mlyesno("附件有問題。無論如何都要暫緩該信嗎？",
 			       FALSE) != TRUE){
 			if(FormatLines(headents[ods.cur_e].hd_text, "",
 				       term.t_ncol - headents[ods.cur_e].prlen,
 				       headents[ods.cur_e].break_on_comma, 0) == -1)
-			  emlwrite("\007Format lines failed!", NULL);
+			  emlwrite("\007版面整理失敗!", NULL);
 			UpdateHeader(0);
 			PaintHeader(COMPOSER_TOP_LINE, FALSE);
 			PaintBody(1);
@@ -998,7 +998,7 @@
 		    if(FormatLines(headents[ods.cur_e].hd_text, buf,
 				   term.t_ncol - headents[ods.cur_e].prlen,
 				   headents[ods.cur_e].break_on_comma,0)==-1){
-			emlwrite("\007Format lines failed!", NULL);
+			emlwrite("\007版面整理失敗!", NULL);
 		    }
 
 		    UpdateHeader(0);
@@ -1057,7 +1057,7 @@
                         if(FormatLines(ods.cur_l, bufp,
 				      (term.t_ncol-headents[ods.cur_e].prlen), 
                                       headents[ods.cur_e].break_on_comma, 0) == -1){
-                            emlwrite("Problem adding address to header !",
+                            emlwrite("在標頭加入地址時出了問題!",
                                      NULL);
                             (*term.t_beep)();
                             break;
@@ -1193,10 +1193,10 @@
 	  default :				/* huh? */
 bleep:
 	    if(ch&CTRL)
-	      emlwrite("\007Unknown command: ^%c", (void *)(ch&0xff));
+	      emlwrite("\007未知的命令：^%c", (void *)(ch&0xff));
 	    else
 	  case BADESC:
-	      emlwrite("\007Unknown command", NULL);
+	      emlwrite("\007未知的命令", NULL);
 
 	  case NODATA:
 	    break;
@@ -1236,14 +1236,14 @@
 	if(gripe){
 	    char xx[81];
 
-	    strcpy(xx, "Can't move down. Use ^X to ");
+	    strcpy(xx, "無法再往下移了。請用 ^X ");
 	    strcat(xx, (Pmaster && Pmaster->exit_label)
 			    ? Pmaster->exit_label
 			    : (gmode & MDHDRONLY)
-			      ? "eXit/Save"
+			      ? "離開/送出"
 			      : (gmode & MDVIEW)
-				? "eXit"
-				: "Send");
+				? "離開"
+				: "送出");
 	    strcat(xx, ".");
 	    emlwrite(xx, NULL);
 	}
@@ -1278,7 +1278,7 @@
 		if(FormatLines(headents[ods.cur_e].hd_text, "",
 			       term.t_ncol-headents[new_e].prlen,
 			       headents[ods.cur_e].break_on_comma, 0) == -1)
-		  emlwrite("\007Format lines failed!", NULL);
+		  emlwrite("\007版面整理失敗!", NULL);
 	    }
 	} else if(headents[ods.cur_e].builder) { /* expand addresses	    */
 	    int mangled = 0;
@@ -1349,8 +1349,8 @@
     if(!(new_l = prev_sel_hline(&new_e, ods.cur_l))){	/* all the way up! */
 	ods.p_line = COMPOSER_TOP_LINE;
 	if(gripe)
-	  emlwrite("Can't move beyond top of %s",
-	      (Pmaster->pine_flags & MDHDRONLY) ? "entry" : "header");
+	  emlwrite("無法移到超出%s的頂端",
+	      (Pmaster->pine_flags & MDHDRONLY) ? "項目" : "標頭");
 
 	return(0);
     }
@@ -1379,7 +1379,7 @@
 		if(FormatLines(headents[ods.cur_e].hd_text, "",
 			       term.t_ncol - headents[ods.cur_e].prlen,
 			       headents[ods.cur_e].break_on_comma,0) == -1)
-		  emlwrite("\007Format lines failed!", NULL);
+		  emlwrite("\007版面整理失敗!", NULL);
 	    }
 	}
 	else if(headents[ods.cur_e].builder){
@@ -1458,7 +1458,7 @@
 	    lp = lp->next;
 	}
 	else{
-	    emlwrite("\007Can't allocate line for new attachment!", NULL);
+	    emlwrite("\007無法為新的附件配置空間!", NULL);
 	    return(0);
 	}
     }
@@ -1472,12 +1472,12 @@
     /* validate the new attachment, and reformat if needed */
     if(status = SyncAttach()){
 	if(status < 0)
-	  emlwrite("\007Problem attaching: %s", fn);
+	  emlwrite("\007有問題的附件：%s", fn);
 
 	if(FormatLines(headents[a_e].hd_text, "",
 		       term.t_ncol - headents[a_e].prlen,
 		       headents[a_e].break_on_comma, 0) == -1){
-	    emlwrite("\007Format lines failed!", NULL);
+	    emlwrite("\007版面整理失敗!", NULL);
 	    return(0);
 	}
     }
@@ -1552,7 +1552,7 @@
 	
 	if (term.t_nrow < 6 && ch != NODATA){
 	    (*term.t_beep)();
-	    emlwrite("Please make the screen bigger.", NULL);
+	    emlwrite("請將畫面調大一些。", NULL);
 	    continue;
 	}
 
@@ -1624,13 +1624,13 @@
 		if(headents[ods.cur_e].only_file_chars
 		   && !fallowc((unsigned char) ch)){
 		    /* no garbage in filenames */
-		    emlwrite("\007Can't have a '%c' in folder name",
+		    emlwrite("\007資料匣中不能有 '%c' 這個字元",
 			     (void *) ch);
 		    continue;
 		}
 		else if(headents[ods.cur_e].is_attach
 			&& intag(strng,ods.p_off)){
-		    emlwrite("\007Can't edit attachment number!", NULL);
+		    emlwrite("\007無法編輯附件的代碼!", NULL);
 		    continue;
 		}
 
@@ -1779,7 +1779,7 @@
 		    headents[ods.cur_e].dirty  = 1;
 		}
 		else
-		  emlwrite("Problem Unkilling text", NULL);
+		  emlwrite("有問題的反刪除文字", NULL);
 		continue;
 
 	      case (CTRL|'F') :
@@ -1830,7 +1830,7 @@
 		  continue;
 
 		if(headents[ods.cur_e].is_attach && intag(strng, ods.p_off)){
-		    emlwrite("\007Can't edit attachment number!", NULL);
+		    emlwrite("\007無法編輯附件的代碼!", NULL);
 		    continue;
 		}
 
@@ -1844,7 +1844,7 @@
 		}
 
 		if(headents[ods.cur_e].is_attach && intag(strng, ods.p_off-1)){
-		    emlwrite("\007Can't edit attachment number!", NULL);
+		    emlwrite("\007無法編輯附件的代碼!", NULL);
 		    continue;
 		}
 
@@ -2141,7 +2141,7 @@
 
 	if(nlp == NULL){			/* no place to add below? */
 	    if((lp = HALLOC()) == NULL){
-		emlwrite("Can't allocate any more lines for header!", NULL);
+		emlwrite("無法再配置更多的空間給標頭!", NULL);
 		free(buf);
 		return(-1);
 	    }
@@ -2174,7 +2174,7 @@
 
 	    if(strlen(buf) && !nlp){
 		if((lp = HALLOC()) == NULL){
-		    emlwrite("Can't allocate any more lines for header!",NULL);
+		    emlwrite("無法再配置更多的空間給標頭!",NULL);
 		    free(buf);
 		    return(-1);
 		}
@@ -2461,14 +2461,14 @@
 
     if(level < 0 || !headents[level].name){
 	(*term.t_beep)();
-	emlwrite("Sorry, I can't help you with that.", NULL);
+	emlwrite("很抱歉，關於那個我無法幫忙。", NULL);
 	sleep(2);
 	return(FALSE);
     }
 
-    sprintf(buf, "Help for %s %.40s Field",
-		 (Pmaster->pine_flags & MDHDRONLY) ? "Address Book"
-						 : "Composer",
+    sprintf(buf, "%s欄位%.40s的輔助說明",
+		 (Pmaster->pine_flags & MDHDRONLY) ? "地址簿"
+						 : "編輯器",
 		 headents[level].name);
     saved_state = save_pico_state();
     (*Pmaster->helper)(headents[level].help, buf, 1);
@@ -3114,7 +3114,7 @@
     }
     
     if((sbuf=(char *)malloc((unsigned) i)) == NULL){
-	emlwrite("Can't malloc space to expand address", NULL);
+	emlwrite("無法配置記憶體空間以展開地址", NULL);
 	return(-1);
     }
     
@@ -3171,7 +3171,7 @@
 		if(!arg){
 		    headarg = arg = (BUILDER_ARG *)malloc(sizeof(BUILDER_ARG));
 		    if(!arg){
-			emlwrite("Can't malloc space for fcc", NULL);
+			emlwrite("無法配置記憶體空間給 fcc", NULL);
 			return(-1);
 		    }
 		    else{
@@ -3184,7 +3184,7 @@
 		else{
 		    nextarg = (BUILDER_ARG *)malloc(sizeof(BUILDER_ARG));
 		    if(!nextarg){
-			emlwrite("Can't malloc space for fcc", NULL);
+			emlwrite("無法配置記憶體空間給 fcc", NULL);
 			return(-1);
 		    }
 		    else{
@@ -3200,7 +3200,7 @@
 		if(!e->sticky){
 		    line = e->hd_text;
 		    if(!(arg->tptr=(char *)malloc(strlen(line->text) + 1))){
-			emlwrite("Can't malloc space for fcc", NULL);
+			emlwrite("無法配置記憶體空間給 fcc", NULL);
 			return(-1);
 		    }
 		    else
@@ -3217,7 +3217,7 @@
     if(!headarg){
 	headarg = (BUILDER_ARG *)malloc(sizeof(BUILDER_ARG));
 	if(!headarg){
-	    emlwrite("Can't malloc space", NULL);
+	    emlwrite("無法配置記憶體空間", NULL);
 	    return(-1);
 	}
 	else{
@@ -3543,7 +3543,7 @@
 
     if(ksize()){
 	if((bp = buf = (char *)malloc(ksize()+5)) == NULL){
-	    emlwrite("Can't malloc space for saved text", NULL);
+	    emlwrite("無法配置保存文字的記憶體空間", NULL);
 	    return(FALSE);
 	}
     }
@@ -3577,7 +3577,7 @@
 	work_buf_len = strlen(ods.cur_l->text) + buf_len;
 	work_buf = (char *) malloc((work_buf_len + 1) * sizeof(char));
 	if (work_buf == NULL) {
-	    emlwrite("Can't malloc space for saved text", NULL);
+	    emlwrite("無法配置保存文字的記憶體空間", NULL);
 	    return(FALSE);
 	}
 
@@ -3786,9 +3786,9 @@
     if(Pmaster && Pmaster->exit_label)
       menu_header[SEND_KEY].label = Pmaster->exit_label;
     else if(gmode & (MDVIEW | MDHDRONLY))
-      menu_header[SEND_KEY].label =  (gmode & MDHDRONLY) ? "eXit/Save" : "eXit";
+      menu_header[SEND_KEY].label =  (gmode & MDHDRONLY) ? "離開/儲存" : "離開";
     else
-      menu_header[SEND_KEY].label = "Send";
+      menu_header[SEND_KEY].label = "送出";
 
     if(gmode & MDVIEW){
 	menu_header[CUT_KEY].name  = NULL;
@@ -3809,14 +3809,14 @@
 	menu_header[RICH_KEY].name  = NULL;
     }
     else{
-	menu_header[RICH_KEY].label = "Rich Hdr";
+	menu_header[RICH_KEY].label = "完整標頭";
 	menu_header[RICH_KEY].name  = "^R";
     }
 
     if(gmode & MDHDRONLY){
 	if(headents[ods.cur_e].fileedit){
 	    menu_header[PONE_KEY].name  = "^_";
-	    menu_header[PONE_KEY].label   = "Edit File";
+	    menu_header[PONE_KEY].label   = "編輯檔案";
 	}
 	else
 	  menu_header[PONE_KEY].name  = NULL;
@@ -3825,7 +3825,7 @@
     }
     else{
 	menu_header[PONE_KEY].name  = "^O";
-	menu_header[PONE_KEY].label = "Postpone";
+	menu_header[PONE_KEY].label = "暫緩";
 	KS_OSDATASET(&menu_header[PONE_KEY],KS_OSDATAGET(&headents[ods.cur_e]));
 
 	menu_header[ATT_KEY].name   = "^J";
@@ -3897,7 +3897,7 @@
                 *headents[i].realaddr = bufp;
             }
             else{
-                emlwrite("Can't make room to pack header field.", NULL);
+                emlwrite("無法配置包裝表頭欄位的記憶體空間。", NULL);
                 retval = FALSE;
             }
         }
