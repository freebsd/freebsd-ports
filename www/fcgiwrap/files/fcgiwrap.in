#!/bin/sh

# $FreeBSD$
#
# fcgiwrap startup script
#
# PROVIDE: fcgiwrap
# REQUIRE: LOGIN
# KEYWORD: shutdown
#
# Add the following to /etc/rc.conf[.local] to enable this service
#
# fcgiwrap_enable="YES"
#
# You can fine tune others variables too:
# fcgiwrap_socket="unix:/var/run/fcgiwrap.sock" 
# this could also be:
# - tcp:[ipv4_addr]:port (for ipv4)
# - tcp6:[ipv6_addr]:port (for ipv6)
# fcgiwrap_flags=
# Use fcgiwrap_user to run fcgiwrap as user
# Use fcgiwrap_group to run fcgiwrap as group
# Use fcgiwrap_socket_mode to change the mode of the socket
# Use fcgiwrap_socket_owner to change the owner of the socket
# Use fcgiwrap_socket_group to change the group of the socket

# fcgiwrap rc.d script supports multiple profiles (a-la rc.d/nginx)
# When profiles are specified, the non-profile specific parameters become defaults.
# You need to make sure that no two profiles have the same socket parameter.
#
# Example:
#
# fcgiwrap_enable="YES"
# fcgiwrap_profiles="myserver myotherserver"
# fcgiwrap_flags="-c 4"
# fcgiwrap_socket_owner="www"
# fcgiwrap_myserver_socket="unix:/var/run/fcgiwrap.myserver.socket"
# fcgiwrap_myserver_user="myuser"
# fcgiwrap_myserver_group="mygroup"
# fcgiwrap_myotherserver_socket="unix:/var/run/fcgiwrap.myotherserver.socket"
# fcgiwrap_myotherserver_user="myotheruser"
# fcgiwrap_myotherserver_group="myothergroup"
# fcgiwrap_myserver_socket_mode="0775"
# fcgiwrap_myotherserver_flags=""  # No flags for this profile.

. /etc/rc.subr

name="fcgiwrap"
rcvar=fcgiwrap_enable

fcgiwrap_setfib() {
	if command -v check_namevarlist > /dev/null 2>&1; then
		check_namevarlist fib && return 0
	fi
	
	${SYSCTL} net.fibs >/dev/null 2>&1 || return 0

	fcgiwrap_fib=${fcgiwrap_fib:-"NONE"}
	case "$fcgiwrap_fib" in
	[Nn][Oo][Nn][Ee])
		;;
	*)
		command="setfib -F ${fcgiwrap_fib} ${command}"
		;;
	esac
} 

fcgiwrap_precmd() {
	fcgiwrap_setfib
	install -d -o root -g wheel -m 1777 /var/run/fcgiwrap
}

fcgiwrap_postcmd() {
	# This is only for unix sockets
	case "${fcgiwrap_socket}" in
		unix:*)
			;;
		*)
			return
			;;
	esac
	if [ -n "${fcgiwrap_socket_mode}" ]; then
		chmod ${fcgiwrap_socket_mode} ${fcgiwrap_socket#unix:}
	fi
	if [ "${fcgiwrap_socket_owner}" != "${fcgiwrap_user}" ]; then
		chown ${fcgiwrap_socket_owner} ${fcgiwrap_socket#unix:}
	fi
	if [ "${fcgiwrap_socket_group}" != "${fcgiwrap_group}" ]; then
		chgrp ${fcgiwrap_socket_group} ${fcgiwrap_socket#unix:}
	fi
}

fcgiwrap_stop() {
	if [ -s ${pidfile} ]; then
		fcgiwrap_pgrp=$(/bin/ps -o ppid= $(cat ${pidfile}))
	fi
	if [ -z "$fcgiwrap_pgrp" -o "${fcgiwrap_pgrp:-0}" -le 1 ] || ! kill -0 $fcgiwrap_pgrp; then
		[ -n "$rc_fast" ] && return 0
		_run_rc_notrunning
		return 1
	fi
	fcgiwrap_pgrp_pids=$(/bin/pgrep -d ' ' -g ${fcgiwrap_pgrp})
	echo "Stopping ${name}."
	kill -TERM -- -${fcgiwrap_pgrp}
	wait_for_pids ${fcgiwrap_pgrp_pids}

	# Workaround the fact that fcgiwrap doesn't cleanup his socket at stopping
	case ${fcgiwrap_socket} in 
		unix*)
		test -S ${fcgiwrap_socket#unix:} && rm -f ${fcgiwrap_socket#unix:}
		;;
	esac
	rm -f $pidfile
}

pidprefix="/var/run/fcgiwrap/fcgiwrap"
pidfile="${pidprefix}.pid"  # May be a different path if profiles are in use

procname="%%PREFIX%%/sbin/${name}"
command="/usr/sbin/daemon"
start_precmd="fcgiwrap_precmd"
start_postcmd="fcgiwrap_postcmd"
stop_cmd="fcgiwrap_stop"

load_rc_config $name

# These are just the defaults, they might get overriden for a specific profile.
fcgiwrap_enable=${fcgiwrap_enable:-"NO"}
fcgiwrap_user=${fcgiwrap_user:-"nobody"}
fcgiwrap_group=${fcgiwrap_group:-"nogroup"}
fcgiwrap_socket=${fcgiwrap_socket:-"unix:/var/run/fcgiwrap/fcgiwrap.sock"}
fcgiwrap_socket_mode=${fcgiwrap_socket_mode:-"0775"}
fcgiwrap_socket_owner=${fcgiwrap_socket_owner:-"nobody"}
fcgiwrap_socket_group=${fcgiwrap_socket_group:-"nogroup"}

# This handles profile specific vars.
if [ -n "$2" ]; then
	profile="$2"
	if [ -n "${fcgiwrap_profiles}" ]; then
		pidfile="${pidprefix}.${profile}.pid"
		eval fcgiwrap_enable="\${fcgiwrap_${profile}_enable:-${fcgiwrap_enable}}"
		eval fcgiwrap_fib="\${fcgiwrap_${profile}_fib:-${fcgiwrap_fib}}"
		eval fcgiwrap_user="\${fcgiwrap_${profile}_user:-${fcgiwrap_user}}"
		eval fcgiwrap_group="\${fcgiwrap_${profile}_group:-${fcgiwrap_group}}"
		eval fcgiwrap_socket="\${fcgiwrap_${profile}_socket:?}"
		eval fcgiwrap_socket_mode="\${fcgiwrap_${profile}_socket_mode:-${fcgiwrap_socket_mode}}"
		eval fcgiwrap_socket_owner="\${fcgiwrap_${profile}_socket_owner:-${fcgiwrap_socket_owner}}"
		eval fcgiwrap_socket_group="\${fcgiwrap_${profile}_socket_group:-${fcgiwrap_socket_group}}"
		eval fcgiwrap_flags="\${fcgiwrap_${profile}_flags:-${fcgiwrap_flags}}"
	else
		echo "$0: extra argument ignored"
	fi
else
	if [ -n "${fcgiwrap_profiles}" -a -n "$1" ]; then
		for profile in ${fcgiwrap_profiles}; do
			echo "===> fcgiwrap profile: ${profile}"
			/usr/local/etc/rc.d/fcgiwrap $1 ${profile}
			retcode="$?"
			if [ "0${retcode}" -ne 0 ]; then
				failed="${profile} (${retcode}) ${failed:-}"
			else
				success="${profile} ${success:-}"
			fi
		done
		# It exits so that non-profile rc.d is not started when there are profiles.
		exit 0
	fi
fi

# run_rc_command would send ${name}_flags as parameters to $command (daemon)
# This ensures they are actually passed to fcgiwrap instead.
actual_fcgiwrap_flags="${fcgiwrap_flags}"
fcgiwrap_flags=""
command_args="-f -p ${pidfile} ${procname} -s ${fcgiwrap_socket} ${actual_fcgiwrap_flags}"
fcgiwrap_saved_umask=$(umask)

run_rc_command "$1"
