diff -Nursrclib/apr/configure.in srclib/apr/configure.in
--- srclib/apr/configure.in	Thu May 27 21:12:47 2004
+++ srclib/apr/configure.in	Wed Jun 23 16:02:02 2004
@@ -596,6 +596,25 @@
 
 AC_CHECK_FUNCS(poll)
 
+# Checks for the FreeBSD KQueue and Linux epoll interfaces:
+AC_CHECK_FUNC(kevent, 
+  [AC_DEFINE([HAVE_KQUEUE], 1, [Define if the KQueue interface is supported])])
+
+# epoll* may be available in libc but return ENOSYS on a pre-2.6 kernel.
+AC_CACHE_CHECK([for epoll support], [apr_cv_epoll],
+[AC_TRY_RUN([
+#include <sys/epoll.h>
+#include <unistd.h>
+
+int main()
+{
+    return epoll_create(5) == -1;
+}], [apr_cv_epoll=yes], [apr_cv_epoll=no], [apr_cv_epoll=no])])
+
+if test "$apr_cv_epoll" = "yes"; then
+   AC_DEFINE([HAVE_EPOLL], 1, [Define if the epoll interface is supported])
+fi
+
 dnl ----------------------------- Checking for missing POSIX thread functions
 AC_CHECK_FUNCS([getpwnam_r getpwuid_r getgrnam_r getgrgid_r])
 
diff -Nursrclib/apr/poll/unix/poll.c srclib/apr/poll/unix/poll.c
--- srclib/apr/poll/unix/poll.c Sat Apr 10 21:29:52 2004
+++ srclib/apr/poll/unix/poll.c Tue Jul 13 09:43:36 2004
@@ -25,8 +25,15 @@
 #if HAVE_SYS_POLL_H
 #include <sys/poll.h>
 #endif
-#if HAVE_ALLOCA_H
-#include <alloca.h>
+
+#ifdef HAVE_KQUEUE
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+#endif
+
+#ifdef HAVE_EPOLL
+#include <sys/epoll.h>
 #endif
 
 #ifdef NETWARE
@@ -34,6 +41,63 @@
 #define HAS_PIPES(dt) (dt == APR_POLL_FILE) ? 1 : 0
 #endif
 
+#ifdef HAVE_KQUEUE
+static apr_int16_t get_kqueue_revent(apr_int16_t event, apr_int16_t flags)
+{
+    apr_int16_t rv = 0;
+
+    if (event & EVFILT_READ)
+        rv |= APR_POLLIN;
+    if (event & EVFILT_WRITE)
+        rv |= APR_POLLOUT;
+    if (flags & EV_ERROR || flags & EV_EOF)
+        rv |= APR_POLLERR;
+
+    return rv;
+}
+
+#endif
+
+#ifdef HAVE_EPOLL
+static apr_int16_t get_epoll_event(apr_int16_t event)
+{
+    apr_int16_t rv = 0;
+
+    if (event & APR_POLLIN)
+        rv |= EPOLLIN;
+    if (event & APR_POLLPRI)
+        rv |= EPOLLPRI;
+    if (event & APR_POLLOUT)
+        rv |= EPOLLOUT;
+    if (event & APR_POLLERR)
+        rv |= EPOLLERR;
+    if (event & APR_POLLHUP)
+        rv |= EPOLLHUP;
+    /* APR_POLLNVAL is not handled by epoll. */
+
+    return rv;
+}
+
+static apr_int16_t get_epoll_revent(apr_int16_t event)
+{
+    apr_int16_t rv = 0;
+
+    if (event & EPOLLIN)
+        rv |= APR_POLLIN;
+    if (event & EPOLLPRI)
+        rv |= APR_POLLPRI;
+    if (event & EPOLLOUT)
+        rv |= APR_POLLOUT;
+    if (event & EPOLLERR)
+        rv |= APR_POLLERR;
+    if (event & EPOLLHUP)
+        rv |= APR_POLLHUP;
+    /* APR_POLLNVAL is not handled by epoll. */
+
+    return rv;
+}
+#endif
+
 #ifdef HAVE_POLL    /* We can just use poll to do our socket polling. */
 
 static apr_int16_t get_event(apr_int16_t event)
@@ -284,11 +348,19 @@
 
 #endif 
 
-
 struct apr_pollset_t {
+    apr_pool_t *pool;
+
     apr_uint32_t nelts;
     apr_uint32_t nalloc;
-#ifdef HAVE_POLL
+#ifdef HAVE_KQUEUE
+    int kqueue_fd;
+    struct kevent kevent;
+    struct kevent *ke_set;
+#elif defined(HAVE_EPOLL)
+    int epoll_fd;
+    struct epoll_event *pollset;
+#elif defined(HAVE_POLL)
     struct pollfd *pollset;
 #else
     fd_set readset, writeset, exceptset;
@@ -296,18 +368,31 @@
 #endif
     apr_pollfd_t *query_set;
     apr_pollfd_t *result_set;
-    apr_pool_t *pool;
+
 #ifdef NETWARE
     int set_type;
 #endif
 };
 
+#if defined(HAVE_KQUEUE) || defined(HAVE_EPOLL)
+static apr_status_t backend_cleanup(void *p_)
+{
+    apr_pollset_t *pollset = (apr_pollset_t *)p_;
+#ifdef HAVE_KQUEUE
+    close(pollset->kqueue_fd);
+#elif defined(HAVE_EPOLL)
+    close(pollset->epoll_fd);
+#endif
+    return APR_SUCCESS;
+}
+#endif /* HAVE_KQUEUE || HAVE_EPOLL */
+
 APR_DECLARE(apr_status_t) apr_pollset_create(apr_pollset_t **pollset,
                                              apr_uint32_t size,
                                              apr_pool_t *p,
                                              apr_uint32_t flags)
 {
-#if !defined(HAVE_POLL) && defined(FD_SETSIZE)
+#if !defined(HAVE_KQUEUE) && !defined(HAVE_EPOLL) && !defined(HAVE_POLL) && defined(FD_SETSIZE)
     if (size > FD_SETSIZE) {
         *pollset = NULL;
         return APR_EINVAL;
@@ -316,7 +401,22 @@
     *pollset = apr_palloc(p, sizeof(**pollset));
     (*pollset)->nelts = 0;
     (*pollset)->nalloc = size;
-#ifdef HAVE_POLL
+    (*pollset)->pool = p;
+#ifdef HAVE_KQUEUE
+    (*pollset)->ke_set = (struct kevent*)apr_palloc(p, size * sizeof(struct  kevent));
+    memset((*pollset)->ke_set, 0, size * sizeof(struct kevent));
+    (*pollset)->kqueue_fd = kqueue();
+    if ((*pollset)->kqueue_fd == -1) {
+         return APR_ENOMEM;
+    }
+    apr_pool_cleanup_register(p, (void*)(*pollset), backend_cleanup, 
+        apr_pool_cleanup_null);
+#elif defined(HAVE_EPOLL)
+    (*pollset)->epoll_fd = epoll_create(size);
+    (*pollset)->pollset = apr_palloc(p, size * sizeof(struct epoll_event));
+    apr_pool_cleanup_register(p, (void*)(*pollset), backend_cleanup, 
+        apr_pool_cleanup_null);
+#elif defined(HAVE_POLL)
     (*pollset)->pollset = apr_palloc(p, size * sizeof(struct pollfd));
 #else
     FD_ZERO(&((*pollset)->readset));
@@ -329,23 +429,31 @@
 #endif
     (*pollset)->query_set = apr_palloc(p, size * sizeof(apr_pollfd_t));
     (*pollset)->result_set = apr_palloc(p, size * sizeof(apr_pollfd_t));
-    (*pollset)->pool = p;
+
     return APR_SUCCESS;
 }
 
 APR_DECLARE(apr_status_t) apr_pollset_destroy(apr_pollset_t *pollset)
 {
-    /* A no-op function for now.  If we later implement /dev/poll
-     * support, we'll need to close the /dev/poll fd here
-     */
+#if defined(HAVE_KQUEUE) || defined(HAVE_EPOLL)
+    return apr_pool_cleanup_run(pollset->pool, pollset, backend_cleanup);
+#else
     return APR_SUCCESS;
+#endif
 }
 
 APR_DECLARE(apr_status_t) apr_pollset_add(apr_pollset_t *pollset,
                                           const apr_pollfd_t *descriptor)
 {
-#ifndef HAVE_POLL
+#ifdef HAVE_KQUEUE
     apr_os_sock_t fd;
+#elif defined(HAVE_EPOLL)
+    struct epoll_event ev;
+    int ret = -1;
+#else
+#if !defined(HAVE_POLL)
+    apr_os_sock_t fd;
+#endif
 #endif
 
     if (pollset->nelts == pollset->nalloc) {
@@ -353,7 +461,49 @@
     }
 
     pollset->query_set[pollset->nelts] = *descriptor;
-#ifdef HAVE_POLL
+
+#ifdef HAVE_KQUEUE
+    if (descriptor->desc_type == APR_POLL_SOCKET) {
+        fd = descriptor->desc.s->socketdes;
+    }
+    else {
+        fd = descriptor->desc.f->filedes;
+    }
+
+    if (descriptor->reqevents & APR_POLLIN) {
+        EV_SET(&pollset->kevent, fd, EVFILT_READ, EV_ADD, 0, 0, NULL);
+
+        if (kevent(pollset->kqueue_fd, &pollset->kevent, 1, NULL, 0,
+                   NULL) == -1) {
+            return APR_ENOMEM;
+        }
+    }
+
+    if (descriptor->reqevents & APR_POLLOUT) {
+        EV_SET(&pollset->kevent, fd, EVFILT_WRITE, EV_ADD, 0, 0, NULL);
+
+        if (kevent(pollset->kqueue_fd, &pollset->kevent, 1, NULL, 0,
+                   NULL) == -1) {
+            return APR_ENOMEM;
+        }
+    }
+
+#elif defined(HAVE_EPOLL)
+    ev.events = get_epoll_event(descriptor->reqevents);
+    if (descriptor->desc_type == APR_POLL_SOCKET) {
+        ev.data.fd = descriptor->desc.s->socketdes;
+        ret = epoll_ctl(pollset->epoll_fd, EPOLL_CTL_ADD,
+                        descriptor->desc.s->socketdes, &ev);
+    }
+    else {
+        ev.data.fd = descriptor->desc.f->filedes;
+        ret = epoll_ctl(pollset->epoll_fd, EPOLL_CTL_ADD,
+                        descriptor->desc.f->filedes, &ev);
+    }
+    if (0 != ret) {
+        return APR_EBADF;
+    }
+#elif defined(HAVE_POLL)
 
     if (descriptor->desc_type == APR_POLL_SOCKET) {
         pollset->pollset[pollset->nelts].fd = descriptor->desc.s->socketdes;
@@ -422,11 +572,97 @@
                                              const apr_pollfd_t *descriptor)
 {
     apr_uint32_t i;
-#ifndef HAVE_POLL
+#ifdef HAVE_KQUEUE
+    apr_os_sock_t fd;
+#elif defined(HAVE_EPOLL)
+    struct epoll_event ev;
+    int ret = -1;
+#elif !defined(HAVE_POLL)
     apr_os_sock_t fd;
 #endif
 
-#ifdef HAVE_POLL
+#ifdef HAVE_KQUEUE
+    for (i = 0; i < pollset->nelts; i++) {
+        if (descriptor->desc.s == pollset->query_set[i].desc.s) {
+            /* Found an instance of the fd: remove this and any other copies  */
+            apr_uint32_t dst = i;
+            apr_uint32_t old_nelts = pollset->nelts;
+            pollset->nelts--;
+            for (i++; i < old_nelts; i++) {
+                if (descriptor->desc.s == pollset->query_set[i].desc.s) {
+                    pollset->nelts--;
+                }
+                else {
+                    pollset->query_set[dst] = pollset->query_set[i];
+                    dst++;
+                }
+            }
+
+            if (descriptor->desc_type == APR_POLL_SOCKET) {
+                fd = descriptor->desc.s->socketdes;
+            }
+            else {
+                fd = descriptor->desc.f->filedes;
+            }
+
+            if (descriptor->reqevents & APR_POLLIN) {
+                EV_SET(&pollset->kevent, fd,
+                       EVFILT_READ, EV_DELETE, 0, 0, NULL);
+
+                if (kevent(pollset->kqueue_fd, &pollset->kevent, 1, NULL, 0,
+                          NULL) == -1) {
+                    return APR_EBADF;
+                }
+            }
+
+            if (descriptor->reqevents & APR_POLLOUT) {
+                EV_SET(&pollset->kevent, fd,
+                       EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
+
+                if (kevent(pollset->kqueue_fd, &pollset->kevent, 1, NULL, 0,
+                          NULL) == -1) {
+                    return APR_EBADF;
+                }
+            }
+
+            return APR_SUCCESS;
+        }
+    }
+#elif defined(HAVE_EPOLL)
+    for (i = 0; i < pollset->nelts; i++) {
+        if (descriptor->desc.s == pollset->query_set[i].desc.s) {
+            /* Found an instance of the fd: remove this and any other copies  */
+            apr_uint32_t dst = i;
+            apr_uint32_t old_nelts = pollset->nelts;
+            pollset->nelts--;
+            for (i++; i < old_nelts; i++) {
+                if (descriptor->desc.s == pollset->query_set[i].desc.s) {
+                    pollset->nelts--;
+                }
+                else {
+                    pollset->query_set[dst] = pollset->query_set[i];
+                    dst++;
+                }
+            }
+            ev.events = get_epoll_event(descriptor->reqevents);
+            if (descriptor->desc_type == APR_POLL_SOCKET) {
+                ev.data.fd = descriptor->desc.s->socketdes;
+                ret = epoll_ctl(pollset->epoll_fd, EPOLL_CTL_DEL,
+                                descriptor->desc.s->socketdes, &ev);
+            }
+            else {
+                ev.data.fd = descriptor->desc.f->filedes;
+                ret = epoll_ctl(pollset->epoll_fd, EPOLL_CTL_DEL,
+                                descriptor->desc.f->filedes, &ev);
+            }
+            if (ret < 0) {
+                return APR_EBADF;
+            }
+
+            return APR_SUCCESS;
+        }
+    }
+#elif defined(HAVE_POLL)
     for (i = 0; i < pollset->nelts; i++) {
         if (descriptor->desc.s == pollset->query_set[i].desc.s) {
             /* Found an instance of the fd: remove this and any other copies */
@@ -487,8 +723,119 @@
 
     return APR_NOTFOUND;
 }
+#ifdef HAVE_KQUEUE
+APR_DECLARE(apr_status_t) apr_pollset_poll(apr_pollset_t *pollset,
+                                           apr_interval_time_t timeout,
+                                           apr_int32_t *num,
+                                           const apr_pollfd_t **descriptors)
+{
+    int rv;
+    apr_uint32_t i, j, r = 0;
+    struct timespec tv, *tvptr;
+
+    if (timeout < 0) {
+        tvptr = NULL;
+    }
+    else {
+        tv.tv_sec = (long)apr_time_sec(timeout);
+        tv.tv_nsec = (long)apr_time_msec(timeout);
+        tvptr = &tv;
+    }
+
+    rv = kevent(pollset->kqueue_fd, NULL, 0, pollset->ke_set, pollset->nelts,
+                tvptr);
+    (*num) = rv;
+    if (rv < 0) {
+        return apr_get_netos_error();
+    }
+    if (rv == 0) {
+        return APR_TIMEUP;
+    }
+
+    /* TODO: Is there a better way to re-associate our data? */
+    for (i = 0; i < pollset->nelts; i++) {
+        apr_os_sock_t fd;
+        if (pollset->query_set[i].desc_type == APR_POLL_SOCKET) {
+            fd = pollset->query_set[i].desc.s->socketdes;
+        }
+        else {
+            fd = pollset->query_set[i].desc.f->filedes;
+        }
+        for (j = 0; j < rv; j++) {
+            if (pollset->ke_set[j].ident == fd ) {
+                pollset->result_set[r] = pollset->query_set[i];
+                pollset->result_set[r].rtnevents =
+                    get_kqueue_revent(pollset->ke_set[j].filter,
+                                      pollset->ke_set[j].flags);
+                r++;
+            }
+        }
+    }
+
+    (*num) = r;
+
+    if (descriptors) {
+        *descriptors = pollset->result_set;
+    }
+
+    return APR_SUCCESS;
+}
+
+#elif defined(HAVE_EPOLL)
 
-#ifdef HAVE_POLL
+APR_DECLARE(apr_status_t) apr_pollset_poll(apr_pollset_t *pollset,
+                                           apr_interval_time_t timeout,
+                                           apr_int32_t *num,
+                                           const apr_pollfd_t **descriptors)
+{
+    int rv;
+    apr_uint32_t i, j, k;
+
+    if (timeout > 0) {
+        timeout /= 1000;
+    }
+
+    rv = epoll_wait(pollset->epoll_fd, pollset->pollset, pollset->nelts,
+                    timeout);
+    (*num) = rv;
+    if (rv < 0) {
+        return apr_get_netos_error();
+    }
+    if (rv == 0) {
+        return APR_TIMEUP;
+    }
+    j = 0;
+    for (i = 0; i < pollset->nelts; i++) {
+        if (pollset->pollset[i].events != 0) {
+            /* TODO: Is there a better way to re-associate our data? */
+            for (k = 0; k < pollset->nelts; k++) {
+                if (pollset->query_set[k].desc_type == APR_POLL_SOCKET &&
+                    pollset->query_set[k].desc.s->socketdes ==
+                        pollset->pollset[i].data.fd) {
+                    pollset->result_set[j] = pollset->query_set[k];
+                    pollset->result_set[j].rtnevents =
+                        get_epoll_revent(pollset->pollset[i].events);
+                    j++;
+                    break;
+                }
+                else if (pollset->query_set[k].desc_type == APR_POLL_FILE 
+                         && pollset->query_set[k].desc.f->filedes ==
+                            pollset->pollset[i].data.fd) {
+                    pollset->result_set[j] = pollset->query_set[k];
+                    pollset->result_set[j].rtnevents =
+                        get_epoll_revent(pollset->pollset[i].events);
+                    j++;
+                    break;
+                }
+            }
+        }
+    }
+    if (descriptors) {
+        *descriptors = pollset->result_set;
+    }
+    return APR_SUCCESS;
+}
+#elif defined(HAVE_POLL)
 APR_DECLARE(apr_status_t) apr_pollset_poll(apr_pollset_t *pollset,
                                            apr_interval_time_t timeout,
                                            apr_int32_t *num,
@@ -517,7 +864,8 @@
             j++;
         }
     }
-    *descriptors = pollset->result_set;
+    if (descriptors)
+        *descriptors = pollset->result_set;
     return APR_SUCCESS;
 }
 
@@ -591,7 +939,8 @@
         }
     }
 
-    *descriptors = pollset->result_set;
+    if (descriptors)
+        *descriptors = pollset->result_set;
     return APR_SUCCESS;
 }
 

