--- Makefile
+++ Makefile
@@ -236,6 +236,18 @@
 
 clean: clobber
 
+# Add location of iconv headers & libs
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    OTHER_LDLIBS += -liconv
+  else
+    ifneq ($(OS_NAME), netbsd)
+      CPPFLAGS += %%ICONV_CPPFLAGS%%
+      OTHER_LDLIBS += %%ICONV_LDFLAGS%%
+    endif
+  endif
+endif
+
 #
 # Dev builds
 #
--- corba/make/common/Defs-bsd.gmk
+++ corba/make/common/Defs-bsd.gmk
@@ -40,18 +40,12 @@
 # Get shared JDK settings
 include $(BUILDDIR)/common/shared/Defs.gmk
 
-# Part of INCREMENTAL_BUILD mechanism.
-#   Compiler emits things like:  path/file.o: file.h
-#   We want something like: relative_path/file.o relative_path/file.d: file.h
-CC_DEPEND	 = -MM
-CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
-
 ifndef PLATFORM_SRC
   PLATFORM_SRC = $(TOPDIR)/src/solaris
 endif # PLATFORM_SRC
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -94,6 +88,10 @@
 #    as the default.
 CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
@@ -176,7 +174,7 @@
   CXXFLAGS_DBG	+= $(CC_LOWER_OPT)
 endif
 
-CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -DLINUX $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -186,33 +184,16 @@
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -Xlinker -z -Xlinker defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
 LDFLAGS_OPT     = -Xlinker -O1
+
+ifneq ($(OS_VENDOR), Apple)
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
+
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -243,13 +224,9 @@
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
-#
-# Support for Quantify.
-#
-ifdef QUANTIFY
-QUANTIFY_CMD = quantify
-QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
-LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
 endif
 
 #
@@ -278,24 +255,22 @@
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
 else
-override LIBCXX                  = -lstdc++
+override LIBCXX                  = %%CXX_LDFLAGS%%
 endif
 override LIBPOSIX4               =
 override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
-override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override NO_INTERRUPTIBLE_IO     = false
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
--- corba/make/common/Defs.gmk
+++ corba/make/common/Defs.gmk
@@ -53,6 +53,24 @@
 
 _OUTPUTDIR=$(TOPDIR)/build/$(PLATFORM)-$(ARCH)
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -97,6 +115,9 @@
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
--- corba/make/common/Mapfile-vers.gmk
+++ corba/make/common/Mapfile-vers.gmk
@@ -77,7 +77,7 @@
 endif # PLATFORM
 
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 ifeq ($(VARIANT), OPT)
   # OPT build MUST have a mapfile?
--- corba/make/common/shared/Compiler-gcc.gmk
+++ corba/make/common/shared/Compiler-gcc.gmk
@@ -100,6 +100,24 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  # Settings specific to BSD
+  CC             ?= $(COMPILER_PATH)gcc
+  CPP            ?= $(COMPILER_PATH)gcc -E
+  CXX            ?= $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.3
+  REQUIRED_GCC_VER = 3.3.*
+
+# Option used to create a shared library
+ifeq ($(OS_VENDOR), Apple)
+  SHARED_LIBRARY_FLAG = -dynamiclib
+else
+  SHARED_LIBRARY_FLAG = -shared
+endif
+
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- corba/make/common/shared/Compiler.gmk
+++ corba/make/common/shared/Compiler.gmk
@@ -42,6 +42,11 @@
   override CC_VERSION = gcc
 endif
 
+# BSD uses GNU compilers by default
+ifeq ($(PLATFORM), bsd)
+  override CC_VERSION = gcc
+endif
+
 # Get the compiler specific settings
 include $(BUILDDIR)/common/shared/Compiler-$(CC_VERSION).gmk
 
--- corba/make/common/shared/Defs-bsd.gmk
+++ corba/make/common/shared/Defs-bsd.gmk
@@ -54,7 +54,7 @@
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH =$(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -107,7 +107,7 @@
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
--- corba/make/common/shared/Defs-utils.gmk
+++ corba/make/common/shared/Defs-utils.gmk
@@ -53,6 +53,13 @@
   UTILS_DEVTOOL_PATH=$(USRBIN_PATH)
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 ifeq ($(PLATFORM),solaris)
   UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
   UTILS_USR_BIN_PATH=$(UNIXCOMMAND_PATH)
@@ -199,3 +206,32 @@
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
--- corba/make/common/shared/Platform.gmk
+++ corba/make/common/shared/Platform.gmk
@@ -261,6 +261,76 @@
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+ REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+ REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586 and sparc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -408,7 +478,14 @@
 #    build machines and adjustments will be made to prevent excessing
 #    system swapping during the build.
 #    If we don't know, assume 512. Subtract 128 from MB for VM MAX.
-#    Don't set VM max over 1024-128=896.
+#    Don't set VM max over 1024-128=896, except on OpenBSD where
+#    736 is the max.
+ifeq ($(OS_VENDOR), OpenBSD)
+  ABS_MAX_MEMORY := "736"
+else
+  ABS_MAX_MEMORY := "896"
+endif
+
 ifneq ($(MB_OF_MEMORY),)
   LOW_MEMORY_MACHINE := $(shell \
     if [ $(MB_OF_MEMORY) -le 512 ] ; then \
@@ -420,7 +497,7 @@
     if [ $(MB_OF_MEMORY) -le 1024 ] ; then \
       expr $(MB_OF_MEMORY) '-' 128 ; \
     else \
-      echo "896"; \
+      echo $(ABS_MAX_MEMORY); \
     fi)
   MIN_VM_MEMORY := $(shell \
     if [ $(MAX_VM_MEMORY) -le 128 ] ; then \
--- hotspot/agent/src/os/bsd/Makefile
+++ hotspot/agent/src/os/bsd/Makefile
@@ -23,7 +23,7 @@
 #
 
 ARCH := $(shell if ([ `uname -m` = "ia64" ])  ; then echo ia64 ; elif ([ `uname -m` = "amd64" ]) ; then echo amd64; elif ([ `uname -m` = "sparc64" ]) ; then echo sparc; else echo i386 ; fi )
-GCC      = gcc
+GCC      ?= gcc
 
 JAVAH    = ${JAVA_HOME}/bin/javah
 
--- hotspot/agent/src/os/bsd/libproc_impl.c
+++ hotspot/agent/src/os/bsd/libproc_impl.c
@@ -235,6 +235,24 @@
 }
 
 // add a thread to ps_prochandle
+#ifdef __FreeBSD__
+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id) {
+   thread_info* newthr;
+   if ( (newthr = (thread_info*) calloc(1, sizeof(thread_info))) == NULL) {
+      print_debug("can't allocate memory for thread_info\n");
+      return NULL;
+   }
+
+   // initialize thread info
+   newthr->lwp_id = lwp_id;
+
+   // add new thread to the list
+   newthr->next = ph->threads;
+   ph->threads = newthr;
+   ph->num_threads++;
+   return newthr;
+}
+#else
 thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
    thread_info* newthr;
    if ( (newthr = (thread_info*) calloc(1, sizeof(thread_info))) == NULL) {
@@ -252,6 +270,7 @@
    ph->num_threads++;
    return newthr;
 }
+#endif
 
 
 // struct used for client data from thread_db callback
@@ -273,10 +292,17 @@
     return err;
   }
 
+#ifdef __FreeBSD__
+  print_debug("thread_db : lwp %d\n", ti.ti_lid);
+
+  if (ptr->callback(ptr->ph, ti.ti_lid) != true)
+    return TD_ERR;
+#else
   print_debug("thread_db : pthread %d (lwp %d)\n", ti.ti_tid, ti.ti_lid);
 
   if (ptr->callback(ptr->ph, (pthread_t)ti.ti_tid, ti.ti_lid) != true)
     return TD_ERR;
+#endif
 
   return TD_OK;
 }
--- hotspot/agent/src/os/bsd/libproc_impl.h
+++ hotspot/agent/src/os/bsd/libproc_impl.h
@@ -109,7 +109,11 @@
 void print_debug(const char* format,...);
 bool is_debug();
 
+#ifdef __FreeBSD__
+typedef bool (*thread_info_callback)(struct ps_prochandle* ph, lwpid_t lwpid);
+#else
 typedef bool (*thread_info_callback)(struct ps_prochandle* ph, pthread_t pid, lwpid_t lwpid);
+#endif
 
 // reads thread info using libthread_db and calls above callback for each thread
 bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb);
@@ -122,7 +126,11 @@
                           uintptr_t base);
 
 // adds a new thread to threads list, returns NULL on failure
+#ifdef __FreeBSD__
+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id);
+#else
 thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id);
+#endif
 
 // a test for ELF signature without using libelf
 bool is_elf_file(int fd);
--- hotspot/agent/src/os/bsd/ps_core.c
+++ hotspot/agent/src/os/bsd/ps_core.c
@@ -540,9 +540,14 @@
    prstatus_t* prstat = (prstatus_t*) buf;
    thread_info* newthr;
    print_debug("got integer regset for lwp %d\n", prstat->pr_pid);
+#ifdef __FreeBSD__
+   if((newthr = add_thread_info(ph, prstat->pr_pid)) == NULL)
+      return false;
+#else
    // we set pthread_t to -1 for core dump
    if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat->pr_pid)) == NULL)
       return false;
+#endif
 
    // copy regs
    memcpy(&newthr->regs, &prstat->pr_reg, sizeof(struct reg));
--- hotspot/agent/src/os/bsd/ps_proc.c
+++ hotspot/agent/src/os/bsd/ps_proc.c
@@ -173,9 +173,15 @@
 // -------------------------------------------------------
 
 // callback for read_thread_info
+#ifdef __FreeBSD__
+static bool add_new_thread(struct ps_prochandle* ph, lwpid_t lwp_id) {
+  return add_thread_info(ph, lwp_id) != NULL;
+}
+#else
 static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
   return add_thread_info(ph, pthread_id, lwp_id) != NULL;
 }
+#endif
 
 #if defined(__FreeBSD__) && __FreeBSD_version < 701000
 /*
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/ConnectorImpl.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/ConnectorImpl.java
@@ -217,7 +217,7 @@
     }
 
     protected void checkNativeLink(SecurityManager sm, String os) {
-        if (os.equals("SunOS") || os.equals("Linux") || os.contains("OS X")) {
+        if (os.equals("SunOS") || os.equals("Linux") || os.equals("FreeBSD") || os.contains("OS X")) {
             // link "saproc" - SA native library on SunOS, Linux, and Mac OS X
             sm.checkLink("saproc");
         } else if (os.startsWith("Windows")) {
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/SAPIDAttachingConnector.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/SAPIDAttachingConnector.java
@@ -66,7 +66,7 @@
             try {
                 // Whether the caller can perform link against SA native library?
                 checkNativeLink(sm, os);
-                if (os.equals("SunOS") || os.equals("Linux")) {
+                if (os.equals("SunOS") || os.equals("Linux") || os.equals("FreeBSD")) {
                     // Whether the caller can read /proc/<pid> file?
                     sm.checkRead("/proc/" + pid);
                 }
--- hotspot/make/bsd/makefiles/adlc.make
+++ hotspot/make/bsd/makefiles/adlc.make
@@ -69,7 +69,7 @@
 # CFLAGS_WARN holds compiler options to suppress/enable warnings.
 # Compiler warnings are treated as errors
 ifneq ($(COMPILER_WARNINGS_FATAL),false)
-  CFLAGS_WARN = -Werror
+  CFLAGS_WARN = $(WARNINGS_ARE_ERRORS)
 endif
 CFLAGS += $(CFLAGS_WARN)
 
--- hotspot/make/bsd/makefiles/build_vm_def.sh
+++ hotspot/make/bsd/makefiles/build_vm_def.sh
@@ -7,6 +7,10 @@
 NM=nm
 fi
 
-$NM --defined-only $* | awk '
-   { if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 ";" }
-   '
+$NM --defined-only $* \
+    | awk '{
+              if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 ";"
+              if ($3 ~ /^UseSharedSpaces$/) print "\t" $3 ";"
+              if ($3 ~ /^_ZN9Arguments17SharedArchivePathE$/) print "\t" $3 ";"
+          }' \
+    | sort -u
--- hotspot/make/bsd/makefiles/gcc.make
+++ hotspot/make/bsd/makefiles/gcc.make
@@ -35,8 +35,8 @@
  HOSTCXX = g++
  HOSTCC  = gcc
 else ifneq ($(OS_VENDOR), Darwin)
- CXX = g++
- CC  = gcc
+ CXX ?= g++
+ CC  ?= gcc
  HOSTCXX = $(CXX)
  HOSTCC  = $(CC)
 endif
@@ -110,12 +110,16 @@
 CFLAGS += $(VM_PICFLAG)
 CFLAGS += -fno-rtti
 CFLAGS += -fno-exceptions
-CFLAGS += -pthread
-CFLAGS += -fcheck-new
-# version 4 and above support fvisibility=hidden (matches jni_x86.h file)
-# except 4.1.2 gives pointless warnings that can't be disabled (afaik)
-ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 3 \) \))" "0"
-CFLAGS += -fvisibility=hidden
+CFLAGS += -D_REENTRANT
+ifeq ($(USE_CLANG),)
+ CFLAGS += -fcheck-new
+ # version 4 and above support fvisibility=hidden (matches jni_x86.h file)
+ # except 4.1.2 gives pointless warnings that can't be disabled (afaik)
+ ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 3 \) \))" "0"
+  CFLAGS += -fvisibility=hidden
+ endif
+else
+ CFLAGS += -fvisibility=hidden
 endif
 
 ARCHFLAG = $(ARCHFLAG/$(BUILDARCH))
@@ -163,14 +167,24 @@
   WARNINGS_ARE_ERRORS = -Werror
 endif
 
-# Except for a few acceptable ones
-# Since GCC 4.3, -Wconversion has changed its meanings to warn these implicit
-# conversions which might affect the values. To avoid that, we need to turn
-# it off explicitly. 
-ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 3 \) \))" "0"
+ifeq ($(USE_CLANG), true)
+  # However we need to clean the code up before we can unrestrictedly enable this option with Clang
+  WARNINGS_ARE_ERRORS += -Wno-logical-op-parentheses -Wno-parentheses-equality -Wno-parentheses
+  WARNINGS_ARE_ERRORS += -Wno-switch -Wno-tautological-compare
+# Not yet supported by clang in Xcode 4.6.2
+# WARNINGS_ARE_ERRORS += -Wno-tautological-constant-out-of-range-compare
+  WARNINGS_ARE_ERRORS += -Wno-delete-non-virtual-dtor -Wno-deprecated -Wno-format -Wno-dynamic-class-memaccess
+  WARNINGS_ARE_ERRORS += -Wno-return-type -Wno-empty-body
+endif 
+
 ACCEPTABLE_WARNINGS = -Wpointer-arith -Wsign-compare
-else
-ACCEPTABLE_WARNINGS = -Wpointer-arith -Wconversion -Wsign-compare
+
+ifeq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 3 \) \))" "0"
+  # Since GCC 4.3, -Wconversion has changed its meanings to warn these implicit
+  # conversions which might affect the values. Only enable it in earlier versions.
+  ifeq ($(USE_CLANG),)
+    ACCEPTABLE_WARNINGS += -Wconversion
+  endif
 endif
 
 CFLAGS_WARN/DEFAULT = $(WARNINGS_ARE_ERRORS) $(ACCEPTABLE_WARNINGS)
@@ -282,7 +296,11 @@
 DEBUG_CFLAGS/ppc   = -g
 DEBUG_CFLAGS += $(DEBUG_CFLAGS/$(BUILDARCH))
 ifeq ($(DEBUG_CFLAGS/$(BUILDARCH)),)
-DEBUG_CFLAGS += -gstabs
+  ifeq ($(USE_CLANG), true)
+    DEBUG_CFLAGS += -g
+  else
+    DEBUG_CFLAGS += -gstabs
+  endif
 endif
 
 # DEBUG_BINARIES overrides everything, use full -g debug information
--- hotspot/make/bsd/makefiles/jsig.make
+++ hotspot/make/bsd/makefiles/jsig.make
@@ -47,7 +47,7 @@
 # cause problems with interposing. See CR: 6466665
 # LFLAGS_JSIG += $(MAPFLAG:FILENAME=$(LIBJSIG_MAPFILE))
 
-LFLAGS_JSIG += -D_GNU_SOURCE -pthread $(LDFLAGS_HASH_STYLE)
+LFLAGS_JSIG += -D_GNU_SOURCE -D_REENTRANT $(LDFLAGS_HASH_STYLE)
 
 # DEBUG_BINARIES overrides everything, use full -g debug information
 ifeq ($(DEBUG_BINARIES), true)
--- hotspot/make/bsd/makefiles/mapfile-vers-debug
+++ hotspot/make/bsd/makefiles/mapfile-vers-debug
@@ -1,8 +1,4 @@
 #
-# @(#)mapfile-vers-debug	1.18 07/10/25 16:47:35
-#
-
-#
 # Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
@@ -88,7 +84,7 @@
                 JVM_EnableCompiler;
                 JVM_Exit;
                 JVM_FillInStackTrace;
-                JVM_FindClassFromCaller
+                JVM_FindClassFromCaller;
                 JVM_FindClassFromClass;
                 JVM_FindClassFromClassLoader;
                 JVM_FindClassFromBootLoader;
@@ -222,6 +218,7 @@
                 JVM_SetArrayElement;
                 JVM_SetClassSigners;
                 JVM_SetLength;
+                JVM_SetNativeThreadName;
                 JVM_SetPrimitiveArrayElement;
                 JVM_SetProtectionDomain;
                 JVM_SetSockOpt;
@@ -245,24 +242,6 @@
                 JVM_Yield;
                 JVM_handle_bsd_signal;
 
-                # Old reflection routines
-                # These do not need to be present in the product build in JDK 1.4
-                # but their code has not been removed yet because there will not
-                # be a substantial code savings until JVM_InvokeMethod and
-                # JVM_NewInstanceFromConstructor can also be removed; see
-                # reflectionCompat.hpp.
-                JVM_GetClassConstructor;
-                JVM_GetClassConstructors;
-                JVM_GetClassField;
-                JVM_GetClassFields;
-                JVM_GetClassMethod;
-                JVM_GetClassMethods;
-                JVM_GetField;
-                JVM_GetPrimitiveField;
-                JVM_NewInstance;
-                JVM_SetField;
-                JVM_SetPrimitiveField;
-
                 # debug JVM
                 JVM_AccessVMBooleanFlag;
                 JVM_AccessVMIntFlag;
--- hotspot/make/bsd/makefiles/mapfile-vers-product
+++ hotspot/make/bsd/makefiles/mapfile-vers-product
@@ -1,8 +1,4 @@
 #
-# @(#)mapfile-vers-product	1.19 08/02/12 10:56:37
-#
-
-#
 # Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
@@ -88,7 +84,7 @@
                 JVM_EnableCompiler;
                 JVM_Exit;
                 JVM_FillInStackTrace;
-                JVM_FindClassFromCaller
+                JVM_FindClassFromCaller;
                 JVM_FindClassFromClass;
                 JVM_FindClassFromClassLoader;
                 JVM_FindClassFromBootLoader;
@@ -222,6 +218,7 @@
                 JVM_SetArrayElement;
                 JVM_SetClassSigners;
                 JVM_SetLength;
+                JVM_SetNativeThreadName;
                 JVM_SetPrimitiveArrayElement;
                 JVM_SetProtectionDomain;
                 JVM_SetSockOpt;
@@ -245,24 +242,6 @@
                 JVM_Yield;
                 JVM_handle_bsd_signal;
 
-                # Old reflection routines
-                # These do not need to be present in the product build in JDK 1.4
-                # but their code has not been removed yet because there will not
-                # be a substantial code savings until JVM_InvokeMethod and
-                # JVM_NewInstanceFromConstructor can also be removed; see
-                # reflectionCompat.hpp.
-                JVM_GetClassConstructor;
-                JVM_GetClassConstructors;
-                JVM_GetClassField;
-                JVM_GetClassFields;
-                JVM_GetClassMethod;
-                JVM_GetClassMethods;
-                JVM_GetField;
-                JVM_GetPrimitiveField;
-                JVM_NewInstance;
-                JVM_SetField;
-                JVM_SetPrimitiveField;
-
                 # miscellaneous functions
                 jio_fprintf;
                 jio_printf;
--- hotspot/make/bsd/makefiles/rules.make
+++ hotspot/make/bsd/makefiles/rules.make
@@ -126,8 +126,8 @@
 RUN.JAR$(MAKE_VERBOSE) += >/dev/null
 
 # Settings for javac
-BOOT_SOURCE_LANGUAGE_VERSION = 6
-BOOT_TARGET_CLASS_VERSION = 6
+BOOT_SOURCE_LANGUAGE_VERSION = 5
+BOOT_TARGET_CLASS_VERSION = 5
 JAVAC_FLAGS = -g -encoding ascii
 BOOTSTRAP_JAVAC_FLAGS = $(JAVAC_FLAGS) -source $(BOOT_SOURCE_LANGUAGE_VERSION) -target $(BOOT_TARGET_CLASS_VERSION)
 
--- hotspot/src/cpu/x86/vm/assembler_x86.cpp
+++ hotspot/src/cpu/x86/vm/assembler_x86.cpp
@@ -4087,7 +4087,7 @@
 }
 
 void Assembler::adcq(Register dst, Register src) {
-  (int) prefixq_and_encode(dst->encoding(), src->encoding());
+  (void) prefixq_and_encode(dst->encoding(), src->encoding());
   emit_arith(0x13, 0xC0, dst, src);
 }
 
@@ -4142,7 +4142,7 @@
 }
 
 void Assembler::andq(Register dst, Register src) {
-  (int) prefixq_and_encode(dst->encoding(), src->encoding());
+  (void) prefixq_and_encode(dst->encoding(), src->encoding());
   emit_arith(0x23, 0xC0, dst, src);
 }
 
--- hotspot/src/cpu/x86/vm/globals_x86.hpp
+++ hotspot/src/cpu/x86/vm/globals_x86.hpp
@@ -70,11 +70,7 @@
 define_pd_global(bool, RewriteBytecodes,     true);
 define_pd_global(bool, RewriteFrequentPairs, true);
 
-#ifdef _ALLBSD_SOURCE
-define_pd_global(bool, UseMembar,            true);
-#else
 define_pd_global(bool, UseMembar,            false);
-#endif
 
 // GC Ergo Flags
 define_pd_global(intx, CMSYoungGenPerWorker, 64*M);  // default max size of CMS young gen, per GC worker thread
--- hotspot/src/cpu/x86/vm/jni_x86.h
+++ hotspot/src/cpu/x86/vm/jni_x86.h
@@ -28,7 +28,7 @@
 
 #if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
 
-#if defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2)
+#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2))
   #define JNIEXPORT     __attribute__((visibility("default")))
   #define JNIIMPORT     __attribute__((visibility("default")))
 #else
--- hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp
+++ hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp
@@ -94,7 +94,7 @@
  private:
 
 #ifdef PRODUCT
-#define inc_counter_np(counter) (0)
+#define inc_counter_np(counter) ((void)0)
 #else
   void inc_counter_np_(int& counter) {
     __ incrementl(ExternalAddress((address)&counter));
--- hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp
+++ hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp
@@ -92,7 +92,7 @@
  private:
 
 #ifdef PRODUCT
-#define inc_counter_np(counter) (0)
+#define inc_counter_np(counter) ((void)0)
 #else
   void inc_counter_np_(int& counter) {
     // This can destroy rscratch1 if counter is far from the code cache
--- hotspot/src/os/bsd/vm/globals_bsd.hpp
+++ hotspot/src/os/bsd/vm/globals_bsd.hpp
@@ -26,25 +26,19 @@
 #define OS_BSD_VM_GLOBALS_BSD_HPP
 
 //
-// Defines Bsd specific flags. They are not available on other platforms.
+// Defines BSD specific flags. They are not available on other platforms.
 //
 #define RUNTIME_OS_FLAGS(develop, develop_pd, product, product_pd, diagnostic, notproduct) \
   product(bool, UseOprofile, false,                                     \
         "enable support for Oprofile profiler")                         \
                                                                         \
-  product(bool, UseBsdPosixThreadCPUClocks, true,                     \
-          "enable fast Bsd Posix clocks where available")             \
-/*  NB: The default value of UseBsdPosixThreadCPUClocks may be        \
-    overridden in Arguments::parse_each_vm_init_arg.  */                \
-                                                                        \
-  product(bool, UseHugeTLBFS, false,                                    \
-          "Use MAP_HUGETLB for large pages")                            \
-                                                                        \
-  product(bool, UseSHM, false,                                          \
-          "Use SYSV shared memory for large pages")
+  product(bool, UseBsdPosixThreadCPUClocks, true,                       \
+          "enable fast BSD Posix clocks where available")
+/*  NB: The default value of UseBsdPosixThreadCPUClocks may be
+    overridden in Arguments::parse_each_vm_init_arg.  */
 
 //
-// Defines Bsd-specific default values. The flags are available on all
+// Defines BSD-specific default values. The flags are available on all
 // platforms, but they may have different default values on other platforms.
 //
 define_pd_global(bool, UseLargePages, false);
--- hotspot/src/os/bsd/vm/jsig.c
+++ hotspot/src/os/bsd/vm/jsig.c
@@ -140,9 +140,13 @@
 }
 
 sa_handler_t sigset(int sig, sa_handler_t disp) {
+#ifdef __FreeBSD__
+  return set_signal(sig, disp, true);
+#else
   printf("sigset() is not supported by BSD");
   exit(0);
- }
+#endif
+}
 
 static int call_os_sigaction(int sig, const struct sigaction  *act,
                              struct sigaction *oact) {
--- hotspot/src/os/bsd/vm/jvm_bsd.cpp
+++ hotspot/src/os/bsd/vm/jvm_bsd.cpp
@@ -50,6 +50,7 @@
     case INTERRUPT_SIGNAL:
     case SIGFPE:
     case SIGILL:
+    case SIGBUS:
     case SIGSEGV:
 
     /* The following signal is used by the VM to dump thread stacks unless
@@ -110,71 +111,29 @@
 JVM_END
 
 /*
-  All the defined signal names for Bsd.
+  All the defined signal names for BSD are defined by sys_signame[].
 
   NOTE that not all of these names are accepted by our Java implementation
 
   Via an existing claim by the VM, sigaction restrictions, or
   the "rules of Unix" some of these names will be rejected at runtime.
   For example the VM sets up to handle USR1, sigaction returns EINVAL for
-  STOP, and Bsd simply doesn't allow catching of KILL.
+  STOP, and BSD simply doesn't allow catching of KILL.
 
   Here are the names currently accepted by a user of sun.misc.Signal with
   1.4.1 (ignoring potential interaction with use of chaining, etc):
 
-    HUP, INT, TRAP, ABRT, IOT, BUS, USR2, PIPE, ALRM, TERM, STKFLT,
-    CLD, CHLD, CONT, TSTP, TTIN, TTOU, URG, XCPU, XFSZ, VTALRM, PROF,
-    WINCH, POLL, IO, PWR, SYS
-
+      HUP, INT, TRAP, ABRT, EMT, SYS, PIPE, ALRM, TERM, URG, TSTP, CONT,
+      CHLD, TTIN, TTOU, IO, XCPU, XFSZ, VTALRM, PROF, WINCH, INFO, USR2
 */
 
-struct siglabel {
-  const char *name;
-  int   number;
-};
-
-struct siglabel siglabels[] = {
-  /* derived from /usr/include/bits/signum.h on RH7.2 */
-   "HUP",       SIGHUP,         /* Hangup (POSIX).  */
-  "INT",        SIGINT,         /* Interrupt (ANSI).  */
-  "QUIT",       SIGQUIT,        /* Quit (POSIX).  */
-  "ILL",        SIGILL,         /* Illegal instruction (ANSI).  */
-  "TRAP",       SIGTRAP,        /* Trace trap (POSIX).  */
-  "ABRT",       SIGABRT,        /* Abort (ANSI).  */
-  "EMT",        SIGEMT,         /* EMT trap  */
-  "FPE",        SIGFPE,         /* Floating-point exception (ANSI).  */
-  "KILL",       SIGKILL,        /* Kill, unblockable (POSIX).  */
-  "BUS",        SIGBUS,         /* BUS error (4.2 BSD).  */
-  "SEGV",       SIGSEGV,        /* Segmentation violation (ANSI).  */
-  "SYS",        SIGSYS,         /* Bad system call. Only on some Bsden! */
-  "PIPE",       SIGPIPE,        /* Broken pipe (POSIX).  */
-  "ALRM",       SIGALRM,        /* Alarm clock (POSIX).  */
-  "TERM",       SIGTERM,        /* Termination (ANSI).  */
-  "URG",        SIGURG,         /* Urgent condition on socket (4.2 BSD).  */
-  "STOP",       SIGSTOP,        /* Stop, unblockable (POSIX).  */
-  "TSTP",       SIGTSTP,        /* Keyboard stop (POSIX).  */
-  "CONT",       SIGCONT,        /* Continue (POSIX).  */
-  "CHLD",       SIGCHLD,        /* Child status has changed (POSIX).  */
-  "TTIN",       SIGTTIN,        /* Background read from tty (POSIX).  */
-  "TTOU",       SIGTTOU,        /* Background write to tty (POSIX).  */
-  "IO",         SIGIO,          /* I/O now possible (4.2 BSD).  */
-  "XCPU",       SIGXCPU,        /* CPU limit exceeded (4.2 BSD).  */
-  "XFSZ",       SIGXFSZ,        /* File size limit exceeded (4.2 BSD).  */
-  "VTALRM",     SIGVTALRM,      /* Virtual alarm clock (4.2 BSD).  */
-  "PROF",       SIGPROF,        /* Profiling alarm clock (4.2 BSD).  */
-  "WINCH",      SIGWINCH,       /* Window size change (4.3 BSD, Sun).  */
-  "INFO",       SIGINFO,        /* Information request.  */
-  "USR1",       SIGUSR1,        /* User-defined signal 1 (POSIX).  */
-  "USR2",       SIGUSR2         /* User-defined signal 2 (POSIX).  */
-  };
-
 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
 
   /* find and return the named signal's number */
 
-  for(uint i=0; i<ARRAY_SIZE(siglabels); i++)
-    if(!strcmp(name, siglabels[i].name))
-      return siglabels[i].number;
+  for (int i = 1; i < NSIG; i++)
+    if (strcasecmp(name, sys_signame[i]) == 0)
+      return i;
 
   return -1;
 
@@ -182,11 +141,14 @@
 
 // used by os::exception_name()
 extern bool signal_name(int signo, char* buf, size_t len) {
-  for(uint i = 0; i < ARRAY_SIZE(siglabels); i++) {
-    if (signo == siglabels[i].number) {
-      jio_snprintf(buf, len, "SIG%s", siglabels[i].name);
-      return true;
-    }
-  }
-  return false;
+  if (signo <= 0 || signo >= NSIG)
+    return false;
+  char signame[8];
+  const char *s = sys_signame[signo];
+  uint i;
+  for (i = 0; i < sizeof(signame) - 1 && s[i] != '\0'; i++)
+    signame[i] = toupper(s[i]);
+  signame[i] = '\0';
+  jio_snprintf(buf, len, "SIG%s", signame);
+  return true;
 }
--- hotspot/src/os/bsd/vm/jvm_bsd.h
+++ hotspot/src/os/bsd/vm/jvm_bsd.h
@@ -112,20 +112,6 @@
 #define SHUTDOWN2_SIGNAL SIGINT
 #define SHUTDOWN3_SIGNAL SIGTERM
 
-#ifndef SIGRTMIN
-#ifdef __OpenBSD__
-#define SIGRTMIN        1
-#else
-#define SIGRTMIN        33
-#endif
-#endif
-#ifndef SIGRTMAX
-#ifdef __OpenBSD__
-#define SIGRTMAX        31
-#else
-#define SIGRTMAX        63
-#endif
-#endif
 #endif /* JVM_MD_H */
 
 #endif // OS_BSD_VM_JVM_BSD_H
--- hotspot/src/os/bsd/vm/osThread_bsd.cpp
+++ hotspot/src/os/bsd/vm/osThread_bsd.cpp
@@ -49,7 +49,7 @@
 
 void OSThread::pd_initialize() {
   assert(this != NULL, "check");
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__FreeBSD__)
   _thread_id        = 0;
 #else
   _thread_id        = NULL;
--- hotspot/src/os/bsd/vm/osThread_bsd.hpp
+++ hotspot/src/os/bsd/vm/osThread_bsd.hpp
@@ -39,7 +39,7 @@
 
  private:
 
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
 
 #ifdef __APPLE__
   thread_t  _thread_id;
@@ -70,7 +70,7 @@
   sigset_t  caller_sigmask() const       { return _caller_sigmask; }
   void    set_caller_sigmask(sigset_t sigmask)  { _caller_sigmask = sigmask; }
 
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
 #ifdef __APPLE__
   thread_t thread_id() const {
     return _thread_id;
@@ -87,8 +87,12 @@
 #endif
 #ifndef PRODUCT
   // Used for debugging, return a unique integer for each thread.
+#ifdef __FreeBSD__
+  int thread_identifier() const   { return _thread_id; }
+#else
   intptr_t thread_identifier() const   { return (intptr_t)_pthread_id; }
 #endif
+#endif
 #ifdef ASSERT
   // We expect no reposition failures so kill vm if we get one.
   //
@@ -96,7 +100,7 @@
     return false;
   }
 #endif // ASSERT
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
 #ifdef __APPLE__
   void set_thread_id(thread_t id) {
     _thread_id = id;
--- hotspot/src/os/bsd/vm/os_bsd.cpp
+++ hotspot/src/os/bsd/vm/os_bsd.cpp
@@ -94,7 +94,6 @@
 # include <sys/mman.h>
 # include <sys/stat.h>
 # include <sys/select.h>
-# include <pthread.h>
 # include <signal.h>
 # include <errno.h>
 # include <dlfcn.h>
@@ -126,11 +125,25 @@
 # include <sys/shm.h>
 #ifndef __APPLE__
 # include <link.h>
+# include <stdlib.h>
 #endif
 # include <stdint.h>
 # include <inttypes.h>
 # include <sys/ioctl.h>
 
+#ifdef __FreeBSD__
+#if __FreeBSD_version > 700109
+#include <sys/cpuset.h>
+#endif
+#include <vm/swap_pager.h>
+#include <vm/vm_param.h>
+#if __FreeBSD_version > 900030
+#include <pthread_np.h>
+#else
+extern "C" int thr_self(long *); // XXX #include <sys/thr.h>
+#endif
+#endif
+
 #if defined(__FreeBSD__) || defined(__NetBSD__)
 # include <elf.h>
 #endif
@@ -162,8 +175,10 @@
 #endif
 
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
 int (*os::Bsd::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
+#endif
+#ifndef _ALLBSD_SOURCE
 Mutex* os::Bsd::_createThread_lock = NULL;
 #endif
 pthread_t os::Bsd::_main_thread;
@@ -171,7 +186,11 @@
 #ifndef _ALLBSD_SOURCE
 bool os::Bsd::_is_floating_stack = false;
 bool os::Bsd::_is_NPTL = false;
+#endif
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
 bool os::Bsd::_supports_fast_thread_cpu_time = false;
+#endif
+#ifndef _ALLBSD_SOURCE
 const char * os::Bsd::_glibc_version = NULL;
 const char * os::Bsd::_libpthread_version = NULL;
 #endif
@@ -205,6 +224,28 @@
 
 julong os::Bsd::available_memory() {
 #ifdef _ALLBSD_SOURCE
+#ifdef __FreeBSD__
+  static const char *vm_stats[] = {
+    "vm.stats.vm.v_free_count",
+    "vm.stats.vm.v_cache_count",
+    "vm.stats.vm.v_inactive_count"
+  };
+  size_t size;
+  julong free_pages;
+  u_int i, npages;
+
+  for (i = 0, free_pages = 0; i < sizeof(vm_stats) / sizeof(vm_stats[0]); i++) {
+    size = sizeof(npages);
+    if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1) {
+      free_pages = 0;
+      break;
+    }
+    free_pages += npages;
+  }
+  if (free_pages > 0)
+    return free_pages * os::vm_page_size();
+  else
+#endif
   // XXXBSD: this is just a stopgap implementation
   return physical_memory() >> 2;
 #else
@@ -221,6 +262,17 @@
 }
 
 julong os::allocatable_physical_memory(julong size) {
+#ifdef _ALLBSD_SOURCE
+  struct rlimit limits;
+  getrlimit(RLIMIT_DATA, &limits);
+  if (limits.rlim_cur != RLIM_INFINITY)
+    size = MIN2(size, (julong)limits.rlim_cur);
+#ifdef RLIMIT_AS
+  getrlimit(RLIMIT_AS, &limits);
+  if (limits.rlim_cur != RLIM_INFINITY)
+    size = MIN2(size, (julong)limits.rlim_cur);
+#endif
+#endif
 #ifdef _LP64
   return size;
 #else
@@ -308,16 +360,22 @@
 #define COMPILER_VARIANT "client"
 #endif
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
 // pid_t gettid()
 //
 // Returns the kernel thread id of the currently running thread. Kernel
 // thread id is used to access /proc.
 //
-// (Note that getpid() on BsdThreads returns kernel thread id too; but
-// on NPTL, it returns the same pid for all threads, as required by POSIX.)
-//
 pid_t os::Bsd::gettid() {
+#ifdef __FreeBSD__
+#if __FreeBSD_version > 900030
+  return pthread_getthreadid_np();
+#else
+  long tid;
+  thr_self(&tid);
+  return (pid_t)tid;
+#endif
+#else
   int rslt = syscall(SYS_gettid);
   if (rslt == -1) {
      // old kernel, no NPTL support
@@ -325,6 +383,7 @@
   } else {
      return (pid_t)rslt;
   }
+#endif
 }
 
 // Most versions of bsd have a bug where the number of processors are
@@ -337,7 +396,35 @@
                      "environment on Bsd when /proc filesystem is not mounted.";
 #endif
 
-#ifdef _ALLBSD_SOURCE
+#if defined(__FreeBSD__)
+void os::Bsd::initialize_system_info() {
+  int cpu_val = sysconf(_SC_NPROCESSORS_CONF);
+  if (cpu_val >= 1)
+    set_processor_count(cpu_val);
+  else
+    set_processor_count(1);   // fallback
+
+#ifdef _SC_PHYS_PAGES
+  long phys_pages = sysconf(_SC_PHYS_PAGES);
+  if (phys_pages > 0)
+    _physical_memory = (julong)phys_pages * _page_size;
+  else
+    _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+#else
+  int mib[2];
+  size_t len;
+  u_long mem_val;
+
+  mib[0] = CTL_HW;
+  mib[1] = HW_PHYSMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+    _physical_memory = mem_val;
+  else
+    _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+#endif
+ }
+#elif defined(_ALLBSD_SOURCE)
 void os::Bsd::initialize_system_info() {
   int mib[2];
   size_t len;
@@ -452,7 +539,7 @@
  *        7: The default directories, normally /lib and /usr/lib.
  */
 #ifndef DEFAULT_LIBPATH
-#define DEFAULT_LIBPATH "/lib:/usr/lib"
+#define DEFAULT_LIBPATH "/lib:/usr/lib:%%LOCALBASE%%/lib"
 #endif
 
 #define EXTENSIONS_DIR  "/lib/ext"
@@ -997,7 +1084,7 @@
     return NULL;
   }
 
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
 #ifdef __APPLE__
   // thread_id is mach thread on macos
   osthread->set_thread_id(::mach_thread_self());
@@ -1009,6 +1096,7 @@
   // thread_id is kernel thread id (similar to Solaris LWP id)
   osthread->set_thread_id(os::Bsd::gettid());
 
+#ifndef __FreeBSD__
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
@@ -1016,6 +1104,7 @@
     }
   }
 #endif
+#endif
   // initialize signal mask for this thread
   os::Bsd::hotspot_sigmask(thread);
 
@@ -1105,7 +1194,7 @@
     // let pthread_create() pick the default value.
   }
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   // glibc guard page
   pthread_attr_setguardsize(&attr, os::Bsd::default_guard_size(thr_type));
 #endif
@@ -1194,7 +1283,7 @@
   }
 
   // Store pthread info into the OSThread
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
 #ifdef __APPLE__
   osthread->set_thread_id(::mach_thread_self());
 #else
@@ -1630,7 +1719,10 @@
 }
 #endif
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
+#ifdef __FreeBSD__
+#define sys_clock_getres       clock_getres
+#else
 #ifndef SYS_clock_getres
 
 #if defined(IA32) || defined(AMD64)
@@ -1644,6 +1736,7 @@
 #else
 #define sys_clock_getres(x,y)  ::syscall(SYS_clock_getres, x, y)
 #endif
+#endif
 
 void os::Bsd::fast_thread_clock_init() {
   if (!UseBsdPosixThreadCPUClocks) {
@@ -1814,8 +1907,10 @@
 }
 
 intx os::current_thread_id() {
-#ifdef __APPLE__
+#if defined(__APPLE__)
   return (intx)::mach_thread_self();
+#elif defined(__FreeBSD__)
+  return (intx)os::Bsd::gettid();
 #else
   return (intx)::pthread_self();
 #endif
@@ -2338,14 +2433,16 @@
 }
 
 void os::print_os_info_brief(outputStream* st) {
-  st->print("Bsd");
+  st->print("BSD");
+  st->cr();
 
   os::Posix::print_uname_info(st);
 }
 
 void os::print_os_info(outputStream* st) {
   st->print("OS:");
-  st->print("Bsd");
+  st->print("BSD");
+  st->cr();
 
   os::Posix::print_uname_info(st);
 
@@ -2363,7 +2460,23 @@
   st->print("Memory:");
   st->print(" %dk page", os::vm_page_size()>>10);
 
-#ifndef _ALLBSD_SOURCE
+#if defined(__FreeBSD__)
+  struct xswdev xsw;
+  size_t mibsize, size;
+  int mib[16], n, total = 0, used = 0;
+
+  mibsize = sizeof(mib) / sizeof(mib[0]);
+  if (sysctlnametomib("vm.swap_info", mib, &mibsize) != -1) {
+    for (n = 0; ; n++) {
+      mib[mibsize] = n;
+      size = sizeof(xsw);
+      if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+        break;
+      total += xsw.xsw_nblks;
+      used += xsw.xsw_used;
+    }
+  }
+#elif !defined(_ALLBSD_SOURCE)
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
@@ -2373,17 +2486,22 @@
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
-#ifndef _ALLBSD_SOURCE
+#if defined(__FreeBSD__)
+  st->print(", swap " UINT64_FORMAT "k",
+            ((jlong)total * os::vm_page_size()) >> 10);
+  st->print("(" UINT64_FORMAT "k free)",
+            ((jlong)(total - used) * os::vm_page_size()) >> 10);
+#elif !defined(_ALLBSD_SOURCE)
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             ((jlong)si.freeswap * si.mem_unit) >> 10);
-#endif
   st->cr();
 
   // meminfo
   st->print("\n/proc/meminfo:\n");
   _print_ascii_file("/proc/meminfo", st);
+#endif
   st->cr();
 }
 
@@ -2396,7 +2514,7 @@
 
 const char *fpe_names[] = { "FPE0", "FPE_INTDIV", "FPE_INTOVF", "FPE_FLTDIV",
                           "FPE_FLTOVF", "FPE_FLTUND", "FPE_FLTRES",
-                          "FPE_FLTINV", "FPE_FLTSUB", "FPE_FLTDEN" };
+                          "FPE_FLTINV", "FPE_FLTSUB" };
 
 const char *segv_names[] = { "SEGV0", "SEGV_MAPERR", "SEGV_ACCERR" };
 
@@ -2422,7 +2540,7 @@
     st->print(", si_addr=" PTR_FORMAT, si->si_addr);
     break;
   case SIGFPE:
-    st->print(", si_code=%d (%s)", c, c > 9 ? "" : fpe_names[c]);
+    st->print(", si_code=%d (%s)", c, c > 8 ? "" : fpe_names[c]);
     st->print(", si_addr=" PTR_FORMAT, si->si_addr);
     break;
   case SIGSEGV:
@@ -2531,10 +2649,17 @@
         jrelib_p = buf + len;
 
         // Add the appropriate library subdir
+#ifdef __APPLE__
         snprintf(jrelib_p, buflen-len, "/jre/lib");
         if (0 != access(buf, F_OK)) {
           snprintf(jrelib_p, buflen-len, "/lib");
         }
+#else
+        snprintf(jrelib_p, buflen-len, "/jre/lib/%s", cpu_arch);
+        if (0 != access(buf, F_OK)) {
+          snprintf(jrelib_p, buflen-len, "/lib/%s", cpu_arch);
+        }
+#endif
 
         // Add the appropriate client or server subdir
         len = strlen(buf);
@@ -2752,7 +2877,7 @@
       if (::write(fd, "", 1) == 1) {
         mmap(base, size,
              PROT_READ|PROT_WRITE|PROT_EXEC,
-             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
+             MAP_PRIVATE|MAP_FIXED, fd, 0);
       }
     }
     ::close(fd);
@@ -2815,7 +2940,7 @@
 }
 
 void os::free_memory(char *addr, size_t bytes, size_t alignment_hint) {
-  ::madvise(addr, bytes, MADV_DONTNEED);
+  commit_memory(addr, bytes, false);
 }
 
 void os::numa_make_global(char *addr, size_t bytes) {
@@ -2962,7 +3087,7 @@
   return ::mprotect(addr, size, PROT_NONE) == 0;
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
-                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
+                MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
 #endif
 }
@@ -2989,15 +3114,16 @@
   char * addr;
   int flags;
 
-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+  flags = MAP_PRIVATE | MAP_ANONYMOUS;
   if (fixed) {
     assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, "unaligned address");
     flags |= MAP_FIXED;
   }
 
-  // Map uncommitted pages PROT_READ and PROT_WRITE, change access
-  // to PROT_EXEC if executable when we commit the page.
-  addr = (char*)::mmap(requested_addr, bytes, PROT_READ|PROT_WRITE,
+  // Map reserved/uncommitted pages PROT_NONE so we fail early if we
+  // touch an uncommitted page. Otherwise, the read/write might
+  // succeed if we have enough swap space to back the physical page.
+  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,
                        flags, -1, 0);
 
   if (addr != MAP_FAILED) {
@@ -3242,9 +3368,11 @@
 #endif
 
 char* os::reserve_memory_special(size_t bytes, char* req_addr, bool exec) {
+#ifndef _ALLBSD_SOURCE
   // "exec" is passed in but not used.  Creating the shared image for
   // the code cache doesn't have an SHM_X executable permission to check.
   assert(UseLargePages && UseSHM, "only for SHM large pages");
+#endif
 
   key_t key = IPC_PRIVATE;
   char *addr;
@@ -3319,11 +3447,19 @@
 // with SysV SHM the entire memory region must be allocated as shared
 // memory.
 bool os::can_commit_large_page_memory() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   return UseHugeTLBFS;
+#endif
 }
 
 bool os::can_execute_large_page_memory() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   return UseHugeTLBFS;
+#endif
 }
 
 // Reserve memory at an arbitrary address, only if that area is
@@ -3652,8 +3788,8 @@
   return OS_OK;
 #else
   int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);
-  return (ret == 0) ? OS_OK : OS_ERR;
 #endif
+  return (ret == 0) ? OS_OK : OS_ERR;
 }
 
 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
@@ -4169,7 +4305,7 @@
   }
 }
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
 // This is the fastest way to get thread cpu time on Bsd.
 // Returns cpu time (user+sys) for any thread, not only for current.
 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
@@ -4186,6 +4322,7 @@
 }
 #endif
 
+#ifndef _ALLBSD_SOURCE
 /////
 // glibc on Bsd platform uses non-documented flag
 // to indicate, that some special sort of signal
@@ -4196,6 +4333,7 @@
 #undef SIGNIFICANT_SIGNAL_MASK
 #endif
 #define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
+#endif
 
 static const char* get_signal_handler_name(address handler,
                                            char* buf, int buflen) {
@@ -4220,8 +4358,10 @@
 
   sigaction(sig, NULL, &sa);
 
+#ifndef _ALLBSD_SOURCE
   // See comment for SIGNIFICANT_SIGNAL_MASK define
   sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;
+#endif
 
   st->print("%s: ", os::exception_name(sig, buf, buflen));
 
@@ -4243,7 +4383,11 @@
   // May be, handler was resetted by VMError?
   if(rh != NULL) {
     handler = rh;
+#ifdef _ALLBSD_SOURCE
+    sa.sa_flags = VMError::get_resetted_sigflags(sig);
+#else
     sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;
+#endif
   }
 
   st->print(", sa_flags="   PTR32_FORMAT, sa.sa_flags);
@@ -4318,7 +4462,9 @@
   os_sigaction(sig, (struct sigaction*)NULL, &act);
 
 
+#ifndef _ALLBSD_SOURCE
   act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;
+#endif
 
   address thisHandler = (act.sa_flags & SA_SIGINFO)
     ? CAST_FROM_FN_PTR(address, act.sa_sigaction)
@@ -4379,6 +4525,14 @@
 
 extern bool signal_name(int signo, char* buf, size_t len);
 
+#ifndef SIGRTMAX
+#ifdef __OpenBSD__
+#define SIGRTMAX        31
+#else
+#define SIGRTMAX        63
+#endif
+#endif
+
 const char* os::exception_name(int exception_code, char* buf, size_t size) {
   if (0 < exception_code && exception_code <= SIGRTMAX) {
     // signal
@@ -4448,7 +4602,7 @@
 // this is called _after_ the global arguments have been parsed
 jint os::init_2(void)
 {
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   Bsd::fast_thread_clock_init();
 #endif
 
@@ -4632,6 +4786,20 @@
 
 int os::active_processor_count() {
 #ifdef _ALLBSD_SOURCE
+#ifdef __FreeBSD__
+  int online_cpus = 0;
+#if __FreeBSD_version > 700109
+  cpuset_t mask;
+  if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(mask),
+      &mask) == 0)
+    for (u_int i = 0; i < sizeof(mask) / sizeof(long); i++)
+      online_cpus += __builtin_popcountl(((long *)&mask)[i]);
+#else
+  online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
+#endif
+  if (online_cpus > 0 && online_cpus <= _processor_count)
+    return online_cpus;
+#endif
   return _processor_count;
 #else
   // Bsd doesn't yet have a (official) notion of processor sets,
@@ -5031,7 +5199,7 @@
   return munmap(addr, bytes) == 0;
 }
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);
 
 static clockid_t thread_cpu_clockid(Thread* thread) {
@@ -5055,7 +5223,7 @@
 jlong os::current_thread_cpu_time() {
 #ifdef __APPLE__
   return os::thread_cpu_time(Thread::current(), true /* user + sys */);
-#elif !defined(_ALLBSD_SOURCE)
+#elif !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
@@ -5066,7 +5234,7 @@
 }
 
 jlong os::thread_cpu_time(Thread* thread) {
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   // consistent with what current_thread_cpu_time() returns
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
@@ -5079,7 +5247,7 @@
 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
 #ifdef __APPLE__
   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
-#elif !defined(_ALLBSD_SOURCE)
+#elif !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
@@ -5108,7 +5276,7 @@
   } else {
     return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
   }
-#elif !defined(_ALLBSD_SOURCE)
+#elif !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
@@ -5117,12 +5285,15 @@
 #endif
 }
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
 //
 //  -1 on error.
 //
 
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
+#ifdef __FreeBSD__
+  return -1;
+#else
   static bool proc_pid_cpu_avail = true;
   static bool proc_task_unchecked = true;
   static const char *proc_stat_path = "/proc/%d/stat";
@@ -5206,6 +5377,7 @@
   } else {
     return (jlong)user_time * (1000000000 / clock_tics_per_sec);
   }
+#endif
 }
 #endif
 
@@ -5224,7 +5396,7 @@
 }
 
 bool os::is_thread_cpu_time_supported() {
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__FreeBSD__)
   return true;
 #elif defined(_ALLBSD_SOURCE)
   return false;
@@ -5799,3 +5971,30 @@
 
     return true;
 }
+
+// Get the default path to the core file
+// Returns the length of the string
+int os::get_core_path(char *buffer, size_t bufferSize) {
+#ifdef __APPLE__
+  jio_snprintf(buffer, bufferSize, "/cores/core.%d", current_process_id());
+#else
+  const char *p = get_current_directory(buffer, bufferSize);
+
+  if (p == NULL) {
+    assert(p != NULL, "failed to get current directory");
+    return 0;
+  }
+
+  const char *q = getprogname();
+
+  if (q == NULL) {
+    assert(q != NULL, "failed to get progname");
+    return 0;
+  }
+
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/%s.core", q);
+#endif
+  return strlen(buffer);
+}
--- hotspot/src/os/bsd/vm/os_bsd.hpp
+++ hotspot/src/os/bsd/vm/os_bsd.hpp
@@ -56,9 +56,11 @@
   static int sigflags[MAXSIGNUM];
 
   static int (*_clock_gettime)(clockid_t, struct timespec *);
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
+#endif
 
+#ifndef _ALLBSD_SOURCE
   static address   _initial_thread_stack_bottom;
   static uintptr_t _initial_thread_stack_size;
 
@@ -67,6 +69,8 @@
 
   static bool _is_floating_stack;
   static bool _is_NPTL;
+#endif
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   static bool _supports_fast_thread_cpu_time;
 #endif
 
@@ -112,13 +116,15 @@
 #endif
   static pthread_t main_thread(void)                                { return _main_thread; }
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   // returns kernel thread id (similar to LWP id on Solaris), which can be
   // used to access /proc
   static pid_t gettid();
+#ifndef _ALLBSD_SOURCE
   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }
   static Mutex* createThread_lock(void)                             { return _createThread_lock; }
 #endif
+#endif
   static void hotspot_sigmask(Thread* thread);
 
 #ifndef _ALLBSD_SOURCE
@@ -197,12 +203,12 @@
   // Real-time clock functions
   static void clock_init(void);
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   // fast POSIX clocks support
   static void fast_thread_clock_init(void);
 #endif
 
-  static bool supports_monotonic_clock() {
+  static inline bool supports_monotonic_clock() {
     return _clock_gettime != NULL;
   }
 
@@ -210,7 +216,7 @@
     return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;
   }
 
-#ifndef _ALLBSD_SOURCE
+#if !defined(_ALLBSD_SOURCE) || defined(__FreeBSD__)
   static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {
     return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;
   }
--- hotspot/src/os/bsd/vm/perfMemory_bsd.cpp
+++ hotspot/src/os/bsd/vm/perfMemory_bsd.cpp
@@ -303,7 +303,6 @@
   DIR *dirp = NULL;
   RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);
   if (result == OS_ERR) {
-    // Directory doesn't exist or is a symlink, so there is nothing to cleanup.
     if (PrintMiscellaneous && Verbose) {
       if (errno == ELOOP) {
         warning("directory %s is a symlink and is not secure\n", dirname);
@@ -420,6 +419,7 @@
   return true;
 }
 
+
 // return the user name for the given user id
 //
 // the caller is expected to free the allocated memory.
@@ -542,6 +542,18 @@
       continue;
     }
 
+    // Since we don't create the backing store files in directories
+    // pointed to by symbolic links, we also don't follow them when
+    // looking for the files. We check for a symbolic link after the
+    // call to opendir in order to eliminate a small window where the
+    // symlink can be exploited.
+    //
+    if (!is_directory_secure(usrdir_name)) {
+      FREE_C_HEAP_ARRAY(char, usrdir_name);
+      os::closedir(subdirp);
+      continue;
+    }
+
     struct dirent* udentry;
     char* udbuf = NEW_C_HEAP_ARRAY(char, os::readdir_buf_size(usrdir_name));
     errno = 0;
@@ -643,6 +655,7 @@
   }
 }
 
+
 // cleanup stale shared memory resources
 //
 // This method attempts to remove all stale shared memory files in
@@ -655,7 +668,7 @@
 static void cleanup_sharedmem_resources(const char* dirname) {
 
   int saved_cwd_fd;
-  // open the directory and set the current working directory to it
+  // open the directory
   DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);
   if (dirp == NULL) {
     // directory doesn't exist or is insecure, so there is nothing to cleanup
@@ -681,7 +694,6 @@
     if (pid == 0) {
 
       if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
-
         // attempt to remove all unexpected files, except "." and ".."
         unlink(entry->d_name);
       }
@@ -705,7 +717,6 @@
     //
     if ((pid == os::current_process_id()) ||
         (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {
-
         unlink(entry->d_name);
     }
     errno = 0;
@@ -914,7 +925,6 @@
 
   char* dirname = get_user_tmp_dir(user_name);
   char* filename = get_sharedmem_filename(dirname, vmid);
-
   // get the short filename
   char* short_filename = strrchr(filename, '/');
   if (short_filename == NULL) {
--- hotspot/src/os/bsd/vm/threadCritical_bsd.cpp
+++ hotspot/src/os/bsd/vm/threadCritical_bsd.cpp
@@ -33,35 +33,36 @@
 // See threadCritical.hpp for details of this class.
 //
 
-static pthread_t             tc_owner = 0;
-static pthread_mutex_t       tc_mutex = PTHREAD_MUTEX_INITIALIZER;
-static int                   tc_count = 0;
+static pthread_mutex_t       tc_mutex;
+static pthread_mutexattr_t   tc_attr;
+static bool                  initialized = false;
 
 void ThreadCritical::initialize() {
+  int ret;
+  ret = pthread_mutexattr_init(&tc_attr);
+  guarantee(ret == 0, "fatal error with pthread_mutexattr_init()");
+  ret = pthread_mutexattr_settype(&tc_attr, PTHREAD_MUTEX_RECURSIVE);
+  guarantee(ret == 0, "fatal error with pthread_mutexattr_settype()");
+  ret = pthread_mutex_init(&tc_mutex, &tc_attr);
+  guarantee(ret == 0, "fatal error with pthread_mutex_init()");
+  initialized = true;
 }
 
 void ThreadCritical::release() {
+  pthread_mutex_destroy(&tc_mutex);
+  pthread_mutexattr_destroy(&tc_attr);
 }
 
 ThreadCritical::ThreadCritical() {
-  pthread_t self = pthread_self();
-  if (self != tc_owner) {
-    int ret = pthread_mutex_lock(&tc_mutex);
-    guarantee(ret == 0, "fatal error with pthread_mutex_lock()");
-    assert(tc_count == 0, "Lock acquired with illegal reentry count.");
-    tc_owner = self;
-  }
-  tc_count++;
+  if (initialized)
+    pthread_mutex_lock(&tc_mutex);
+  else
+    assert(Threads::number_of_threads() == 0, "valid only during initialization");
 }
 
 ThreadCritical::~ThreadCritical() {
-  assert(tc_owner == pthread_self(), "must have correct owner");
-  assert(tc_count > 0, "must have correct count");
-
-  tc_count--;
-  if (tc_count == 0) {
-    tc_owner = 0;
-    int ret = pthread_mutex_unlock(&tc_mutex);
-    guarantee(ret == 0, "fatal error with pthread_mutex_unlock()");
-  }
+  if (initialized)
+    pthread_mutex_unlock(&tc_mutex);
+  else
+    assert(Threads::number_of_threads() == 0, "valid only during initialization");
 }
--- hotspot/src/os/bsd/vm/vmError_bsd.cpp
+++ hotspot/src/os/bsd/vm/vmError_bsd.cpp
@@ -33,30 +33,50 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <signal.h>
+#ifdef __FreeBSD__
+#include <limits.h>
+#include <sys/sysctl.h>
+#endif
+
+#define GDB_CMD "gdb"
+
+static void set_debugger(char *buf, int buflen) {
+  int pid = os::current_process_id();
+#ifdef __FreeBSD__
+  char cmd[PATH_MAX+1];
+  int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, pid };
+  size_t len = sizeof(cmd);
+  if (sysctl(name, 4, cmd, &len, NULL, 0) == 0 && len > 0) {
+    cmd[len] = '\0';
+    jio_snprintf(buf, buflen, "%s %s %d", GDB_CMD, cmd, pid);
+  } else
+#endif
+  jio_snprintf(buf, buflen, "%s /proc/%d/file %d", GDB_CMD, pid, pid);
+}
 
 void VMError::show_message_box(char *buf, int buflen) {
   bool yes;
   do {
-    error_string(buf, buflen);
-    int len = (int)strlen(buf);
+    intx tid = os::current_thread_id();
+    set_debugger(buf, buflen);
+    int len = (int)strlen(buf) + 1;
+    char *msg = &buf[len];
+    error_string(msg, buflen - len);
+    len += (int)strlen(msg);
     char *p = &buf[len];
 
     jio_snprintf(p, buflen - len,
                "\n\n"
                "Do you want to debug the problem?\n\n"
-               "To debug, run 'gdb /proc/%d/exe %d'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
-               "Enter 'yes' to launch gdb automatically (PATH must include gdb)\n"
+               "To debug, run '%s'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
+               "Enter 'yes' to launch " GDB_CMD " automatically (PATH must include " GDB_CMD ")\n"
                "Otherwise, press RETURN to abort...",
-               os::current_process_id(), os::current_process_id(),
-               os::current_thread_id(), os::current_thread_id());
+               buf, tid, tid);
 
-    yes = os::message_box("Unexpected Error", buf);
+    yes = os::message_box("Unexpected Error", msg);
 
     if (yes) {
       // yes, user asked VM to launch debugger
-      jio_snprintf(buf, buflen, "gdb /proc/%d/exe %d",
-                   os::current_process_id(), os::current_process_id());
-
       os::fork_and_exec(buf);
       yes = false;
     }
--- hotspot/src/os/posix/launcher/java_md.c
+++ hotspot/src/os/posix/launcher/java_md.c
@@ -35,6 +35,9 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifdef __FreeBSD__
+#include <sys/sysctl.h>
+#endif
 
 #ifndef GAMMA
 #include "manifest_info.h"
@@ -96,8 +99,8 @@
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __linux__
-static const char *system_dir   = "/usr/java";
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+static const char *system_dir   = "%%JAVA_HOME%%";
 static const char *user_dir     = "/java";
 #else /* Solaris */
 static const char *system_dir   = "/usr/jdk";
@@ -526,7 +529,7 @@
        * LD_LIBRARY_PATH.  Note that this prevents any possible infinite
        * loop of execv() because we test for the prefix, above.
        */
-      if (runpath != 0) {
+      if (runpath != 0 && runpath[0] != '\0') {
         strcat(new_runpath, ":");
         strcat(new_runpath, runpath);
       }
@@ -1002,7 +1005,17 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__sun && !__linux */
+#elif defined(__FreeBSD__)
+    {
+        char buf[PATH_MAX+1];
+        int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+        size_t len = sizeof(buf);
+        if (sysctl(name, 4, buf, &len, NULL, 0) == 0 && len > 0) {
+            buf[len] = '\0';
+            exec_path = JLI_StringDup(buf);
+        }
+    }
+#else /* !__sun && !__linux && !__FreeBSD__ */
     {
         /* Not implemented */
     }
@@ -1100,6 +1113,7 @@
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+#ifdef _SC_PHYS_PAGES
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
   const uint64_t result    = pages * page_size;
@@ -1111,6 +1125,28 @@
            "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   }
+#else
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+  uint64_t result;
+# define UINT64_FORMAT "%" PRIu64
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+       physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  if (_launcher_debug) {
+    printf("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  }
+#endif
   return result;
 }
 
@@ -1271,7 +1307,7 @@
 #endif
 }
 
-#endif /* __linux__ && i586 */
+#endif /* (__linux__ || _ALLBSD_SOURCE) && i586 */
 
 #ifdef i586
 /*
@@ -1450,7 +1486,7 @@
 
 #endif /* __sun && i586 */
 
-#if defined(__linux__) && defined(i586)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(i586)
 
 /* The definition of a server-class machine for linux-i586 */
 jboolean
@@ -1481,7 +1517,7 @@
   return result;
 }
 
-#endif /* __linux__ && i586 */
+#endif /* (__linux__ || _ALLBSD_SOURCE) && i586 */
 
 #if defined(_ALLBSD_SOURCE) && defined(i586)
 
@@ -1508,7 +1544,7 @@
     }
   }
   if (_launcher_debug) {
-    printf("linux_" LIBARCHNAME "_ServerClassMachine: %s\n",
+    printf("bsd_" LIBARCHNAME "_ServerClassMachine: %s\n",
            (result == JNI_TRUE ? "true" : "false"));
   }
   return result;
@@ -1672,7 +1708,7 @@
     while (dp != NULL) {
         cp = strchr(dp, (int)':');
         if (cp != NULL)
-            *cp = (char)NULL;
+            *cp = '\0';
         if ((target = ProcessDir(info, dp)) != NULL)
             break;
         dp = cp;
@@ -1931,8 +1967,8 @@
 #define MAX_PID_STR_SZ   20
 
 void SetJavaLauncherPlatformProps() {
-   /* Linux only */
-#ifdef __linux__
+   /* Linux and BSDs only */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     const char *substr = "-Dsun.java.launcher.pid=";
     char *pid_prop_str = (char *)JLI_MemAlloc(strlen(substr) + MAX_PID_STR_SZ + 1);
     sprintf(pid_prop_str, "%s%d", substr, getpid());
--- hotspot/src/os/posix/vm/os_posix.cpp
+++ hotspot/src/os/posix/vm/os_posix.cpp
@@ -33,19 +33,18 @@
 
 // Check core dump limit and report possible place where core can be found
 void os::check_or_create_dump(void* exceptionRecord, void* contextRecord, char* buffer, size_t bufferSize) {
+  int n;
   struct rlimit rlim;
-  static char cwd[O_BUFLEN];
   bool success;
 
-  get_current_directory(cwd, sizeof(cwd));
+  n = get_core_path(buffer, bufferSize);
 
   if (getrlimit(RLIMIT_CORE, &rlim) != 0) {
-    jio_snprintf(buffer, bufferSize, "%s/core or core.%d (may not exist)", cwd, current_process_id());
+    jio_snprintf(buffer + n, bufferSize - n, " (may not exist)");
     success = true;
   } else {
     switch(rlim.rlim_cur) {
       case RLIM_INFINITY:
-        jio_snprintf(buffer, bufferSize, "%s/core or core.%d", cwd, current_process_id());
         success = true;
         break;
       case 0:
@@ -53,7 +52,7 @@
         success = false;
         break;
       default:
-        jio_snprintf(buffer, bufferSize, "%s/core or core.%d (max size %lu kB). To ensure a full core dump, try \"ulimit -c unlimited\" before starting Java again", cwd, current_process_id(), (unsigned long)(rlim.rlim_cur >> 10));
+        jio_snprintf(buffer + n, bufferSize - n, " (max size %lu kB). To ensure a full core dump, try \"ulimit -c unlimited\" before starting Java again", (unsigned long)(rlim.rlim_cur >> 10));
         success = true;
         break;
     }
--- hotspot/src/os_cpu/bsd_x86/vm/globals_bsd_x86.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/globals_bsd_x86.hpp
@@ -42,7 +42,6 @@
 #endif // AMD64
 
 define_pd_global(intx, CompilerThreadStackSize,  0);
-define_pd_global(intx, SurvivorRatio,            8);
 
 define_pd_global(uintx, JVMInvokeMethodSlack,    8192);
 
--- hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp
@@ -29,8 +29,10 @@
 // constants required by the Serviceability Agent. This file is
 // referenced by vmStructs.cpp.
 
-#ifdef __APPLE__
+#if defined(__APPLE__)
 #define OS_THREAD_ID_TYPE thread_t
+#elif defined(__FreeBSD__)
+#define OS_THREAD_ID_TYPE pid_t
 #else
 #define OS_THREAD_ID_TYPE pthread_t
 #endif
@@ -46,17 +48,31 @@
   last_entry()
 
 
+#ifdef __FreeBSD__
 #define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type, last_entry) \
                                                                           \
   /**********************/                                                \
   /* Posix Thread IDs   */                                                \
   /**********************/                                                \
                                                                           \
-  declare_unsigned_integer_type(thread_t)                                 \
+  declare_integer_type(pid_t)                                             \
   declare_unsigned_integer_type(pthread_t)                                \
                                                                           \
   /* This must be the last entry, and must be present */                  \
   last_entry()
+#else
+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type, last_entry) \
+                                                                          \
+  /**********************/                                                \
+  /* Posix Thread IDs   */                                                \
+  /**********************/                                                \
+                                                                          \
+  declare_unsigned_integer_type(OS_THREAD_ID_TYPE)                        \
+  declare_unsigned_integer_type(pthread_t)                                \
+                                                                          \
+  /* This must be the last entry, and must be present */                  \
+  last_entry()
+#endif
 
 #define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant, last_entry) \
                                                                         \
--- hotspot/src/share/vm/adlc/arena.cpp
+++ hotspot/src/share/vm/adlc/arena.cpp
@@ -24,7 +24,7 @@
 
 #include "adlc.hpp"
 
-void* Chunk::operator new(size_t requested_size, size_t length) {
+void* Chunk::operator new(size_t requested_size, size_t length) throw() {
   return CHeapObj::operator new(requested_size + length);
 }
 
@@ -163,7 +163,7 @@
 //-----------------------------------------------------------------------------
 // CHeapObj
 
-void* CHeapObj::operator new(size_t size){
+void* CHeapObj::operator new(size_t size) throw() {
   return (void *) malloc(size);
 }
 
--- hotspot/src/share/vm/adlc/arena.hpp
+++ hotspot/src/share/vm/adlc/arena.hpp
@@ -42,7 +42,7 @@
 
 class CHeapObj {
  public:
-  void* operator new(size_t size);
+  void* operator new(size_t size) throw();
   void  operator delete(void* p);
   void* new_array(size_t size);
 };
@@ -53,7 +53,7 @@
 
 class ValueObj {
  public:
-  void* operator new(size_t size);
+  void* operator new(size_t size) throw();
   void operator delete(void* p);
 };
 
@@ -61,7 +61,7 @@
 
 class AllStatic {
  public:
-  void* operator new(size_t size);
+  void* operator new(size_t size) throw();
   void operator delete(void* p);
 };
 
@@ -70,7 +70,7 @@
 // Linked list of raw memory chunks
 class Chunk: public CHeapObj {
  public:
-  void* operator new(size_t size, size_t length);
+  void* operator new(size_t size, size_t length) throw();
   void  operator delete(void* p, size_t length);
   Chunk(size_t length);
 
--- hotspot/src/share/vm/adlc/main.cpp
+++ hotspot/src/share/vm/adlc/main.cpp
@@ -508,7 +508,7 @@
 
 // VS2005 has its own definition, identical to this one.
 #if !defined(_WIN32) || defined(_WIN64) || _MSC_VER < 1400
-void *operator new( size_t size, int, const char *, int ) {
+void *operator new( size_t size, int, const char *, int ) throw() {
   return ::operator new( size );
 }
 #endif
--- hotspot/src/share/vm/asm/codeBuffer.hpp
+++ hotspot/src/share/vm/asm/codeBuffer.hpp
@@ -290,7 +290,7 @@
   // CodeBuffers must be allocated on the stack except for a single
   // special case during expansion which is handled internally.  This
   // is done to guarantee proper cleanup of resources.
-  void* operator new(size_t size) { return ResourceObj::operator new(size); }
+  void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }
   void  operator delete(void* p)  { ShouldNotCallThis(); }
 
  public:
--- hotspot/src/share/vm/c1/c1_Compilation.hpp
+++ hotspot/src/share/vm/c1/c1_Compilation.hpp
@@ -263,8 +263,8 @@
 // Base class for objects allocated by the compiler in the compilation arena
 class CompilationResourceObj ALLOCATION_SUPER_CLASS_SPEC {
  public:
-  void* operator new(size_t size) { return Compilation::current()->arena()->Amalloc(size); }
-  void* operator new(size_t size, Arena* arena) {
+  void* operator new(size_t size) throw() { return Compilation::current()->arena()->Amalloc(size); }
+  void* operator new(size_t size, Arena* arena) throw() {
     return arena->Amalloc(size);
   }
   void  operator delete(void* p) {} // nothing to do
--- hotspot/src/share/vm/c1/c1_IR.cpp
+++ hotspot/src/share/vm/c1/c1_IR.cpp
@@ -499,7 +499,7 @@
   _loop_map(0, 0),          // initialized later with correct size
   _compilation(c)
 {
-  TRACE_LINEAR_SCAN(2, "***** computing linear-scan block order");
+  TRACE_LINEAR_SCAN(2, tty->print_cr("***** computing linear-scan block order"));
 
   init_visited();
   count_edges(start_block, NULL);
@@ -665,7 +665,7 @@
 }
 
 void ComputeLinearScanOrder::assign_loop_depth(BlockBegin* start_block) {
-  TRACE_LINEAR_SCAN(3, "----- computing loop-depth and weight");
+  TRACE_LINEAR_SCAN(3, tty->print_cr("----- computing loop-depth and weight"));
   init_visited();
 
   assert(_work_list.is_empty(), "work list must be empty before processing");
@@ -839,7 +839,7 @@
 }
 
 void ComputeLinearScanOrder::compute_order(BlockBegin* start_block) {
-  TRACE_LINEAR_SCAN(3, "----- computing final block order");
+  TRACE_LINEAR_SCAN(3, tty->print_cr("----- computing final block order"));
 
   // the start block is always the first block in the linear scan order
   _linear_scan_order = new BlockList(_num_blocks);
--- hotspot/src/share/vm/c1/c1_Instruction.hpp
+++ hotspot/src/share/vm/c1/c1_Instruction.hpp
@@ -311,7 +311,7 @@
   }
 
  public:
-  void* operator new(size_t size) {
+  void* operator new(size_t size) throw() {
     Compilation* c = Compilation::current();
     void* res = c->arena()->Amalloc(size);
     ((Instruction*)res)->_id = c->get_next_id();
@@ -1529,7 +1529,7 @@
   friend class SuxAndWeightAdjuster;
 
  public:
-   void* operator new(size_t size) {
+   void* operator new(size_t size) throw() {
     Compilation* c = Compilation::current();
     void* res = c->arena()->Amalloc(size);
     ((BlockBegin*)res)->_id = c->get_next_id();
--- hotspot/src/share/vm/ci/ciUtilities.hpp
+++ hotspot/src/share/vm/ci/ciUtilities.hpp
@@ -93,7 +93,7 @@
     CLEAR_PENDING_EXCEPTION;                     \
     return (result);                             \
   }                                              \
-  (0
+  (void)(0
 
 #define KILL_COMPILE_ON_ANY                      \
   THREAD);                                       \
@@ -101,7 +101,7 @@
     fatal("unhandled ci exception");             \
     CLEAR_PENDING_EXCEPTION;                     \
   }                                              \
-(0
+(void)(0
 
 
 inline const char* bool_to_str(bool b) {
--- hotspot/src/share/vm/classfile/verifier.hpp
+++ hotspot/src/share/vm/classfile/verifier.hpp
@@ -84,9 +84,9 @@
 // These macros are used similarly to CHECK macros but also check
 // the status of the verifier and return if that has an error.
 #define CHECK_VERIFY(verifier) \
-  CHECK); if ((verifier)->has_error()) return; (0
+  CHECK); if ((verifier)->has_error()) return; ((void)0
 #define CHECK_VERIFY_(verifier, result) \
-  CHECK_(result)); if ((verifier)->has_error()) return (result); (0
+  CHECK_(result)); if ((verifier)->has_error()) return (result); ((void)0
 
 // A new instance of this class is created for each class being verified
 class ClassVerifier : public StackObj {
--- hotspot/src/share/vm/code/codeBlob.cpp
+++ hotspot/src/share/vm/code/codeBlob.cpp
@@ -242,7 +242,7 @@
 }
 
 
-void* BufferBlob::operator new(size_t s, unsigned size) {
+void* BufferBlob::operator new(size_t s, unsigned size) throw() {
   void* p = CodeCache::allocate(size);
   return p;
 }
@@ -344,14 +344,14 @@
 }
 
 
-void* RuntimeStub::operator new(size_t s, unsigned size) {
+void* RuntimeStub::operator new(size_t s, unsigned size) throw() {
   void* p = CodeCache::allocate(size);
   if (!p) fatal("Initial size of CodeCache is too small");
   return p;
 }
 
 // operator new shared by all singletons:
-void* SingletonBlob::operator new(size_t s, unsigned size) {
+void* SingletonBlob::operator new(size_t s, unsigned size) throw() {
   void* p = CodeCache::allocate(size);
   if (!p) fatal("Initial size of CodeCache is too small");
   return p;
--- hotspot/src/share/vm/code/codeBlob.hpp
+++ hotspot/src/share/vm/code/codeBlob.hpp
@@ -213,7 +213,7 @@
   BufferBlob(const char* name, int size);
   BufferBlob(const char* name, int size, CodeBuffer* cb);
 
-  void* operator new(size_t s, unsigned size);
+  void* operator new(size_t s, unsigned size) throw();
 
  public:
   // Creation
@@ -287,7 +287,7 @@
     bool        caller_must_gc_arguments
   );
 
-  void* operator new(size_t s, unsigned size);
+  void* operator new(size_t s, unsigned size) throw();
 
  public:
   // Creation
@@ -325,7 +325,7 @@
   friend class VMStructs;
 
  protected:
-  void* operator new(size_t s, unsigned size);
+  void* operator new(size_t s, unsigned size) throw();
 
  public:
    SingletonBlob(
--- hotspot/src/share/vm/code/debugInfoRec.cpp
+++ hotspot/src/share/vm/code/debugInfoRec.cpp
@@ -38,7 +38,7 @@
   int  _length; // number of bytes in the stream
   int  _hash;   // hash of stream bytes (for quicker reuse)
 
-  void* operator new(size_t ignore, DebugInformationRecorder* dir) {
+  void* operator new(size_t ignore, DebugInformationRecorder* dir) throw() {
     assert(ignore == sizeof(DIR_Chunk), "");
     if (dir->_next_chunk >= dir->_next_chunk_limit) {
       const int CHUNK = 100;
--- hotspot/src/share/vm/code/dependencies.cpp
+++ hotspot/src/share/vm/code/dependencies.cpp
@@ -932,7 +932,7 @@
   assert(changes.involves_context(context_type), "irrelevant dependency");
   klassOop new_type = changes.new_type();
 
-  count_find_witness_calls();
+  (void)count_find_witness_calls();
   NOT_PRODUCT(deps_find_witness_singles++);
 
   // Current thread must be in VM (not native mode, as in CI):
--- hotspot/src/share/vm/code/nmethod.cpp
+++ hotspot/src/share/vm/code/nmethod.cpp
@@ -784,7 +784,7 @@
 }
 #endif // def HAVE_DTRACE_H
 
-void* nmethod::operator new(size_t size, int nmethod_size) {
+void* nmethod::operator new(size_t size, int nmethod_size) throw() {
   // Always leave some room in the CodeCache for I2C/C2I adapters
   if (CodeCache::largest_free_block() < CodeCacheMinimumFreeSpace) return NULL;
   return CodeCache::allocate(nmethod_size);
@@ -2488,7 +2488,8 @@
                       relocation_begin()-1+ip[1]);
       for (; ip < index_end; ip++)
         tty->print_cr("  (%d ?)", ip[0]);
-      tty->print_cr("          @" INTPTR_FORMAT ": index_size=%d", ip, *ip++);
+      tty->print_cr("          @" INTPTR_FORMAT ": index_size=%d", ip, *ip);
+      ip++;
       tty->print_cr("reloc_end @" INTPTR_FORMAT ":", ip);
     }
   }
--- hotspot/src/share/vm/code/nmethod.hpp
+++ hotspot/src/share/vm/code/nmethod.hpp
@@ -263,7 +263,7 @@
           int comp_level);
 
   // helper methods
-  void* operator new(size_t size, int nmethod_size);
+  void* operator new(size_t size, int nmethod_size) throw();
 
   const char* reloc_string_for(u_char* begin, u_char* end);
   // Returns true if this thread changed the state of the nmethod or
--- hotspot/src/share/vm/code/relocInfo.hpp
+++ hotspot/src/share/vm/code/relocInfo.hpp
@@ -371,7 +371,7 @@
   // "immediate" in the prefix header word itself.  This optimization
   // is invisible outside this module.)
 
-  inline friend relocInfo prefix_relocInfo(int datalen = 0);
+  inline friend relocInfo prefix_relocInfo(int datalen);
 
  protected:
   // an immediate relocInfo optimizes a prefix with one 10-bit unsigned value
@@ -466,7 +466,7 @@
   return relocInfo(relocInfo::none, relocInfo::offset_limit() - relocInfo::offset_unit);
 }
 
-inline relocInfo prefix_relocInfo(int datalen) {
+inline relocInfo prefix_relocInfo(int datalen = 0) {
   assert(relocInfo::fits_into_immediate(datalen), "datalen in limits");
   return relocInfo(relocInfo::data_prefix_tag, relocInfo::RAW_BITS, relocInfo::datalen_tag | datalen);
 }
@@ -686,7 +686,7 @@
   }
 
  public:
-  void* operator new(size_t size, const RelocationHolder& holder) {
+  void* operator new(size_t size, const RelocationHolder& holder) throw() {
     if (size > sizeof(holder._relocbuf)) guarantee_size();
     assert((void* const *)holder.reloc() == &holder._relocbuf[0], "ptrs must agree");
     return holder.reloc();
--- hotspot/src/share/vm/code/vtableStubs.cpp
+++ hotspot/src/share/vm/code/vtableStubs.cpp
@@ -49,7 +49,7 @@
 static int num_vtable_chunks = 0;
 
 
-void* VtableStub::operator new(size_t size, int code_size) {
+void* VtableStub::operator new(size_t size, int code_size) throw() {
   assert(size == sizeof(VtableStub), "mismatched size");
   num_vtable_chunks++;
   // compute real VtableStub size (rounded to nearest word)
--- hotspot/src/share/vm/code/vtableStubs.hpp
+++ hotspot/src/share/vm/code/vtableStubs.hpp
@@ -46,7 +46,7 @@
   bool           _is_vtable_stub;    // True if vtable stub, false, is itable stub
   /* code follows here */            // The vtableStub code
 
-  void* operator new(size_t size, int code_size);
+  void* operator new(size_t size, int code_size) throw();
 
   VtableStub(bool is_vtable_stub, int index)
         : _next(NULL), _is_vtable_stub(is_vtable_stub),
--- hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.hpp
+++ hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.hpp
@@ -1858,8 +1858,9 @@
       _cm->grayRegionIfNecessary(MemRegion(_real_start_word, _real_end_word));
 
 #ifndef PRODUCT
-      if (use_local_bitmaps && verify_local_bitmaps)
-        verify();
+#if (use_local_bitmaps && verify_local_bitmaps)
+      verify();
+#endif
 #endif // PRODUCT
     } else {
       assert(_real_start_word == NULL && _real_end_word == NULL, "invariant");
--- hotspot/src/share/vm/gc_implementation/parallelScavenge/psPromotionManager.inline.hpp
+++ hotspot/src/share/vm/gc_implementation/parallelScavenge/psPromotionManager.inline.hpp
@@ -25,6 +25,7 @@
 #ifndef SHARE_VM_GC_IMPLEMENTATION_PARALLELSCAVENGE_PSPROMOTIONMANAGER_INLINE_HPP
 #define SHARE_VM_GC_IMPLEMENTATION_PARALLELSCAVENGE_PSPROMOTIONMANAGER_INLINE_HPP
 
+#include "gc_implementation/parallelScavenge/psOldGen.hpp"
 #include "gc_implementation/parallelScavenge/psPromotionManager.hpp"
 #include "gc_implementation/parallelScavenge/psScavenge.hpp"
 
--- hotspot/src/share/vm/gc_implementation/shared/gcUtil.hpp
+++ hotspot/src/share/vm/gc_implementation/shared/gcUtil.hpp
@@ -144,9 +144,9 @@
     _padded_avg(0.0), _deviation(0.0), _padding(padding) {}
 
   // Placement support
-  void* operator new(size_t ignored, void* p) { return p; }
+  void* operator new(size_t ignored, void* p) throw() { return p; }
   // Allocator
-  void* operator new(size_t size) { return CHeapObj::operator new(size); }
+  void* operator new(size_t size) throw() { return CHeapObj::operator new(size); }
 
   // Accessor
   float padded_average() const         { return _padded_avg; }
--- hotspot/src/share/vm/libadt/port.hpp
+++ hotspot/src/share/vm/libadt/port.hpp
@@ -163,7 +163,7 @@
 extern void *safe_calloc (const char *file, unsigned line, unsigned nitems, unsigned size);
 extern void *safe_realloc(const char *file, unsigned line, void *ptr, unsigned size);
 extern char *safe_strdup (const char *file, unsigned line, const char *src);
-inline void *operator new( size_t size ) { return malloc(size); }
+inline void *operator new( size_t size ) throw() { return malloc(size); }
 inline void operator delete( void *ptr ) { free(ptr); }
 #endif
 
--- hotspot/src/share/vm/memory/allocation.cpp
+++ hotspot/src/share/vm/memory/allocation.cpp
@@ -43,11 +43,11 @@
 # include "os_bsd.inline.hpp"
 #endif
 
-void* CHeapObj::operator new(size_t size){
+void* CHeapObj::operator new(size_t size) throw() {
   return (void *) AllocateHeap(size, "CHeapObj-new");
 }
 
-void* CHeapObj::operator new (size_t size, const std::nothrow_t&  nothrow_constant) {
+void* CHeapObj::operator new (size_t size, const std::nothrow_t&  nothrow_constant) throw() {
   char* p = (char*) os::malloc(size);
 #ifdef ASSERT
   if (PrintMallocFree) trace_heap_malloc(size, "CHeapObj-new", p);
@@ -59,12 +59,12 @@
  FreeHeap(p);
 }
 
-void* StackObj::operator new(size_t size)  { ShouldNotCallThis(); return 0; };
+void* StackObj::operator new(size_t size) throw() { ShouldNotCallThis(); return 0; };
 void  StackObj::operator delete(void* p)   { ShouldNotCallThis(); };
-void* _ValueObj::operator new(size_t size)  { ShouldNotCallThis(); return 0; };
+void* _ValueObj::operator new(size_t size) throw() { ShouldNotCallThis(); return 0; };
 void  _ValueObj::operator delete(void* p)   { ShouldNotCallThis(); };
 
-void* ResourceObj::operator new(size_t size, allocation_type type) {
+void* ResourceObj::operator new(size_t size, allocation_type type) throw() {
   address res;
   switch (type) {
    case C_HEAP:
@@ -311,7 +311,7 @@
 //--------------------------------------------------------------------------------------
 // Chunk implementation
 
-void* Chunk::operator new(size_t requested_size, AllocFailType alloc_failmode, size_t length) {
+void* Chunk::operator new(size_t requested_size, AllocFailType alloc_failmode, size_t length) throw() {
   // requested_size is equal to sizeof(Chunk) but in order for the arena
   // allocations to come out aligned as expected the size must be aligned
   // to expected arean alignment.
@@ -576,7 +576,7 @@
 // src/share/native/sun/awt/font/fontmanager/textcache/hsMemory.cpp::hsSoftNew
 // define CATCH_OPERATOR_NEW_USAGE if you want to use this.
 #ifdef CATCH_OPERATOR_NEW_USAGE
-void* operator new(size_t size){
+void* operator new(size_t size) throw() {
   static bool warned = false;
   if (!warned && warn_new_operator)
     warning("should not call global (default) operator new");
--- hotspot/src/share/vm/memory/allocation.hpp
+++ hotspot/src/share/vm/memory/allocation.hpp
@@ -106,8 +106,8 @@
 
 class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {
  public:
-  void* operator new(size_t size);
-  void* operator new (size_t size, const std::nothrow_t&  nothrow_constant);
+  void* operator new(size_t size) throw();
+  void* operator new (size_t size, const std::nothrow_t&  nothrow_constant) throw();
   void  operator delete(void* p);
   void* new_array(size_t size);
 };
@@ -117,7 +117,7 @@
 
 class StackObj ALLOCATION_SUPER_CLASS_SPEC {
  public:
-  void* operator new(size_t size);
+  void* operator new(size_t size) throw();
   void  operator delete(void* p);
 };
 
@@ -141,7 +141,7 @@
 //
 class _ValueObj {
  public:
-  void* operator new(size_t size);
+  void* operator new(size_t size) throw();
   void operator delete(void* p);
 };
 
@@ -163,7 +163,7 @@
   Chunk*       _next;     // Next Chunk in list
   const size_t _len;      // Size of this Chunk
  public:
-  void* operator new(size_t size, AllocFailType alloc_failmode, size_t length);
+  void* operator new(size_t size, AllocFailType alloc_failmode, size_t length) throw();
   void  operator delete(void* p);
   Chunk(size_t length);
 
@@ -392,19 +392,19 @@
 #endif // ASSERT
 
  public:
-  void* operator new(size_t size, allocation_type type);
-  void* operator new(size_t size, Arena *arena) {
+  void* operator new(size_t size, allocation_type type) throw();
+  void* operator new(size_t size, Arena *arena) throw() {
       address res = (address)arena->Amalloc(size);
       DEBUG_ONLY(set_allocation_type(res, ARENA);)
       return res;
   }
-  void* operator new(size_t size) {
+  void* operator new(size_t size) throw() {
       address res = (address)resource_allocate_bytes(size);
       DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)
       return res;
   }
 
-  void* operator new(size_t size, const std::nothrow_t& nothrow_constant) {
+  void* operator new(size_t size, const std::nothrow_t& nothrow_constant) throw() {
     address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);
     DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)
     return res;
--- hotspot/src/share/vm/memory/cardTableModRefBS.cpp
+++ hotspot/src/share/vm/memory/cardTableModRefBS.cpp
@@ -389,7 +389,7 @@
   }
   // Touch the last card of the covered region to show that it
   // is committed (or SEGV).
-  debug_only(*byte_for(_covered[ind].last());)
+  debug_only((void) (*byte_for(_covered[ind].last()));)
   debug_only(verify_guard();)
 }
 
--- hotspot/src/share/vm/memory/memRegion.hpp
+++ hotspot/src/share/vm/memory/memRegion.hpp
@@ -99,13 +99,13 @@
 
 class MemRegionClosureRO: public MemRegionClosure {
 public:
-  void* operator new(size_t size, ResourceObj::allocation_type type) {
+  void* operator new(size_t size, ResourceObj::allocation_type type) throw() {
         return ResourceObj::operator new(size, type);
   }
-  void* operator new(size_t size, Arena *arena) {
+  void* operator new(size_t size, Arena *arena) throw() {
         return ResourceObj::operator new(size, arena);
   }
-  void* operator new(size_t size) {
+  void* operator new(size_t size) throw() {
         return ResourceObj::operator new(size);
   }
 
--- hotspot/src/share/vm/memory/universe.cpp
+++ hotspot/src/share/vm/memory/universe.cpp
@@ -657,7 +657,9 @@
   if (vt) vt->initialize_vtable(false, CHECK);
   if (ko->oop_is_instance()) {
     instanceKlass* ik = (instanceKlass*)ko;
-    for (KlassHandle s_h(THREAD, ik->subklass()); s_h() != NULL; s_h = (THREAD, s_h()->klass_part()->next_sibling())) {
+    for (KlassHandle s_h(THREAD, ik->subklass());
+         s_h() != NULL;
+         s_h = KlassHandle(THREAD, s_h()->klass_part()->next_sibling())) {
       reinitialize_vtable_of(s_h, CHECK);
     }
   }
--- hotspot/src/share/vm/oops/klass.cpp
+++ hotspot/src/share/vm/oops/klass.cpp
@@ -181,7 +181,7 @@
 }
 
 void* Klass_vtbl::operator new(size_t ignored, KlassHandle& klass,
-                               int size, TRAPS) {
+                               int size, TRAPS) throw() {
   // The vtable pointer is installed during the execution of
   // constructors in the call to permanent_obj_allocate().  Delay
   // the installation of the klass pointer into the new klass "k"
--- hotspot/src/share/vm/oops/klass.hpp
+++ hotspot/src/share/vm/oops/klass.hpp
@@ -168,7 +168,7 @@
   bool null_vtbl() { return *(intptr_t*)this == 0; }
 
  protected:
-  void* operator new(size_t ignored, KlassHandle& klass, int size, TRAPS);
+  void* operator new(size_t ignored, KlassHandle& klass, int size, TRAPS) throw();
 };
 
 
@@ -419,11 +419,11 @@
   }
   static bool layout_helper_is_typeArray(jint lh) {
     // _lh_array_tag_type_value == (lh >> _lh_array_tag_shift);
-    return (juint)lh >= (juint)(_lh_array_tag_type_value << _lh_array_tag_shift);
+    return (juint)lh >= (juint)((juint)_lh_array_tag_type_value << _lh_array_tag_shift);
   }
   static bool layout_helper_is_objArray(jint lh) {
     // _lh_array_tag_obj_value == (lh >> _lh_array_tag_shift);
-    return (jint)lh < (jint)(_lh_array_tag_type_value << _lh_array_tag_shift);
+    return (jint)lh < (jint)((juint)_lh_array_tag_type_value << _lh_array_tag_shift);
   }
   static int layout_helper_header_size(jint lh) {
     assert(lh < (jint)_lh_neutral_value, "must be array");
--- hotspot/src/share/vm/oops/symbol.cpp
+++ hotspot/src/share/vm/oops/symbol.cpp
@@ -36,7 +36,7 @@
   }
 }
 
-void* Symbol::operator new(size_t size, int len) {
+void* Symbol::operator new(size_t size, int len) throw() {
   return (void *) AllocateHeap(object_size(len) * HeapWordSize, "symbol");
 }
 
--- hotspot/src/share/vm/oops/symbol.hpp
+++ hotspot/src/share/vm/oops/symbol.hpp
@@ -121,7 +121,7 @@
   }
 
   Symbol(const u1* name, int length);
-  void* operator new(size_t size, int len);
+  void* operator new(size_t size, int len) throw();
 
  public:
   // Low-level access (used with care, since not GC-safe)
--- hotspot/src/share/vm/opto/callGenerator.hpp
+++ hotspot/src/share/vm/opto/callGenerator.hpp
@@ -240,7 +240,7 @@
   // Because WarmInfo objects live over the entire lifetime of the
   // Compile object, they are allocated into the comp_arena, which
   // does not get resource marked or reset during the compile process
-  void *operator new( size_t x, Compile* C ) { return C->comp_arena()->Amalloc(x); }
+  void *operator new( size_t x, Compile* C ) throw() { return C->comp_arena()->Amalloc(x); }
   void operator delete( void * ) { } // fast deallocation
 
   static WarmCallInfo* always_hot();
--- hotspot/src/share/vm/opto/callnode.hpp
+++ hotspot/src/share/vm/opto/callnode.hpp
@@ -215,7 +215,7 @@
   // Because JVMState objects live over the entire lifetime of the
   // Compile object, they are allocated into the comp_arena, which
   // does not get resource marked or reset during the compile process
-  void *operator new( size_t x, Compile* C ) { return C->comp_arena()->Amalloc(x); }
+  void *operator new( size_t x, Compile* C ) throw() { return C->comp_arena()->Amalloc(x); }
   void operator delete( void * ) { } // fast deallocation
 
   // Create a new JVMState, ready for abstract interpretation.
--- hotspot/src/share/vm/opto/machnode.hpp
+++ hotspot/src/share/vm/opto/machnode.hpp
@@ -58,7 +58,7 @@
 class MachOper : public ResourceObj {
 public:
   // Allocate right next to the MachNodes in the same arena
-  void *operator new( size_t x, Compile* C ) { return C->node_arena()->Amalloc_D(x); }
+  void *operator new( size_t x, Compile* C ) throw() { return C->node_arena()->Amalloc_D(x); }
 
   // Opcode
   virtual uint opcode() const = 0;
--- hotspot/src/share/vm/opto/memnode.cpp
+++ hotspot/src/share/vm/opto/memnode.cpp
@@ -1933,6 +1933,11 @@
       if (t != NULL) {
         // constant oop => constant klass
         if (offset == java_lang_Class::array_klass_offset_in_bytes()) {
+          if (t->is_void()) {
+            // We cannot create a void array. Since void is a primitive type return null
+            // klass. Users of this result need to do a null check on the returned klass.
+            return TypePtr::NULL_PTR;
+          }
           return TypeKlassPtr::make(ciArrayKlass::make(t));
         }
         if (!t->is_klass()) {
@@ -4164,7 +4169,7 @@
   }
 }
 #else // !ASSERT
-#define verify_memory_slice(m,i,n) (0)  // PRODUCT version is no-op
+#define verify_memory_slice(m,i,n) (void)(0)  // PRODUCT version is no-op
 #endif
 
 
--- hotspot/src/share/vm/opto/node.cpp
+++ hotspot/src/share/vm/opto/node.cpp
@@ -284,6 +284,10 @@
 #ifdef _MSC_VER // the IDX_INIT hack falls foul of warning C4355
 #pragma warning( disable:4355 ) // 'this' : used in base member initializer list
 #endif
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#endif
 
 // Out-of-line code from node constructors.
 // Executed only when extra debug info. is being passed around.
@@ -459,6 +463,10 @@
   _in[6] = n6; if (n6 != NULL) n6->add_out((Node *)this);
 }
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 
 //------------------------------clone------------------------------------------
 // Clone a Node.
--- hotspot/src/share/vm/opto/node.hpp
+++ hotspot/src/share/vm/opto/node.hpp
@@ -207,7 +207,7 @@
 
   // New Operator that takes a Compile pointer, this will eventually
   // be the "new" New operator.
-  inline void* operator new( size_t x, Compile* C) {
+  inline void* operator new( size_t x, Compile* C) throw() {
     Node* n = (Node*)C->node_arena()->Amalloc_D(x);
 #ifdef ASSERT
     n->_in = (Node**)n; // magic cookie for assertion check
--- hotspot/src/share/vm/opto/parse3.cpp
+++ hotspot/src/share/vm/opto/parse3.cpp
@@ -487,7 +487,8 @@
                           fun, NULL, TypeRawPtr::BOTTOM,
                           makecon(TypeKlassPtr::make(array_klass)),
                           length[0], length[1], length[2],
-                          length[3], length[4]);
+                          (ndimensions > 2) ? length[3] : NULL,
+                          (ndimensions > 3) ? length[4] : NULL);
   } else {
     // Create a java array for dimension sizes
     Node* dims = NULL;
--- hotspot/src/share/vm/opto/type.hpp
+++ hotspot/src/share/vm/opto/type.hpp
@@ -144,7 +144,7 @@
 
 public:
 
-  inline void* operator new( size_t x ) {
+  inline void* operator new( size_t x ) throw() {
     Compile* compile = Compile::current();
     compile->set_type_last_size(x);
     void *temp = compile->type_arena()->Amalloc_D(x);
--- hotspot/src/share/vm/prims/forte.cpp
+++ hotspot/src/share/vm/prims/forte.cpp
@@ -635,7 +635,7 @@
                             void* null_argument_3);
 #pragma weak collector_func_load
 #define collector_func_load(x0,x1,x2,x3,x4,x5,x6) \
-        ( collector_func_load ? collector_func_load(x0,x1,x2,x3,x4,x5,x6),0 : 0 )
+        ( collector_func_load ? collector_func_load(x0,x1,x2,x3,x4,x5,x6),(void)0 : (void)0 )
 #endif // __APPLE__
 #endif // !_WINDOWS
 
--- hotspot/src/share/vm/runtime/arguments.cpp
+++ hotspot/src/share/vm/runtime/arguments.cpp
@@ -2499,7 +2499,9 @@
          FLAG_SET_CMDLINE(uintx, MaxNewSize, NewSize);
       }
 
+#ifndef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
       FLAG_SET_DEFAULT(UseLargePages, true);
+#endif
 
       // Increase some data structure sizes for efficiency
       FLAG_SET_CMDLINE(uintx, BaseFootPrintEstimate, MaxHeapSize);
@@ -3046,6 +3048,10 @@
   UNSUPPORTED_OPTION(UseG1GC, "G1 GC");
 #endif
 
+#ifdef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
+  UNSUPPORTED_OPTION(UseLargePages, "-XX:+UseLargePages");
+#endif
+
 #ifndef PRODUCT
   if (TraceBytecodesAt != 0) {
     TraceBytecodes = true;
--- hotspot/src/share/vm/runtime/fprofiler.cpp
+++ hotspot/src/share/vm/runtime/fprofiler.cpp
@@ -264,7 +264,7 @@
 
  public:
 
-  void* operator new(size_t size, ThreadProfiler* tp);
+  void* operator new(size_t size, ThreadProfiler* tp) throw();
   void  operator delete(void* p);
 
   ProfilerNode() {
@@ -371,7 +371,7 @@
   }
 };
 
-void* ProfilerNode::operator new(size_t size, ThreadProfiler* tp){
+void* ProfilerNode::operator new(size_t size, ThreadProfiler* tp) throw() {
   void* result = (void*) tp->area_top;
   tp->area_top += size;
 
--- hotspot/src/share/vm/runtime/globals.hpp
+++ hotspot/src/share/vm/runtime/globals.hpp
@@ -1125,7 +1125,7 @@
   product(intx, hashCode, 0,                                                \
          "(Unstable) select hashCode generation algorithm" )                \
                                                                             \
-  product(intx, WorkAroundNPTLTimedWaitHang, 1,                             \
+  product(intx, WorkAroundNPTLTimedWaitHang, 0,                             \
          "(Unstable, Linux-specific)"                                       \
          " avoid NPTL-FUTEX hang pthread_cond_timedwait" )                  \
                                                                             \
--- hotspot/src/share/vm/runtime/interfaceSupport.hpp
+++ hotspot/src/share/vm/runtime/interfaceSupport.hpp
@@ -67,7 +67,7 @@
   }
 
  private:
-  inline void* operator new(size_t size, void* ptr) {
+  inline void* operator new(size_t size, void* ptr) throw() {
     return ptr;
   }
 };
--- hotspot/src/share/vm/runtime/os.hpp
+++ hotspot/src/share/vm/runtime/os.hpp
@@ -636,6 +636,10 @@
   // On Windows this will create an actual minidump, on Linux/Solaris it will simply check core dump limits
   static void check_or_create_dump(void* exceptionRecord, void* contextRecord, char* buffer, size_t bufferSize);
 
+  // Get the default path to the core file
+  // Returns the length of the string
+  static int get_core_path(char* buffer, size_t bufferSize);
+
   // JVMTI & JVM monitoring and management support
   // The thread_cpu_time() and current_thread_cpu_time() are only
   // supported if is_thread_cpu_time_supported() returns true.
--- hotspot/src/share/vm/runtime/park.cpp
+++ hotspot/src/share/vm/runtime/park.cpp
@@ -140,7 +140,7 @@
 // well as bank access imbalance on Niagara-like platforms,
 // although Niagara's hash function should help.
 
-void * ParkEvent::operator new (size_t sz) {
+void * ParkEvent::operator new (size_t sz) throw() {
   return (void *) ((intptr_t (CHeapObj::operator new (sz + 256)) + 256) & -256) ;
 }
 
--- hotspot/src/share/vm/runtime/park.hpp
+++ hotspot/src/share/vm/runtime/park.hpp
@@ -166,7 +166,7 @@
     // aligned on 256-byte address boundaries.  This ensures that the least
     // significant byte of a ParkEvent address is always 0.
 
-    void * operator new (size_t sz) ;
+    void * operator new (size_t sz) throw() ;
     void operator delete (void * a) ;
 
   public:
--- hotspot/src/share/vm/runtime/sharedRuntime.cpp
+++ hotspot/src/share/vm/runtime/sharedRuntime.cpp
@@ -2778,7 +2778,7 @@
   // ResourceObject, so do not put any ResourceMarks in here.
   char *s = sig->as_C_string();
   int len = (int)strlen(s);
-  *s++; len--;                  // Skip opening paren
+  s++; len--;                   // Skip opening paren
   char *t = s+len;
   while( *(--t) != ')' ) ;      // Find close paren
 
--- hotspot/src/share/vm/runtime/thread.cpp
+++ hotspot/src/share/vm/runtime/thread.cpp
@@ -170,7 +170,7 @@
 // ======= Thread ========
 
 // Support for forcing alignment of thread objects for biased locking
-void* Thread::operator new(size_t size) {
+void* Thread::operator new(size_t size) throw() {
   if (UseBiasedLocking) {
     const int alignment = markOopDesc::biased_lock_alignment;
     size_t aligned_size = size + (alignment - sizeof(intptr_t));
--- hotspot/src/share/vm/runtime/thread.hpp
+++ hotspot/src/share/vm/runtime/thread.hpp
@@ -104,7 +104,7 @@
   // Support for forcing alignment of thread objects for biased locking
   void*       _real_malloc_address;
  public:
-  void* operator new(size_t size);
+  void* operator new(size_t size) throw();
   void  operator delete(void* p);
  private:
 
--- hotspot/src/share/vm/services/diagnosticArgument.cpp
+++ hotspot/src/share/vm/services/diagnosticArgument.cpp
@@ -191,7 +191,7 @@
   } else {
     _value._time = 0;
     _value._nanotime = 0;
-    strcmp(_value._unit, "ns");
+    strcpy(_value._unit, "ns");
   }
 }
 
--- hotspot/src/share/vm/utilities/exceptions.hpp
+++ hotspot/src/share/vm/utilities/exceptions.hpp
@@ -182,15 +182,15 @@
 #define HAS_PENDING_EXCEPTION                    (((ThreadShadow*)THREAD)->has_pending_exception())
 #define CLEAR_PENDING_EXCEPTION                  (((ThreadShadow*)THREAD)->clear_pending_exception())
 
-#define CHECK                                    THREAD); if (HAS_PENDING_EXCEPTION) return       ; (0
-#define CHECK_(result)                           THREAD); if (HAS_PENDING_EXCEPTION) return result; (0
+#define CHECK                                    THREAD); if (HAS_PENDING_EXCEPTION) return       ; (void)(0
+#define CHECK_(result)                           THREAD); if (HAS_PENDING_EXCEPTION) return result; (void)(0
 #define CHECK_0                                  CHECK_(0)
 #define CHECK_NH                                 CHECK_(Handle())
 #define CHECK_NULL                               CHECK_(NULL)
 #define CHECK_false                              CHECK_(false)
 
-#define CHECK_AND_CLEAR                         THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return;        } (0
-#define CHECK_AND_CLEAR_(result)                THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return result; } (0
+#define CHECK_AND_CLEAR                         THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return;        } (void)(0
+#define CHECK_AND_CLEAR_(result)                THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return result; } (void)(0
 #define CHECK_AND_CLEAR_0                       CHECK_AND_CLEAR_(0)
 #define CHECK_AND_CLEAR_NH                      CHECK_AND_CLEAR_(Handle())
 #define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(NULL)
@@ -263,7 +263,7 @@
     CLEAR_PENDING_EXCEPTION;               \
     ex->print();                           \
     ShouldNotReachHere();                  \
-  } (0
+  } (void)(0
 
 // ExceptionMark is a stack-allocated helper class for local exception handling.
 // It is used with the EXCEPTION_MARK macro.
--- hotspot/src/share/vm/utilities/globalDefinitions.hpp
+++ hotspot/src/share/vm/utilities/globalDefinitions.hpp
@@ -421,7 +421,7 @@
 // Utility macros for compilers
 // used to silence compiler warnings
 
-#define Unused_Variable(var) var
+#define Unused_Variable(var) (void)(var)
 
 
 //----------------------------------------------------------------------------------------------------
--- hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp
+++ hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp
@@ -260,7 +260,7 @@
 #endif
 
 // GCC 4.3 does not allow 0.0/0.0 to produce a NAN value
-#if (__GNUC__ == 4) && (__GNUC_MINOR__ > 2)
+#if defined(__clang__) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 2))
 #define CAN_USE_NAN_DEFINE 1
 #endif
 
--- hotspot/src/share/vm/utilities/macros.hpp
+++ hotspot/src/share/vm/utilities/macros.hpp
@@ -177,6 +177,14 @@
 #define NOT_WIN64(code) code
 #endif
 
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
+#define BSD_ONLY(code) code
+#define NOT_BSD(code)
+#else
+#define BSD_ONLY(code)
+#define NOT_BSD(code) code
+#endif
+
 #if defined(IA32) || defined(AMD64)
 #define X86
 #define X86_ONLY(code) code
--- hotspot/src/share/vm/utilities/taskqueue.hpp
+++ hotspot/src/share/vm/utilities/taskqueue.hpp
@@ -334,8 +334,12 @@ bool GenericTaskQueue<E, N>::push_slow(E
   if (dirty_n_elems == N - 1) {
     // Actually means 0, so do the push.
     uint localBot = _bottom;
-    // g++ complains if the volatile result of the assignment is unused.
-    const_cast<E&>(_elems[localBot] = t);
+    // g++ complains if the volatile result of the assignment is
+    // unused, so we cast the volatile away.  We cannot cast directly
+    // to void, because gcc treats that as not using the result of the
+    // assignment.  However, casting to E& means that we trigger an
+    // unused-value warning.  So, we cast the E& to void.
+    (void)const_cast<E&>(_elems[localBot] = t);
     OrderAccess::release_store(&_bottom, increment_index(localBot));
     TASKQUEUE_STATS_ONLY(stats.record_push());
     return true;
@@ -385,13 +389,24 @@ bool GenericTaskQueue<E, N>::pop_local_s
 template<class E, unsigned int N>
 bool GenericTaskQueue<E, N>::pop_global(E& t) {
   Age oldAge = _age.get();
-  uint localBot = _bottom;
+  // Architectures with weak memory model require a barrier here
+  // to guarantee that bottom is not older than age,
+  // which is crucial for the correctness of the algorithm.
+#if !(defined SPARC || defined IA32 || defined AMD64)
+  OrderAccess::fence();
+#endif
+  uint localBot = OrderAccess::load_acquire((volatile juint*)&_bottom); 
   uint n_elems = size(localBot, oldAge.top());
   if (n_elems == 0) {
     return false;
   }
 
-  const_cast<E&>(t = _elems[oldAge.top()]);
+  // g++ complains if the volatile result of the assignment is
+  // unused, so we cast the volatile away.  We cannot cast directly
+  // to void, because gcc treats that as not using the result of the
+  // assignment.  However, casting to E& means that we trigger an
+  // unused-value warning.  So, we cast the E& to void.
+  (void) const_cast<E&>(t = _elems[oldAge.top()]);
   Age newAge(oldAge);
   newAge.increment();
   Age resAge = _age.cmpxchg(newAge, oldAge);
@@ -668,13 +683,17 @@ public:
 template<class E, unsigned int N> inline bool
 GenericTaskQueue<E, N>::push(E t) {
   uint localBot = _bottom;
-  assert((localBot >= 0) && (localBot < N), "_bottom out of range.");
+  assert(localBot < N, "_bottom out of range.");
   idx_t top = _age.top();
   uint dirty_n_elems = dirty_size(localBot, top);
   assert(dirty_n_elems < N, "n_elems out of range.");
   if (dirty_n_elems < max_elems()) {
-    // g++ complains if the volatile result of the assignment is unused.
-    const_cast<E&>(_elems[localBot] = t);
+    // g++ complains if the volatile result of the assignment is
+    // unused, so we cast the volatile away.  We cannot cast directly
+    // to void, because gcc treats that as not using the result of the
+    // assignment.  However, casting to E& means that we trigger an
+    // unused-value warning.  So, we cast the E& to void.
+    (void) const_cast<E&>(_elems[localBot] = t);
     OrderAccess::release_store(&_bottom, increment_index(localBot));
     TASKQUEUE_STATS_ONLY(stats.record_push());
     return true;
@@ -698,7 +717,12 @@ GenericTaskQueue<E, N>::pop_local(E& t) 
   // This is necessary to prevent any read below from being reordered
   // before the store just above.
   OrderAccess::fence();
-  const_cast<E&>(t = _elems[localBot]);
+  // g++ complains if the volatile result of the assignment is
+  // unused, so we cast the volatile away.  We cannot cast directly
+  // to void, because gcc treats that as not using the result of the
+  // assignment.  However, casting to E& means that we trigger an
+  // unused-value warning.  So, we cast the E& to void.
+  (void) const_cast<E&>(t = _elems[localBot]);
   // This is a second read of "age"; the "size()" above is the first.
   // If there's still at least one element in the queue, based on the
   // "_bottom" and "age" we've read, then there can be no interference with
--- hotspot/src/share/vm/utilities/vmError.cpp
+++ hotspot/src/share/vm/utilities/vmError.cpp
@@ -1043,7 +1043,7 @@
   const char* ptr = OnOutOfMemoryError;
   while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){
     tty->print("#   Executing ");
-#if defined(LINUX)
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     tty->print  ("/bin/sh -c ");
 #elif defined(SOLARIS)
     tty->print  ("/usr/bin/sh -c ");
--- jdk/make/com/sun/java/pack/Makefile
+++ jdk/make/com/sun/java/pack/Makefile
@@ -61,6 +61,7 @@
 
 
 ifeq ($(STANDALONE),true)
+ ifneq ($(SYSTEM_ZLIB),true)
   ZIPOBJDIR = $(OUTPUTDIR)/tmp/sun/java.util.zip/zip/$(OBJDIRNAME)
 
   ZIPOBJS =  $(ZIPOBJDIR)/zcrc32.$(OBJECT_SUFFIX) \
@@ -78,6 +79,10 @@
   ZINCLUDE=-I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
   OTHER_CXXFLAGS += $(ZINCLUDE)
   LDDFLAGS += $(ZIPOBJS)
+ else
+  LDDFLAGS += %%ZLIB_LDFLAGS%%
+  OTHER_CXXFLAGS += -DSYSTEM_ZLIB
+ endif
 else
   OTHER_CXXFLAGS += -DNO_ZLIB -DUNPACK_JNI
   OTHER_LDLIBS += $(JVMLIB)
@@ -102,7 +107,11 @@
   COMPILER_WARNINGS_FATAL=false
 else
   LDOUTPUT = -o #Have a space 
+ifeq ($(PLATFORM), bsd)
+  LDDFLAGS += -pthread
+else
   LDDFLAGS += -lc
+endif
   OTHER_LDLIBS  += $(LIBCXX)
 # setup the list of libraries to link in...
 ifeq ($(PLATFORM), linux)
--- jdk/make/com/sun/jmx/Makefile
+++ jdk/make/com/sun/jmx/Makefile
@@ -102,7 +102,7 @@
 # when available, we need to run with latest rmic version available. rmic 
 # launch tool not built at this stage but we can invoke via rmi class.
 
-RMIC_JAVA = $(OUTPUTDIR)/bin/java
+RMIC_JAVA = $(BOOTDIR)/bin/java
 # need to treat 64bit solaris differently
 ifeq ($(PLATFORM)-$(LIBARCH), solaris-amd64)
 RMIC_JAVA = $(OUTPUTDIR)/bin/amd64/java
--- jdk/make/com/sun/security/auth/module/Makefile
+++ jdk/make/com/sun/security/auth/module/Makefile
@@ -70,7 +70,7 @@
   include FILES_c_solaris.gmk
 endif # solaris
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   LIBRARY = jaas_unix
   include FILES_export_unix.gmk
   include FILES_c_unix.gmk
--- jdk/make/com/sun/tools/attach/Exportedfiles.gmk
+++ jdk/make/com/sun/tools/attach/Exportedfiles.gmk
@@ -43,5 +43,7 @@
 	sun/tools/attach/LinuxVirtualMachine.java
 endif
 
-
-
+ifeq ($(PLATFORM), bsd)
+FILES_export = \
+	sun/tools/attach/BsdVirtualMachine.java
+endif
--- jdk/make/com/sun/tools/attach/FILES_c.gmk
+++ jdk/make/com/sun/tools/attach/FILES_c.gmk
@@ -39,4 +39,7 @@
 	LinuxVirtualMachine.c
 endif
 
-
+ifeq ($(PLATFORM),bsd)
+FILES_c = \
+	BsdVirtualMachine.c
+endif
--- jdk/make/com/sun/tools/attach/FILES_java.gmk
+++ jdk/make/com/sun/tools/attach/FILES_java.gmk
@@ -43,6 +43,11 @@
 	sun/tools/attach/LinuxAttachProvider.java
 endif
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+	sun/tools/attach/BsdAttachProvider.java
+endif
+
 #
 # Files that need to be copied
 #
--- jdk/make/com/sun/tools/attach/Makefile
+++ jdk/make/com/sun/tools/attach/Makefile
@@ -36,6 +36,9 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 
 #
--- jdk/make/com/sun/tools/attach/mapfile-bsd
+++ jdk/make/com/sun/tools/attach/mapfile-bsd
@@ -30,14 +30,12 @@
 	    Java_sun_tools_attach_BsdVirtualMachine_checkPermissions;
 	    Java_sun_tools_attach_BsdVirtualMachine_close;
 	    Java_sun_tools_attach_BsdVirtualMachine_connect;
-	    Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager;
-	    Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads;
 	    Java_sun_tools_attach_BsdVirtualMachine_open;
 	    Java_sun_tools_attach_BsdVirtualMachine_sendQuitTo;
-            Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf;
 	    Java_sun_tools_attach_BsdVirtualMachine_socket;
 	    Java_sun_tools_attach_BsdVirtualMachine_read;
 	    Java_sun_tools_attach_BsdVirtualMachine_write;
+	    Java_sun_tools_attach_BsdVirtualMachine_createAttachFile;
 	local:
 		*;
 };
--- jdk/make/common/Defs-bsd.gmk
+++ jdk/make/common/Defs-bsd.gmk
@@ -43,12 +43,6 @@
 # Get shared JDK settings
 include $(JDK_MAKE_SHARED_DIR)/Defs.gmk
 
-# Part of INCREMENTAL_BUILD mechanism.
-#   Compiler emits things like:  path/file.o: file.h
-#   We want something like: relative_path/file.o relative_path/file.d: file.h
-CC_DEPEND	 = -MM
-CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
-
 ifndef PLATFORM_SRC
   PLATFORM_SRC = $(BUILDDIR)/../src/solaris
 endif # PLATFORM_SRC
@@ -61,7 +55,7 @@
 endif
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -104,6 +98,10 @@
 #    as the default.
 CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
@@ -201,7 +199,7 @@
   CPP_ARCH_FLAGS += -D_$(ARCH)_
 endif
 
-CPPFLAGS_COMMON = $(CPP_ARCH_FLAGS) -DLINUX $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = $(CPP_ARCH_FLAGS) -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -211,33 +209,15 @@
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -Xlinker -z -Xlinker defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
-LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+
+ifneq ($(OS_VENDOR), Apple)
+LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -259,9 +239,9 @@
 ifeq ($(VARIANT), OPT)
   ifneq ($(NO_STRIP), true)
     ifneq ($(DEBUG_BINARIES), true)
-      # Debug 'strip -g' leaves local function Elf symbols (better stack
+      # Debug 'strip -S' leaves local function Elf symbols (better stack
       # traces)
-      POST_STRIP_PROCESS = $(STRIP) -g
+      POST_STRIP_PROCESS = $(STRIP) -S
     endif
   endif
 endif
@@ -271,13 +251,9 @@
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
-#
-# Support for Quantify.
-#
-ifdef QUANTIFY
-QUANTIFY_CMD = quantify
-QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
-LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
 endif
 
 #
@@ -306,24 +282,22 @@
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
 else
-override LIBCXX                  = -lstdc++
+override LIBCXX                  = %%CXX_LDFLAGS%%
 endif
 override LIBPOSIX4               =
 override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
-override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override NO_INTERRUPTIBLE_IO     = false
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
@@ -344,6 +318,14 @@
 # DPS (Displayable PostScript) is available on Solaris machines
 HAVE_DPS = no
 
+ifeq ($(OS_VENDOR), FreeBSD)
+  SYSTEM_ZLIB = true
+endif
+
+ifeq ($(OS_VENDOR), OpenBSD)
+  SYSTEM_ZLIB = true
+endif
+
 #
 # Japanese manpages
 #
--- jdk/make/common/Defs.gmk
+++ jdk/make/common/Defs.gmk
@@ -117,6 +117,24 @@
 _OUTPUTDIR=$(JDK_TOPDIR)/build/$(PLATFORM)-$(ARCH)
 endif
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -152,6 +170,7 @@
 
   ifdef ALT_FREETYPE_LIB_PATH
     FREETYPE_LIB_PATH = $(ALT_FREETYPE_LIB_PATH)
+    USING_SYSTEM_FT_LIB=true
   else
     ifeq ($(DEVTOOLS_FT_DIR_EXISTS), true)
       FREETYPE_LIB_PATH = $(DEVTOOLS_FT_DIR)/lib
@@ -216,6 +235,10 @@
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
+
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
--- jdk/make/common/Program.gmk
+++ jdk/make/common/Program.gmk
@@ -67,11 +67,27 @@
 # Create a dependency on libjli (Java Launcher Infrastructure)
 #
 # On UNIX, this is a relative dependency using $ORIGIN. Unfortunately, to
-# do this reliably on Linux takes a different syntax than Solaris.
+# do this reliably on Linux takes a different syntax than Solaris. BSD's
+# don't support $ORIGIN so build an archive instead.
 #
 # On Windows, this is done by using the same directory as the executable
 # itself, as with all the Windows libraries.
 #
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+# Work-around an dlsym(RTLD_DEFAULT) bug in at least FreeBSD & OpenBSD
+    LDFLAGS += -Wl,--export-dynamic
+  endif
+  ifeq ($(SYSTEM_ZLIB),true)
+      OTHER_LDLIBS += %%ZLIB_LDFLAGS%%
+  endif
+endif
 ifneq (,$(findstring $(PLATFORM), linux solaris))	# UNIX systems
     LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
     OTHER_LDLIBS += -ljli
@@ -166,6 +182,10 @@
   THREADLIBS = $(LIBTHREAD)
 endif # USE_PTHREADS
 
+ifeq ($(PLATFORM), bsd)
+THREADLIBS = -pthread
+endif
+
 #
 # This rule only applies on unix.  It supports quantify and its ilk.
 #
@@ -221,15 +241,19 @@
 
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRTIME=true
 endif
+endif
 
 ifeq ($(HAVE_GETHRTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRTIME
 endif
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)/bin -I$(LAUNCHER_PLATFORM_SRC)/bin
+ifneq ($(SYSTEM_ZLIB),true)
 OTHER_INCLUDES += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 
 OTHER_CPPFLAGS += -DPROGNAME='"$(PROGRAM)"'
 VERSION_DEFINES += -DFULL_VERSION='"$(FULL_VERSION)"'
--- jdk/make/common/Release.gmk
+++ jdk/make/common/Release.gmk
@@ -145,14 +145,13 @@
 	tnameserv.1     \
 	unpack200.1
 
-ifeq ($(ARCH_DATA_MODEL),32)
+ifeq ($(BUILD_DEPLOY), true)
   JRE_MAN_PAGES += javaws.1
 endif
 
 JDK_MAN_PAGES =            \
 	$(JRE_MAN_PAGES)   \
 	appletviewer.1     \
-        apt.1              \
 	extcheck.1         \
 	idlj.1             \
 	jar.1              \
@@ -191,6 +190,11 @@
   JA_DIRNAME=ja_JP.$(JA_SOURCE_ENCODING)
 endif # linux
 
+ifeq ($(PLATFORM), bsd)
+  MANBASEDIRS=$(JDK_TOPDIR)/src/bsd/doc $(IMPORTDOCDIR)
+  MAN1SUBDIR = man
+endif
+
 define copy-man-pages
 $(MKDIR) -p $1/man/man1
 for manbase in $(MANBASEDIRS:%=%/$(MAN1SUBDIR)) ; do \
@@ -313,6 +317,12 @@
   SOURCE_DIRS += $(CLOSED_SRC)/share/classes
 endif
 
+ifeq ($(OS_VENDOR), OpenBSD)
+  FILES_FROM_ARG=-I
+else
+  FILES_FROM_ARG=-T
+endif
+
 
 #
 # Specific files and directories that will be filtered out from above areas.
@@ -629,6 +639,8 @@
 	$(BOOT_JAVA_CMD) -jar $(JARSPLIT_JARFILE) \
 		$(TOTAL_JAR_FILELIST) \
 		-o  $(RT_JAR_FILELIST) $(RES_JAR_FILELIST)
+	$(EGREP) -v hotspot.log $(RES_JAR_FILELIST) > $(RES_JAR_FILELIST).temp
+	$(MV) $(RES_JAR_FILELIST).temp $(RES_JAR_FILELIST)
 	@$(java-vm-cleanup)
 
 # Create the manifest file.
@@ -974,7 +986,7 @@
 	@# generated by the more efficient solaris/windows method of copying files.
 	@# So for Linux, make use of the -T option (like Solaris' -I option) of
 	@# obtaining the list of files from a file. MKS tar has no such option.
-  ifeq ($(PLATFORM), linux)
+  ifneq (,$(findstring $(PLATFORM), linux bsd))
 	for d in $(SOURCE_DIRS); do \
 	  $(RM) $(ABS_TEMPDIR)/src-files.list; \
 	  ($(CD) $$d &&  \
@@ -987,7 +999,7 @@
 	    done ; \
 	  ) ; \
 	  if [ -f  $(ABS_TEMPDIR)/src-files.list ] ; then \
-	    ($(CD) $$d && $(TAR) cf - -T $(ABS_TEMPDIR)/src-files.list ) \
+	    ($(CD) $$d && $(TAR) cf - $(FILES_FROM_ARG) $(ABS_TEMPDIR)/src-files.list ) \
 	       | ($(CD) $(JDK_IMAGE_DIR)/src && $(TAR) xf -); \
 	  fi; \
 	done
--- jdk/make/common/shared/Compiler-gcc.gmk
+++ jdk/make/common/shared/Compiler-gcc.gmk
@@ -99,6 +99,24 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+
+  # Settings specific to BSD
+  CC             ?= $(COMPILER_PATH)gcc
+  CPP            ?= $(COMPILER_PATH)gcc -E
+  CXX            ?= $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.2
+
+  # Option used to create a shared library
+  # Option used to create a shared library
+  ifeq ($(OS_VENDOR), Apple)
+    SHARED_LIBRARY_FLAG = -dynamiclib 
+  else
+    SHARED_LIBRARY_FLAG = -shared
+  endif
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- jdk/make/common/shared/Compiler.gmk
+++ jdk/make/common/shared/Compiler.gmk
@@ -37,8 +37,8 @@
   override CC_VERSION = sun
 endif
 
-# Linux uses GNU compilers by default
-ifeq ($(PLATFORM), linux)
+# Linux  & BSD uses GNU compilers by default
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   override CC_VERSION = gcc
 endif
 
--- jdk/make/common/shared/Defs-bsd.gmk
+++ jdk/make/common/shared/Defs-bsd.gmk
@@ -70,7 +70,7 @@
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH = $(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -123,7 +123,7 @@
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
@@ -162,16 +162,12 @@
 endif
 MOTIF_INCLUDE = $(MOTIF_DIR)/include
 
-# GCC29_COMPILER_PATH: is the path to where the gcc 2.9 compiler is installed
-#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
-ifneq "$(origin ALT_GCC29_COMPILER_PATH)" "undefined"
-  GCC29_COMPILER_PATH :=$(call PrefixPath,$(ALT_GCC29_COMPILER_PATH))
+ifeq ($(OS_VENDOR), Apple)
+  _CUPS_HEADERS_PATH=/usr/include
 else
-  GCC29_COMPILER_PATH = $(JDK_DEVTOOLS_DIR)/$(PLATFORM)/gcc29/usr/
+  _CUPS_HEADERS_PATH=$(PACKAGE_PATH)/include
 endif
 
-_CUPS_HEADERS_PATH=/usr/include
-
 # Import JDK images allow for partial builds, components not built are
 #    imported (or copied from) these import areas when needed.
 
--- jdk/make/common/shared/Defs-utils.gmk
+++ jdk/make/common/shared/Defs-utils.gmk
@@ -80,6 +80,13 @@
   endif
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 # Utilities
 ADB            = $(UTILS_COMMAND_PATH)adb
 AR             = $(UTILS_CCS_BIN_PATH)ar
@@ -201,3 +208,32 @@
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
--- jdk/make/common/shared/Defs.gmk
+++ jdk/make/common/shared/Defs.gmk
@@ -143,7 +143,7 @@
         echo older; \
       else \
 	if [ $(call MajorVersion,$1) -eq $(call MajorVersion,$2) -a \
-	     $(call MinorVersion,$1) -lt $(call MinorVersion,$2) ]; then \
+	     `echo $(call MinorVersion,$1) | sed -e 's/\([0-9]*\)\(.*\)/\1/'` -lt $(call MinorVersion,$2) ]; then \
           echo older; \
         else \
           echo newer; \
--- jdk/make/common/shared/Platform.gmk
+++ jdk/make/common/shared/Platform.gmk
@@ -264,6 +264,76 @@
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+  REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+  REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586 and sparc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -413,6 +483,13 @@
 #    system swapping during the build.
 #    If we don't know, assume 512. Subtract 128 from MB for VM MAX.
 #    Don't set VM max over 1024-128=896.
+#    736 is the max for OpenBSD.
+ifeq ($(OS_VENDOR), OpenBSD)
+  ABS_MAX_MEMORY := "736"
+else
+  ABS_MAX_MEMORY := "896"
+endif
+
 ifneq ($(MB_OF_MEMORY),)
   LOW_MEMORY_MACHINE := $(shell \
     if [ $(MB_OF_MEMORY) -le 512 ] ; then \
@@ -424,7 +501,7 @@
     if [ $(MB_OF_MEMORY) -le 1024 ] ; then \
       expr $(MB_OF_MEMORY) '-' 128 ; \
     else \
-      echo "896"; \
+      echo $(ABS_MAX_MEMORY); \
     fi)
   MIN_VM_MEMORY := $(shell \
     if [ $(MAX_VM_MEMORY) -le 128 ] ; then \
@@ -476,6 +553,15 @@
   ARCH_VM_SUBDIR=jre/lib/$(LIBARCH)
 endif
 
+# Darwin-specific Overrides
+ifeq ($(SYSTEM_UNAME),Darwin)
+  # The suffix applied to runtime libraries
+  LIBRARY_SUFFIX = dylib
+  # The suffix applied to link libraries
+  LIB_SUFFIX = dylib
+endif
+
+
 # If blanks in the username, use the first 4 words and pack them together
 _USER1:=$(subst ', ,$(_USER))
 _USER2:=$(subst ", ,$(_USER1))
--- jdk/make/common/shared/Sanity-Settings.gmk
+++ jdk/make/common/shared/Sanity-Settings.gmk
@@ -242,6 +242,7 @@
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_HEADERS_PATH)
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_LIB_PATH)
 endif
+ALL_SETTINGS+=$(call addAltSetting,X11_PATH)
 ALL_SETTINGS+=$(call addOptionalSetting,PLUG_LIBRARY_NAMES)
 
 ifdef OPENJDK
--- jdk/make/common/shared/Sanity.gmk
+++ jdk/make/common/shared/Sanity.gmk
@@ -90,6 +90,11 @@
     $(EGREP) "\#define" | $(NAWK) '{print $$3}')
 endif
 
+ifeq ($(PLATFORM), bsd)
+  FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(OUTPUTDIR) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+  TEMP_FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(TEMP_DISK) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+endif
+
 # Get the version numbers of what we are using
 _MAKE_VER  :=$(shell $(MAKE) --version 2>&1 | $(HEAD) -n 1)
 _ZIP_VER   :=$(shell $(ZIPEXE) -help 2>&1 | $(HEAD) -n 4 | $(EGREP) '^Zip')
--- jdk/make/java/Makefile
+++ jdk/make/java/Makefile
@@ -49,7 +49,7 @@
   endif
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   SUBDIRS += jexec
 endif # PLATFORM
 
--- jdk/make/java/hpi/hpi_common.gmk
+++ jdk/make/java/hpi/hpi_common.gmk
@@ -86,5 +86,9 @@
 # Things that must be linked in.
 #
 ifneq ($(PLATFORM), windows)
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(LIBM)
+else
 OTHER_LDLIBS += $(LIBSOCKET) -lnsl $(LIBM) -ldl
 endif
+endif
--- jdk/make/java/hpi/native/Makefile
+++ jdk/make/java/hpi/native/Makefile
@@ -72,11 +72,18 @@
 ifeq ($(MOOT_PRIORITIES),true)
 OTHER_CPPFLAGS += -DMOOT_PRIORITIES
 endif
+ifeq ($(PLATFORM), bsd)
+LIBPOSIX4      =
+OTHER_LDLIBS   += -pthread
+else
 LIBPOSIX4	= -lposix4
 OTHER_LDLIBS   += -lpthread $(LIBPOSIX4)
 endif
+endif
 
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRVTIME=true
+endif
 ifeq ($(HAVE_GETHRVTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRVTIME
 endif
--- jdk/make/java/instrument/Makefile
+++ jdk/make/java/instrument/Makefile
@@ -102,6 +102,19 @@
   # equivalent of strcasecmp is stricmp on Windows
   CPPFLAGS_COMMON += -Dstrcasecmp=stricmp
 else
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+  endif
+# Use CPPFLAGS instead of OTHER_INCLUDES to force this last
+  CPPFLAGS += %%ICONV_CPPFLAGS%%
+  OTHER_LDLIBS += %%ICONV_LDFLAGS%%
+else
   LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
   OTHER_LDLIBS += -ljli
   OTHER_LDLIBS += -ldl 
@@ -114,6 +127,7 @@
     LDFLAGS += -Wl,-rpath -Wl,\$$ORIGIN/jli
   endif
 endif
+endif
 
 #
 # Library to compile.
--- jdk/make/java/java/Makefile
+++ jdk/make/java/java/Makefile
@@ -167,8 +167,10 @@
 # Is the altzone extern documented in ctime(3C) available?
 #
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_ALTZONE=true
 endif
+endif
 
 ifeq ($(HAVE_ALTZONE),true)
 OTHER_CPPFLAGS += -DHAVE_ALTZONE
@@ -205,9 +207,14 @@
 OTHER_LDLIBS += $(JVMLIB) -libpath:$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) fdlibm.lib \
 		       -libpath:$(OBJDIR)/../../../verify/$(OBJDIRNAME) verify.lib
 else
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(JVMLIB) -lverify \
+		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
+else
 OTHER_LDLIBS += $(JVMLIB) -lverify $(LIBSOCKET) -lnsl -ldl \
 		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
 endif
+endif
 
 #
 # Rules.
--- jdk/make/java/java/genlocales.gmk
+++ jdk/make/java/java/genlocales.gmk
@@ -76,11 +76,16 @@
 $(LocaleDataMetaInfo_Dest):$(LocaleDataMetaInfo_Src) $(LOCALEGEN_SH)
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 	@$(prep-target) 
-	@$(ECHO) $(subst .properties,'\n',$(Euro_Resources_properties)) > $@.tmp.euro;
-	@$(ECHO) $(subst .java,'\n',$(Euro_Resources_java)) >> $@.tmp.euro;	
-	@$(ECHO) $(subst .properties,'\n',$(NonEuro_Resources_properties)) > $@.tmp.noneuro;
-	@$(ECHO) $(subst .java,'\n',$(NonEuro_Resources_java)) >> $@.tmp.noneuro;
-	NAWK="$(NAWK)" SED="$(SED)" $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
+	@$(ECHO) $(Euro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.euro;
+	@$(ECHO) $(Euro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.euro;
+	@$(ECHO) $(NonEuro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.noneuro;
+	@$(ECHO) $(NonEuro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.noneuro;
+	NAWK="$(NAWK)" SED="$(SED)" SORT="$(SORT)" \
+	     $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
 		$@.tmp.noneuro $< $@
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 	
--- jdk/make/java/java/localegen.sh
+++ jdk/make/java/java/localegen.sh
@@ -29,7 +29,7 @@
 # This script is to generate the supported locale list string and replace the
 # LocaleDataMetaInfo-XLocales.java in <ws>/src/share/classes/sun/util
 # 
-# NAWK & SED is passed in as environment variables.
+# SORT, NAWK & SED is passed in as environment variables.
 #
 
 # A list of resource base name list;
@@ -47,7 +47,7 @@
 localelist=
 getlocalelist() {
     localelist=""
-    localelist=`$NAWK -F$1_ '{print $2}' $2 | sort`
+    localelist=`$NAWK -F$1_ '{print $2}' $2 | $SORT`
 }
 
 sed_script="$SED -e \"s@^#warn .*@// -- This file was mechanically generated: Do not edit! -- //@\" " 
@@ -55,9 +55,9 @@
 for FILE in $RESOURCE_NAMES 
 do
     getlocalelist $FILE $EURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_EuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_EuroLocales#@$localelist@g\" "
     getlocalelist $FILE $NONEURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_NonEuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_NonEuroLocales#@$localelist@g\" "
 done
 
 sed_script=$sed_script"$INPUT_FILE > $OUTPUT_FILE"
--- jdk/make/java/java_hprof_demo/Makefile
+++ jdk/make/java/java_hprof_demo/Makefile
@@ -83,8 +83,10 @@
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS += wsock32.lib winmm.lib
 else
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += $(LIBSOCKET) -lnsl -ldl
 endif
+endif
 
 #
 # Tell library.gmk to copy the txt file first
--- jdk/make/java/jli/Makefile
+++ jdk/make/java/jli/Makefile
@@ -44,8 +44,10 @@
 
 include $(BUILDDIR)/common/Defs.gmk
 
+ifneq ($(SYSTEM_ZLIB),true)
 ZLIB_VERSION = 1.1.3
 ZIP_SRC = $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+endif
 LAUNCHER_SHARE_SRC = $(SHARE_SRC)/bin
 LAUNCHER_PLATFORM_SRC = $(PLATFORM_SRC)/bin
 
@@ -56,7 +58,10 @@
 	parse_manifest.c \
 	version_comp.c \
 	wildcard.c \
-	jli_util.c \
+	jli_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	inflate.c \
 	infblock.c \
 	inftrees.c \
@@ -65,6 +70,7 @@
 	infutil.c \
 	zadler32.c \
 	zutil.c
+endif
 
 OTHER_CPPFLAGS += -DEXPAND_CLASSPATH_WILDCARDS
 
@@ -98,7 +104,11 @@
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)
 OTHER_INCLUDES += -I$(LAUNCHER_PLATFORM_SRC)
-OTHER_INCLUDES += -I$(ZIP_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  OTHER_INCLUDES += -I$(ZIP_SRC)
+else
+  LDLIBS += %%ZLIB_LDFLAGS%%
+endif
 
 #
 # Library to compile.
@@ -136,8 +146,29 @@
 
 endif	# PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+
+STATIC_LIBRARY_DIR = $(OBJDIR)/static
+STATIC_LIBRARY_NAME = lib$(LIBRARY).a
+STATIC_LIBRARY = $(STATIC_LIBRARY_DIR)/$(STATIC_LIBRARY_NAME)
+
+$(STATIC_LIBRARY_DIR): $(OBJDIR)
+	@$(MKDIR) $(STATIC_LIBRARY_DIR)
+
+$(STATIC_LIBRARY): $(STATIC_LIBRARY_DIR)
+	@$(prep-target)
+	$(AR) -r $@ $(FILES_o)
+
+library:: $(STATIC_LIBRARY)
+
+endif  # PLATFORM
+
 #
 # Add to ambient vpath so we pick up the library files
 #
-vpath %.c $(LAUNCHER_SHARE_SRC) $(ZIP_SRC)
+vpath %.c $(LAUNCHER_SHARE_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c $(ZIP_SRC)
+endif
+
 
--- jdk/make/java/management/Makefile
+++ jdk/make/java/management/Makefile
@@ -85,6 +85,11 @@
 OTHER_INCLUDES += \
   -I$(SHARE_SRC)/native/sun/management 
 
+ifeq ($(PLATFORM),bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB)
 endif
--- jdk/make/java/net/FILES_c.gmk
+++ jdk/make/java/net/FILES_c.gmk
@@ -43,6 +43,10 @@
     FILES_c += linux_close.c
 endif
 
+ifeq ($(OS_VENDOR), FreeBSD)
+    FILES_c += bsd_close.c
+endif
+
 ifeq ($(PLATFORM), windows)
     FILES_c += TwoStacksPlainSocketImpl.c
     FILES_c += DualStackPlainSocketImpl.c
--- jdk/make/java/net/Makefile
+++ jdk/make/java/net/Makefile
@@ -92,6 +92,12 @@
 
 include $(BUILDDIR)/common/Library.gmk
 
+ifeq ($(PLATFORM), bsd)
+  ifdef DONT_ENABLE_IPV6
+    OTHER_CFLAGS += -DDONT_ENABLE_IPV6
+  endif
+  OTHER_LDLIBS = $(JVMLIB) -pthread
+else
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = ws2_32.lib $(JVMLIB)
   # Will not compile at warning level 3 if warnings are fatal
@@ -102,6 +108,7 @@
 ifeq ($(PLATFORM), linux)
   OTHER_LDLIBS += -lpthread
 endif
+endif # PLATFORM == bsd
 
 CLASSES.export += java.lang.Integer java.io.FileDescriptor java.net.InetAddressImplFactory java.net.Inet4AddressImpl java.net.Inet6AddressImpl
 
--- jdk/make/java/nio/Makefile
+++ jdk/make/java/nio/Makefile
@@ -104,6 +104,28 @@
 	sun/nio/ch/NativeThread.java
 endif # PLATFORM = linux
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+	sun/nio/ch/AbstractPollSelectorImpl.java \
+	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/KqueueArrayWrapper.java \
+	sun/nio/ch/KqueueSelectorProvider.java \
+	sun/nio/ch/KqueueSelectorImpl.java \
+	sun/nio/ch/PollSelectorProvider.java \
+	sun/nio/ch/PollSelectorImpl.java
+
+FILES_c += \
+	KqueueArrayWrapper.c \
+	PollArrayWrapper.c \
+	InheritedChannel.c \
+	NativeThread.c
+
+FILES_export += \
+	sun/nio/ch/KqueueArrayWrapper.java \
+	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/NativeThread.java
+endif # PLATFORM = bsd
+
 # Find platform-specific C source files
 #
 vpath %.c $(PLATFORM_SRC)/native/sun/nio/ch
@@ -126,6 +148,11 @@
   -I$(PLATFORM_SRC)/native/java/net \
   -I$(CLASSHDRDIR)/../../../java.lang/java/CClassHeaders
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB) ws2_32.lib \
      -libpath:$(LIBDIR) java.lib \
@@ -137,6 +164,9 @@
 COMPILER_WARNINGS_FATAL=true
 OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -lpthread -ldl
 endif
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -pthread
+endif
 ifeq ($(PLATFORM), solaris)
 OTHER_LDLIBS += $(JVMLIB) $(LIBSOCKET) -lposix4 -ldl \
 		-L$(LIBDIR)/$(LIBARCH) -ljava -lnet
@@ -159,6 +189,9 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 include $(BUILDDIR)/common/Library.gmk
 
--- jdk/make/java/npt/Makefile
+++ jdk/make/java/npt/Makefile
@@ -70,6 +70,18 @@
   OTHER_LCF += -export:nptInitialize -export:nptTerminate
 endif
 
+# Add location of iconv headers & libs
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    OTHER_LDLIBS += -liconv
+  else
+    ifneq ($(OS_NAME), netbsd)
+      CPPFLAGS += %%ICONV_CPPFLAGS%%
+      OTHER_LDLIBS += %%ICONV_LDFLAGS%%
+    endif
+  endif
+endif
+
 #
 # Add to ambient vpath so we pick up the library files
 #
--- jdk/make/java/redist/FILES.gmk
+++ jdk/make/java/redist/FILES.gmk
@@ -38,6 +38,14 @@
 	$(LIBDIR)/fonts/LucidaSansDemiBold.ttf       	\
 
 ifeq ($(PLATFORM), linux)
+NEED_OBLIQUE_FONTS = true
+endif
+
+ifeq ($(PLATFORM), bsd)
+NEED_OBLIQUE_FONTS = true
+endif
+
+ifeq ($(NEED_OBLIQUE_FONTS), true)
 
 # The oblique versions of the font are derived from the base versions
 # and since 2D can do this derivation on the fly at run time there is no
--- jdk/make/java/redist/Makefile
+++ jdk/make/java/redist/Makefile
@@ -311,7 +311,7 @@
 $(FONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.fonts.dir
 	$(install-file)
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique fonts are only needed/wanted on Linux.
 
@@ -325,7 +325,7 @@
 $(OBLFONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.oblique-fonts.dir
 	$(install-file)
 
-endif # linux
+endif # linux || bsd
 endif # !OPENJDK
 
 # Import internal files (ones that are stashed in this source tree)
--- jdk/make/java/security/Makefile
+++ jdk/make/java/security/Makefile
@@ -51,7 +51,15 @@
   ifneq ($(ARCH_DATA_MODEL), 64)
     PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-windows
   endif
+
+else # windows
+
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), OpenBSD)
+    PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-openbsd
+  endif
 endif
+endif # windows
 endif # PLATFORM
 
 
--- jdk/make/java/zip/FILES_c.gmk
+++ jdk/make/java/zip/FILES_c.gmk
@@ -30,6 +30,10 @@
 	Inflater.c \
 	ZipFile.c \
 	ZipEntry.c \
+	zip_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	zadler32.c \
 	zcrc32.c \
 	deflate.c \
@@ -40,5 +44,5 @@
 	inftrees.c \
 	infcodes.c \
 	infutil.c \
-	inffast.c \
-	zip_util.c
+	inffast.c
+endif
--- jdk/make/java/zip/Makefile
+++ jdk/make/java/zip/Makefile
@@ -72,16 +72,24 @@
 CPPFLAGS += -UDEBUG 
 endif
 
-CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 CPPFLAGS += -I$(SHARE_SRC)/native/java/io
 CPPFLAGS += -I$(PLATFORM_SRC)/native/java/io
 
+ifneq ($(SYSTEM_ZLIB),true)
+CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+
 #
 # Add to ambient vpath so we pick up the library files
 #
 vpath %.c $(SHARE_SRC)/native/$(PKGDIR)/zlib-$(ZLIB_VERSION)
+endif
 
 #
 # Link to JVM library for JVM_Zip* functions
 #
+ifeq ($(SYSTEM_ZLIB),true)
+OTHER_LDLIBS = %%ZLIB_LDFLAGS%%
+else
 OTHER_LDLIBS = $(JVMLIB)
+endif
+
--- jdk/make/javax/sound/FILES_c.gmk
+++ jdk/make/javax/sound/FILES_c.gmk
@@ -34,6 +34,8 @@
 
 FILES_linux = 
 
+FILES_bsd =
+
 FILES_windows = \
 	PLATFORM_API_WinOS_MidiIn.c \
 	PLATFORM_API_WinOS_MidiOut.c \
--- jdk/make/javax/sound/SoundDefs.gmk
+++ jdk/make/javax/sound/SoundDefs.gmk
@@ -40,6 +40,10 @@
   CPPFLAGS += -DX_PLATFORM=X_LINUX
 endif # PLATFORM linux
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -DX_PLATFORM=X_BSD
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -DX_PLATFORM=X_SOLARIS
 
--- jdk/make/javax/sound/jsoundalsa/Makefile
+++ jdk/make/javax/sound/jsoundalsa/Makefile
@@ -65,6 +65,15 @@
 	$(MIDIFILES_export) \
 	$(PORTFILES_export)
 
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS  += -L$(PACKAGE_PATH)/lib -lasound
+
+CPPFLAGS += \
+	-DUSE_DAUDIO=TRUE \
+	-DUSE_PORTS=TRUE  \
+	-I$(PACKAGE_PATH)/include \
+	-I$(SHARE_SRC)/native/com/sun/media/sound
+else
 OTHER_LDLIBS += -lasound
 
 CPPFLAGS += \
@@ -73,6 +82,7 @@
 	-DUSE_PLATFORM_MIDI_OUT=TRUE \
 	-DUSE_PLATFORM_MIDI_IN=TRUE \
 	-I$(SHARE_SRC)/native/com/sun/media/sound
+endif
 
 #
 # Add to the ambient VPATH.
--- jdk/make/jpda/back/Makefile
+++ jdk/make/jpda/back/Makefile
@@ -49,8 +49,10 @@
                  -I$(GENNATIVESRCDIR)/jdwp
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += -ldl
 endif # PLATFORM
+endif # PLATFORM
 
 #
 # This turns off all assert() checking in the optimized library
--- jdk/make/sun/awt/Makefile
+++ jdk/make/sun/awt/Makefile
@@ -129,6 +129,14 @@
 OTHER_LDLIBS = $(JVMLIB) $(LIBM) -ldl
 endif
 
+ifeq  ($(PLATFORM), bsd)
+FILES_c = $(FILES_2D_c)
+FILES_c += awt_LoadLibrary.c
+OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
+OTHER_CFLAGS += -DMOTIF_VERSION=2
+OTHER_LDLIBS = $(JVMLIB) $(LIBM)
+endif
+
 FILES_c += initIDs.c
 
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS/LINUX
@@ -241,7 +249,7 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ WINDOWS
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv LINUX
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/../java2d/opengl
@@ -422,6 +430,19 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS
 endif # PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BSD
+
+FONTCONFIGS_SRC = $(PLATFORM_SRC)/classes/sun/awt/fontconfigs
+_FONTCONFIGS   = \
+       fontconfig.properties
+
+FONTCONFIGS_SRC_PREFIX = $(PLATFORM).
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ BSD
+endif # PLATFORM
+
+
 FONTCONFIGS     = $(_FONTCONFIGS:%=$(LIBDIR)/%.src)
 BINARYFONTCONFIGS = $(_FONTCONFIGS:%.properties=$(LIBDIR)/%.bfc)
 
@@ -515,6 +536,9 @@
             -I$(OPENWIN_HOME)/include/X11/extensions \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
 endif
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
+endif
 CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/../font \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../font \
@@ -536,7 +560,13 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR) \
 	    $(EVENT_MODEL)
 
-ifeq ($(PLATFORM), linux)
+# include these last so we don't pick up unintentional includes
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(OPENWIN_HOME)/include \
+            -I$(OPENWIN_HOME)/include/X11/extensions
+endif
+
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 LDFLAGS += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
 endif
 
--- jdk/make/sun/awt/mawt.gmk
+++ jdk/make/sun/awt/mawt.gmk
@@ -174,7 +174,7 @@
 OTHER_LDLIBS = $(LIBXM) -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
 endif
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
 OTHER_CFLAGS += -DMOTIF_VERSION=2
 OTHER_CFLAGS += -DXMSTRINGDEFINES=1
@@ -185,7 +185,11 @@
 # !HEADLESS
 
 OTHER_LDLIBS += $(JVMLIB) $(LIBCXX) \
-                -lawt $(LIBM) -ldl
+                -lawt $(LIBM)
+
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
 
 #
 # Sun CC with -Xa misdefines __STDC__ to 0 (zero).
@@ -229,16 +233,33 @@
         -I$(PLATFORM_SRC)/native/$(PKGDIR) \
         $(EVENT_MODEL)
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
+ifndef HEADLESS
+CPPFLAGS += -I$(MOTIF_DIR)/include \
+            -I$(OPENWIN_HOME)/include 
+LDFLAGS  += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
+
+endif # !HEADLESS
+
 ifeq ($(PLATFORM), linux)
 # Checking for the X11/extensions headers at the additional location
   CPPFLAGS += -I/X11R6/include/X11/extensions \
               -I/usr/include/X11/extensions
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
+              -I$(OPENWIN_HOME)/include 
+endif
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions
 endif
 
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
 
 LDFLAGS += -L$(LIBDIR)/$(LIBARCH)/$(TSOBJDIR) \
 	   $(AWT_RUNPATH)
--- jdk/make/sun/font/Makefile
+++ jdk/make/sun/font/Makefile
@@ -177,6 +177,15 @@
 # Libraries to link, and other C flags.
 #
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += -I$(X11_PATH)/include
+OTHER_LDLIBS  += -lawt $(LIBM) $(LIBCXX)
+ ifeq ($(OS_VENDOR),Apple)
+   # XXXDARWIN Match BSD/Linux behavior -- the mawt.dylib symbols will
+   # be available at runtime.
+   OTHER_LDLIBS += -flat_namespace -undefined suppress
+ endif
+else
 ifeq ($(PLATFORM), solaris)
   # Note that on Solaris, fontmanager is built against the headless library.
   LDFLAGS      += -L$(LIBDIR)/$(LIBARCH)/headless
@@ -187,6 +196,7 @@
     OTHER_LDLIBS  += -Wl,-Bstatic -lgcc_eh -Wl,-Bdynamic
   endif                           
 endif
+endif
 
 endif # PLATFORM
 
--- jdk/make/sun/image/generic/Makefile
+++ jdk/make/sun/image/generic/Makefile
@@ -69,5 +69,9 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/medialib 
 
 OTHER_CFLAGS += -D__USE_J2D_NAMES -D__MEDIALIB_OLD_NAMES
-OTHER_LDLIBS = $(LIBM) -ldl
+OTHER_LDLIBS = $(LIBM)
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
+
 
--- jdk/make/sun/jawt/Makefile
+++ jdk/make/sun/jawt/Makefile
@@ -98,9 +98,7 @@
 #
 # Other extra flags needed for compiling.
 #
-CPPFLAGS += -I$(OPENWIN_HOME)/include \
-	    -I$(MOTIF_DIR)/include \
-	    -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/image \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/image/cvutils \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/alphacomposite \
@@ -114,6 +112,8 @@
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/doe \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/path \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../jdga \
+	    -I$(OPENWIN_HOME)/include \
+	    -I$(MOTIF_DIR)/include \
 	    $(EVENT_MODEL)
 #
 # Libraries to link in.
@@ -122,7 +122,7 @@
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -L$(OPENWIN_LIB) -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -lawt -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
--- jdk/make/sun/security/jgss/wrapper/Makefile
+++ jdk/make/sun/security/jgss/wrapper/Makefile
@@ -71,6 +71,10 @@
 #
 # Libraries to link
 #
-ifneq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), linux solaris))
   OTHER_LDLIBS = -ldl $(JVMLIB)
 endif
+
+ifeq ($(PLATFORM), bsd)
+  OTHER_LDLIBS = $(JVMLIB)
+endif
--- jdk/make/sun/security/pkcs11/Makefile
+++ jdk/make/sun/security/pkcs11/Makefile
@@ -156,7 +156,7 @@
 #
 # Libraries to link
 #
-ifeq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), windows bsd))
   OTHER_LDLIBS = $(JVMLIB)
 else
   OTHER_LDLIBS = -ldl $(JVMLIB)
--- jdk/make/sun/security/smartcardio/Makefile
+++ jdk/make/sun/security/smartcardio/Makefile
@@ -75,6 +75,10 @@
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = $(JVMLIB) winscard.lib
 else
-  OTHER_LDLIBS = -ldl $(JVMLIB)
+  ifeq ($(PLATFORM), bsd)
+    OTHER_LDLIBS = $(JVMLIB)
+  else
+    OTHER_LDLIBS = -ldl $(JVMLIB)
+  endif
   OTHER_CFLAGS = -D__sun_jdk
 endif
--- jdk/make/sun/splashscreen/FILES_c.gmk
+++ jdk/make/sun/splashscreen/FILES_c.gmk
@@ -49,20 +49,6 @@
 	dgif_lib.c \
 	gif_err.c \
 	gifalloc.c \
-	compress.c \
-	deflate.c \
-	gzio.c \
-	infblock.c \
-	infcodes.c \
-	inffast.c \
-	inflate.c \
-	inftrees.c \
-	infutil.c \
-	trees.c \
-	uncompr.c \
-	zadler32.c \
-	zcrc32.c \
-	zutil.c \
 	jcomapi.c \
 	jdapimin.c \
 	jdapistd.c \
@@ -108,3 +94,20 @@
 	jfdctfst.c \
 	jfdctint.c
 
+ifneq ($(SYSTEM_ZLIB),true)
+  FILES_c += \
+	compress.c \
+	deflate.c \
+	gzio.c \
+	infblock.c \
+	infcodes.c \
+	inffast.c \
+	inflate.c \
+	inftrees.c \
+	infutil.c \
+	trees.c \
+	uncompr.c \
+	zadler32.c \
+	zcrc32.c \
+	zutil.c
+endif
--- jdk/make/sun/splashscreen/Makefile
+++ jdk/make/sun/splashscreen/Makefile
@@ -61,10 +61,25 @@
 
 CFLAGS += -DSPLASHSCREEN
 
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
+ifneq ($(SYSTEM_ZLIB),true)
+  CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
+
+
 ifneq ($(PLATFORM), windows)
   CFLAGS += -DWITH_X11
-  CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
-  OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  ifeq ($(PLATFORM), bsd)
+    CFLAGS += -DPNG_NO_MMX_CODE
+    CPPFLAGS += -I$(OPENWIN_HOME)/include \
+                -I$(OPENWIN_HOME)/include/X11/extensions
+    CPPFLAGS += %%ICONV_CPPFLAGS%%
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext %%ICONV_LDFLAGS%% $(LIBM) -pthread
+  else
+    CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  endif
 else # PLATFORM
   CFLAGS += -DWITH_WIN32
   OTHER_LDLIBS += kernel32.lib user32.lib gdi32.lib 
@@ -77,14 +92,13 @@
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/splashscreen
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/giflib
-vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/libpng
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen
 
-CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
-CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
-
 ifeq ($(PLATFORM), linux)
   ifeq ($(ARCH_DATA_MODEL), 64)
     # 64-bit gcc has problems compiling MMX instructions.
--- jdk/make/sun/xawt/Makefile
+++ jdk/make/sun/xawt/Makefile
@@ -53,6 +53,11 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
+ifeq ($(PLATFORM), bsd)
+LDFLAGS += -pthread
+dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
+endif
+
 # Since this library will be living in a subdirectory below the other libraries
 #   we need to add an extra runpath so that libraries in the upper directory
 #   are found at runtime.
@@ -86,7 +91,12 @@
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/x11
 
-OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 -ldl \
+ifeq ($(PLATFORM), bsd)
+LIBDL=
+else
+LIBDL=-ldl
+endif
+OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 $(LIBDL) \
                    $(LDFLAGS_COMMON) $(AWT_RUNPATH) $(OTHER_LDFLAGS) -lXtst -lXi
 
 ifeq  ($(PLATFORM), solaris)
@@ -94,8 +104,6 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
-CPPFLAGS += -I$(CUPS_HEADERS_PATH)
-
 CPPFLAGS += -DXAWT -DXAWT_HACK \
         -I$(TEMPDIR)/../../sun.awt/awt/CClassHeaders \
         -I$(PLATFORM_SRC)/native/sun/awt \
@@ -122,9 +130,11 @@
         -I$(SHARE_SRC)/native/sun/awt \
         -I$(PLATFORM_SRC)/native/sun/awt 
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
 ifeq ($(PLATFORM), linux)
 # Allows for builds on Debian GNU Linux, X11 is in a different place 
-  CPPFLAGS += -I/usr/X11R6/include/X11/extensions \
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
               -I/usr/include/X11/extensions \
               -I$(MOTIF_DIR)/include \
               -I$(OPENWIN_HOME)/include 
@@ -134,6 +144,14 @@
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(MOTIF_DIR)/include 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(OPENWIN_HOME)/include
+endif
+
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
+
 ifeq ($(MILESTONE), internal)
   CPPFLAGS += -DINTERNAL_BUILD
 endif
--- jdk/make/tools/freetypecheck/Makefile
+++ jdk/make/tools/freetypecheck/Makefile
@@ -60,8 +60,12 @@
   #add runtime lib search path to ensure test will be runnable
   ifeq ($(PLATFORM), solaris)
     FT_OPTIONS += -R $(FT_LIB) -lfreetype
-  else #linux
-      FT_OPTIONS += -Wl,-rpath -Wl,$(FT_LIB) -lfreetype
+  else 
+    ifeq ($(PLATFORM), bsd)
+      FT_OPTIONS += -lfreetype %%ZLIB_LDFLAGS%%
+    else # linux
+        FT_OPTIONS += -Wl,-rpath -Wl,$(FREETYPE_LIB_PATH) -lfreetype
+    endif
   endif
 endif
 
--- jdk/src/share/back/commonRef.c
+++ jdk/src/share/back/commonRef.c
@@ -23,6 +23,10 @@
  * questions.
  */
 
+#if defined(_ALLBSD_SOURCE)
+#include <stdint.h>			/* for uintptr_t */
+#endif
+
 #include "util.h"
 #include "commonRef.h"
 
--- jdk/src/share/bin/java.c
+++ jdk/src/share/bin/java.c
@@ -104,6 +104,11 @@
 static char *launchername;
 jboolean _launcher_debug = JNI_FALSE;
 
+#ifdef __APPLE__
+static jboolean continueInSameThread = JNI_FALSE; /* start VM in current thread */
+#endif
+
+
 /*
  * Entries for splash screen environment variables.
  * putenv is performed in SelectVersion. We need
@@ -146,6 +151,10 @@
 static void SetPaths(int argc, char **argv);
 
 
+#ifdef __APPLE__
+static int ContinueInSameThread(InvocationFunctions* ifn, int argc, char **argv, char *jarfile, char *classname, int ret);
+#endif
+
 /* Maximum supported entries from jvm.cfg. */
 #define INIT_MAX_KNOWN_VMS      10
 /* Values for vmdesc.flag */
@@ -184,13 +193,13 @@
 
 int JNICALL JavaMain(void * args); /* entry point                  */
 
-struct JavaMainArgs {
+typedef struct {
   int     argc;
   char ** argv;
   char *  jarfile;
   char *  classname;
   InvocationFunctions ifn;
-};
+} JavaMainArgs;
 
 /*
  * Entry point.
@@ -332,49 +341,24 @@
     /* Show the splash screen if needed */
     ShowSplashScreen();
 
-    /*
-     * Done with all command line processing and potential re-execs so
-     * clean up the environment.
-     */
-    (void)UnsetEnv(ENV_ENTRY);
-    (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
-    (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
-
-    JLI_MemFree(splash_jar_entry);
-    JLI_MemFree(splash_file_entry);
 
-    /*
-     * If user doesn't specify stack size, check if VM has a preference.
-     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
-     * return its default stack size through the init args structure.
-     */
-    if (threadStackSize == 0) {
-      struct JDK1_1InitArgs args1_1;
-      memset((void*)&args1_1, 0, sizeof(args1_1));
-      args1_1.version = JNI_VERSION_1_1;
-      ifn.GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
-      if (args1_1.javaStackSize > 0) {
-         threadStackSize = args1_1.javaStackSize;
+#ifdef __APPLE__
+      if (continueInSameThread == JNI_TRUE) {
+        return ContinueInSameThread(&ifn, argc, argv, jarfile, classname, ret);
+      } else {
+        return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
       }
-    }
-
-    { /* Create a new thread to create JVM and invoke main method */
-      struct JavaMainArgs args;
+#else
 
-      args.argc = argc;
-      args.argv = argv;
-      args.jarfile = jarfile;
-      args.classname = classname;
-      args.ifn = ifn;
+      return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
+#endif
 
-      return ContinueInNewThread(JavaMain, threadStackSize, (void*)&args, ret);
-    }
 }
 
 int JNICALL
 JavaMain(void * _args)
 {
-    struct JavaMainArgs *args = (struct JavaMainArgs *)_args;
+    JavaMainArgs *args = (JavaMainArgs *)_args;
     int argc = args->argc;
     char **argv = args->argv;
     char *jarfile = args->jarfile;
@@ -1159,6 +1143,10 @@
         } else if (strcmp(arg, "-X") == 0) {
             printXUsage = JNI_TRUE;
             return JNI_TRUE;
+#ifdef __APPLE__
+        } else if (JLI_StrCmp(arg, "-XstartOnFirstThread") == 0) {
+            continueInSameThread = JNI_TRUE;
+#endif            
 /*
  * The following case provide backward compatibility with old-style
  * command line options.
@@ -1979,6 +1967,84 @@
     return -1;
 }
 
+static int
+ContinueInNewThread(InvocationFunctions* ifn, int argc,
+                     char **argv, char *jarfile, char *classname, int ret)
+{
+
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+      struct JDK1_1InitArgs args1_1;
+      memset((void*)&args1_1, 0, sizeof(args1_1));
+      args1_1.version = JNI_VERSION_1_1;
+      ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+      if (args1_1.javaStackSize > 0) {
+         threadStackSize = args1_1.javaStackSize;
+      }
+    }
+
+    { /* Create a new thread to create JVM and invoke main method */
+      JavaMainArgs args;
+      int rslt;
+
+      args.argc = argc;
+      args.argv = argv;
+      args.jarfile = jarfile;
+      args.classname = classname;
+      args.ifn = *ifn;
+
+      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&args);
+      /* If the caller has deemed there is an error we
+       * simply return that, otherwise we return the value of
+       * the callee
+       */
+      return (ret != 0) ? ret : rslt;
+    }
+}
+
+
+#ifdef __APPLE__
+static int
+ContinueInSameThread(InvocationFunctions* ifn, int argc,
+                    char **argv, char *jarfile, char *classname, int ret)
+{
+        
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+        struct JDK1_1InitArgs args1_1;
+        memset((void*)&args1_1, 0, sizeof(args1_1));
+        args1_1.version = JNI_VERSION_1_1;
+        ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+        if (args1_1.javaStackSize > 0) {
+            threadStackSize = args1_1.javaStackSize;
+        }
+    }
+    
+    { /* Create create JVM and invoke main method */
+        JavaMainArgs args;
+        int rslt;
+        
+        args.argc = argc;
+        args.argv = argv;
+        args.jarfile = jarfile;
+        args.classname = classname;
+        args.ifn = *ifn;
+        
+        rslt = JavaMain((void*)&args);
+        
+        return (ret != 0) ? ret : rslt;
+    }
+}
+#endif
+
 static void
 FreeKnownVMs()
 {
--- jdk/src/share/bin/java.h
+++ jdk/src/share/bin/java.h
@@ -91,11 +91,17 @@
 void PrintMachineDependentOptions();
 
 const char *jlong_format_specifier();
+
 /*
  * Block current thread and continue execution in new thread
  */
-int ContinueInNewThread(int (JNICALL *continuation)(void *),
-                        jlong stack_size, void * args, int ret);
+int ContinueInNewThread0(int (JNICALL *continuation)(void *),
+                        jlong stack_size, void * args);
+
+
+ static int ContinueInNewThread(InvocationFunctions* ifn, int argc, char** argv,
+                         char* jarfile, char* classname, int ret);
+
 
 /* sun.java.launcher.* platform properties. */
 void SetJavaLauncherPlatformProps(void);
--- jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java
+++ jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java
@@ -477,6 +477,8 @@
                 String[] dirs = new String[] {
                     userHome + sep + ".themes",
                     System.getProperty("swing.metacitythemedir"),
+		    "%%LOCALBASE%%/share/themes",
+		    "%%LOCALBASE%%/share/gnome/themes",
                     "/usr/share/themes",
                     "/usr/gnome/share/themes",  // Debian/Redhat/Solaris
                     "/opt/gnome2/share/themes"  // SuSE
--- jdk/src/share/classes/java/awt/Font.java
+++ jdk/src/share/classes/java/awt/Font.java
@@ -449,18 +449,19 @@
      */
     private AttributeValues getAttributeValues() {
         if (values == null) {
-            values = new AttributeValues();
-            values.setFamily(name);
-            values.setSize(pointSize); // expects the float value.
+            AttributeValues valuesTmp = new AttributeValues();
+            valuesTmp.setFamily(name);
+            valuesTmp.setSize(pointSize); // expects the float value.
 
             if ((style & BOLD) != 0) {
-                values.setWeight(2); // WEIGHT_BOLD
+                valuesTmp.setWeight(2); // WEIGHT_BOLD
             }
 
             if ((style & ITALIC) != 0) {
-                values.setPosture(.2f); // POSTURE_OBLIQUE
+                valuesTmp.setPosture(.2f); // POSTURE_OBLIQUE
             }
-            values.defineAll(PRIMARY_MASK); // for streaming compatibility
+            valuesTmp.defineAll(PRIMARY_MASK); // for streaming compatibility
+            values = valuesTmp;
         }
 
         return values;
--- jdk/src/share/classes/java/awt/GraphicsEnvironment.java
+++ jdk/src/share/classes/java/awt/GraphicsEnvironment.java
@@ -148,7 +148,12 @@
                         } else {
                             String osName = System.getProperty("os.name");
                             headless = defaultHeadless =
-                                Boolean.valueOf(("Linux".equals(osName) || "SunOS".equals(osName)) &&
+                                Boolean.valueOf(("Linux".equals(osName) ||
+                                                "SunOS".equals(osName) ||
+                                                "FreeBSD".equals(osName) ||
+                                                "NetBSD".equals(osName) ||
+                                                "OpenBSD".equals(osName) ||
+                                                "Darwin".equals(osName)) &&
                                                 (System.getenv("DISPLAY") == null));
                         }
                     } else if (nm.equals("true")) {
--- jdk/src/share/classes/java/util/TimeZone.java
+++ jdk/src/share/classes/java/util/TimeZone.java
@@ -833,15 +833,13 @@
         }
         int gmtOffset =  (hours * 60 + num) * 60 * 1000;
 
+        zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         if (gmtOffset == 0) {
-            zi = ZoneInfoFile.getZoneInfo(GMT_ID);
             if (negative) {
                 zi.setID("GMT-00:00");
             } else {
                 zi.setID("GMT+00:00");
             }
-        } else {
-            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         }
         return zi;
     }
--- jdk/src/share/classes/sun/awt/FontConfiguration.java
+++ jdk/src/share/classes/sun/awt/FontConfiguration.java
@@ -1073,7 +1073,7 @@
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!environment.isLinux) {
+        if (!environment.isLinuxOrBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
@@ -1309,7 +1309,7 @@
                                    + "<filename."
                                    + getString(table_componentFontNameIDs[ii])
                                    + "> entry is missing!!!");
-                if (!osName.contains("Linux")) {
+                if (!osName.contains("Linux") && !osName.contains("BSD") && !osName.contains("Darwin")) {
                     errors++;
                 }
             }
--- jdk/src/share/classes/sun/font/TrueTypeFont.java
+++ jdk/src/share/classes/sun/font/TrueTypeFont.java
@@ -160,6 +160,13 @@
     private boolean supportsJA;
     private boolean supportsCJK;
 
+    /* These are for faster access to the name of the font as
+     * typically exposed via API to applications.
+     */
+    private Locale nameLocale;
+    private String localeFamilyName;
+    private String localeFullName;
+
     /**
      * - does basic verification of the file
      * - reads the header table for this font (within a collection)
@@ -1061,6 +1068,10 @@
              * greater than 32767, so read and store those as ints
              */
             int stringPtr = sbuffer.get() & 0xffff;
+
+            nameLocale = sun.awt.SunToolkit.getStartupLocale();
+            short nameLocaleID = FontManager.getLCIDFromLocale(nameLocale);
+
             for (int i=0; i<numRecords; i++) {
                 short platformID = sbuffer.get();
                 if (platformID != MS_PLATFORM_ID) {
@@ -1072,15 +1083,24 @@
                 short nameID     = sbuffer.get();
                 int nameLen    = ((int) sbuffer.get()) & 0xffff;
                 int namePtr    = (((int) sbuffer.get()) & 0xffff) + stringPtr;
-
+                String tmpName = null;
                 switch (nameID) {
 
                 case FAMILY_NAME_ID:
 
-                    if (familyName == null || langID == ENGLISH_LOCALE_ID) {
+                    if (familyName == null || langID == ENGLISH_LOCALE_ID ||
+                        langID == nameLocaleID)
+                    {
                         buffer.position(namePtr);
                         buffer.get(name, 0, nameLen);
-                        familyName = makeString(name, nameLen, encodingID);
+                        tmpName = makeString(name, nameLen, encodingID);
+
+                        if (familyName == null || langID == ENGLISH_LOCALE_ID){
+                            familyName = tmpName;
+                        }
+                        if (langID == nameLocaleID) {
+                            localeFamilyName = tmpName;
+                        }
                     }
 /*
                     for (int ii=0;ii<nameLen;ii++) {
@@ -1098,15 +1118,29 @@
 
                 case FULL_NAME_ID:
 
-                    if (fullName == null || langID == ENGLISH_LOCALE_ID) {
+                    if (fullName == null || langID == ENGLISH_LOCALE_ID ||
+                        langID == nameLocaleID)
+                    {
                         buffer.position(namePtr);
                         buffer.get(name, 0, nameLen);
-                        fullName = makeString(name, nameLen, encodingID);
+                        tmpName = makeString(name, nameLen, encodingID);
+
+                        if (fullName == null || langID == ENGLISH_LOCALE_ID) {
+                            fullName = tmpName;
+                        }
+                        if (langID == nameLocaleID) {
+                            localeFullName = tmpName;
+                        }
                     }
                     break;
-
                 }
             }
+            if (localeFamilyName == null) {
+                localeFamilyName = familyName;
+            }
+            if (localeFullName == null) {
+                localeFullName = fullName;
+            }
         }
     }
 
@@ -1189,6 +1223,8 @@
     public String getFontName(Locale locale) {
         if (locale == null) {
             return fullName;
+        } else if (locale.equals(nameLocale) && localeFullName != null) {
+            return localeFullName;
         } else {
             short localeID = FontManager.getLCIDFromLocale(locale);
             String name = lookupName(localeID, FULL_NAME_ID);
@@ -1203,11 +1239,13 @@
     public String getFamilyName(Locale locale) {
         if (locale == null) {
             return familyName;
+        } else if (locale.equals(nameLocale) && localeFamilyName != null) {
+            return localeFamilyName;
         } else {
             short localeID = FontManager.getLCIDFromLocale(locale);
             String name = lookupName(localeID, FAMILY_NAME_ID);
             if (name == null) {
-                return familyName;
+               return familyName;
             } else {
                 return name;
             }
--- jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java
+++ jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java
@@ -76,7 +76,7 @@
 public abstract class SunGraphicsEnvironment extends GraphicsEnvironment
     implements FontSupport, DisplayChangedListener {
 
-    public static boolean isLinux;
+    public static boolean isLinuxOrBSD;
     public static boolean isSolaris;
     public static boolean isWindows;
     public static boolean noType1Font;
@@ -164,7 +164,15 @@
             public Object run() {
                 String osName = System.getProperty("os.name");
                 if ("Linux".equals(osName)) {
-                    isLinux = true;
+                    isLinuxOrBSD = true;
+                } else if ("FreeBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("Darwin".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("NetBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("OpenBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
                 } else if ("SunOS".equals(osName)) {
                     isSolaris = true;
                 } else if ("Windows".equals(osName)) {
@@ -227,8 +235,8 @@
                  * Pass "true" to registerFonts method as on-screen these
                  * JRE fonts always go through the T2K rasteriser.
                  */
-                if (isLinux) {
-                    /* Linux font configuration uses these fonts */
+                if (isLinuxOrBSD) {
+                    /* Linux/BSD font configuration uses these fonts */
                     registerFontDir(jreFontDirName);
                 }
                 registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,
--- jdk/src/share/classes/sun/nio/ch/KqueueSelectorProvider.java
+++ jdk/src/share/classes/sun/nio/ch/KqueueSelectorProvider.java
@@ -0,0 +1,17 @@
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+public class KqueueSelectorProvider
+    extends SelectorProviderImpl
+{
+    public AbstractSelector openSelector() throws IOException {
+	return new KqueueSelectorImpl(this);
+    }
+
+    public Channel inheritedChannel() throws IOException {
+	return InheritedChannel.getChannel();
+    }
+}
--- jdk/src/share/classes/sun/print/PSPrinterJob.java
+++ jdk/src/share/classes/sun/print/PSPrinterJob.java
@@ -1531,9 +1531,33 @@
             pFlags |= NOSHEET;
             ncomps+=1;
         }
-       if (System.getProperty("os.name").equals("Linux")) {
+
+       String osname = System.getProperty("os.name");
+       if (osname.equals("Linux") || osname.endsWith("BSD") || osname.contains("OS X")) {
+            String lprPath = "/usr/bin/lpr";
+            if (osname.endsWith("BSD")) {
+                final PrintService pservice = getPrintService();
+                Boolean isIPPPrinter =
+                    (Boolean)java.security.AccessController.doPrivileged(
+                    new java.security.PrivilegedAction() {
+                        public Object run() {
+                            try {
+                                Class psClass =
+                                    Class.forName("sun.print.IPPPrintService");
+                                if (psClass.isInstance(pservice)) {
+                                    return Boolean.TRUE;
+                                }
+                            } catch (Throwable t) {
+                            }
+                            return Boolean.FALSE;
+                        }
+                    });
+                if (isIPPPrinter) {
+                    lprPath = "%%LOCALBASE%%/bin/lpr";
+                }
+            }
             execCmd = new String[ncomps];
-            execCmd[n++] = "/usr/bin/lpr";
+            execCmd[n++] = lprPath;
             if ((pFlags & PRINTER) != 0) {
                 execCmd[n++] = new String("-P" + printer);
             }
--- jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java
+++ jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java
@@ -49,8 +49,12 @@
             AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
                     public Boolean run() {
                             String osname = System.getProperty("os.name");
-                            if (osname.startsWith("SunOS") ||
-                                osname.startsWith("Linux")) {
+                            if (osname.startsWith("SunOS")
+                                    || osname.startsWith("Linux")
+                                    || osname.startsWith("FreeBSD")
+                                    || osname.startsWith("NetBSD")
+                                    || osname.startsWith("OpenBSD")
+                                    || osname.startsWith("Darwin")) {
                                 return new Boolean(System.getProperty
                                     (USE_NATIVE_PROP));
                             }
--- jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
+++ jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
@@ -82,7 +82,11 @@
                             String osname = System.getProperty("os.name");
                             if (osname.startsWith("SunOS")) {
                                 gssLib = "libgss.so";
-                            } else if (osname.startsWith("Linux")) {
+                            } else if (osname.startsWith("Linux")
+                                    || osname.startsWith("FreeBSD")
+                                    || osname.startsWith("NetBSD")
+                                    || osname.startsWith("OpenBSD")
+                                    || osname.startsWith("Darwin")) {
                                 gssLib = "libgssapi.so";
                             }
                         }
--- jdk/src/share/classes/sun/security/krb5/Config.java
+++ jdk/src/share/classes/sun/security/krb5/Config.java
@@ -711,7 +711,11 @@
                     }
                 } else if (osname.startsWith("SunOS")) {
                     name =  "/etc/krb5/krb5.conf";
-                } else if (osname.startsWith("Linux")) {
+                } else if (osname.startsWith("Linux")
+                        || osname.startsWith("FreeBSD")
+                        || osname.startsWith("NetBSD")
+                        || osname.startsWith("OpenBSD")
+                        || osname.startsWith("Darwin")) {
                     name =  "/etc/krb5.conf";
                 }
             }
--- jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java
+++ jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java
@@ -386,8 +386,12 @@
             String uidStr = null;
             long uid = 0;
 
-            if (osname.startsWith("SunOS") ||
-                (osname.startsWith("Linux"))) {
+            if (osname.startsWith("SunOS")
+                    || osname.startsWith("Linux")
+                    || osname.startsWith("FreeBSD")
+                    || osname.startsWith("NetBSD")
+                    || osname.startsWith("OpenBSD")
+                    || osname.startsWith("Darwin")) {
                 try {
                     Class<?> c = Class.forName
                         ("com.sun.security.auth.module.UnixSystem");
--- jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider
+++ jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider
@@ -30,3 +30,4 @@
 #[solaris]sun.tools.attach.SolarisAttachProvider
 #[windows]sun.tools.attach.WindowsAttachProvider
 #[linux]sun.tools.attach.LinuxAttachProvider
+#[bsd]sun.tools.attach.BsdAttachProvider
--- jdk/src/share/classes/sun/tools/jar/Main.java
+++ jdk/src/share/classes/sun/tools/jar/Main.java
@@ -48,6 +48,7 @@
     String zname = "";
     String[] files;
     String rootjar = null;
+    String cwd;
 
     // An entryName(path)->File map generated during "expand", it helps to
     // decide whether or not an existing entry in a jar file needs to be
@@ -250,6 +251,16 @@
                     }
                 }
             } else if (xflag) {
+                // Current working directory
+                cwd = System.getProperty("user.dir");
+                if (cwd == null) {
+                    fatalError(getMsg("error.no.cwd"));
+                }
+                cwd = (new File(cwd)).getCanonicalPath();
+                if (!cwd.endsWith(File.separator)) {
+                    cwd += File.separator;
+                }
+                // Extract the files
                 replaceFSC(files);
                 if (fname != null && files != null) {
                     extract(fname, files);
@@ -975,6 +986,10 @@
             return rc;    // leading '/' or 'dot-dot' only path
         }
         File f = new File(name.replace('/', File.separatorChar));
+        if (!f.getCanonicalPath().startsWith(cwd)) {
+            output(formatMsg("out.ignore.entry", name));
+            return null;
+        }
         if (e.isDirectory()) {
             if (f.exists()) {
                 if (!f.isDirectory()) {
@@ -996,6 +1011,10 @@
         } else {
             if (f.getParent() != null) {
                 File d = new File(f.getParent());
+                if (!d.getCanonicalPath().startsWith(cwd)) {
+                    output(formatMsg("out.ignore.entry", name));
+                    return null;
+                }
                 if (!d.exists() && !d.mkdirs() || !d.isDirectory()) {
                     throw new IOException(formatMsg(
                         "error.create.dir", d.getPath()));
--- jdk/src/share/classes/sun/tools/jar/resources/jar.properties
+++ jdk/src/share/classes/sun/tools/jar/resources/jar.properties
@@ -44,6 +44,8 @@
         {0} : could not create directory
 error.incorrect.length=\
         incorrect length while processing: {0}
+error.no.cwd=\
+	{0} : could not determine current working directory
 out.added.manifest=\
         added manifest
 out.update.manifest=\
--- jdk/src/share/hpi/include/hpi_impl.h
+++ jdk/src/share/hpi/include/hpi_impl.h
@@ -138,7 +138,11 @@
 int sysBind(int fd, struct sockaddr *him, int len);
 int sysAccept(int fd, struct sockaddr *him, int *len);
 int sysGetSockName(int fd, struct sockaddr *him, int *len);
-#ifdef _LP64
+#if defined(_LP64) || defined(_ALLBSD_SOURCE)
+// XXXBSD: The implementations all use ssize_t, except on Windows,
+// regardless of _LP64. The resulting mismatch between "int" and "ssize_t"
+// causes gcc on Darwin to report a conflicting types error.
+// Appears to be an upstream issue introduced in 1.7
 ssize_t sysSendTo(int fd, char *buf, int len, int flags, struct sockaddr *to,
               int tolen);
 ssize_t sysRecvFrom(int fd, char *buf, int nbytes, int flags,
--- jdk/src/share/native/com/sun/java/util/jar/pack/defines.h
+++ jdk/src/share/native/com/sun/java/util/jar/pack/defines.h
@@ -32,6 +32,10 @@
 #include <unistd.h>
 #endif
 
+#ifndef NO_ZLIB
+#      include <zconf.h>
+#endif
+
 #ifndef FULL
 #define FULL 1 /* Adds <500 bytes to the zipped final product. */
 #endif
@@ -89,11 +93,13 @@
 // bytes and byte arrays
 
 typedef unsigned int uint;
+#ifdef NO_ZLIB
 #ifdef _LP64
 typedef unsigned int uLong; // Historical zlib, should be 32-bit.
 #else
 typedef unsigned long uLong;
 #endif
+#endif
 #ifdef _MSC_VER 
 typedef LONGLONG 	jlong;
 typedef DWORDLONG 	julong;
--- jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp
+++ jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp
@@ -33,9 +33,14 @@
 #include <limits.h>
 #include <time.h>
 
+/* !PRODUCT needs intptr_t */
+#if defined(_ALLBSD_SOURCE) && !defined(PRODUCT)
+#include <stdint.h>
+#endif
+
 #if defined(unix) && !defined(PRODUCT)
 #include "pthread.h"
-#define THREAD_SELF ((int)pthread_self())
+#define THREAD_SELF ((intptr_t) pthread_self())
 #endif
 
 #include "defines.h"
@@ -58,9 +63,9 @@
 // Single-threaded, implementation, not reentrant.
 // Includes a weak error check against MT access.
 #ifndef THREAD_SELF
-#define THREAD_SELF (0)
+#define THREAD_SELF ((intptr_t) 0)
 #endif
-NOT_PRODUCT(static int uThread = -1;)
+NOT_PRODUCT(static intptr_t uThread = -1;)
 
 unpacker* unpacker::non_mt_current = null;
 unpacker* unpacker::current() {
@@ -69,7 +74,7 @@
 }
 static void set_current_unpacker(unpacker* u) {
   unpacker::non_mt_current = u;
-  assert(((uThread = (u == null) ? -1 : THREAD_SELF),
+  assert(((uThread = (u == null) ? ((intptr_t) -1) : THREAD_SELF),
           true));
 }
 
--- jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c
+++ jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c
@@ -33,7 +33,11 @@
 
 #include <jni.h>
 // for malloc
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "SoundDefs.h"
 #include "DirectAudio.h"
 #include "Utilities.h"
--- jdk/src/share/native/com/sun/media/sound/SoundDefs.h
+++ jdk/src/share/native/com/sun/media/sound/SoundDefs.h
@@ -31,6 +31,7 @@
 #define X_WINDOWS       1
 #define X_SOLARIS       2
 #define X_LINUX         3
+#define X_BSD           4
 
 // types for X_ARCH
 #define X_I586          1
@@ -50,7 +51,7 @@
 
 
 // following is needed for _LP64
-#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX))
+#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX) || (X_PLATFORM == X_BSD))
 #include <sys/types.h>
 #endif
 
@@ -130,4 +131,9 @@
 #endif
 
 
+#if X_PLATFORM == X_BSD
+#define INLINE          inline
+#endif
+
+
 #endif  // __SOUNDDEFS_INCLUDED__
--- jdk/src/share/native/common/check_code.c
+++ jdk/src/share/native/common/check_code.c
@@ -1069,7 +1069,7 @@
  * Make sure that branches don't go into the middle of nowhere.
  */
 
-static jint ntohl(jint n)
+static jint _ck_ntohl(jint n)
 {
     unsigned char *p = (unsigned char *)&n;
     return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
@@ -1148,26 +1148,26 @@
             }
         }
         if (opcode == opc_tableswitch) {
-            keys = ntohl(lpc[2]) -  ntohl(lpc[1]) + 1;
+            keys = _ck_ntohl(lpc[2]) -  _ck_ntohl(lpc[1]) + 1;
             delta = 1;
         } else {
-            keys = ntohl(lpc[1]); /* number of pairs */
+            keys = _ck_ntohl(lpc[1]); /* number of pairs */
             delta = 2;
             /* Make sure that the tableswitch items are sorted */
             for (k = keys - 1, lptr = &lpc[2]; --k >= 0; lptr += 2) {
-                int this_key = ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
-                int next_key = ntohl(lptr[2]);
+                int this_key = _ck_ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
+                int next_key = _ck_ntohl(lptr[2]);
                 if (this_key >= next_key) {
                     CCerror(context, "Unsorted lookup switch");
                 }
             }
         }
         saved_operand = NEW(int, keys + 2);
-        if (!isLegalTarget(context, offset + ntohl(lpc[0])))
+        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))
             CCerror(context, "Illegal default target in switch");
-        saved_operand[keys + 1] = code_data[offset + ntohl(lpc[0])];
+        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];
         for (k = keys, lptr = &lpc[3]; --k >= 0; lptr += delta) {
-            int target = offset + ntohl(lptr[0]);
+            int target = offset + _ck_ntohl(lptr[0]);
             if (!isLegalTarget(context, target))
                 CCerror(context, "Illegal branch in opc_tableswitch");
             saved_operand[k + 1] = code_data[target];
@@ -1615,7 +1615,7 @@
             if (lpc + 2 >= (int *)end) {
                 return -1; /* do not read pass the end */
             }
-            index = ntohl(lpc[2]) - ntohl(lpc[1]);
+	    index = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]);
             if ((index < 0) || (index > 65535)) {
                 return -1;      /* illegal */
             } else {
@@ -1628,7 +1628,7 @@
             int npairs;
             if (lpc + 1 >= (int *)end)
                 return -1; /* do not read pass the end */
-            npairs = ntohl(lpc[1]);
+	    npairs = _ck_ntohl(lpc[1]);
             /* There can't be more than 64K labels because of the limit
              * on per-method byte code length.
              */
--- jdk/src/share/native/java/io/io_util.h
+++ jdk/src/share/native/java/io/io_util.h
@@ -29,7 +29,15 @@
 extern jfieldID IO_fd_fdID;
 extern jfieldID IO_handle_fdID;
 
-#if !defined(O_DSYNC) || !defined(O_SYNC)
+#ifdef _ALLBSD_SOURCE
+#include <fcntl.h>
+#ifndef O_SYNC
+#define O_SYNC  O_FSYNC
+#endif
+#ifndef O_DSYNC
+#define O_DSYNC O_FSYNC
+#endif
+#elif !defined(O_DSYNC) || !defined(O_SYNC)
 #define O_SYNC  (0x0800)
 #define O_DSYNC (0x2000)
 #endif
--- jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h
+++ jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h
@@ -25,6 +25,10 @@
  * questions.
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include "jfdlibm.h"
 
 #ifdef __NEWVALID       /* special setup for Sun test regime */
@@ -47,11 +51,13 @@
 #define __LOp(x) *(1+(int*)x)
 #endif
 
+#ifndef __P
 #ifdef __STDC__
 #define __P(p)  p
 #else
 #define __P(p)  ()
 #endif
+#endif
 
 /*
  * ANSI/POSIX
--- jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h
+++ jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h
@@ -61,7 +61,7 @@
 #define log1p   jlog1p
 #define expm1   jexpm1
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define __ieee754_sqrt          __j__ieee754_sqrt
 #define __ieee754_acos          __j__ieee754_acos
 #define __ieee754_acosh         __j__ieee754_acosh
--- jdk/src/share/native/java/util/zip/Inflater.c
+++ jdk/src/share/native/java/util/zip/Inflater.c
@@ -65,6 +65,10 @@
 	return jlong_zero;
     } else {
 	char *msg;
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+	strm->adler = 1;
+#endif
 	switch (inflateInit2(strm, nowrap ? -MAX_WBITS : MAX_WBITS)) {
 	  case Z_OK:
 	    return ptr_to_jlong(strm);
@@ -197,6 +201,10 @@
     if (inflateReset(jlong_to_ptr(addr)) != Z_OK) {
 	JNU_ThrowInternalError(env, 0);
     }
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+    ((z_stream *)jlong_to_ptr(strm))->adler = 1;
+#endif
 }
 
 JNIEXPORT void JNICALL
--- jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h
+++ jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h
@@ -42,44 +42,49 @@
 /* for _LP64 */
 #include <sys/types.h>
 
+/**
+ * Privatise the symbols to the JDK.
+ */
+#define Z_PREFIX
+
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
  */
 #ifdef Z_PREFIX
-#  define deflateInit_  z_deflateInit_
-#  define deflate       z_deflate
-#  define deflateEnd    z_deflateEnd
-#  define inflateInit_  z_inflateInit_
-#  define inflate       z_inflate
-#  define inflateEnd    z_inflateEnd
-#  define deflateInit2_ z_deflateInit2_
-#  define deflateSetDictionary z_deflateSetDictionary
-#  define deflateCopy   z_deflateCopy
-#  define deflateReset  z_deflateReset
-#  define deflateParams z_deflateParams
-#  define inflateInit2_ z_inflateInit2_
-#  define inflateSetDictionary z_inflateSetDictionary
-#  define inflateSync   z_inflateSync
-#  define inflateSyncPoint z_inflateSyncPoint
-#  define inflateReset  z_inflateReset
-#  define compress      z_compress
-#  define compress2     z_compress2
-#  define uncompress    z_uncompress
-#  define adler32       z_adler32
-#  define crc32         z_crc32
-#  define get_crc_table z_get_crc_table
-
-#  define Byte          z_Byte
-#  define uInt          z_uInt
-#  define uLong         z_uLong
-#  define Bytef         z_Bytef
-#  define charf         z_charf
-#  define intf          z_intf
-#  define uIntf         z_uIntf
-#  define uLongf        z_uLongf
-#  define voidpf        z_voidpf
-#  define voidp         z_voidp
+#  define deflateInit_  _java_z_deflateInit_
+#  define deflate       _java_z_deflate
+#  define deflateEnd    _java_z_deflateEnd
+#  define inflateInit_  _java_z_inflateInit_
+#  define inflate       _java_z_inflate
+#  define inflateEnd    _java_z_inflateEnd
+#  define deflateInit2_ _java_z_deflateInit2_
+#  define deflateSetDictionary _java_z_deflateSetDictionary
+#  define deflateCopy   _java_z_deflateCopy
+#  define deflateReset  _java_z_deflateReset
+#  define deflateParams _java_z_deflateParams
+#  define inflateInit2_ _java_z_inflateInit2_
+#  define inflateSetDictionary _java_z_inflateSetDictionary
+#  define inflateSync   _java_z_inflateSync
+#  define inflateSyncPoint _java_z_inflateSyncPoint
+#  define inflateReset  _java_z_inflateReset
+#  define compress      _java_z_compress
+#  define compress2     _java_z_compress2
+#  define uncompress    _java_z_uncompress
+#  define adler32       _java_z_adler32
+#  define crc32         _java_z_crc32
+#  define get_crc_table _java_z_get_crc_table
+
+#  define Byte          _java_z_Byte
+#  define uInt          _java_z_uInt
+#  define uLong         _java_z_uLong
+#  define Bytef         _java_z_Bytef
+#  define charf         _java_z_charf
+#  define intf          _java_z_intf
+#  define uIntf         _java_z_uIntf
+#  define uLongf        _java_z_uLongf
+#  define voidpf        _java_z_voidpf
+#  define voidp         _java_z_voidp
 #endif
 
 #if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
--- jdk/src/share/native/sun/awt/debug/debug_util.h
+++ jdk/src/share/native/sun/awt/debug/debug_util.h
@@ -50,7 +50,9 @@
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <malloc.h>
+#endif
 #include <limits.h>
 
 /* keep these after the other headers */
--- jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c
+++ jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c
@@ -24,7 +24,11 @@
  */
 
 #include "BufImgSurfaceData.h"
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "sun_awt_image_BufImgSurfaceData.h"
 
--- jdk/src/share/native/sun/awt/image/DataBufferNative.c
+++ jdk/src/share/native/sun/awt/image/DataBufferNative.c
@@ -23,7 +23,11 @@
  * questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "SurfaceData.h"
 #include "sun_awt_image_DataBufferNative.h"
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c
@@ -86,7 +86,7 @@
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c
@@ -95,7 +95,7 @@
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -612,7 +612,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -622,12 +622,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -637,7 +637,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -645,7 +645,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -655,12 +655,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -670,7 +670,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -718,7 +718,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -732,14 +732,14 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -753,7 +753,7 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -763,7 +763,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -777,14 +777,14 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -798,7 +798,7 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -851,7 +851,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -861,12 +861,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -876,12 +876,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -891,12 +891,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -906,7 +906,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -914,7 +914,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -924,12 +924,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -939,12 +939,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -954,12 +954,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -969,7 +969,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c
@@ -88,7 +88,7 @@
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
--- jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c
@@ -275,11 +275,11 @@
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
--- jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* BYTE_ORDER == ... */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- jdk/src/share/native/sun/awt/medialib/mlib_image.h
+++ jdk/src/share/native/sun/awt/medialib/mlib_image.h
@@ -27,6 +27,11 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
+
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
--- jdk/src/share/native/sun/awt/medialib/mlib_sys.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_sys.c
@@ -26,9 +26,15 @@
 
 #include <stdlib.h>
 #include <string.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#endif
 #include <mlib_types.h>
 #include <mlib_sys_proto.h>
 #include "mlib_SysMath.h"
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#endif
 
 /***************************************************************/
 
@@ -86,7 +92,12 @@
    * alignment. -- from stdlib.h of MS VC++5.0.
    */
   return (void *) malloc(size);
-#else /* _MSC_VER */
+#elif defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
+#elif defined(_ALLBSD_SOURCE)
+  return valloc(size);
+#else
   return (void *) memalign(8, size);
 #endif /* _MSC_VER */
 }
--- jdk/src/share/native/sun/awt/medialib/mlib_types.h
+++ jdk/src/share/native/sun/awt/medialib/mlib_types.h
@@ -59,7 +59,10 @@
 
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(__GNUC__)
 
-#if defined(__linux__)
+#if defined(_ALLBSD_SOURCE)
+#include <stddef.h>                     /* for ptrdiff_t */
+#include <stdint.h>                     /* for uintptr_t */
+#elif defined(__linux__)
 #include <stdint.h>                     /* for uintptr_t */
 #include <malloc.h>                     /* for ptrdiff_t */
 #else
--- jdk/src/share/native/sun/font/AccelGlyphCache.c
+++ jdk/src/share/native/sun/font/AccelGlyphCache.c
@@ -23,7 +23,11 @@
  * questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "jni.h"
 #include "AccelGlyphCache.h"
 #include "Trace.h"
--- jdk/src/share/native/sun/font/DrawGlyphList.c
+++ jdk/src/share/native/sun/font/DrawGlyphList.c
@@ -26,7 +26,11 @@
 #include "jlong.h"
 #include "math.h"
 #include "string.h"
+#ifdef _ALLBSD_SOURCE
+#include "stdlib.h"
+#else
 #include "malloc.h"
+#endif
 #include "sunfontids.h"
 #include "fontscalerdefs.h"
 #include "glyphblitting.h"
--- jdk/src/share/native/sun/font/sunFont.c
+++ jdk/src/share/native/sun/font/sunFont.c
@@ -24,7 +24,9 @@
  */
 
 #include "stdlib.h"
+#ifndef _ALLBSD_SOURCE
 #include "malloc.h"
+#endif
 #include "string.h"
 #include "gdefs.h"
 #include "jlong.h"
--- jdk/src/share/native/sun/java2d/SurfaceData.c
+++ jdk/src/share/native/sun/java2d/SurfaceData.c
@@ -28,7 +28,11 @@
 #include "jni_util.h"
 #include "Disposer.h"
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 #include "string.h"
 
 /**
--- jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h
+++ jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h
@@ -26,6 +26,9 @@
 #ifndef OGLFuncs_h_Included
 #define OGLFuncs_h_Included
 
+#ifdef _ALLBSD_SOURCE
+#include <dlfcn.h>
+#endif
 #include "jni.h"
 #include "J2D_GL/gl.h"
 #include "J2D_GL/glext.h"
--- jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c
+++ jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "sun_java2d_pipe_BufferedOpCodes.h"
 
--- jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c
+++ jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <math.h>
 #include <jlong.h>
 
--- jdk/src/share/transport/socket/socketTransport.c
+++ jdk/src/share/transport/socket/socketTransport.c
@@ -65,6 +65,9 @@
 #define HEADER_SIZE     11
 #define MAX_DATA_SIZE 1000
 
+static jint recv_fully(int, char *, int);
+static jint send_fully(int, char *, int);
+
 /*
  * Record the last error for this thread.
  */
@@ -155,7 +158,7 @@
         }
         buf = b;
         buf += received;
-        n = dbgsysRecv(fd, buf, helloLen-received, 0);
+        n = recv_fully(fd, buf, helloLen-received);
         if (n == 0) {
             setLastError(0, "handshake failed - connection prematurally closed");
             return JDWPTRANSPORT_ERROR_IO_ERROR;
@@ -180,7 +183,7 @@
         return JDWPTRANSPORT_ERROR_IO_ERROR;
     }
 
-    if (dbgsysSend(fd, (char*)hello, helloLen, 0) != helloLen) {
+    if (send_fully(fd, hello,  helloLen) != helloLen) {
         RETURN_IO_ERROR("send failed during handshake");
     }
     return JDWPTRANSPORT_ERROR_NONE;
@@ -555,19 +558,19 @@
     /* Do one send for short packets, two for longer ones */
     if (data_len <= MAX_DATA_SIZE) {
         memcpy(header + HEADER_SIZE, data, data_len);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + data_len, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + data_len) != 
             HEADER_SIZE + data_len) {
             RETURN_IO_ERROR("send failed");
         }
     } else {
         memcpy(header + HEADER_SIZE, data, MAX_DATA_SIZE);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE) != 
             HEADER_SIZE + MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
         /* Send the remaining data bytes right out of the data area. */
-        if (dbgsysSend(socketFD, (char *)data + MAX_DATA_SIZE,
-                       data_len - MAX_DATA_SIZE, 0) != data_len - MAX_DATA_SIZE) {
+        if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE, 
+                       data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
     }
@@ -575,13 +578,33 @@
     return JDWPTRANSPORT_ERROR_NONE;
 }
 
-static jint
+jint
 recv_fully(int f, char *buf, int len)
 {
     int nbytes = 0;
     while (nbytes < len) {
         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
         if (res < 0) {
+	    if (errno == EINTR)
+		continue;
+            return res;
+        } else if (res == 0) {
+            break; /* eof, return nbytes which is less than len */
+        }
+        nbytes += res;
+    }
+    return nbytes;
+}
+
+jint
+send_fully(int f, char *buf, int len)
+{
+    int nbytes = 0;
+    while (nbytes < len) {
+        int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
+        if (res < 0) {
+	    if (errno == EINTR)
+		continue;
             return res;
         } else if (res == 0) {
             break; /* eof, return nbytes which is less than len */
--- jdk/src/solaris/back/exec_md.c
+++ jdk/src/solaris/back/exec_md.c
@@ -30,7 +30,7 @@
 #include "sys.h"
 #include "util.h"
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   /* Linux */
   #define FORK() fork()
 #else
--- jdk/src/solaris/back/linker_md.c
+++ jdk/src/solaris/back/linker_md.c
@@ -48,6 +48,12 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -77,9 +83,9 @@
     }
 
     if (pnamelen == 0) {
-        (void)snprintf(holder, holderlen, "lib%s.so", fname);
+        (void)snprintf(holder, holderlen, "lib%s." LIB_SUFFIX, fname);
     } else {
-        (void)snprintf(holder, holderlen, "%s/lib%s.so", pname, fname);
+        (void)snprintf(holder, holderlen, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
--- jdk/src/solaris/back/util_md.h
+++ jdk/src/solaris/back/util_md.h
@@ -29,7 +29,7 @@
 #include <stddef.h>
 
 /* To get uintptr_t */
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
 #else
 /* The file stdint.h is not on Solaris 8 machines. */
@@ -40,6 +40,7 @@
 
 #include <limits.h>
 #include <sys/types.h>
+#include <machine/endian.h>
 
 #ifdef _LP64
 typedef unsigned long UNSIGNED_JLONG;
@@ -55,7 +56,7 @@
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
--- jdk/src/solaris/bin/java_md.c
+++ jdk/src/solaris/bin/java_md.c
@@ -24,6 +24,7 @@
  */
 
 #include "java.h"
+#include "jvm_md.h"
 #include <dirent.h>
 #include <dlfcn.h>
 #include <fcntl.h>
@@ -34,17 +35,31 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#endif
+
 #include "manifest_info.h"
 #include "version_comp.h"
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #else
 #include <thread.h>
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+/* FALLBACK avoids naming conflicts with system libraries
+ * (eg, ImageIO's libJPEG.dylib) */
+#define LD_LIBRARY_PATH "DYLD_FALLBACK_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 #define JRE_ERROR1      "Error: Could not find Java SE Runtime Environment."
 #define JRE_ERROR11     "Error: Path length exceeds maximum length (PATH_MAX)"
@@ -79,14 +94,31 @@
 #endif
 
 /* pointer to environment */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char **environ;
+#endif
 
 /*
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __linux__
-static const char *system_dir   = "/usr/java";
+#if defined(__FreeBSD__)
+static const char *system_dir	= "%%JAVA_HOME%%";
+static const char *user_dir	= "/java";
+#elif defined(__NetBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__OpenBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__APPLE__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__linux__)
+static const char *system_dir   = "/usr/local/java";
 static const char *user_dir     = "/java";
 #else /* Solaris */
 static const char *system_dir   = "/usr/jdk";
@@ -408,10 +440,10 @@
        * If not on Solaris, assume only a single LD_LIBRARY_PATH
        * variable.
        */
-      runpath = getenv("LD_LIBRARY_PATH");
+      runpath = getenv(LD_LIBRARY_PATH);
 #endif /* __sun */
 
-#ifdef __linux
+#if defined(__linux__)
       /*
        * On linux, if a binary is running as sgid or suid, glibc sets
        * LD_LIBRARY_PATH to the empty string for security purposes.  (In
@@ -427,6 +459,22 @@
       if((getgid() != getegid()) || (getuid() != geteuid()) ) {
         return;
       }
+#elif defined(_ALLBSD_SOURCE)
+      /*
+       * On BSD, if a binary is running as sgid or suid, libc sets
+       * LD_LIBRARY_PATH to the empty string for security purposes.  (In
+       * contrast, on Solaris the LD_LIBRARY_PATH variable for a
+       * privileged binary does not lose its settings; but the dynamic
+       * linker does apply more scrutiny to the path.) The launcher uses
+       * the value of LD_LIBRARY_PATH to prevent an exec loop.
+       * Therefore, if we are running sgid or suid, this function's
+       * setting of LD_LIBRARY_PATH will be ineffective and we should
+       * return from the function now.  Getting the right libraries to
+       * be found must be handled through other mechanisms.
+       */
+      if(issetugid()) {
+        return;
+      }
 #endif
 
       /* runpath contains current effective LD_LIBRARY_PATH setting */
@@ -436,7 +484,7 @@
                               2*strlen(jrepath) + 2*strlen(arch) +
                               strlen(jvmpath) + 52;
       new_runpath = JLI_MemAlloc(new_runpath_size);
-      newpath = new_runpath + strlen("LD_LIBRARY_PATH=");
+      newpath = new_runpath + strlen(LD_LIBRARY_PATH "=");
 
 
       /*
@@ -451,7 +499,7 @@
 
         /* jvmpath, ((running != wanted)?((wanted==64)?"/"LIBARCH64NAME:"/.."):""), */
 
-        sprintf(new_runpath, "LD_LIBRARY_PATH="
+        sprintf(new_runpath, LD_LIBRARY_PATH "="
                 "%s:"
                 "%s/lib/%s:"
                 "%s/../lib/%s",
@@ -737,7 +785,7 @@
 jboolean
 GetApplicationHome(char *buf, jint bufsize)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     char *execname = GetExecname();
     if (execname) {
         strncpy(buf, execname, bufsize-1);
@@ -904,7 +952,17 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__sun && !__linux */
+#elif defined(__FreeBSD__)
+    {
+        char buf[PATH_MAX+1];
+        int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+        size_t len = sizeof(buf);
+        if (sysctl(name, 4, buf, &len, NULL, 0) == 0 && len > 0) {
+            buf[len] = '\0';
+            exec_path = JLI_StringDup(buf);
+        }
+    }
+#else /* !__sun && !__linux && !__FreeBSD__ */
     {
         /* Not implemented */
     }
@@ -993,6 +1051,7 @@
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+#ifdef _SC_PHYS_PAGES
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
   const uint64_t result    = pages * page_size;
@@ -1004,6 +1063,28 @@
            "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   }
+#else
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+  uint64_t result;
+# define UINT64_FORMAT "%" PRIu64
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+       physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  if (_launcher_debug) {
+    printf("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  }
+#endif
   return result;
 }
 
@@ -1099,7 +1180,7 @@
 
 #endif /* __sun && i586 */
 
-#if defined(__linux__) && defined(i586)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(i586)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -1164,7 +1245,7 @@
 #endif
 }
 
-#endif /* __linux__ && i586 */
+#endif /* (__linux__ || _ALLBSD_SOURCE) && i586 */
 
 #ifdef i586
 /*
@@ -1376,6 +1457,39 @@
 
 #endif /* __linux__ && i586 */
 
+#if defined(_ALLBSD_SOURCE) && defined(i586)
+
+/* The definition of a server-class machine for bsd-i586 */
+jboolean
+bsd_i586_ServerClassMachine(void) {
+  jboolean            result            = JNI_FALSE;
+  /* How big is a server class machine? */
+  const unsigned long server_processors = 2UL;
+  const uint64_t      server_memory     = 2UL * GB;
+  /*
+   * We seem not to get our full complement of memory.
+   *     We allow some part (1/8?) of the memory to be "missing",
+   *     based on the sizes of DIMMs, and maybe graphics cards.
+   */
+  const uint64_t      missing_memory    = 256UL * MB;
+  const uint64_t      actual_memory     = physical_memory();
+
+  /* Is this a server class machine? */
+  if (actual_memory >= (server_memory - missing_memory)) {
+    const unsigned long actual_processors = physical_processors();
+    if (actual_processors >= server_processors) {
+      result = JNI_TRUE;
+    }
+  }
+  if (_launcher_debug) {
+    printf("bsd_" LIBARCHNAME "_ServerClassMachine: %s\n",
+           (result == JNI_TRUE ? "true" : "false"));
+  }
+  return result;
+}
+
+#endif /* _ALLBSD_SOURCE && i586 */
+
 /* Dispatch to the platform-specific definition of "server-class" */
 jboolean
 ServerClassMachine(void) {
@@ -1390,6 +1504,8 @@
   result = solaris_i586_ServerClassMachine();
 #elif defined(__linux__) && defined(i586)
   result = linux_i586_ServerClassMachine();
+#elif defined(_ALLBSD_SOURCE) && defined(i586)
+  result = bsd_i586_ServerClassMachine();
 #else
   if (_launcher_debug) {
     printf("ServerClassMachine: returns default value of %s\n",
@@ -1530,7 +1646,7 @@
     while (dp != NULL) {
         cp = strchr(dp, (int)':');
         if (cp != NULL)
-            *cp = (char)NULL;
+            *cp = '\0';
         if ((target = ProcessDir(info, dp)) != NULL)
             break;
         dp = cp;
@@ -1708,9 +1824,29 @@
     return(borrowed_unsetenv(name));
 }
 
+#if defined(_ALLBSD_SOURCE)
+/*
+ * BSD's implementation of CounterGet()
+ */
+int64_t
+CounterGet()
+{
+#ifdef __FreeBSD__
+	struct timespec tp;
+	clock_gettime(CLOCK_MONOTONIC, &tp);
+	return (uint64_t)tp.tv_sec * 1000000 + tp.tv_nsec / 1000;
+#else
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (uint64_t)tv.tv_sec * 1000000 + tv.tv_usec;
+#endif
+}
+#endif
+
+
 /* --- Splash Screen shared library support --- */
 
-static const char* SPLASHSCREEN_SO = "libsplashscreen.so";
+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME("splashscreen");
 
 static void* hSplashLib = NULL;
 
@@ -1759,13 +1895,15 @@
     return "%lld";
 }
 
+
+
 /*
  * Block current thread and continue execution in a new thread
  */
 int
-ContinueInNewThread(int (JNICALL *continuation)(void *), jlong stack_size, void * args, int ret) {
+ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
     int rslt;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pthread_t tid;
     pthread_attr_t attr;
     pthread_attr_init(&attr);
@@ -1778,7 +1916,7 @@
     if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) {
       void * tmp;
       pthread_join(tid, &tmp);
-      rslt = (int)tmp;
+      rslt = (int)(intptr_t)tmp;
     } else {
      /*
       * Continue execution in current thread if for some reason (e.g. out of
@@ -1796,25 +1934,23 @@
     if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {
       void * tmp;
       thr_join(tid, NULL, &tmp);
-      rslt = (int)tmp;
+      rslt = (int)(intptr_t)tmp;
     } else {
       /* See above. Continue in current thread if thr_create() failed */
       rslt = continuation(args);
     }
 #endif
-    /* If the caller has deemed there is an error we
-     * simply return that, otherwise we return the value of
-     * the callee
-     */
-    return (ret != 0) ? ret : rslt;
+    return rslt;
 }
 
+
+
 /* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */
 #define MAX_PID_STR_SZ   20
 
 void SetJavaLauncherPlatformProps() {
-   /* Linux only */
-#ifdef __linux__
+   /* Linux and BSDs only */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     const char *substr = "-Dsun.java.launcher.pid=";
     char *pid_prop_str = (char *)JLI_MemAlloc(strlen(substr) + MAX_PID_STR_SZ + 1);
     sprintf(pid_prop_str, "%s%d", substr, getpid());
--- jdk/src/solaris/bin/java_md.h
+++ jdk/src/solaris/bin/java_md.h
@@ -58,10 +58,14 @@
 #include <sys/time.h>
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
+#elif defined(_ALLBSD_SOURCE)
+/* CounterGet() is implemented in java_md.c */
+int64_t CounterGet(void);
+#define Counter2Micros(counts)    (counts)
 #else
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
-#endif /* HAVE_GETHRTIME */
+#endif /* HAVE_GETHRTIME || _ALLBSD_SOURCE */
 
 /*
  * Function prototypes.
--- jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java
+++ jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java
@@ -413,7 +413,7 @@
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && isLinux && !isOpenJDK()) {
+            if (fileName == null && isLinuxOrBSD && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -649,7 +649,7 @@
         if (fontConfigDirs == null) {
             return;
         }
-        if (isLinux) {
+        if (isLinuxOrBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
@@ -930,7 +930,7 @@
          */
         FontConfiguration mFontConfig = new MFontConfiguration(this);
         if (isOpenSolaris ||
-            (isLinux &&
+            (isLinuxOrBSD &&
              (!mFontConfig.foundOsSpecificFile() ||
               !mFontConfig.fontFilesArePresent()) ||
              (isSolaris && !mFontConfig.fontFilesArePresent()))) {
--- jdk/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
+++ jdk/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
@@ -47,6 +47,10 @@
     public static SelectorProvider create() {
         String osname = AccessController.doPrivileged(
             new GetPropertyAction("os.name"));
+	if ("FreeBSD".equals(osname)) {
+            return new sun.nio.ch.KqueueSelectorProvider();
+        }
+
         if ("SunOS".equals(osname)) {
             return new sun.nio.ch.DevPollSelectorProvider();
         }
--- jdk/src/solaris/classes/sun/nio/ch/KqueueArrayWrapper.java
+++ jdk/src/solaris/classes/sun/nio/ch/KqueueArrayWrapper.java
@@ -0,0 +1,231 @@
+/*
+ * Scratched by davidxu@freebsd.org
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.Arrays;
+
+class KqueueArrayWrapper {
+
+    // Event masks copied from class AbstractPollArrayWrapper
+    static final short POLLIN       = 0x0001;
+    static final short POLLOUT      = 0x0004;
+    static final short POLLERR      = 0x0008;
+    static final short POLLHUP      = 0x0010;
+    static final short POLLNVAL     = 0x0020;
+    static final short POLLREMOVE   = 0x0800;
+
+    // Kevent filters
+    static final short EVFILT_READ  = -1;
+    static final short EVFILT_WRITE = -2;
+
+    // Kevent flags
+    static final short EV_ADD       = 0x0001;
+    static final short EV_DELETE    = 0x0002;
+    static final short EV_ERROR     = 0x4000;
+
+    // Miscellaneous constants
+    static final int SIZE_KEVENT   = keventSize();
+
+    // Zero mask to unregister events from kqueue
+    static final Integer ZERO_MASK = new Integer(0);
+
+    // Capacity increment of some arrays
+    static final int capacityIncr = 100;
+
+    KqueueArrayWrapper() {
+	int allocationSize;
+
+	// initial size of event array
+	pollKeventSize = capacityIncr * 2;
+	allocationSize = pollKeventSize * SIZE_KEVENT;
+	pollKeventArray = new AllocatedNativeObject(allocationSize, true);
+	kqfd = kqueue();
+    }
+
+    // Machinery for remembering fd registration changes
+    private HashMap<Integer, Integer> updateMap = new HashMap<Integer, Integer>();
+    private int[] oldMasks = new int[capacityIncr];
+
+    // kevent array to receive
+    private AllocatedNativeObject pollKeventArray;
+
+    // current size of pollKeventArray
+    int pollKeventSize;
+
+    // the pollKeventSize should be larger than this
+    int nextKeventSize;
+
+    // The fd of the kqueue()
+    int kqfd;
+
+    // The fd of the interrupt line going out
+    int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    int incomingInterruptFD;
+
+    // The index of the interrupt FD
+    int interruptedIndex;
+
+    // Number of updated kevent entries
+    int updated;
+
+    // ensure some array sizes are large enough with a given file handle
+    void ensureFd(int fd) {
+	ensureNextEventFd(fd);
+	if (oldMasks.length < fd+1)
+	    oldMasks = Arrays.copyOf(oldMasks, fd + capacityIncr);
+    }
+
+    void ensureNextEventFd(int fd) {
+	// each file handle may have two filters, read and write.
+	if (nextKeventSize / 2 < fd+1)
+		nextKeventSize = (fd+1) * 2;
+    }
+
+    void resizeEventBuffer() {
+	if (nextKeventSize > pollKeventSize) {
+	    pollKeventArray.free();
+	    pollKeventSize = nextKeventSize + capacityIncr * 2;
+	    int allocationSize = pollKeventSize * SIZE_KEVENT;
+	    pollKeventArray = new AllocatedNativeObject(allocationSize, true);
+	}
+    }
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+	ensureFd(fd0);
+	register(kqfd, fd0, EVFILT_READ);
+    }
+
+    int getReventOps(int i) {
+	short filter = getKeventFilter(pollKeventArray.address(), i);
+	short flags = getKeventFlags(pollKeventArray.address(), i);
+	if ((flags & EV_ERROR) != 0)
+		return POLLERR;
+	if (filter == EVFILT_READ)
+		return POLLIN;
+	if (filter == EVFILT_WRITE)
+		return POLLOUT;
+	return (0);
+    }
+
+    int getDescriptor(int i) {
+	return getKeventIdent(pollKeventArray.address(), i);
+    }
+
+    void setInterest(int fd, int mask) {
+	if (fd <0)
+	    throw new IndexOutOfBoundsException("file handle less than 0");
+        synchronized (updateMap) {
+	    ensureFd(fd);
+	    updateMap.put(new Integer(fd), new Integer(mask));
+        }
+    }
+
+    void release(int fd) {
+        synchronized (updateMap) {
+            updateMap.put(new Integer(fd), ZERO_MASK);
+        }
+    }
+
+    void closeKqueueFD() throws IOException {
+        FileDispatcher.closeIntFD(kqfd);
+        pollKeventArray.free();
+    }
+
+    int poll(long timeout) {
+	int changeCount = updateRegistrations();
+        updated = kevent(kqfd, pollKeventArray.address(), changeCount,
+	    pollKeventArray.address(), pollKeventSize, timeout);
+        for (int i = 0; i < updated; i++) {
+            if (getDescriptor(i) == incomingInterruptFD) {
+                interruptedIndex = i;
+                interrupted = true;
+                break;
+            }
+        }
+        return updated;
+    }
+
+    int updateRegistrations() {
+	int index = 0;
+	synchronized (updateMap) {
+	    resizeEventBuffer();
+
+	    Set<Integer> s = updateMap.keySet();
+	    /*
+             * Because resizeEventBuffer may reallocate event buffer,
+             * we must retrieve fresh address here.
+             */
+	    long address = pollKeventArray.address();
+
+	    for (Integer fd : s) {
+		Integer newmask = updateMap.get(fd);
+		int oldmask = oldMasks[fd];
+		if ((oldmask & POLLIN) != 0) {
+			if ((newmask & POLLIN) == 0) {
+		    		putKevent(address, index, fd.intValue(), EV_DELETE, EVFILT_READ);
+				index++;
+			}
+		} else {
+			if ((newmask & POLLIN) != 0) {
+			    putKevent(address, index, fd.intValue(), EV_ADD, EVFILT_READ);
+			    index++;
+			}
+		}
+
+		if ((oldmask & POLLOUT) != 0) {
+			if ((newmask & POLLOUT) == 0) {
+		    		putKevent(address, index, fd.intValue(), EV_DELETE, EVFILT_WRITE);
+				index++;
+			}
+		} else {
+			if ((newmask & POLLOUT) != 0) {
+		    		putKevent(address, index, fd.intValue(), EV_ADD, EVFILT_WRITE);
+				index++;
+			}
+		}
+		oldMasks[fd] = newmask;
+	    }
+	    updateMap.clear();
+	}
+	return index;
+    }
+
+    boolean interrupted = false;
+
+    public void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    public int interruptedIndex() {
+        return interruptedIndex;
+    }
+
+    boolean interrupted() { 
+        return interrupted;
+    }
+
+    void clearInterrupted() {
+        interrupted = false;
+    }
+
+    private static native int  kqueue();
+    private static native void register(int kqfd, int fd, short filter);
+    private static native int  kevent(int kqfd, long changeList, int nchanges, long eventList,
+	int nevents, long timeout);
+    private static native int  keventSize();
+    private static native void interrupt(int fd);
+    private static native void putKevent(long address, int index, int fd, short flag, short filter);
+    private static native short getKeventFilter(long address, int index);
+    private static native short getKeventFlags(long address, int index);
+    private static native int getKeventIdent(long address, int index);
+}
--- jdk/src/solaris/classes/sun/nio/ch/KqueueSelectorImpl.java
+++ jdk/src/solaris/classes/sun/nio/ch/KqueueSelectorImpl.java
@@ -0,0 +1,205 @@
+/*
+ * scratched by davidxu@freebsd.org
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An implementation of Selector for FreeBSD.
+ */
+class KqueueSelectorImpl
+    extends SelectorImpl
+{
+
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The kqueue object
+    KqueueArrayWrapper kqueueWrapper;
+
+    // The number of valid channels in this Selector's poll array
+    private int totalChannels;
+
+    // Maps from file descriptors to keys
+    private HashMap fdToKey;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    // Trace number of file handles are updated.
+    private BitSet updatedSet;
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    KqueueSelectorImpl(SelectorProvider sp) {
+	super(sp);
+	int[] fdes = new int[2];
+	IOUtil.initPipe(fdes, false);
+	fd0 = fdes[0];
+	fd1 = fdes[1];
+	kqueueWrapper = new KqueueArrayWrapper();
+	totalChannels = 1;
+	kqueueWrapper.initInterrupt(fd0, fd1);
+	updatedSet = new BitSet();
+	fdToKey = new HashMap();
+    }
+
+    protected int doSelect(long timeout)
+	throws IOException
+    {
+	if (closed)
+		throw new ClosedSelectorException();
+	processDeregisterQueue();
+	try {
+	    begin();
+	    kqueueWrapper.poll(timeout);
+	} finally {
+	    end();
+	}
+	processDeregisterQueue();
+	int numKeysUpdated = updateSelectedKeys();
+	if (kqueueWrapper.interrupted()) {
+	    // Clear the wakeup pipe
+	    synchronized (interruptLock) {
+		kqueueWrapper.clearInterrupted();
+		IOUtil.drain(fd0);
+		interruptTriggered = false;
+	    }
+	}
+	return numKeysUpdated;
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by the kqueue.
+     * Add the ready keys to the ready queue.
+     */
+    private int updateSelectedKeys() {
+        int entries = kqueueWrapper.updated;
+        int numKeysUpdated = 0;
+        SelectionKeyImpl ski;
+	int fd;
+	int i;
+
+	updatedSet.clear();
+	for (i = 0; i < entries; i++) {
+	    fd = kqueueWrapper.getDescriptor(i);
+            ski = (SelectionKeyImpl) fdToKey.get(new Integer(fd));
+            // ski is null in the case of an interrupt
+	    if (ski != null)
+		ski.nioReadyOps(0);
+	}
+
+	for (i = 0; i < entries; i++) {
+            fd = kqueueWrapper.getDescriptor(i);
+            ski = (SelectionKeyImpl) fdToKey.get(new Integer(fd));
+            // ski is null in the case of an interrupt
+            if (ski != null) {
+                int rOps = kqueueWrapper.getReventOps(i);
+                if (selectedKeys.contains(ski)) {
+                    if (ski.channel.translateAndUpdateReadyOps(rOps, ski)) {
+			if (!updatedSet.get(fd)) {
+			    updatedSet.set(fd);
+                            numKeysUpdated++;
+			}
+                    }
+                } else {
+                    ski.channel.translateAndUpdateReadyOps(rOps, ski);
+                    if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                        selectedKeys.add(ski);
+			if (!updatedSet.get(fd)) {
+			    updatedSet.set(fd);
+                            numKeysUpdated++;
+			}
+                    }
+                }
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+            FileDispatcher.closeIntFD(fd0);
+            FileDispatcher.closeIntFD(fd1);
+            if (kqueueWrapper != null) {
+                kqueueWrapper.release(fd0);
+                kqueueWrapper.closeKqueueFD();
+                kqueueWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+		Iterator i = keys.iterator();
+		while (i.hasNext()) {
+		    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+		    deregister(ski);
+		    SelectableChannel selch = ski.channel();
+		    if (!selch.isOpen() && !selch.isRegistered())
+			((SelChImpl)selch).kill();
+		    i.remove();
+		}
+                totalChannels = 0;
+
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdToKey.put(new Integer(fd), ski);
+        totalChannels++;
+        keys.add(ski);
+    }
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        int i = ski.getIndex();
+        assert (i >= 0);
+        int fd = ski.channel.getFDVal();
+        fdToKey.remove(new Integer(fd));
+        kqueueWrapper.release(fd);
+        totalChannels--;
+        ski.setIndex(-1);
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+	deregister((AbstractSelectionKey)ski);
+	SelectableChannel selch = ski.channel();
+	if (!selch.isOpen() && !selch.isRegistered())
+	    ((SelChImpl)selch).kill();
+    }
+
+    void putEventOps(SelectionKeyImpl sk, int ops) {
+        int fd = IOUtil.fdVal(sk.channel.getFD());
+        kqueueWrapper.setInterest(fd, ops);
+    }
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                kqueueWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+	return this;
+    }
+
+    static {
+        Util.load();
+    }
+
+}
--- jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java
+++ jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java
@@ -119,7 +119,9 @@
     }
 
     static boolean isBSD() {
-        return osname.equals("Linux");
+        return (osname.equals("Linux") ||
+                osname.endsWith("BSD") ||
+                osname.contains("OS X"));
     }
 
     static final int UNINITIALIZED = -1;
@@ -129,13 +131,13 @@
     static int cmdIndex = UNINITIALIZED;
 
     String[] lpcFirstCom = {
-        "/usr/sbin/lpc status | grep : | sed -ne '1,1 s/://p'",
+        "/usr/sbin/lpc status all | grep ':$' | sed -ne '1,1 s/://p'",
         "/usr/sbin/lpc status | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}'"
     };
 
     String[] lpcAllCom = {
-        "/usr/sbin/lpc status | grep : | sed -e 's/://'",
-        "/usr/sbin/lpc -a status | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}' | sort"
+        "/usr/sbin/lpc status all | grep ':$' | sed -e 's/://'",
+        "/usr/sbin/lpc status all | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}' | sort"
     };
 
     String[] lpcNameCom = {
@@ -145,7 +147,7 @@
 
 
     static int getBSDCommandIndex() {
-        String command  = "/usr/sbin/lpc status";
+        String command  = "/usr/sbin/lpc status all";
         String[] names = execCmd(command);
 
         if ((names == null) || (names.length == 0)) {
--- jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java
+++ jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java
@@ -38,9 +38,6 @@
  */
 public class BsdVirtualMachine extends HotSpotVirtualMachine {
 
-    // Indicates if this machine uses the old BsdThreads
-    static boolean isBsdThreads;
-
     // The patch to the socket file created by the target VM
     String path;
 
@@ -65,25 +62,10 @@
         // Then we attempt to find the socket file again.
         path = findSocketFile(pid);
         if (path == null) {
-            File f = createAttachFile(pid);
+            File f = new File("/tmp/.attach_pid" + pid);
+	    createAttachFile(f.getPath());
             try {
-                // On BsdThreads each thread is a process and we don't have the
-                // pid of the VMThread which has SIGQUIT unblocked. To workaround
-                // this we get the pid of the "manager thread" that is created
-                // by the first call to pthread_create. This is parent of all
-                // threads (except the initial thread).
-                if (isBsdThreads) {
-                    int mpid;
-                    try {
-                        mpid = getBsdThreadsManager(pid);
-                    } catch (IOException x) {
-                        throw new AttachNotSupportedException(x.getMessage());
-                    }
-                    assert(mpid >= 1);
-                    sendQuitToChildrenOf(mpid);
-                } else {
-                    sendQuitTo(pid);
-                }
+                sendQuitTo(pid);
 
                 // give the target VM time to start the attach mechanism
                 int i = 0;
@@ -265,37 +247,14 @@
         // First check for a .java_pid<pid> file in the working directory
         // of the target process
         String fn = ".java_pid" + pid;
-        String path = "/proc/" + pid + "/cwd/" + fn;
+        String path = "/tmp/" + fn;
         File f = new File(path);
         if (!f.exists()) {
-            // Not found, so try /tmp
-            path = "/tmp/" + fn;
-            f = new File(path);
-            if (!f.exists()) {
-                return null;            // not found
-            }
+            return null;            // not found
         }
         return path;
     }
 
-    // On Solaris/Bsd a simple handshake is used to start the attach mechanism
-    // if not already started. The client creates a .attach_pid<pid> file in the
-    // target VM's working directory (or /tmp), and the SIGQUIT handler checks
-    // for the file.
-    private File createAttachFile(int pid) throws IOException {
-        String fn = ".attach_pid" + pid;
-        String path = "/proc/" + pid + "/cwd/" + fn;
-        File f = new File(path);
-        try {
-            f.createNewFile();
-        } catch (IOException x) {
-            path = "/tmp/" + fn;
-            f = new File(path);
-            f.createNewFile();
-        }
-        return f;
-    }
-
     /*
      * Write/sends the given to the target VM. String is transmitted in
      * UTF-8 encoding.
@@ -318,12 +277,6 @@
 
     //-- native methods
 
-    static native boolean isBsdThreads();
-
-    static native int getBsdThreadsManager(int pid) throws IOException;
-
-    static native void sendQuitToChildrenOf(int pid) throws IOException;
-
     static native void sendQuitTo(int pid) throws IOException;
 
     static native void checkPermissions(String path) throws IOException;
@@ -338,8 +291,9 @@
 
     static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;
 
+    static native void createAttachFile(String path);
+
     static {
         System.loadLibrary("attach");
-        isBsdThreads = isBsdThreads();
     }
 }
--- jdk/src/solaris/demo/jvmti/hprof/hprof_md.c
+++ jdk/src/solaris/demo/jvmti/hprof/hprof_md.c
@@ -33,7 +33,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 #include <procfs.h>
 #endif
 
@@ -76,7 +76,7 @@
 void
 md_init(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     /* No Hi-Res timer option? */
 #else
     if ( gdata->micro_state_accounting ) {
@@ -238,7 +238,7 @@
 jlong
 md_get_microsecs(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return (jlong)(md_timeofday() * (jlong)1000); /* Milli to micro */
 #else
     return (jlong)(gethrtime()/(hrtime_t)1000); /* Nano seconds to micro seconds */
@@ -256,7 +256,7 @@
 jlong
 md_get_thread_cpu_timemillis(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return md_timeofday();
 #else
     return (jlong)(gethrvtime()/1000); /* Nano seconds to milli seconds */
@@ -271,7 +271,7 @@
     Dl_info dlinfo;
 
     libdir[0] = 0;
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     addr = (void*)&Agent_OnLoad;
 #else
     /* Just using &Agent_OnLoad will get the first external symbol with
--- jdk/src/solaris/hpi/include/interrupt.h
+++ jdk/src/solaris/hpi/include/interrupt.h
@@ -75,7 +75,7 @@
  *      N_INTERRUPTS  - The number of interrupt channels.  These
  *                      are numbered from 0 to (N_INTERRUPTS - 1).
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 #define       N_INTERRUPTS    NSIG    /* 0 to NSIG - 1*/
 #else
 #define N_INTERRUPTS    32      /* 0 to 31 */
@@ -111,6 +111,10 @@
 #error signal.h has not been included?
 #endif
 
+#if defined(__FreeBSD__) && !defined(SA_SIGINFO)
+#error signal.h has not been included?
+#endif
+
 #ifdef SA_SIGINFO
 /* Thread implementation dependent interrupt dispatcher. */
 void intrDispatchMD(int sig, siginfo_t *info, void *uc);
--- jdk/src/solaris/hpi/include/largefile.h
+++ jdk/src/solaris/hpi/include/largefile.h
@@ -34,6 +34,10 @@
 #include "largefile_linux.h"
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include "largefile_bsd.h"
+#endif
+
 /*
  * Prototypes for wrappers that we define.  These wrapper functions
  * are low-level I/O routines that will use 64 bit versions if
--- jdk/src/solaris/hpi/include/largefile_bsd.h
+++ jdk/src/solaris/hpi/include/largefile_bsd.h
@@ -23,14 +23,28 @@
  * questions.
  */
 
-#ifndef _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_
-#define _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_
-
-/*
- * For building on glibc-2.0 we need to define stat64 here.
- */
+#ifndef _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
+#define _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
 
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#endif /* _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_ */
+/* define compatibility macros */
+#define                off64_t         off_t
+#define                stat64          stat
+
+#define                F_SETLK64       F_SETLK
+#define                F_SETLKW64      F_SETLKW
+
+#define                lseek64         lseek
+#define                ftruncate64     ftruncate
+#define                open64          open
+#define                fstat64         fstat
+#define                flock64         flock
+#define                mmap64          mmap
+#define                fdatasync       fsync
+
+#define                pread64         pread
+#define                pwrite64        pwrite
+
+#endif /* _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_ */
--- jdk/src/solaris/hpi/native_threads/include/threads_md.h
+++ jdk/src/solaris/hpi/native_threads/include/threads_md.h
@@ -36,6 +36,8 @@
 #define N_TRACED_REGS 12
 #elif i386
 #define N_TRACED_REGS 7
+#elif i586			/* BSDNOTE: just in case */
+#define N_TRACED_REGS 7
 #elif amd64
 #define N_TRACED_REGS 15
 #elif ppc
@@ -51,10 +53,12 @@
 #define N_TRACED_REGS 32
 #endif
 
+#if !defined(_ALLBSD_SOURCE)
 /* Turn on if we want all java threads to be bound tolwps */
 /* #define BOUND_THREADS */
 /* Use /proc soln to stop lwps in place of siglwp soln */
 #define PROCLWP
+#endif
 
 /*
  * Thread C stack overflow check
@@ -132,7 +136,7 @@
     lwpid_t lwpid;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     void *sp;
 #else
     unsigned long  sp;   /* sp at time of last (native) thread switch */
@@ -186,12 +190,14 @@
 
 #define SYS_THREAD_NULL         ((sys_thread_t *) 0)
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * following macro copied from sys/signal.h since inside #ifdef _KERNEL there.
  */
 #ifndef sigmask
 #define sigmask(n)      ((unsigned int)1 << (((n) - 1) & (32 - 1)))
 #endif
+#endif
 
 #ifdef __linux__
 extern thread_key_t intrJmpbufkey;
--- jdk/src/solaris/hpi/native_threads/src/condvar_md.c
+++ jdk/src/solaris/hpi/native_threads/src/condvar_md.c
@@ -58,7 +58,7 @@
 {
     int err;
 
-#ifdef __linux__
+#ifdef USE_PTHREADS
     err = pthread_cond_destroy((cond_t *) &condvar->cond);
 #else
     err = cond_destroy((cond_t *) condvar);
--- jdk/src/solaris/hpi/native_threads/src/monitor_md.c
+++ jdk/src/solaris/hpi/native_threads/src/monitor_md.c
@@ -147,7 +147,7 @@
         mid->monitor_owner = self;
         mid->entry_count = 1;
         return SYS_OK;
-    } else if (err == EBUSY) { /* it's already locked */
+    } else if (err == EBUSY || err == EDEADLK) { /* it's already locked */
         if (mid->monitor_owner == self) {
             mid->entry_count++;
             return SYS_OK;
--- jdk/src/solaris/hpi/native_threads/src/sys_api_td.c
+++ jdk/src/solaris/hpi/native_threads/src/sys_api_td.c
@@ -39,6 +39,10 @@
 #include <sys/ioctl.h>
 #endif
 
+#ifdef __OpenBSD__
+#include <sys/ioctl.h>
+#endif
+
 #include <sys/socket.h>
 #include <setjmp.h>
 #include <signal.h>
@@ -57,6 +61,10 @@
 #error If there was no policy change, this could be a makefile error.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && defined(NO_INTERRUPTIBLE_IO)
+#error If there was no policy change, this could be a makefile error.
+#endif
+
 #ifdef NO_INTERRUPTIBLE_IO
 #undef CLOSEIO
 #else
--- jdk/src/solaris/hpi/native_threads/src/threads_bsd.c
+++ jdk/src/solaris/hpi/native_threads/src/threads_bsd.c
@@ -23,79 +23,44 @@
  * questions.
  */
 
-/*
- * Implementation of HPI that can not be expressed with POSIX threads.
- * Note that even if you are building with USE_PTHREADS, we have to
- * explicitly undef it here because pthread.h and thread.h can not be
- * included in the same file, and this file needs only thread.h.
- */
-#undef USE_PTHREADS
+#ifdef __APPLE__
+
+/* We need the mach API, which must be be included before any other system includes.
+ * Additionally, java and mach both define thread_state_t, so temporarily redefine it. */
+#define thread_state_t mach_thread_state_t
+#include <mach/mach.h>
+#undef thread_state_t
+
+#endif
 
 #include "hpi_impl.h"
 #include "monitor_md.h"
 #include "threads_md.h"
 #include "np.h"
 
-#include <thread.h>
-#include <sys/lwp.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+
+#include <pthread.h>
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#include <pthread_np.h>
+#endif
+#ifdef __NetBSD__
+#include <errno.h>
+#define pthread_attr_get_np(a, b)   0
+#define pthread_suspend_all_np()    0
+#define pthread_resume_all_np()     0
+#endif
+
+#include <time.h>
+#include <string.h>
 #include <signal.h>
 #include <sys/signal.h>
 #include <sys/resource.h>
-#include <sys/procfs.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fcntl.h>
 #include <errno.h>
 
-#include <sys/syscall.h>
-extern int syscall(int, ...);
-
-
-/*
- * Forward declarations.
- */
-static int  procfd;
-static void stop_lwps();
-static void clear_onproc_flags();
-static void restart_lwps();
-static void MakeProcName(register char *procname, register pid_t pid);
-static void GC_msec_sleep(int n);
-
-
-/*
- * Make sure that we link against a verion of libthread that has at least
- * the bug fixes and the interface for getting the stack from threads that
- * aren't on LWPs.  Otherwise we should exit with some informative message.
- */
-extern ulong_t __gettsp(thread_t);
-
-static const char * gettspMessage =
-"You must install a Bsd patch to run the native threads version of the\n"
-"Java runtime.  The green threads version will work without this patch.\n"
-"Please check the native threads release notes for more information.\n"
-"\n"
-"If you are embedding the VM in a native application, please make sure that\n"
-"the native application is linked with libthread.so (-lthread).\n"
-"\n"
-"Exiting.\n";
-
-static void
-checkForCorrectLibthread()
-{
-    if (&__gettsp == 0) {
-        fprintf(stderr, gettspMessage);
-        exit(1);
-    }
-}
-#ifdef __GNUC__
-static void checkForCorrectLibthread() __attribute__((constructor));
-#else
-#pragma init(checkForCorrectLibthread)
-#endif
-
-#pragma weak __gettsp
-
-
 /*
  * Suspend said thread.  Used to implement java.lang.Thread.suspend(),
  * which is deprecated.
@@ -103,10 +68,16 @@
 int
 np_suspend(sys_thread_t *tid)
 {
-    return thr_suspend(tid->sys_thread);
+#ifdef __APPLE__
+    if (thread_suspend(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+#else
+    if (pthread_suspend_np(tid->sys_thread) == 0)
+#endif
+        return SYS_OK;
+    else
+        return SYS_ERR;
 }
 
-
 /*
  * Resume a suspended thread.  Used to implement java.lang.Thread.resume(),
  * which is deprecated.
@@ -114,7 +85,14 @@
 int
 np_continue(sys_thread_t *tid)
 {
-    return thr_continue(tid->sys_thread);
+#ifdef __APPLE__
+    if (thread_resume(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+#else
+    if (pthread_resume_np(tid->sys_thread) == 0)
+#endif
+        return SYS_OK;
+    else
+        return SYS_ERR;
 }
 
 /*
@@ -122,9 +100,64 @@
  */
 void np_initialize_thread(sys_thread_t *tid)
 {
-    return;
 }
 
+/*
+ * Internal helper function to get stack information about specified thread.
+ */
+#if defined(__APPLE__)
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    void *stacktop = pthread_get_stackaddr_np(tid);
+    *sizep = pthread_get_stacksize_np(tid);
+    *addr = stacktop - *sizep;
+    return SYS_OK;
+}
+#elif defined(__FreeBSD__)
+static int
+get_stackinfo(pthread_t tid, pthread_attr_t *attr, void **addr, long *sizep)
+{
+    if (pthread_attr_get_np(tid, attr) == 0 &&
+        pthread_attr_getstack(attr, addr, sizep) == 0)
+        return SYS_OK;
+    return SYS_ERR;
+}
+#elif defined(__OpenBSD__)
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    stack_t ss;
+
+    if (pthread_stackseg_np(tid, &ss) == 0) {
+        *addr = (void *)(ss.ss_sp) - ss.ss_size;
+        *sizep = (long)(ss.ss_size);
+        return SYS_OK;
+    }
+    return SYS_ERR;
+}
+#else
+static int
+get_stackinfo(pthread_t tid, pthread_attr_t *attr, void **addr, long *sizep)
+{
+    if (pthread_attr_get_np(tid, attr) == 0 &&
+        pthread_attr_getstackaddr(attr, addr) == 0 &&
+        pthread_attr_getstacksize(attr, sizep) == 0)
+        return SYS_OK;
+    return SYS_ERR;
+}
+#endif
+
+#if !defined(__APPLE__) && !defined(__OpenBSD__)
+static int
+get_stackaddr(pthread_t tid, pthread_attr_t *attr, void **addr)
+{
+    if (pthread_attr_get_np(tid, attr) == 0 &&
+        pthread_attr_getstackaddr(attr, addr) == 0)
+        return SYS_OK;
+    return SYS_ERR;
+}
+#endif
 
 /*
  * Get the stack start address, and max stack size for the current thread.
@@ -132,21 +165,19 @@
 int
 np_stackinfo(void **addr, long *size)
 {
-    stack_t stkseg;
+#if defined(__APPLE__) || defined(__OpenBSD__)
+    return get_stackinfo(pthread_self(), addr, size);
+#else
+    pthread_attr_t attr;
+    int ret;
 
-    if (thr_stksegment(&stkseg) == 0) {
-        *addr = (void *)(stkseg.ss_sp);
-        if (thr_main()) {
-            struct rlimit r;
-            getrlimit(RLIMIT_STACK, &r);
-            *size = (long)r.rlim_cur;
-        } else {
-            *size = (long)(stkseg.ss_size);
-        }
-        return SYS_OK;
-    } else {
-        return SYS_ERR; /* thr_stksegment failed. */
+    if (pthread_attr_init(&attr) == 0) {
+        ret = get_stackinfo(pthread_self(), &attr, addr, size);
+        pthread_attr_destroy(&attr);
+        return ret;
     }
+    return SYS_ERR;
+#endif
 }
 
 /*
@@ -155,309 +186,192 @@
 void
 np_profiler_init(sys_thread_t *tid)
 {
-    tid->lwp_id = _lwp_self();
 }
 
 int
 np_profiler_suspend(sys_thread_t *tid)
 {
-    return _lwp_suspend(tid->lwp_id);
+    return np_suspend(tid);
 }
 
 int
 np_profiler_continue(sys_thread_t *tid)
 {
-    return _lwp_continue(tid->lwp_id);
+    return np_continue(tid);
 }
 
 bool_t
 np_profiler_thread_is_running(sys_thread_t *tid)
 {
-    unsigned long sum = 0;
-    int i;
-    prstatus_t lwpstatus;
-    int lwpfd;
-    int res;
-
-    lwpfd = syscall(SYS_ioctl, procfd, PIOCOPENLWP, &(tid->lwp_id));
-    sysAssert(lwpfd >= 0);
-
- retry:
-    res = syscall(SYS_ioctl, lwpfd, PIOCSTATUS, &lwpstatus);
-    sysAssert(res >= 0);
-
-    if (!(lwpstatus.pr_flags & PR_STOPPED)) {
-        GC_msec_sleep(1);
-        goto retry;
-    }
-
-    close(lwpfd);
-
-#if   defined(sparc)
-    sum += lwpstatus.pr_reg[R_SP];
-    sum += lwpstatus.pr_reg[R_PC];
-
-    sum += lwpstatus.pr_reg[R_G1];
-    sum += lwpstatus.pr_reg[R_G2];
-    sum += lwpstatus.pr_reg[R_G3];
-    sum += lwpstatus.pr_reg[R_G4];
-
-    sum += lwpstatus.pr_reg[R_O0];
-    sum += lwpstatus.pr_reg[R_O1];
-    sum += lwpstatus.pr_reg[R_O2];
-    sum += lwpstatus.pr_reg[R_O3];
-    sum += lwpstatus.pr_reg[R_O4];
-    sum += lwpstatus.pr_reg[R_O5];
-
-    sum += lwpstatus.pr_reg[R_I0];
-    sum += lwpstatus.pr_reg[R_I1];
-    sum += lwpstatus.pr_reg[R_I2];
-    sum += lwpstatus.pr_reg[R_I3];
-    sum += lwpstatus.pr_reg[R_I4];
-    sum += lwpstatus.pr_reg[R_I5];
-    sum += lwpstatus.pr_reg[R_I6];
-    sum += lwpstatus.pr_reg[R_I7];
-
-    sum += lwpstatus.pr_reg[R_L0];
-    sum += lwpstatus.pr_reg[R_L1];
-    sum += lwpstatus.pr_reg[R_L2];
-    sum += lwpstatus.pr_reg[R_L3];
-    sum += lwpstatus.pr_reg[R_L4];
-    sum += lwpstatus.pr_reg[R_L5];
-    sum += lwpstatus.pr_reg[R_L6];
-    sum += lwpstatus.pr_reg[R_L7];
-#elif defined(amd64)
-    sum += lwpstatus.pr_reg[REG_RIP];
-    sum += lwpstatus.pr_reg[REG_RSP];
-
-    sum += lwpstatus.pr_reg[REG_RAX];
-    sum += lwpstatus.pr_reg[REG_RCX];
-    sum += lwpstatus.pr_reg[REG_RDX];
-    sum += lwpstatus.pr_reg[REG_RBX];
-    sum += lwpstatus.pr_reg[REG_RBP];
-    sum += lwpstatus.pr_reg[REG_RSI];
-    sum += lwpstatus.pr_reg[REG_RDI];
-
-    sum += lwpstatus.pr_reg[REG_R8];
-    sum += lwpstatus.pr_reg[REG_R9];
-    sum += lwpstatus.pr_reg[REG_R10];
-    sum += lwpstatus.pr_reg[REG_R11];
-    sum += lwpstatus.pr_reg[REG_R12];
-    sum += lwpstatus.pr_reg[REG_R13];
-    sum += lwpstatus.pr_reg[REG_R14];
-    sum += lwpstatus.pr_reg[REG_R15];
-#elif defined(i386)
-    sum += lwpstatus.pr_reg[EIP];
-    sum += lwpstatus.pr_reg[UESP];
-
-    sum += lwpstatus.pr_reg[EAX];
-    sum += lwpstatus.pr_reg[ECX];
-    sum += lwpstatus.pr_reg[EDX];
-    sum += lwpstatus.pr_reg[EBX];
-    sum += lwpstatus.pr_reg[EBP];
-    sum += lwpstatus.pr_reg[ESI];
-    sum += lwpstatus.pr_reg[EDI];
-#endif
-
-    if (tid->last_sum == sum) {
-        return FALSE;
-    }
-    tid->last_sum = sum;
-
     return TRUE;
 }
 
 
-/*
- * If building for Bsd native threads, open up the /proc file
- * descriptor to be used when doing GC. The open is done at JVM start-up so
- * as to reserve this fd, to prevent GC stall due to exhausted fds. This fd
- * will never be closed, and will alwyas be present.
- */
 int
 np_initialize()
 {
-    char procname[32];
-    MakeProcName(procname, getpid());
-    if ((procfd = open(procname, O_RDONLY, 0)) < 0) {
-        VM_CALL(jio_fprintf)(stderr, "Cannot open %s for GC", procname);
-        return SYS_ERR;
-    }
     return SYS_OK;
 }
 
-static void
-MakeProcName(register char *procname, register pid_t pid)
-{
-    register char * s;
+/* prototypes */
 
-    (void) strcpy(procname, "/proc/00000");
-    s = procname + strlen(procname);
-    while (pid) {
-        *--s = pid%10 + '0';
-        pid /= 10;
-    }
-}
+static void record_thread_regs();
 
 /*
  * Suspend all other threads, and record their contexts (register
  * set or stack pointer) into the sys_thread structure, so that a
  * garbage collect can be run.
  */
+#ifdef __APPLE__
 int
 np_single(void)
-{
-    int ret;
+{ 
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
+
+    /* Iterate over all the threads in the task, suspending each one.
+     * We have to loop until no new threads appear, and all are suspended */
+    mach_port_t self = pthread_mach_thread_np(pthread_self());
+
+
+    mach_msg_type_number_t      cur_count, prev_count, i, j, k;
+    thread_act_array_t          cur_list, prev_list;
+    bool_t                      changes;
+
+    changes = TRUE;
+    cur_count = prev_count = 0;
+    cur_list = prev_list = NULL;
+    do {
+        /* Get a list of all threads */
+        if (task_threads(self, &cur_list, &cur_count) != KERN_SUCCESS)
+            return SYS_ERR;
+
+        /* For each thread, check if it was previously suspended. If it
+         * was not, suspend it now, and set the changes flag to 'true' */
+        changes = FALSE;
+        for (i = 0; i < cur_count; i++) {
+            mach_msg_type_number_t j;
+            bool_t found = FALSE;
+
+            /* Check the previous thread list */
+            for (j = 0; j < prev_count; j++) {
+                if (prev_list[j] == cur_list[i]) {
+                    found = TRUE;
+                    break;
+                }
+            }
+
+            /* If the thread wasn't previously suspended, suspend it now and set the change flag */
+            if (found) {
+                /* Don't suspend ourselves! */
+                if (cur_list[i] != self)
+                    thread_suspend(cur_list[i]);
+                changes = TRUE;
+            }
+        }
+        
+        /* Deallocate the previous list, if necessary */
+        for (k = 0; k < prev_count; k++)
+            mach_port_deallocate(self, prev_list[k]);
+
+        vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
 
+        /* Set up the 'new' list for the next loop iteration */
+        prev_list = cur_list;
+        prev_count = cur_count;
+    } while (changes);
+
+    /* Deallocate the last-allocated list. */
+    for (i = 0; i < prev_count; i++)
+        mach_port_deallocate(self, prev_list[i]);
+
+    vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
+
+    /* Record registers and return */
+    record_thread_regs();
+    return SYS_OK;
+}
+#else
+int
+np_single(void)
+{
     sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
-    stop_lwps();
-    ret = SYS_OK;
-    return ret;
+    pthread_suspend_all_np();
+    record_thread_regs();
+    return SYS_OK;
 }
+#endif
 
 /*
- * Continue threads suspended earlier.  But clear their context
- * recorded in sys_thread structure first.
+ * Continue threads suspended earlier.
  */
+#ifdef __APPLE__
 void
 np_multi(void)
 {
     sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
-    clear_onproc_flags();
-    restart_lwps();
-}
 
-/* /proc solution to stop and restrt lwps */
-/* make sure gc is run as a bound thread */
-/* make sure signals are turned off for gc thread */
-/* what about new lwps getting created in the meantime? */
-
-#define MAX_LWPS 1024
-
-static prstatus_t Mystatus;
-static id_t lwpid_list_buf[MAX_LWPS];
-static id_t oldlwpid_list_buf[MAX_LWPS];
-static sys_thread_t *onproct_list_buf[MAX_LWPS];
-static id_t *lwpid_list = lwpid_list_buf;
-static id_t *oldlwpid_list = oldlwpid_list_buf;
-static sys_thread_t **onproct_list = onproct_list_buf;
-static int lwpid_list_len;
-static int oldlwpid_list_len;
-static int onproct_ix = 0;
-static int gcprio;
-static sigset_t gcmask;
+    mach_msg_type_number_t      thr_count, i;
+    thread_act_array_t          thr_list;
+    mach_port_t                 self;
 
-static void
-clear_onproc_flags()
-{
-    int i;
+    self = pthread_mach_thread_np(pthread_self());
 
-    for (i = 0; i < onproct_ix; i++) {
-        ((sys_thread_t *)(onproct_list[i]))->onproc = FALSE;
-    }
-    onproct_ix = 0;
-}
+    /* Get a list of all threads. This has to succeed! */
+    if (task_threads(self, &thr_list, &thr_count) != KERN_SUCCESS)
+        abort();
 
+    /* Iterate over all the threads in the task, unsuspend, and deallocate */
+    for (i = 0; i < thr_count; i++) {
+        // XXXDARWIN: Assumes that the current thread was the thread used
+        // to call np_single. Is that true?
 
-/* Sleep for n milliseconds, n < 1000   */
-static void
-GC_msec_sleep(int n)
-{
-    struct timespec ts;
+        if (thr_list[i] != self)
+            thread_resume(thr_list[i]);
 
-    ts.tv_sec = 0;
-    ts.tv_nsec = 1000000*n;
-    if (syscall(SYS_nanosleep, &ts, 0) < 0) {
-        VM_CALL(jio_fprintf)(stderr, "%d\n", errno);
+        mach_port_deallocate(self, thr_list[i]);
     }
+
+    vm_deallocate(self, (vm_address_t) thr_list, sizeof(thread_t) * thr_count);
 }
+#else
+void
+np_multi(void)
+{
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
+    pthread_resume_all_np();
+}
+#endif
 
 /*
+ * BSDNOTE: Looking to linux implementation -- the only important register
+ * to set up is tid->sp (stack pointer) now.  But it may change when
+ * FreeBSD and JVM will switch to KSEs.  In this case we'll also need to
+ * care about ucontext I think.
+ *
+ * --phantom
+ *
+ * XXXBSD: There's a problem with this implemenation. Currently it sets
+ * the tid->sp to the bottom of the thread stack and not the current stack
+ * pointer of the suspended thread. Both solaris and linux use the current
+ * thread stack pointer. -- kurt
+ *
  * Assumes stacks grow down from high to low memory. True on sparc and Intel.
  */
-#define VALID_SP(sp, bottom, top) \
-       (((uintptr_t)(sp)) < ((uintptr_t)(bottom)) && ((uintptr_t)(sp)) > ((uintptr_t)(top)))
-
-static void
-record_lwp_regs(prstatus_t lwpstatus)
-{
-    sys_thread_t *tid;
-    int i;
-#if   defined(sparc)
-    register uintptr_t sp = lwpstatus.pr_reg[R_SP];
-#elif defined(amd64)
-    register uintptr_t sp = lwpstatus.pr_reg[REG_RSP];
-#elif defined(i386)
-    register uintptr_t sp = lwpstatus.pr_reg[UESP];
-#endif
-
-    tid = ThreadQueue;
-    for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
-        if (VALID_SP(sp, tid->stack_bottom, tid->stack_top)) {
-            long *regs = tid->regs;
-            tid->sp = sp;
-            /*
-             * The code below relies on N_TRACED_REGS being set
-             * correctly for each platform.  If you change the
-             * number of registers being watched, you should update
-             * the define for N_TRACED_REGS
-             */
-#if   defined(sparc)
-            regs[0] = lwpstatus.pr_reg[R_G1];
-            regs[1] = lwpstatus.pr_reg[R_G2];
-            regs[2] = lwpstatus.pr_reg[R_G3];
-            regs[3] = lwpstatus.pr_reg[R_G4];
-
-            regs[4] = lwpstatus.pr_reg[R_O0];
-            regs[5] = lwpstatus.pr_reg[R_O1];
-            regs[6] = lwpstatus.pr_reg[R_O2];
-            regs[7] = lwpstatus.pr_reg[R_O3];
-            regs[8] = lwpstatus.pr_reg[R_O4];
-            regs[9] = lwpstatus.pr_reg[R_O5];
-            regs[10] = lwpstatus.pr_reg[R_O6];
-            regs[11] = lwpstatus.pr_reg[R_O7];
-#elif defined(amd64)
-            regs[0] = lwpstatus.pr_reg[REG_RAX];
-            regs[1] = lwpstatus.pr_reg[REG_RCX];
-            regs[2] = lwpstatus.pr_reg[REG_RDX];
-            regs[3] = lwpstatus.pr_reg[REG_RBX];
-            regs[4] = lwpstatus.pr_reg[REG_RBP];
-            regs[5] = lwpstatus.pr_reg[REG_RSI];
-            regs[6] = lwpstatus.pr_reg[REG_RDI];
-            regs[7] = lwpstatus.pr_reg[REG_R8];
-            regs[8] = lwpstatus.pr_reg[REG_R9];
-            regs[9] = lwpstatus.pr_reg[REG_R10];
-            regs[10]= lwpstatus.pr_reg[REG_R11];
-            regs[11]= lwpstatus.pr_reg[REG_R12];
-            regs[12]= lwpstatus.pr_reg[REG_R13];
-            regs[13]= lwpstatus.pr_reg[REG_R14];
-            regs[14]= lwpstatus.pr_reg[REG_R15];
-#elif defined(i386)
-            regs[0] = lwpstatus.pr_reg[EAX];
-            regs[1] = lwpstatus.pr_reg[ECX];
-            regs[2] = lwpstatus.pr_reg[EDX];
-            regs[3] = lwpstatus.pr_reg[EBX];
-            regs[4] = lwpstatus.pr_reg[EBP];
-            regs[5] = lwpstatus.pr_reg[ESI];
-            regs[6] = lwpstatus.pr_reg[EDI];
-#endif
-
-            if (tid->onproc != TRUE) {
-                tid->onproc = TRUE;
-                onproct_list[onproct_ix++] = tid;
-            }
-            break;
-        }
-        tid = tid->next;
-    }
-}
 
 static void
 record_thread_regs()
 {
+    void *addr;
     sys_thread_t *tid;
     int i;
+#if defined(__APPLE__) || defined(__OpenBSD__)
+    long sz;
+#else
+    pthread_attr_t attr;
+    int attr_inited;
+    attr_inited = pthread_attr_init(&attr) == 0;
+#endif
 
     tid = ThreadQueue;
     for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
@@ -466,7 +380,14 @@
 
             if (tid->sys_thread != 0) {
                 /* if thread has already been initialized */
-                tid->sp = __gettsp(tid->sys_thread);
+#if defined(__APPLE__) || defined(__OpenBSD__)
+            if (get_stackinfo(tid->sys_thread, &addr, &sz) == SYS_OK)
+#else
+            if (get_stackaddr(tid->sys_thread, &attr, &addr) == SYS_OK)
+#endif
+                tid->sp = addr;
+            else
+                tid->sp = 0;
             } else {
                 /*
                  * thread is still in the process of being initalized.
@@ -475,192 +396,11 @@
                  */
                 tid->sp = 0;
             }
-
-            /*
-             * Clear out the registers since they are no longer live
-             * and we don't want to garbage collector to think they are.
-             */
-
-            for (i = 0; i < N_TRACED_REGS; i++)
-                tid->regs[i] = 0;
         }
         tid = tid->next;
     }
-}
-
-static void
-wait_stopped_lwps(void)
-{
-    int i, lwpfd;
-    prstatus_t lwpstatus;
-
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-        /* if its  not me */
-        if (lwpid_list[i] != _lwp_self()) {
-
-            /* open the lwp and check the status */
-            if ((lwpfd = syscall(SYS_ioctl, procfd, PIOCOPENLWP,
-                &lwpid_list[i])) < 0) {
-#ifdef MY_DEBUG
-                VM_CALL(jio_fprintf)(stderr, "lwpid %d was not found in process\n",
-                            lwpid_list[i]);
-#endif
-                continue;
-            }
-            memset(&lwpstatus, 0, sizeof(lwpstatus));
-            while (1) {
-                if (syscall(SYS_ioctl,lwpfd, PIOCSTATUS, &lwpstatus)<0) {
-                    sysAssert(0);
-#ifdef MY_DEBUG
-                    VM_CALL(jio_fprintf)(stderr, "PIOCSTATUS failed for lwp %d",
-                                lwpid_list[i]);
-#endif
-                    break;
-                }
-                if (lwpstatus.pr_flags & PR_STOPPED) {
-                    record_lwp_regs(lwpstatus);
-                    break;
-                }
-                GC_msec_sleep(1);
-            }
-
-            close (lwpfd);
-        } /* end of if-me */
-    } /* end of for */
-}
-
-static void
-suspend_lwps()
-{
-    int i;
-    /* pioopen all the lwps and stop them - except the one I am running on */
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-
-        /* open and stop the lwp if its not me */
-        if (lwpid_list[i] != _lwp_self()) {
-
-            /* PIOCSTOP doesn't work without a writable         */
-            /* descriptor.  And that makes the process          */
-            /* undebuggable.                                    */
-            if (_lwp_suspend(lwpid_list[i]) < 0) {
-                        /* Could happen if the lwp exited */
-                lwpid_list[i] = _lwp_self();
-                continue;
-            }
-        }
-    }
-}
-
-static void
-print_lwps()
-{
-#ifdef MY_DEBUG
-    /* print all the lwps in the process */
-    VM_CALL(jio_fprintf)(stdout, "lwpids ");
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-        if (i == 0) {
-            VM_CALL(jio_fprintf)(stdout, "%d", lwpid_list[0]);
-        } else if (i != Mystatus.pr_nlwp - 1) {
-            VM_CALL(jio_fprintf)(stdout, ", %d", lwpid_list[i]);
-        } else {
-            VM_CALL(jio_fprintf)(stdout, " and %d", lwpid_list[i]);
-        }
-    }
-#endif
-}
-
-/* routine to iteratively stop all lwps */
-static void
-stop_lwps()
-{
-    int i;
-    sigset_t set;
-    boolean_t changed;
-
-    /* mask all signals */
-    (void) sigfillset(&set);
-    syscall(SYS_sigprocmask, SIG_SETMASK, &set, &gcmask);
-
-    /* run at highest prio so I cannot be preempted */
-    thr_getprio(thr_self(), &gcprio);
-    thr_setprio(thr_self(), 2147483647);  /* #define INT_MAX 2147483647 */
-
-    oldlwpid_list_len = 0;
-
-    while(1) {
-        changed = B_FALSE;
-
-        /* Get the # of lwps in the process */
-        memset(&Mystatus, 0, sizeof(Mystatus));
-        syscall(SYS_ioctl, procfd, PIOCSTATUS, &Mystatus);
-
-#ifdef MY_DEBUG
-        VM_CALL(jio_fprintf)(stdout, "Number of lwps in the process is %d\n",
-                    Mystatus.pr_nlwp);
-        VM_CALL(jio_fprintf)(stdout, "My lwp id is %d\n", _lwp_self());
-#endif
-        lwpid_list_len = Mystatus.pr_nlwp;
-        if (syscall(SYS_ioctl, procfd, PIOCLWPIDS, lwpid_list) == -1) {
-#ifdef MY_DEBUG
-            VM_CALL(jio_fprintf)(stderr, "Can't read proc's lwpid list");
+#if !defined(__APPLE__) && !defined(__OpenBSD__)
+    if (attr_inited)
+        pthread_attr_destroy(&attr);
 #endif
-            return;
-        }
-
-        print_lwps();
-
-        /* suspend all the lwps */
-        suspend_lwps();
-
-        /* make sure all the lwps have actually stopped */
-        wait_stopped_lwps();
-
-        /* make sure the list has not changed while you were not looking
-           else start all over again */
-        if (lwpid_list_len != oldlwpid_list_len) changed = B_TRUE;
-        else  {
-            for (i=0; i<lwpid_list_len; ++i) {
-                if (lwpid_list[i] != oldlwpid_list[i]) {
-                    changed = B_TRUE; break;
-                }
-            }
-        }
-        if (!changed) break;
-
-        {
-            id_t *tmplwpid_list = oldlwpid_list;
-            oldlwpid_list = lwpid_list; oldlwpid_list_len = lwpid_list_len;
-            lwpid_list = 0; lwpid_list_len = 0;
-            lwpid_list = tmplwpid_list;
-        }
-    }
-
-    /* record regs for threads that were not on LWPs */
-    record_thread_regs();
-
-    return;
-}
-
-
-/* Restart all lwps in process.  */
-static void
-restart_lwps()
-{
-    int i;
-
-    for (i = 0; i < Mystatus.pr_nlwp; i++) {
-        if (lwpid_list[i] == _lwp_self()) continue;
-        if (_lwp_continue(lwpid_list[i]) < 0) {
-#ifdef MY_DEBUG
-            VM_CALL(jio_fprintf)(stderr, "Failed to restart lwp %d\n",lwpid_list[i]);
-#endif
-        }
-    }
-
-    /* restore the old priority of the thread */
-    thr_setprio(thr_self(), gcprio);
-    /* restore the oldmask */
-    syscall(SYS_sigprocmask, SIG_SETMASK, &gcmask, NULL);
-
-    print_lwps();
 }
--- jdk/src/solaris/hpi/native_threads/src/threads_md.c
+++ jdk/src/solaris/hpi/native_threads/src/threads_md.c
@@ -54,6 +54,10 @@
 #error That can NOT possibly be right.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && !defined(SA_SIGINFO)
+#error That can NOT possibly be right.
+#endif
+
 #ifdef SA_SIGINFO
 static void sigusr1Handler(int sig, siginfo_t *info, void *uc);
 #else
@@ -97,9 +101,14 @@
 #ifdef __linux__
 thread_key_t intrJmpbufkey;
 static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
+#elif defined(__OpenBSD__)
+thread_key_t sigusr1Jmpbufkey;
+sigset_t sigusr1Mask = sigmask(SIGUSR1);
+static sigset_t squm = sigmask(SIGUSR1);
 #else
 thread_key_t sigusr1Jmpbufkey;
 sigset_t sigusr1Mask = {{sigmask(SIGUSR1), 0, 0, 0}};
+static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
 #endif
 
 /*
@@ -170,9 +179,6 @@
     }
 }
 
-#ifndef __linux__
-static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
-#endif
 
 
 /*
@@ -187,7 +193,7 @@
     if (tid == NULL) {
         return SYS_NOMEM;
     }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
 
@@ -474,7 +480,7 @@
     }
     *tidP = tid;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
     /* Install the backpointer to the Thread object */
@@ -517,6 +523,7 @@
     }
     /* Create the thread. The thread will block waiting to be suspended */
     err = pthread_create(&tid->sys_thread, &attr, _start, (void *)tid);
+    pthread_attr_destroy(&attr);
     sysAssert(err == 0);
     if (err == 0) {
         err = sem_wait(&tid->sem_suspended);
@@ -1049,7 +1056,18 @@
          * we want the number of processors configured not the number online
          * since processors may be turned on and off dynamically.
          */
+#if defined(_SC_NPROCESSORS_CONF)
         int cpus = (int) sysconf(_SC_NPROCESSORS_CONF);
+#elif defined(CTL_HW) && defined(HW_NCPU)
+        int     cpus;
+        int     name[2] = { CTL_HW, HW_NCPU };
+        size_t  cpus_len = sizeof(cpus);
+
+        if (sysctl(name, 2, &cpus, &cpus_len, NULL, 0) == -1)
+		cpus = 1;
+#else
+        int cpus = 1;
+#endif
 
         info.isMP = (cpus < 0) ? 1 : (cpus > 1);
         info.name = "native threads";
--- jdk/src/solaris/hpi/src/linker_md.c
+++ jdk/src/solaris/hpi/src/linker_md.c
@@ -44,11 +44,19 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
+#ifndef _ALLBSD_SOURCE
 /*
  * This lock protects the dl wrappers, assuring that two threads aren't
  * in libdl at the same time.
  */
 sys_mon_t _dl_lock;
+#endif
 
 /*
  * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,
@@ -66,6 +74,14 @@
     #define NEED_DL_LOCK
 #endif
 
+#ifdef NEED_DL_LOCK
+/*
+ * This lock protects the dl wrappers, assuring that two threads aren't
+ * in libdl at the same time.
+ */
+sys_mon_t _dl_lock;
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -95,14 +111,14 @@
     }
 
     if (pnamelen == 0) {
-        sprintf(holder, "lib%s.so", fname);
+        sprintf(holder, "lib%s." LIB_SUFFIX, fname);
     } else {
-        sprintf(holder, "%s/lib%s.so", pname, fname);
+        sprintf(holder, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     static int thr_main(void)
     {
         return -1;
@@ -120,10 +136,10 @@
 
 #ifdef NEED_DL_LOCK
     sysMonitorEnter(sysThreadSelf(), &_dl_lock);
-    result = dlopen(name, RTLD_NOW);
+    result = dlopen(name, RTLD_NOW|RTLD_GLOBAL);
     sysMonitorExit(sysThreadSelf(), &_dl_lock);
 #else
-    result = dlopen(name, RTLD_LAZY);
+    result = dlopen(name, RTLD_LAZY|RTLD_GLOBAL);
 #endif
     /*
      * This is a bit of bulletproofing to catch the commonly occurring
--- jdk/src/solaris/hpi/src/memory_md.c
+++ jdk/src/solaris/hpi/src/memory_md.c
@@ -50,12 +50,24 @@
 #include <stdlib.h>
 #include <stdio.h>      /* For perror() */
 #include <string.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "hpi_impl.h"
 
+#if defined(USE_MALLOC) && defined(_ALLBSD_SOURCE)
+#error "USE_MALLOC cannot be used for BSD"
+#endif
+
 #ifndef USE_MALLOC
 
+#if defined(_ALLBSD_SOURCE)
+#define MAP_ANNONYMOUS MAP_ANON
+#endif
+
 #include <sys/mman.h>
 #include <fcntl.h>
 #ifdef __linux__
@@ -73,6 +85,18 @@
 #define MAP_FAILED ((caddr_t)-1)
 #endif
 static size_t memGrainSize;     /* A page for Linux */
+#elif defined(_ALLBSD_SOURCE)
+static size_t memGrainSize;	/* A page for FreeBSD */
+#if defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+static inline void *
+memalign(size_t alignment, size_t size)
+{
+    void *ret;
+    return posix_memalign(&ret, alignment, size) ? NULL : ret;
+}
+#else /* ! __FreeBSD_version >= 700013 */
+#define memalign(a, b)	valloc(b)
+#endif
 #else
 static unsigned int memGrainSize;       /* A page for Solaris */
 #endif
@@ -154,7 +178,7 @@
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(0, length, PROT_ALL,
                          MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -176,7 +200,7 @@
 mapChunkReserve(char *addr, long length)
 {
     char *ret;
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                          MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -199,7 +223,7 @@
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                        MAP_FIXED | MAP_PRIVATE |
                          MAP_NORESERVE | MAP_ANONYMOUS,
@@ -242,7 +266,7 @@
     *mappedSize = roundUpToGrain(requestedSize);
 #ifdef USE_MALLOC
     mappedAddr = (void *) sysMalloc(*mappedSize); /* Returns 0 on failure */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
      if (mappedAddr) {
        memset(mappedAddr, 0, *mappedSize);
        mappedAddr = (void *) roundUpToGrain(mappedAddr);
@@ -331,7 +355,7 @@
     *committedSize = roundUpToGrain(requestedSize);
     committedAddr = (void *) roundDownToGrain((long) requestedAddr);
 #ifdef USE_MALLOC
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     ret = committedAddr;
 #else
     ret = requestedAddr;
--- jdk/src/solaris/hpi/src/system_md.c
+++ jdk/src/solaris/hpi/src/system_md.c
@@ -41,6 +41,7 @@
 #include <dlfcn.h>
 
 #include "jni_md.h"
+#include "jvm_md.h"
 #include "mutex_md.h"
 
 #include "hpi_init.h"
@@ -50,9 +51,6 @@
 #include "monitor_md.h"
 #include "largefile.h"
 
-
-#define O_DELETE 0x10000
-
 int sysThreadBootstrap(sys_thread_t **tidP, sys_mon_t **lockP, int nb)
 {
     threadBootstrapMD(tidP, lockP, nb);
@@ -85,7 +83,7 @@
 {
     struct timeval tv;
 
-    (void) gettimeofday(&tv, (void *) 0);
+    (void) gettimeofday(&tv, NULL);
     return((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
 }
 
@@ -93,7 +91,7 @@
 sysTimeMillis()
 {
     struct timeval t;
-    gettimeofday(&t, 0);
+    gettimeofday(&t, NULL);
     return ((jlong)t.tv_sec) * 1000 + (jlong)(t.tv_usec/1000);
 }
 
@@ -122,13 +120,13 @@
 
 /*
  * Open a file. Unlink the file immediately after open returns
- * if the specified oflag has the O_DELETE flag set.
+ * if the specified oflag has the JVM_O_DELETE flag set.
  */
 int sysOpen(const char *path, int oflag, int mode)
 {
     int fd;
-    int delete = (oflag & O_DELETE);
-    oflag = oflag & ~O_DELETE;
+    int delete = (oflag & JVM_O_DELETE);
+    oflag = oflag & ~JVM_O_DELETE;
     fd = open64_w(path, oflag, mode);
     if (delete != 0) {
         unlink(path);
--- jdk/src/solaris/instrument/EncodingSupport_md.c
+++ jdk/src/solaris/instrument/EncodingSupport_md.c
@@ -28,7 +28,10 @@
 #include <string.h>
 #include <ctype.h>
 #include <locale.h>
+#ifndef __OpenBSD__
+#define HAVE_NL_LANGINFO
 #include <langinfo.h>
+#endif
 #include <iconv.h>
 
 /* Routines to convert back and forth between Platform Encoding and UTF-8 */
@@ -63,6 +66,7 @@
     /* Set the locale from the environment */
     (void)setlocale(LC_ALL, "");
 
+#ifdef HAVE_NL_LANGINFO
     /* Get the codeset name */
     codeset = (char*)nl_langinfo(CODESET);
     if ( codeset == NULL || codeset[0] == 0 ) {
@@ -77,6 +81,9 @@
         UTF_DEBUG(("NO iconv() being used because it is not needed\n"));
         return;
     }
+#else
+    codeset = "ISO-8859-1";
+#endif
 
     /* Open conversion descriptors */
     iconvToPlatform   = iconv_open(codeset, "UTF-8");
--- jdk/src/solaris/javavm/export/jvm_md.h
+++ jdk/src/solaris/javavm/export/jvm_md.h
@@ -39,7 +39,14 @@
 #define JNI_ONUNLOAD_SYMBOLS {"JNI_OnUnload"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME "." VERSION JNI_LIB_SUFFIX
+#else
 #define JNI_LIB_SUFFIX ".so"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX "." VERSION
+#endif
+#define JNI_LIB_NAME(NAME) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX
 
 #define JVM_MAXPATHLEN MAXPATHLEN
 
@@ -66,7 +73,7 @@
 #define JVM_O_O_APPEND   O_APPEND
 #define JVM_O_EXCL       O_EXCL
 #define JVM_O_CREAT      O_CREAT
-#define JVM_O_DELETE     0x10000
+#define JVM_O_DELETE     0x10000000
 
 /* Signals */
 
--- jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c
+++ jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c
@@ -32,10 +32,16 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/sysctl.h>
+#else
 #include <sys/swap.h>
+#endif
 #include <sys/resource.h>
 #include <sys/times.h>
+#ifndef _ALLBSD_SOURCE
 #include <sys/sysinfo.h>
+#endif
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -43,19 +49,28 @@
 #include <limits.h>
 #include <stdlib.h>
 #include <unistd.h>
+#if defined(__FreeBSD__)
+#include <vm/vm_param.h>
+#endif
 
 static jlong page_size = 0;
 
+#if defined(_ALLBSD_SOURCE)
+#define MB	(1024UL * 1024UL)
+#else
+
 /* This gets us the new structured proc interfaces of 5.6 & later */
 /* - see comment in <sys/procfs.h> */
 #define _STRUCTURED_PROC 1
 #include <sys/procfs.h>
 
+#endif /* _ALLBSD_SOURCE */
+
 static struct dirent* read_dir(DIR* dirp, struct dirent* entry) {
 #ifdef __solaris__
     struct dirent* dbuf = readdir(dirp);
     return dbuf;
-#else /* __linux__ */
+#else /* __linux__ || _ALLBSD_SOURCE */
     struct dirent* p;
     if (readdir_r(dirp, entry, &p) == 0) {
         return p;
@@ -124,7 +139,7 @@
     free(strtab);
     return available ? ((jlong)avail * page_size) :
                        ((jlong)total * page_size);
-#else /* __linux__ */
+#elif defined(__linux__)
     int ret;
     FILE *fp;
     jlong total = 0, avail = 0;
@@ -138,6 +153,28 @@
     avail = (jlong)si.freeswap * si.mem_unit;
 
     return available ? avail : total;
+#elif defined(__FreeBSD__)
+    struct xswdev xsw;
+    size_t mibsize, size;
+    jlong npages;
+    int mib[16], n;
+
+    mibsize = sizeof(mib) / sizeof(mib[0]);
+    if (sysctlnametomib("vm.swap_info", mib, &mibsize) == -1)
+	return (0);
+    for (n = 0, npages = 0; ; n++) {
+	mib[mibsize] = n;
+	size = sizeof(xsw);
+	if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+	    break;
+	npages += xsw.xsw_nblks;
+	if (available)
+	    npages -= xsw.xsw_used;
+    }
+    return (npages * page_size);
+#else /* _ALLBSD_SOURCE */
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (0);
 #endif
 }
 
@@ -179,7 +216,7 @@
 
     JVM_Close(fd);
     return (jlong) psinfo.pr_size * 1024;
-#else /* __linux__ */
+#elif defined(__linux__)
     FILE *fp;
     unsigned long vsize = 0;
 
@@ -197,6 +234,31 @@
 
     fclose(fp);
     return (jlong)vsize;
+#elif defined(__FreeBSD__)
+    FILE *fp;
+    unsigned long end, start;
+    jlong total = 0;
+
+    if ((fp = fopen("/proc/curproc/map", "r")) == NULL) {
+        throw_internal_error(env, "Unable to open /proc/curproc/map");
+        return -1;
+    }
+
+    for (;;) {
+	// Ignore everything except start and end entries
+	if (fscanf(fp, "0x%lx 0x%lx %*[^\n]\n", &start, &end) != 2 || start > end)
+	    break;
+	total += end - start;
+    }
+
+    fclose(fp);
+    return total;
+#else /* _ALLBSD_SOURCE */
+    /*
+     * XXXBSD: there's no way available to get vsize in BSD.
+     */
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (64 * MB);
 #endif
 }
 
@@ -222,9 +284,13 @@
     jlong cpu_time_ns;
     struct tms time;
 
-#ifdef __solaris__
+    /*
+     * BSDNOTE: FreeBSD implements _SC_CLK_TCK since FreeBSD 5, so
+     *          add a magic to handle it
+     */
+#if defined(__solaris__) || defined(_SC_CLK_TCK)
     clk_tck = (jlong) sysconf(_SC_CLK_TCK);
-#else /* __linux__ */
+#elif defined(__linux__) || defined(_ALLBSD_SOURCE)
     clk_tck = 100;
 #endif
     if (clk_tck == -1) {
@@ -244,32 +310,79 @@
 Java_com_sun_management_UnixOperatingSystem_getFreePhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#if defined (__FreeBSD__)
+    static const char *vm_stats[] = {
+	"vm.stats.vm.v_free_count",
+	"vm.stats.vm.v_cache_count",
+	/* "vm.stats.vm.v_inactive_count", */
+	NULL
+    };
+    size_t size;
+    jlong free_pages;
+    u_int i, npages;
+    for (i = 0, free_pages = 0, size = sizeof(npages); vm_stats[i] != NULL; i++) {
+	if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1)
+	    return 0;
+	free_pages += npages;
+    }
+    return (free_pages * page_size);
+#elif defined(_ALLBSD_SOURCE)
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (128 * MB);
+#else
     jlong num_avail_physical_pages = sysconf(_SC_AVPHYS_PAGES);
     return (num_avail_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getTotalPhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#if defined(_ALLBSD_SOURCE) && !defined(_SC_PHYS_PAGES)
+    jlong result;
+    int mib[2];
+    size_t rlen;
+
+    mib[0] = CTL_HW;
+    mib[1] = HW_PHYSMEM;
+    rlen = sizeof(result);
+    if (sysctl(mib, 2, &result, &rlen, NULL, 0) == -1)
+	result = 256 * MB;
+
+    return (result);
+#else
     jlong num_physical_pages = sysconf(_SC_PHYS_PAGES);
     return (num_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getOpenFileDescriptorCount
   (JNIEnv *env, jobject mbean)
 {
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (100);
+#else /* solaris/linux */
     DIR *dirp;
     struct dirent dbuf;
     struct dirent* dentp;
     jlong fds = 0;
 
+#if defined(__FreeBSD__)
+    dirp = opendir("/dev/fd");
+    if (dirp == NULL) {
+        throw_internal_error(env, "Unable to open directory /dev/fd");
+        return -1;
+    }
+#else
     dirp = opendir("/proc/self/fd");
     if (dirp == NULL) {
         throw_internal_error(env, "Unable to open directory /proc/self/fd");
         return -1;
     }
+#endif
 
     // iterate through directory entries, skipping '.' and '..'
     // each entry represents an open file descriptor.
@@ -282,6 +395,7 @@
     closedir(dirp);
     // subtract by 1 which was the fd open for this implementation
     return (fds - 1);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
--- jdk/src/solaris/native/java/io/UnixFileSystem_md.c
+++ jdk/src/solaris/native/java/io/UnixFileSystem_md.c
@@ -41,6 +41,11 @@
 #include "java_io_FileSystem.h"
 #include "java_io_UnixFileSystem.h"
 
+#if defined(_ALLBSD_SOURCE)
+#define dirent64 dirent
+#define readdir64_r readdir_r
+#define stat64 stat
+#endif
 
 /* -- Field IDs -- */
 
@@ -58,7 +63,7 @@
                                   "path", "Ljava/lang/String;");
 }
 
-
+#ifndef _ALLBSD_SOURCE
 /* -- Large-file support -- */
 
 /* LINUX_FIXME: ifdef __solaris__ here is wrong.  We need to move the
@@ -98,6 +103,7 @@
 };
 
 #endif  /* !_LFS_LARGEFILE */
+#endif /* !_ALLBSD_SOURCE */
 
 typedef int (*STAT64)(const char *, struct stat64 *);
 
@@ -107,6 +113,7 @@
 static STAT64 stat64_ptr = NULL;
 #endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef __linux__
 #ifdef __GNUC__
 static void init64IO(void) __attribute__((constructor));
@@ -120,7 +127,7 @@
     stat64_ptr = (STAT64) dlsym(handle, "_stat64");
     dlclose(handle);
 }
-
+#endif /* !_ALLBSD_SOURCE */
 
 /* -- Path operations -- */
 
@@ -485,7 +492,7 @@
 #endif
 
         /* Preserve access time */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         struct stat sb;
 
         if (stat(path, &sb) == 0) {
--- jdk/src/solaris/native/java/io/canonicalize_md.c
+++ jdk/src/solaris/native/java/io/canonicalize_md.c
@@ -33,7 +33,9 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <limits.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 
 
 /* Note: The comments in this file use the terminology
--- jdk/src/solaris/native/java/io/io_util_md.c
+++ jdk/src/solaris/native/java/io/io_util_md.c
@@ -36,7 +36,7 @@
     WITH_PLATFORM_STRING(env, path, ps) {
         FD fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /* Remove trailing slashes, since the kernel won't */
         char *p = (char *)ps + strlen(ps) - 1;
         while ((p > ps) && (*p == '/'))
--- jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c
+++ jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c
@@ -28,6 +28,11 @@
 #include "jni.h"
 #include "jni_util.h"
 
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 JNIEXPORT jobjectArray JNICALL
 Java_java_lang_ProcessEnvironment_environ(JNIEnv *env, jclass ign)
 {
@@ -37,7 +42,9 @@
      * no standard (not even de-facto) header file where the
      * declaration is to be found.  See:
      * http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html */
+#ifndef __APPLE__
     extern char ** environ; /* environ[i] looks like: VAR=VALUE\0 */
+#endif
 
     jsize count = 0;
     jsize i, j;
@@ -46,7 +53,7 @@
 
     for (i = 0; environ[i]; i++) {
         /* Ignore corrupted environment variables */
-        if (strchr(environ[i], '=') != NULL)
+        if (strchr(environ[i], '=') != NULL && *environ[i] != '=')
             count++;
     }
 
@@ -56,7 +63,7 @@
     for (i = 0, j = 0; environ[i]; i++) {
         const char * varEnd = strchr(environ[i], '=');
         /* Ignore corrupted environment variables */
-        if (varEnd != NULL) {
+        if (varEnd != NULL && varEnd != environ[i]) {
             jbyteArray var, val;
             const char * valBeg = varEnd + 1;
             jsize varLength = varEnd - environ[i];
--- jdk/src/solaris/native/java/lang/UNIXProcess_md.c
+++ jdk/src/solaris/native/java/lang/UNIXProcess_md.c
@@ -40,7 +40,11 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <sys/wait.h>
+#else
 #include <wait.h>
+#endif
 #include <signal.h>
 #include <string.h>
 #include <errno.h>
@@ -49,6 +53,17 @@
 #include <fcntl.h>
 #include <limits.h>
 
+#ifdef __FreeBSD__
+#include <dlfcn.h>
+#include <pthread.h>
+#include <pthread_np.h>
+#endif
+
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 #ifndef STDIN_FILENO
 #define STDIN_FILENO 0
 #endif
@@ -259,11 +274,89 @@
     }
 }
 
+#if defined(__FreeBSD__)
+
+extern pid_t   __sys_fork(void);
+
+static pid_t
+jdk_fork_wrapper()
+{
+    pid_t resultPid;
+    typedef void (*void_func)();
+    static void_func func_defer = NULL;
+    static void_func func_undefer = NULL;
+    static int is_libc_r = -1;
+
+    if (is_libc_r == -1) {
+
+	/*
+         * BSDNOTE: Check for loaded symbols.
+         *
+         * If "_thread_kern_sig_defer" symbol is found assume we are
+	 * libc_r
+         *
+         * If libc_r is loaded, use fork system call drectly to avoid
+         * problems with using protected pages. 
+         *
+         * --phantom
+	 */
+	func_defer =
+		(void_func)dlsym(RTLD_DEFAULT, "_thread_kern_sig_defer");
+	func_undefer =
+		(void_func)dlsym(RTLD_DEFAULT, "_thread_kern_sig_undefer");
+	if (func_defer != NULL)
+	    is_libc_r = 1;
+	else {
+	    is_libc_r = 0;
+	}
+    }
+
+    if (is_libc_r == 0) {
+	/* Not a libc_r */
+	resultPid = fork();
+    } else {
+        (*func_defer)();		/* call _thread_kern_sig_defer() */
+        resultPid = __sys_fork();
+        if (resultPid != 0)
+ 	    (*func_undefer)();		/* call _thread_kern_sig_undefer() */
+	/* leave child with signals disabled, but reenable in parent */
+    }
+
+    return resultPid;
+}
+#endif /* __FreeBSD__ */
+
+#if defined(__OpenBSD__)
+/*
+ * Directly call _thread_sys_closefrom() so the child process
+ * doesn't reset the parrent's file descriptors to be blocking.
+ * This function is only called from the child process which
+ * is single threaded and about to call execvp() so it is
+ * safe to bypass the threaded closefrom().
+ */
+int _thread_sys_closefrom(int);
+
+static int
+closeDescriptors(void)
+{
+    return _thread_sys_closefrom(FAIL_FILENO + 1);
+}
+
+#else
+
+#ifdef _ALLBSD_SOURCE                                                          
+#define FD_DIR "/dev/fd"
+#else
+#define dirent dirent64                                                        
+#define readdir readdir64                                                      
+#define FD_DIR "/proc/self/fd"
+#endif
+
 static int
 closeDescriptors(void)
 {
     DIR *dp;
-    struct dirent64 *dirp;
+    struct dirent *dirp;
     int from_fd = FAIL_FILENO + 1;
 
     /* We're trying to close all file descriptors, but opendir() might
@@ -276,13 +369,13 @@
     close(from_fd);             /* for possible use by opendir() */
     close(from_fd + 1);         /* another one for good luck */
 
-    if ((dp = opendir("/proc/self/fd")) == NULL)
+    if ((dp = opendir(FD_DIR)) == NULL)
         return 0;
 
     /* We use readdir64 instead of readdir to work around Solaris bug
      * 6395699: /proc/self/fd fails to report file descriptors >= 1024 on Solaris 9
      */
-    while ((dirp = readdir64(dp)) != NULL) {
+    while ((dirp = readdir(dp)) != NULL) {
         int fd;
         if (isdigit(dirp->d_name[0]) &&
             (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)
@@ -293,6 +386,7 @@
 
     return 1;
 }
+#endif /* !__OpenBSD__ */
 
 static void
 moveDescriptor(int fd_from, int fd_to)
@@ -449,7 +543,9 @@
      * "All identifiers in this volume of IEEE Std 1003.1-2001, except
      * environ, are defined in at least one of the headers" (!)
      */
+#ifndef __APPLE__
     extern char **environ;
+#endif
 
     if (envp != NULL)
         environ = (char **) envp;
@@ -513,10 +609,15 @@
     }
 }
 
+#if defined(__FreeBSD__)
+#undef fork1
+#define fork1() jdk_fork_wrapper()
+#else
 #ifndef __solaris__
 #undef fork1
 #define fork1() fork()
 #endif
+#endif
 
 JNIEXPORT jint JNICALL
 Java_java_lang_UNIXProcess_forkAndExec(JNIEnv *env,
@@ -578,6 +679,30 @@
     if (resultPid == 0) {
         /* Child process */
 
+
+#ifdef __OpenBSD__
+// XXXBSD: Work-around userland pthread implementation issue.
+// Closing file descriptors will reset them to be blocking.
+// This is problematic for the parent when it attemts to use
+// the blocking fd and deadlocks. Setting them to non-blocking
+// in the child prevents the close/dup2 from resetting them.
+    {
+ int flags;
+ flags = fcntl(STDIN_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);
+
+ flags = fcntl(STDOUT_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDOUT_FILENO, F_SETFL, flags | O_NONBLOCK);
+
+ flags = fcntl(STDERR_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDOUT_FILENO, F_SETFL, flags | O_NONBLOCK);
+    }
+#endif
+
+
         /* Close the parent sides of the pipe.
            Give the child sides of the pipes the right fileno's.
            Closing pipe fds here is redundant, since closeDescriptors()
--- jdk/src/solaris/native/java/lang/java_props_md.c
+++ jdk/src/solaris/native/java/lang/java_props_md.c
@@ -23,7 +23,7 @@
  * questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdio.h>
 #include <ctype.h>
 #endif
@@ -42,9 +42,17 @@
 #include <time.h>
 #include <errno.h>
 
+#if defined(_ALLBSD_SOURCE)
+#if !defined(P_tmpdir)
+#include <paths.h>
+#define P_tmpdir _PATH_VARTMP
+#endif
+#endif
+
 #include "locale_str.h"
 #include "java_props.h"
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
 #define CODESET _NL_CTYPE_CODESET_NAME
 #else
@@ -52,6 +60,7 @@
 #define CODESET ALT_CODESET_KEY
 #endif
 #endif
+#endif /* !_ALLBSD_SOURCE */
 
 /* Take an array of string pairs (map of key->value) and a string (key).
  * Examine each pair in the map to see if the first string (key) matches the
@@ -188,7 +197,12 @@
     {
         char *lc;
         lc = setlocale(LC_CTYPE, "");
-#ifndef __linux__
+#if defined(_ALLBSD_SOURCE)
+	if (lc == NULL) {
+	    lc = "C";
+	}
+	{
+#elif !defined(__linux__)
         if (lc == NULL) {
             /*
              * 'lc == null' means system doesn't support user's environment
@@ -219,7 +233,7 @@
             char *p, encoding_variant[64];
             int i, found;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
             /*
              * Workaround for Solaris bug 4201684: Xlib doesn't like @euro
              * locales. Since we don't depend on the libc @euro behavior,
@@ -236,6 +250,13 @@
                 *p = '\0';
             setlocale(LC_ALL, temp);
 #endif
+	    if (lc == NULL) {
+		strncpy(temp, "C", sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    } else {
+		strncpy(temp, lc, sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    }
 
             strcpy(temp, lc);
 
@@ -316,6 +337,9 @@
             else
                 p = nl_langinfo(CODESET);
 
+	    if (p == NULL || !strcmp(p, "C") || !strcmp(p, "US-ASCII"))
+		p = ""; // use default
+
             /* Convert the bare "646" used on Solaris to a proper IANA name */
             if (strcmp(p, "646") == 0)
                 p = "ISO646-US";
@@ -325,6 +349,7 @@
             std_encoding = (*p != '\0') ? p : "ISO8859-1";
 
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
             /*
              * Remap the encoding string to a different value for japanese
@@ -355,11 +380,19 @@
                     std_encoding = "Big5_Solaris";
             }
 #endif
+#endif /* !_ALLBSD_SOURCE */
             sprops.encoding = std_encoding;
             sprops.sun_jnu_encoding = sprops.encoding;
         }
     }
 
+#ifdef _ALLBSD_SOURCE
+#if BYTE_ORDER == _LITTLE_ENDIAN
+     sprops.unicode_encoding = "UnicodeLittle";
+ #else
+     sprops.unicode_encoding = "UnicodeBig";
+ #endif
+#else /* !_ALLBSD_SOURCE */
 #ifdef __linux__
 #if __BYTE_ORDER == __LITTLE_ENDIAN
     sprops.unicode_encoding = "UnicodeLittle";
@@ -369,6 +402,7 @@
 #else
     sprops.unicode_encoding = "UnicodeBig";
 #endif
+#endif /* _ALLBSD_SOURCE */
 
     /* user properties */
     {
@@ -405,12 +439,14 @@
     sprops.path_separator = ":";
     sprops.line_separator = "\n";
 
+#if !defined(_ALLBSD_SOURCE)
     /* Append CDE message and resource search path to NLSPATH and
      * XFILESEARCHPATH, in order to pick localized message for
      * FileSelectionDialog window (Bug 4173641).
      */
     setPathEnvironment("NLSPATH=/usr/dt/lib/nls/msg/%L/%N.cat");
     setPathEnvironment("XFILESEARCHPATH=/usr/dt/app-defaults/%L/Dt");
+#endif
 
     return &sprops;
 }
--- jdk/src/solaris/native/java/net/Inet4AddressImpl.c
+++ jdk/src/solaris/native/java/net/Inet4AddressImpl.c
@@ -35,17 +35,293 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#include <sys/param.h>
+#endif
+
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
 
 #include "java_net_Inet4AddressImpl.h"
 
+#if defined(__GLIBC__) || (defined(__FreeBSD__) && (__FreeBSD_version >= 601104))
+#define HAS_GLIBC_GETHOSTBY_R	1
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R)
+/* Use getaddrinfo(3), which is thread safe */
+/************************************************************************
+ * Inet4AddressImpl
+ */
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getLocalHostName
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getLocalHostName(JNIEnv *env, jobject this) {
+    char hostname[NI_MAXHOST+1];
+
+    hostname[0] = '\0';
+    if (JVM_GetHostName(hostname, NI_MAXHOST)) {
+	/* Something went wrong, maybe networking is not setup? */
+	strcpy(hostname, "localhost");
+    } else {
+	 struct addrinfo  hints, *res;
+	 int error;
+
+	 memset(&hints, 0, sizeof(hints));
+	 hints.ai_flags = AI_CANONNAME;
+	 hints.ai_family = AF_UNSPEC;
+
+	 error = getaddrinfo(hostname, NULL, &hints, &res);
+
+	 if (error == 0) {
+	     /* host is known to name service */
+	     error = getnameinfo(res->ai_addr,
+				 res->ai_addrlen,
+				 hostname,
+				 NI_MAXHOST,
+				 NULL,
+				 0,
+				 NI_NAMEREQD);
+
+	     /* if getnameinfo fails hostname is still the value
+	        from gethostname */
+
+	     freeaddrinfo(res);
+	}
+    }
+    return (*env)->NewStringUTF(env, hostname);
+}
+
+static jclass ni_iacls;
+static jclass ni_ia4cls;
+static jmethodID ni_ia4ctrID;
+static jfieldID ni_iaaddressID;
+static jfieldID ni_iahostID;
+static jfieldID ni_iafamilyID;
+static int initialized = 0;
+
+/*
+ * Find an internet address for a given hostname.  Note that this
+ * code only works for addresses of type INET. The translation
+ * of %d.%d.%d.%d to an address (int) occurs in java now, so the
+ * String "host" shouldn't *ever* be a %d.%d.%d.%d string
+ *
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    lookupAllHostAddr
+ * Signature: (Ljava/lang/String;)[[B
+ */
+
+JNIEXPORT jobjectArray JNICALL
+Java_java_net_Inet4AddressImpl_lookupAllHostAddr(JNIEnv *env, jobject this,
+						jstring host) {
+    const char *hostname;
+    jobject name;
+    jobjectArray ret = 0;
+    int retLen = 0;
+
+    int error=0;
+    struct addrinfo hints, *res, *resNew = NULL;
+
+    if (!initialized) {
+      ni_iacls = (*env)->FindClass(env, "java/net/InetAddress");
+      ni_iacls = (*env)->NewGlobalRef(env, ni_iacls);
+      ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
+      ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
+      ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
+      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
+      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
+      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
+      initialized = 1;
+    }
+
+    if (IS_NULL(host)) {
+	JNU_ThrowNullPointerException(env, "host is null");
+	return 0;
+    }
+    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);
+    CHECK_NULL_RETURN(hostname, NULL);
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_flags = AI_CANONNAME;
+    hints.ai_family = AF_INET;
+
+    /*
+     * Workaround for Solaris bug 4160367 - if a hostname contains a
+     * white space then 0.0.0.0 is returned
+     */
+    if (isspace(hostname[0])) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    }
+	
+    error = getaddrinfo(hostname, NULL, &hints, &res);
+	
+    if (error) {
+	/* report error */
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    } else {
+	int i = 0;
+	struct addrinfo *itr, *last, *iterator = res;
+	while (iterator != NULL) {
+	    int skip = 0;
+	    itr = resNew;
+
+	    while (itr != NULL) {
+		struct sockaddr_in *addr1, *addr2;
+
+		addr1 = (struct sockaddr_in *)iterator->ai_addr;
+		addr2 = (struct sockaddr_in *)itr->ai_addr;
+		if (addr1->sin_addr.s_addr ==
+		    addr2->sin_addr.s_addr) {
+		    skip = 1;
+		    break;
+		}
+		     
+		itr = itr->ai_next;
+	    }
+		
+	    if (!skip) {
+		struct addrinfo *next
+	            = (struct addrinfo*) malloc(sizeof(struct addrinfo));
+		if (!next) {
+		    JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
+		    ret = NULL;
+		    goto cleanupAndReturn;
+		}
+		memcpy(next, iterator, sizeof(struct addrinfo));
+		next->ai_next = NULL;
+		if (resNew == NULL) {
+		    resNew = next;
+		} else {
+		    last->ai_next = next;
+		}
+		last = next;
+		i++;
+	    }
+	    iterator = iterator->ai_next;
+	}
+
+	retLen = i;
+	iterator = resNew;
+	i = 0;
+
+        name = (*env)->NewStringUTF(env, hostname);
+        if (IS_NULL(name)) {
+          goto cleanupAndReturn;
+        }
+
+	ret = (*env)->NewObjectArray(env, retLen, ni_iacls, NULL);
+	if (IS_NULL(ret)) {
+	    /* we may have memory to free at the end of this */
+	    goto cleanupAndReturn;
+	}
+
+	while (iterator != NULL) {
+	    /* We need 4 bytes to store ipv4 address; */
+	    int len = 4;
+		
+            jobject iaObj = (*env)->NewObject(env, ni_ia4cls, ni_ia4ctrID);
+	    if (IS_NULL(iaObj)) {
+		/* we may have memory to free at the end of this */
+		ret = NULL;
+		goto cleanupAndReturn;
+	    }
+            (*env)->SetIntField(env, iaObj, ni_iaaddressID,
+                                ntohl(((struct sockaddr_in*)(iterator->ai_addr))->sin_addr.s_addr));
+            (*env)->SetObjectField(env, iaObj, ni_iahostID, name);
+            (*env)->SetObjectArrayElement(env, ret, retLen - i -1, iaObj);
+	    i++;
+	    iterator = iterator->ai_next;
+	}
+    }
+    
+cleanupAndReturn:
+    {
+	struct addrinfo *iterator, *tmp;
+	iterator = resNew;
+	while (iterator != NULL) {
+	    tmp = iterator;
+	    iterator = iterator->ai_next;
+	    free(tmp);
+	}
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+    }
+   
+    freeaddrinfo(res);
+    
+    return ret;
+
+}
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getHostByAddr
+ * Signature: (I)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getHostByAddr(JNIEnv *env, jobject this,
+					    jbyteArray addrArray) {
+    jstring ret = NULL;
+
+    char host[NI_MAXHOST+1];
+    jfieldID fid;
+    int error = 0;
+    jint family;
+    struct sockaddr *him ; 
+    int len = 0;
+    jbyte caddr[4];
+    jint addr;
+
+    struct sockaddr_in him4;
+    struct sockaddr *sa;
+
+    /* 
+	 * For IPv4 addresses construct a sockaddr_in structure.
+	 */
+    (*env)->GetByteArrayRegion(env, addrArray, 0, 4, caddr);
+    addr = ((caddr[0]<<24) & 0xff000000);
+    addr |= ((caddr[1] <<16) & 0xff0000);
+    addr |= ((caddr[2] <<8) & 0xff00);
+    addr |= (caddr[3] & 0xff);
+    memset((char *) &him4, 0, sizeof(him4));
+    him4.sin_addr.s_addr = (uint32_t) htonl(addr);
+    him4.sin_family = AF_INET;
+    sa = (struct sockaddr *) &him4;
+    len = sizeof(him4);
+    
+    error = getnameinfo(sa, len, host, NI_MAXHOST, NULL, 0,
+			       NI_NAMEREQD);
+
+    if (!error) {
+	ret = (*env)->NewStringUTF(env, host);
+    }
+
+    if (ret == NULL) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException", NULL);
+    }
+
+    return ret;
+
+}
+
+#else /* defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R) */
+
 /* the initial size of our hostent buffers */
 #define HENT_BUF_SIZE 1024
 #define BIG_HENT_BUF_SIZE 10240  /* a jumbo-sized one */
 
-#ifndef __GLIBC__
+#if !defined(__GLIBC__) && !defined(_ALLBSD_SOURCE)
 /* gethostname() is in libc.so but I can't find a header file for it */
 extern int gethostname(char *buf, int buf_len);
 #endif
@@ -85,13 +361,13 @@
         char buf2[HENT_BUF_SIZE];
         int h_error=0;
 
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
         gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
         hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
 #endif
         if (hp) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r(hp->h_addr, hp->h_length, AF_INET,
                             &res2, buf2, sizeof(buf2), &hp, &h_error);
 #else
@@ -172,7 +448,7 @@
     }
 
     /* Try once, with our static buffer. */
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
     hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
@@ -185,7 +461,7 @@
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyname_r(hostname, &res, tmp, BIG_HENT_BUF_SIZE,
                             &hp, &h_error);
 #else
@@ -274,7 +550,7 @@
     addr |= ((caddr[2] <<8) & 0xff00);
     addr |= (caddr[3] & 0xff);
     addr = htonl(addr);
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET, &hent,
                     buf, sizeof(buf), &hp, &h_error);
 #else
@@ -288,7 +564,7 @@
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET,
                             &hent, tmp, BIG_HENT_BUF_SIZE, &hp, &h_error);
 #else
@@ -310,6 +586,8 @@
     return ret;
 }
 
+#endif /* _ALLBSD_SOURCE */
+
 #define SET_NONBLOCKING(fd) {           \
         int flags = fcntl(fd, F_GETFL); \
         flags |= O_NONBLOCK;            \
--- jdk/src/solaris/native/java/net/Inet6AddressImpl.c
+++ jdk/src/solaris/native/java/net/Inet6AddressImpl.c
@@ -32,6 +32,9 @@
 #include <strings.h>
 #include <stdlib.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h> /* gethostname */
+#endif
 
 #include "jvm.h"
 #include "jni_util.h"
@@ -48,7 +51,7 @@
 #define NI_MAXHOST 1025
 #endif
 
-#ifndef __GLIBC__
+#if !defined(__GLIBC__) && !defined(_ALLBSD_SOURCE)
 /* gethostname() is in libc.so but I can't find a header file for it */
 extern int gethostname(char *buf, int buf_len);
 #endif
@@ -71,10 +74,18 @@
         /* Something went wrong, maybe networking is not setup? */
         strcpy(hostname, "localhost");
     } else {
-#ifdef __linux__
-        /* On Linux gethostname() says "host.domain.sun.com".  On
+#if defined(__linux__) && defined(_ALLBSD_SOURCE)
+	/* On Linux/FreeBSD gethostname() says "host.domain.sun.com".  On
          * Solaris gethostname() says "host", so extra work is needed.
          */
+        /*
+         * XXXBSD: Though on FreeBSD it's possible case then hostname does
+         * not contain '.' (depends on previous sethostname() call).  Maybe
+         * we need to proceed with Solaris way, but using getnameinfo()
+         * in conjunction with gethostby*() breaks thread-safeness, so
+         * we need to protect all calls to gethostby*() and getnameinfo()
+         * using same mutex.
+         */
 #else
         /* Solaris doesn't want to give us a fully qualified domain name.
          * We do a reverse lookup to try and get one.  This works
@@ -110,7 +121,7 @@
             }
         }
 #endif /* AF_INET6 */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
     }
     return (*env)->NewStringUTF(env, hostname);
 }
--- jdk/src/solaris/native/java/net/NetworkInterface.c
+++ jdk/src/solaris/native/java/net/NetworkInterface.c
@@ -24,13 +24,13 @@
  */
 
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <strings.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -41,6 +41,19 @@
 #include <stropts.h>
 #include <sys/sockio.h>
 #endif
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#if defined(__FreeBSD__) || defined(__APPLE__)
+#include <net/ethernet.h>
+#include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#endif
+#include <net/if_dl.h>
+#include <netinet/in_var.h>
+#include <ifaddrs.h>
+#endif
 
 #ifdef __linux__
 #include <sys/ioctl.h>
@@ -133,8 +146,9 @@
 
 
 
-#ifdef __solaris__
+#if defined(_ALLBSD_SOURCE) || defined(__solaris__)
 static netif *enumIPvXInterfaces(JNIEnv *env, int sock, netif *ifs, int family);
+#ifdef __solaris__
 static int    getMacFromDevice(JNIEnv *env, const char* ifname, unsigned char* retbuf);
 
 #ifndef SIOCGLIFHWADDR
@@ -142,6 +156,7 @@
 #endif
 
 #endif
+#endif
 
 /******************* Java entry points *****************************/
 
@@ -995,6 +1010,240 @@
 }
 
 
+/** BSD **/
+#ifdef _ALLBSD_SOURCE
+/* Open socket for further ioct calls, try v4 socket first and
+ * if it falls return v6 socket
+ */
+
+#ifdef AF_INET6
+// unused arg ifname and struct if2
+static int openSocketWithFallback(JNIEnv *env, const char *ifname){
+    int sock;
+    struct ifreq if2;
+
+    if ((sock = JVM_Socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+        if (errno == EPROTONOSUPPORT){
+            if ( (sock = JVM_Socket(AF_INET6, SOCK_DGRAM, 0)) < 0 ){
+                NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException", "IPV6 Socket creation failed");
+                return -1;
+            }
+        }
+        else{ // errno is not NOSUPPORT
+            NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException", "IPV4 Socket creation failed");
+            return -1;
+        }
+    }
+
+    return sock;
+}
+
+#else
+static int openSocketWithFallback(JNIEnv *env, const char *ifname){
+    return openSocket(env, AF_INET);
+}
+#endif
+
+static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
+    return enumIPvXInterfaces(env, sock, ifs, AF_INET);
+}
+
+#ifdef AF_INET6
+static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
+    return enumIPvXInterfaces(env, sock, ifs, AF_INET6);
+}
+#endif
+
+/*
+   Enumerates and returns all interfaces on BSD
+   use the same code for IPv4 and IPv6
+ */
+static netif *enumIPvXInterfaces(JNIEnv *env, int sock, netif *ifs, int family) {
+    struct ifaddrs *ifa0, *ifa;
+  
+    /*
+     * Grab the interface list
+     */
+    if (getifaddrs(&ifa0) < 0) {
+        return NULL;
+    }
+
+    /*
+     * Iterate through each interface
+     */
+    for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
+        if (ifa->ifa_addr->sa_family == family) {
+            /*
+             * Add to the list
+             */
+            ifs = addif(env, sock, ifa->ifa_name, ifs, ifa->ifa_addr, family, 0);
+
+            /*
+             * If an exception occurred then free the list
+             */
+            if ((*env)->ExceptionOccurred(env)) {
+                freeif(ifs);
+                ifs = NULL;
+                break;
+            }
+        }
+    }
+    freeifaddrs(ifa0);
+
+    return ifs;
+}
+
+static int getIndex(int sock, const char *name){
+     /*
+      * Try to get the interface index
+      */
+    struct ifreq if2;
+    strcpy(if2.ifr_name, name);
+
+    if (ioctl(sock, SIOCGIFINDEX, (char *)&if2) < 0) {
+        return -1;
+    }
+
+    return if2.ifr_index;
+}
+
+/**
+ * Returns the IPv4 broadcast address of a named interface, if it exists.
+ * Returns 0 if it doesn't have one.
+ */
+static struct sockaddr *getBroadcast(JNIEnv *env, int sock, const char *ifname, struct sockaddr *brdcast_store) {
+  struct sockaddr *ret = NULL;
+  struct ifreq if2;
+
+  memset((char *) &if2, 0, sizeof(if2));
+  strcpy(if2.ifr_name, ifname);
+
+  /* Let's make sure the interface does have a broadcast address */
+  if (ioctl(sock, SIOCGIFFLAGS, (char *)&if2)  < 0) {
+      NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL  SIOCGIFFLAGS failed");
+      return ret;
+  }
+
+  if (if2.ifr_flags & IFF_BROADCAST) {
+      /* It does, let's retrieve it*/
+      if (ioctl(sock, SIOCGIFBRDADDR, (char *)&if2) < 0) {
+          NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFBRDADDR failed");
+          return ret;
+      }
+
+      ret = brdcast_store;
+      memcpy(ret, &if2.ifr_broadaddr, sizeof(struct sockaddr));
+  }
+
+  return ret;
+}
+
+/**
+ * Returns the IPv4 subnet prefix length (aka subnet mask) for the named
+ * interface, if it has one, otherwise return -1.
+ */
+static short getSubnet(JNIEnv *env, int sock, const char *ifname) {
+    unsigned int mask;
+    short ret;
+    struct ifreq if2;
+
+    memset((char *) &if2, 0, sizeof(if2));
+    strcpy(if2.ifr_name, ifname);
+
+    if (ioctl(sock, SIOCGIFNETMASK, (char *)&if2) < 0) {
+        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFNETMASK failed");
+        return -1;
+    }
+
+    mask = ntohl(((struct sockaddr_in*)&(if2.ifr_addr))->sin_addr.s_addr);
+    ret = 0;
+    while (mask) {
+       mask <<= 1;
+       ret++;
+    }
+
+    return ret;
+}
+
+/**
+ * Get the Hardware address (usually MAC address) for the named interface.
+ * return puts the data in buf, and returns the length, in byte, of the
+ * MAC address. Returns -1 if there is no hardware address on that interface.
+ */
+static int getMacAddress(JNIEnv *env, int sock, const char* ifname, const struct in_addr* addr, unsigned char *buf) {
+    struct ifaddrs *ifa0, *ifa;
+    struct sockaddr *saddr;
+    struct sockaddr_dl *sadl;
+    int ret = -1;
+  
+    /*
+     * Grab the interface list
+     */
+    if (getifaddrs(&ifa0) < 0) {
+        return ret;
+    }
+
+    /*
+     * Iterate through each interface
+     */
+    for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
+        saddr = ifa->ifa_addr;
+
+        /* Link layer contains the MAC address */
+        if (saddr->sa_family == AF_LINK && strcmp(ifname, ifa->ifa_name) == 0) {
+            sadl = (struct sockaddr_dl *)saddr;
+
+            /* Check the address is the correct length */
+            if (sadl->sdl_alen == ETHER_ADDR_LEN) {
+                memcpy(buf, (sadl->sdl_data + sadl->sdl_nlen), ETHER_ADDR_LEN);
+                ret = ETHER_ADDR_LEN;
+                break;
+            }
+        }
+    }
+    freeifaddrs(ifa0);
+
+    return ret;
+}
+
+static int getMTU(JNIEnv *env, int sock,  const char *ifname) {
+    struct ifreq if2;
+    memset((char *) &if2, 0, sizeof(if2));
+
+    if (ifname != NULL) {
+        strcpy(if2.ifr_name, ifname);
+    } else {
+        JNU_ThrowNullPointerException(env, "network interface name is NULL");
+        return -1;
+    }
+
+    if (ioctl(sock, SIOCGIFMTU, (char *)&if2) < 0) {
+        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFMTU failed");
+        return -1;
+    }
+
+    return  if2.ifr_mtu;
+}
+
+static int getFlags(int sock, const char *ifname) {
+    struct ifreq if2;
+    int flags;
+
+    memset((char *) &if2, 0, sizeof(if2));
+    strcpy(if2.ifr_name, ifname);
+
+    if (ioctl(sock, SIOCGIFFLAGS, (char *)&if2) < 0) {
+        return -1;
+    }
+
+    flags = if2.ifr_flags & 0xffff;
+    flags |= if2.ifr_flagshigh << 16;
+
+    return flags;
+}
+
+#endif
+
 /** Linux **/
 #ifdef __linux__
 /* Open socket for further ioct calls, try v4 socket first and
--- jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c
+++ jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c
@@ -23,12 +23,12 @@
  * questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 
 #ifdef __solaris__
 #include <fcntl.h>
@@ -331,7 +331,7 @@
     /* The fdObj'fd */
     jint fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     SOCKADDR addr;
     int len;
 #endif
@@ -341,26 +341,39 @@
     }
     fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
 
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #ifdef __linux__
     if (isOldKernel) {
         int t = 1;
         setsockopt(fd, SOL_SOCKET, SO_BSDCOMPAT, (char*) &t, sizeof(int));
     } else {
+#endif /* __linux__ */
         memset(&addr, 0, sizeof(addr));
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&addr;
+#ifdef __FreeBSD__
+            him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&addr;
+#ifdef __FreeBSD__
+            him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
         JVM_Connect(fd, (struct sockaddr *)&addr, len);
+	/* XXXBSD: here we can get EADDRNOTAVAIL which need to be ignored
+	   but since return value is not checked, ignore it */
 
+#ifdef __linux__
         // After disconnecting a UDP socket, Linux kernel will set
         // local port to zero if the port number comes from implicit
         // bind. Successive send/recv on the same socket will fail.
@@ -383,6 +396,7 @@
             NET_Bind(fd, (struct sockaddr *)&addr, len);
         }
     }
+#endif
 #else
     JVM_Connect(fd, 0, 0);
 #endif
@@ -1306,7 +1320,7 @@
         /*
          * value is an InetAddress.
          */
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
         if (ipv6_available()) {
             mcast_set_if_by_addr_v6(env, this, fd, value);
         } else {
@@ -1325,7 +1339,7 @@
         /*
          * value is a NetworkInterface.
          */
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
         if (ipv6_available()) {
             mcast_set_if_by_if_v6(env, this, fd, value);
         } else {
@@ -1402,7 +1416,7 @@
  */
 static void setMulticastLoopbackMode(JNIEnv *env, jobject this, int fd,
                                   jint opt, jobject value) {
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
     if (ipv6_available()) {
         mcast_set_loop_v6(env, this, fd, value);
     } else {
@@ -1982,7 +1996,7 @@
         fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
     }
     /* setsockopt to be correct ttl */
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
     if (ipv6_available()) {
         setHopLimit(env, fd, ttl);
     } else {
@@ -2374,18 +2388,30 @@
             mname6.ipv6mr_interface = idx;
         }
 
+#if defined(_ALLBSD_SOURCE)
+#define ADD_MEMBERSHIP		IPV6_JOIN_GROUP
+#define DRP_MEMBERSHIP		IPV6_LEAVE_GROUP
+#define S_ADD_MEMBERSHIP	"IPV6_JOIN_GROUP"
+#define S_DRP_MEMBERSHIP	"IPV6_LEAVE_GROUP"
+#else
+#define ADD_MEMBERSHIP		IPV6_ADD_MEMBERSHIP
+#define DRP_MEMBERSHIP		IPV6_DROP_MEMBERSHIP
+#define S_ADD_MEMBERSHIP	"IPV6_ADD_MEMBERSHIP"
+#define S_DRP_MEMBERSHIP	"IPV6_DROP_MEMBERSHIP"
+#endif
+
         /* Join the multicast group */
-        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP),
+        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),
                            (char *) &mname6, sizeof (mname6)) < 0) {
 
             if (join) {
-                NET_ThrowCurrent(env, "setsockopt IPV6_ADD_MEMBERSHIP failed");
+                NET_ThrowCurrent(env, "setsockopt " S_ADD_MEMBERSHIP " failed");
             } else {
                 if (errno == ENOENT) {
                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Not a member of the multicast group");
                 } else {
-                    NET_ThrowCurrent(env, "setsockopt IPV6_DROP_MEMBERSHIP failed");
+                    NET_ThrowCurrent(env, "setsockopt " S_DRP_MEMBERSHIP " failed");
                 }
             }
         }
--- jdk/src/solaris/native/java/net/PlainSocketImpl.c
+++ jdk/src/solaris/native/java/net/PlainSocketImpl.c
@@ -279,10 +279,21 @@
          */
         NET_ThrowNew(env, errno, "can't create socket");
         return;
-    } else {
-        (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);
     }
 
+#ifdef AF_INET6
+    /* Disable IPV6_V6ONLY to ensure dual-socket support */
+    if (ipv6_available()) {
+        int arg = 0;
+        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,
+                       sizeof(int)) < 0) {
+            NET_ThrowNew(env, errno, "cannot set IPPROTO_IPV6");
+            close(fd);
+            return;
+        }
+    }
+#endif /* AF_INET6 */
+
     /*
      * If this is a server socket then enable SO_REUSEADDR
      * automatically and set to non blocking.
@@ -291,9 +302,15 @@
     if (ssObj != NULL) {
         int arg = 1;
         SET_NONBLOCKING(fd);
-        JVM_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
-            sizeof(arg));
+        if (JVM_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
+                           sizeof(arg)) < 0) {
+            NET_ThrowNew(env, errno, "cannot set SO_REUSEADDR");
+            close(fd);
+            return;
+        }
     }
+
+    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);
 }
 
 /*
@@ -525,9 +542,11 @@
         if (connect_rv == JVM_IO_INTR) {
             JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
                             "operation interrupted");
+#if defined(EPROTO)
         } else if (errno == EPROTO) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ProtocolException",
                            "Protocol error");
+#endif
         } else if (errno == ECONNREFUSED) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ConnectException",
                            "Connection refused");
--- jdk/src/solaris/native/java/net/bsd_close.c
+++ jdk/src/solaris/native/java/net/bsd_close.c
@@ -57,7 +57,7 @@
 /*
  * Signal to unblock thread
  */
-static int sigWakeup = (__SIGRTMAX - 2);
+static int sigWakeup = SIGIO;
 
 /*
  * The fd table and the number of file descriptors
@@ -281,9 +281,7 @@
 
 int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
        struct sockaddr *from, int *fromlen) {
-    socklen_t socklen = *fromlen;
-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &socklen) );
-    *fromlen = socklen;
+    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, (socklen_t *)fromlen) );
 }
 
 int NET_Send(int s, void *msg, int len, unsigned int flags) {
@@ -300,9 +298,7 @@
 }
 
 int NET_Accept(int s, struct sockaddr *addr, int *addrlen) {
-    socklen_t socklen = *addrlen;
-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, &socklen) );
-    *addrlen = socklen;
+    BLOCKING_IO_RETURN_INT( s, accept(s, addr, (socklen_t *)addrlen) );
 }
 
 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
--- jdk/src/solaris/native/java/net/net_util_md.c
+++ jdk/src/solaris/native/java/net/net_util_md.c
@@ -34,6 +34,15 @@
 #include <stdlib.h>
 #include <dlfcn.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
+
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -220,6 +229,14 @@
     return (*env)->GetFieldID(env, cls, "fd", "I");
 }
 
+#if defined(DONT_ENABLE_IPV6)
+jint  IPv6_supported()
+{
+    return JNI_FALSE;
+}
+
+#else /* !DONT_ENABLE_IPV6 */
+
 jint  IPv6_supported()
 {
 #ifndef AF_INET6
@@ -356,6 +373,7 @@
     close(fd);
     return JNI_TRUE;
 }
+#endif /* DONT_ENABLE_IPV6 */
 
 void
 NET_AllocSockaddr(struct sockaddr **him, int *len) {
@@ -707,6 +725,10 @@
         him6->sin6_family = AF_INET6;
         *len = sizeof(struct sockaddr_in6) ;
 
+#if defined(_ALLBSD_SOURCE) && defined(_AF_INET6)
+// XXXBSD: should we do something with scope id here ? see below linux comment
+#endif
+
         /*
          * On Linux if we are connecting to a link-local address
          * we need to specify the interface in the scope_id (2.4 kernel only)
@@ -1160,6 +1182,24 @@
 #define IPTOS_PREC_MASK 0xe0
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+#if defined(KIPC_MAXSOCKBUF)
+    int mib[3];
+    size_t rlen;
+#endif
+
+    int *bufsize;
+
+#ifdef __APPLE__
+    static int maxsockbuf = -1;
+#else
+    static long maxsockbuf = -1;
+#endif
+
+    int addopt;
+    struct linger *ling;
+#endif
+
     /*
      * IPPROTO/IP_TOS :-
      * 1. IPv6 on Solaris: no-op and will be set in flowinfo
@@ -1192,6 +1232,10 @@
         *iptos &= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
     }
 
+#if defined(AF_INET6) && defined(_ALLBSD_SOURCE)
+// XXXBSD: to be implemented ?
+#endif
+
     /*
      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris need to
      * ensure that value is <= max_buf as otherwise we get
@@ -1239,6 +1283,84 @@
     }
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+    /*
+     * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
+     * ensure that value is <= kern.ipc.maxsockbuf as otherwise we get
+     * an ENOBUFS error.
+     */
+    if (level == SOL_SOCKET) {
+        if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
+#ifdef KIPC_MAXSOCKBUF
+            if (maxsockbuf == -1) {
+               mib[0] = CTL_KERN;
+               mib[1] = KERN_IPC;
+               mib[2] = KIPC_MAXSOCKBUF;
+               rlen = sizeof(maxsockbuf);
+               if (sysctl(mib, 3, &maxsockbuf, &rlen, NULL, 0) == -1)
+                   maxsockbuf = 1024;
+
+#if 1
+               /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
+                  problem.  It should be removed when kern.ipc.maxsockbuf
+                  will be real value. */
+               maxsockbuf = (maxsockbuf/5)*4;
+#endif
+           }
+#elif defined(__OpenBSD__)
+	   maxsockbuf = SB_MAX;
+#else
+	   maxsockbuf = 64 * 1024;	/* XXX: NetBSD */
+#endif
+
+           bufsize = (int *)arg;
+           if (*bufsize > maxsockbuf) {
+               *bufsize = maxsockbuf;
+           }
+
+	   if (opt == SO_RCVBUF && *bufsize < 1024) {
+		*bufsize = 1024;
+	   }
+
+        }
+    }
+
+    /*
+     * On Solaris, SO_REUSEADDR will allow multiple datagram
+     * sockets to bind to the same port.  The network jck tests
+     * for this "feature", so we need to emulate it by turning on
+     * SO_REUSEPORT as well for that combination.
+     */
+    if (level == SOL_SOCKET && opt == SO_REUSEADDR) {
+        int sotype;
+        socklen_t arglen;
+
+        arglen = sizeof(sotype);
+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen) < 0) {
+            return -1;
+        }
+
+        if (sotype == SOCK_DGRAM) {
+            addopt = SO_REUSEPORT;
+            setsockopt(fd, level, addopt, arg, len);
+        }
+    }
+
+    /*
+     * Don't allow SO_LINGER value to be too big.
+     * Current max value (240) is empiric value based on tcp_timer.h's
+     * constant TCP_LINGERTIME, which was doubled.
+     *
+     * XXXBSD: maybe we should step it down to 120 ?
+     */
+    if (level == SOL_SOCKET && opt == SO_LINGER) {
+        ling = (struct linger *)arg;
+       if (ling->l_linger > 240 || ling->l_linger < 0) {
+           ling->l_linger = 240;
+       }
+    }
+#endif
+
     return setsockopt(fd, level, opt, arg, len);
 }
 
--- jdk/src/solaris/native/java/net/net_util_md.h
+++ jdk/src/solaris/native/java/net/net_util_md.h
@@ -37,7 +37,7 @@
 #endif
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 extern int NET_Timeout(int s, long timeout);
 extern int NET_Read(int s, void* buf, size_t len);
 extern int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
--- jdk/src/solaris/native/java/nio/MappedByteBuffer.c
+++ jdk/src/solaris/native/java/nio/MappedByteBuffer.c
@@ -38,7 +38,11 @@
                                         jlong address, jlong len)
 {
     jboolean loaded = JNI_TRUE;
+#if defined(_ALLBSD_SOURCE)
+    jint pageSize = getpagesize();
+#else
     jint pageSize = sysconf(_SC_PAGESIZE);
+#endif
     jint numPages = (len + pageSize - 1) / pageSize;
     int result = 0;
     int i = 0;
@@ -92,7 +96,11 @@
 Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jlong address,
                                       jlong len)
 {
+#if defined(_ALLBSD_SOURCE)
+    jlong pageSize = getpagesize();
+#else
     jlong pageSize = sysconf(_SC_PAGESIZE);
+#endif
     unsigned long lAddress = address;
 
     jlong offset = lAddress % pageSize;
--- jdk/src/solaris/native/java/util/FileSystemPreferences.c
+++ jdk/src/solaris/native/java/util/FileSystemPreferences.c
@@ -47,8 +47,11 @@
     return (jint) result;
 }
 
-
+#if defined(_ALLBSD_SOURCE)
+typedef struct flock FLOCK;
+#else
 typedef struct flock64 FLOCK;
+#endif
 
 /**
  * Try to open a named lock file.
@@ -86,7 +89,11 @@
     if (fd < 0) {
         result[0] = 0;
     } else {
+#if defined(_ALLBSD_SOURCE)
+        rc = fcntl(fd, F_SETLK, &fl); 
+#else
         rc = fcntl(fd, F_SETLK64, &fl);
+#endif
         result[1] = errno;
         if (rc < 0) {
             result[0]= 0;
@@ -116,7 +123,11 @@
     fl.l_start = 0;
     fl.l_type = F_UNLCK;
 
+#if defined(_ALLBSD_SOURCE)
+    rc = fcntl(fd, F_SETLK, &fl);
+#else
     rc = fcntl(fd, F_SETLK64, &fl);
+#endif
 
     if (rc < 0) {
         close(fd);
--- jdk/src/solaris/native/java/util/TimeZone_md.c
+++ jdk/src/solaris/native/java/util/TimeZone_md.c
@@ -31,7 +31,7 @@
 #include <errno.h>
 #include <stddef.h>
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #include <dirent.h>
 #include <sys/stat.h>
@@ -49,9 +49,13 @@
 #define fileclose       fclose
 #endif
 
-#ifdef __linux__
+#if defined(__linux__)  || defined(_ALLBSD_SOURCE)
 
+#ifdef __FreeBSD__
+static const char *ETC_TIMEZONE_FILE = "/var/db/zoneinfo";
+#else
 static const char *ETC_TIMEZONE_FILE = "/etc/timezone";
+#endif
 static const char *ZONEINFO_DIR = "/usr/share/zoneinfo";
 static const char *DEFAULT_ZONEINFO_FILE = "/etc/localtime";
 
@@ -199,7 +203,9 @@
     int fd;
     char *buf;
     size_t size;
+    char zoneinfo_file[PATH_MAX+1];
 
+#if defined(__linux__) || defined(__FreeBSD__)
     /*
      * Try reading the /etc/timezone file for Debian distros. There's
      * no spec of the file format available. This parsing assumes that
@@ -223,6 +229,7 @@
             return tz;
         }
     }
+#endif /* __linux__ || __FreeBSD__ */
 
     /*
      * Next, try /etc/localtime to find the zone ID.
@@ -231,6 +238,9 @@
         return NULL;
     }
 
+    strlcpy(zoneinfo_file, DEFAULT_ZONEINFO_FILE, PATH_MAX+1);
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /*
      * If it's a symlink, get the link name and its zone ID part. (The
      * older versions of timeconfig created a symlink as described in
@@ -239,21 +249,25 @@
      * from /etc/localtime.)
      */
     if (S_ISLNK(statbuf.st_mode)) {
-        char linkbuf[PATH_MAX+1];
         int len;
 
-        if ((len = readlink(DEFAULT_ZONEINFO_FILE, linkbuf, sizeof(linkbuf)-1)) == -1) {
+        if ((len = readlink(DEFAULT_ZONEINFO_FILE, zoneinfo_file, sizeof(zoneinfo_file)-1)) == -1) {
             jio_fprintf(stderr, (const char *) "can't get a symlink of %s\n",
                         DEFAULT_ZONEINFO_FILE);
             return NULL;
         }
-        linkbuf[len] = '\0';
-        tz = getZoneName(linkbuf);
+        zoneinfo_file[len] = '\0';
+        tz = getZoneName(zoneinfo_file);
         if (tz != NULL) {
             tz = strdup(tz);
+            return tz;
+        } else {
+            if (lstat(zoneinfo_file, &statbuf) == -1) {
+                return NULL;
+            }
         }
-        return tz;
     }
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     /*
      * If it's a regular file, we need to find out the same zoneinfo file
@@ -264,7 +278,7 @@
     if (buf == NULL) {
         return NULL;
     }
-    if ((fd = open(DEFAULT_ZONEINFO_FILE, O_RDONLY)) == -1) {
+    if ((fd = open(zoneinfo_file, O_RDONLY)) == -1) {
         free((void *) buf);
         return NULL;
     }
@@ -493,7 +507,7 @@
 
     tz = getenv("TZ");
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (tz == NULL) {
 #else
 #ifdef __solaris__
@@ -532,19 +546,32 @@
 {
     time_t offset;
     char sign, buf[16];
+#if defined(_ALLBSD_SOURCE)
+    struct tm *local_tm;
+    time_t clock;
+ 
+    clock = time(NULL);
+    tzset();
+    local_tm = localtime(&clock);
+    if (local_tm->tm_gmtoff >= 0) {
+	offset = (time_t) local_tm->tm_gmtoff;
+	sign = '+';
+    } else {
+	offset = (time_t) -local_tm->tm_gmtoff;
+	sign = '-';
+    }
+#else
 
     if (timezone == 0) {
         return strdup("GMT");
-    }
-
-    /* Note that the time offset direction is opposite. */
-    if (timezone > 0) {
+    } else if (timezone > 0) {
         offset = timezone;
         sign = '-';
     } else {
         offset = -timezone;
         sign = '+';
     }
+#endif
     sprintf(buf, (const char *)"GMT%c%02d:%02d",
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
--- jdk/src/solaris/native/sun/awt/CUPSfuncs.c
+++ jdk/src/solaris/native/sun/awt/CUPSfuncs.c
@@ -25,6 +25,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 #include <cups/cups.h>
 #include <cups/ppd.h>
@@ -65,10 +66,11 @@
 JNIEXPORT jboolean JNICALL
 Java_sun_print_CUPSPrinter_initIDs(JNIEnv *env,
                                          jobject printObj) {
-  void *handle = dlopen("libcups.so.2", RTLD_LAZY | RTLD_GLOBAL);
+  void *handle = dlopen(VERSIONED_JNI_LIB_NAME("cups", "2"),
+                        RTLD_LAZY | RTLD_GLOBAL);
 
   if (handle == NULL) {
-    handle = dlopen("libcups.so", RTLD_LAZY | RTLD_GLOBAL);
+    handle = dlopen(JNI_LIB_NAME("cups"), RTLD_LAZY | RTLD_GLOBAL);
     if (handle == NULL) {
       return JNI_FALSE;
     }
--- jdk/src/solaris/native/sun/awt/VDrawingArea.c
+++ jdk/src/solaris/native/sun/awt/VDrawingArea.c
@@ -31,7 +31,11 @@
 #endif /* !HEADLESS */
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef __linux__
 /* XXX: Shouldn't be necessary. */
--- jdk/src/solaris/native/sun/awt/X11Color.c
+++ jdk/src/solaris/native/sun/awt/X11Color.c
@@ -33,7 +33,9 @@
 #include <math.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 #ifndef HEADLESS
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
--- jdk/src/solaris/native/sun/awt/XDrawingArea.c
+++ jdk/src/solaris/native/sun/awt/XDrawingArea.c
@@ -30,7 +30,11 @@
 #include <Xm/XmP.h>
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef DEBUG
 #include <jvm.h>  /* To get jio_fprintf() */
--- jdk/src/solaris/native/sun/awt/awt_Font.c
+++ jdk/src/solaris/native/sun/awt/awt_Font.c
@@ -334,7 +334,7 @@
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
--- jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c
+++ jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c
@@ -40,6 +40,7 @@
 #include <jni.h>
 #include <jni_util.h>
 #include <jvm.h>
+#include <jvm_md.h>
 #include <jlong.h>
 
 #include <stdlib.h>
@@ -51,6 +52,8 @@
 #include <dlfcn.h>
 #include "Trace.h"
 
+#include "jvm_md.h"
+
 #ifdef NETSCAPE
 #include <signal.h>
 extern int awt_init_xt;
@@ -122,7 +125,7 @@
  */
 
 #define MAXFRAMEBUFFERS 16
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -600,19 +603,22 @@
 #endif /* HEADLESS */
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXinerama.so.1";
+    void* libHandle = NULL;
     int32_t locNumScr = 0;
     XineramaScreenInfo *xinInfo;
     char* XineramaQueryScreensName = "XineramaQueryScreens";
     XineramaQueryScreensFunc* XineramaQueryScreens = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(VERSIONED_JNI_LIB_NAME("Xinerama", "1"),
+                       RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle == NULL) {
+        libHandle = dlopen(JNI_LIB_NAME("Xinerama"), RTLD_LAZY | RTLD_GLOBAL);
+    }
+    if (libHandle != NULL) {
         XineramaQueryScreens = (XineramaQueryScreensFunc*)
             dlsym(libHandle, XineramaQueryScreensName);
 
@@ -648,11 +654,10 @@
     }
 }
 #endif
-#ifndef __linux__ /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXext.so";
+    void* libHandle = NULL;
     unsigned char fbhints[MAXFRAMEBUFFERS];
     int32_t locNumScr = 0;
     /* load and run XineramaGetInfo */
@@ -661,8 +666,8 @@
     XineramaGetInfoFunc* XineramaSolarisFunc = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(JNI_LIB_NAME("Xext"), RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle != NULL) {
         XineramaSolarisFunc = (XineramaGetInfoFunc*)dlsym(libHandle, XineramaGetInfoName);
         XineramaSolarisCenterFunc =
             (XineramaGetCenterHintFunc*)dlsym(libHandle, XineramaGetCenterHintName);
@@ -709,11 +714,11 @@
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1571,7 +1576,7 @@
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1584,7 +1589,7 @@
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
@@ -1649,7 +1654,11 @@
 {
     int rr_maj_ver = 0, rr_min_ver = 0;
 
-    void *pLibRandR = dlopen("libXrandr.so.2", RTLD_LAZY | RTLD_LOCAL);
+    void *pLibRandR = dlopen(VERSIONED_JNI_LIB_NAME("Xrandr", "2"),
+                             RTLD_LAZY | RTLD_LOCAL);
+    if (pLibRandR == NULL) {
+        pLibRandR = dlopen(JNI_LIB_NAME("Xrandr"), RTLD_LAZY | RTLD_LOCAL);
+    }
     if (pLibRandR == NULL) {
         J2dRlsTraceLn(J2D_TRACE_ERROR,
                       "X11GD_InitXrandrFuncs: Could not open libXrandr.so.2");
--- jdk/src/solaris/native/sun/awt/awt_InputMethod.c
+++ jdk/src/solaris/native/sun/awt/awt_InputMethod.c
@@ -67,7 +67,7 @@
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -81,7 +81,7 @@
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -99,14 +99,14 @@
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -146,7 +146,7 @@
 #endif /* XAWT */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #else
 #ifndef XAWT
@@ -425,7 +425,7 @@
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -531,7 +531,7 @@
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -539,7 +539,7 @@
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -648,7 +648,7 @@
     return result;
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
 #ifdef XAWT
                                 Window parent) {
@@ -993,7 +993,7 @@
         }
     }
 }
-#endif  /*__linux__*/
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -1050,7 +1050,7 @@
         return FALSE ;
     }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -1063,7 +1063,7 @@
             break;
         }
     }
-#else /*! __linux__ */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
 #ifdef XAWT
     on_the_spot_styles |= XIMStatusNothing;
 #else /* !XAWT */
@@ -1086,7 +1086,7 @@
         on_the_spot_styles |= XIMStatusNothing;
 
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -1134,7 +1134,7 @@
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1156,7 +1156,7 @@
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
         if (on_the_spot_styles & XIMStatusArea) {
             Widget parent;
@@ -1184,7 +1184,7 @@
         }
 #endif /* XAWT */
         XFree((void *)preedit);
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
         pX11IMData->ic_passive = XCreateIC(X11im,
                                            XNClientWindow, w,
                                            XNFocusWindow, w,
@@ -1343,7 +1343,7 @@
 
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1411,7 +1411,7 @@
  finally:
     AWT_UNLOCK();
 }
-#endif /*__linux__*/
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1513,14 +1513,14 @@
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIDProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1584,13 +1584,13 @@
 #endif /* XAWT */
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#else /* __linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
     pX11IMData->statusWidget = (Widget) NULL;
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1737,14 +1737,14 @@
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  w;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1761,7 +1761,7 @@
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1858,7 +1858,7 @@
     X11InputMethodData *pX11IMData;
     XVaNestedList status;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
       /*do nothing for linux? */
 #else
     AWT_LOCK();
@@ -1964,7 +1964,7 @@
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
--- jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
+++ jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
@@ -260,7 +260,11 @@
         }
     }
 
+#ifdef __APPLE__ 
+    strcat(p, ".dylib");
+#else
     strcat(p, ".so");
+#endif
 
     JNU_CallStaticMethodByName(env, NULL, "java/lang/System", "load",
                                "(Ljava/lang/String;)V",
--- jdk/src/solaris/native/sun/awt/awt_MToolkit.c
+++ jdk/src/solaris/native/sun/awt/awt_MToolkit.c
@@ -63,8 +63,9 @@
 extern JavaVM *jvm;
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 extern void statusWindowEventHandler(XEvent event);
+Boolean awt_dnd_process_event(XEvent* event);
 #endif
 #endif /* !HEADLESS */
 
@@ -1642,7 +1643,7 @@
               */
               Widget widget=XtWindowToWidget(awt_display, xev.xany.window);
               eventNumber++;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
               statusWindowEventHandler(xev);
 #endif
               xembed_eventHandler(&xev);
--- jdk/src/solaris/native/sun/awt/awt_Mlib.c
+++ jdk/src/solaris/native/sun/awt/awt_Mlib.c
@@ -32,6 +32,7 @@
 #include <dlfcn.h>
 #include "jni.h"
 #include <jni_util.h>
+#include "jvm_md.h"
 #include "awt_Mlib.h"
 #include "java_awt_image_BufferedImage.h"
 
@@ -67,11 +68,11 @@
         ((strncmp(name.machine, "sun4v" , 5) == 0) &&
          (getenv("USE_VIS_ON_SUN4V") != NULL)))
     {
-        handle = dlopen("libmlib_image_v.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image_v"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
-        handle = dlopen("libmlib_image.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
--- jdk/src/solaris/native/sun/awt/awt_Robot.c
+++ jdk/src/solaris/native/sun/awt/awt_Robot.c
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
--- jdk/src/solaris/native/sun/awt/awt_util.h
+++ jdk/src/solaris/native/sun/awt/awt_util.h
@@ -187,15 +187,20 @@
 #ifdef __solaris__
 extern Widget awt_util_getXICStatusAreaWindow(Widget w);
 #else
+#if defined(_ALLBSD_SOURCE)
+int32_t awt_util_getIMStatusHeight(Widget vw);
+Widget awt_util_getXICStatusAreaWindow(Widget w);
+#else
 int32_t awt_util_getIMStatusHeight(Widget vw);
 XVaNestedList awt_util_getXICStatusAreaList(Widget w);
 Widget awt_util_getXICStatusAreaWindow(Widget w);
 #endif
+#endif
 
 
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct _XmImRefRec {
   Cardinal      num_refs;       /* Number of referencing widgets. */
   Cardinal      max_refs;       /* Maximum length of refs array. */
--- jdk/src/solaris/native/sun/awt/awt_wm.c
+++ jdk/src/solaris/native/sun/awt/awt_wm.c
@@ -121,12 +121,19 @@
 static Atom XA_KWM_WIN_MAXIMIZED;
 
 /* OpenLook */
+static Atom _XA_OL_DECOR_ADD;
 static Atom _XA_OL_DECOR_DEL;
 static Atom _XA_OL_DECOR_HEADER;
 static Atom _XA_OL_DECOR_RESIZE;
 static Atom _XA_OL_DECOR_PIN;
 static Atom _XA_OL_DECOR_CLOSE;
 
+/* AfterStep */
+static Atom _XA_AS_STYLE;
+
+/* WindowMaker */
+static Atom _XA_WINDOWMAKER_STATE;
+
 /* For _NET_WM_STATE ClientMessage requests */
 #define _NET_WM_STATE_REMOVE    0 /* remove/unset property */
 #define _NET_WM_STATE_ADD       1 /* add/set property      */
@@ -193,7 +200,12 @@
         { &_XA_OL_DECOR_HEADER,              "_OL_DECOR_HEADER"              },
         { &_XA_OL_DECOR_RESIZE,              "_OL_DECOR_RESIZE"              },
         { &_XA_OL_DECOR_PIN,                 "_OL_DECOR_PIN"                 },
-        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               }
+        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               },
+	{ &_XA_OL_DECOR_ADD,		     "_OL_DECOR_ADD"		     },
+
+	{ &_XA_AS_STYLE,		     "_XA_AS_STYLE"		     },
+
+	{ &_XA_WINDOWMAKER_STATE,	     "_XA_WINDOWMAKER_STATE"	     }
     };
 #define ATOM_LIST_LENGTH (sizeof(atom_list)/sizeof(atom_list[0]))
 
@@ -942,6 +954,39 @@
     return True;
 }
 
+/*
+ * Window Maker.
+ */
+static Boolean
+awt_wm_isWindowmaker()
+{
+    if (awt_wm_atomInterned(&_XA_WINDOWMAKER_STATE, "_WINDOWMAKER_STATE"))
+        return True;
+    return False;
+}
+
+/*
+ * Afterstep.
+ */
+static Boolean
+awt_wm_isAfterstep()
+{
+    if (awt_wm_atomInterned(&_XA_AS_STYLE, "_AS_STYLE"))
+        return True;
+    return False;
+}
+
+/*
+ * FVWM 2.
+ */
+static Boolean
+awt_wm_isFvwm2()
+{
+    if (awt_wm_atomInterned(&_XA_OL_DECOR_ADD, "_OL_DECOR_ADD")
+        && !awt_wm_atomInterned(&_XA_OL_DECOR_PIN, "_OL_DECOR_PIN"))
+        return True;
+    return False;
+}
 
 static Boolean
 awt_wm_isNetWMName(char *name)
@@ -1280,6 +1325,12 @@
     else if (awt_wm_isKDE2()) {
         awt_wmgr = KDE2_WM;
     }
+    else if (awt_wm_isWindowmaker()) {
+	awt_wmgr = WINDOWMAKER_WM;
+    }
+    else if (awt_wm_isAfterstep()) {
+	awt_wmgr = AFTERSTEP_WM;
+    }
     /*
      * We don't check for legacy WM when we already know that WM
      * supports WIN or _NET wm spec.
@@ -1302,6 +1353,9 @@
         awt_wmgr = MOTIF_WM;
     }
     else if (awt_wm_isOpenLook()) {
+	awt_wmgr = OPENLOOK_WM;
+    }
+    else if (awt_wm_isFvwm2()) {
         awt_wmgr = OPENLOOK_WM;
     }
     else {
--- jdk/src/solaris/native/sun/awt/awt_wm.h
+++ jdk/src/solaris/native/sun/awt/awt_wm.h
@@ -45,7 +45,10 @@
     KDE2_WM,
     SAWFISH_WM,
     ICE_WM,
-    METACITY_WM
+    METACITY_WM,
+    AFTERSTEP_WM,
+    WINDOWMAKER_WM,
+    FVWM2_WM
 };
 
 extern void awt_wm_init(void);
--- jdk/src/solaris/native/sun/awt/extutil.h
+++ jdk/src/solaris/native/sun/awt/extutil.h
@@ -58,7 +58,7 @@
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
--- jdk/src/solaris/native/sun/awt/fontpath.c
+++ jdk/src/solaris/native/sun/awt/fontpath.c
@@ -23,7 +23,7 @@
  * questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif /* __linux__ */
 #include <stdio.h>
@@ -40,6 +40,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <sizecalc.h>
 #include <sun_font_FontManager.h>
 #ifndef HEADLESS
@@ -59,10 +60,24 @@
 extern Display *awt_display;
 #endif /* !HEADLESS */
 
+#ifdef __APPLE__
+// XXXDARWIN: Hard-code the path to Apple's freetype, as it is
+// not included in the dyld search path by default, and 10.4
+// does not support -rpath.
+//
+// This ignores the build time setting of ALT_FREETYPE_LIB_PATH,
+// and should be replaced with -rpath/@rpath support on 10.5 or later,
+// or via support for a the FREETYPE_LIB_PATH define.
+#define FONTCONFIG_DLL_VERSIONED X11_PATH "/lib/" VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL X11_PATH "/lib/" JNI_LIB_NAME("fontconfig")
+#else
+#define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL JNI_LIB_NAME("fontconfig")
+#endif
 
 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 /*
  * This can be set in the makefile to "/usr/X11" if so desired.
  */
@@ -112,24 +127,40 @@
     NULL, /* terminates the list */
 };
 
+#elif _ALLBSD_SOURCE
+static char *fullBSDFontPath[] = {
+    X11_PATH "/lib/X11/fonts/TrueType",
+    X11_PATH "/lib/X11/fonts/truetype",
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/tt",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #else /* __linux */
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
  */
 static char *fullLinuxFontPath[] = {
-    "/usr/X11R6/lib/X11/fonts/TrueType",  /* RH 7.1+ */
-    "/usr/X11R6/lib/X11/fonts/truetype",  /* SuSE */
-    "/usr/X11R6/lib/X11/fonts/tt",
-    "/usr/X11R6/lib/X11/fonts/TTF",
-    "/usr/X11R6/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
-    "/usr/share/fonts/ja/TrueType",       /* RH 7.2+ */
-    "/usr/share/fonts/truetype",
-    "/usr/share/fonts/ko/TrueType",       /* RH 9.0 */
-    "/usr/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
-    "/usr/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/TrueType",  /* RH 7.1+ */
+    X11_PATH "/lib/X11/fonts/truetype",  /* SuSE */
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
+    PACKAGE_PATH "/share/fonts/ja/TrueType",       /* RH 7.2+ */
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/ko/TrueType",       /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
     "/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType", /* Debian */
-    "/usr/X11R6/lib/X11/fonts/Type1",
-    "/usr/share/fonts/default/Type1",     /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/default/Type1",     /* RH 9.0 */
     NULL, /* terminates the list */
 };
 #endif
@@ -357,7 +388,7 @@
 
 #endif /* !HEADLESS */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -482,8 +513,10 @@
      */
     fcdirs = getFontConfigLocations();
 
-#ifdef __linux__
+#if defined(__linux__)
     knowndirs = fullLinuxFontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #else /* IF SOLARIS */
     knowndirs = fullSolarisFontPath;
 #endif
@@ -494,7 +527,8 @@
      * be initialised.
      */
 #ifndef HEADLESS
-#ifdef __linux__        /* There's no headless build on linux ... */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    /* There's no headless build on linux ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
     AWT_LOCK();
@@ -502,7 +536,7 @@
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 #endif /* !HEADLESS */
@@ -614,7 +648,7 @@
 }
 
 #include <dlfcn.h>
-#ifndef __linux__ /* i.e. is solaris */
+#if !(defined(__linux__) || defined(__APPLE__))
 #include <link.h>
 #endif
 
@@ -660,9 +694,9 @@
      * certain symbols - and functionality - to be available.
      * Also add explicit search for .so.1 in case .so symlink doesn't exist.
      */
-    libfontconfig = dlopen("libfontconfig.so.1", RTLD_LOCAL|RTLD_LAZY);
+    libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);
     if (libfontconfig == NULL) {
-        libfontconfig = dlopen("libfontconfig.so", RTLD_LOCAL|RTLD_LAZY);
+        libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);
         if (libfontconfig == NULL) {
             return NULL;
         }
--- jdk/src/solaris/native/sun/awt/gtk2_interface.c
+++ jdk/src/solaris/native/sun/awt/gtk2_interface.c
@@ -30,9 +30,10 @@
 #include <string.h>
 #include "gtk2_interface.h"
 #include "java_awt_Transparency.h"
+#include "jvm_md.h"
 #include "sizecalc.h"
 
-#define GTK2_LIB "libgtk-x11-2.0.so.0"
+#define GTK2_LIB VERSIONED_JNI_LIB_NAME("gtk-x11-2.0", "0")
 
 #define G_TYPE_INVALID                  G_TYPE_MAKE_FUNDAMENTAL (0)
 #define G_TYPE_NONE                     G_TYPE_MAKE_FUNDAMENTAL (1)
--- jdk/src/solaris/native/sun/awt/list.c
+++ jdk/src/solaris/native/sun/awt/list.c
@@ -66,7 +66,11 @@
   ----------------------------------------------------------------------- **/
 
 #include <stdio.h>
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "list.h"
 
 
--- jdk/src/solaris/native/sun/awt/robot_common.c
+++ jdk/src/solaris/native/sun/awt/robot_common.c
@@ -27,6 +27,9 @@
     #error This file should not be included in headless library
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#endif
 #include "robot_common.h"
 
 /*
--- jdk/src/solaris/native/sun/font/X11FontScaler.c
+++ jdk/src/solaris/native/sun/font/X11FontScaler.c
@@ -32,7 +32,11 @@
  * into X11FontScaler_md.c, which is compiled into another library.
  */
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <ctype.h>
 #include <sys/utsname.h>
 
--- jdk/src/solaris/native/sun/font/X11TextRenderer.c
+++ jdk/src/solaris/native/sun/font/X11TextRenderer.c
@@ -39,7 +39,11 @@
 #include "GraphicsPrimitiveMgr.h"
 #include "glyphblitting.h"
 #include "sunfontids.h"
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 
 JNIEXPORT void JNICALL AWTDrawGlyphList
--- jdk/src/solaris/native/sun/java2d/j2d_md.h
+++ jdk/src/solaris/native/sun/java2d/j2d_md.h
@@ -28,11 +28,11 @@
 #include <sys/types.h>
 
 /*
- * Linux version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's version of <sys/types.h> does not define intptr_t
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 typedef unsigned char   jubyte;
 typedef unsigned short  jushort;
--- jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c
+++ jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c
@@ -66,6 +66,10 @@
  *    MLIB_EDGE_SRC_PADDED
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include <mlib_image.h>
 #include <mlib_ImageZoom.h>
 
@@ -102,7 +106,7 @@
 
 /***************************************************************/
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -111,7 +115,7 @@
   0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
 };
 
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
@@ -120,7 +124,7 @@
   0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 /***************************************************************/
 
@@ -344,11 +348,11 @@
 #ifdef _NO_LONGLONG
 
 typedef struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   mlib_u32 uint1, uint0;
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
   mlib_u32 uint0, uint1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 } two_uint;
 
 /***************************************************************/
@@ -511,11 +515,11 @@
         DTYPE mask;
         MASK(mask);
         off *= 8;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         LSHIFT(dd_old, da[0], 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
         RSHIFT(dd_old, da[0], 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
@@ -540,30 +544,30 @@
 
           res = (res & 0xff) | (res >> 8);
           dd = gray_mask[res];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* *da++ = (dd_old >> (64 - off)) | (dd << off);*/
           RSHIFT(dd_old, dd_old, 64 - off);
           LSHIFT(dtmp, dd, off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* *da++ = (dd_old << (64 - off)) | (dd >> off);*/
           LSHIFT(dd_old, dd_old, 64 - off);
           RSHIFT(dtmp, dd, off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
           LOGIC(*da++, dd_old, dtmp, |);
           dd_old = dd;
         }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* da[0] = (dd_old >> (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) << off));*/
         LSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         RSHIFT(dtmp1, dd_old, 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* da[0] = (dd_old << (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) >> off));*/
         RSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         LSHIFT(dtmp1, dd_old, 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
         LOGIC(da[0], dtmp, dtmp1, |);
       }
       else {                                               /* aligned */
--- jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c
+++ jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c
@@ -794,7 +794,7 @@
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
--- jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h
+++ jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h
@@ -27,7 +27,10 @@
 #define OGLFuncs_md_h_Included
 
 #include <stdlib.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
+#include "jvm_md.h"
 #include "J2D_GL/glx.h"
 #include "OGLFuncMacros.h"
 
@@ -113,7 +116,7 @@
     { \
         char *libGLPath = getenv("J2D_ALT_LIBGL_PATH"); \
         if (libGLPath == NULL) { \
-            libGLPath = "libGL.so.1"; \
+            libGLPath = VERSIONED_JNI_LIB_NAME("GL", "1"); \
         } \
         OGL_LIB_HANDLE = dlopen(libGLPath, RTLD_LAZY | RTLD_LOCAL); \
     } \
--- jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c
+++ jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c
@@ -32,6 +32,7 @@
 #include "gdefs.h"
 
 #include "jni_util.h"
+#include "jvm_md.h"
 #include "awt_Component.h"
 #include "awt_GraphicsEnv.h"
 
@@ -129,7 +130,7 @@
 
     if (tryDGA && (getenv("NO_J2D_DGA") == NULL)) {
     /* we use RTLD_NOW because of bug 4032715 */
-        lib = dlopen("libsunwjdga.so", RTLD_NOW);
+        lib = dlopen(JNI_LIB_NAME("sunwjdga"), RTLD_NOW);
     }
     dgaAvailable = JNI_FALSE;
     if (lib != NULL) {
--- jdk/src/solaris/native/sun/jdga/dgalock.c
+++ jdk/src/solaris/native/sun/jdga/dgalock.c
@@ -44,6 +44,7 @@
 #include <X11/Xlib.h>
 
 #include "jni.h"
+#include "jvm_md.h"
 #include "jdga.h"
 #include "jdgadevice.h"
 
@@ -84,10 +85,10 @@
 static GetVirtualDrawableFunc * GetVirtualDrawable = GetVirtualDrawableStub;
 
 static void Solaris_DGA_XineramaInit(Display *display) {
-    void * handle = 0;
+    void * handle = NULL;
     if (IsXineramaOn == NULL) {
-        handle = dlopen("libxinerama.so", RTLD_NOW);
-        if (handle != 0) {
+        handle = dlopen(JNI_LIB_NAME("xinerama"), RTLD_NOW);
+        if (handle != NULL) {
             void *sym = dlsym(handle, "IsXineramaOn");
             IsXineramaOn = (IsXineramaOnFunc *)sym;
             if (IsXineramaOn != 0 && (*IsXineramaOn)(display)) {
--- jdk/src/solaris/native/sun/management/FileSystemImpl.c
+++ jdk/src/solaris/native/sun/management/FileSystemImpl.c
@@ -26,6 +26,10 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 #include "jni.h"
 #include "jni_util.h"
 #include "sun_management_FileSystemImpl.h"
--- jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c
+++ jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c
@@ -33,7 +33,7 @@
 #include <strings.h>
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif
 
--- jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c
+++ jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c
@@ -26,11 +26,12 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include "sun_net_spi_DefaultProxySelector.h"
 #include <dlfcn.h>
 #include <stdio.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #else
 #include <strings.h>
@@ -109,8 +110,9 @@
   /**
    * Let's try to load le GConf-2 library
    */
-  if (dlopen("libgconf-2.so", RTLD_GLOBAL | RTLD_LAZY) != NULL ||
-      dlopen("libgconf-2.so.4", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+  if (dlopen(JNI_LIB_NAME("gconf-2"), RTLD_GLOBAL | RTLD_LAZY) != NULL ||
+      dlopen(VERSIONED_JNI_LIB_NAME("gconf-2", "4"),
+             RTLD_GLOBAL | RTLD_LAZY) != NULL) {
     gconf_ver = 2;
   }
   if (gconf_ver > 0) {
--- jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c
+++ jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c
@@ -35,7 +35,7 @@
 #include <string.h>
 #include <errno.h>
 
-#if __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <netinet/in.h>
 #endif
 
@@ -81,7 +81,7 @@
     rv = connect(fd, 0, 0);
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     {
         int len;
         SOCKADDR sa;
@@ -91,17 +91,30 @@
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
 
         rv = connect(fd, (struct sockaddr *)&sa, len);
+
+#if defined(_ALLBSD_SOURCE)
+	if (rv < 0 && errno == EADDRNOTAVAIL)
+		rv = errno = 0;
+#endif
     }
 #endif
 
--- jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c
+++ jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c
@@ -72,7 +72,7 @@
     m.msg_accrightslen = 0;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     m.msg_control = NULL;
     m.msg_controllen = 0;
 #endif
@@ -120,7 +120,7 @@
     m.msg_accrightslen = 0;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     m.msg_control = NULL;
     m.msg_controllen = 0;
 #endif
--- jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c
+++ jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c
@@ -26,15 +26,21 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 #include "sun_nio_ch_FileChannelImpl.h"
 #include "java_lang_Integer.h"
 #include "nio.h"
 #include "nio_util.h"
 #include <dlfcn.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID chan_fd;        /* jobject 'fd' in sun.io.FileChannelImpl */
 
 #ifdef __solaris__
@@ -59,6 +65,24 @@
 typedef ssize_t sendfile64_func(int out_fd, int in_fd, off64_t *offset, size_t count);
 
 sendfile64_func* my_sendfile64_func = NULL;
+#elif defined(_ALLBSD_SOURCE)
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#ifdef __APPLE__
+typedef int sendfile_func(int fd, int s, off_t offset, off_t *len,
+                          struct sf_hdtr *hdtr, int flags);
+#elif defined(__FreeBSD__)
+typedef int sendfile_func(int fd, int s, off_t offset, size_t nbytes,
+                          struct sf_hdtr *hdtr, off_t *sbytes, int flags);
+#endif
+
+#if defined(__APPLE__) || defined(__FreeBSD__)
+sendfile_func* my_sendfile_func = NULL;
+#endif
 #endif
 
 JNIEXPORT jlong JNICALL
@@ -68,7 +92,8 @@
     chan_fd = (*env)->GetFieldID(env, clazz, "fd", "Ljava/io/FileDescriptor;");
 
 #ifdef __solaris__
-    if (dlopen("/usr/lib/libsendfile.so.1", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+    if (dlopen("/usr/lib/" VERSIONED_JNI_LIB_NAME("sendfile", "1"),
+               RTLD_GLOBAL | RTLD_LAZY) != NULL) {
         my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfilev64");
     }
 #endif
@@ -77,6 +102,10 @@
     my_sendfile64_func = (sendfile64_func*) dlsym(RTLD_DEFAULT, "sendfile64");
 #endif
 
+#if defined(__APPLE__) || defined(__FreeBSD__)
+    my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfile");
+#endif
+
     return pageSize;
 }
 
@@ -278,6 +307,48 @@
         return result;
     }
 #endif
+
+#ifdef _ALLBSD_SOURCE
+#if defined(__APPLE__) || defined(__FreeBSD__)
+    if (my_sendfile_func == NULL)
+        return IOS_UNSUPPORTED;
+
+    off_t numBytes;
+    int result;
+
+    numBytes = count;
+
+#ifdef __APPLE__
+    result = (*my_sendfile_func)(srcFD, dstFD, position,
+                                     &numBytes, NULL, 0);
+#elif defined(__FreeBSD__)
+    result = (*my_sendfile_func)(srcFD, dstFD, position,
+                                     count, NULL, &numBytes, 0);
+#else
+    Add an #elif for your BSD flavor
+#endif
+
+    if (numBytes > 0)
+        return numBytes;
+
+    if (result == -1) {
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)
+            return IOS_UNSUPPORTED_CASE;
+        if ((errno == EINVAL) && ((ssize_t)count >= 0))
+            return IOS_UNSUPPORTED_CASE;
+        if (errno == EINTR)
+            return IOS_INTERRUPTED;
+        JNU_ThrowIOExceptionWithLastError(env, "Transfer failed");
+        return IOS_THROWN;
+    }
+
+    return result;
+#else
+    return IOS_UNSUPPORTED;
+#endif
+#endif
 }
 
 JNIEXPORT jint JNICALL
@@ -329,6 +400,23 @@
     fl.l_start = (off64_t)pos;
     fl.l_type = F_UNLCK;
     lockResult = fcntl(fd, cmd, &fl);
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+    /* XXXFREEBSD:  While doing of preClose0() we're closing actual fd which
+       was locked, so here we'll get an error which need to be ignored to
+       satisfy TCK FileLock test */
+    /* XXXFREEBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EBADF)
+	lockResult = errno = 0;
+#endif
+#if defined(__NetBSD__)
+    /* XXXNETBSD: The dup2 in preClose0 is being done onto 1 end of a
+       socketpair which isn't a valid target for F_UNLCK. No good way to see
+       this vs. a bad lock setup so just return errno = 0 there
+       to pass JCK (lock will get removed once all fd's close anyways) */
+    /* XXXNETBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EINVAL)
+	lockResult = errno = 0;
+#endif
     if (lockResult < 0) {
         JNU_ThrowIOExceptionWithLastError(env, "Release failed");
     }
--- jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c
+++ jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c
@@ -32,8 +32,12 @@
 #include <sys/socket.h>
 #include <fcntl.h>
 #include <sys/uio.h>
+#include <unistd.h>
 #include "nio_util.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
 
 static int preCloseFD = -1;     /* File descriptor to which we dup other fd's
                                    before closing them for real */
--- jdk/src/solaris/native/sun/nio/ch/FileKey.c
+++ jdk/src/solaris/native/sun/nio/ch/FileKey.c
@@ -30,6 +30,10 @@
 #include "nio_util.h"
 #include "sun_nio_ch_FileKey.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID key_st_dev;    /* id for FileKey.st_dev */
 static jfieldID key_st_ino;    /* id for FileKey.st_ino */
 
--- jdk/src/solaris/native/sun/nio/ch/KqueueArrayWrapper.c
+++ jdk/src/solaris/native/sun/nio/ch/KqueueArrayWrapper.c
@@ -0,0 +1,186 @@
+/*
+ * Scratched by davidxu@freebsd.org
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+
+#include "sun_nio_ch_KqueueArrayWrapper.h"
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static int
+restartable_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents);
+
+static int
+timeout_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents, int timo);
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_kqueue
+  (JNIEnv *env, jclass cls)
+{
+	int kqfd = kqueue();
+	if (kqfd < 0) {
+		JNU_ThrowIOExceptionWithLastError(env, "Error creating kqueue");
+		return -1;
+    	}
+	return kqfd;
+}
+
+JNIEXPORT void JNICALL Java_sun_nio_ch_KqueueArrayWrapper_register
+  (JNIEnv *env, jclass cls, jint kqfd, jint fd, jshort filter)
+{
+	struct kevent ev;
+	struct timespec ts;
+	
+	ev.ident = fd;
+	ev.filter = filter; 
+	ev.flags = EV_ADD; 
+	ev.fflags = 0;
+	ev.data = 0;  
+	ev.udata = NULL;
+	ts.tv_sec = 0;
+	ts.tv_nsec = 0;
+	if (kevent(kqfd, &ev, 1, NULL, 0, &ts) < 0) {
+		JNU_ThrowIOExceptionWithLastError(env, "Error register kqueue event");
+	}
+}
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_kevent
+  (JNIEnv *env, jclass cls, jint kqfd, jlong changelist_addr, jint nchanges,
+   jlong eventlist_addr, jint nevents, jlong timeout)
+{
+	struct kevent *changelist = (struct kevent *)jlong_to_ptr(changelist_addr);
+	struct kevent *eventlist = (struct kevent *)jlong_to_ptr(eventlist_addr);
+	int result;
+
+	if (timeout < 0) {
+		result = restartable_kevent(kqfd, changelist, nchanges,
+			eventlist, nevents);
+	} else {
+		result = timeout_kevent(kqfd, changelist, nchanges, eventlist,
+			nevents, timeout);
+	}
+
+	if (result < 0) {
+		JNU_ThrowIOExceptionWithLastError(env, "Error polling kevent");
+		return -1;
+	}
+	return result;
+}
+
+static int
+restartable_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents)
+{
+	int result;
+
+	for (;;) {
+		result = kevent(kqfd, changelist, nchanges, eventlist,
+			nevents, NULL);
+		if (result == -1 && errno == EINTR) {
+			continue;
+		} else {
+			return result;
+		}
+	}
+}
+
+static int
+timeout_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents, int timo)
+{
+	struct timeval timeout, now, end;
+	int result;
+
+	timeout.tv_sec = timo / 1000;
+	timeout.tv_usec = (timo % 1000) * 1000;
+	gettimeofday(&now, NULL);
+	timeradd(&now, &timeout, &end);
+
+	for (;;) {
+		struct timespec ts;
+		
+		ts.tv_sec = timeout.tv_sec;
+		ts.tv_nsec = timeout.tv_usec * 1000;
+		result = kevent(kqfd, changelist, nchanges, eventlist, nevents,
+			&ts);
+		if (result == -1 && (errno == EINTR)) {
+			gettimeofday(&now, NULL);
+			if (timercmp(&now, &end, >=))
+			    return 0;
+			timersub(&end, &now, &timeout);
+		} else {
+			return result;
+		}
+	}
+}
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_keventSize
+  (JNIEnv *env, jclass cls)
+{
+	return sizeof(struct kevent);
+}
+
+JNIEXPORT void JNICALL Java_sun_nio_ch_KqueueArrayWrapper_interrupt
+  (JNIEnv *env, jclass cls, jint fd)
+{
+	int fakebuf[1];
+
+	fakebuf[0] = 1;
+	if (write(fd, fakebuf, 1) < 0) {
+		JNU_ThrowIOExceptionWithLastError(env,
+                                          "Write to interrupt fd failed");
+	}
+}
+
+JNIEXPORT void JNICALL Java_sun_nio_ch_KqueueArrayWrapper_putKevent
+  (JNIEnv *env, jclass cls, jlong address, jint index, jint fd, jshort flags, jshort filter)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	ev[index].ident = fd;
+	ev[index].flags = flags;
+	ev[index].filter = filter;
+	ev[index].fflags = 0;
+	ev[index].data = 0;
+	ev[index].udata = NULL;
+}
+
+JNIEXPORT jshort JNICALL Java_sun_nio_ch_KqueueArrayWrapper_getKeventFilter
+  (JNIEnv *env, jclass cls, jlong address, jint index)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	return ev[index].filter;
+}
+
+JNIEXPORT jshort JNICALL Java_sun_nio_ch_KqueueArrayWrapper_getKeventFlags
+  (JNIEnv *env, jclass cls, jlong address, jint index)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	return ev[index].flags;
+}
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_getKeventIdent
+  (JNIEnv *env, jclass cls, jlong address, jint index)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	return (int)ev[index].ident;
+}
+
+#ifdef __cplusplus
+}
+#endif
--- jdk/src/solaris/native/sun/nio/ch/NativeThread.c
+++ jdk/src/solaris/native/sun/nio/ch/NativeThread.c
@@ -33,12 +33,20 @@
 #include "nio_util.h"
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+#if defined(__linux__)
 #include <pthread.h>
 #include <sys/signal.h>
 
 /* Also defined in src/solaris/native/java/net/linux_close.c */
 #define INTERRUPT_SIGNAL (__SIGRTMAX - 2)
+#else
+#include <pthread.h>
+#include <signal.h>
+
+/* Also defined in src/solaris/native/java/net/bsd_close.c */
+#define INTERRUPT_SIGNAL SIGIO
+#endif
 
 static void
 nullHandler(int sig)
@@ -51,7 +59,7 @@
 JNIEXPORT void JNICALL
 Java_sun_nio_ch_NativeThread_init(JNIEnv *env, jclass cl)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
     /* Install the null handler for INTERRUPT_SIGNAL.  This might overwrite the
      * handler previously installed by java/net/linux_close.c, but that's okay
@@ -74,7 +82,7 @@
 JNIEXPORT jlong JNICALL
 Java_sun_nio_ch_NativeThread_current(JNIEnv *env, jclass cl)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     return (long)pthread_self();
 #else
     return -1;
@@ -84,7 +92,7 @@
 JNIEXPORT void JNICALL
 Java_sun_nio_ch_NativeThread_signal(JNIEnv *env, jclass cl, jlong thread)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pthread_kill((pthread_t)thread, INTERRUPT_SIGNAL))
         JNU_ThrowIOExceptionWithLastError(env, "Thread signal failed");
 #endif
--- jdk/src/solaris/native/sun/nio/ch/Net.c
+++ jdk/src/solaris/native/sun/nio/ch/Net.c
@@ -65,17 +65,33 @@
                             jboolean reuse)
 {
     int fd;
-
+    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);
 #ifdef AF_INET6
-    if (ipv6_available())
-        fd = socket(AF_INET6, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
-    else
-#endif /* AF_INET6 */
-        fd = socket(AF_INET, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
+    int domain = ipv6_available() ? AF_INET6 : AF_INET;
+#else
+    int domain = AF_INET;
+#endif
 
+    fd = socket(domain, type, 0);
     if (fd < 0) {
         return handleSocketError(env, errno);
     }
+
+#ifdef AF_INET6
+    /* Disable IPV6_V6ONLY to ensure dual-socket support */
+    if (domain == AF_INET6) {
+        int arg = 0;
+        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,
+                       sizeof(int)) < 0) {
+            JNU_ThrowByNameWithLastError(env,
+                                         JNU_JAVANETPKG "SocketException",
+                                         "sun.nio.ch.Net.setIntOption");
+            close(fd);
+            return -1;
+        }
+    }
+#endif
+
     if (reuse) {
         int arg = 1;
         if (NET_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
@@ -143,10 +159,33 @@
 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
 {
     SOCKADDR sa;
-    int sa_len = SOCKADDR_LEN;
+    socklen_t sa_len = SOCKADDR_LEN;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+#ifdef _ALLBSD_SOURCE
+ /*
+  * XXXBSD:
+  * ECONNRESET is specific to the BSDs. We can not return an error,
+  * as the calling Java code with raise a java.lang.Error given the expectation
+  * that getsockname() will never fail. According to the Single UNIX Specification,
+  * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+  */
+ if (errno == ECONNRESET) {
+     struct sockaddr_in *sin;
+     sin = (struct sockaddr_in *) &sa;
+     bzero(sin, sizeof(*sin));
+     sin->sin_len  = sizeof(struct sockaddr_in);
+     sin->sin_family = AF_INET;
+     sin->sin_port = htonl(0);
+     sin->sin_addr.s_addr = INADDR_ANY;
+ } else {
+     handleSocketError(env, errno);
+     return -1;
+ }
+#else /* _ALLBSD_SOURCE */
         handleSocketError(env, errno);
         return -1;
+#endif /* _ALLBSD_SOURCE */
+
     }
     return NET_GetPortFromSockaddr((struct sockaddr *)&sa);
 }
@@ -155,15 +194,79 @@
 Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
 {
     SOCKADDR sa;
-    int sa_len = SOCKADDR_LEN;
+    socklen_t sa_len = SOCKADDR_LEN;
     int port;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
-        handleSocketError(env, errno);
-        return NULL;
+#ifdef _ALLBSD_SOURCE
+ /*
+  * XXXBSD:
+  * ECONNRESET is specific to the BSDs. We can not return an error,
+  * as the calling Java code with raise a java.lang.Error with the expectation
+  * that getsockname() will never fail. According to the Single UNIX Specification,
+  * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+  */
+ if (errno == ECONNRESET) {
+     struct sockaddr_in *sin;
+     sin = (struct sockaddr_in *) &sa;
+     bzero(sin, sizeof(*sin));
+     sin->sin_len  = sizeof(struct sockaddr_in);
+     sin->sin_family = AF_INET;
+     sin->sin_port = htonl(0);
+     sin->sin_addr.s_addr = INADDR_ANY;
+ } else {
+     handleSocketError(env, errno);
+     return NULL;
+ }
+#else /* _ALLBSD_SOURCE */
+          handleSocketError(env, errno);
+          return NULL;
+#endif /* _ALLBSD_SOURCE */
+
     }
     return NET_SockaddrToInetAddress(env, (struct sockaddr *)&sa, &port);
 }
 
+#ifdef _ALLBSD_SOURCE
+
+#ifndef IP_BLOCK_SOURCE
+
+#define IP_ADD_SOURCE_MEMBERSHIP        70   /* join a source-specific group */
+#define IP_DROP_SOURCE_MEMBERSHIP       71   /* drop a single source */
+#define IP_BLOCK_SOURCE                 72   /* block a source */
+#define IP_UNBLOCK_SOURCE               73   /* unblock a source */
+
+#endif  /* IP_BLOCK_SOURCE */
+
+#ifndef MCAST_BLOCK_SOURCE
+
+#define MCAST_JOIN_SOURCE_GROUP         82   /* join a source-specific group */
+#define MCAST_LEAVE_SOURCE_GROUP        83   /* leave a single source */
+#define MCAST_BLOCK_SOURCE              84   /* block a source */
+#define MCAST_UNBLOCK_SOURCE            85   /* unblock a source */
+
+#endif /* MCAST_BLOCK_SOURCE */
+
+#ifndef IPV6_ADD_MEMBERSHIP
+
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+
+#endif /* IPV6_ADD_MEMBERSHIP */
+
+struct my_ip_mreq_source {
+        struct in_addr  imr_multiaddr;
+        struct in_addr  imr_interface;
+        struct in_addr  imr_sourceaddr;
+};
+
+struct my_group_source_req {
+        uint32_t                gsr_interface;  /* interface index */
+        struct sockaddr_storage gsr_group;      /* group address */
+        struct sockaddr_storage gsr_source;     /* source address */
+};
+
+#endif   /* _ALLBSD_SOURCE */
+
 
 #ifdef NEEDED
 
@@ -309,9 +412,11 @@
     switch (errorValue) {
         case EINPROGRESS:       /* Non-blocking connect */
             return 0;
+#ifdef EPROTO
         case EPROTO:
             xn = JNU_JAVANETPKG "ProtocolException";
             break;
+#endif
         case ECONNREFUSED:
             xn = JNU_JAVANETPKG "ConnectException";
             break;
--- jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c
+++ jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c
@@ -26,7 +26,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 #include "NativeFunc.h"
 
 /* standard GSS method names (ordering is from mapfile) */
--- jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c
+++ jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c
@@ -28,12 +28,19 @@
 #include <string.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni_util.h>
 
 #include "j2secmod.h"
 
+#ifndef RTLD_NOLOAD
+/* A gross hack that will work if the NSS library is only opened once */
+static void *nssLibHandle = NULL;
+#endif
+
 void *findFunction(JNIEnv *env, jlong jHandle, const char *functionName) {
     void *hModule = (void*)jHandle;
     void *fAddress = dlsym(hModule, functionName);
@@ -51,7 +58,11 @@
 {
     const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);
     // look up existing handle only, do not load
+#ifdef RTLD_NOLOAD
     void *hModule = dlopen(libName, RTLD_NOLOAD);
+#else
+    void *hModule = nssLibHandle;
+#endif
     dprintf2("-handle for %s: %u\n", libName, hModule);
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     return (jlong)hModule;
@@ -65,6 +76,9 @@
 
     dprintf1("-lib %s\n", libName);
     hModule = dlopen(libName, RTLD_LAZY);
+#ifndef RTLD_NOLOAD
+    nssLibHandle = hModule;
+#endif
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     dprintf2("-handle: %u (0X%X)\n", hModule, hModule);
 
--- jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c
+++ jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c
@@ -64,7 +64,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni.h>
 
--- jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c
+++ jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c
@@ -29,7 +29,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <winscard.h>
 
--- jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c
+++ jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c
@@ -35,10 +35,10 @@
 #include <dirent.h>
 #include <ctype.h>
 #include <sys/types.h>
-#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/un.h>
+#include <fcntl.h>
 
 #include "sun_tools_attach_BsdVirtualMachine.h"
 
@@ -49,85 +49,6 @@
 } while(0)
 
 /*
- * Defines a callback that is invoked for each process
- */
-typedef void (*ProcessCallback)(const pid_t pid, void* user_data);
-
-/*
- * Invokes the callback function for each process
- */
-static void forEachProcess(ProcessCallback f, void* user_data) {
-    DIR* dir;
-    struct dirent* ptr;
-
-    /*
-     * To locate the children we scan /proc looking for files that have a
-     * position integer as a filename.
-     */
-    if ((dir = opendir("/proc")) == NULL) {
-        return;
-    }
-    while ((ptr = readdir(dir)) != NULL) {
-        pid_t pid;
-
-        /* skip current/parent directories */
-        if (strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0) {
-            continue;
-        }
-
-        /* skip files that aren't numbers */
-        pid = (pid_t)atoi(ptr->d_name);
-        if ((int)pid <= 0) {
-            continue;
-        }
-
-        /* invoke the callback */
-        (*f)(pid, user_data);
-    }
-    closedir(dir);
-}
-
-
-/*
- * Returns the parent pid of a given pid, or -1 if not found
- */
-static pid_t getParent(pid_t pid) {
-    char state;
-    FILE* fp;
-    char stat[2048];
-    int statlen;
-    char fn[32];
-    int i, p;
-    char* s;
-
-    /*
-     * try to open /proc/%d/stat
-     */
-    sprintf(fn, "/proc/%d/stat", pid);
-    fp = fopen(fn, "r");
-    if (fp == NULL) {
-        return -1;
-    }
-
-    /*
-     * The format is: pid (command) state ppid ...
-     * As the command could be anything we must find the right most
-     * ")" and then skip the white spaces that follow it.
-     */
-    statlen = fread(stat, 1, 2047, fp);
-    stat[statlen] = '\0';
-    fclose(fp);
-    s = strrchr(stat, ')');
-    if (s == NULL) {
-        return -1;
-    }
-    do s++; while (isspace(*s));
-    i = sscanf(s, "%c %d", &state, &p);
-    return (pid_t)p;
-}
-
-
-/*
  * Class:     sun_tools_attach_BsdVirtualMachine
  * Method:    socket
  * Signature: ()I
@@ -188,146 +109,6 @@
 
 /*
  * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    isBsdThreads
- * Signature: ()V
- */
-JNIEXPORT jboolean JNICALL Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads
-  (JNIEnv *env, jclass cls)
-{
-# ifndef _CS_GNU_LIBPTHREAD_VERSION
-# define _CS_GNU_LIBPTHREAD_VERSION 3
-# endif
-    size_t n;
-    char* s;
-    jboolean res;
-
-    n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-    if (n <= 0) {
-       /* glibc before 2.3.2 only has BsdThreads */
-       return JNI_TRUE;
-    }
-
-    s = (char *)malloc(n);
-    if (s == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "malloc failed");
-        return JNI_TRUE;
-    }
-    confstr(_CS_GNU_LIBPTHREAD_VERSION, s, n);
-
-    /*
-     * If the LIBPTHREAD version include "NPTL" then we know we
-     * have the new threads library and not BsdThreads
-     */
-    res = (jboolean)(strstr(s, "NPTL") == NULL);
-    free(s);
-    return res;
-}
-
-/*
- * Structure and callback function used to count the children of
- * a given process, and record the pid of the "manager thread".
- */
-typedef struct {
-    pid_t ppid;
-    int count;
-    pid_t mpid;
-} ChildCountContext;
-
-static void ChildCountCallback(const pid_t pid, void* user_data) {
-    ChildCountContext* context = (ChildCountContext*)user_data;
-    if (getParent(pid) == context->ppid) {
-        context->count++;
-        /*
-         * Remember the pid of the first child. If the final count is
-         * one then this is the pid of the BsdThreads manager.
-         */
-        if (context->count == 1) {
-            context->mpid = pid;
-        }
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    getBsdThreadsManager
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    ChildCountContext context;
-
-    /*
-     * Iterate over all processes to find how many children 'pid' has
-     */
-    context.ppid = pid;
-    context.count = 0;
-    context.mpid = (pid_t)0;
-    forEachProcess(ChildCountCallback, (void*)&context);
-
-    /*
-     * If there's no children then this is likely the pid of the primordial
-     * created by the launcher - in that case the BsdThreads manager is the
-     * parent of this process.
-     */
-    if (context.count == 0) {
-        pid_t parent = getParent(pid);
-        if ((int)parent > 0) {
-            return (jint)parent;
-        }
-    }
-
-    /*
-     * There's one child so this is likely the embedded VM case where the
-     * the primordial thread == BsdThreads initial thread. The BsdThreads
-     * manager in that case is the child.
-     */
-    if (context.count == 1) {
-        return (jint)context.mpid;
-    }
-
-    /*
-     * If we get here it's most likely we were given the wrong pid
-     */
-    JNU_ThrowIOException(env, "Unable to get pid of BsdThreads manager thread");
-    return -1;
-}
-
-/*
- * Structure and callback function used to send a QUIT signal to all
- * children of a given process
- */
-typedef struct {
-    pid_t ppid;
-} SendQuitContext;
-
-static void SendQuitCallback(const pid_t pid, void* user_data) {
-    SendQuitContext* context = (SendQuitContext*)user_data;
-    pid_t parent = getParent(pid);
-    if (parent == context->ppid) {
-        kill(pid, SIGQUIT);
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    sendQuitToChildrenOf
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    SendQuitContext context;
-    context.ppid = (pid_t)pid;
-
-    /*
-     * Iterate over all children of 'pid' and send a QUIT signal to each.
-     */
-    forEachProcess(SendQuitCallback, (void*)&context);
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
  * Method:    sendQuitTo
  * Signature: (I)V
  */
@@ -350,7 +131,7 @@
     jboolean isCopy;
     const char* p = GetStringPlatformChars(env, path, &isCopy);
     if (p != NULL) {
-        struct stat64 sb;
+        struct stat sb;
         uid_t uid, gid;
         int res;
 
@@ -361,7 +142,7 @@
         uid = geteuid();
         gid = getegid();
 
-        res = stat64(p, &sb);
+        res = stat(p, &sb);
         if (res != 0) {
             /* save errno */
             res = errno;
@@ -459,3 +240,40 @@
 
     } while (remaining > 0);
 }
+
+/*
+ * Class:     sun_tools_attach_BSDVirtualMachine
+ * Method:    createAttachFile
+ * Signature: (Ljava.lang.String;)V
+ */
+JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_createAttachFile(JNIEnv *env, jclass cls, jstring path)
+{
+    const char* _path;
+    jboolean isCopy;
+    int fd, rc;
+
+    _path = GetStringPlatformChars(env, path, &isCopy);
+    if (_path == NULL) {
+        JNU_ThrowIOException(env, "Must specify a path");
+        return;
+    }
+
+    RESTARTABLE(open(_path, O_CREAT | O_EXCL, S_IWUSR | S_IRUSR), fd);
+    if (fd == -1) {
+        /* release p here before we throw an I/O exception */
+        if (isCopy) {
+            JNU_ReleaseStringPlatformChars(env, path, _path);
+        }
+        JNU_ThrowIOExceptionWithLastError(env, "open");
+        return;
+    }
+
+    RESTARTABLE(chown(_path, geteuid(), getegid()), rc);
+
+    RESTARTABLE(close(fd), rc);
+
+    /* release p here */
+    if (isCopy) {
+        JNU_ReleaseStringPlatformChars(env, path, _path);
+    }
+}
--- jdk/src/solaris/native/sun/xawt/XWindow.c
+++ jdk/src/solaris/native/sun/xawt/XWindow.c
@@ -228,10 +228,10 @@
     {java_awt_event_KeyEvent_VK_DOWN, XK_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
 
     /* Keypad equivalents of Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_KP_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
 
     /* Other vendor-specific Triangular Navigation Block */
     {java_awt_event_KeyEvent_VK_LEFT, osfXK_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
@@ -865,7 +865,7 @@
 {
     KeySym originalKeysym = *keysym;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
--- jdk/src/solaris/native/sun/xawt/awt_Desktop.c
+++ jdk/src/solaris/native/sun/xawt/awt_Desktop.c
@@ -24,6 +24,7 @@
  */
 
 #include <jni.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 
 typedef int gboolean;
@@ -36,7 +37,7 @@
     gboolean (*gnome_vfs_init) (void);
     const char *errmsg;
 
-    vfs_handle = dlopen("libgnomevfs-2.so.0", RTLD_LAZY);
+    vfs_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnomevfs-2", "0"), RTLD_LAZY);
     if (vfs_handle == NULL) {
 #ifdef INTERNAL_BUILD
         fprintf(stderr, "can not load libgnomevfs-2.so\n");
@@ -54,7 +55,7 @@
     // call gonme_vfs_init()
     (*gnome_vfs_init)();
 
-    gnome_handle = dlopen("libgnome-2.so.0", RTLD_LAZY);
+    gnome_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnome-2", "0"), RTLD_LAZY);
     if (gnome_handle == NULL) {
 #ifdef INTERNAL_BUILD
         fprintf(stderr, "can not load libgnome-2.so\n");
--- jdk/src/solaris/npt/npt_md.h
+++ jdk/src/solaris/npt/npt_md.h
@@ -32,9 +32,10 @@
 #include <string.h>
 #include <errno.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
-
-#define NPT_LIBNAME "libnpt.so"
+#endif
+#include <jvm_md.h>
 
 #define NPT_INITIALIZE(pnpt,version,options)                            \
     {                                                                   \
@@ -43,7 +44,7 @@
                                                                         \
         if ( (pnpt) == NULL ) NPT_ERROR("NptEnv* is NULL");             \
         *(pnpt) = NULL;                                                 \
-        _handle =  dlopen(NPT_LIBNAME, RTLD_LAZY);                      \
+        _handle =  dlopen(JNI_LIB_NAME("npt"), RTLD_LAZY);              \
         if ( _handle == NULL ) NPT_ERROR("Cannot open library");        \
         _sym = dlsym(_handle, "nptInitialize");                         \
         if ( _sym == NULL ) NPT_ERROR("Cannot find nptInitialize");     \
--- jdk/src/solaris/transport/socket/socket_md.c
+++ jdk/src/solaris/transport/socket/socket_md.c
@@ -36,7 +36,7 @@
 #ifdef __solaris__
 #include <thread.h>
 #endif
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #include <sys/poll.h>
 #endif
@@ -283,7 +283,7 @@
 
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 int
 dbgsysTlsAlloc() {
     pthread_key_t key;
--- langtools/src/share/classes/com/sun/tools/javah/Util.java
+++ langtools/src/share/classes/com/sun/tools/javah/Util.java
@@ -180,6 +180,14 @@
             os = "win32";
         } else if (os.indexOf("Linux") >= 0) {
             os = "Linux";
+	} else if (os.indexOf("FreeBSD") >= 0) {
+	    os = "FreeBSD";
+	} else if (os.indexOf("Darwin") >= 0) {
+	    os = "Darwin";
+	} else if (os.indexOf("NetBSD") >= 0) {
+	    os = "NetBSD";
+	} else if (os.indexOf("OpenBSD") >= 0) {
+	    os = "OpenBSD";
         }
         String arch = System.getProperty("os.arch");
         String resname = "com.sun.tools.javah.resources." + os + "_" + arch;
