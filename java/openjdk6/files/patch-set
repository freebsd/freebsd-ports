--- Makefile
+++ Makefile
@@ -236,6 +236,18 @@
 
 clean: clobber
 
+# Add location of iconv headers & libs
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    OTHER_LDLIBS += -liconv
+  else
+    ifneq ($(OS_NAME), netbsd)
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
+  endif
+endif
+
 #
 # Dev builds
 #
--- corba/make/common/Defs-bsd.gmk
+++ corba/make/common/Defs-bsd.gmk
@@ -40,18 +40,12 @@
 # Get shared JDK settings
 include $(BUILDDIR)/common/shared/Defs.gmk
 
-# Part of INCREMENTAL_BUILD mechanism.
-#   Compiler emits things like:  path/file.o: file.h
-#   We want something like: relative_path/file.o relative_path/file.d: file.h
-CC_DEPEND	 = -MM
-CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
-
 ifndef PLATFORM_SRC
   PLATFORM_SRC = $(TOPDIR)/src/solaris
 endif # PLATFORM_SRC
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -94,6 +88,10 @@
 #    as the default.
 CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
@@ -176,7 +174,7 @@
   CXXFLAGS_DBG	+= $(CC_LOWER_OPT)
 endif
 
-CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -DLINUX $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -186,33 +184,16 @@
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -Xlinker -z -Xlinker defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
 LDFLAGS_OPT     = -Xlinker -O1
+
+ifneq ($(OS_VENDOR), Apple)
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
+
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -243,13 +224,9 @@
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
-#
-# Support for Quantify.
-#
-ifdef QUANTIFY
-QUANTIFY_CMD = quantify
-QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
-LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
 endif
 
 #
@@ -278,7 +255,9 @@
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
@@ -289,13 +268,9 @@
 override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
-override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override NO_INTERRUPTIBLE_IO     = false
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
--- corba/make/common/Defs-linux.gmk
+++ corba/make/common/Defs-linux.gmk
@@ -290,7 +290,7 @@
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
--- corba/make/common/Defs.gmk
+++ corba/make/common/Defs.gmk
@@ -53,6 +53,24 @@
 
 _OUTPUTDIR=$(TOPDIR)/build/$(PLATFORM)-$(ARCH)
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -97,6 +115,9 @@
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
--- corba/make/common/Mapfile-vers.gmk
+++ corba/make/common/Mapfile-vers.gmk
@@ -77,7 +77,7 @@
 endif # PLATFORM
 
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 ifeq ($(VARIANT), OPT)
   # OPT build MUST have a mapfile?
--- corba/make/common/shared/Compiler-gcc.gmk
+++ corba/make/common/shared/Compiler-gcc.gmk
@@ -100,6 +100,24 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  # Settings specific to BSD
+  CC             ?= $(COMPILER_PATH)gcc
+  CPP            ?= $(COMPILER_PATH)gcc -E
+  CXX            ?= $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.3
+  REQUIRED_GCC_VER = 3.3.*
+
+# Option used to create a shared library
+ifeq ($(OS_VENDOR), Apple)
+  SHARED_LIBRARY_FLAG = -dynamiclib
+else
+  SHARED_LIBRARY_FLAG = -shared
+endif
+
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- corba/make/common/shared/Compiler.gmk
+++ corba/make/common/shared/Compiler.gmk
@@ -42,6 +42,11 @@
   override CC_VERSION = gcc
 endif
 
+# BSD uses GNU compilers by default
+ifeq ($(PLATFORM), bsd)
+  override CC_VERSION = gcc
+endif
+
 # Get the compiler specific settings
 include $(BUILDDIR)/common/shared/Compiler-$(CC_VERSION).gmk
 
--- corba/make/common/shared/Defs-bsd.gmk
+++ corba/make/common/shared/Defs-bsd.gmk
@@ -54,7 +54,7 @@
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH =$(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -107,7 +107,7 @@
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
--- corba/make/common/shared/Defs-java.gmk
+++ corba/make/common/shared/Defs-java.gmk
@@ -38,7 +38,7 @@
   #   Suspect this may not be needed anymore.
   JAVA_MEM_FLAGS   += -Xms$(MAX_VM_MEMORY)m -XX:-Inline
 else
-  JAVA_MEM_FLAGS   += -Xms$(MIN_VM_MEMORY)m -XX:PermSize=32m -XX:MaxPermSize=160m
+  JAVA_MEM_FLAGS   += -Xms$(MIN_VM_MEMORY)m
 endif
 
 # 
--- corba/make/common/shared/Defs-utils.gmk
+++ corba/make/common/shared/Defs-utils.gmk
@@ -53,6 +53,13 @@
   UTILS_DEVTOOL_PATH=$(USRBIN_PATH)
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 ifeq ($(PLATFORM),solaris)
   UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
   UTILS_USR_BIN_PATH=$(UNIXCOMMAND_PATH)
@@ -199,3 +206,32 @@
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
--- corba/make/common/shared/Platform.gmk
+++ corba/make/common/shared/Platform.gmk
@@ -261,6 +261,76 @@
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+ REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+ REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586 and sparc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -408,7 +478,14 @@
 #    build machines and adjustments will be made to prevent excessing
 #    system swapping during the build.
 #    If we don't know, assume 512. Subtract 128 from MB for VM MAX.
-#    Don't set VM max over 1024-128=896.
+#    Don't set VM max over 1024-128=896, except on OpenBSD where
+#    736 is the max.
+ifeq ($(OS_VENDOR), OpenBSD)
+  ABS_MAX_MEMORY := "736"
+else
+  ABS_MAX_MEMORY := "896"
+endif
+
 ifneq ($(MB_OF_MEMORY),)
   LOW_MEMORY_MACHINE := $(shell \
     if [ $(MB_OF_MEMORY) -le 512 ] ; then \
@@ -420,7 +497,7 @@
     if [ $(MB_OF_MEMORY) -le 1024 ] ; then \
       expr $(MB_OF_MEMORY) '-' 128 ; \
     else \
-      echo "896"; \
+      echo $(ABS_MAX_MEMORY); \
     fi)
   MIN_VM_MEMORY := $(shell \
     if [ $(MAX_VM_MEMORY) -le 128 ] ; then \
--- hotspot/agent/make/Makefile
+++ hotspot/agent/make/Makefile
@@ -52,6 +52,9 @@
 sun.jvm.hotspot.compiler \
 sun.jvm.hotspot.debugger \
 sun.jvm.hotspot.debugger.amd64 \
+sun.jvm.hotspot.debugger.bsd \
+sun.jvm.hotspot.debugger.bsd.amd64 \
+sun.jvm.hotspot.debugger.bsd.x86 \
 sun.jvm.hotspot.debugger.cdbg \
 sun.jvm.hotspot.debugger.cdbg.basic \
 sun.jvm.hotspot.debugger.cdbg.basic.amd64 \
@@ -94,6 +97,9 @@
 sun.jvm.hotspot.oops \
 sun.jvm.hotspot.runtime \
 sun.jvm.hotspot.runtime.amd64 \
+sun.jvm.hotspot.runtime.bsd \
+sun.jvm.hotspot.runtime.bsd_amd64 \
+sun.jvm.hotspot.runtime.bsd_x86 \
 sun.jvm.hotspot.runtime.ia64 \
 sun.jvm.hotspot.runtime.linux \
 sun.jvm.hotspot.runtime.linux_amd64 \
@@ -143,6 +149,9 @@
 sun/jvm/hotspot/compiler/*.java \
 sun/jvm/hotspot/debugger/*.java \
 sun/jvm/hotspot/debugger/amd64/*.java \
+sun/jvm/hotspot/debugger/bsd/*.java \
+sun/jvm/hotspot/debugger/bsd/amd64/*.java \
+sun/jvm/hotspot/debugger/bsd/x86/*.java \
 sun/jvm/hotspot/debugger/cdbg/*.java \
 sun/jvm/hotspot/debugger/cdbg/basic/*.java \
 sun/jvm/hotspot/debugger/cdbg/basic/amd64/*.java \
@@ -178,6 +187,9 @@
 sun/jvm/hotspot/oops/*.java \
 sun/jvm/hotspot/runtime/*.java \
 sun/jvm/hotspot/runtime/amd64/*.java \
+sun/jvm/hotspot/runtime/bsd/*.java \
+sun/jvm/hotspot/runtime/bsd_amd64/*.java \
+sun/jvm/hotspot/runtime/bsd_x86/*.java \
 sun/jvm/hotspot/runtime/ia64/*.java \
 sun/jvm/hotspot/runtime/linux/*.java \
 sun/jvm/hotspot/runtime/linux_amd64/*.java \
--- hotspot/agent/src/os/bsd/BsdDebuggerLocal.c
+++ hotspot/agent/src/os/bsd/BsdDebuggerLocal.c
@@ -22,6 +22,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <jni.h>
 #include "libproc.h"
 
@@ -73,7 +74,7 @@
   (JNIEnv *env, jclass cls) {
   jclass listClass;
 
-  if (init_libproc(getenv("LIBSAPROC_DEBUG")) != true) {
+  if (init_libproc(getenv("LIBSAPROC_DEBUG") != NULL) != true) {
      THROW_NEW_DEBUGGER_EXCEPTION("can't initialize libproc");
   }
 
@@ -275,7 +276,7 @@
   bufPtr = (*env)->GetByteArrayElements(env, array, &isCopy);
   CHECK_EXCEPTION_(0);
 
-  err = ps_pdread(get_proc_handle(env, this_obj), (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
+  err = ps_pread(get_proc_handle(env, this_obj), (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
   (*env)->ReleaseByteArrayElements(env, array, bufPtr, 0);
   return (err == PS_OK)? array : 0;
 }
@@ -283,11 +284,10 @@
 JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0
   (JNIEnv *env, jobject this_obj, jint lwp_id) {
 
-  struct user_regs_struct gregs;
+  struct reg gregs;
   jboolean isCopy;
   jlongArray array;
   jlong *regs;
-  int i;
 
   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
   if (get_lwp_regs(ph, lwp_id, &gregs) != true) {
@@ -317,26 +317,27 @@
 #ifdef i386
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##reg
 
-  regs[REG_INDEX(GS)]  = (uintptr_t) gregs.xgs;
-  regs[REG_INDEX(FS)]  = (uintptr_t) gregs.xfs;
-  regs[REG_INDEX(ES)]  = (uintptr_t) gregs.xes;
-  regs[REG_INDEX(DS)]  = (uintptr_t) gregs.xds;
-  regs[REG_INDEX(EDI)] = (uintptr_t) gregs.edi;
-  regs[REG_INDEX(ESI)] = (uintptr_t) gregs.esi;
-  regs[REG_INDEX(FP)] = (uintptr_t) gregs.ebp;
-  regs[REG_INDEX(SP)] = (uintptr_t) gregs.esp;
-  regs[REG_INDEX(EBX)] = (uintptr_t) gregs.ebx;
-  regs[REG_INDEX(EDX)] = (uintptr_t) gregs.edx;
-  regs[REG_INDEX(ECX)] = (uintptr_t) gregs.ecx;
-  regs[REG_INDEX(EAX)] = (uintptr_t) gregs.eax;
-  regs[REG_INDEX(PC)] = (uintptr_t) gregs.eip;
-  regs[REG_INDEX(CS)]  = (uintptr_t) gregs.xcs;
-  regs[REG_INDEX(SS)]  = (uintptr_t) gregs.xss;
+  regs[REG_INDEX(GS)]  = (uintptr_t) gregs.r_gs;
+  regs[REG_INDEX(FS)]  = (uintptr_t) gregs.r_fs;
+  regs[REG_INDEX(ES)]  = (uintptr_t) gregs.r_es;
+  regs[REG_INDEX(DS)]  = (uintptr_t) gregs.r_ds;
+  regs[REG_INDEX(EDI)] = (uintptr_t) gregs.r_edi;
+  regs[REG_INDEX(ESI)] = (uintptr_t) gregs.r_esi;
+  regs[REG_INDEX(FP)] = (uintptr_t) gregs.r_ebp;
+  regs[REG_INDEX(SP)] = (uintptr_t) gregs.r_isp;
+  regs[REG_INDEX(EBX)] = (uintptr_t) gregs.r_ebx;
+  regs[REG_INDEX(EDX)] = (uintptr_t) gregs.r_edx;
+  regs[REG_INDEX(ECX)] = (uintptr_t) gregs.r_ecx;
+  regs[REG_INDEX(EAX)] = (uintptr_t) gregs.r_eax;
+  regs[REG_INDEX(PC)] = (uintptr_t) gregs.r_eip;
+  regs[REG_INDEX(CS)]  = (uintptr_t) gregs.r_cs;
+  regs[REG_INDEX(SS)]  = (uintptr_t) gregs.r_ss;
 
 #endif /* i386 */
 
 #if ia64
   regs = (*env)->GetLongArrayElements(env, array, &isCopy);
+  int i;
   for (i = 0; i < NPRGREG; i++ ) {
     regs[i] = 0xDEADDEAD;
   }
@@ -345,31 +346,31 @@
 #ifdef amd64
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 
-  regs[REG_INDEX(R15)] = gregs.r15;
-  regs[REG_INDEX(R14)] = gregs.r14;
-  regs[REG_INDEX(R13)] = gregs.r13;
-  regs[REG_INDEX(R12)] = gregs.r12;
-  regs[REG_INDEX(RBP)] = gregs.rbp;
-  regs[REG_INDEX(RBX)] = gregs.rbx;
-  regs[REG_INDEX(R11)] = gregs.r11;
-  regs[REG_INDEX(R10)] = gregs.r10;
-  regs[REG_INDEX(R9)] = gregs.r9;
-  regs[REG_INDEX(R8)] = gregs.r8;
-  regs[REG_INDEX(RAX)] = gregs.rax;
-  regs[REG_INDEX(RCX)] = gregs.rcx;
-  regs[REG_INDEX(RDX)] = gregs.rdx;
-  regs[REG_INDEX(RSI)] = gregs.rsi;
-  regs[REG_INDEX(RDI)] = gregs.rdi;
-  regs[REG_INDEX(RIP)] = gregs.rip;
-  regs[REG_INDEX(CS)] = gregs.cs;
-  regs[REG_INDEX(RSP)] = gregs.rsp;
-  regs[REG_INDEX(SS)] = gregs.ss;
-  regs[REG_INDEX(FSBASE)] = gregs.fs_base;
-  regs[REG_INDEX(GSBASE)] = gregs.gs_base;
-  regs[REG_INDEX(DS)] = gregs.ds;
-  regs[REG_INDEX(ES)] = gregs.es;
-  regs[REG_INDEX(FS)] = gregs.fs;
-  regs[REG_INDEX(GS)] = gregs.gs;
+  regs[REG_INDEX(R15)] = gregs.r_r15;
+  regs[REG_INDEX(R14)] = gregs.r_r14;
+  regs[REG_INDEX(R13)] = gregs.r_r13;
+  regs[REG_INDEX(R12)] = gregs.r_r12;
+  regs[REG_INDEX(RBP)] = gregs.r_rbp;
+  regs[REG_INDEX(RBX)] = gregs.r_rbx;
+  regs[REG_INDEX(R11)] = gregs.r_r11;
+  regs[REG_INDEX(R10)] = gregs.r_r10;
+  regs[REG_INDEX(R9)] = gregs.r_r9;
+  regs[REG_INDEX(R8)] = gregs.r_r8;
+  regs[REG_INDEX(RAX)] = gregs.r_rax;
+  regs[REG_INDEX(RCX)] = gregs.r_rcx;
+  regs[REG_INDEX(RDX)] = gregs.r_rdx;
+  regs[REG_INDEX(RSI)] = gregs.r_rsi;
+  regs[REG_INDEX(RDI)] = gregs.r_rdi;
+  regs[REG_INDEX(RIP)] = gregs.r_rip;
+  regs[REG_INDEX(CS)] = gregs.r_cs;
+  regs[REG_INDEX(RSP)] = gregs.r_rsp;
+  regs[REG_INDEX(SS)] = gregs.r_ss;
+//  regs[REG_INDEX(FSBASE)] = gregs.fs_base;
+//  regs[REG_INDEX(GSBASE)] = gregs.gs_base;
+//  regs[REG_INDEX(DS)] = gregs.ds;
+//  regs[REG_INDEX(ES)] = gregs.es;
+//  regs[REG_INDEX(FS)] = gregs.fs;
+//  regs[REG_INDEX(GS)] = gregs.gs;
 
 #endif /* amd64 */
 
--- hotspot/agent/src/os/bsd/Makefile
+++ hotspot/agent/src/os/bsd/Makefile
@@ -22,8 +22,8 @@
 #  
 #
 
-ARCH := $(shell if ([ `uname -m` = "ia64" ])  ; then echo ia64 ; elif ([ `uname -m` = "x86_64" ]) ; then echo amd64; elif ([ `uname -m` = "sparc64" ]) ; then echo sparc; else echo i386 ; fi )
-GCC      = gcc
+ARCH := $(shell if ([ `uname -m` = "ia64" ])  ; then echo ia64 ; elif ([ `uname -m` = "amd64" ]) ; then echo amd64; elif ([ `uname -m` = "sparc64" ]) ; then echo sparc; else echo i386 ; fi )
+GCC      ?= gcc
 
 JAVAH    = ${JAVA_HOME}/bin/javah
 
@@ -32,25 +32,24 @@
 	libproc_impl.c  \
 	ps_proc.c       \
 	ps_core.c       \
-	BsdDebuggerLocal.c 
+	BsdDebuggerLocal.c
 
-INCLUDES = -I${JAVA_HOME}/include -I${JAVA_HOME}/include/bsd 
+INCLUDES = -I${JAVA_HOME}/include -I${JAVA_HOME}/include/$(shell uname -s | tr "[:upper:]" "[:lower:]")
 
 OBJS     = $(SOURCES:.c=.o)
 
-LIBS     = -lthread_db
+LIBS     = -lutil -lthread_db
 
-CFLAGS   = -c -fPIC -g -D_GNU_SOURCE -D$(ARCH) $(INCLUDES)
+CFLAGS   = -c -fPIC -g -Wall -D_ALLBSD_SOURCE -D_GNU_SOURCE -D$(ARCH) $(INCLUDES)
 
 LIBSA = $(ARCH)/libsaproc.so
 
 all: $(LIBSA)
 
 BsdDebuggerLocal.o: BsdDebuggerLocal.c
-	$(JAVAH) -jni -classpath ../../../build/classes  \
+	$(JAVAH) -jni -classpath ../../../../../build/bsd-i586/hotspot/outputdir/bsd_i486_compiler2/generated/saclasses  \
 		sun.jvm.hotspot.debugger.x86.X86ThreadContext \
-		sun.jvm.hotspot.debugger.sparc.SPARCThreadContext \
-		sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext 
+		sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext
 	$(GCC) $(CFLAGS) $<
 
 .c.obj:
@@ -60,26 +59,19 @@
   LFLAGS_LIBSA = -Xlinker --version-script=mapfile
 endif
 
-# If this is a --hash-style=gnu system, use --hash-style=both
-#   The gnu .hash section won't work on some Bsd systems like SuSE 10.
-_HAS_HASH_STYLE_GNU:=$(shell $(CC) -dumpspecs | grep -- '--hash-style=gnu')
-ifneq ($(_HAS_HASH_STYLE_GNU),)
-  LDFLAGS_HASH_STYLE = -Wl,--hash-style=both
-endif
-LFLAGS_LIBSA += $(LDFLAGS_HASH_STYLE)
-
 $(LIBSA): $(OBJS) mapfile
 	if [ ! -d $(ARCH) ] ; then mkdir $(ARCH) ; fi
 	$(GCC) -shared $(LFLAGS_LIBSA) -o $(LIBSA) $(OBJS) $(LIBS)
 
-test.o: test.c
+test.o: $(LIBSA) test.c
 	$(GCC) -c -o test.o -g -D_GNU_SOURCE -D$(ARCH) $(INCLUDES) test.c
 
 test: test.o
 	$(GCC) -o test test.o -L$(ARCH) -lsaproc $(LIBS)
 
 clean:
-	rm -rf $(LIBSA)
-	rm -rf $(OBJS)
-	rmdir $(ARCH)
+	rm -f $(LIBSA)
+	rm -f $(OBJS)
+	rm -f test.o
+	-rmdir $(ARCH)
 
--- hotspot/agent/src/os/bsd/elfmacros.h
+++ hotspot/agent/src/os/bsd/elfmacros.h
@@ -25,16 +25,19 @@
 #ifndef _ELFMACROS_H_
 #define _ELFMACROS_H_
 
+#define ELF_NHDR        Elf_Note
+
 #if defined(_LP64)
 #define ELF_EHDR        Elf64_Ehdr
 #define ELF_SHDR        Elf64_Shdr
 #define ELF_PHDR        Elf64_Phdr
 #define ELF_SYM         Elf64_Sym
-#define ELF_NHDR        Elf64_Nhdr
 #define ELF_DYN         Elf64_Dyn
 #define ELF_ADDR        Elf64_Addr
 
+#ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE     ELF64_ST_TYPE
+#endif
 
 #else
 
@@ -42,11 +45,12 @@
 #define ELF_SHDR        Elf32_Shdr
 #define ELF_PHDR        Elf32_Phdr
 #define ELF_SYM         Elf32_Sym
-#define ELF_NHDR        Elf32_Nhdr
 #define ELF_DYN         Elf32_Dyn
 #define ELF_ADDR        Elf32_Addr
 
+#ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE     ELF32_ST_TYPE
+#endif
 
 #endif
 
--- hotspot/agent/src/os/bsd/libproc.h
+++ hotspot/agent/src/os/bsd/libproc.h
@@ -27,7 +27,8 @@
 
 #include <unistd.h>
 #include <stdint.h>
-#include "proc_service.h"
+#include <machine/reg.h>
+#include <proc_service.h>
 
 #if defined(sparc) || defined(sparcv9)
 /*
@@ -50,14 +51,11 @@
 adds Pgrab__ and some missing stuff. We hide the difference b/w live process and core
 file by this interface.
 
-1. pthread_id unique in both NPTL & BsdThreads. We store this in
-OSThread::_pthread_id in JVM code.
+1. pthread_id is unique. We store this in OSThread::_pthread_id in JVM code.
 
-2. All threads see the same pid when they call getpid() under NPTL.
-Threads receive different pid under BsdThreads. We used to save the result of
-::getpid() call in OSThread::_thread_id. This way uniqueness of OSThread::_thread_id
-was lost under NPTL. Now, we store the result of ::gettid() call in
-OSThread::_thread_id. Because gettid returns actual pid of thread (lwp id), this is
+2. All threads see the same pid when they call getpid().
+We used to save the result of ::getpid() call in OSThread::_thread_id.
+Because gettid returns actual pid of thread (lwp id), this is
 unique again. We therefore use OSThread::_thread_id as unique identifier.
 
 3. There is a unique LWP id under both thread libraries. libthread_db  maps pthread_id
@@ -74,20 +72,7 @@
 
 *************************************************************************************/
 
-#ifdef ia64
-struct user_regs_struct {
-/* copied from user.h which doesn't define this in a struct */
-
-#define IA64_REG_COUNT (EF_SIZE/8+32)   /* integer and fp regs */
-unsigned long   regs[IA64_REG_COUNT];     /* integer and fp regs */
-};
-#endif
-
-#if defined(sparc)  || defined(sparcv9)
-#define user_regs_struct  pt_regs
-#endif
-
-// This C bool type must be int for compatibility with Bsd calls and
+// This C bool type must be int for compatibility with BSD calls and
 // it would be a mistake to equivalence it to C++ bool on many platforms
 
 typedef int bool;
@@ -118,7 +103,7 @@
 lwpid_t get_lwp_id(struct ps_prochandle* ph, int index);
 
 // get regs for a given lwp
-bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lid, struct user_regs_struct* regs);
+bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lid, struct reg* regs);
 
 // get number of shared objects
 int get_num_libs(struct ps_prochandle* ph);
--- hotspot/agent/src/os/bsd/libproc_impl.c
+++ hotspot/agent/src/os/bsd/libproc_impl.c
@@ -174,10 +174,13 @@
       return NULL;
    }
 
-   newlib->symtab = build_symtab(newlib->fd, libname);
+   newlib->symtab = build_symtab(newlib->fd);
    if (newlib->symtab == NULL) {
       print_debug("symbol table build failed for %s\n", newlib->name);
    }
+   else {
+      print_debug("built symbol table for %s\n", newlib->name);
+   }
 
    // even if symbol table building fails, we add the lib_info.
    // This is because we may need to read from the ELF file for core file
@@ -232,6 +235,24 @@
 }
 
 // add a thread to ps_prochandle
+#ifdef __FreeBSD__
+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id) {
+   thread_info* newthr;
+   if ( (newthr = (thread_info*) calloc(1, sizeof(thread_info))) == NULL) {
+      print_debug("can't allocate memory for thread_info\n");
+      return NULL;
+   }
+
+   // initialize thread info
+   newthr->lwp_id = lwp_id;
+
+   // add new thread to the list
+   newthr->next = ph->threads;
+   ph->threads = newthr;
+   ph->num_threads++;
+   return newthr;
+}
+#else
 thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
    thread_info* newthr;
    if ( (newthr = (thread_info*) calloc(1, sizeof(thread_info))) == NULL) {
@@ -249,6 +270,7 @@
    ph->num_threads++;
    return newthr;
 }
+#endif
 
 
 // struct used for client data from thread_db callback
@@ -270,10 +292,17 @@
     return err;
   }
 
+#ifdef __FreeBSD__
+  print_debug("thread_db : lwp %d\n", ti.ti_lid);
+
+  if (ptr->callback(ptr->ph, ti.ti_lid) != true)
+    return TD_ERR;
+#else
   print_debug("thread_db : pthread %d (lwp %d)\n", ti.ti_tid, ti.ti_lid);
 
-  if (ptr->callback(ptr->ph, ti.ti_tid, ti.ti_lid) != true)
+  if (ptr->callback(ptr->ph, (pthread_t)ti.ti_tid, ti.ti_lid) != true)
     return TD_ERR;
+#endif
 
   return TD_OK;
 }
@@ -324,7 +353,7 @@
 }
 
 // get regs for a given lwp
-bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id, struct user_regs_struct* regs) {
+bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id, struct reg* regs) {
   return ph->ops->get_lwp_regs(ph, lwp_id, regs);
 }
 
@@ -375,11 +404,6 @@
 //--------------------------------------------------------------------------
 // proc service functions
 
-// get process id
-pid_t ps_getpid(struct ps_prochandle *ph) {
-   return ph->pid;
-}
-
 // ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
 // of the load object object_name in the target process identified by ph.
 // It returns the symbol's value as an address in the target process in
@@ -392,17 +416,33 @@
 }
 
 // read "size" bytes info "buf" from address "addr"
-ps_err_e ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
-                   void *buf, size_t size) {
+ps_err_e ps_pread(struct ps_prochandle *ph, psaddr_t  addr,
+                  void *buf, size_t size) {
   return ph->ops->p_pread(ph, (uintptr_t) addr, buf, size)? PS_OK: PS_ERR;
 }
 
 // write "size" bytes of data to debuggee at address "addr"
-ps_err_e ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
-                    const void *buf, size_t size) {
+ps_err_e ps_pwrite(struct ps_prochandle *ph, psaddr_t addr,
+                   const void *buf, size_t size) {
   return ph->ops->p_pwrite(ph, (uintptr_t)addr, buf, size)? PS_OK: PS_ERR;
 }
 
+// fill in ptrace_lwpinfo for lid
+ps_err_e ps_linfo(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+  return ph->ops->get_lwp_info(ph, lwp_id, linfo)? PS_OK: PS_ERR;
+}
+
+// needed for when libthread_db is compiled with TD_DEBUG defined
+void
+ps_plog (const char *format, ...)
+{
+  va_list alist;
+
+  va_start(alist, format);
+  vfprintf(stderr, format, alist);
+  va_end(alist);
+}
+
 // ------------------------------------------------------------------------
 // Functions below this point are not yet implemented. They are here only
 // to make the linker happy.
@@ -427,8 +467,12 @@
   return PS_OK;
 }
 
-// new libthread_db of NPTL seem to require this symbol
-ps_err_e ps_get_thread_area() {
-  print_debug("ps_get_thread_area not implemented\n");
+ps_err_e ps_lstop(struct ps_prochandle *ph, lwpid_t lid) {
+  print_debug("ps_lstop not implemented\n");
+  return PS_OK;
+}
+
+ps_err_e ps_pcontinue(struct ps_prochandle *ph) {
+  print_debug("ps_pcontinue not implemented\n");
   return PS_OK;
 }
--- hotspot/agent/src/os/bsd/libproc_impl.h
+++ hotspot/agent/src/os/bsd/libproc_impl.h
@@ -47,7 +47,7 @@
 typedef struct thread_info {
    lwpid_t                  lwp_id;
    pthread_t                pthread_id; // not used cores, always -1
-   struct user_regs_struct  regs;       // not for process, core uses for caching regset
+   struct reg               regs;       // not for process, core uses for caching regset
    struct thread_info*      next;
 } thread_info;
 
@@ -71,7 +71,9 @@
    bool (*p_pwrite)(struct ps_prochandle *ph,
             uintptr_t addr, const char *buf , size_t size);
    // get integer regset of a thread
-   bool (*get_lwp_regs)(struct ps_prochandle* ph, lwpid_t lwp_id, struct user_regs_struct* regs);
+   bool (*get_lwp_regs)(struct ps_prochandle* ph, lwpid_t lwp_id, struct reg* regs);
+   // get info on thread
+   bool (*get_lwp_info)(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo);
 } ps_prochandle_ops;
 
 // the ps_prochandle
@@ -79,7 +81,7 @@
 struct core_data {
    int                core_fd;   // file descriptor of core file
    int                exec_fd;   // file descriptor of exec file
-   int                interp_fd; // file descriptor of interpreter (ld-bsd.so.2)
+   int                interp_fd; // file descriptor of interpreter (ld-elf.so.1)
    // part of the class sharing workaround
    int                classes_jsa_fd; // file descriptor of class share archive
    uintptr_t          dynamic_addr;  // address of dynamic section of a.out
@@ -107,7 +109,11 @@
 void print_debug(const char* format,...);
 bool is_debug();
 
+#ifdef __FreeBSD__
+typedef bool (*thread_info_callback)(struct ps_prochandle* ph, lwpid_t lwpid);
+#else
 typedef bool (*thread_info_callback)(struct ps_prochandle* ph, pthread_t pid, lwpid_t lwpid);
+#endif
 
 // reads thread info using libthread_db and calls above callback for each thread
 bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb);
@@ -120,7 +126,11 @@
                           uintptr_t base);
 
 // adds a new thread to threads list, returns NULL on failure
+#ifdef __FreeBSD__
+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id);
+#else
 thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id);
+#endif
 
 // a test for ELF signature without using libelf
 bool is_elf_file(int fd);
--- hotspot/agent/src/os/bsd/mapfile
+++ hotspot/agent/src/os/bsd/mapfile
@@ -43,13 +43,17 @@
 		# proc_service.h functions - to be used by libthread_db
 		ps_getpid;
 		ps_pglobal_lookup;
-		ps_pdread;
-		ps_pdwrite;
+		ps_pread;
+		ps_pwrite;
 		ps_lsetfpregs;
 		ps_lsetregs;
 		ps_lgetfpregs;
 		ps_lgetregs;
-		ps_get_thread_area;
+		ps_lcontinue;
+		ps_lgetxmmregs;
+		ps_lsetxmmregs;
+		ps_lstop;
+		ps_linfo;
 
                 # used by attach test program
                 init_libproc;
--- hotspot/agent/src/os/bsd/proc_service.h
+++ hotspot/agent/src/os/bsd/proc_service.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,76 +0,0 @@
-/*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#ifndef _PROC_SERVICE_H_
-#define _PROC_SERVICE_H_
-
-#include <stdio.h>
-#include <thread_db.h>
-
-// Bsd does not have the proc service library, though it does provide the
-// thread_db library which can be used to manipulate threads without having
-// to know the details of BsdThreads or NPTL
-
-// copied from Solaris "proc_service.h"
-typedef enum {
-        PS_OK,          /* generic "call succeeded" */
-        PS_ERR,         /* generic error */
-        PS_BADPID,      /* bad process handle */
-        PS_BADLID,      /* bad lwp identifier */
-        PS_BADADDR,     /* bad address */
-        PS_NOSYM,       /* p_lookup() could not find given symbol */
-        PS_NOFREGS      /* FPU register set not available for given lwp */
-} ps_err_e;
-
-// ps_getpid() is only defined on Bsd to return a thread's process ID
-pid_t ps_getpid(struct ps_prochandle *ph);
-
-// ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
-// of the load object object_name in the target process identified by ph.
-// It returns the symbol's value as an address in the target process in
-// *sym_addr.
-
-ps_err_e ps_pglobal_lookup(struct ps_prochandle *ph, const char *object_name,
-                    const char *sym_name, psaddr_t *sym_addr);
-
-// read "size" bytes of data from debuggee at address "addr"
-ps_err_e ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
-                   void *buf, size_t size);
-
-// write "size" bytes of data to debuggee at address "addr"
-ps_err_e ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
-                    const void *buf, size_t size);
-
-ps_err_e ps_lsetfpregs(struct ps_prochandle *ph, lwpid_t lid, const prfpregset_t *fpregs);
-
-ps_err_e ps_lsetregs(struct ps_prochandle *ph, lwpid_t lid, const prgregset_t gregset);
-
-ps_err_e  ps_lgetfpregs(struct  ps_prochandle  *ph,  lwpid_t lid, prfpregset_t *fpregs);
-
-ps_err_e ps_lgetregs(struct ps_prochandle *ph, lwpid_t lid, prgregset_t gregset);
-
-// new libthread_db of NPTL seem to require this symbol
-ps_err_e ps_get_thread_area();
-
-#endif /* _PROC_SERVICE_H_ */
--- hotspot/agent/src/os/bsd/ps_core.c
+++ hotspot/agent/src/os/bsd/ps_core.c
@@ -142,6 +142,7 @@
 
    map->next = ph->core->class_share_maps;
    ph->core->class_share_maps = map;
+   return map;
 }
 
 // Return the map_info for the given virtual address.  We keep a sorted
@@ -228,8 +229,8 @@
 
     // 4991491 NOTICE These are C++ bool's in filemap.hpp and must match up with
     // the C type matching the C++ bool type on any given platform. For
-    // Hotspot on Bsd we assume the corresponding C type is char but
-    // licensees on Bsd versions may need to adjust the type of these fields.
+    // Hotspot on BSD we assume the corresponding C type is char but
+    // licensees on BSD versions may need to adjust the type of these fields.
     char   _read_only;       // read only space?
     char   _allow_exec;      // executable code in space?
 
@@ -240,7 +241,7 @@
 
 static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {
    jboolean i;
-   if (ps_pdread(ph, (psaddr_t) addr, &i, sizeof(i)) == PS_OK) {
+   if (ps_pread(ph, (psaddr_t) addr, &i, sizeof(i)) == PS_OK) {
       *pvalue = i;
       return true;
    } else {
@@ -250,7 +251,7 @@
 
 static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {
    uintptr_t uip;
-   if (ps_pdread(ph, (psaddr_t) addr, &uip, sizeof(uip)) == PS_OK) {
+   if (ps_pread(ph, (psaddr_t) addr, &uip, sizeof(uip)) == PS_OK) {
       *pvalue = uip;
       return true;
    } else {
@@ -264,7 +265,7 @@
    char  c = ' ';
 
    while (c != '\0') {
-     if (ps_pdread(ph, (psaddr_t) addr, &c, sizeof(char)) != PS_OK)
+     if (ps_pread(ph, (psaddr_t) addr, &c, sizeof(char)) != PS_OK)
          return false;
       if (i < size - 1)
          buf[i] = c;
@@ -296,7 +297,6 @@
          uintptr_t base = 0, useSharedSpacesAddr = 0;
          uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;
          jboolean useSharedSpaces = 0;
-         map_info* mi = 0;
 
          memset(classes_jsa, 0, sizeof(classes_jsa));
          jvm_name = lib->name;
@@ -306,9 +306,9 @@
             return false;
          }
 
-         // Hotspot vm types are not exported to build this library. So
-         // using equivalent type jboolean to read the value of
-         // UseSharedSpaces which is same as hotspot type "bool".
+	 // Hotspot vm types are not exported to build this library. So
+	 // using equivalent type jboolean to read the value of
+	 // UseSharedSpaces which is same as hotspot type "bool".
          if (read_jboolean(ph, useSharedSpacesAddr, &useSharedSpaces) != true) {
             print_debug("can't read the value of 'UseSharedSpaces' flag\n");
             return false;
@@ -507,12 +507,12 @@
 }
 
 static bool core_get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id,
-                          struct user_regs_struct* regs) {
+                          struct reg* regs) {
    // for core we have cached the lwp regs from NOTE section
    thread_info* thr = ph->threads;
    while (thr) {
      if (thr->lwp_id == lwp_id) {
-       memcpy(regs, &thr->regs, sizeof(struct user_regs_struct));
+       memcpy(regs, &thr->regs, sizeof(struct reg));
        return true;
      }
      thr = thr->next;
@@ -520,11 +520,17 @@
    return false;
 }
 
+static bool core_get_lwp_info(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+   print_debug("core_get_lwp_info not implemented\n");
+   return false;
+}
+
 static ps_prochandle_ops core_ops = {
    .release=  core_release,
    .p_pread=  core_read_data,
    .p_pwrite= core_write_data,
-   .get_lwp_regs= core_get_lwp_regs
+   .get_lwp_regs= core_get_lwp_regs,
+   .get_lwp_info= core_get_lwp_info
 };
 
 // read regs and create thread from NT_PRSTATUS entries from core file
@@ -534,57 +540,62 @@
    prstatus_t* prstat = (prstatus_t*) buf;
    thread_info* newthr;
    print_debug("got integer regset for lwp %d\n", prstat->pr_pid);
+#ifdef __FreeBSD__
+   if((newthr = add_thread_info(ph, prstat->pr_pid)) == NULL)
+      return false;
+#else
    // we set pthread_t to -1 for core dump
    if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat->pr_pid)) == NULL)
       return false;
+#endif
 
    // copy regs
-   memcpy(&newthr->regs, prstat->pr_reg, sizeof(struct user_regs_struct));
+   memcpy(&newthr->regs, &prstat->pr_reg, sizeof(struct reg));
 
    if (is_debug()) {
       print_debug("integer regset\n");
 #ifdef i386
       // print the regset
-      print_debug("\teax = 0x%x\n", newthr->regs.eax);
-      print_debug("\tebx = 0x%x\n", newthr->regs.ebx);
-      print_debug("\tecx = 0x%x\n", newthr->regs.ecx);
-      print_debug("\tedx = 0x%x\n", newthr->regs.edx);
-      print_debug("\tesp = 0x%x\n", newthr->regs.esp);
-      print_debug("\tebp = 0x%x\n", newthr->regs.ebp);
-      print_debug("\tesi = 0x%x\n", newthr->regs.esi);
-      print_debug("\tedi = 0x%x\n", newthr->regs.edi);
-      print_debug("\teip = 0x%x\n", newthr->regs.eip);
+      print_debug("\teax = 0x%x\n", newthr->regs.r_eax);
+      print_debug("\tebx = 0x%x\n", newthr->regs.r_ebx);
+      print_debug("\tecx = 0x%x\n", newthr->regs.r_ecx);
+      print_debug("\tedx = 0x%x\n", newthr->regs.r_edx);
+      print_debug("\tesp = 0x%x\n", newthr->regs.r_esp);
+      print_debug("\tebp = 0x%x\n", newthr->regs.r_ebp);
+      print_debug("\tesi = 0x%x\n", newthr->regs.r_esi);
+      print_debug("\tedi = 0x%x\n", newthr->regs.r_edi);
+      print_debug("\teip = 0x%x\n", newthr->regs.r_eip);
 #endif
 
 #if defined(amd64) || defined(x86_64)
       // print the regset
-      print_debug("\tr15 = 0x%lx\n", newthr->regs.r15);
-      print_debug("\tr14 = 0x%lx\n", newthr->regs.r14);
-      print_debug("\tr13 = 0x%lx\n", newthr->regs.r13);
-      print_debug("\tr12 = 0x%lx\n", newthr->regs.r12);
-      print_debug("\trbp = 0x%lx\n", newthr->regs.rbp);
-      print_debug("\trbx = 0x%lx\n", newthr->regs.rbx);
-      print_debug("\tr11 = 0x%lx\n", newthr->regs.r11);
-      print_debug("\tr10 = 0x%lx\n", newthr->regs.r10);
-      print_debug("\tr9 = 0x%lx\n", newthr->regs.r9);
-      print_debug("\tr8 = 0x%lx\n", newthr->regs.r8);
-      print_debug("\trax = 0x%lx\n", newthr->regs.rax);
-      print_debug("\trcx = 0x%lx\n", newthr->regs.rcx);
-      print_debug("\trdx = 0x%lx\n", newthr->regs.rdx);
-      print_debug("\trsi = 0x%lx\n", newthr->regs.rsi);
-      print_debug("\trdi = 0x%lx\n", newthr->regs.rdi);
-      print_debug("\torig_rax = 0x%lx\n", newthr->regs.orig_rax);
-      print_debug("\trip = 0x%lx\n", newthr->regs.rip);
-      print_debug("\tcs = 0x%lx\n", newthr->regs.cs);
-      print_debug("\teflags = 0x%lx\n", newthr->regs.eflags);
-      print_debug("\trsp = 0x%lx\n", newthr->regs.rsp);
-      print_debug("\tss = 0x%lx\n", newthr->regs.ss);
-      print_debug("\tfs_base = 0x%lx\n", newthr->regs.fs_base);
-      print_debug("\tgs_base = 0x%lx\n", newthr->regs.gs_base);
-      print_debug("\tds = 0x%lx\n", newthr->regs.ds);
-      print_debug("\tes = 0x%lx\n", newthr->regs.es);
-      print_debug("\tfs = 0x%lx\n", newthr->regs.fs);
-      print_debug("\tgs = 0x%lx\n", newthr->regs.gs);
+      print_debug("\tr15 = 0x%lx\n", newthr->regs.r_r15);
+      print_debug("\tr14 = 0x%lx\n", newthr->regs.r_r14);
+      print_debug("\tr13 = 0x%lx\n", newthr->regs.r_r13);
+      print_debug("\tr12 = 0x%lx\n", newthr->regs.r_r12);
+      print_debug("\trbp = 0x%lx\n", newthr->regs.r_rbp);
+      print_debug("\trbx = 0x%lx\n", newthr->regs.r_rbx);
+      print_debug("\tr11 = 0x%lx\n", newthr->regs.r_r11);
+      print_debug("\tr10 = 0x%lx\n", newthr->regs.r_r10);
+      print_debug("\tr9 = 0x%lx\n", newthr->regs.r_r9);
+      print_debug("\tr8 = 0x%lx\n", newthr->regs.r_r8);
+      print_debug("\trax = 0x%lx\n", newthr->regs.r_rax);
+      print_debug("\trcx = 0x%lx\n", newthr->regs.r_rcx);
+      print_debug("\trdx = 0x%lx\n", newthr->regs.r_rdx);
+      print_debug("\trsi = 0x%lx\n", newthr->regs.r_rsi);
+      print_debug("\trdi = 0x%lx\n", newthr->regs.r_rdi);
+      //print_debug("\torig_rax = 0x%lx\n", newthr->regs.orig_rax);
+      print_debug("\trip = 0x%lx\n", newthr->regs.r_rip);
+      print_debug("\tcs = 0x%lx\n", newthr->regs.r_cs);
+      //print_debug("\teflags = 0x%lx\n", newthr->regs.eflags);
+      print_debug("\trsp = 0x%lx\n", newthr->regs.r_rsp);
+      print_debug("\tss = 0x%lx\n", newthr->regs.r_ss);
+      //print_debug("\tfs_base = 0x%lx\n", newthr->regs.fs_base);
+      //print_debug("\tgs_base = 0x%lx\n", newthr->regs.gs_base);
+      //print_debug("\tds = 0x%lx\n", newthr->regs.ds);
+      //print_debug("\tes = 0x%lx\n", newthr->regs.es);
+      //print_debug("\tfs = 0x%lx\n", newthr->regs.fs);
+      //print_debug("\tgs = 0x%lx\n", newthr->regs.gs);
 #endif
    }
 
@@ -656,7 +667,7 @@
     * contains a set of saved /proc structures), and PT_LOAD (which
     * represents a memory mapping from the process's address space).
     *
-    * Difference b/w Solaris PT_NOTE and Bsd PT_NOTE:
+    * Difference b/w Solaris PT_NOTE and BSD PT_NOTE:
     *
     *     In Solaris there are two PT_NOTE segments the first PT_NOTE (if present)
     *     contains /proc structs in the pre-2.6 unstructured /proc format. the last
@@ -666,10 +677,10 @@
     *     integer register set among other stuff. For each LWP, we have one lwpstatus
     *     entry that has integer regset for that LWP.
     *
-    *     Bsd threads are actually 'clone'd processes. To support core analysis
-    *     of "multithreaded" process, Bsd creates more than one pstatus (called
+    *     Linux threads are actually 'clone'd processes. To support core analysis
+    *     of "multithreaded" process, Linux creates more than one pstatus (called
     *     "prstatus") entry in PT_NOTE. Each prstatus entry has integer regset for one
-    *     "thread". Please refer to Bsd kernel src file 'fs/binfmt_elf.c', in particular
+    *     "thread". Please refer to Linux kernel src file 'fs/binfmt_elf.c', in particular
     *     function "elf_core_dump".
     */
 
@@ -725,7 +736,7 @@
    return false;
 }
 
-// process segments from interpreter (ld.so or ld-bsd.so)
+// process segments from interpreter (ld-elf.so.1)
 static bool read_interp_segments(struct ps_prochandle* ph) {
    ELF_EHDR interp_ehdr;
 
@@ -826,7 +837,7 @@
 
    dyn.d_tag = DT_NULL;
    while (dyn.d_tag != DT_DEBUG) {
-      if (ps_pdread(ph, (psaddr_t) addr, &dyn, sizeof(ELF_DYN)) != PS_OK) {
+      if (ps_pread(ph, (psaddr_t) addr, &dyn, sizeof(ELF_DYN)) != PS_OK) {
          print_debug("can't read debug info from _DYNAMIC\n");
          return false;
       }
@@ -836,23 +847,27 @@
    // we have got Dyn entry with DT_DEBUG
    debug_base = dyn.d_un.d_ptr;
    // at debug_base we have struct r_debug. This has first link map in r_map field
-   if (ps_pdread(ph, (psaddr_t) debug_base + FIRST_LINK_MAP_OFFSET,
+   if (ps_pread(ph, (psaddr_t) debug_base + FIRST_LINK_MAP_OFFSET,
                  &first_link_map_addr, sizeof(uintptr_t)) != PS_OK) {
       print_debug("can't read first link map address\n");
       return false;
    }
 
    // read ld_base address from struct r_debug
-   if (ps_pdread(ph, (psaddr_t) debug_base + LD_BASE_OFFSET, &ld_base_addr,
+   // XXX: There is no r_ldbase member on BSD
+/*
+   if (ps_pread(ph, (psaddr_t) debug_base + LD_BASE_OFFSET, &ld_base_addr,
                  sizeof(uintptr_t)) != PS_OK) {
       print_debug("can't read ld base address\n");
       return false;
    }
    ph->core->ld_base_addr = ld_base_addr;
+*/
+   ph->core->ld_base_addr = 0;
 
    print_debug("interpreter base address is 0x%lx\n", ld_base_addr);
 
-   // now read segments from interp (i.e ld.so or ld-bsd.so)
+   // now read segments from interp (i.e ld-elf.so.1)
    if (read_interp_segments(ph) != true)
       return false;
 
@@ -870,26 +885,23 @@
       // address mentioned in shared object and the actual virtual base where runtime
       // linker loaded it. We use "base diff" in read_lib_segments call below.
 
-      if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_ADDR_OFFSET,
+      if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_ADDR_OFFSET,
                    &lib_base_diff, sizeof(uintptr_t)) != PS_OK) {
          print_debug("can't read shared object base address diff\n");
          return false;
       }
 
       // read address of the name
-      if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_NAME_OFFSET,
+      if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_NAME_OFFSET,
                     &lib_name_addr, sizeof(uintptr_t)) != PS_OK) {
          print_debug("can't read address of shared object name\n");
          return false;
       }
 
       // read name of the shared object
-      lib_name[0] = '\0';
-      if (lib_name_addr != 0 &&
-          read_string(ph, (uintptr_t) lib_name_addr, lib_name, sizeof(lib_name)) != true) {
+      if (read_string(ph, (uintptr_t) lib_name_addr, lib_name, sizeof(lib_name)) != true) {
          print_debug("can't read shared object name\n");
-         // don't let failure to read the name stop opening the file.  If something is really wrong
-         // it will fail later.
+         return false;
       }
 
       if (lib_name[0] != '\0') {
@@ -924,7 +936,7 @@
       }
 
       // read next link_map address
-      if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_NEXT_OFFSET,
+      if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_NEXT_OFFSET,
                         &link_map_addr, sizeof(uintptr_t)) != PS_OK) {
          print_debug("can't read next link in link_map\n");
          return false;
@@ -938,7 +950,6 @@
 struct ps_prochandle* Pgrab_core(const char* exec_file, const char* core_file) {
    ELF_EHDR core_ehdr;
    ELF_EHDR exec_ehdr;
-   ELF_EHDR lib_ehdr;
 
    struct ps_prochandle* ph = (struct ps_prochandle*) calloc(1, sizeof(struct ps_prochandle));
    if (ph == NULL) {
--- hotspot/agent/src/os/bsd/ps_proc.c
+++ hotspot/agent/src/os/bsd/ps_proc.c
@@ -22,20 +22,22 @@
  *
  */
 
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 #include <sys/ptrace.h>
+#include <sys/param.h>
+#include <sys/user.h>
+#include <elf.h>
+#include <sys/elf_common.h>
+#include <sys/link_elf.h>
+#include <libutil.h>
 #include "libproc_impl.h"
-
-#if defined(x86_64) && !defined(amd64)
-#define amd64 1
-#endif
-
-#ifndef __WALL
-#define __WALL          0x40000000  // Copied from /usr/include/bsd/wait.h
-#endif
+#include "elfmacros.h"
 
 // This file has the libproc implementation specific to live process
 // For core files, refer to ps_core.c
@@ -50,253 +52,365 @@
 
 // read "size" bytes of data from "addr" within the target process.
 // unlike the standard ptrace() function, process_read_data() can handle
-// unaligned address - alignment check, if required, should be done
+// unaligned address - alignment check, if required, should be done 
 // before calling process_read_data.
 
 static bool process_read_data(struct ps_prochandle* ph, uintptr_t addr, char *buf, size_t size) {
-  long rslt;
+  int rslt;
   size_t i, words;
   uintptr_t end_addr = addr + size;
-  uintptr_t aligned_addr = align(addr, sizeof(long));
+  uintptr_t aligned_addr = align(addr, sizeof(int));
 
   if (aligned_addr != addr) {
     char *ptr = (char *)&rslt;
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
     for (; aligned_addr != addr; aligned_addr++, ptr++);
-    for (; ((intptr_t)aligned_addr % sizeof(long)) && aligned_addr < end_addr;
-        aligned_addr++)
+    for (; ((intptr_t)aligned_addr % sizeof(int)) && aligned_addr < end_addr; 
+        aligned_addr++) 
        *(buf++) = *(ptr++);
   }
 
-  words = (end_addr - aligned_addr) / sizeof(long);
+  words = (end_addr - aligned_addr) / sizeof(int);
 
-  // assert((intptr_t)aligned_addr % sizeof(long) == 0);
+  // assert((intptr_t)aligned_addr % sizeof(int) == 0);
   for (i = 0; i < words; i++) {
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
-    *(long *)buf = rslt;
-    buf += sizeof(long);
-    aligned_addr += sizeof(long);
+    *(int *)buf = rslt;
+    buf += sizeof(int);
+    aligned_addr += sizeof(int);
   }
 
   if (aligned_addr != end_addr) {
     char *ptr = (char *)&rslt;
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
-    for (; aligned_addr != end_addr; aligned_addr++)
+    for (; aligned_addr != end_addr; aligned_addr++) 
        *(buf++) = *(ptr++);
   }
   return true;
 }
 
 // null implementation for write
-static bool process_write_data(struct ps_prochandle* ph,
+static bool process_write_data(struct ps_prochandle* ph, 
                              uintptr_t addr, const char *buf , size_t size) {
   return false;
 }
 
-// "user" should be a pointer to a user_regs_struct
-static bool process_get_lwp_regs(struct ps_prochandle* ph, pid_t pid, struct user_regs_struct *user) {
+// "user" should be a pointer to a reg
+static bool process_get_lwp_regs(struct ps_prochandle* ph, pid_t pid, struct reg *user) {
   // we have already attached to all thread 'pid's, just use ptrace call
   // to get regset now. Note that we don't cache regset upfront for processes.
-// Bsd on x86 and sparc are different.  On x86 ptrace(PTRACE_GETREGS, ...)
-// uses pointer from 4th argument and ignores 3rd argument.  On sparc it uses
-// pointer from 3rd argument and ignores 4th argument
-#if defined(sparc) || defined(sparcv9)
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, addr, data)
-#else
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, data, addr)
-#endif
-
-#if defined(_LP64) && defined(PTRACE_GETREGS64)
-#define PTRACE_GETREGS_REQ PTRACE_GETREGS64
-#elif defined(PTRACE_GETREGS)
-#define PTRACE_GETREGS_REQ PTRACE_GETREGS
-#elif defined(PT_GETREGS)
-#define PTRACE_GETREGS_REQ PT_GETREGS
-#endif
-
-#ifdef PTRACE_GETREGS_REQ
- if (ptrace_getregs(PTRACE_GETREGS_REQ, pid, user, NULL) < 0) {
+ if (ptrace(PT_GETREGS, pid, (caddr_t) user, 0) < 0) {
    print_debug("ptrace(PTRACE_GETREGS, ...) failed for lwp %d\n", pid);
    return false;
  }
  return true;
-#else
- print_debug("ptrace(PTRACE_GETREGS, ...) not supported\n");
- return false;
-#endif
+}
+
+// fill in ptrace_lwpinfo for lid
+static bool process_get_lwp_info(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+  errno = 0;
+  ptrace(PT_LWPINFO, lwp_id, linfo, sizeof(struct ptrace_lwpinfo));
 
+  return (errno == 0)? true: false;
 }
 
 // attach to a process/thread specified by "pid"
 static bool ptrace_attach(pid_t pid) {
-  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {
+  if (ptrace(PT_ATTACH, pid, NULL, 0) < 0) {
     print_debug("ptrace(PTRACE_ATTACH, ..) failed for %d\n", pid);
     return false;
   } else {
     int ret;
     int status;
     do {
-      // Wait for debuggee to stop.
+      // Wait for debuggee to stop. 
       ret = waitpid(pid, &status, 0);
-      if (ret == -1 && errno == ECHILD) {
-        // try cloned process.
-        ret = waitpid(pid, &status, __WALL);
-      }
       if (ret >= 0) {
-        if (WIFSTOPPED(status)) {
-          // Debuggee stopped.
-          return true;
+	if (WIFSTOPPED(status)) {
+	  // Debuggee stopped.
+	  return true;
         } else {
-          print_debug("waitpid(): Child process exited/terminated (status = 0x%x)\n", status);
-          return false;
-        }
+    	  print_debug("waitpid(): Child process exited/terminated (status = 0x%x)\n", status);
+	  return false;
+	}
       } else {
-        switch (errno) {
-          case EINTR:
+	switch (errno) {
+	  case EINTR: 
             continue;
-            break;
-          case ECHILD:
-            print_debug("waitpid() failed. Child process pid (%d) does not exist \n", pid);
-            break;
-          case EINVAL:
-            print_debug("waitpid() failed. Invalid options argument.\n");
-            break;
-          default:
-            print_debug("waitpid() failed. Unexpected error %d\n",errno);
+	    break;
+	  case ECHILD:
+    	    print_debug("waitpid() failed. Child process pid (%d) does not exist \n", pid);
+	    break;
+	  case EINVAL:
+    	    print_debug("waitpid() failed. Invalid options argument.\n");
+	    break;
+	  default:
+    	    print_debug("waitpid() failed. Unexpected error %d\n",errno);
         }
         return false;
-      }
+      } 
     } while(true);
-  }
-}
-
+  } 
+} 
+  
 // -------------------------------------------------------
 // functions for obtaining library information
 // -------------------------------------------------------
 
-/*
- * splits a string _str_ into substrings with delimiter _delim_ by replacing old * delimiters with _new_delim_ (ideally, '\0'). the address of each substring
- * is stored in array _ptrs_ as the return value. the maximum capacity of _ptrs_ * array is specified by parameter _n_.
- * RETURN VALUE: total number of substrings (always <= _n_)
- * NOTE: string _str_ is modified if _delim_!=_new_delim_
- */
-static int split_n_str(char * str, int n, char ** ptrs, char delim, char new_delim)
-{
-   int i;
-   for(i = 0; i < n; i++) ptrs[i] = NULL;
-   if (str == NULL || n < 1 ) return 0;
-
-   i = 0;
-
-   // skipping leading blanks
-   while(*str&&*str==delim) str++;
-
-   while(*str&&i<n){
-     ptrs[i++] = str;
-     while(*str&&*str!=delim) str++;
-     while(*str&&*str==delim) *(str++) = new_delim;
-   }
-
-   return i;
+// callback for read_thread_info
+#ifdef __FreeBSD__
+static bool add_new_thread(struct ps_prochandle* ph, lwpid_t lwp_id) {
+  return add_thread_info(ph, lwp_id) != NULL;
+}
+#else
+static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
+  return add_thread_info(ph, pthread_id, lwp_id) != NULL;
 }
+#endif
 
+#if defined(__FreeBSD__) && __FreeBSD_version < 701000
 /*
- * fgets without storing '\n' at the end of the string
+ * TEXT_START_ADDR from binutils/ld/emulparams/<arch_spec>.sh
+ * Not the most robust but good enough.
  */
-static char * fgets_no_cr(char * buf, int n, FILE *fp)
-{
-   char * rslt = fgets(buf, n, fp);
-   if (rslt && buf && *buf){
-       char *p = strchr(buf, '\0');
-       if (*--p=='\n') *p='\0';
-   }
-   return rslt;
-}
 
-// callback for read_thread_info
-static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
-  return add_thread_info(ph, pthread_id, lwp_id) != NULL;
+#if defined(amd64) || defined(x86_64)
+#define TEXT_START_ADDR 0x400000
+#elif defined(i386)
+#define TEXT_START_ADDR 0x8048000
+#else
+#error TEXT_START_ADDR not defined
+#endif
+
+#define BUF_SIZE (PATH_MAX + NAME_MAX + 1)
+
+uintptr_t linkmap_addr(struct ps_prochandle *ph) {
+  uintptr_t ehdr_addr, phdr_addr, dyn_addr, dmap_addr, lmap_addr;
+  ELF_EHDR ehdr;
+  ELF_PHDR *phdrs, *phdr;
+  ELF_DYN *dyns, *dyn;
+  struct r_debug dmap;
+  unsigned long hdrs_size;
+  unsigned int i;
+
+  /* read ELF_EHDR at TEXT_START_ADDR and validate */
+
+  ehdr_addr = (uintptr_t)TEXT_START_ADDR;
+
+  if (process_read_data(ph, ehdr_addr, (char *)&ehdr, sizeof(ehdr)) != true) {
+    print_debug("process_read_data failed for ehdr_addr %p\n", ehdr_addr);
+    return (0);
+  }
+
+  if (!IS_ELF(ehdr) ||
+        ehdr.e_ident[EI_CLASS] != ELF_TARG_CLASS ||
+        ehdr.e_ident[EI_DATA] != ELF_TARG_DATA ||
+        ehdr.e_ident[EI_VERSION] != EV_CURRENT ||
+        ehdr.e_phentsize != sizeof(ELF_PHDR) ||
+        ehdr.e_version != ELF_TARG_VER ||
+        ehdr.e_machine != ELF_TARG_MACH) {
+    print_debug("not an ELF_EHDR at %p\n", ehdr_addr);
+    return (0);
+  }
+
+  /* allocate space for all ELF_PHDR's and read */
+
+  phdr_addr = ehdr_addr + ehdr.e_phoff;
+  hdrs_size = ehdr.e_phnum * sizeof(ELF_PHDR);
+
+  if ((phdrs = malloc(hdrs_size)) == NULL)
+    return (0);
+
+  if (process_read_data(ph, phdr_addr, (char *)phdrs, hdrs_size) != true) {
+    print_debug("process_read_data failed for phdr_addr %p\n", phdr_addr);
+    return (0);
+  }
+
+  /* find PT_DYNAMIC section */
+
+  for (i = 0, phdr = phdrs; i < ehdr.e_phnum; i++, phdr++) {
+    if (phdr->p_type == PT_DYNAMIC)
+      break;
+  }
+
+  if (i >= ehdr.e_phnum) {
+    print_debug("PT_DYNAMIC section not found!\n");
+    free(phdrs);
+    return (0);
+  }
+
+  /* allocate space and read in ELF_DYN headers */
+
+  dyn_addr = phdr->p_vaddr;
+  hdrs_size = phdr->p_memsz;
+  free(phdrs);
+
+  if ((dyns = malloc(hdrs_size)) == NULL)
+    return (0);
+
+  if (process_read_data(ph, dyn_addr, (char *)dyns, hdrs_size) != true) {
+    print_debug("process_read_data failed for dyn_addr %p\n", dyn_addr);
+    free(dyns);
+    return (0);
+  }
+
+  /* find DT_DEBUG */
+  
+  dyn = dyns;
+  while (dyn->d_tag != DT_DEBUG && dyn->d_tag != DT_NULL) {
+    dyn++;
+  }
+
+  if (dyn->d_tag != DT_DEBUG) {
+    print_debug("failed to find DT_DEBUG\n");
+    free(dyns);
+    return (0);
+  }
+
+  /* read struct r_debug into dmap */
+
+  dmap_addr = (uintptr_t)dyn->d_un.d_ptr;
+  free(dyns);
+
+  if (process_read_data(ph, dmap_addr, (char *)&dmap, sizeof(dmap)) != true) {
+    print_debug("process_read_data failed for dmap_addr %p\n", dmap_addr);
+    return (0);
+  }
+
+  lmap_addr = (uintptr_t)dmap.r_map;
+
+  return (lmap_addr);
 }
+#endif // __FreeBSD__ && __FreeBSD_version < 701000
 
 static bool read_lib_info(struct ps_prochandle* ph) {
-  char fname[32];
-  char buf[256];
-  FILE *fp = NULL;
-
-  sprintf(fname, "/proc/%d/maps", ph->pid);
-  fp = fopen(fname, "r");
-  if (fp == NULL) {
-    print_debug("can't open /proc/%d/maps file\n", ph->pid);
-    return false;
+#if defined(__FreeBSD__) && __FreeBSD_version >= 701000
+  struct kinfo_vmentry *freep, *kve;
+  int i, cnt;
+
+  freep = kinfo_getvmmap(ph->pid, &cnt);
+  if (freep == NULL) {
+      print_debug("can't get vm map for pid\n", ph->pid);
+      return false;
   }
 
-  while(fgets_no_cr(buf, 256, fp)){
-    char * word[6];
-    int nwords = split_n_str(buf, 6, word, ' ', '\0');
-    if (nwords > 5 && find_lib(ph, word[5]) == false) {
-       intptr_t base;
-       lib_info* lib;
-#ifdef _LP64
-       sscanf(word[0], "%lx", &base);
-#else
-       sscanf(word[0], "%x", &base);
-#endif
-       if ((lib = add_lib_info(ph, word[5], (uintptr_t)base)) == NULL)
+  for (i = 0; i < cnt; i++) {
+    kve = &freep[i];
+    if ((kve->kve_flags & KVME_FLAG_COW) &&
+        kve->kve_path != NULL &&
+        strlen(kve->kve_path) > 0) {
+
+      if (find_lib(ph, kve->kve_path) == false) {
+        lib_info* lib;
+        if ((lib = add_lib_info(ph, kve->kve_path,
+                                (uintptr_t) kve->kve_start)) == NULL)
           continue; // ignore, add_lib_info prints error
 
-       // we don't need to keep the library open, symtab is already
-       // built. Only for core dump we need to keep the fd open.
-       close(lib->fd);
-       lib->fd = -1;
+        // we don't need to keep the library open, symtab is already
+        // built. Only for core dump we need to keep the fd open.
+        close(lib->fd);
+        lib->fd = -1;
+      }
     }
   }
-  fclose(fp);
+
+  free(freep);
+
+  return true;
+#else
+  char *l_name;
+  struct link_map *lmap;
+  uintptr_t lmap_addr;
+
+  if ((l_name = malloc(BUF_SIZE)) == NULL)
+    return false;
+
+  if ((lmap = malloc(sizeof(*lmap))) == NULL) {
+    free(l_name);
+    return false;
+  }
+
+  lmap_addr = linkmap_addr(ph);
+
+  if (lmap_addr == 0) {
+    free(l_name);
+    free(lmap);
+    return false;
+  }
+
+  do {
+    if (process_read_data(ph, lmap_addr, (char *)lmap, sizeof(*lmap)) != true) {
+      print_debug("process_read_data failed for lmap_addr %p\n", lmap_addr);
+      free (l_name);
+      free (lmap);
+      return false;
+    }
+
+    if (process_read_data(ph, (uintptr_t)lmap->l_name, l_name,
+        BUF_SIZE) != true) {
+      print_debug("process_read_data failed for lmap->l_name %p\n",
+          lmap->l_name);
+      free (l_name);
+      free (lmap);
+      return false;
+    }
+
+    if (find_lib(ph, l_name) == false) {
+      lib_info* lib;
+      if ((lib = add_lib_info(ph, l_name,
+                              (uintptr_t) lmap->l_addr)) == NULL)
+        continue; // ignore, add_lib_info prints error
+
+      // we don't need to keep the library open, symtab is already
+      // built. Only for core dump we need to keep the fd open.
+      close(lib->fd);
+      lib->fd = -1;
+    }
+    lmap_addr = (uintptr_t)lmap->l_next;
+  } while (lmap->l_next != NULL);
+
+  free (l_name);
+  free (lmap);
+
   return true;
+#endif
 }
 
 // detach a given pid
 static bool ptrace_detach(pid_t pid) {
-  if (pid && ptrace(PTRACE_DETACH, pid, NULL, NULL) < 0) {
+  if (pid && ptrace(PT_DETACH, pid, (caddr_t)1, 0) < 0) {
     print_debug("ptrace(PTRACE_DETACH, ..) failed for %d\n", pid);
     return false;
   } else {
     return true;
-  }
-}
-
-// detach all pids of a ps_prochandle
-static void detach_all_pids(struct ps_prochandle* ph) {
-  thread_info* thr = ph->threads;
-  while (thr) {
-     ptrace_detach(thr->lwp_id);
-     thr = thr->next;
-  }
+  } 
 }
 
 static void process_cleanup(struct ps_prochandle* ph) {
-  detach_all_pids(ph);
+  ptrace_detach(ph->pid);
 }
 
 static ps_prochandle_ops process_ops = {
   .release=  process_cleanup,
   .p_pread=  process_read_data,
   .p_pwrite= process_write_data,
-  .get_lwp_regs= process_get_lwp_regs
+  .get_lwp_regs= process_get_lwp_regs,
+  .get_lwp_info= process_get_lwp_info
 };
 
 // attach to the process. One and only one exposed stuff
@@ -323,21 +437,14 @@
   // read library info and symbol tables, must do this before attaching threads,
   // as the symbols in the pthread library will be used to figure out
   // the list of threads within the same process.
-  read_lib_info(ph);
-
+  if (read_lib_info(ph) != true) {
+     ptrace_detach(pid);
+     free(ph);
+     return NULL;
+  }
+ 
   // read thread info
   read_thread_info(ph, add_new_thread);
 
-  // attach to the threads
-  thr = ph->threads;
-  while (thr) {
-     // don't attach to the main thread again
-     if (ph->pid != thr->lwp_id && ptrace_attach(thr->lwp_id) != true) {
-        // even if one attach fails, we get return NULL
-        Prelease(ph);
-        return NULL;
-     }
-     thr = thr->next;
-  }
   return ph;
 }
--- hotspot/agent/src/os/bsd/salibelf.c
+++ hotspot/agent/src/os/bsd/salibelf.c
@@ -25,6 +25,7 @@
 #include "salibelf.h"
 #include <stdlib.h>
 #include <unistd.h>
+#include <string.h>
 
 extern void print_debug(const char*,...);
 
--- hotspot/agent/src/os/bsd/symtab.c
+++ hotspot/agent/src/os/bsd/symtab.c
@@ -23,10 +23,11 @@
  */
 
 #include <unistd.h>
-#include <sys/procfs.h>
 #include <search.h>
 #include <stdlib.h>
 #include <string.h>
+#include <db.h>
+#include <fcntl.h>
 #include "symtab.h"
 #include "salibelf.h"
 
@@ -50,279 +51,12 @@
   char *strs;
   size_t num_symbols;
   struct elf_symbol *symbols;
-  struct hsearch_data *hash_table;
+  DB* hash_table;
 } symtab_t;
 
-
-// Directory that contains global debuginfo files.  In theory it
-// should be possible to change this, but in a Java environment there
-// is no obvious place to put a user interface to do it.  Maybe this
-// could be set with an environment variable.
-static const char debug_file_directory[] = "/usr/lib/debug";
-
-/* The CRC used in gnu_debuglink, retrieved from
-   http://sourceware.org/gdb/current/onlinedocs/gdb/Separate-Debug-Files.html#Separate-Debug-Files. */
-unsigned int gnu_debuglink_crc32 (unsigned int crc,
-                                  unsigned char *buf, size_t len)
-{
-  static const unsigned int crc32_table[256] =
-    {
-      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
-      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
-      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
-      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
-      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
-      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
-      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
-      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
-      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
-      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
-      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
-      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
-      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
-      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
-      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
-      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
-      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
-      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
-      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
-      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
-      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
-      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
-      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
-      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
-      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
-      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
-      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
-      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
-      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
-      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
-      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
-      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
-      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
-      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
-      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
-      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
-      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
-      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
-      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
-      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
-      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
-      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
-      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
-      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
-      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
-      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
-      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
-      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
-      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
-      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
-      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
-      0x2d02ef8d
-    };
-  unsigned char *end;
-
-  crc = ~crc & 0xffffffff;
-  for (end = buf + len; buf < end; ++buf)
-    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
-  return ~crc & 0xffffffff;
-}
-
-/* Open a debuginfo file and check its CRC.  If it exists and the CRC
-   matches return its fd.  */
-static int
-open_debug_file (const char *pathname, unsigned int crc)
-{
-  unsigned int file_crc = 0;
-  unsigned char buffer[8 * 1024];
-
-  int fd = pathmap_open(pathname);
-
-  if (fd < 0)
-    return -1;
-
-  lseek(fd, 0, SEEK_SET);
-
-  for (;;) {
-    int len = read(fd, buffer, sizeof buffer);
-    if (len <= 0)
-      break;
-    file_crc = gnu_debuglink_crc32(file_crc, buffer, len);
-  }
-
-  if (crc == file_crc)
-    return fd;
-  else {
-    close(fd);
-    return -1;
-  }
-}
-
-/* Find an ELF section.  */
-static struct elf_section *find_section_by_name(char *name,
-                                                int fd,
-                                                ELF_EHDR *ehdr,
-                                                ELF_SHDR *shbuf,
-                                                struct elf_section *scn_cache)
-{
-  ELF_SHDR* cursct = NULL;
-  char *strtab;
-  int cnt;
-
-  if (scn_cache[ehdr->e_shstrndx].c_data == NULL) {
-    if ((scn_cache[ehdr->e_shstrndx].c_data
-         = read_section_data(fd, ehdr, cursct)) == NULL) {
-      return NULL;
-    }
-  }
-
-  strtab = scn_cache[ehdr->e_shstrndx].c_data;
-
-  for (cursct = shbuf, cnt = 0;
-       cnt < ehdr->e_shnum;
-       cnt++, cursct++) {
-    if (strcmp(cursct->sh_name + strtab, name) == 0) {
-      scn_cache[cnt].c_data = read_section_data(fd, ehdr, cursct);
-      return &scn_cache[cnt];
-    }
-  }
-
-  return NULL;
-}
-
-/* Look for a ".gnu_debuglink" section.  If one exists, try to open a
-   suitable debuginfo file.  */
-static int open_file_from_debug_link(const char *name,
-                                     int fd,
-                                     ELF_EHDR *ehdr,
-                                     ELF_SHDR *shbuf,
-                                     struct elf_section *scn_cache)
-{
-  int debug_fd;
-  struct elf_section *debug_link = find_section_by_name(".gnu_debuglink", fd, ehdr,
-                                                        shbuf, scn_cache);
-  if (debug_link == NULL)
-    return -1;
-  char *debug_filename = debug_link->c_data;
-  int offset = (strlen(debug_filename) + 4) >> 2;
-  static unsigned int crc;
-  crc = ((unsigned int*)debug_link->c_data)[offset];
-  char *debug_pathname = malloc(strlen(debug_filename)
-                                + strlen(name)
-                                + strlen(".debug/")
-                                + strlen(debug_file_directory)
-                                + 2);
-  strcpy(debug_pathname, name);
-  char *last_slash = strrchr(debug_pathname, '/');
-  if (last_slash == NULL)
-    return -1;
-
-  /* Look in the same directory as the object.  */
-  strcpy(last_slash+1, debug_filename);
-
-  debug_fd = open_debug_file(debug_pathname, crc);
-  if (debug_fd >= 0) {
-    free(debug_pathname);
-    return debug_fd;
-  }
-
-  /* Look in a subdirectory named ".debug".  */
-  strcpy(last_slash+1, ".debug/");
-  strcat(last_slash, debug_filename);
-
-  debug_fd = open_debug_file(debug_pathname, crc);
-  if (debug_fd >= 0) {
-    free(debug_pathname);
-    return debug_fd;
-  }
-
-  /* Look in /usr/lib/debug + the full pathname.  */
-  strcpy(debug_pathname, debug_file_directory);
-  strcat(debug_pathname, name);
-  last_slash = strrchr(debug_pathname, '/');
-  strcpy(last_slash+1, debug_filename);
-
-  debug_fd = open_debug_file(debug_pathname, crc);
-  if (debug_fd >= 0) {
-    free(debug_pathname);
-    return debug_fd;
-  }
-
-  free(debug_pathname);
-  return -1;
-}
-
-static struct symtab* build_symtab_internal(int fd, const char *filename, bool try_debuginfo);
-
-/* Look for a ".gnu_debuglink" section.  If one exists, try to open a
-   suitable debuginfo file and read a symbol table from it.  */
-static struct symtab *build_symtab_from_debug_link(const char *name,
-                                     int fd,
-                                     ELF_EHDR *ehdr,
-                                     ELF_SHDR *shbuf,
-                                     struct elf_section *scn_cache)
-{
-  fd = open_file_from_debug_link(name, fd, ehdr, shbuf, scn_cache);
-
-  if (fd >= 0) {
-    struct symtab *symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
-    close(fd);
-    return symtab;
-  }
-
-  return NULL;
-}
-
-// Given a build_id, find the associated debuginfo file
-static char *
-build_id_to_debug_filename (size_t size, unsigned char *data)
-{
-  char *filename, *s;
-
-  filename = malloc(strlen (debug_file_directory) + (sizeof "/.build-id/" - 1) + 1
-                    + 2 * size + (sizeof ".debug" - 1) + 1);
-  s = filename + sprintf (filename, "%s/.build-id/", debug_file_directory);
-  if (size > 0)
-    {
-      size--;
-      s += sprintf (s, "%02x", *data++);
-    }
-  if (size > 0)
-    *s++ = '/';
-  while (size-- > 0)
-    s += sprintf (s, "%02x", *data++);
-  strcpy (s, ".debug");
-
-  return filename;
-}
-
-// Read a build ID note.  Try to open any associated debuginfo file
-// and return its symtab
-static struct symtab* build_symtab_from_build_id(Elf64_Nhdr *note)
-{
-  int fd;
-  struct symtab *symtab = NULL;
-
-  unsigned char *bytes
-    = (unsigned char*)(note+1) + note->n_namesz;
-  unsigned char *filename
-    = (build_id_to_debug_filename (note->n_descsz, bytes));
-
-  fd = pathmap_open(filename);
-  if (fd >= 0) {
-    symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
-    close(fd);
-  }
-  free(filename);
-
-  return symtab;
-}
-
-// read symbol table from given fd.  If try_debuginfo) is true, also
-// try to open an associated debuginfo file
-static struct symtab* build_symtab_internal(int fd, const char *filename, bool try_debuginfo) {
+// read symbol table from given fd.
+struct symtab* build_symtab(int fd) {
   ELF_EHDR ehdr;
-  char *names = NULL;
   struct symtab* symtab = NULL;
 
   // Reading of elf header
@@ -331,8 +65,9 @@
   ELF_SHDR* shbuf = NULL;
   ELF_SHDR* cursct = NULL;
   ELF_PHDR* phbuf = NULL;
-  ELF_PHDR* phdr = NULL;
-  int sym_section = SHT_DYNSYM;
+  int symtab_found = 0;
+  int dynsym_found = 0;
+  uint32_t symsection = SHT_SYMTAB;
 
   uintptr_t baseaddr = (uintptr_t)-1;
 
@@ -349,33 +84,39 @@
 
   baseaddr = find_base_address(fd, &ehdr);
 
-  scn_cache = (struct elf_section *)
-              calloc(ehdr.e_shnum * sizeof(struct elf_section), 1);
+  scn_cache = calloc(ehdr.e_shnum, sizeof(*scn_cache));
   if (scn_cache == NULL) {
     goto quit;
   }
 
   for (cursct = shbuf, cnt = 0; cnt < ehdr.e_shnum; cnt++) {
     scn_cache[cnt].c_shdr = cursct;
-    if (cursct->sh_type == SHT_SYMTAB || cursct->sh_type == SHT_STRTAB
-        || cursct->sh_type == SHT_NOTE || cursct->sh_type == SHT_DYNSYM) {
-      if ( (scn_cache[cnt].c_data = read_section_data(fd, &ehdr, cursct)) == NULL) {
+    if (cursct->sh_type == SHT_SYMTAB ||
+        cursct->sh_type == SHT_STRTAB ||
+        cursct->sh_type == SHT_DYNSYM) {
+      if ((scn_cache[cnt].c_data = read_section_data(fd, &ehdr, cursct)) == NULL) {
          goto quit;
       }
     }
-    if (cursct->sh_type == SHT_SYMTAB) {
-      // Full symbol table available so use that
-      sym_section = cursct->sh_type;
-    }
+
+    if (cursct->sh_type == SHT_SYMTAB)
+       symtab_found++;
+
+    if (cursct->sh_type == SHT_DYNSYM)
+       dynsym_found++;
+
     cursct++;
   }
 
+  if (!symtab_found && dynsym_found)
+     symsection = SHT_DYNSYM;
+
   for (cnt = 1; cnt < ehdr.e_shnum; cnt++) {
     ELF_SHDR *shdr = scn_cache[cnt].c_shdr;
 
-    if (shdr->sh_type == sym_section) {
+    if (shdr->sh_type == symsection) {
       ELF_SYM  *syms;
-      int j, n, rslt;
+      int j, n;
       size_t size;
 
       // FIXME: there could be multiple data buffers associated with the
@@ -383,7 +124,7 @@
       // for elf_getdata on Solaris.
 
       // guarantee(symtab == NULL, "multiple symtab");
-      symtab = (struct symtab*)calloc(1, sizeof(struct symtab));
+      symtab = calloc(1, sizeof(*symtab));
       if (symtab == NULL) {
          goto quit;
       }
@@ -393,27 +134,32 @@
       // number of symbols
       n = shdr->sh_size / shdr->sh_entsize;
 
-      // create hash table, we use hcreate_r, hsearch_r and hdestroy_r to
+      // create hash table, we use berkeley db to
       // manipulate the hash table.
-      symtab->hash_table = (struct hsearch_data*) calloc(1, sizeof(struct hsearch_data));
-      rslt = hcreate_r(n, symtab->hash_table);
-      // guarantee(rslt, "unexpected failure: hcreate_r");
+      symtab->hash_table = dbopen(NULL, O_CREAT | O_RDWR, 0600, DB_HASH, NULL);
+      // guarantee(symtab->hash_table, "unexpected failure: dbopen");
+      if (symtab->hash_table == NULL)
+	goto bad;
 
       // shdr->sh_link points to the section that contains the actual strings
       // for symbol names. the st_name field in ELF_SYM is just the
       // string table index. we make a copy of the string table so the
       // strings will not be destroyed by elf_end.
       size = scn_cache[shdr->sh_link].c_shdr->sh_size;
-      symtab->strs = (char *)malloc(size);
+      symtab->strs = malloc(size);
+      if (symtab->strs == NULL)
+	goto bad;
       memcpy(symtab->strs, scn_cache[shdr->sh_link].c_data, size);
 
       // allocate memory for storing symbol offset and size;
       symtab->num_symbols = n;
-      symtab->symbols = (struct elf_symbol *)calloc(n , sizeof(struct elf_symbol));
+      symtab->symbols = calloc(n , sizeof(*symtab->symbols));
+      if (symtab->symbols == NULL)
+	goto bad;
 
       // copy symbols info our symtab and enter them info the hash table
       for (j = 0; j < n; j++, syms++) {
-        ENTRY item, *ret;
+        DBT key, value;
         char *sym_name = symtab->strs + syms->st_name;
 
         // skip non-object and non-function symbols
@@ -427,52 +173,19 @@
         symtab->symbols[j].offset = syms->st_value - baseaddr;
         symtab->symbols[j].size   = syms->st_size;
 
-        item.key = sym_name;
-        item.data = (void *)&(symtab->symbols[j]);
-
-        hsearch_r(item, ENTER, &ret, symtab->hash_table);
+        key.data = sym_name;
+        key.size = strlen(sym_name) + 1;
+        value.data = &(symtab->symbols[j]);
+        value.size = sizeof(void *);
+        (*symtab->hash_table->put)(symtab->hash_table, &key, &value, 0);
       }
     }
   }
+  goto quit;
 
-  // Look for a separate debuginfo file.
-  if (try_debuginfo) {
-
-    // We prefer a debug symtab to an object's own symtab, so look in
-    // the debuginfo file.  We stash a copy of the old symtab in case
-    // there is no debuginfo.
-    struct symtab* prev_symtab = symtab;
-    symtab = NULL;
-
-#ifdef NT_GNU_BUILD_ID
-    // First we look for a Build ID
-    for (cursct = shbuf, cnt = 0;
-         symtab == NULL && cnt < ehdr.e_shnum;
-         cnt++) {
-      if (cursct->sh_type == SHT_NOTE) {
-        Elf64_Nhdr *note = (Elf64_Nhdr *)scn_cache[cnt].c_data;
-        if (note->n_type == NT_GNU_BUILD_ID) {
-          symtab = build_symtab_from_build_id(note);
-        }
-      }
-      cursct++;
-    }
-#endif
-
-    // Then, if that doesn't work, the debug link
-    if (symtab == NULL) {
-      symtab = build_symtab_from_debug_link(filename, fd, &ehdr, shbuf,
-                                            scn_cache);
-    }
-
-    // If we still haven't found a symtab, use the object's own symtab.
-    if (symtab != NULL) {
-      if (prev_symtab != NULL)
-        destroy_symtab(prev_symtab);
-    } else {
-      symtab = prev_symtab;
-    }
-  }
+bad:
+  destroy_symtab(symtab);
+  symtab = NULL;
 
 quit:
   if (shbuf) free(shbuf);
@@ -488,44 +201,36 @@
   return symtab;
 }
 
-struct symtab* build_symtab(int fd, const char *filename) {
-  return build_symtab_internal(fd, filename, /* try_debuginfo */ true);
-}
-
-
 void destroy_symtab(struct symtab* symtab) {
   if (!symtab) return;
   if (symtab->strs) free(symtab->strs);
   if (symtab->symbols) free(symtab->symbols);
   if (symtab->hash_table) {
-     hdestroy_r(symtab->hash_table);
-     free(symtab->hash_table);
+    (*symtab->hash_table->close)(symtab->hash_table);
   }
   free(symtab);
 }
 
 uintptr_t search_symbol(struct symtab* symtab, uintptr_t base,
                       const char *sym_name, int *sym_size) {
-  ENTRY item;
-  ENTRY* ret = NULL;
+  DBT key, value;
+  int ret;
 
   // library does not have symbol table
   if (!symtab || !symtab->hash_table)
-     return (uintptr_t)NULL;
+     return 0;
 
-  item.key = (char*) strdup(sym_name);
-  hsearch_r(item, FIND, &ret, symtab->hash_table);
-  if (ret) {
-    struct elf_symbol * sym = (struct elf_symbol *)(ret->data);
+  key.data = (char*)(uintptr_t)sym_name;
+  key.size = strlen(sym_name) + 1;
+  ret = (*symtab->hash_table->get)(symtab->hash_table, &key, &value, 0);
+  if (ret == 0) {
+    struct elf_symbol *sym = value.data;
     uintptr_t rslt = (uintptr_t) ((char*)base + sym->offset);
     if (sym_size) *sym_size = sym->size;
-    free(item.key);
     return rslt;
   }
 
-quit:
-  free(item.key);
-  return (uintptr_t) NULL;
+  return 0;
 }
 
 const char* nearest_symbol(struct symtab* symtab, uintptr_t offset,
@@ -533,12 +238,12 @@
   int n = 0;
   if (!symtab) return NULL;
   for (; n < symtab->num_symbols; n++) {
-     struct elf_symbol* sym = &(symtab->symbols[n]);
-     if (sym->name != NULL &&
-         offset >= sym->offset && offset < sym->offset + sym->size) {
-        if (poffset) *poffset = (offset - sym->offset);
-        return sym->name;
-     }
+    struct elf_symbol* sym = &symtab->symbols[n];
+    if (sym->name != NULL &&
+      offset >= sym->offset && offset < sym->offset + sym->size) {
+      if (poffset) *poffset = (offset - sym->offset);
+      return sym->name;
+    }
   }
   return NULL;
 }
--- hotspot/agent/src/os/bsd/symtab.h
+++ hotspot/agent/src/os/bsd/symtab.h
@@ -32,7 +32,7 @@
 struct symtab;
 
 // build symbol table for a given ELF file descriptor
-struct symtab* build_symtab(int fd, const char *filename);
+struct symtab* build_symtab(int fd);
 
 // destroy the symbol table
 void destroy_symtab(struct symtab* symtab);
--- hotspot/agent/src/os/bsd/test.c
+++ hotspot/agent/src/os/bsd/test.c
@@ -44,7 +44,7 @@
       }
 
       default: {
-        printf("usage %s <pid> or %s <exec file> <core file>\n");
+        fprintf(stderr, "usage %s <pid> or %s <exec file> <core file>\n", argv[0], argv[0]);
         return 1;
       }
    }
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java
@@ -28,6 +28,7 @@
 import java.net.*;
 import java.rmi.*;
 import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.bsd.*;
 import sun.jvm.hotspot.debugger.dbx.*;
 import sun.jvm.hotspot.debugger.proc.*;
 import sun.jvm.hotspot.debugger.remote.*;
@@ -337,6 +338,8 @@
                 setupDebuggerWin32();
             } else if (os.equals("linux")) {
                 setupDebuggerLinux();
+            } else if (os.equals("bsd")) {
+                setupDebuggerBsd();
             } else {
                 // Add support for more operating systems here
                 throw new DebuggerException("Operating system " + os + " not yet supported");
@@ -392,6 +395,10 @@
                 db = new HotSpotTypeDataBase(machDesc,
                 new LinuxVtblAccess(debugger, jvmLibNames),
                 debugger, jvmLibNames);
+            } else if (os.equals("bsd")) {
+                db = new HotSpotTypeDataBase(machDesc,
+                new BsdVtblAccess(debugger, jvmLibNames),
+                debugger, jvmLibNames);
             } else {
                 throw new DebuggerException("OS \"" + os + "\" not yet supported (no VtblAccess yet)");
             }
@@ -557,6 +564,8 @@
             setupJVMLibNamesWin32();
         } else if (os.equals("linux")) {
             setupJVMLibNamesLinux();
+        } else if (os.equals("bsd")) {
+            setupJVMLibNamesBsd();
         } else {
             throw new RuntimeException("Unknown OS type");
         }
@@ -638,6 +647,31 @@
         jvmLibNames = new String[] { "libjvm.so", "libjvm_g.so" };
     }
 
+    //
+    // BSD
+    //
+
+    private void setupDebuggerBsd() {
+        setupJVMLibNamesBsd();
+
+        if (cpu.equals("x86")) {
+            machDesc = new MachineDescriptionIntelX86();
+        } else if (cpu.equals("amd64")) {
+            machDesc = new MachineDescriptionAMD64();
+        } else {
+            throw new DebuggerException("BSD only supported on x86/amd64");
+        }
+
+        BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);
+        debugger = dbg;
+
+        attachDebugger();
+    }
+
+    private void setupJVMLibNamesBsd() {
+        jvmLibNames = new String[] { "libjvm.so", "libjvm_g.so" };
+    }
+
     /** Convenience routine which should be called by per-platform
       debugger setup. Should not be called when startupMode is
       REMOTE_MODE. */
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/bugspot/BugSpotAgent.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/bugspot/BugSpotAgent.java
@@ -29,6 +29,7 @@
 import java.rmi.*;
 import sun.jvm.hotspot.*;
 import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.bsd.*;
 import sun.jvm.hotspot.debugger.dbx.*;
 import sun.jvm.hotspot.debugger.proc.*;
 import sun.jvm.hotspot.debugger.cdbg.*;
@@ -516,6 +517,8 @@
                 setupDebuggerWin32();
             } else if (os.equals("linux")) {
                 setupDebuggerLinux();
+            } else if (os.equals("bsd")) {
+                setupDebuggerBsd();
             } else {
                 // Add support for more operating systems here
                 throw new DebuggerException("Operating system " + os + " not yet supported");
@@ -567,6 +570,9 @@
             } else if (os.equals("linux")) {
                 db = new HotSpotTypeDataBase(machDesc, new LinuxVtblAccess(debugger, jvmLibNames),
                 debugger, jvmLibNames);
+            } else if (os.equals("bsd")) {
+                db = new HotSpotTypeDataBase(machDesc, new BsdVtblAccess(debugger, jvmLibNames),
+                debugger, jvmLibNames);
             } else {
                 throw new DebuggerException("OS \"" + os + "\" not yet supported (no VtblAccess implemented yet)");
             }
@@ -739,6 +745,8 @@
             setupJVMLibNamesWin32();
         } else if (os.equals("linux")) {
             setupJVMLibNamesLinux();
+        } else if (os.equals("bsd")) {
+            setupJVMLibNamesBsd();
         } else {
             throw new RuntimeException("Unknown OS type");
         }
@@ -822,6 +830,34 @@
         setupJVMLibNamesSolaris();
     }
 
+    //
+    // BSD
+    //
+
+    private void setupDebuggerBsd() {
+        setupJVMLibNamesBsd();
+
+        if (cpu.equals("x86")) {
+            machDesc = new MachineDescriptionIntelX86();
+        } else if (cpu.equals("amd64")) {
+            machDesc = new MachineDescriptionAMD64();
+        } else {
+            throw new DebuggerException("BSD only supported on x86/amd64");
+        }
+
+        // Note we do not use a cache for the local debugger in server
+        // mode; it will be taken care of on the client side (once remote
+        // debugging is implemented).
+
+        debugger = new BsdDebuggerLocal(machDesc, !isServer);
+        attachDebugger();
+    }
+
+    private void setupJVMLibNamesBsd() {
+        // same as solaris
+        setupJVMLibNamesSolaris();
+    }
+
     /** Convenience routine which should be called by per-platform
       debugger setup. Should not be called when startupMode is
       REMOTE_MODE. */
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
@@ -30,10 +30,8 @@
 import sun.jvm.hotspot.debugger.cdbg.*;
 import sun.jvm.hotspot.debugger.x86.*;
 import sun.jvm.hotspot.debugger.amd64.*;
-import sun.jvm.hotspot.debugger.sparc.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
-import sun.jvm.hotspot.debugger.bsd.sparc.*;
 import sun.jvm.hotspot.utilities.*;
 
 class BsdCDebugger implements CDebugger {
@@ -99,13 +97,6 @@
        Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);
        if (pc == null) return null;
        return new BsdAMD64CFrame(dbg, rbp, pc);
-    } else if (cpu.equals("sparc")) {
-       SPARCThreadContext context = (SPARCThreadContext) thread.getContext();
-       Address sp = context.getRegisterAsAddress(SPARCThreadContext.R_SP);
-       if (sp == null) return null;
-       Address pc  = context.getRegisterAsAddress(SPARCThreadContext.R_O7);
-       if (pc == null) return null;
-       return new BsdSPARCCFrame(dbg, sp, pc, BsdDebuggerLocal.getAddressSize());
     } else {
        throw new DebuggerException(cpu + " is not yet supported");
     }
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
@@ -26,9 +26,7 @@
 
 import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
-import sun.jvm.hotspot.debugger.bsd.ia64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
-import sun.jvm.hotspot.debugger.bsd.sparc.*;
 
 class BsdThreadContextFactory {
    static ThreadContext createThreadContext(BsdDebugger dbg) {
@@ -37,10 +35,6 @@
          return new BsdX86ThreadContext(dbg);
       } else if (cpu.equals("amd64")) {
          return new BsdAMD64ThreadContext(dbg);
-      } else if (cpu.equals("ia64")) {
-         return new BsdIA64ThreadContext(dbg);
-      } else if (cpu.equals("sparc")) {
-         return new BsdSPARCThreadContext(dbg);
       } else {
          throw new RuntimeException("cpu " + cpu + " is not yet supported");
       }
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/ConnectorImpl.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/ConnectorImpl.java
@@ -217,7 +217,7 @@
     }
 
     protected void checkNativeLink(SecurityManager sm, String os) {
-        if (os.equals("SunOS") || os.equals("Linux")) {
+        if (os.equals("SunOS") || os.equals("Linux") || os.equals("FreeBSD")) {
             // link "saproc" - SA native library on SunOS and Linux?
             sm.checkLink("saproc");
         } else if (os.startsWith("Windows")) {
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/SAPIDAttachingConnector.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/SAPIDAttachingConnector.java
@@ -66,7 +66,7 @@
             try {
                 // Whether the caller can perform link against SA native library?
                 checkNativeLink(sm, os);
-                if (os.equals("SunOS") || os.equals("Linux")) {
+                if (os.equals("SunOS") || os.equals("Linux") || os.equals("FreeBSD")) {
                     // Whether the caller can read /proc/<pid> file?
                     sm.checkRead("/proc/" + pid);
                 }
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/Threads.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/Threads.java
@@ -37,6 +37,8 @@
 import sun.jvm.hotspot.runtime.linux_ia64.LinuxIA64JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.linux_amd64.LinuxAMD64JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.linux_sparc.LinuxSPARCJavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;
 import sun.jvm.hotspot.utilities.*;
 
 public class Threads {
@@ -90,7 +92,12 @@
             } else if (cpu.equals("sparc")) {
                 access = new LinuxSPARCJavaThreadPDAccess();
             }
-
+        } else if (os.equals("bsd")) {
+            if (cpu.equals("x86")) {
+                access = new BsdX86JavaThreadPDAccess();
+            } else if (cpu.equals("amd64")) {
+                access = new BsdAMD64JavaThreadPDAccess();
+            }
         }
 
         if (access == null) {
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd/BsdSignals.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd/BsdSignals.java
@@ -28,37 +28,36 @@
   private static String[] signalNames = {
     "",           /* No signal 0 */
     "SIGHUP",     /* hangup */
-    "SIGINT",     /* interrupt (rubout) */
-    "SIGQUIT",    /* quit (ASCII FS) */
-    "SIGILL",     /* illegal instruction (not reset when caught) */
+    "SIGINT",     /* interrupt */
+    "SIGQUIT",    /* quit */
+    "SIGILL",     /* illegal instr. (not reset when caught) */
     "SIGTRAP",    /* trace trap (not reset when caught) */
-    "SIGABRT",    /* used by abort, replace SIGIOT in the future */
-    "SIGIOT",
-    "SIGBUS",
+    "SIGABRT",    /* abort() */
+    "SIGEMT",     /* EMT instruction */
     "SIGFPE",     /* floating point exception */
     "SIGKILL",    /* kill (cannot be caught or ignored) */
-    "SIGUSR1",    /* user defined signal 1 */
+    "SIGBUS",     /* bus error */
     "SIGSEGV",    /* segmentation violation */
-    "SIGUSR2",    /* user defined signal 2 */
+    "SIGSYS",     /* non-existent system call invoked */
     "SIGPIPE",    /* write on a pipe with no one to read it */
     "SIGALRM",    /* alarm clock */
     "SIGTERM",    /* software termination signal from kill */
-    "SIGSTKFLT",
-    "SIGCHLD",    /* child status change alias */
-    "SIGCONT",    /* stopped process has been continued */
-    "SIGSTOP",    /* stop (cannot be caught or ignored) */
-    "SIGTSTP",    /* user stop requested from tty */
-    "SIGTTIN",    /* background tty read attempted */
-    "SIGTTOU",    /* background tty write attempted */
-    "SIGURG",     /* urgent socket condition */
-    "SIGXCPU",    /* exceeded cpu limit */
+    "SIGURG",     /* urgent condition on IO channel */
+    "SIGSTOP",    /* sendable stop signal not from tty */
+    "SIGTSTP",    /* stop signal from tty */
+    "SIGCONT",    /* continue a stopped process */
+    "SIGCHLD",    /* to parent on child stop or exit */
+    "SIGTTIN",    /* to readers pgrp upon background tty read */
+    "SIGTTOU",    /* like TTIN if (tp->t_local&LTOSTOP) */
+    "SIGIO",      /* input/output possible signal */
+    "SIGXCPU",    /* exceeded CPU time limit */
     "SIGXFSZ",    /* exceeded file size limit */
-    "SIGVTALRM",  /* virtual timer expired */
-    "SIGPROF",    /* profiling timer expired */
-    "SIGWINCH",   /* window size change */
-    "SIGPOLL",    /* pollable event occured */
-    "SIGPWR",     /* power-fail restart */
-    "SIGSYS"
+    "SIGVTALRM",  /* virtual time alarm */
+    "SIGPROF",    /* profiling time alarm */
+    "SIGWINCH",   /* window size changes */
+    "SIGINFO",    /* information request */
+    "SIGUSR1",    /* user defined signal 1 */
+    "SIGUSR2"     /* user defined signal 2 */
   };
 
   public static String getSignalName(int sigNum) {
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_x86/BsdSignals.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_x86/BsdSignals.java
@@ -28,37 +28,36 @@
   private static String[] signalNames = {
     "",           /* No signal 0 */
     "SIGHUP",     /* hangup */
-    "SIGINT",     /* interrupt (rubout) */
-    "SIGQUIT",    /* quit (ASCII FS) */
-    "SIGILL",     /* illegal instruction (not reset when caught) */
+    "SIGINT",     /* interrupt */
+    "SIGQUIT",    /* quit */
+    "SIGILL",     /* illegal instr. (not reset when caught) */
     "SIGTRAP",    /* trace trap (not reset when caught) */
-    "SIGABRT",    /* used by abort, replace SIGIOT in the future */
-    "SIGIOT",
-    "SIGBUS",
+    "SIGABRT",    /* abort() */
+    "SIGEMT",     /* EMT instruction */
     "SIGFPE",     /* floating point exception */
     "SIGKILL",    /* kill (cannot be caught or ignored) */
-    "SIGUSR1",    /* user defined signal 1 */
+    "SIGBUS",     /* bus error */
     "SIGSEGV",    /* segmentation violation */
-    "SIGUSR2",    /* user defined signal 2 */
+    "SIGSYS",     /* non-existent system call invoked */
     "SIGPIPE",    /* write on a pipe with no one to read it */
     "SIGALRM",    /* alarm clock */
     "SIGTERM",    /* software termination signal from kill */
-    "SIGSTKFLT",
-    "SIGCHLD",    /* child status change alias */
-    "SIGCONT",    /* stopped process has been continued */
-    "SIGSTOP",    /* stop (cannot be caught or ignored) */
-    "SIGTSTP",    /* user stop requested from tty */
-    "SIGTTIN",    /* background tty read attempted */
-    "SIGTTOU",    /* background tty write attempted */
-    "SIGURG",     /* urgent socket condition */
-    "SIGXCPU",    /* exceeded cpu limit */
+    "SIGURG",     /* urgent condition on IO channel */
+    "SIGSTOP",    /* sendable stop signal not from tty */
+    "SIGTSTP",    /* stop signal from tty */
+    "SIGCONT",    /* continue a stopped process */
+    "SIGCHLD",    /* to parent on child stop or exit */
+    "SIGTTIN",    /* to readers pgrp upon background tty read */
+    "SIGTTOU",    /* like TTIN if (tp->t_local&LTOSTOP) */
+    "SIGIO",      /* input/output possible signal */
+    "SIGXCPU",    /* exceeded CPU time limit */
     "SIGXFSZ",    /* exceeded file size limit */
-    "SIGVTALRM",  /* virtual timer expired */
-    "SIGPROF",    /* profiling timer expired */
-    "SIGWINCH",   /* window size change */
-    "SIGPOLL",    /* pollable event occured */
-    "SIGPWR",     /* power-fail restart */
-    "SIGSYS"
+    "SIGVTALRM",  /* virtual time alarm */
+    "SIGPROF",    /* profiling time alarm */
+    "SIGWINCH",   /* window size changes */
+    "SIGINFO",    /* information request */
+    "SIGUSR1",    /* user defined signal 1 */
+    "SIGUSR2"     /* user defined signal 2 */
   };
 
   public static String getSignalName(int sigNum) {
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java
@@ -37,6 +37,14 @@
       return "solaris";
     } else if (os.equals("Linux")) {
       return "linux";
+    } else if (os.equals("FreeBSD")) {
+      return "bsd";
+    } else if (os.equals("NetBSD")) {
+      return "bsd";
+    } else if (os.equals("OpenBSD")) {
+      return "bsd";
+    } else if (os.equals("Darwin")) {
+      return "bsd";
     } else if (os.startsWith("Windows")) {
       return "win32";
     } else {
--- hotspot/make/Makefile
+++ hotspot/make/Makefile
@@ -321,28 +321,28 @@
 ifneq ($(OSNAME),windows)
   ifeq ($(ZERO_BUILD), true)
     ifeq ($(SHARK_BUILD), true)
-$(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(SHARK_DIR)/%.so
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(SHARK_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/%.so:       $(SHARK_DIR)/%.so
+$(EXPORT_SERVER_DIR)/%.$(LIBRARY_SUFFIX):       $(SHARK_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
     else
-$(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(ZERO_DIR)/%.so
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(ZERO_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/%.so:       $(ZERO_DIR)/%.so
+$(EXPORT_SERVER_DIR)/%.$(LIBRARY_SUFFIX):       $(ZERO_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
     endif
   else
-$(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(C1_DIR)/%.so
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(C1_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(C2_DIR)/%.so
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(C2_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_CLIENT_DIR)/%.so:       $(C1_DIR)/%.so
+$(EXPORT_CLIENT_DIR)/%.$(LIBRARY_SUFFIX):       $(C1_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_CLIENT_DIR)/64/%.so:    $(C1_DIR)/%.so
+$(EXPORT_CLIENT_DIR)/64/%.$(LIBRARY_SUFFIX):    $(C1_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/%.so:       $(C2_DIR)/%.so
+$(EXPORT_SERVER_DIR)/%.$(LIBRARY_SUFFIX):       $(C2_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/64/%.so:    $(C2_DIR)/%.so
+$(EXPORT_SERVER_DIR)/64/%.$(LIBRARY_SUFFIX):    $(C2_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
   endif
 endif
--- hotspot/make/bsd/Makefile
+++ hotspot/make/bsd/Makefile
@@ -39,11 +39,11 @@
 # One can set ALT_BOOTDIR or BOOTDIR to point to a jdk that runs on
 # an architecture that differs from the target architecture, as long
 # as the bootstrap jdk runs under the same flavor of OS as the target
-# (i.e., if the target is bsd, point to a jdk that runs on a bsd
+# (i.e., if the target is linux, point to a jdk that runs on a linux
 # box).  In order to use such a bootstrap jdk, set the make variable
 # REMOTE to the desired remote command mechanism, e.g.,
 #
-#    make REMOTE="rsh -l me myotherbsdbox"
+#    make REMOTE="rsh -l me myotherlinuxbox"
 
 # Along with VM, Serviceability Agent (SA) is built for SA/JDI binding.
 # JDI binding on SA produces two binaries:
@@ -94,7 +94,7 @@
 #
 # We only do this on SunOS variants, for a couple of reasons:
 #  * It is extremely rare that source trees exist on other systems
-#  * It has been claimed that the Bsd automounter is flakey, so
+#  * It has been claimed that the Linux automounter is flakey, so
 #    changing GAMMADIR in a way that exercises the automounter could
 #    prove to be a source of unreliability in the build process.
 # Obviously, this Makefile is only relevant on SunOS boxes to begin
@@ -226,11 +226,12 @@
 
 checks: check_os_version check_j2se_version
 
-# We do not want people accidentally building on old systems (e.g. Bsd 2.2.x,
+# We do not want people accidentally building on old systems (e.g. Linux 2.2.x,
 # Solaris 2.5.1, 2.6).
 # Disable this check by setting DISABLE_HOTSPOT_OS_VERSION_CHECK=ok.
 
-SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3%
+#SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3%
+DISABLE_HOTSPOT_OS_VERSION_CHECK = ok
 OS_VERSION := $(shell uname -r)
 EMPTY_IF_NOT_SUPPORTED = $(filter $(SUPPORTED_OS_VERSION),$(OS_VERSION))
 
--- hotspot/make/bsd/makefiles/adlc.make
+++ hotspot/make/bsd/makefiles/adlc.make
@@ -60,7 +60,8 @@
 
 # CFLAGS_WARN holds compiler options to suppress/enable warnings.
 # Compiler warnings are treated as errors
-CFLAGS_WARN = -Werror
+WARNINGS_ARE_ERRORS ?= -Werror
+CFLAGS_WARN = $(WARNINGS_ARE_ERRORS)
 CFLAGS += $(CFLAGS_WARN)
 
 OBJECTNAMES = \
--- hotspot/make/bsd/makefiles/buildtree.make
+++ hotspot/make/bsd/makefiles/buildtree.make
@@ -303,10 +303,11 @@
 	[ -n "$$JAVA_HOME" ] && { echo ": \$${JAVA_HOME:=$${JAVA_HOME}}"; }; \
 	{ \
 	echo "LD_LIBRARY_PATH=.:$${LD_LIBRARY_PATH:+$$LD_LIBRARY_PATH:}\$${JAVA_HOME}/jre/lib/${LIBARCH}/native_threads:\$${JAVA_HOME}/jre/lib/${LIBARCH}:${GCC_LIB}"; \
+	echo "DYLD_LIBRARY_PATH=.:$${DYLD_LIBRARY_PATH:+$$DYLD_LIBRARY_PATH:}\$${JAVA_HOME}/jre/lib/${LIBARCH}/native_threads:\$${JAVA_HOME}/jre/lib/${LIBARCH}:${GCC_LIB}"; \
 	echo "CLASSPATH=$${CLASSPATH:+$$CLASSPATH:}.:\$${JAVA_HOME}/jre/lib/rt.jar:\$${JAVA_HOME}/jre/lib/i18n.jar"; \
 	} | sed s:$${JAVA_HOME:--------}:\$${JAVA_HOME}:g; \
 	echo "HOTSPOT_BUILD_USER=\"$${LOGNAME:-$$USER} in `basename $(GAMMADIR)`\""; \
-	echo "export JAVA_HOME LD_LIBRARY_PATH CLASSPATH HOTSPOT_BUILD_USER"; \
+	echo "export JAVA_HOME LD_LIBRARY_PATH DYLD_LIBRARY_PATH CLASSPATH HOTSPOT_BUILD_USER"; \
 	) > $@
 
 env.csh: env.sh
--- hotspot/make/bsd/makefiles/cscope.make
+++ hotspot/make/bsd/makefiles/cscope.make
@@ -71,7 +71,7 @@
 # OS-specific files for other systems are excluded by default.  Use CS_OS=yes
 # to include platform-specific files for other platforms.
 ifndef	CS_OS
-CS_OS		= bsd macos solaris win32
+CS_OS		= linux macos solaris win32 bsd
 CS_PRUNE_OS	= $(patsubst %,-o -name '*%*',$(filter-out ${OS},${CS_OS}))
 endif
 
--- hotspot/make/bsd/makefiles/defs.make
+++ hotspot/make/bsd/makefiles/defs.make
@@ -72,8 +72,8 @@
   HS_ARCH            = sparc
 endif
 
-# x86_64
-ifeq ($(ARCH), x86_64) 
+# amd64
+ifeq ($(ARCH), amd64) 
   ifeq ($(ARCH_DATA_MODEL), 64)
     ARCH_DATA_MODEL = 64
     MAKE_ARGS       += LP64=1
@@ -85,17 +85,27 @@
     PLATFORM        = bsd-i586
     VM_PLATFORM     = bsd_i486
     HS_ARCH         = x86
-    # We have to reset ARCH to i686 since SRCARCH relies on it
-    ARCH            = i686   
+    # We have to reset ARCH to i386 since SRCARCH relies on it
+    ARCH            = i386   
   endif
 endif
 
-# i686
-ifeq ($(ARCH), i686)
-  ARCH_DATA_MODEL  = 32
-  PLATFORM         = bsd-i586
-  VM_PLATFORM      = bsd_i486
-  HS_ARCH          = x86
+# i386
+ifeq ($(ARCH), i386)
+  ifeq ($(ARCH_DATA_MODEL), 64)
+    ARCH_DATA_MODEL = 64
+    MAKE_ARGS       += LP64=1
+    PLATFORM        = bsd-amd64
+    VM_PLATFORM     = bsd_amd64
+    HS_ARCH         = x86
+    # We have to reset ARCH to amd64 since SRCARCH relies on it
+    ARCH            = amd64
+  else
+    ARCH_DATA_MODEL  = 32
+    PLATFORM         = bsd-i586
+    VM_PLATFORM      = bsd_i486
+    HS_ARCH          = x86
+  endif
 endif
 
 # ARM
@@ -116,39 +126,45 @@
 
 JDK_INCLUDE_SUBDIR=bsd
 
+# Library suffix
+OS_VENDOR:=$(shell uname -s)
+ifeq ($(OS_VENDOR),Darwin)
+  LIBRARY_SUFFIX=dylib
+else
+  LIBRARY_SUFFIX=so
+endif
+
 # FIXUP: The subdirectory for a debug build is NOT the same on all platforms
 VM_DEBUG=jvmg
 
 EXPORT_LIST += $(EXPORT_DOCS_DIR)/platform/jvmti/jvmti.html
 
 # client and server subdirectories have symbolic links to ../libjsig.so
-EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.so
+EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.$(LIBRARY_SUFFIX)
 EXPORT_SERVER_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/server
 
 ifndef BUILD_CLIENT_ONLY
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.so
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.$(LIBRARY_SUFFIX)
 endif
 
 ifneq ($(ZERO_BUILD), true)
   ifeq ($(ARCH_DATA_MODEL), 32)
     EXPORT_CLIENT_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/client
     EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.so 
+    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX)
   endif
 endif
 
 # Serviceability Binaries
 # No SA Support for PPC, IA64, ARM or zero
-ADD_SA_BINARIES/x86   = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so \
-                        $(EXPORT_LIB_DIR)/sa-jdi.jar 
-ADD_SA_BINARIES/sparc = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so \
-                        $(EXPORT_LIB_DIR)/sa-jdi.jar 
-ADD_SA_BINARIES/ppc   = 
-ADD_SA_BINARIES/ia64  = 
-ADD_SA_BINARIES/arm   = 
-ADD_SA_BINARIES/zero  = 
+ADD_SA_BINARIES/x86   = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
+                        $(EXPORT_LIB_DIR)/sa-jdi.jar
+ADD_SA_BINARIES/sparc = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
+                        $(EXPORT_LIB_DIR)/sa-jdi.jar
+ADD_SA_BINARIES/ppc   =
+ADD_SA_BINARIES/ia64  =
+ADD_SA_BINARIES/arm   =
+ADD_SA_BINARIES/zero  =
 
 EXPORT_LIST += $(ADD_SA_BINARIES/$(HS_ARCH))
-
-
--- hotspot/make/bsd/makefiles/gcc.make
+++ hotspot/make/bsd/makefiles/gcc.make
@@ -22,20 +22,24 @@
 #  
 #
 
+OS_VENDOR = $(shell uname -s)
+
 #------------------------------------------------------------------------
 # CC, CPP & AS
 
 # When cross-compiling the ALT_COMPILER_PATH points
 # to the cross-compilation toolset
 ifdef CROSS_COMPILE_ARCH
+CXX = $(ALT_COMPILER_PATH)/g++
 CPP = $(ALT_COMPILER_PATH)/g++
 CC  = $(ALT_COMPILER_PATH)/gcc
 else
-CPP = g++
-CC  = gcc
+CXX ?= g++
+CPP = $(CXX)
+CC  ?= gcc
 endif
 
-AS  = $(CC) -c
+AS   = $(CC) -c -x assembler-with-cpp
 
 # -dumpversion in gcc-2.91 shows "egcs-2.91.66". In later version, it only
 # prints the numbers (e.g. "2.95", "3.2.1")
@@ -73,7 +77,7 @@
 CFLAGS += $(VM_PICFLAG)
 CFLAGS += -fno-rtti
 CFLAGS += -fno-exceptions
-CFLAGS += -D_REENTRANT
+CFLAGS += -pthread
 CFLAGS += -fcheck-new
 
 ARCHFLAG = $(ARCHFLAG/$(BUILDARCH))
@@ -82,10 +86,12 @@
 ARCHFLAG/ia64    =
 ARCHFLAG/sparc   = -m32 -mcpu=v9
 ARCHFLAG/sparcv9 = -m64 -mcpu=v9
-ARCHFLAG/arm     =  -fsigned-char
 ARCHFLAG/zero    = $(ZERO_ARCHFLAG)
-ifndef E500V2
-ARCHFLAG/ppc     =  -mcpu=powerpc
+
+# Darwin-specific build flags
+ifeq ($(OS_VENDOR), Darwin)
+  # Ineffecient 16-byte stack re-alignment on Darwin/IA32
+  ARCHFLAG/i486 += -mstackrealign
 endif
 
 CFLAGS     += $(ARCHFLAG)
@@ -115,7 +121,7 @@
 endif
 
 # Compiler warnings are treated as errors
-WARNINGS_ARE_ERRORS = -Werror
+WARNINGS_ARE_ERRORS ?= -Werror
 
 # Except for a few acceptable ones
 # Since GCC 4.3, -Wconversion has changed its meanings to warn these implicit
@@ -130,6 +136,11 @@
 CFLAGS_WARN/DEFAULT = $(WARNINGS_ARE_ERRORS) $(ACCEPTABLE_WARNINGS)
 # Special cases
 CFLAGS_WARN/BYFILE = $(CFLAGS_WARN/$@)$(CFLAGS_WARN/DEFAULT$(CFLAGS_WARN/$@)) 
+# XXXDARWIN: for _dyld_bind_fully_image_containing_address
+ifeq ($(OS_VENDOR), Darwin)
+  CFLAGS_WARN/os_bsd.o = $(CFLAGS_WARN/DEFAULT) -Wno-deprecated-declarations
+endif
+
 
 # The flags to use for an Optimized g++ build
 OPT_CFLAGS += -O3
@@ -175,28 +186,40 @@
 LFLAGS += -Wl,-relax
 endif
 
-# Enable linker optimization
-LFLAGS += -Xlinker -O1
-
-# If this is a --hash-style=gnu system, use --hash-style=both
-#   The gnu .hash section won't work on some Bsd systems like SuSE 10.
-_HAS_HASH_STYLE_GNU:=$(shell $(CC) -dumpspecs | grep -- '--hash-style=gnu')
-ifneq ($(_HAS_HASH_STYLE_GNU),)
-  LDFLAGS_HASH_STYLE = -Wl,--hash-style=both
-endif
-LFLAGS += $(LDFLAGS_HASH_STYLE)
-
 # Use $(MAPFLAG:FILENAME=real_file_name) to specify a map file.
 MAPFLAG = -Xlinker --version-script=FILENAME
 
-# Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
-SONAMEFLAG = -Xlinker -soname=SONAME
+#
+# Shared Library
+#
+ifeq ($(OS_VENDOR), Darwin)
+  # Standard linker flags
+  LFLAGS +=
+
+  # Darwin doesn't use ELF and doesn't support version scripts
+  LDNOMAP = true
+
+  # Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
+  SONAMEFLAG =
+
+  # Build shared library
+  SHARED_FLAG = -dynamiclib $(VM_PICFLAG)
 
-# Build shared library
-SHARED_FLAG = -shared
+  # Keep symbols even they are not used
+  #AOUT_FLAGS += -export-dynamic
+else
+  # Enable linker optimization
+  LFLAGS += -Xlinker -O1
+
+  # Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
+  SONAMEFLAG = -Xlinker -soname=SONAME
 
-# Keep symbols even they are not used
-AOUT_FLAGS += -export-dynamic
+  # Build shared library
+  SHARED_FLAG = -shared $(VM_PICFLAG)
+
+  # Keep symbols even they are not used
+  AOUT_FLAGS += -export-dynamic
+endif
 
 #------------------------------------------------------------------------
 # Debug flags
--- hotspot/make/bsd/makefiles/jsig.make
+++ hotspot/make/bsd/makefiles/jsig.make
@@ -25,11 +25,16 @@
 # Rules to build signal interposition library, used by vm.make
 
 # libjsig[_g].so: signal interposition library
-JSIG = jsig
-LIBJSIG = lib$(JSIG).so
+JSIG   = jsig
+JSIG_G = $(JSIG)$(G_SUFFIX)
 
-JSIG_G    = $(JSIG)$(G_SUFFIX)
-LIBJSIG_G = lib$(JSIG_G).so
+ifeq ($(OS_VENDOR), Darwin)
+  LIBJSIG   = lib$(JSIG).dylib
+  LIBJSIG_G = lib$(JSIG_G).dylib
+else
+  LIBJSIG   = lib$(JSIG).so
+  LIBJSIG_G = lib$(JSIG_G).so
+endif
 
 JSIGSRCDIR = $(GAMMADIR)/src/os/$(Platform_os_family)/vm
 
@@ -42,7 +47,7 @@
 # cause problems with interposing. See CR: 6466665
 # LFLAGS_JSIG += $(MAPFLAG:FILENAME=$(LIBJSIG_MAPFILE))
 
-LFLAGS_JSIG += -D_GNU_SOURCE -D_REENTRANT $(LDFLAGS_HASH_STYLE)
+LFLAGS_JSIG += -D_GNU_SOURCE -pthread $(LDFLAGS_HASH_STYLE)
 
 # DEBUG_BINARIES overrides everything, use full -g debug information
 ifeq ($(DEBUG_BINARIES), true)
@@ -52,7 +57,7 @@
 $(LIBJSIG): $(JSIGSRCDIR)/jsig.c $(LIBJSIG_MAPFILE)
 	@echo Making signal interposition lib...
 	$(QUIETLY) $(CC) $(SYMFLAG) $(ARCHFLAG) $(SHARED_FLAG) $(PICFLAG) \
-                         $(LFLAGS_JSIG) $(JSIG_DEBUG_CFLAGS) -o $@ $< -ldl
+                         $(LFLAGS_JSIG) $(JSIG_DEBUG_CFLAGS) -o $@ $<
 	$(QUIETLY) [ -f $(LIBJSIG_G) ] || { ln -s $@ $(LIBJSIG_G); }
 
 install_jsig: $(LIBJSIG)
--- hotspot/make/bsd/makefiles/launcher.make
+++ hotspot/make/bsd/makefiles/launcher.make
@@ -50,7 +50,7 @@
   LIBS_LAUNCHER             += $(STATIC_STDCXX) $(LIBS)
 else
   LAUNCHER.o                 = launcher.o
-  LFLAGS_LAUNCHER           += -L `pwd`
+  LFLAGS_LAUNCHER           += -L`pwd`
   LIBS_LAUNCHER             += -l$(JVM) $(LIBS)
 endif
 
--- hotspot/make/bsd/makefiles/sa.make
+++ hotspot/make/bsd/makefiles/sa.make
@@ -45,8 +45,8 @@
 
 # gnumake 3.78.1 does not accept the *s that
 # are in AGENT_FILES1 and AGENT_FILES2, so use the shell to expand them
-AGENT_FILES1 := $(shell /usr/bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES1))
-AGENT_FILES2 := $(shell /usr/bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES2))
+AGENT_FILES1 := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES1))
+AGENT_FILES2 := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES2))
 
 AGENT_FILES1_LIST := $(GENERATED)/agent1.classes.list
 AGENT_FILES2_LIST := $(GENERATED)/agent2.classes.list
--- hotspot/make/bsd/makefiles/saproc.make
+++ hotspot/make/bsd/makefiles/saproc.make
@@ -25,23 +25,33 @@
 # Rules to build serviceability agent library, used by vm.make
 
 # libsaproc[_g].so: serviceability agent
-
-SAPROC = saproc
-LIBSAPROC = lib$(SAPROC).so
-
+SAPROC   = saproc
 SAPROC_G = $(SAPROC)$(G_SUFFIX)
-LIBSAPROC_G = lib$(SAPROC_G).so
+
+ifeq ($(OS_VENDOR), Darwin)
+  LIBSAPROC   = lib$(SAPROC).dylib
+  LIBSAPROC_G = lib$(SAPROC_G).dylib
+else
+  LIBSAPROC   = lib$(SAPROC).so
+  LIBSAPROC_G = lib$(SAPROC_G).so
+endif
 
 AGENT_DIR = $(GAMMADIR)/agent
 
 SASRCDIR = $(AGENT_DIR)/src/os/$(Platform_os_family)
 
+ifeq ($(OS_VENDOR), FreeBSD)
 SASRCFILES = $(SASRCDIR)/salibelf.c                   \
              $(SASRCDIR)/symtab.c                     \
              $(SASRCDIR)/libproc_impl.c               \
              $(SASRCDIR)/ps_proc.c                    \
              $(SASRCDIR)/ps_core.c                    \
              $(SASRCDIR)/BsdDebuggerLocal.c
+SALIBS = -lutil -lthread_db
+else
+SASRCFILES = $(SASRCDIR)/StubDebuggerLocal.c
+SALIBS = 
+endif
 
 SAMAPFILE = $(SASRCDIR)/mapfile
 
@@ -62,7 +72,10 @@
 endif
 
 
-SA_LFLAGS = $(MAPFLAG:FILENAME=$(SAMAPFILE)) $(LDFLAGS_HASH_STYLE)
+ifneq ($(OS_VENDOR), Darwin)
+SA_LFLAGS = $(MAPFLAG:FILENAME=$(SAMAPFILE))
+endif
+SA_LFLAGS += $(LDFLAGS_HASH_STYLE)
 
 $(LIBSAPROC): $(SASRCFILES) $(SAMAPFILE)
 	$(QUIETLY) if [ "$(BOOT_JAVA_HOME)" = "" ]; then \
@@ -75,12 +88,12 @@
 	           -I$(SASRCDIR)                                        \
 	           -I$(GENERATED)                                       \
 	           -I$(BOOT_JAVA_HOME)/include                          \
-	           -I$(BOOT_JAVA_HOME)/include/$(Platform_os_family)    \
+	           -I$(BOOT_JAVA_HOME)/include/$(shell uname -s | tr "[:upper:]" "[:lower:]") \
 	           $(SASRCFILES)                                        \
 	           $(SA_LFLAGS)                                         \
 	           $(SA_DEBUG_CFLAGS)                                   \
 	           -o $@                                                \
-	           -lthread_db
+	           $(SALIBS)
 	$(QUIETLY) [ -f $(LIBSAPROC_G) ] || { ln -s $@ $(LIBSAPROC_G); }
 
 install_saproc: $(BUILDLIBSAPROC)
--- hotspot/make/bsd/makefiles/vm.make
+++ hotspot/make/bsd/makefiles/vm.make
@@ -91,6 +91,10 @@
   ${JRE_VERSION}     \
   ${VM_DISTRO}
 
+ifdef DEFAULT_LIBPATH
+CPPFLAGS += -DDEFAULT_LIBPATH="\"$(DEFAULT_LIBPATH)\""
+endif
+
 # CFLAGS_WARN holds compiler options to suppress/enable warnings.
 CFLAGS += $(CFLAGS_WARN/BYFILE)
 
@@ -101,7 +105,7 @@
 CFLAGS += $(EXTRA_CFLAGS)
 LFLAGS += $(EXTRA_CFLAGS)
 
-LIBS += -lm -ldl -lpthread
+LIBS += -lm -pthread
 
 # By default, link the *.o into the library, not the executable.
 LINK_INTO$(LINK_INTO) = LIBJVM
@@ -115,9 +119,15 @@
 #----------------------------------------------------------------------
 # JVM
 
-JVM      = jvm
-LIBJVM   = lib$(JVM).so
-LIBJVM_G = lib$(JVM)$(G_SUFFIX).so
+JVM    = jvm
+ifeq ($(OS_VENDOR), Darwin)
+  LIBJVM   = lib$(JVM).dylib
+  LIBJVM_G = lib$(JVM)$(G_SUFFIX).dylib
+  CFLAGS  += -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE
+else
+  LIBJVM   = lib$(JVM).so
+  LIBJVM_G = lib$(JVM)$(G_SUFFIX).so
+endif
 
 CORE_PATHS := $(shell find $(GAMMADIR)/src/share/vm/* -type d \! \( -name adlc -o -name c1 -o -name gc_implementation -o -name opto -o -name shark -o -name libadt \))
 CORE_PATHS += $(GAMMADIR)/src/os/$(Platform_os_family)/vm
@@ -196,15 +206,7 @@
 vm.def: $(Res_Files) $(Obj_Files)
 	sh $(GAMMADIR)/make/bsd/makefiles/build_vm_def.sh *.o > $@
 
-ifeq ($(SHARK_BUILD), true)
-  STATIC_CXX = false
-else
-  ifeq ($(ZERO_LIBARCH), ppc64)
-    STATIC_CXX = false
-  else
-    STATIC_CXX = true
-  endif
-endif
+STATIC_CXX = false
 
 ifeq ($(LINK_INTO),AOUT)
   LIBJVM.o                 =
@@ -216,14 +218,21 @@
   LFLAGS_VM$(LDNOMAP)      += $(MAPFLAG:FILENAME=$(LIBJVM_MAPFILE))
   LFLAGS_VM                += $(SONAMEFLAG:SONAME=$(LIBJVM))
 
+  ifeq ($(OS_VENDOR), Darwin)
+    LFLAGS_VM += -Xlinker -rpath -Xlinker @loader_path/.
+    LFLAGS_VM += -Xlinker -rpath -Xlinker @loader_path/..
+    LFLAGS_VM += -Xlinker -install_name -Xlinker @rpath/$(@F)
+  endif
+
   # JVM is statically linked with libgcc[_s] and libstdc++; this is needed to
   # get around library dependency and compatibility issues. Must use gcc not
   # g++ to link.
   ifeq ($(STATIC_CXX), true)
     LFLAGS_VM              += $(STATIC_LIBGCC)
     LIBS_VM                += $(STATIC_STDCXX)
+    LINK_VM                = $(LINK_LIB.c)
   else
-    LIBS_VM                += -lstdc++
+    LINK_VM                = $(LINK_LIB.CC)
   endif
 
   LIBS_VM                  += $(LIBS)
@@ -236,7 +245,6 @@
   LIBS_VM   += $(LLVM_LIBS)
 endif
 
-LINK_VM = $(LINK_LIB.c)
 
 # rule for building precompiled header
 $(PRECOMPILED_HEADER):
@@ -264,11 +272,6 @@
 LD_SCRIPT_FLAG = -Wl,-T,$(LD_SCRIPT)
 endif
 
-# With more recent Redhat releases (or the cutting edge version Fedora), if
-# SEBsd is configured to be enabled, the runtime linker will fail to apply
-# the text relocation to libjvm.so considering that it is built as a non-PIC
-# DSO. To workaround that, we run chcon to libjvm.so after it is built. See 
-# details in bug 6538311.
 $(LIBJVM): $(LIBJVM.o) $(LIBJVM_MAPFILE) $(LD_SCRIPT)
 	$(QUIETLY) {                                                    \
 	    echo Linking vm...;                                         \
@@ -278,17 +281,6 @@
 	    $(LINK_LIB.CC/POST_HOOK)                                    \
 	    rm -f $@.1; ln -s $@ $@.1;                                  \
 	    [ -f $(LIBJVM_G) ] || { ln -s $@ $(LIBJVM_G); ln -s $@.1 $(LIBJVM_G).1; }; \
-            if [ \"$(CROSS_COMPILE_ARCH)\" = \"\" ] ; then                    \
-	      if [ -x /usr/sbin/sebsdenabled ] ; then                 \
-	        /usr/sbin/sebsdenabled;                               \
-                if [ $$? = 0 ] ; then					\
-		  /usr/bin/chcon -t textrel_shlib_t $@;                 \
-		  if [ $$? != 0 ]; then                                 \
-		    echo "ERROR: Cannot chcon $@";			\
-		  fi							\
-	        fi							\
-	      fi                                                        \
-            fi 								\
 	}
 
 DEST_JVM = $(JDK_LIBDIR)/$(VM_SUBDIR)/$(LIBJVM)
--- hotspot/make/bsd/platform_amd64
+++ hotspot/make/bsd/platform_amd64
@@ -12,4 +12,4 @@
 
 compiler = gcc
 
-sysdefs = -DBSD -D_GNU_SOURCE -DAMD64
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DAMD64
--- hotspot/make/bsd/platform_i486
+++ hotspot/make/bsd/platform_i486
@@ -12,4 +12,4 @@
 
 compiler = gcc
 
-sysdefs = -DBSD -D_GNU_SOURCE -DIA32
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DIA32
--- hotspot/make/defs.make
+++ hotspot/make/defs.make
@@ -118,13 +118,23 @@
 # Windows should have OS predefined
 ifeq ($(OS),)
   OS   := $(shell uname -s)
+  ifneq ($(findstring BSD,$(OS)),)
+    OS=bsd
+  endif
+  ifeq ($(OS), Darwin)
+    OS=bsd
+  endif
   HOST := $(shell uname -n)
 endif
 
-# If not SunOS and not Linux, assume Windows
+# If not SunOS, not Linux and not BSD, assume Windows
 ifneq ($(OS), Linux)
   ifneq ($(OS), SunOS)
-    OSNAME=windows
+    ifneq ($(OS), bsd)
+      OSNAME=windows
+    else
+      OSNAME=bsd
+    endif
   else
     OSNAME=solaris
   endif
--- hotspot/make/sa.files
+++ hotspot/make/sa.files
@@ -50,6 +50,9 @@
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/compiler/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/basic/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/basic/x86/*.java \
@@ -95,6 +98,9 @@
 AGENT_FILES2 = \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/ia64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/linux/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/linux_amd64/*.java \
--- hotspot/src/cpu/x86/vm/bytes_x86.hpp
+++ hotspot/src/cpu/x86/vm/bytes_x86.hpp
@@ -81,6 +81,9 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "bytes_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "bytes_bsd_x86.inline.hpp"
+#endif
 
 
 #endif // CPU_X86_VM_BYTES_X86_HPP
--- hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp
+++ hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp
@@ -481,8 +481,8 @@
   // Fetch the exception from TLS and clear out exception related thread state
   __ get_thread(rsi);
   __ movptr(rax, Address(rsi, JavaThread::exception_oop_offset()));
-  __ movptr(Address(rsi, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);
-  __ movptr(Address(rsi, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
+  __ movptr(Address(rsi, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
+  __ movptr(Address(rsi, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 
   __ bind(_unwind_handler_entry);
   __ verify_not_null_oop(rax);
--- hotspot/src/cpu/x86/vm/copy_x86.hpp
+++ hotspot/src/cpu/x86/vm/copy_x86.hpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "copy_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "copy_bsd_x86.inline.hpp"
+#endif
 
 
 static void pd_fill_to_words(HeapWord* tohw, size_t count, juint value) {
--- hotspot/src/cpu/x86/vm/interp_masm_x86_32.cpp
+++ hotspot/src/cpu/x86/vm/interp_masm_x86_32.cpp
@@ -45,6 +45,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 // Implementation of InterpreterMacroAssembler
@@ -1170,7 +1173,7 @@
   int recvr_offset = in_bytes(VirtualCallData::receiver_offset(start_row));
   set_mdp_data_at(mdp, recvr_offset, receiver);
   int count_offset = in_bytes(VirtualCallData::receiver_count_offset(start_row));
-  movptr(reg2, (int32_t)DataLayout::counter_increment);
+  movptr(reg2, (intptr_t)DataLayout::counter_increment);
   set_mdp_data_at(mdp, count_offset, reg2);
   if (start_row > 0) {
     jmp(done);
@@ -1313,7 +1316,7 @@
     test_method_data_pointer(mdp, profile_continue);
 
     // Build the base (index * per_case_size_in_bytes()) + case_array_offset_in_bytes()
-    movptr(reg2, (int32_t)in_bytes(MultiBranchData::per_case_size()));
+    movptr(reg2, (intptr_t)in_bytes(MultiBranchData::per_case_size()));
     // index is positive and so should have correct value if this code were
     // used on 64bits
     imulptr(index, reg2);
--- hotspot/src/cpu/x86/vm/interp_masm_x86_64.cpp
+++ hotspot/src/cpu/x86/vm/interp_masm_x86_64.cpp
@@ -45,6 +45,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 // Implementation of InterpreterMacroAssembler
--- hotspot/src/cpu/x86/vm/jni_x86.h
+++ hotspot/src/cpu/x86/vm/jni_x86.h
@@ -26,7 +26,7 @@
 #ifndef _JAVASOFT_JNI_MD_H_
 #define _JAVASOFT_JNI_MD_H_
 
-#if defined(SOLARIS) || defined(LINUX)
+#if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
   #define JNIEXPORT
   #define JNIIMPORT
   #define JNICALL
--- hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp
+++ hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp
@@ -47,6 +47,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifdef COMPILER2
 #include "opto/runtime.hpp"
 #endif
--- hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp
+++ hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp
@@ -47,6 +47,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifdef COMPILER2
 #include "opto/runtime.hpp"
 #endif
--- hotspot/src/cpu/x86/vm/stubRoutines_x86_32.cpp
+++ hotspot/src/cpu/x86/vm/stubRoutines_x86_32.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Implementation of the platform-specific part of StubRoutines - for
 // a description of how to extend it, see the stubRoutines.hpp file.
--- hotspot/src/cpu/x86/vm/stubRoutines_x86_64.cpp
+++ hotspot/src/cpu/x86/vm/stubRoutines_x86_64.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Implementation of the platform-specific part of StubRoutines - for
 // a description of how to extend it, see the stubRoutines.hpp file.
--- hotspot/src/cpu/x86/vm/vm_version_x86.cpp
+++ hotspot/src/cpu/x86/vm/vm_version_x86.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 int VM_Version::_cpu;
--- hotspot/src/cpu/zero/vm/bytes_zero.hpp
+++ hotspot/src/cpu/zero/vm/bytes_zero.hpp
@@ -168,6 +168,9 @@
 #ifdef TARGET_OS_ARCH_linux_zero
 # include "bytes_linux_zero.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "bytes_bsd_zero.inline.hpp"
+#endif
 
 #endif // VM_LITTLE_ENDIAN
 
--- hotspot/src/cpu/zero/vm/interp_masm_zero.cpp
+++ hotspot/src/cpu/zero/vm/interp_masm_zero.cpp
@@ -40,5 +40,8 @@
 #ifdef TARGET_OS_FAMILY_linux
 # include "thread_linux.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // This file is intentionally empty
--- hotspot/src/cpu/zero/vm/stubGenerator_zero.cpp
+++ hotspot/src/cpu/zero/vm/stubGenerator_zero.cpp
@@ -43,6 +43,9 @@
 #ifdef TARGET_OS_FAMILY_linux
 # include "thread_linux.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifdef COMPILER2
 #include "opto/runtime.hpp"
 #endif
--- hotspot/src/cpu/zero/vm/stubRoutines_zero.cpp
+++ hotspot/src/cpu/zero/vm/stubRoutines_zero.cpp
@@ -30,6 +30,9 @@
 #ifdef TARGET_OS_FAMILY_linux
 # include "thread_linux.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifdef IA32
 address StubRoutines::x86::_call_stub_compiled_return = NULL;
--- hotspot/src/cpu/zero/vm/vm_version_zero.cpp
+++ hotspot/src/cpu/zero/vm/vm_version_zero.cpp
@@ -32,5 +32,8 @@
 #ifdef TARGET_OS_FAMILY_linux
 # include "os_linux.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 // This file is intentionally empty
--- hotspot/src/os/bsd/vm/attachListener_bsd.cpp
+++ hotspot/src/os/bsd/vm/attachListener_bsd.cpp
@@ -170,53 +170,41 @@
 // Initialization - create a listener socket and bind it to a file
 
 int BsdAttachListener::init() {
-  char path[UNIX_PATH_MAX];          // socket file
-  char initial_path[UNIX_PATH_MAX];  // socket file during setup
-  int listener;                      // listener socket (file descriptor)
+  char path[UNIX_PATH_MAX];        // socket file
+  int listener;                 // listener socket (file descriptor)
 
   // register function to cleanup
   ::atexit(listener_cleanup);
 
-  int n = snprintf(path, UNIX_PATH_MAX, "%s/.java_pid%d",
-                   os::get_temp_directory(), os::current_process_id());
-  if (n < (int)UNIX_PATH_MAX) {
-    n = snprintf(initial_path, UNIX_PATH_MAX, "%s.tmp", path);
-  }
-  if (n >= (int)UNIX_PATH_MAX) {
-    return -1;
-  }
-
   // create the listener socket
   listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
   if (listener == -1) {
     return -1;
   }
 
-  // bind socket
+  int res = -1;
   struct sockaddr_un addr;
   addr.sun_family = AF_UNIX;
-  strcpy(addr.sun_path, initial_path);
-  ::unlink(initial_path);
-  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
+
+  snprintf(path, UNIX_PATH_MAX, "%s/.java_pid%d",
+           os::get_temp_directory(), os::current_process_id());
+  strcpy(addr.sun_path, path);
+  ::unlink(path);
+  res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
   if (res == -1) {
     RESTARTABLE(::close(listener), res);
     return -1;
   }
+  set_path(path);
 
-  // put in listen mode, set permissions, and rename into place
-  res = ::listen(listener, 5);
-  if (res == 0) {
-      RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);
-      if (res == 0) {
-          res = ::rename(initial_path, path);
-      }
-  }
-  if (res == -1) {
+  // put in listen mode and set permission and ownership
+  if ((::listen(listener, 5) == -1) || (::chmod(path, S_IREAD|S_IWRITE) == -1) ||
+      (::chown(path, geteuid(), getegid()) == -1)) {
     RESTARTABLE(::close(listener), res);
-    ::unlink(initial_path);
+    ::unlink(path);
+    set_path(NULL);
     return -1;
   }
-  set_path(path);
   set_listener(listener);
 
   return 0;
@@ -337,6 +325,15 @@
 
     // get the credentials of the peer and check the effective uid/guid
     // - check with jeff on this.
+#ifdef _ALLBSD_SOURCE
+    uid_t puid;
+    gid_t pgid;
+    if (::getpeereid(s, &puid, &pgid) != 0) {
+      int res;
+      RESTARTABLE(::close(s), res);
+      continue;
+    }
+#else
     struct ucred cred_info;
     socklen_t optlen = sizeof(cred_info);
     if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
@@ -344,10 +341,13 @@
       RESTARTABLE(::close(s), res);
       continue;
     }
+    uid_t puid = cred_info.uid;
+    gid_t pgid = cred_info.gid;
+#endif
     uid_t euid = geteuid();
     gid_t egid = getegid();
 
-    if (cred_info.uid != euid || cred_info.gid != egid) {
+    if (puid != euid || pgid != egid) {
       int res;
       RESTARTABLE(::close(s), res);
       continue;
@@ -467,16 +467,13 @@
   if (init_at_startup() || is_initialized()) {
     return false;               // initialized at startup or already initialized
   }
-  char fn[PATH_MAX+1];
-  sprintf(fn, ".attach_pid%d", os::current_process_id());
+  char path[PATH_MAX + 1];
   int ret;
-  struct stat64 st;
-  RESTARTABLE(::stat64(fn, &st), ret);
-  if (ret == -1) {
-    snprintf(fn, sizeof(fn), "%s/.attach_pid%d",
-             os::get_temp_directory(), os::current_process_id());
-    RESTARTABLE(::stat64(fn, &st), ret);
-  }
+  struct stat st;
+
+  snprintf(path, PATH_MAX + 1, "%s/.attach_pid%d",
+           os::get_temp_directory(), os::current_process_id());
+  RESTARTABLE(::stat(path, &st), ret);
   if (ret == 0) {
     // simple check to avoid starting the attach mechanism when
     // a bogus user creates the file
--- hotspot/src/os/bsd/vm/jsig.c
+++ hotspot/src/os/bsd/vm/jsig.c
@@ -143,7 +143,8 @@
 }
 
 sa_handler_t sigset(int sig, sa_handler_t disp) {
-  return set_signal(sig, disp, true);
+  printf("sigset() is not supported by BSD");
+  exit(0);
  }
 
 static int call_os_sigaction(int sig, const struct sigaction  *act,
--- hotspot/src/os/bsd/vm/jvm_bsd.cpp
+++ hotspot/src/os/bsd/vm/jvm_bsd.cpp
@@ -146,38 +146,31 @@
   "ILL",        SIGILL,         /* Illegal instruction (ANSI).  */
   "TRAP",       SIGTRAP,        /* Trace trap (POSIX).  */
   "ABRT",       SIGABRT,        /* Abort (ANSI).  */
-  "IOT",        SIGIOT,         /* IOT trap (4.2 BSD).  */
-  "BUS",        SIGBUS,         /* BUS error (4.2 BSD).  */
+  "EMT",	SIGEMT,		/* EMT trap  */
   "FPE",        SIGFPE,         /* Floating-point exception (ANSI).  */
   "KILL",       SIGKILL,        /* Kill, unblockable (POSIX).  */
-  "USR1",       SIGUSR1,        /* User-defined signal 1 (POSIX).  */
+  "BUS",	SIGBUS,		/* BUS error (4.2 BSD).  */
   "SEGV",       SIGSEGV,        /* Segmentation violation (ANSI).  */
-  "USR2",       SIGUSR2,        /* User-defined signal 2 (POSIX).  */
+  "SYS",	SIGSYS,		/* Bad system call. Only on some Bsden! */
   "PIPE",       SIGPIPE,        /* Broken pipe (POSIX).  */
   "ALRM",       SIGALRM,        /* Alarm clock (POSIX).  */
   "TERM",       SIGTERM,        /* Termination (ANSI).  */
-#ifdef SIGSTKFLT
-  "STKFLT",     SIGSTKFLT,      /* Stack fault.  */
-#endif
-  "CLD",        SIGCLD,         /* Same as SIGCHLD (System V).  */
-  "CHLD",       SIGCHLD,        /* Child status has changed (POSIX).  */
-  "CONT",       SIGCONT,        /* Continue (POSIX).  */
+  "URG",	SIGURG,		/* Urgent condition on socket (4.2 BSD).  */
   "STOP",       SIGSTOP,        /* Stop, unblockable (POSIX).  */
   "TSTP",       SIGTSTP,        /* Keyboard stop (POSIX).  */
+  "CONT",	SIGCONT,	/* Continue (POSIX).  */
+  "CHLD",	SIGCHLD,	/* Child status has changed (POSIX).  */
   "TTIN",       SIGTTIN,        /* Background read from tty (POSIX).  */
   "TTOU",       SIGTTOU,        /* Background write to tty (POSIX).  */
-  "URG",        SIGURG,         /* Urgent condition on socket (4.2 BSD).  */
+  "IO",		SIGIO,		/* I/O now possible (4.2 BSD).  */
   "XCPU",       SIGXCPU,        /* CPU limit exceeded (4.2 BSD).  */
   "XFSZ",       SIGXFSZ,        /* File size limit exceeded (4.2 BSD).  */
   "VTALRM",     SIGVTALRM,      /* Virtual alarm clock (4.2 BSD).  */
   "PROF",       SIGPROF,        /* Profiling alarm clock (4.2 BSD).  */
   "WINCH",      SIGWINCH,       /* Window size change (4.3 BSD, Sun).  */
-  "POLL",       SIGPOLL,        /* Pollable event occurred (System V).  */
-  "IO",         SIGIO,          /* I/O now possible (4.2 BSD).  */
-  "PWR",        SIGPWR,         /* Power failure restart (System V).  */
-#ifdef SIGSYS
-  "SYS",        SIGSYS          /* Bad system call. Only on some Bsden! */
-#endif
+  "INFO",	SIGINFO,	/* Information request.  */
+  "USR1",	SIGUSR1,	/* User-defined signal 1 (POSIX).  */
+  "USR2",	SIGUSR2		/* User-defined signal 2 (POSIX).  */
   };
 
 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
--- hotspot/src/os/bsd/vm/jvm_bsd.h
+++ hotspot/src/os/bsd/vm/jvm_bsd.h
@@ -54,7 +54,11 @@
 #define AGENT_ONATTACH_SYMBOLS  {"Agent_OnAttach"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
 #define JNI_LIB_SUFFIX ".so"
+#endif
 
 // Hack: MAXPATHLEN is 4095 on some Bsd and 4096 on others. This may
 //       cause problems if JVM and the rest of JDK are built on different
@@ -93,6 +97,20 @@
 #define SHUTDOWN2_SIGNAL SIGINT
 #define SHUTDOWN3_SIGNAL SIGTERM
 
+#ifndef SIGRTMIN
+#ifdef __OpenBSD__
+#define SIGRTMIN	1
+#else
+#define SIGRTMIN	33
+#endif
+#endif
+#ifndef SIGRTMAX
+#ifdef __OpenBSD__
+#define SIGRTMAX	31
+#else
+#define SIGRTMAX	63
+#endif
+#endif
 #endif /* JVM_MD_H */
 
 // Reconciliation History
--- hotspot/src/os/bsd/vm/osThread_bsd.cpp
+++ hotspot/src/os/bsd/vm/osThread_bsd.cpp
@@ -43,8 +43,12 @@
 
 void OSThread::pd_initialize() {
   assert(this != NULL, "check");
+#ifdef __FreeBSD__
   _thread_id        = 0;
-  _pthread_id       = 0;
+#else
+  _thread_id        = NULL;
+#endif
+  _pthread_id       = NULL;
   _siginfo = NULL;
   _ucontext = NULL;
   _expanding_stack = 0;
--- hotspot/src/os/bsd/vm/osThread_bsd.hpp
+++ hotspot/src/os/bsd/vm/osThread_bsd.hpp
@@ -39,6 +39,7 @@
 
  private:
 
+#ifdef __FreeBSD__
   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
   // to access /proc.
@@ -47,6 +48,12 @@
   // _pthread_id is the pthread id, which is used by library calls
   // (e.g. pthread_kill).
   pthread_t _pthread_id;
+#else
+  // _thread_id and _pthread_id are the same on BSD
+  // keep both to minimize code divergence in os_bsd.cpp
+  pthread_t _thread_id;
+  pthread_t _pthread_id;
+#endif
 
   sigset_t _caller_sigmask; // Caller's signal mask
 
@@ -56,12 +63,22 @@
   sigset_t  caller_sigmask() const       { return _caller_sigmask; }
   void    set_caller_sigmask(sigset_t sigmask)  { _caller_sigmask = sigmask; }
 
+#ifdef __FreeBSD__
   pid_t thread_id() const {
     return _thread_id;
   }
+#else
+  pthread_t thread_id() const {
+    return _thread_id;
+  }
+#endif
 #ifndef PRODUCT
   // Used for debugging, return a unique integer for each thread.
+#ifdef __FreeBSD__
   int thread_identifier() const   { return _thread_id; }
+#else
+  intptr_t thread_identifier() const   { return (intptr_t)_pthread_id; }
+#endif
 #endif
 #ifdef ASSERT
   // We expect no reposition failures so kill vm if we get one.
@@ -70,9 +87,15 @@
     return false;
   }
 #endif // ASSERT
+#ifdef __FreeBSD__
   void set_thread_id(pid_t id) {
     _thread_id = id;
   }
+#else
+  void set_thread_id(pthread_t id) {
+    _thread_id = id;
+  }
+#endif
   pthread_t pthread_id() const {
     return _pthread_id;
   }
--- hotspot/src/os/bsd/vm/os_bsd.cpp
+++ hotspot/src/os/bsd/vm/os_bsd.cpp
@@ -88,7 +88,6 @@
 # include <sys/mman.h>
 # include <sys/stat.h>
 # include <sys/select.h>
-# include <pthread.h>
 # include <signal.h>
 # include <errno.h>
 # include <dlfcn.h>
@@ -102,21 +101,57 @@
 # include <sys/utsname.h>
 # include <sys/socket.h>
 # include <sys/wait.h>
+# include <time.h>
 # include <pwd.h>
 # include <poll.h>
 # include <semaphore.h>
 # include <fcntl.h>
 # include <string.h>
+#ifdef _ALLBSD_SOURCE
+# include <sys/param.h>
+# include <sys/sysctl.h>
+#else
 # include <syscall.h>
 # include <sys/sysinfo.h>
 # include <gnu/libc-version.h>
+#endif
 # include <sys/ipc.h>
 # include <sys/shm.h>
-# include <link.h>
 # include <stdint.h>
 # include <inttypes.h>
 # include <sys/ioctl.h>
 
+#ifdef __FreeBSD__
+#if __FreeBSD_version > 700109
+#include <bitset>
+#include <sys/cpuset.h>
+#endif
+#include <vm/swap_pager.h>
+#include <vm/vm_param.h>
+#if __FreeBSD_version > 900030
+#include <pthread_np.h>
+#else
+extern "C" int thr_self(long *); // XXX #include <sys/thr.h>
+#endif
+#endif
+
+#ifndef __APPLE__
+# include <link.h>
+#endif
+
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+# include <elf.h>
+#endif
+
+#ifdef __APPLE__
+#include <mach/mach.h> // semaphore_* API
+#include <mach-o/dyld.h>
+#endif
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
 #define MAX_PATH    (2 * K)
 
 // for timer info max values which include all bits
@@ -127,19 +162,25 @@
 // global variables
 julong os::Bsd::_physical_memory = 0;
 
+#ifndef _ALLBSD_SOURCE
 address   os::Bsd::_initial_thread_stack_bottom = NULL;
 uintptr_t os::Bsd::_initial_thread_stack_size   = 0;
+#endif
 
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+#ifndef _ALLBSD_SOURCE
 int (*os::Bsd::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 Mutex* os::Bsd::_createThread_lock = NULL;
+#endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
+#ifndef _ALLBSD_SOURCE
 bool os::Bsd::_is_floating_stack = false;
 bool os::Bsd::_is_NPTL = false;
 bool os::Bsd::_supports_fast_thread_cpu_time = false;
 const char * os::Bsd::_glibc_version = NULL;
 const char * os::Bsd::_libpthread_version = NULL;
+#endif
 
 static jlong initial_time_count=0;
 
@@ -157,8 +198,6 @@
 static int SR_signum = SIGUSR2;
 sigset_t SR_sigset;
 
-/* Used to protect dlsym() calls */
-static pthread_mutex_t dl_mutex;
 
 ////////////////////////////////////////////////////////////////////////////////
 // utility functions
@@ -171,11 +210,38 @@
 }
 
 julong os::Bsd::available_memory() {
+#ifdef _ALLBSD_SOURCE
+#ifdef __FreeBSD__
+  static const char *vm_stats[] = {
+    "vm.stats.vm.v_free_count",
+    "vm.stats.vm.v_cache_count",
+    /* "vm.stats.vm.v_inactive_count", */
+    NULL
+  };
+  size_t size;
+  julong free_pages;
+  u_int i, npages;
+
+  for (i = 0, free_pages = 0, size = sizeof(npages); vm_stats[i] != NULL; i++) {
+    if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1) {
+      free_pages = 0;
+      break;
+    }
+    free_pages += npages;
+  }
+  if (free_pages > 0)
+    free_pages *= os::vm_page_size();
+  else
+#endif
+  // XXXBSD: this is just a stopgap implementation
+  return physical_memory() >> 2;
+#else
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
 
   return (julong)si.freeram * si.mem_unit;
+#endif
 }
 
 julong os::physical_memory() {
@@ -223,6 +289,7 @@
 }
 
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_gettid
 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 #ifdef __ia64__
@@ -237,6 +304,7 @@
 #error define gettid for the arch
 #endif
 #endif
+#endif
 
 // Cpu architecture string
 #if   defined(ZERO)
@@ -267,28 +335,86 @@
 // Returns the kernel thread id of the currently running thread. Kernel
 // thread id is used to access /proc.
 //
-// (Note that getpid() on BsdThreads returns kernel thread id too; but
-// on NPTL, it returns the same pid for all threads, as required by POSIX.)
-//
+#ifdef __FreeBSD__
 pid_t os::Bsd::gettid() {
-  int rslt = syscall(SYS_gettid);
-  if (rslt == -1) {
-     // old kernel, no NPTL support
-     return getpid();
-  } else {
-     return (pid_t)rslt;
-  }
+#if __FreeBSD_version > 900030
+  return pthread_getthreadid_np();
+#else
+  long tid;
+  thr_self(&tid);
+  return (pid_t)tid;
+#endif
+}
+#endif
+
+#if defined(__FreeBSD__)
+void os::Bsd::initialize_system_info() {
+  int cpu_val = sysconf(_SC_NPROCESSORS_CONF);
+  if (cpu_val >= 1)
+    set_processor_count(cpu_val);
+  else
+    set_processor_count(1);   // fallback
+
+#ifdef _SC_PHYS_PAGES
+  long phys_pages = sysconf(_SC_PHYS_PAGES);
+  if (phys_pages > 0)
+    _physical_memory = (julong)phys_pages * _page_size;
+  else
+    _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+#else
+  int mib[2];
+  size_t len;
+  u_long mem_val;
+
+  mib[0] = CTL_HW;
+  mib[1] = HW_PHYSMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+    _physical_memory = mem_val;
+  else
+    _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+#endif
 }
+#elif defined(_ALLBSD_SOURCE)
+void os::Bsd::initialize_system_info() {
+  int mib[2];
+  size_t len;
+  int cpu_val;
+  u_long mem_val;
+
+  /* get processors count via hw.ncpus sysctl */
+  mib[0] = CTL_HW;
+  mib[1] = HW_NCPU;
+  len = sizeof(cpu_val);
+  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1 && cpu_val >= 1) {
+       set_processor_count(cpu_val);
+  }
+  else {
+       set_processor_count(1);   // fallback
+  }
 
-// Most versions of bsd have a bug where the number of processors are
-// determined by looking at the /proc file system.  In a chroot environment,
-// the system call returns 1.  This causes the VM to act as if it is
-// a single processor and elide locking (see is_MP() call).
-static bool unsafe_chroot_detected = false;
-static const char *unstable_chroot_error = "/proc file system not found.\n"
-                     "Java may be unstable running multithreaded in a chroot "
-                     "environment on Bsd when /proc filesystem is not mounted.";
+  /* get physical memory via hw.usermem sysctl (hw.usermem is used
+   * instead of hw.physmem because we need size of allocatable memory
+   */
+  mib[0] = CTL_HW;
+  mib[1] = HW_USERMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+       _physical_memory = mem_val;
+  else
+       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
 
+#ifdef __OpenBSD__
+  {
+       // limit _physical_memory memory view on OpenBSD since
+       // datasize rlimit restricts us anyway.
+       struct rlimit limits;
+       getrlimit(RLIMIT_DATA, &limits);
+       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);
+  }
+#endif
+}
+#else
 void os::Bsd::initialize_system_info() {
   set_processor_count(sysconf(_SC_NPROCESSORS_CONF));
   if (processor_count() == 1) {
@@ -305,6 +431,7 @@
   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);
   assert(processor_count() > 0, "bsd error");
 }
+#endif
 
 void os::init_system_properties_values() {
 //  char arch[12];
@@ -348,9 +475,7 @@
  *        ...
  *        7: The default directories, normally /lib and /usr/lib.
  */
-#if defined(AMD64) || defined(_LP64) && (defined(SPARC) || defined(PPC) || defined(S390))
-#define DEFAULT_LIBPATH "/usr/lib64:/lib64:/lib:/usr/lib"
-#else
+#ifndef DEFAULT_LIBPATH
 #define DEFAULT_LIBPATH "/lib:/usr/lib"
 #endif
 
@@ -429,7 +554,11 @@
          * should always exist (until the legacy problem cited above is
          * addressed).
          */
+#ifdef __APPLE__
+        char *v = getenv("DYLD_LIBRARY_PATH");
+#else
         char *v = getenv("LD_LIBRARY_PATH");
+#endif
         if (v != NULL) {
             char *t = ld_library_path;
             /* That's +1 for the colon and +1 for the trailing '\0' */
@@ -588,6 +717,7 @@
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 //////////////////////////////////////////////////////////////////////////////
 // detecting pthread library
 
@@ -751,6 +881,7 @@
   }
   return false;
 }
+#endif
 
 //////////////////////////////////////////////////////////////////////////////
 // create new thread
@@ -759,6 +890,9 @@
 
 // check if it's safe to start a new thread
 static bool _thread_safety_check(Thread* thread) {
+#ifdef _ALLBSD_SOURCE
+    return true;
+#else
   if (os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack()) {
     // Fixed stack BsdThreads (SuSE Bsd/x86, and some versions of Redhat)
     //   Heap is mmap'ed at lower end of memory space. Thread stacks are
@@ -792,6 +926,7 @@
     //   here, that means enough space has been reserved for stack.
     return true;
   }
+#endif
 }
 
 // Thread start routine for all newly created threads
@@ -819,15 +954,22 @@
     return NULL;
   }
 
+#ifdef __FreeBSD__
   // thread_id is kernel thread id (similar to Solaris LWP id)
   osthread->set_thread_id(os::Bsd::gettid());
+#else
+  // thread_id is pthread_id on BSD
+  osthread->set_thread_id(::pthread_self());
+#endif
 
+#ifndef _ALLBSD_SOURCE
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
       thread->set_lgrp_id(lgrp_id);
     }
   }
+#endif
   // initialize signal mask for this thread
   os::Bsd::hotspot_sigmask(thread);
 
@@ -910,17 +1052,22 @@
     // let pthread_create() pick the default value.
   }
 
+#ifndef _ALLBSD_SOURCE
   // glibc guard page
   pthread_attr_setguardsize(&attr, os::Bsd::default_guard_size(thr_type));
+#endif
 
   ThreadState state;
 
   {
+
+#ifndef _ALLBSD_SOURCE
     // Serialize thread creation if we are running with fixed stack BsdThreads
     bool lock = os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack();
     if (lock) {
       os::Bsd::createThread_lock()->lock_without_safepoint_check();
     }
+#endif
 
     pthread_t tid;
     int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
@@ -934,7 +1081,9 @@
       // Need to clean up stuff we've allocated so far
       thread->set_osthread(NULL);
       delete osthread;
+#ifndef _ALLBSD_SOURCE
       if (lock) os::Bsd::createThread_lock()->unlock();
+#endif
       return false;
     }
 
@@ -950,9 +1099,11 @@
       }
     }
 
+#ifndef _ALLBSD_SOURCE
     if (lock) {
       os::Bsd::createThread_lock()->unlock();
     }
+#endif
   }
 
   // Aborted due to thread limit being reached
@@ -990,7 +1141,11 @@
   }
 
   // Store pthread info into the OSThread
+#ifdef __FreeBSD__
   osthread->set_thread_id(os::Bsd::gettid());
+#else
+  osthread->set_thread_id(::pthread_self());
+#endif
   osthread->set_pthread_id(::pthread_self());
 
   // initialize floating point control register
@@ -1001,6 +1156,7 @@
 
   thread->set_osthread(osthread);
 
+#ifndef _ALLBSD_SOURCE
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
@@ -1027,6 +1183,7 @@
     os::Bsd::manually_expand_stack(jt, addr);
     osthread->clear_expanding_stack();
   }
+#endif
 
   // initialize signal mask for this thread
   // and save the caller's signal mask
@@ -1085,6 +1242,7 @@
 //////////////////////////////////////////////////////////////////////////////
 // initial thread
 
+#ifndef _ALLBSD_SOURCE
 // Check if current thread is the initial thread, similar to Solaris thr_main.
 bool os::Bsd::is_initial_thread(void) {
   char dummy;
@@ -1321,6 +1479,7 @@
   _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());
   _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;
 }
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 // time support
@@ -1342,9 +1501,7 @@
   return (1000 * 1000);
 }
 
-// For now, we say that bsd does not support vtime.  I have no idea
-// whether it can actually be made to (DLD, 9/13/05).
-
+// XXX: For now, code this as if BSD does not support vtime.
 bool os::supports_vtime() { return false; }
 bool os::enable_vtime()   { return false; }
 bool os::vtime_enabled()  { return false; }
@@ -1364,6 +1521,21 @@
 #define CLOCK_MONOTONIC (1)
 #endif
 
+#ifdef __APPLE__
+void os::Bsd::clock_init() {
+	// XXXDARWIN: Investigate replacement monotonic clock
+}
+#elif defined(_ALLBSD_SOURCE)
+void os::Bsd::clock_init() {
+  struct timespec res;
+  struct timespec tp;
+  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
+      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
+    // yes, monotonic clock is supported
+    _clock_gettime = ::clock_gettime;
+  }
+}
+#else
 void os::Bsd::clock_init() {
   // we do dlopen's in this particular order due to bug in bsd
   // dynamical loader (see 6348968) leading to crash on exit
@@ -1399,7 +1571,9 @@
     }
   }
 }
+#endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_clock_getres
 
 #if defined(IA32) || defined(AMD64)
@@ -1440,6 +1614,7 @@
     _pthread_getcpuclockid = pthread_getcpuclockid_func;
   }
 }
+#endif
 
 jlong os::javaTimeNanos() {
   if (Bsd::supports_monotonic_clock()) {
@@ -1608,7 +1783,14 @@
 
 // DLL functions
 
-const char* os::dll_file_extension() { return ".so"; }
+#define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
+#define JNI_LIB_SUFFIX ".so"
+#endif
+
+const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
 
 // This must be hard coded because it's the system's temporary
 // directory not the java application's temp directory, ala java.io.tmpdir.
@@ -1628,13 +1810,13 @@
   const size_t pnamelen = pname ? strlen(pname) : 0;
 
   // Quietly truncate on buffer overflow.  Should be an error.
-  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {
+  if (pnamelen + strlen(fname) + strlen(JNI_LIB_PREFIX) + strlen(JNI_LIB_SUFFIX) + 2 > buflen) {
     *buffer = '\0';
     return;
   }
 
   if (pnamelen == 0) {
-    snprintf(buffer, buflen, "lib%s.so", fname);
+    snprintf(buffer, buflen, JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX, fname);
   } else if (strchr(pname, *os::path_separator()) != NULL) {
     int n;
     char** pelements = split_path(pname, &n);
@@ -1643,7 +1825,8 @@
       if (pelements[i] == NULL || strlen(pelements[i]) == 0) {
         continue; // skip the empty path values
       }
-      snprintf(buffer, buflen, "%s/lib%s.so", pelements[i], fname);
+      snprintf(buffer, buflen, "%s/" JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX,
+          pelements[i], fname);
       if (file_exists(buffer)) {
         break;
       }
@@ -1658,7 +1841,7 @@
       FREE_C_HEAP_ARRAY(char*, pelements);
     }
   } else {
-    snprintf(buffer, buflen, "%s/lib%s.so", pname, fname);
+    snprintf(buffer, buflen, "%s/" JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX, pname, fname);
   }
 }
 
@@ -1708,6 +1891,23 @@
   return false;
 }
 
+#ifdef _ALLBSD_SOURCE
+// ported from solaris version
+bool os::dll_address_to_library_name(address addr, char* buf,
+                                     int buflen, int* offset) {
+  Dl_info dlinfo;
+
+  if (dladdr((void*)addr, &dlinfo)){
+     if (buf) jio_snprintf(buf, buflen, "%s", dlinfo.dli_fname);
+     if (offset) *offset = addr - (address)dlinfo.dli_fbase;
+     return true;
+  } else {
+     if (buf) buf[0] = '\0';
+     if (offset) *offset = -1;
+     return false;
+  }
+}
+#else
 struct _address_to_library_name {
   address addr;          // input : memory address
   size_t  buflen;        //         size of fname
@@ -1782,11 +1982,27 @@
      return false;
   }
 }
+#endif
 
   // Loads .dll/.so and
   // in case of error it checks if .dll/.so was built for the
   // same architecture as Hotspot is running on
+ 
+#ifdef __APPLE__
+void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
+  void * result= ::dlopen(filename, RTLD_LAZY);
+  if (result != NULL) {
+    // Successful loading
+    return result;
+  }
+
+  // Read system error message into ebuf
+  ::strncpy(ebuf, ::dlerror(), ebuflen-1);
+  ebuf[ebuflen-1]='\0';
 
+  return NULL;
+}
+#else
 void * os::dll_load(const char *filename, char *ebuf, int ebuflen)
 {
   void * result= ::dlopen(filename, RTLD_LAZY);
@@ -1839,6 +2055,26 @@
   #define EM_486          6               /* Intel 80486 */
   #endif
 
+  #ifndef EM_MIPS_RS3_LE
+  #define EM_MIPS_RS3_LE  10              /* MIPS */
+  #endif
+
+  #ifndef EM_PPC64
+  #define EM_PPC64        21              /* PowerPC64 */
+  #endif
+
+  #ifndef EM_S390
+  #define EM_S390         22              /* IBM System/390 */
+  #endif
+
+  #ifndef EM_IA_64
+  #define EM_IA_64        50              /* HP/Intel IA-64 */ 
+  #endif
+
+  #ifndef EM_X86_64
+  #define EM_X86_64       62              /* AMD x86-64 */ 
+  #endif
+
   static const arch_t arch_array[]={
     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
@@ -1942,17 +2178,11 @@
 
   return NULL;
 }
+#endif /* !__APPLE__ */
 
-/*
- * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,
- * chances are you might want to run the generated bits against glibc-2.0
- * libdl.so, so always use locking for any version of glibc.
- */
+// XXX: Do we need a lock around this as per Linux?
 void* os::dll_lookup(void* handle, const char* name) {
-  pthread_mutex_lock(&dl_mutex);
-  void* res = dlsym(handle, name);
-  pthread_mutex_unlock(&dl_mutex);
-  return res;
+  return dlsym(handle, name);
 }
 
 
@@ -1975,7 +2205,51 @@
 
 void os::print_dll_info(outputStream *st) {
    st->print_cr("Dynamic libraries:");
-
+#ifdef _ALLBSD_SOURCE
+#ifdef RTLD_DI_LINKMAP
+    Dl_info dli;
+    void *handle;
+    Link_map *map;
+    Link_map *p;
+
+    if (!dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli)) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    handle = dlopen(dli.dli_fname, RTLD_LAZY);
+    if (handle == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    dlinfo(handle, RTLD_DI_LINKMAP, &map);
+    if (map == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+
+    while (map->l_prev != NULL)
+        map = map->l_prev;
+
+    while (map != NULL) {
+        st->print_cr(PTR_FORMAT " \t%s", map->l_addr, map->l_name);
+        map = map->l_next;
+    }
+
+    dlclose(handle);
+#elif defined(__APPLE__)
+    uint32_t count;
+    uint32_t i;
+
+    count = _dyld_image_count();
+    for (i = 1; i < count; i++) {
+        const char *name = _dyld_get_image_name(i);
+        intptr_t slide = _dyld_get_image_vmaddr_slide(i);
+        st->print_cr(PTR_FORMAT " \t%s", slide, name);
+    }
+#else
+   st->print_cr("Error: Cannot print dynamic libraries.");
+#endif
+#else
    char fname[32];
    pid_t pid = os::Bsd::gettid();
 
@@ -1984,6 +2258,7 @@
    if (!_print_ascii_file(fname, st)) {
      st->print("Can not get library information for pid = %d\n", pid);
    }
+#endif
 }
 
 
@@ -2018,6 +2293,7 @@
   st->print(name.machine);
   st->cr();
 
+#ifndef _ALLBSD_SOURCE
   // Print warning if unsafe chroot environment detected
   if (unsafe_chroot_detected) {
     st->print("WARNING!! ");
@@ -2032,6 +2308,7 @@
      st->print("(%s stack)", os::Bsd::is_floating_stack() ? "floating" : "fixed");
   }
   st->cr();
+#endif
 
   // rlimit
   st->print("rlimit:");
@@ -2057,6 +2334,7 @@
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifndef _ALLBSD_SOURCE
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
@@ -2069,11 +2347,7 @@
   os::loadavg(loadavg, 3);
   st->print("%0.02f %0.02f %0.02f", loadavg[0], loadavg[1], loadavg[2]);
   st->cr();
-
-  // meminfo
-  st->print("\n/proc/meminfo:\n");
-  _print_ascii_file("/proc/meminfo", st);
-  st->cr();
+#endif
 }
 
 void os::print_memory_info(outputStream* st) {
@@ -2081,19 +2355,55 @@
   st->print("Memory:");
   st->print(" %dk page", os::vm_page_size()>>10);
 
+#ifdef _ALLBSD_SOURCE
+#ifdef __FreeBSD__
+  struct xswdev xsw;
+  size_t mibsize, size;
+  int mib[16], n, total = 0, used = 0;
+
+  mibsize = sizeof(mib) / sizeof(mib[0]);
+  if (sysctlnametomib("vm.swap_info", mib, &mibsize) != -1) {
+    for (n = 0; ; n++) {
+      mib[mibsize] = n;
+      size = sizeof(xsw);
+      if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+        break;
+      total += xsw.xsw_nblks;
+      used += xsw.xsw_used;
+    }
+  }
+#endif
+#else
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
+#endif
 
   st->print(", physical " UINT64_FORMAT "k",
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
+#ifdef _ALLBSD_SOURCE
+#ifdef __FreeBSD__
+  st->print(", swap " UINT64_FORMAT "k",
+            ((jlong)total * os::vm_page_size()) >> 10);
+  st->print("(" UINT64_FORMAT "k free)",
+            ((jlong)(total - used) * os::vm_page_size()) >> 10);
+#endif
+#else
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             ((jlong)si.freeswap * si.mem_unit) >> 10);
+#endif
+  st->cr();
+
+#ifndef _ALLBSD_SOURCE
+  // meminfo
+  st->print("\n/proc/meminfo:\n");
+  _print_ascii_file("/proc/meminfo", st);
   st->cr();
+#endif
 }
 
 // Taken from /usr/include/bits/siginfo.h  Supposed to be architecture specific
@@ -2333,19 +2643,29 @@
 static volatile jint pending_signals[NSIG+1] = { 0 };
 
 // Bsd(POSIX) specific hand shaking semaphore.
+#ifdef __APPLE__
+static semaphore_t sig_sem;
+#define SEM_INIT(sem, value)	semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, value)
+#define SEM_WAIT(sem)		semaphore_wait(sem);
+#define SEM_POST(sem)		semaphore_signal(sem);
+#else
 static sem_t sig_sem;
+#define SEM_INIT(sem, value)	sem_init(&sem, 0, value)
+#define SEM_WAIT(sem)		sem_wait(&sem);
+#define SEM_POST(sem)		sem_post(&sem);
+#endif
 
 void os::signal_init_pd() {
   // Initialize signal structures
   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
 
   // Initialize signal semaphore
-  ::sem_init(&sig_sem, 0, 0);
+  ::SEM_INIT(sig_sem, 0);
 }
 
 void os::signal_notify(int sig) {
   Atomic::inc(&pending_signals[sig]);
-  ::sem_post(&sig_sem);
+  ::SEM_POST(sig_sem);
 }
 
 static int check_pending_signals(bool wait) {
@@ -2367,7 +2687,7 @@
     do {
       thread->set_suspend_equivalent();
       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
-      ::sem_wait(&sig_sem);
+      ::SEM_WAIT(sig_sem);
 
       // were we externally suspended while we were waiting?
       threadIsSuspended = thread->handle_special_suspend_equivalent_condition();
@@ -2378,7 +2698,7 @@
         // while suspended because that would surprise the thread that
         // suspended us.
         //
-        ::sem_post(&sig_sem);
+        ::SEM_POST(sig_sem);
 
         thread->java_suspend_self();
       }
@@ -2422,10 +2742,10 @@
     return;
   }
 
-  char buf[PATH_MAX+1];
+  char buf[PATH_MAX + 1];
   int num = Atomic::add(1, &cnt);
 
-  snprintf(buf, sizeof(buf), "%s/hs-vm-%d-%d",
+  snprintf(buf, PATH_MAX + 1, "%s/hs-vm-%d-%d",
            os::get_temp_directory(), os::current_process_id(), num);
   unlink(buf);
 
@@ -2451,9 +2771,14 @@
 //       problem.
 bool os::commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return ::mprotect(addr, size, prot) == 0;
+#else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                    MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res != (uintptr_t) MAP_FAILED;
+#endif
 }
 
 bool os::commit_memory(char* addr, size_t size, size_t alignment_hint,
@@ -2469,36 +2794,27 @@
 }
 
 void os::numa_make_global(char *addr, size_t bytes) {
-  Bsd::numa_interleave_memory(addr, bytes);
 }
 
 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {
-  Bsd::numa_tonode_memory(addr, bytes, lgrp_hint);
 }
 
 bool os::numa_topology_changed()   { return false; }
 
 size_t os::numa_get_groups_num() {
-  int max_node = Bsd::numa_max_node();
-  return max_node > 0 ? max_node + 1 : 1;
+  return 1;
 }
 
 int os::numa_get_group_id() {
-  int cpu_id = Bsd::sched_getcpu();
-  if (cpu_id != -1) {
-    int lgrp_id = Bsd::get_node_by_cpu(cpu_id);
-    if (lgrp_id != -1) {
-      return lgrp_id;
-    }
-  }
   return 0;
 }
 
 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
-  for (size_t i = 0; i < size; i++) {
-    ids[i] = i;
+  if (size > 0) {
+    ids[0] = 0;
+    return 1;
   }
-  return size;
+  return 0;
 }
 
 bool os::get_page_info(char *start, page_info* info) {
@@ -2509,6 +2825,7 @@
   return end;
 }
 
+#ifndef _ALLBSD_SOURCE
 extern "C" void numa_warn(int number, char *where, ...) { }
 extern "C" void numa_error(char *where) { }
 
@@ -2610,104 +2927,26 @@
 os::Bsd::numa_tonode_memory_func_t os::Bsd::_numa_tonode_memory;
 os::Bsd::numa_interleave_memory_func_t os::Bsd::_numa_interleave_memory;
 unsigned long* os::Bsd::_numa_all_nodes;
+#endif
 
 bool os::uncommit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return ::mprotect(addr, size, PROT_NONE) == 0;
+#else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                 MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
+#endif
 }
 
-// Bsd uses a growable mapping for the stack, and if the mapping for
-// the stack guard pages is not removed when we detach a thread the
-// stack cannot grow beyond the pages where the stack guard was
-// mapped.  If at some point later in the process the stack expands to
-// that point, the Bsd kernel cannot expand the stack any further
-// because the guard pages are in the way, and a segfault occurs.
-//
-// However, it's essential not to split the stack region by unmapping
-// a region (leaving a hole) that's already part of the stack mapping,
-// so if the stack mapping has already grown beyond the guard pages at
-// the time we create them, we have to truncate the stack mapping.
-// So, we need to know the extent of the stack mapping when
-// create_stack_guard_pages() is called.
-
-// Find the bounds of the stack mapping.  Return true for success.
-//
-// We only need this for stacks that are growable: at the time of
-// writing thread stacks don't use growable mappings (i.e. those
-// creeated with MAP_GROWSDOWN), and aren't marked "[stack]", so this
-// only applies to the main thread.
-static bool
-get_stack_bounds(uintptr_t *bottom, uintptr_t *top)
-{
-  FILE *f = fopen("/proc/self/maps", "r");
-  if (f == NULL)
-    return false;
-
-  while (!feof(f)) {
-    size_t dummy;
-    char *str = NULL;
-    ssize_t len = getline(&str, &dummy, f);
-    if (len == -1) {
-      fclose(f);
-      return false;
-    }
-
-    if (len > 0 && str[len-1] == '\n') {
-      str[len-1] = 0;
-      len--;
-    }
-
-    static const char *stack_str = "[stack]";
-    if (len > (ssize_t)strlen(stack_str)
-       && (strcmp(str + len - strlen(stack_str), stack_str) == 0)) {
-      if (sscanf(str, "%" SCNxPTR "-%" SCNxPTR, bottom, top) == 2) {
-        uintptr_t sp = (uintptr_t)__builtin_frame_address(0);
-        if (sp >= *bottom && sp <= *top) {
-          free(str);
-          fclose(f);
-          return true;
-        }
-      }
-    }
-    free(str);
-  }
-  fclose(f);
-  return false;
-}
-
-// If the (growable) stack mapping already extends beyond the point
-// where we're going to put our guard pages, truncate the mapping at
-// that point by munmap()ping it.  This ensures that when we later
-// munmap() the guard pages we don't leave a hole in the stack
-// mapping. This only affects the main/initial thread, but guard
-// against future OS changes
 bool os::create_stack_guard_pages(char* addr, size_t size) {
-  uintptr_t stack_extent, stack_base;
-  bool chk_bounds = NOT_DEBUG(os::Bsd::is_initial_thread()) DEBUG_ONLY(true);
-  if (chk_bounds && get_stack_bounds(&stack_extent, &stack_base)) {
-      assert(os::Bsd::is_initial_thread(),
-           "growable stack in non-initial thread");
-    if (stack_extent < (uintptr_t)addr)
-      ::munmap((void*)stack_extent, (uintptr_t)addr - stack_extent);
-  }
-
   return os::commit_memory(addr, size);
 }
 
 // If this is a growable mapping, remove the guard pages entirely by
-// munmap()ping them.  If not, just call uncommit_memory(). This only
-// affects the main/initial thread, but guard against future OS changes
+// munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  uintptr_t stack_extent, stack_base;
-  bool chk_bounds = NOT_DEBUG(os::Bsd::is_initial_thread()) DEBUG_ONLY(true);
-  if (chk_bounds && get_stack_bounds(&stack_extent, &stack_base)) {
-      assert(os::Bsd::is_initial_thread(),
-           "growable stack in non-initial thread");
-
-    return ::munmap(addr, size) == 0;
-  }
-
   return os::uncommit_memory(addr, size);
 }
 
@@ -2812,6 +3051,9 @@
 static size_t _large_page_size = 0;
 
 bool os::large_page_init() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   if (!UseLargePages) return false;
 
   if (LargePageSizeInBytes) {
@@ -2869,6 +3111,7 @@
   // We optimistically assume the support is available. If later it turns out
   // not true, VM will automatically switch to use regular page size.
   return true;
+#endif
 }
 
 #ifndef SHM_HUGETLB
@@ -3045,7 +3288,7 @@
 }
 
 size_t os::read(int fd, void *buf, unsigned int nBytes) {
-  return ::read(fd, buf, nBytes);
+  RESTARTABLE_RETURN_INT(::read(fd, buf, nBytes));
 }
 
 // TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.
@@ -3181,6 +3424,44 @@
 // this reason, the code should not be used as default (ThreadPriorityPolicy=0).
 // It is only used when ThreadPriorityPolicy=1 and requires root privilege.
 
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__)
+int os::java_to_os_priority[MaxPriority + 1] = {
+  19,              // 0 Entry should never be used
+
+   0,              // 1 MinPriority
+   3,              // 2
+   6,              // 3
+
+   10,              // 4
+   15,              // 5 NormPriority
+   18,              // 6
+
+   21,              // 7
+   25,              // 8
+   28,              // 9 NearMaxPriority
+
+   31              // 10 MaxPriority
+};
+#elif defined(__APPLE__)
+/* Using Mach high-level priority assignments */
+int os::java_to_os_priority[MaxPriority + 1] = {
+   0,              // 0 Entry should never be used (MINPRI_USER)
+
+  27,              // 1 MinPriority
+  28,              // 2
+  29,              // 3
+
+  30,              // 4
+  31,              // 5 NormPriority (BASEPRI_DEFAULT)
+  32,              // 6
+
+  33,              // 7
+  34,              // 8
+  35,              // 9 NearMaxPriority
+
+  36               // 10 MaxPriority
+};
+#else
 int os::java_to_os_priority[MaxPriority + 1] = {
   19,              // 0 Entry should never be used
 
@@ -3198,6 +3479,7 @@
 
   -5               // 10 MaxPriority
 };
+#endif
 
 static int prio_init() {
   if (ThreadPriorityPolicy == 1) {
@@ -3217,8 +3499,28 @@
 OSReturn os::set_native_priority(Thread* thread, int newpri) {
   if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;
 
+#ifdef __OpenBSD__
+  // OpenBSD pthread_setprio starves low priority threads
+  return OS_OK;
+#elif defined(__FreeBSD__)
+  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+#elif defined(__APPLE__) || defined(__NetBSD__)
+  struct sched_param sp;
+  int policy;
+  pthread_t self = pthread_self();
+
+  if (pthread_getschedparam(self, &policy, &sp) != 0)
+    return OS_ERR;
+
+  sp.sched_priority = newpri;
+  if (pthread_setschedparam(self, policy, &sp) != 0)
+    return OS_ERR;
+
+  return OS_OK;
+#else
   int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);
   return (ret == 0) ? OS_OK : OS_ERR;
+#endif
 }
 
 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
@@ -3228,7 +3530,17 @@
   }
 
   errno = 0;
+#if defined(__OpenBSD__) || defined(__FreeBSD__)
+  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());
+#elif defined(__APPLE__) || defined(__NetBSD__)
+  int policy;
+  struct sched_param sp;
+
+  pthread_getschedparam(pthread_self(), &policy, &sp);
+  *priority_ptr = sp.sched_priority;
+#else
   *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());
+#endif
   return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);
 }
 
@@ -3338,7 +3650,7 @@
   /* Get signal number to use for suspend/resume */
   if ((s = ::getenv("_JAVA_SR_SIGNUM")) != 0) {
     int sig = ::strtol(s, 0, 10);
-    if (sig > 0 || sig < _NSIG) {
+    if (sig > 0 || sig < NSIG) {
         SR_signum = sig;
     }
   }
@@ -3682,6 +3994,28 @@
     set_signal_handler(SIGFPE, true);
     set_signal_handler(SIGXFSZ, true);
 
+#if defined(__APPLE__)
+    // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including
+    // signals caught and handled by the JVM. To work around this, we reset the mach task
+    // signal handler that's placed on our process by CrashReporter. This disables
+    // CrashReporter-based reporting.
+    //
+    // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes
+    // on caught fatal signals.
+    //
+    // Additionally, gdb installs both standard BSD signal handlers, and mach exception
+    // handlers. By replacing the existing task exception handler, we disable gdb's mach
+    // exception handling, while leaving the standard BSD signal handlers functional.
+    kern_return_t kr;
+    kr = task_set_exception_ports(mach_task_self(),
+        EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
+        MACH_PORT_NULL,
+        EXCEPTION_STATE_IDENTITY,
+        MACHINE_THREAD_STATE);
+
+    assert(kr == KERN_SUCCESS, "could not set mach task signal handler");
+#endif
+
     if (libjsig_is_loaded) {
       // Tell libjsig jvm finishes setting signal handlers
       (*end_signal_setting)();
@@ -3702,6 +4036,7 @@
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 // This is the fastest way to get thread cpu time on Bsd.
 // Returns cpu time (user+sys) for any thread, not only for current.
 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
@@ -3716,6 +4051,7 @@
 
   return (tp.tv_sec * SEC_IN_NANOSECS) + tp.tv_nsec;
 }
+#endif
 
 /////
 // glibc on Bsd platform uses non-documented flag
@@ -3937,13 +4273,13 @@
 
   _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();
 
-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);
+  clock_tics_per_sec = CLK_TCK;
 
   init_random(1234567);
 
   ThreadCritical::initialize();
 
-  Bsd::set_page_size(sysconf(_SC_PAGESIZE));
+  Bsd::set_page_size(getpagesize());
   if (Bsd::page_size() == -1) {
     fatal(err_msg("os_bsd.cpp: os::init: sysconf failed (%s)",
                   strerror(errno)));
@@ -3957,7 +4293,16 @@
 
   Bsd::clock_init();
   initial_time_count = os::elapsed_counter();
-  pthread_mutex_init(&dl_mutex, NULL);
+
+#ifdef __APPLE__
+  // XXXDARWIN
+  // Work around the unaligned VM callbacks in hotspot's
+  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on
+  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces
+  // alignment when doing symbol lookup. To work around this, we force early
+  // binding of all symbols now, thus binding when alignment is known-good.
+  _dyld_bind_fully_image_containing_address((const void *) &os::init);
+#endif
 }
 
 // To install functions for atexit system call
@@ -3970,7 +4315,9 @@
 // this is called _after_ the global arguments have been parsed
 jint os::init_2(void)
 {
+#ifndef _ALLBSD_SOURCE
   Bsd::fast_thread_clock_init();
+#endif
 
   // Allocate a single page and mark it as readable for safepoint polling
   address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
@@ -4028,6 +4375,7 @@
   JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,
         vm_page_size()));
 
+#ifndef _ALLBSD_SOURCE
   Bsd::capture_initial_stack(JavaThread::stack_size_at_create());
 
   Bsd::libpthread_init();
@@ -4050,6 +4398,7 @@
       UseNUMA = true;
     }
   }
+#endif
 
   if (MaxFDLimit) {
     // set the number of file descriptors to max. print out error
@@ -4061,6 +4410,14 @@
         perror("os::init_2 getrlimit failed");
     } else {
       nbr_files.rlim_cur = nbr_files.rlim_max;
+      
+#ifdef __APPLE__
+      // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if
+      // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must
+      // be used instead
+      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);
+#endif
+
       status = setrlimit(RLIMIT_NOFILE, &nbr_files);
       if (status != 0) {
         if (PrintMiscellaneous && (Verbose || WizardMode))
@@ -4069,8 +4426,10 @@
     }
   }
 
+#ifndef _ALLBSD_SOURCE
   // Initialize lock used to serialize thread creation (see os::create_thread)
   Bsd::set_createThread_lock(new Mutex(Mutex::leaf, "createThread_lock", false));
+#endif
 
   // at-exit methods are called in the reverse order of their registration.
   // atexit functions are called on return from main or as a result of a
@@ -4114,11 +4473,29 @@
 };
 
 int os::active_processor_count() {
+#ifdef _ALLBSD_SOURCE
+#ifdef __FreeBSD__
+  int online_cpus = 0;
+#if __FreeBSD_version > 700109
+  std::bitset<CPU_SETSIZE> mask;
+  assert(sizeof(mask) == sizeof(cpuset_t), "Invalid bitset for cpuset_t");
+  if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(mask),
+      reinterpret_cast<cpuset_t*>(&mask)) == 0)
+    online_cpus = mask.count();
+#else
+  online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
+#endif
+  if (online_cpus > 0 && online_cpus <= _processor_count)
+    return online_cpus;
+#endif
+  return _processor_count;
+#else
   // Bsd doesn't yet have a (official) notion of processor sets,
   // so just return the number of online processors.
   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
   assert(online_cpus > 0 && online_cpus <= processor_count(), "sanity check");
   return online_cpus;
+#endif
 }
 
 bool os::distribute_processes(uint length, uint* distribution) {
@@ -4160,6 +4537,9 @@
 
 int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)
 {
+#ifdef _ALLBSD_SOURCE
+  return pthread_cond_timedwait(_cond, _mutex, _abstime);
+#else
    if (is_NPTL()) {
       return pthread_cond_timedwait(_cond, _mutex, _abstime);
    } else {
@@ -4175,6 +4555,7 @@
 #endif // IA64
       return status;
    }
+#endif
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -4322,14 +4703,14 @@
   int o_delete = (oflag & O_DELETE);
   oflag = oflag & ~O_DELETE;
 
-  fd = ::open64(path, oflag, mode);
+  fd = ::open(path, oflag, mode);
   if (fd == -1) return -1;
 
   //If the open succeeded, the file might still be a directory
   {
-    struct stat64 buf64;
-    int ret = ::fstat64(fd, &buf64);
-    int st_mode = buf64.st_mode;
+    struct stat buf;
+    int ret = ::fstat(fd, &buf);
+    int st_mode = buf.st_mode;
 
     if (ret != -1) {
       if ((st_mode & S_IFMT) == S_IFDIR) {
@@ -4386,17 +4767,17 @@
   if (!rewrite_existing) {
     oflags |= O_EXCL;
   }
-  return ::open64(path, oflags, S_IREAD | S_IWRITE);
+  return ::open(path, oflags, S_IREAD | S_IWRITE);
 }
 
 // return current position of file pointer
 jlong os::current_file_offset(int fd) {
-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
 }
 
 // move file pointer to the specified offset
 jlong os::seek_to_file_offset(int fd, jlong offset) {
-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
 }
 
 // This code originates from JDK's sysAvailable
@@ -4405,10 +4786,10 @@
 int os::available(int fd, jlong *bytes) {
   jlong cur, end;
   int mode;
-  struct stat64 buf64;
+  struct stat buf;
 
-  if (::fstat64(fd, &buf64) >= 0) {
-    mode = buf64.st_mode;
+  if (::fstat(fd, &buf) >= 0) {
+    mode = buf.st_mode;
     if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {
       /*
       * XXX: is the following call interruptible? If so, this might
@@ -4422,11 +4803,11 @@
       }
     }
   }
-  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {
+  if ((cur = ::lseek(fd, 0L, SEEK_CUR)) == -1) {
     return 0;
-  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {
+  } else if ((end = ::lseek(fd, 0L, SEEK_END)) == -1) {
     return 0;
-  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {
+  } else if (::lseek(fd, cur, SEEK_SET) == -1) {
     return 0;
   }
   *bytes = end - cur;
@@ -4489,6 +4870,7 @@
   return munmap(addr, bytes) == 0;
 }
 
+#ifndef _ALLBSD_SOURCE
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);
 
 static clockid_t thread_cpu_clockid(Thread* thread) {
@@ -4500,6 +4882,7 @@
   assert(rc == 0, "pthread_getcpuclockid is expected to return 0 code");
   return clockid;
 }
+#endif
 
 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
 // are used by JVM M&M and JVMTI to get user+sys or user CPU time
@@ -4509,39 +4892,71 @@
 // the fast estimate available on the platform.
 
 jlong os::current_thread_cpu_time() {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), true /* user + sys */);
+#elif !defined(_ALLBSD_SOURCE)
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     // return user + sys since the cost is the same
     return slow_thread_cpu_time(Thread::current(), true /* user + sys */);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread* thread) {
+#ifndef _ALLBSD_SOURCE
   // consistent with what current_thread_cpu_time() returns
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, true /* user + sys */);
   }
+#endif
 }
 
 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  struct thread_basic_info tinfo;
+  mach_msg_type_number_t tcount = THREAD_INFO_MAX;
+  kern_return_t kr;
+  mach_port_t mach_thread;
+
+  mach_thread = pthread_mach_thread_np(thread->osthread()->thread_id());
+  kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&tinfo, &tcount);
+  if (kr != KERN_SUCCESS)
+    return -1;
+
+  if (user_sys_cpu_time) {
+    jlong nanos;
+    nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;
+    nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;
+    return nanos;
+  } else {
+    return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
+  }
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, user_sys_cpu_time);
   }
+#endif
 }
 
+#ifndef _ALLBSD_SOURCE
 //
 //  -1 on error.
 //
@@ -4631,6 +5046,7 @@
     return (jlong)user_time * (1000000000 / clock_tics_per_sec);
   }
 }
+#endif
 
 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
   info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
@@ -4647,7 +5063,13 @@
 }
 
 bool os::is_thread_cpu_time_supported() {
+#ifdef __APPLE__
   return true;
+#elif defined(_ALLBSD_SOURCE)
+  return false;
+#else
+  return true;
+#endif
 }
 
 // System loadavg support.  Returns -1 if load average cannot be obtained.
@@ -4780,7 +5202,7 @@
 // abstime will be the absolute timeout time
 // TODO: replace compute_abstime() with unpackTime()
 
-static struct timespec* compute_abstime(timespec* abstime, jlong millis) {
+static struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
   struct timeval now;
   int status = gettimeofday(&now, NULL);
@@ -4832,7 +5254,7 @@
         status = pthread_cond_wait(_cond, _mutex);
         // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
         // Treat this the same as if the wait was interrupted
-        if (status == ETIME) { status = EINTR; }
+        if (status == ETIMEDOUT) { status = EINTR; } 
         assert_status(status == 0 || status == EINTR, status, "cond_wait");
      }
      -- _nParked ;
@@ -4890,10 +5312,10 @@
       pthread_cond_init (_cond, NULL) ;
     }
     assert_status(status == 0 || status == EINTR ||
-                  status == ETIME || status == ETIMEDOUT,
+		  status == ETIMEDOUT, 
                   status, "cond_timedwait");
     if (!FilterSpuriousWakeups) break ;                 // previous semantics
-    if (status == ETIME || status == ETIMEDOUT) break ;
+    if (status == ETIMEDOUT) break ; 
     // We consume and ignore EINTR and spurious wakeups.
   }
   --_nParked ;
@@ -4985,7 +5407,7 @@
  * years from "now".
  */
 
-static void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {
+static void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
 
   struct timeval now;
@@ -5045,7 +5467,7 @@
   }
 
   // Next, demultiplex/decode time arguments
-  timespec absTime;
+  struct timespec absTime;
   if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all
     return;
   }
@@ -5099,7 +5521,7 @@
     }
   }
   assert_status(status == 0 || status == EINTR ||
-                status == ETIME || status == ETIMEDOUT,
+                status == ETIMEDOUT, 
                 status, "cond_timedwait");
 
 #ifdef ASSERT
@@ -5142,14 +5564,12 @@
 }
 
 
+/* Darwin has no "environ" in a dynamic library. */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char** environ;
-
-#ifndef __NR_fork
-#define __NR_fork IA32_ONLY(2) IA64_ONLY(not defined) AMD64_ONLY(57)
-#endif
-
-#ifndef __NR_execve
-#define __NR_execve IA32_ONLY(11) IA64_ONLY(1033) AMD64_ONLY(59)
 #endif
 
 // Run the specified command in a separate process. Return its exit value,
@@ -5164,8 +5584,7 @@
   // separate process to execve. Make a direct syscall to fork process.
   // On IA64 there's no fork syscall, we have to use fork() and hope for
   // the best...
-  pid_t pid = NOT_IA64(syscall(__NR_fork);)
-              IA64_ONLY(fork();)
+  pid_t pid = fork();
 
   if (pid < 0) {
     // fork failed
@@ -5181,8 +5600,7 @@
     // in the new process, so make a system call directly.
     // IA64 should use normal execve() from glibc to match the glibc fork()
     // above.
-    NOT_IA64(syscall(__NR_execve, "/bin/sh", argv, environ);)
-    IA64_ONLY(execve("/bin/sh", (char* const*)argv, environ);)
+    execve("/bin/sh", (char* const*)argv, environ);
 
     // execve failed
     _exit(-1);
--- hotspot/src/os/bsd/vm/os_bsd.hpp
+++ hotspot/src/os/bsd/vm/os_bsd.hpp
@@ -30,6 +30,12 @@
 /* pthread_getattr_np comes with BsdThreads-0.9-7 on RedHat 7.1 */
 typedef int (*pthread_getattr_func_type) (pthread_t, pthread_attr_t *);
 
+#ifdef __APPLE__
+// Mac OS X doesn't support clock_gettime. Stub out the type, it is
+// unused
+typedef int clockid_t;
+#endif
+
 class Bsd {
   friend class os;
 
@@ -50,6 +56,7 @@
   static int sigflags[MAXSIGNUM];
 
   static int (*_clock_gettime)(clockid_t, struct timespec *);
+#ifndef _ALLBSD_SOURCE
   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
 
   static address   _initial_thread_stack_bottom;
@@ -61,6 +68,7 @@
   static bool _is_floating_stack;
   static bool _is_NPTL;
   static bool _supports_fast_thread_cpu_time;
+#endif
 
   static GrowableArray<int>* _cpu_to_node;
 
@@ -68,38 +76,54 @@
 
   static julong _physical_memory;
   static pthread_t _main_thread;
+#ifndef _ALLBSD_SOURCE
   static Mutex* _createThread_lock;
+#endif
   static int _page_size;
 
   static julong available_memory();
   static julong physical_memory() { return _physical_memory; }
   static void initialize_system_info();
 
+#ifndef _ALLBSD_SOURCE
   static void set_glibc_version(const char *s)      { _glibc_version = s; }
   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
+#endif
 
   static bool supports_variable_stack_size();
 
+#ifndef _ALLBSD_SOURCE
   static void set_is_NPTL()                   { _is_NPTL = true;  }
   static void set_is_BsdThreads()           { _is_NPTL = false; }
   static void set_is_floating_stack()         { _is_floating_stack = true; }
+#endif
 
   static void rebuild_cpu_to_node_map();
   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }
  public:
+
   static void init_thread_fpu_state();
+#ifndef _ALLBSD_SOURCE
   static int  get_fpu_control_word();
   static void set_fpu_control_word(int fpu_control);
+#endif
   static pthread_t main_thread(void)                                { return _main_thread; }
+
+#ifdef __FreeBSD__
   // returns kernel thread id (similar to LWP id on Solaris), which can be
   // used to access /proc
   static pid_t gettid();
+#endif
+#ifndef _ALLBSD_SOURCE
   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }
   static Mutex* createThread_lock(void)                             { return _createThread_lock; }
+#endif
   static void hotspot_sigmask(Thread* thread);
 
+#ifndef _ALLBSD_SOURCE
   static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
   static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
+#endif
   static bool is_initial_thread(void);
 
   static int page_size(void)                                        { return _page_size; }
@@ -136,6 +160,7 @@
   static struct sigaction *get_chained_signal_action(int sig);
   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
 
+#ifndef _ALLBSD_SOURCE
   // GNU libc and libpthread version strings
   static const char *glibc_version()          { return _glibc_version; }
   static const char *libpthread_version()     { return _libpthread_version; }
@@ -151,6 +176,7 @@
   static void libpthread_init();
   static bool libnuma_init();
   static void* libnuma_dlsym(void* handle, const char* name);
+#endif
   // Minimum stack size a thread can be created with (allowing
   // the VM to completely create the thread and enter user code)
   static size_t min_stack_allowed;
@@ -159,17 +185,21 @@
   static size_t default_stack_size(os::ThreadType thr_type);
   static size_t default_guard_size(os::ThreadType thr_type);
 
+#ifndef _ALLBSD_SOURCE
   static void capture_initial_stack(size_t max_size);
 
   // Stack overflow handling
   static bool manually_expand_stack(JavaThread * t, address addr);
   static int max_register_window_saves_before_flushing();
+#endif
 
   // Real-time clock functions
   static void clock_init(void);
 
+#ifndef _ALLBSD_SOURCE
   // fast POSIX clocks support
   static void fast_thread_clock_init(void);
+#endif
 
   static bool supports_monotonic_clock() {
     return _clock_gettime != NULL;
@@ -179,6 +209,7 @@
     return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;
   }
 
+#ifndef _ALLBSD_SOURCE
   static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {
     return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;
   }
@@ -188,6 +219,7 @@
   }
 
   static jlong fast_thread_cpu_time(clockid_t clockid);
+#endif
 
   // Stack repair handling
 
--- hotspot/src/os/bsd/vm/os_bsd.inline.hpp
+++ hotspot/src/os/bsd/vm/os_bsd.inline.hpp
@@ -86,7 +86,15 @@
 
 inline bool os::allocate_stack_guard_pages() {
   assert(uses_stack_guard_pages(), "sanity check");
+#if !defined(__FreeBSD__) || __FreeBSD__ < 5
+  // Since FreeBSD 4 uses malloc() for allocating the thread stack
+  // there is no need to do anything extra to allocate the guard pages
+  return false;
+#else
+  // FreeBSD 5+ uses mmap MAP_STACK for allocating the thread stacks.
+  // Must 'allocate' them or guard pages are ignored.
   return true;
+#endif
 }
 
 
@@ -118,7 +126,7 @@
 }
 
 inline jlong os::lseek(int fd, jlong offset, int whence) {
-  return (jlong) ::lseek64(fd, offset, whence);
+  return (jlong) ::lseek(fd, (off_t)offset, whence);
 }
 
 inline int os::fsync(int fd) {
@@ -130,7 +138,7 @@
 }
 
 inline int os::ftruncate(int fd, jlong length) {
-  return ::ftruncate64(fd, length);
+  return ::ftruncate(fd, (off_t)length);
 }
 
 inline struct dirent* os::readdir(DIR* dirp, dirent *dbuf)
--- hotspot/src/os/bsd/vm/vmError_bsd.cpp
+++ hotspot/src/os/bsd/vm/vmError_bsd.cpp
@@ -34,6 +34,12 @@
 #include <unistd.h>
 #include <signal.h>
 
+#ifdef __FreeBSD__
+#define	GDB_LAUNCHER	"gdb /proc/%d/file %d"
+#else
+#define	GDB_LAUNCHER	"gdb /proc/%d/exe %d"
+#endif
+
 void VMError::show_message_box(char *buf, int buflen) {
   bool yes;
   do {
@@ -44,7 +50,7 @@
     jio_snprintf(p, buflen - len,
                "\n\n"
                "Do you want to debug the problem?\n\n"
-               "To debug, run 'gdb /proc/%d/exe %d'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
+               "To debug, run '" GDB_LAUNCHER "'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
                "Enter 'yes' to launch gdb automatically (PATH must include gdb)\n"
                "Otherwise, press RETURN to abort...",
                os::current_process_id(), os::current_process_id(),
@@ -54,7 +60,7 @@
 
     if (yes) {
       // yes, user asked VM to launch debugger
-      jio_snprintf(buf, buflen, "gdb /proc/%d/exe %d",
+      jio_snprintf(buf, buflen, GDB_LAUNCHER,
                    os::current_process_id(), os::current_process_id());
 
       os::fork_and_exec(buf);
--- hotspot/src/os/posix/launcher/java_md.c
+++ hotspot/src/os/posix/launcher/java_md.c
@@ -35,20 +35,30 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifndef _SC_PHYS_PAGES
+#include <sys/sysctl.h>
+#endif
 
 #ifndef GAMMA
 #include "manifest_info.h"
 #include "version_comp.h"
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #else
 #include <thread.h>
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+#define LD_LIBRARY_PATH "DYLD_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 #ifndef GAMMA   /* launcher.make defines ARCH */
 /*
@@ -89,7 +99,7 @@
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static const char *system_dir   = "/usr/java";
 static const char *user_dir     = "/java";
 #else /* Solaris */
@@ -423,10 +433,10 @@
        * If not on Solaris, assume only a single LD_LIBRARY_PATH
        * variable.
        */
-      runpath = getenv("LD_LIBRARY_PATH");
+      runpath = getenv(LD_LIBRARY_PATH);
 #endif /* __sun */
 
-#ifdef __linux
+#if defined(__linux)
       /*
        * On linux, if a binary is running as sgid or suid, glibc sets
        * LD_LIBRARY_PATH to the empty string for security purposes.  (In
@@ -442,6 +452,22 @@
       if((getgid() != getegid()) || (getuid() != geteuid()) ) {
         return;
       }
+#elif defined(_ALLBSD_SOURCE)
+      /*
+       * On BSD, if a binary is running as sgid or suid, libc sets
+       * LD_LIBRARY_PATH to the empty string for security purposes.  (In
+       * contrast, on Solaris the LD_LIBRARY_PATH variable for a
+       * privileged binary does not lose its settings; but the dynamic
+       * linker does apply more scrutiny to the path.) The launcher uses
+       * the value of LD_LIBRARY_PATH to prevent an exec loop.
+       * Therefore, if we are running sgid or suid, this function's
+       * setting of LD_LIBRARY_PATH will be ineffective and we should
+       * return from the function now.  Getting the right libraries to
+       * be found must be handled through other mechanisms.
+       */
+      if(issetugid()) {
+        return;
+      }
 #endif
 
       /* runpath contains current effective LD_LIBRARY_PATH setting */
@@ -450,7 +476,7 @@
       new_runpath = JLI_MemAlloc( ((runpath!=NULL)?strlen(runpath):0) +
                               2*strlen(jrepath) + 2*strlen(arch) +
                               strlen(jvmpath) + 52);
-      newpath = new_runpath + strlen("LD_LIBRARY_PATH=");
+      newpath = new_runpath + strlen(LD_LIBRARY_PATH "=");
 
 
       /*
@@ -465,7 +491,7 @@
 
         /* jvmpath, ((running != wanted)?((wanted==64)?"/"LIBARCH64NAME:"/.."):""), */
 
-        sprintf(new_runpath, "LD_LIBRARY_PATH="
+        sprintf(new_runpath, LD_LIBRARY_PATH "="
                 "%s:"
                 "%s/lib/%s:"
                 "%s/../lib/%s",
@@ -503,7 +529,7 @@
        * LD_LIBRARY_PATH.  Note that this prevents any possible infinite
        * loop of execv() because we test for the prefix, above.
        */
-      if (runpath != 0) {
+      if (runpath != 0 && runpath[0] != '\0') {
         strcat(new_runpath, ":");
         strcat(new_runpath, runpath);
       }
@@ -792,7 +818,7 @@
 jboolean
 GetApplicationHome(char *buf, jint bufsize)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     char *execname = GetExecname();
     if (execname) {
         strncpy(buf, execname, bufsize-1);
@@ -961,9 +987,13 @@
             }
         }
     }
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(_ALLBSD_SOURCE)
     {
+#ifdef __FreeBSD__
+        const char* self = "/proc/curproc/file";
+#else
         const char* self = "/proc/self/exe";
+#endif
         char buf[PATH_MAX+1];
         int len = readlink(self, buf, PATH_MAX);
         if (len >= 0) {
@@ -971,7 +1001,7 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__sun && !__linux */
+#else /* !__sun && !__linux && !_ALLBSD_SOURCE */
     {
         /* Not implemented */
     }
@@ -1069,6 +1099,7 @@
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+#ifdef _SC_PHYS_PAGES
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
   const uint64_t result    = pages * page_size;
@@ -1080,6 +1111,28 @@
            "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   }
+#else
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+  uint64_t result;
+# define UINT64_FORMAT "%" PRIu64
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+       physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  if (_launcher_debug) {
+    printf("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  }
+#endif
   return result;
 }
 
@@ -1175,7 +1228,7 @@
 
 #endif /* __sun && i586 */
 
-#if defined(__linux__) && defined(i586)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(i586)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -1240,7 +1293,7 @@
 #endif
 }
 
-#endif /* __linux__ && i586 */
+#endif /* (__linux__ || _ALLBSD_SOURCE) && i586 */
 
 #ifdef i586
 /*
@@ -1452,6 +1505,39 @@
 
 #endif /* __linux__ && i586 */
 
+#if defined(_ALLBSD_SOURCE) && defined(i586)
+
+/* The definition of a server-class machine for bsd-i586 */
+jboolean
+bsd_i586_ServerClassMachine(void) {
+  jboolean            result            = JNI_FALSE;
+  /* How big is a server class machine? */
+  const unsigned long server_processors = 2UL;
+  const uint64_t      server_memory     = 2UL * GB;
+  /*
+   * We seem not to get our full complement of memory.
+   *     We allow some part (1/8?) of the memory to be "missing",
+   *     based on the sizes of DIMMs, and maybe graphics cards.
+   */
+  const uint64_t      missing_memory    = 256UL * MB;
+  const uint64_t      actual_memory     = physical_memory();
+
+  /* Is this a server class machine? */
+  if (actual_memory >= (server_memory - missing_memory)) {
+    const unsigned long actual_processors = physical_processors();
+    if (actual_processors >= server_processors) {
+      result = JNI_TRUE;
+    }
+  }
+  if (_launcher_debug) {
+    printf("bsd_" LIBARCHNAME "_ServerClassMachine: %s\n",
+           (result == JNI_TRUE ? "true" : "false"));
+  }
+  return result;
+}
+
+#endif /* _ALLBSD_SOURCE && i586 */
+
 /* Dispatch to the platform-specific definition of "server-class" */
 jboolean
 ServerClassMachine(void) {
@@ -1466,6 +1552,8 @@
   result = solaris_i586_ServerClassMachine();
 #elif defined(__linux__) && defined(i586)
   result = linux_i586_ServerClassMachine();
+#elif defined(_ALLBSD_SOURCE) && defined(i586)
+  result = bsd_i586_ServerClassMachine();
 #else
   if (_launcher_debug) {
     printf("ServerClassMachine: returns default value of %s\n",
@@ -1606,7 +1694,7 @@
     while (dp != NULL) {
         cp = strchr(dp, (int)':');
         if (cp != NULL)
-            *cp = (char)NULL;
+            *cp = '\0';
         if ((target = ProcessDir(info, dp)) != NULL)
             break;
         dp = cp;
@@ -1821,7 +1909,7 @@
 int
 ContinueInNewThread(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
     int rslt;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pthread_t tid;
     pthread_attr_t attr;
     pthread_attr_init(&attr);
@@ -1865,8 +1953,8 @@
 #define MAX_PID_STR_SZ   20
 
 void SetJavaLauncherPlatformProps() {
-   /* Linux only */
-#ifdef __linux__
+   /* Linux and BSDs only */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     const char *substr = "-Dsun.java.launcher.pid=";
     char *pid_prop_str = (char *)JLI_MemAlloc(strlen(substr) + MAX_PID_STR_SZ + 1);
     sprintf(pid_prop_str, "%s%d", substr, getpid());
--- hotspot/src/os/posix/launcher/launcher.script
+++ hotspot/src/os/posix/launcher/launcher.script
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 
 # Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
--- hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s
+++ hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s
@@ -21,6 +21,17 @@
 # questions.
 # 
 
+ 
+#ifdef __APPLE__
+# Darwin uses _ prefixed global symbols
+#define SYMBOL(s) _ ## s
+#define ELF_TYPE(name, description)
+#else
+#define SYMBOL(s) s
+#define ELF_TYPE(name, description) .type name,description
+#endif
+
+	.globl SYMBOL(fixcw)
 	
         # NOTE WELL!  The _Copy functions are called directly
 	# from server-compiler-generated code via CallLeafNoFP,
@@ -28,42 +39,62 @@
 	# point or use it in the same manner as does the server
 	# compiler.
 	
-        .globl _Copy_conjoint_bytes
-        .globl _Copy_arrayof_conjoint_bytes
-        .globl _Copy_conjoint_jshorts_atomic
-	.globl _Copy_arrayof_conjoint_jshorts
-        .globl _Copy_conjoint_jints_atomic
-        .globl _Copy_arrayof_conjoint_jints
-	.globl _Copy_conjoint_jlongs_atomic
-	.globl _mmx_Copy_arrayof_conjoint_jshorts
+        .globl SYMBOL(_Copy_conjoint_bytes)
+        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
+        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
+	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jints_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jints)
+	.globl SYMBOL(_Copy_conjoint_jlongs_atomic)
+	.globl SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)
 
-        .globl _Atomic_cmpxchg_long
-        .globl _Atomic_move_long
+        .globl SYMBOL(_Atomic_cmpxchg_long)
+        .globl SYMBOL(_Atomic_move_long)
 
 	.text
 
-        .globl  SafeFetch32, Fetch32PFI, Fetch32Resume
-        .globl  SafeFetchN
+# Support for void os::Solaris::init_thread_fpu_state() in os_solaris_i486.cpp
+# Set fpu to 53 bit precision.  This happens too early to use a stub.
+# ported from solaris_x86_32.s
+#ifdef __APPLE__
+        .align   4
+#else
+	.align   16
+#endif
+SYMBOL(fixcw):
+	pushl    $0x27f
+	fldcw    0(%esp)
+	popl     %eax
+	ret
+
+#ifdef __APPLE__
+        .align   4
+#else
+        .align   16
+#endif
+
+        .globl  SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
+        .globl  SYMBOL(SafeFetchN)
         ## TODO: avoid exposing Fetch32PFI and Fetch32Resume.
         ## Instead, the signal handler would call a new SafeFetchTriage(FaultingEIP)
         ## routine to vet the address.  If the address is the faulting LD then
         ## SafeFetchTriage() would return the resume-at EIP, otherwise null.
-	.type    SafeFetch32,@function
+	ELF_TYPE(SafeFetch32,@function)
         .p2align 4,,15
-SafeFetch32:
-SafeFetchN:
+SYMBOL(SafeFetch32):
+SYMBOL(SafeFetchN):
          movl    0x8(%esp), %eax
          movl    0x4(%esp), %ecx
-Fetch32PFI:
+SYMBOL(Fetch32PFI):
          movl    (%ecx), %eax
-Fetch32Resume:
+SYMBOL(Fetch32Resume):
          ret
 
 
-        .globl  SpinPause
-	.type   SpinPause,@function
+        .globl  SYMBOL(SpinPause)
+	ELF_TYPE(SpinPause,@function)
         .p2align 4,,15
-SpinPause:
+SYMBOL(SpinPause):
         rep
         nop
         movl    $1, %eax
@@ -73,8 +104,8 @@
         #                                       void* to,
         #                                       size_t count)
         .p2align 4,,15
-	.type    _Copy_conjoint_bytes,@function
-_Copy_conjoint_bytes:
+	ELF_TYPE(_Copy_conjoint_bytes,@function)
+SYMBOL(_Copy_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -181,8 +212,8 @@
         #
         # Same as _Copy_conjoint_bytes, except no source alignment check.
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_bytes,@function
-_Copy_arrayof_conjoint_bytes:
+	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+SYMBOL(_Copy_arrayof_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -241,7 +272,7 @@
         jbe      2f                   # <= 32 dwords
         rep;     smovl
         jmp      4f
-	.=.+8
+	.skip 8
 2:      subl     %esi,%edi
         .p2align 4,,15
 3:      movl     (%esi),%edx
@@ -269,8 +300,8 @@
         #                                                void* to,
         #                                                size_t count)
         .p2align 4,,15
-	.type    _Copy_conjoint_jshorts_atomic,@function
-_Copy_conjoint_jshorts_atomic:
+	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+SYMBOL(_Copy_conjoint_jshorts_atomic):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -356,8 +387,8 @@
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jshorts,@function
-_Copy_arrayof_conjoint_jshorts:
+	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+SYMBOL(_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -378,7 +409,7 @@
         rep;     smovl
         jmp      4f 
         # copy aligned dwords
-        .=.+5
+        .skip 5
 2:      subl     %esi,%edi 
         .p2align 4,,15
 3:      movl     (%esi),%edx
@@ -433,10 +464,10 @@
         # Equivalent to
         #   arrayof_conjoint_jints
         .p2align 4,,15
-	.type    _Copy_conjoint_jints_atomic,@function
-	.type    _Copy_arrayof_conjoint_jints,@function
-_Copy_conjoint_jints_atomic:
-_Copy_arrayof_conjoint_jints:
+	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+SYMBOL(_Copy_conjoint_jints_atomic):
+SYMBOL(_Copy_arrayof_conjoint_jints):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -454,7 +485,7 @@
         popl     %edi
         popl     %esi
         ret
-        .=.+10
+        .skip 10
 2:      subl     %esi,%edi
         jmp      4f
         .p2align 4,,15
@@ -498,7 +529,7 @@
         #
         # count treated as signed
         #
-        # if (from > to) {
+        # // if (from > to) {
         #   while (--count >= 0) {
         #     *to++ = *from++;
         #   }
@@ -508,8 +539,8 @@
         #   }
         # }
         .p2align 4,,15
-	.type    _Copy_conjoint_jlongs_atomic,@function
-_Copy_conjoint_jlongs_atomic:
+	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+SYMBOL(_Copy_conjoint_jlongs_atomic):
         movl     4+8(%esp),%ecx       # count
         movl     4+0(%esp),%eax       # from
         movl     4+4(%esp),%edx       # to
@@ -537,8 +568,8 @@
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	.type    _mmx_Copy_arrayof_conjoint_jshorts,@function
-_mmx_Copy_arrayof_conjoint_jshorts:
+	ELF_TYPE(_mmx_Copy_arrayof_conjoint_jshorts,@function)
+SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx
         pushl    %edi
@@ -636,8 +667,8 @@
         #                                   bool is_MP)
         #
         .p2align 4,,15
-	.type    _Atomic_cmpxchg_long,@function
-_Atomic_cmpxchg_long:
+	ELF_TYPE(_Atomic_cmpxchg_long,@function)
+SYMBOL(_Atomic_cmpxchg_long):
                                    #  8(%esp) : return PC
         pushl    %ebx              #  4(%esp) : old %ebx
         pushl    %edi              #  0(%esp) : old %edi
@@ -658,8 +689,8 @@
         # Support for jlong Atomic::load and Atomic::store.
         # void _Atomic_move_long(volatile jlong* src, volatile jlong* dst)
         .p2align 4,,15
-	.type    _Atomic_move_long,@function
-_Atomic_move_long:
+	ELF_TYPE(_Atomic_move_long,@function)
+SYMBOL(_Atomic_move_long):
         movl     4(%esp), %eax   # src
         fildll    (%eax)
         movl     8(%esp), %eax   # dest
--- hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s
+++ hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s
@@ -21,6 +21,14 @@
 # questions.
 #
 
+#ifdef __APPLE__
+# Darwin uses _ prefixed global symbols
+#define SYMBOL(s) _ ## s
+#define ELF_TYPE(name, description)
+#else
+#define SYMBOL(s) s
+#define ELF_TYPE(name, description) .type name,description
+#endif
 
         # NOTE WELL!  The _Copy functions are called directly
 	# from server-compiler-generated code via CallLeafNoFP,
@@ -28,42 +36,54 @@
 	# point or use it in the same manner as does the server
 	# compiler.
 	
-        .globl _Copy_arrayof_conjoint_bytes
-	.globl _Copy_arrayof_conjoint_jshorts
-        .globl _Copy_conjoint_jshorts_atomic
-        .globl _Copy_arrayof_conjoint_jints
-        .globl _Copy_conjoint_jints_atomic
-        .globl _Copy_arrayof_conjoint_jlongs
-        .globl _Copy_conjoint_jlongs_atomic
+        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
+	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jints)
+        .globl SYMBOL(_Copy_conjoint_jints_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jlongs)
+        .globl SYMBOL(_Copy_conjoint_jlongs_atomic)
 
 	.text
 
-        .globl SafeFetch32, Fetch32PFI, Fetch32Resume
+        .globl SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
+#ifdef __APPLE__
+        .align  4
+#else
         .align  16
-        .type   SafeFetch32,@function
+#endif
+        ELF_TYPE(SafeFetch32,@function)
         // Prototype: int SafeFetch32 (int * Adr, int ErrValue) 
-SafeFetch32:
+SYMBOL(SafeFetch32):
         movl    %esi, %eax
-Fetch32PFI:
+SYMBOL(Fetch32PFI):
         movl    (%rdi), %eax
-Fetch32Resume:
+SYMBOL(Fetch32Resume):
         ret
 
-        .globl SafeFetchN, FetchNPFI, FetchNResume
+        .globl SYMBOL(SafeFetchN), SYMBOL(FetchNPFI), SYMBOL(FetchNResume)
+#ifdef __APPLE__
+        .align  4
+#else
         .align  16
-        .type   SafeFetchN,@function
+#endif
+        ELF_TYPE(SafeFetchN,@function)
         // Prototype: intptr_t SafeFetchN (intptr_t * Adr, intptr_t ErrValue) 
-SafeFetchN:
+SYMBOL(SafeFetchN):
         movq    %rsi, %rax
-FetchNPFI:
+SYMBOL(FetchNPFI):
         movq    (%rdi), %rax
-FetchNResume:
+SYMBOL(FetchNResume):
         ret
 
-        .globl SpinPause
-        .align 16
-        .type  SpinPause,@function
-SpinPause:
+        .globl SYMBOL(SpinPause)
+#ifdef __APPLE__
+        .align  4
+#else
+        .align  16
+#endif
+        ELF_TYPE(SpinPause,@function)
+SYMBOL(SpinPause):
         rep
         nop
         movq   $1, %rax
@@ -77,8 +97,8 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_bytes,@function
-_Copy_arrayof_conjoint_bytes:
+	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+SYMBOL(_Copy_arrayof_conjoint_bytes):
         movq     %rdx,%r8             # byte count
         shrq     $3,%rdx              # qword count
         cmpq     %rdi,%rsi
@@ -179,10 +199,10 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jshorts,@function
-	.type    _Copy_conjoint_jshorts_atomic,@function
-_Copy_arrayof_conjoint_jshorts:
-_Copy_conjoint_jshorts_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jshorts):
+SYMBOL(_Copy_conjoint_jshorts_atomic):
         movq     %rdx,%r8             # word count
         shrq     $2,%rdx              # qword count
         cmpq     %rdi,%rsi
@@ -269,10 +289,10 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jints,@function
-	.type    _Copy_conjoint_jints_atomic,@function
-_Copy_arrayof_conjoint_jints:
-_Copy_conjoint_jints_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jints):
+SYMBOL(_Copy_conjoint_jints_atomic):
         movq     %rdx,%r8             # dword count
         shrq     %rdx                 # qword count
         cmpq     %rdi,%rsi
@@ -348,10 +368,10 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jlongs,@function
-	.type    _Copy_conjoint_jlongs_atomic,@function
-_Copy_arrayof_conjoint_jlongs:
-_Copy_conjoint_jlongs_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jlongs,@function)
+	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jlongs):
+SYMBOL(_Copy_conjoint_jlongs_atomic):
         cmpq     %rdi,%rsi
         leaq     -8(%rdi,%rdx,8),%rax # from + count*8 - 8
         jbe      acl_CopyRight
--- hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp
@@ -25,7 +25,33 @@
 #ifndef OS_CPU_BSD_X86_VM_BYTES_BSD_X86_INLINE_HPP
 #define OS_CPU_BSD_X86_VM_BYTES_BSD_X86_INLINE_HPP
 
+#ifndef _ALLBSD_SOURCE
 #include <byteswap.h>
+#endif
+
+#ifdef __APPLE__
+#include <libkern/OSByteOrder.h>
+#endif
+
+#if defined(AMD64)
+#  if defined(__APPLE__)
+#    define bswap_16(x)	OSSwapInt16(x)
+#    define bswap_32(x)	OSSwapInt32(x)
+#    define bswap_64(x)	OSSwapInt64(x)
+#  elif defined(__OpenBSD__)
+#    define bswap_16(x)	swap16(x)
+#    define bswap_32(x)	swap32(x)
+#    define bswap_64(x)	swap64(x)
+#  elif defined(__NetBSD__)
+#    define bswap_16(x)	bswap16(x)
+#    define bswap_32(x)	bswap32(x)
+#    define bswap_64(x)	bswap64(x)
+#  else
+#    define bswap_16(x) __bswap16(x)
+#    define bswap_32(x) __bswap32(x)
+#    define bswap_64(x) __bswap64(x)
+#  endif
+#endif
 
 // Efficient swapping of data bytes from Java byte
 // ordering to native byte ordering and vice versa.
--- hotspot/src/os_cpu/bsd_x86/vm/globals_bsd_x86.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/globals_bsd_x86.hpp
@@ -25,9 +25,10 @@
 #ifndef OS_CPU_BSD_X86_VM_GLOBALS_BSD_X86_HPP
 #define OS_CPU_BSD_X86_VM_GLOBALS_BSD_X86_HPP
 
+//
 // Sets the default values for platform dependent flags used by the runtime system.
 // (see globals.hpp)
-
+//
 define_pd_global(bool, DontYieldALot,            false);
 #ifdef AMD64
 define_pd_global(intx, ThreadStackSize,          1024); // 0 => use system default
@@ -41,11 +42,12 @@
 #endif // AMD64
 
 define_pd_global(intx, CompilerThreadStackSize,  0);
+define_pd_global(intx, SurvivorRatio,            8);
 
-define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+define_pd_global(uintx, JVMInvokeMethodSlack,    8192);
 
 // Only used on 64 bit platforms
-define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+define_pd_global(uintx, HeapBaseMinAddress,      2*G);
 // Only used on 64 bit Windows platforms
 define_pd_global(bool, UseVectoredExceptions,    false);
 
--- hotspot/src/os_cpu/bsd_x86/vm/orderAccess_bsd_x86.inline.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/orderAccess_bsd_x86.inline.hpp
@@ -93,7 +93,7 @@
 
 inline void     OrderAccess::store_fence(jbyte*  p, jbyte  v) {
   __asm__ volatile (  "xchgb (%2),%0"
-                    : "=r" (v)
+                    : "=q" (v)
                     : "0" (v), "r" (p)
                     : "memory");
 }
@@ -155,7 +155,7 @@
 // Must duplicate definitions instead of calling store_fence because we don't want to cast away volatile.
 inline void     OrderAccess::release_store_fence(volatile jbyte*  p, jbyte  v) {
   __asm__ volatile (  "xchgb (%2),%0"
-                    : "=r" (v)
+                    : "=q" (v)
                     : "0" (v), "r" (p)
                     : "memory");
 }
--- hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp
+++ hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp
@@ -78,25 +78,209 @@
 # include <sys/wait.h>
 # include <pwd.h>
 # include <poll.h>
+#ifndef __OpenBSD__
 # include <ucontext.h>
-# include <fpu_control.h>
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__) && !defined(__NetBSD__)
+# include <pthread_np.h>
+#endif
 
 #ifdef AMD64
-#define REG_SP REG_RSP
-#define REG_PC REG_RIP
-#define REG_FP REG_RBP
 #define SPELL_REG_SP "rsp"
 #define SPELL_REG_FP "rbp"
 #else
-#define REG_SP REG_UESP
-#define REG_PC REG_EIP
-#define REG_FP REG_EBP
 #define SPELL_REG_SP "esp"
 #define SPELL_REG_FP "ebp"
 #endif // AMD64
 
+#ifdef __FreeBSD__
+# define context_trapno uc_mcontext.mc_trapno
+# ifdef AMD64
+#  define context_pc uc_mcontext.mc_rip
+#  define context_sp uc_mcontext.mc_rsp
+#  define context_fp uc_mcontext.mc_rbp
+#  define context_rip uc_mcontext.mc_rip
+#  define context_rsp uc_mcontext.mc_rsp
+#  define context_rbp uc_mcontext.mc_rbp
+#  define context_rax uc_mcontext.mc_rax
+#  define context_rbx uc_mcontext.mc_rbx
+#  define context_rcx uc_mcontext.mc_rcx
+#  define context_rdx uc_mcontext.mc_rdx
+#  define context_rsi uc_mcontext.mc_rsi
+#  define context_rdi uc_mcontext.mc_rdi
+#  define context_r8  uc_mcontext.mc_r8
+#  define context_r9  uc_mcontext.mc_r9
+#  define context_r10 uc_mcontext.mc_r10
+#  define context_r11 uc_mcontext.mc_r11
+#  define context_r12 uc_mcontext.mc_r12
+#  define context_r13 uc_mcontext.mc_r13
+#  define context_r14 uc_mcontext.mc_r14
+#  define context_r15 uc_mcontext.mc_r15
+#  define context_flags uc_mcontext.mc_flags
+#  define context_err uc_mcontext.mc_err
+# else
+#  define context_pc uc_mcontext.mc_eip
+#  define context_sp uc_mcontext.mc_esp
+#  define context_fp uc_mcontext.mc_ebp
+#  define context_eip uc_mcontext.mc_eip
+#  define context_esp uc_mcontext.mc_esp
+#  define context_eax uc_mcontext.mc_eax
+#  define context_ebx uc_mcontext.mc_ebx
+#  define context_ecx uc_mcontext.mc_ecx
+#  define context_edx uc_mcontext.mc_edx
+#  define context_ebp uc_mcontext.mc_ebp
+#  define context_esi uc_mcontext.mc_esi
+#  define context_edi uc_mcontext.mc_edi
+#  define context_eflags uc_mcontext.mc_eflags
+#  define context_trapno uc_mcontext.mc_trapno
+# endif
+#endif
+
+#ifdef __APPLE__ 
+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+  // 10.5 UNIX03 member name prefixes
+  #define DU3_PREFIX(s, m) __ ## s.__ ## m
+# else
+  #define DU3_PREFIX(s, m) s ## . ## m
+# endif
+
+# ifdef AMD64
+#  define context_pc context_rip
+#  define context_sp context_rsp
+#  define context_fp context_rbp
+#  define context_rip uc_mcontext->DU3_PREFIX(ss,rip)
+#  define context_rsp uc_mcontext->DU3_PREFIX(ss,rsp)
+#  define context_rax uc_mcontext->DU3_PREFIX(ss,rax)
+#  define context_rbx uc_mcontext->DU3_PREFIX(ss,rbx)
+#  define context_rcx uc_mcontext->DU3_PREFIX(ss,rcx)
+#  define context_rdx uc_mcontext->DU3_PREFIX(ss,rdx)
+#  define context_rbp uc_mcontext->DU3_PREFIX(ss,rbp)
+#  define context_rsi uc_mcontext->DU3_PREFIX(ss,rsi)
+#  define context_rdi uc_mcontext->DU3_PREFIX(ss,rdi)
+#  define context_r8  uc_mcontext->DU3_PREFIX(ss,r8)
+#  define context_r9  uc_mcontext->DU3_PREFIX(ss,r9)
+#  define context_r10 uc_mcontext->DU3_PREFIX(ss,r10)
+#  define context_r11 uc_mcontext->DU3_PREFIX(ss,r11)
+#  define context_r12 uc_mcontext->DU3_PREFIX(ss,r12)
+#  define context_r13 uc_mcontext->DU3_PREFIX(ss,r13)
+#  define context_r14 uc_mcontext->DU3_PREFIX(ss,r14)
+#  define context_r15 uc_mcontext->DU3_PREFIX(ss,r15)
+#  define context_flags uc_mcontext->DU3_PREFIX(ss,rflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+#  define context_err uc_mcontext->DU3_PREFIX(es,err)
+# else
+#  define context_pc context_eip
+#  define context_sp context_esp
+#  define context_fp context_ebp
+#  define context_eip uc_mcontext->DU3_PREFIX(ss,eip)
+#  define context_esp uc_mcontext->DU3_PREFIX(ss,esp)
+#  define context_eax uc_mcontext->DU3_PREFIX(ss,eax)
+#  define context_ebx uc_mcontext->DU3_PREFIX(ss,ebx)
+#  define context_ecx uc_mcontext->DU3_PREFIX(ss,ecx)
+#  define context_edx uc_mcontext->DU3_PREFIX(ss,edx)
+#  define context_ebp uc_mcontext->DU3_PREFIX(ss,ebp)
+#  define context_esi uc_mcontext->DU3_PREFIX(ss,esi)
+#  define context_edi uc_mcontext->DU3_PREFIX(ss,edi)
+#  define context_eflags uc_mcontext->DU3_PREFIX(ss,eflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+# endif
+#endif
+
+#ifdef __OpenBSD__
+# define context_trapno sc_trapno
+# ifdef AMD64
+#  define context_pc sc_rip
+#  define context_sp sc_rsp
+#  define context_fp sc_rbp
+#  define context_rip sc_rip
+#  define context_rsp sc_rsp
+#  define context_rbp sc_rbp
+#  define context_rax sc_rax
+#  define context_rbx sc_rbx
+#  define context_rcx sc_rcx
+#  define context_rdx sc_rdx
+#  define context_rsi sc_rsi
+#  define context_rdi sc_rdi
+#  define context_r8  sc_r8
+#  define context_r9  sc_r9
+#  define context_r10 sc_r10
+#  define context_r11 sc_r11
+#  define context_r12 sc_r12
+#  define context_r13 sc_r13
+#  define context_r14 sc_r14
+#  define context_r15 sc_r15
+#  define context_flags sc_rflags
+#  define context_err sc_err
+# else
+#  define context_pc sc_eip
+#  define context_sp sc_esp
+#  define context_fp sc_ebp
+#  define context_eip sc_eip
+#  define context_esp sc_esp
+#  define context_eax sc_eax
+#  define context_ebx sc_ebx
+#  define context_ecx sc_ecx
+#  define context_edx sc_edx
+#  define context_ebp sc_ebp
+#  define context_esi sc_esi
+#  define context_edi sc_edi
+#  define context_eflags sc_eflags
+#  define context_trapno sc_trapno
+# endif
+#endif
+
+#ifdef __NetBSD__
+# define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]
+# ifdef AMD64
+#  define __register_t __greg_t
+#  define context_pc uc_mcontext.__gregs[_REG_RIP]
+#  define context_sp uc_mcontext.__gregs[_REG_URSP]
+#  define context_fp uc_mcontext.__gregs[_REG_RBP]
+#  define context_rip uc_mcontext.__gregs[_REG_RIP]
+#  define context_rsp uc_mcontext.__gregs[_REG_URSP]
+#  define context_rax uc_mcontext.__gregs[_REG_RAX]
+#  define context_rbx uc_mcontext.__gregs[_REG_RBX]
+#  define context_rcx uc_mcontext.__gregs[_REG_RCX]
+#  define context_rdx uc_mcontext.__gregs[_REG_RDX]
+#  define context_rbp uc_mcontext.__gregs[_REG_RBP]
+#  define context_rsi uc_mcontext.__gregs[_REG_RSI]
+#  define context_rdi uc_mcontext.__gregs[_REG_RDI]
+#  define context_r8  uc_mcontext.__gregs[_REG_R8]
+#  define context_r9  uc_mcontext.__gregs[_REG_R9]
+#  define context_r10 uc_mcontext.__gregs[_REG_R10]
+#  define context_r11 uc_mcontext.__gregs[_REG_R11]
+#  define context_r12 uc_mcontext.__gregs[_REG_R12]
+#  define context_r13 uc_mcontext.__gregs[_REG_R13]
+#  define context_r14 uc_mcontext.__gregs[_REG_R14]
+#  define context_r15 uc_mcontext.__gregs[_REG_R15]
+#  define context_flags uc_mcontext.__gregs[_REG_RFL]
+#  define context_err uc_mcontext.__gregs[_REG_ERR]
+# else
+#  define context_pc uc_mcontext.__gregs[_REG_EIP]
+#  define context_sp uc_mcontext.__gregs[_REG_UESP]
+#  define context_fp uc_mcontext.__gregs[_REG_EBP]
+#  define context_eip uc_mcontext.__gregs[_REG_EIP]
+#  define context_esp uc_mcontext.__gregs[_REG_UESP]
+#  define context_eax uc_mcontext.__gregs[_REG_EAX]
+#  define context_ebx uc_mcontext.__gregs[_REG_EBX]
+#  define context_ecx uc_mcontext.__gregs[_REG_ECX]
+#  define context_edx uc_mcontext.__gregs[_REG_EDX]
+#  define context_ebp uc_mcontext.__gregs[_REG_EBP]
+#  define context_esi uc_mcontext.__gregs[_REG_ESI]
+#  define context_edi uc_mcontext.__gregs[_REG_EDI]
+#  define context_eflags uc_mcontext.__gregs[_REG_EFL]
+#  define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]
+# endif
+#endif
+
 address os::current_stack_pointer() {
-#ifdef SPARC_WORKS
+#if defined(__clang__)
+  register void *esp;
+  // XXX must be compiled with -O1 or above.
+  __asm__ volatile("mov %%" SPELL_REG_SP ", %0" : "=r"(esp));
+  return (address) esp;
+#elif defined(SPARC_WORKS)
   register void *esp;
   __asm__("mov %%"SPELL_REG_SP", %0":"=r"(esp));
   return (address) ((char*)esp + sizeof(long)*2);
@@ -119,15 +303,15 @@
 }
 
 address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
-  return (address)uc->uc_mcontext.gregs[REG_PC];
+  return (address)uc->context_pc;
 }
 
 intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_SP];
+  return (intptr_t*)uc->context_sp;
 }
 
 intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_FP];
+  return (intptr_t*)uc->context_fp;
 }
 
 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
@@ -179,7 +363,11 @@
 }
 
 intptr_t* _get_previous_fp() {
-#ifdef SPARC_WORKS
+#if defined(__clang__)
+  register intptr_t **ebp;
+  // XXX must be compiled with -O1 or above.
+  __asm__ volatile("mov %%" SPELL_REG_FP ", %0" : "=r"(ebp));
+#elif defined(SPARC_WORKS)
   register intptr_t **ebp;
   __asm__("mov %%"SPELL_REG_FP", %0":"=r"(ebp));
 #else
@@ -279,18 +467,18 @@
     pc = (address) os::Bsd::ucontext_get_pc(uc);
 
     if (pc == (address) Fetch32PFI) {
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ;
+       uc->context_pc = intptr_t(Fetch32Resume) ;
        return 1 ;
     }
 #ifdef AMD64
     if (pc == (address) FetchNPFI) {
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ;
+       uc->context_pc = intptr_t (FetchNResume) ;
        return 1 ;
     }
 #endif // AMD64
 
     // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
+    if (sig == SIGSEGV || sig == SIGBUS) {
       address addr = (address) info->si_addr;
 
       // check if fault address is within thread stack
@@ -312,6 +500,7 @@
           // to handle_unexpected_exception way down below.
           thread->disable_stack_red_zone();
           tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+#ifndef _ALLBSD_SOURCE
         } else {
           // Accessing stack address below sp may cause SEGV if current
           // thread has MAP_GROWSDOWN stack. This should only happen when
@@ -327,6 +516,7 @@
           } else {
              fatal("recursive segv. expanding stack.");
           }
+#endif
         }
       }
     }
@@ -335,9 +525,16 @@
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
 
-      if (sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {
+      if ((sig == SIGSEGV || sig == SIGBUS) && os::is_poll_address((address)info->si_addr)) {
         stub = SharedRuntime::get_poll_stub(pc);
+#if defined(__APPLE__) && !defined(AMD64)
+      // 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.
+      // Catching SIGBUS here prevents the implicit SIGBUS NULL check below from
+      // being called, so only do so if the implicit NULL check is not necessary.
+      } else if (sig == SIGBUS && MacroAssembler::needs_explicit_null_check((int)info->si_addr)) {
+#else
       } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+#endif
         // BugId 4454115: A read from a MappedByteBuffer can fault
         // here if the underlying file has been truncated.
         // Do not crash the VM in such a case.
@@ -358,6 +555,28 @@
                                               pc,
                                               SharedRuntime::
                                               IMPLICIT_DIVIDE_BY_ZERO);
+#ifdef __APPLE__
+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
+        int op = pc[0];
+
+        // Skip REX
+        if ((pc[0] & 0xf0) == 0x40) {
+          op = pc[1];
+        } else {
+          op = pc[0];
+        }
+
+        // Check for IDIV
+        if (op == 0xF7) {
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime:: IMPLICIT_DIVIDE_BY_ZERO);
+        } else {
+          // TODO: handle more cases if we are using other x86 instructions
+          //   that can generate SIGFPE signal.
+          tty->print_cr("unknown opcode 0x%X with SIGFPE.", op);
+          fatal("please update this code.");
+        }
+#endif /* __APPLE__ */
+
 #else
       if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
         // HACK: si_code does not work on bsd 2.2.12-20!!!
@@ -385,7 +604,7 @@
           fatal("please update this code.");
         }
 #endif // AMD64
-      } else if (sig == SIGSEGV &&
+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&
                !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {
           // Determination of interpreter/vtable stub/compiled code null exception
           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
@@ -409,7 +628,7 @@
     // process of write protecting the memory serialization page.
     // It write enables the page immediately after protecting it
     // so we can just return to retry the write.
-    if ((sig == SIGSEGV) &&
+    if ((sig == SIGSEGV || sig == SIGBUS) &&
         os::is_memory_serialize_page(thread, (address) info->si_addr)) {
       // Block current thread until the memory serialize page permission restored.
       os::block_on_serialize_page_trap();
@@ -430,7 +649,7 @@
   // Furthermore, a false-positive should be harmless.
   if (UnguardOnExecutionViolation > 0 &&
       (sig == SIGSEGV || sig == SIGBUS) &&
-      uc->uc_mcontext.gregs[REG_TRAPNO] == trap_page_fault) {
+      uc->context_trapno == trap_page_fault) {
     int page_size = os::vm_page_size();
     address addr = (address) info->si_addr;
     address pc = os::Bsd::ucontext_get_pc(uc);
@@ -500,7 +719,7 @@
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
 
-    uc->uc_mcontext.gregs[REG_PC] = (greg_t)stub;
+    uc->context_pc = (intptr_t)stub;
     return true;
   }
 
@@ -530,13 +749,24 @@
   ShouldNotReachHere();
 }
 
+#ifdef _ALLBSD_SOURCE
+// From solaris_i486.s ported to bsd_i486.s
+extern "C" void fixcw();
+#endif
+
 void os::Bsd::init_thread_fpu_state(void) {
 #ifndef AMD64
+# ifdef _ALLBSD_SOURCE
+  // Set fpu to 53 bit precision. This happens too early to use a stub.
+  fixcw();
+# else
   // set fpu to 53 bit precision
   set_fpu_control_word(0x27f);
+# endif
 #endif // !AMD64
 }
 
+#ifndef _ALLBSD_SOURCE
 int os::Bsd::get_fpu_control_word(void) {
 #ifdef AMD64
   return 0;
@@ -552,11 +782,12 @@
   _FPU_SETCW(fpu_control);
 #endif // !AMD64
 }
+#endif
 
 // Check that the bsd kernel version is 2.4 or higher since earlier
 // versions do not support SSE without patches.
 bool os::supports_sse() {
-#ifdef AMD64
+#if defined(AMD64) || defined(_ALLBSD_SOURCE)
   return true;
 #else
   struct utsname uts;
@@ -610,6 +841,9 @@
 #define GET_GS() ({int gs; __asm__ volatile("movw %%gs, %w0":"=q"(gs)); gs&0xffff;})
 #endif
 
+#ifdef _ALLBSD_SOURCE
+bool os::Bsd::supports_variable_stack_size() { return true; }
+#else
 // Test if pthread library can support variable thread stack size. BsdThreads
 // in fixed stack mode allocates 2M fixed slot for each thread. BsdThreads
 // in floating stack mode and NPTL support variable stack size.
@@ -632,7 +866,7 @@
     //
     // Note that %gs is a reserved glibc register since early 2001, so
     // applications are not allowed to change its value (Ulrich Drepper from
-    // Red Hat confirmed that all known offenders have been modified to use
+    // Redhat confirmed that all known offenders have been modified to use
     // either %fs or TSD). In the worst case scenario, when VM is embedded in
     // a native application that plays with %gs, we might see non-zero %gs
     // even BsdThreads is running in fixed stack mode. As the result, we'll
@@ -646,6 +880,7 @@
 #endif
   }
 }
+#endif
 #endif // AMD64
 
 // return default stack size for thr_type
@@ -699,6 +934,41 @@
 //    pthread_attr_getstack()
 
 static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_stackseg_np failed with err = %d", rslt));
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#elif defined(_ALLBSD_SOURCE)
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_init failed with err = %d", rslt));
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_get_np failed with err = %d", rslt));
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#else
   if (os::Bsd::is_initial_thread()) {
      // initial thread needs special handling because pthread_getattr_np()
      // may return bogus value.
@@ -725,6 +995,7 @@
      pthread_attr_destroy(&attr);
 
   }
+#endif
   assert(os::current_stack_pointer() >= *bottom &&
          os::current_stack_pointer() < *bottom + *size, "just checking");
 }
@@ -753,46 +1024,44 @@
   ucontext_t *uc = (ucontext_t*)context;
   st->print_cr("Registers:");
 #ifdef AMD64
-  st->print(  "RAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RAX]);
-  st->print(", RBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBX]);
-  st->print(", RCX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RCX]);
-  st->print(", RDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDX]);
-  st->cr();
-  st->print(  "RSP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSP]);
-  st->print(", RBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBP]);
-  st->print(", RSI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSI]);
-  st->print(", RDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDI]);
-  st->cr();
-  st->print(  "R8 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R8]);
-  st->print(", R9 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R9]);
-  st->print(", R10=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R10]);
-  st->print(", R11=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R11]);
-  st->cr();
-  st->print(  "R12=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R12]);
-  st->print(", R13=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R13]);
-  st->print(", R14=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R14]);
-  st->print(", R15=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R15]);
-  st->cr();
-  st->print(  "RIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RIP]);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
-  st->print(", CSGSFS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_CSGSFS]);
-  st->print(", ERR=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ERR]);
-  st->cr();
-  st->print("  TRAPNO=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_TRAPNO]);
-#else
-  st->print(  "EAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EAX]);
-  st->print(", EBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBX]);
-  st->print(", ECX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ECX]);
-  st->print(", EDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDX]);
-  st->cr();
-  st->print(  "ESP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_UESP]);
-  st->print(", EBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBP]);
-  st->print(", ESI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ESI]);
-  st->print(", EDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDI]);
-  st->cr();
-  st->print(  "EIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EIP]);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
-  st->print(", CR2=" INTPTR_FORMAT, uc->uc_mcontext.cr2);
+  st->print(  "RAX=" INTPTR_FORMAT, uc->context_rax);
+  st->print(", RBX=" INTPTR_FORMAT, uc->context_rbx);
+  st->print(", RCX=" INTPTR_FORMAT, uc->context_rcx);
+  st->print(", RDX=" INTPTR_FORMAT, uc->context_rdx);
+  st->cr();
+  st->print(  "RSP=" INTPTR_FORMAT, uc->context_rsp);
+  st->print(", RBP=" INTPTR_FORMAT, uc->context_rbp);
+  st->print(", RSI=" INTPTR_FORMAT, uc->context_rsi);
+  st->print(", RDI=" INTPTR_FORMAT, uc->context_rdi);
+  st->cr();
+  st->print(  "R8 =" INTPTR_FORMAT, uc->context_r8);
+  st->print(", R9 =" INTPTR_FORMAT, uc->context_r9);
+  st->print(", R10=" INTPTR_FORMAT, uc->context_r10);
+  st->print(", R11=" INTPTR_FORMAT, uc->context_r11);
+  st->cr();
+  st->print(  "R12=" INTPTR_FORMAT, uc->context_r12);
+  st->print(", R13=" INTPTR_FORMAT, uc->context_r13);
+  st->print(", R14=" INTPTR_FORMAT, uc->context_r14);
+  st->print(", R15=" INTPTR_FORMAT, uc->context_r15);
+  st->cr();
+  st->print(  "RIP=" INTPTR_FORMAT, uc->context_rip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_flags);
+  st->print(", ERR=" INTPTR_FORMAT, uc->context_err);
+  st->cr();
+  st->print("  TRAPNO=" INTPTR_FORMAT, uc->context_trapno);
+#else
+  st->print(  "EAX=" INTPTR_FORMAT, uc->context_eax);
+  st->print(", EBX=" INTPTR_FORMAT, uc->context_ebx);
+  st->print(", ECX=" INTPTR_FORMAT, uc->context_ecx);
+  st->print(", EDX=" INTPTR_FORMAT, uc->context_edx);
+  st->cr();
+  st->print(  "ESP=" INTPTR_FORMAT, uc->context_esp);
+  st->print(", EBP=" INTPTR_FORMAT, uc->context_ebp);
+  st->print(", ESI=" INTPTR_FORMAT, uc->context_esi);
+  st->print(", EDI=" INTPTR_FORMAT, uc->context_edi);
+  st->cr();
+  st->print(  "EIP=" INTPTR_FORMAT, uc->context_eip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_eflags);
 #endif // AMD64
   st->cr();
   st->cr();
@@ -825,31 +1094,31 @@
   // this is only for the "general purpose" registers
 
 #ifdef AMD64
-  st->print("RAX="); print_location(st, uc->uc_mcontext.gregs[REG_RAX]);
-  st->print("RBX="); print_location(st, uc->uc_mcontext.gregs[REG_RBX]);
-  st->print("RCX="); print_location(st, uc->uc_mcontext.gregs[REG_RCX]);
-  st->print("RDX="); print_location(st, uc->uc_mcontext.gregs[REG_RDX]);
-  st->print("RSP="); print_location(st, uc->uc_mcontext.gregs[REG_RSP]);
-  st->print("RBP="); print_location(st, uc->uc_mcontext.gregs[REG_RBP]);
-  st->print("RSI="); print_location(st, uc->uc_mcontext.gregs[REG_RSI]);
-  st->print("RDI="); print_location(st, uc->uc_mcontext.gregs[REG_RDI]);
-  st->print("R8 ="); print_location(st, uc->uc_mcontext.gregs[REG_R8]);
-  st->print("R9 ="); print_location(st, uc->uc_mcontext.gregs[REG_R9]);
-  st->print("R10="); print_location(st, uc->uc_mcontext.gregs[REG_R10]);
-  st->print("R11="); print_location(st, uc->uc_mcontext.gregs[REG_R11]);
-  st->print("R12="); print_location(st, uc->uc_mcontext.gregs[REG_R12]);
-  st->print("R13="); print_location(st, uc->uc_mcontext.gregs[REG_R13]);
-  st->print("R14="); print_location(st, uc->uc_mcontext.gregs[REG_R14]);
-  st->print("R15="); print_location(st, uc->uc_mcontext.gregs[REG_R15]);
-#else
-  st->print("EAX="); print_location(st, uc->uc_mcontext.gregs[REG_EAX]);
-  st->print("EBX="); print_location(st, uc->uc_mcontext.gregs[REG_EBX]);
-  st->print("ECX="); print_location(st, uc->uc_mcontext.gregs[REG_ECX]);
-  st->print("EDX="); print_location(st, uc->uc_mcontext.gregs[REG_EDX]);
-  st->print("ESP="); print_location(st, uc->uc_mcontext.gregs[REG_ESP]);
-  st->print("EBP="); print_location(st, uc->uc_mcontext.gregs[REG_EBP]);
-  st->print("ESI="); print_location(st, uc->uc_mcontext.gregs[REG_ESI]);
-  st->print("EDI="); print_location(st, uc->uc_mcontext.gregs[REG_EDI]);
+  st->print("RAX="); print_location(st, uc->context_rax);
+  st->print("RBX="); print_location(st, uc->context_rbx);
+  st->print("RCX="); print_location(st, uc->context_rcx);
+  st->print("RDX="); print_location(st, uc->context_rdx);
+  st->print("RSP="); print_location(st, uc->context_rsp);
+  st->print("RBP="); print_location(st, uc->context_rbp);
+  st->print("RSI="); print_location(st, uc->context_rsi);
+  st->print("RDI="); print_location(st, uc->context_rdi);
+  st->print("R8 ="); print_location(st, uc->context_r8);
+  st->print("R9 ="); print_location(st, uc->context_r9);
+  st->print("R10="); print_location(st, uc->context_r10);
+  st->print("R11="); print_location(st, uc->context_r11);
+  st->print("R12="); print_location(st, uc->context_r12);
+  st->print("R13="); print_location(st, uc->context_r13);
+  st->print("R14="); print_location(st, uc->context_r14);
+  st->print("R15="); print_location(st, uc->context_r15);
+#else
+  st->print("EAX="); print_location(st, uc->context_eax);
+  st->print("EBX="); print_location(st, uc->context_ebx);
+  st->print("ECX="); print_location(st, uc->context_ecx);
+  st->print("EDX="); print_location(st, uc->context_edx);
+  st->print("ESP="); print_location(st, uc->context_esp);
+  st->print("EBP="); print_location(st, uc->context_ebp);
+  st->print("ESI="); print_location(st, uc->context_esi);
+  st->print("EDI="); print_location(st, uc->context_edi);
 #endif // AMD64
 
   st->cr();
--- hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp
@@ -30,8 +30,10 @@
 #ifndef AMD64
   // map stack pointer to thread pointer - see notes in threadLS_bsd_x86.cpp
   #define SP_BITLENGTH  32
+#ifndef PAGE_SHIFT
   #define PAGE_SHIFT    12
   #define PAGE_SIZE     (1UL << PAGE_SHIFT)
+#endif
   static Thread* _sp_map[1UL << (SP_BITLENGTH - PAGE_SHIFT)];
 #endif // !AMD64
 
--- hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp
+++ hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp
@@ -29,6 +29,7 @@
 // constants required by the Serviceability Agent. This file is
 // referenced by vmStructs.cpp.
 
+#ifdef __FreeBSD__
 #define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field, last_entry) \
                                                                                                                                      \
   /******************************/                                                                                                   \
@@ -38,6 +39,17 @@
   nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)                         \
   /* This must be the last entry, and must be present */                                                                             \
   last_entry()
+#else
+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field, last_entry) \
+                                                                                                                                     \
+  /******************************/                                                                                                   \
+  /* Threads (NOTE: incomplete) */                                                                                                   \
+  /******************************/                                                                                                   \
+  nonstatic_field(OSThread,                      _thread_id,                                      pthread_t)                         \
+  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)                         \
+  /* This must be the last entry, and must be present */                                                                             \
+  last_entry()
+#endif
 
 
 #define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type, last_entry) \
--- hotspot/src/share/vm/adlc/adlc.hpp
+++ hotspot/src/share/vm/adlc/adlc.hpp
@@ -72,9 +72,9 @@
 #endif
 #endif // _WIN32
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   #include <inttypes.h>
-#endif // LINUX
+#endif // LINUX || _ALLBSD_SOURCE
 
 // Macros
 #define uint32 unsigned int
--- hotspot/src/share/vm/c1/c1_globals.hpp
+++ hotspot/src/share/vm/c1/c1_globals.hpp
@@ -41,6 +41,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "c1_globals_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "c1_globals_bsd.hpp"
+#endif
 
 //
 // Defines all global flags used by the client compiler.
--- hotspot/src/share/vm/classfile/classLoader.cpp
+++ hotspot/src/share/vm/classfile/classLoader.cpp
@@ -68,6 +68,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 // Entry points in zip.dll for loading zip/jar file entries
--- hotspot/src/share/vm/classfile/javaClasses.cpp
+++ hotspot/src/share/vm/classfile/javaClasses.cpp
@@ -55,6 +55,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 static bool find_field(instanceKlass* ik,
                        symbolOop name_symbol, symbolOop signature_symbol,
@@ -991,7 +994,7 @@
     }
     nmethod* nm = method->code();
     if (WizardMode && nm != NULL) {
-      sprintf(buf + (int)strlen(buf), "(nmethod " PTR_FORMAT ")", (intptr_t)nm);
+      sprintf(buf + (int)strlen(buf), "(nmethod " INTPTR_FORMAT ")", (intptr_t)nm);
     }
   }
 
--- hotspot/src/share/vm/code/stubs.hpp
+++ hotspot/src/share/vm/code/stubs.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 // The classes in this file provide a simple framework for the
 // management of little pieces of machine code - or stubs -
--- hotspot/src/share/vm/compiler/disassembler.hpp
+++ hotspot/src/share/vm/compiler/disassembler.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 class decode_env;
 
--- hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/cmsAdaptiveSizePolicy.cpp
+++ hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/cmsAdaptiveSizePolicy.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 elapsedTimer CMSAdaptiveSizePolicy::_concurrent_timer;
 elapsedTimer CMSAdaptiveSizePolicy::_STW_timer;
 
--- hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/cmsCollectorPolicy.cpp
+++ hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/cmsCollectorPolicy.cpp
@@ -50,6 +50,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 //
 // ConcurrentMarkSweepPolicy methods
--- hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepThread.hpp
+++ hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepThread.hpp
@@ -36,6 +36,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 class ConcurrentMarkSweepGeneration;
 class CMSCollector;
--- hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/freeBlockDictionary.cpp
+++ hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/freeBlockDictionary.cpp
@@ -33,6 +33,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifndef PRODUCT
 Mutex* FreeBlockDictionary::par_lock() const {
--- hotspot/src/share/vm/gc_implementation/g1/dirtyCardQueue.cpp
+++ hotspot/src/share/vm/gc_implementation/g1/dirtyCardQueue.cpp
@@ -39,6 +39,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 bool DirtyCardQueue::apply_closure(CardTableEntryClosure* cl,
                                    bool consume,
--- hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.cpp
+++ hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 G1SATBCardTableModRefBS::G1SATBCardTableModRefBS(MemRegion whole_heap,
                                                  int max_covered_regions) :
--- hotspot/src/share/vm/gc_implementation/g1/ptrQueue.cpp
+++ hotspot/src/share/vm/gc_implementation/g1/ptrQueue.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 PtrQueue::PtrQueue(PtrQueueSet* qset, bool perm, bool active) :
   _qset(qset), _buf(NULL), _index(0), _active(active),
--- hotspot/src/share/vm/gc_implementation/parallelScavenge/parMarkBitMap.cpp
+++ hotspot/src/share/vm/gc_implementation/parallelScavenge/parMarkBitMap.cpp
@@ -38,6 +38,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 bool
 ParMarkBitMap::initialize(MemRegion covered_region)
--- hotspot/src/share/vm/gc_implementation/parallelScavenge/psVirtualspace.cpp
+++ hotspot/src/share/vm/gc_implementation/parallelScavenge/psVirtualspace.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 // PSVirtualSpace
 
--- hotspot/src/share/vm/gc_implementation/shared/mutableNUMASpace.cpp
+++ hotspot/src/share/vm/gc_implementation/shared/mutableNUMASpace.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment) {
--- hotspot/src/share/vm/gc_interface/collectedHeap.cpp
+++ hotspot/src/share/vm/gc_interface/collectedHeap.cpp
@@ -39,6 +39,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 #ifdef ASSERT
--- hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
+++ hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
@@ -43,6 +43,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Inline allocation implementations.
 
--- hotspot/src/share/vm/interpreter/abstractInterpreter.hpp
+++ hotspot/src/share/vm/interpreter/abstractInterpreter.hpp
@@ -50,6 +50,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // This file contains the platform-independent parts
 // of the abstract interpreter and the abstract interpreter generator.
--- hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp
+++ hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp
@@ -59,6 +59,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "orderAccess_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "orderAccess_bsd_x86.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "orderAccess_bsd_zero.inline.hpp"
+#endif
 
 
 // no precompiled headers
--- hotspot/src/share/vm/interpreter/bytecodeTracer.cpp
+++ hotspot/src/share/vm/interpreter/bytecodeTracer.cpp
@@ -92,7 +92,7 @@
       // the incoming method.  We could lose a line of trace output.
       // This is acceptable in a debug-only feature.
       st->cr();
-      st->print("[%d] ", (int) Thread::current()->osthread()->thread_id());
+      st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
       method->print_name(st);
       st->cr();
       _current_method = method();
@@ -106,7 +106,7 @@
     }
     _code = code;
      int bci = bcp - method->code_base();
-    st->print("[%d] ", (int) Thread::current()->osthread()->thread_id());
+    st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
     if (Verbose) {
       st->print("%8d  %4d  " INTPTR_FORMAT " " INTPTR_FORMAT " %s",
            BytecodeCounter::counter_value(), bci, tos, tos2, Bytecodes::name(code));
--- hotspot/src/share/vm/interpreter/interpreterRuntime.hpp
+++ hotspot/src/share/vm/interpreter/interpreterRuntime.hpp
@@ -41,6 +41,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // The InterpreterRuntime is called by the interpreter for everything
 // that cannot/should not be dealt with in assembly and needs C support.
--- hotspot/src/share/vm/interpreter/linkResolver.cpp
+++ hotspot/src/share/vm/interpreter/linkResolver.cpp
@@ -52,6 +52,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 //------------------------------------------------------------------------------------------------------------------------
 // Implementation of FieldAccessInfo
--- hotspot/src/share/vm/memory/allocation.cpp
+++ hotspot/src/share/vm/memory/allocation.cpp
@@ -39,6 +39,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 void* CHeapObj::operator new(size_t size){
   return (void *) AllocateHeap(size, "CHeapObj-new");
--- hotspot/src/share/vm/memory/collectorPolicy.cpp
+++ hotspot/src/share/vm/memory/collectorPolicy.cpp
@@ -47,6 +47,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/cmsAdaptiveSizePolicy.hpp"
 #include "gc_implementation/concurrentMarkSweep/cmsGCAdaptivePolicyCounters.hpp"
--- hotspot/src/share/vm/memory/defNewGeneration.cpp
+++ hotspot/src/share/vm/memory/defNewGeneration.cpp
@@ -48,6 +48,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 //
 // DefNewGeneration functions.
--- hotspot/src/share/vm/memory/gcLocker.hpp
+++ hotspot/src/share/vm/memory/gcLocker.hpp
@@ -41,6 +41,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 // The direct lock/unlock calls do not force a collection if an unlock
 // decrements the count to zero. Avoid calling these if at all possible.
--- hotspot/src/share/vm/memory/genMarkSweep.cpp
+++ hotspot/src/share/vm/memory/genMarkSweep.cpp
@@ -55,6 +55,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 void GenMarkSweep::invoke_at_safepoint(int level, ReferenceProcessor* rp,
   bool clear_all_softrefs) {
--- hotspot/src/share/vm/memory/resourceArea.cpp
+++ hotspot/src/share/vm/memory/resourceArea.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 //------------------------------ResourceMark-----------------------------------
 debug_only(int ResourceArea::_warned;)      // to suppress multiple warnings
--- hotspot/src/share/vm/memory/resourceArea.hpp
+++ hotspot/src/share/vm/memory/resourceArea.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // The resource area holds temporary data structures in the VM.
 // The actual allocation areas are thread local. Typical usage:
--- hotspot/src/share/vm/memory/space.hpp
+++ hotspot/src/share/vm/memory/space.hpp
@@ -44,6 +44,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 // A space is an abstraction for the "storage units" backing
 // up the generation abstraction. It includes specific
--- hotspot/src/share/vm/memory/threadLocalAllocBuffer.cpp
+++ hotspot/src/share/vm/memory/threadLocalAllocBuffer.cpp
@@ -38,6 +38,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Thread-Local Edens support
 
--- hotspot/src/share/vm/memory/universe.cpp
+++ hotspot/src/share/vm/memory/universe.cpp
@@ -89,6 +89,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/cmsAdaptiveSizePolicy.hpp"
 #include "gc_implementation/concurrentMarkSweep/cmsCollectorPolicy.hpp"
--- hotspot/src/share/vm/oops/constantPoolKlass.cpp
+++ hotspot/src/share/vm/oops/constantPoolKlass.cpp
@@ -44,6 +44,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/parNew/parOopClosures.inline.hpp"
 #include "gc_implementation/parallelScavenge/psPromotionManager.inline.hpp"
--- hotspot/src/share/vm/oops/instanceKlass.cpp
+++ hotspot/src/share/vm/oops/instanceKlass.cpp
@@ -59,6 +59,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
 #include "gc_implementation/g1/g1OopClosures.inline.hpp"
--- hotspot/src/share/vm/oops/markOop.cpp
+++ hotspot/src/share/vm/oops/markOop.cpp
@@ -33,6 +33,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 void markOopDesc::print_on(outputStream* st) const {
--- hotspot/src/share/vm/oops/oop.cpp
+++ hotspot/src/share/vm/oops/oop.cpp
@@ -36,6 +36,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 bool always_do_update_barrier = false;
 
--- hotspot/src/share/vm/oops/oopsHierarchy.cpp
+++ hotspot/src/share/vm/oops/oopsHierarchy.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifdef CHECK_UNHANDLED_OOPS
 
--- hotspot/src/share/vm/opto/c2_globals.hpp
+++ hotspot/src/share/vm/opto/c2_globals.hpp
@@ -41,6 +41,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "c2_globals_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "c2_globals_bsd.hpp"
+#endif
 
 //
 // Defines all globals flags used by the server compiler.
--- hotspot/src/share/vm/prims/forte.cpp
+++ hotspot/src/share/vm/prims/forte.cpp
@@ -639,6 +639,11 @@
 // Method to let libcollector know about a dynamically loaded function.
 // Because it is weakly bound, the calls become NOP's when the library
 // isn't present.
+#ifdef __APPLE__
+// XXXDARWIN: Link errors occur even when __attribute__((weak_import))
+// is added
+#define collector_func_load(x0,x1,x2,x3,x4,x5,x6) (0)
+#else
 void    collector_func_load(char* name,
                             void* null_argument_1,
                             void* null_argument_2,
@@ -649,6 +654,7 @@
 #pragma weak collector_func_load
 #define collector_func_load(x0,x1,x2,x3,x4,x5,x6) \
         ( collector_func_load ? collector_func_load(x0,x1,x2,x3,x4,x5,x6),0 : 0 )
+#endif // __APPLE__
 #endif // !_WINDOWS
 
 } // end extern "C"
--- hotspot/src/share/vm/prims/jni.cpp
+++ hotspot/src/share/vm/prims/jni.cpp
@@ -88,6 +88,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 static jint CurrentVersion = JNI_VERSION_1_6;
 
--- hotspot/src/share/vm/prims/jvm.cpp
+++ hotspot/src/share/vm/prims/jvm.cpp
@@ -72,6 +72,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "jvm_windows.h"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "jvm_bsd.h"
+#endif
 
 #include <errno.h>
 
--- hotspot/src/share/vm/prims/jvm.h
+++ hotspot/src/share/vm/prims/jvm.h
@@ -36,6 +36,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "jvm_windows.h"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "jvm_bsd.h"
+#endif
 
 #ifndef _JAVASOFT_JVM_H_
 #define _JAVASOFT_JVM_H_
--- hotspot/src/share/vm/prims/jvmtiEnv.cpp
+++ hotspot/src/share/vm/prims/jvmtiEnv.cpp
@@ -68,6 +68,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 
--- hotspot/src/share/vm/prims/jvmtiImpl.cpp
+++ hotspot/src/share/vm/prims/jvmtiImpl.cpp
@@ -51,6 +51,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 //
 // class JvmtiAgentThread
--- hotspot/src/share/vm/prims/nativeLookup.cpp
+++ hotspot/src/share/vm/prims/nativeLookup.cpp
@@ -49,6 +49,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 static void mangle_name_on(outputStream* st, symbolOop name, int begin, int end) {
--- hotspot/src/share/vm/runtime/arguments.cpp
+++ hotspot/src/share/vm/runtime/arguments.cpp
@@ -55,6 +55,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.hpp"
 #endif
--- hotspot/src/share/vm/runtime/atomic.cpp
+++ hotspot/src/share/vm/runtime/atomic.cpp
@@ -33,6 +33,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_linux_x86
 # include "atomic_linux_x86.inline.hpp"
 #endif
@@ -51,6 +54,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "atomic_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "atomic_bsd_x86.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "atomic_bsd_zero.inline.hpp"
+#endif
 
 jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) {
   assert(sizeof(jbyte) == 1, "assumption.");
--- hotspot/src/share/vm/runtime/fprofiler.hpp
+++ hotspot/src/share/vm/runtime/fprofiler.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // a simple flat profiler for Java
 
--- hotspot/src/share/vm/runtime/globals.hpp
+++ hotspot/src/share/vm/runtime/globals.hpp
@@ -44,6 +44,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "globals_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "globals_bsd.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_linux_x86
 # include "globals_linux_x86.hpp"
 #endif
@@ -62,6 +65,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "globals_windows_x86.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "globals_bsd_x86.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "globals_bsd_zero.hpp"
+#endif
 #ifdef COMPILER1
 #ifdef TARGET_ARCH_x86
 # include "c1_globals_x86.hpp"
@@ -78,6 +87,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "c1_globals_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "c1_globals_bsd.hpp"
+#endif
 #endif
 #ifdef COMPILER2
 #ifdef TARGET_ARCH_x86
@@ -95,6 +107,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "c2_globals_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "c2_globals_bsd.hpp"
+#endif
 #endif
 #ifdef SHARK
 #ifdef TARGET_ARCH_zero
--- hotspot/src/share/vm/runtime/handles.cpp
+++ hotspot/src/share/vm/runtime/handles.cpp
@@ -38,6 +38,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifdef ASSERT
 oop* HandleArea::allocate_handle(oop obj) {
--- hotspot/src/share/vm/runtime/handles.inline.hpp
+++ hotspot/src/share/vm/runtime/handles.inline.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // these inline functions are in a separate file to break an include cycle
 // between Thread and Handle
--- hotspot/src/share/vm/runtime/interfaceSupport.hpp
+++ hotspot/src/share/vm/runtime/interfaceSupport.hpp
@@ -44,6 +44,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Wrapper for all entry points to the virtual machine.
 // The HandleMarkCleaner is a faster version of HandleMark.
@@ -114,6 +117,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "interfaceSupport_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "interfaceSupport_bsd.hpp"
+#endif
 
 };
 
--- hotspot/src/share/vm/runtime/java.cpp
+++ hotspot/src/share/vm/runtime/java.cpp
@@ -79,6 +79,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/concurrentMarkSweepThread.hpp"
 #include "gc_implementation/parallelScavenge/psScavenge.hpp"
--- hotspot/src/share/vm/runtime/javaCalls.cpp
+++ hotspot/src/share/vm/runtime/javaCalls.cpp
@@ -48,6 +48,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // -----------------------------------------------------
 // Implementation of JavaCallWrapper
--- hotspot/src/share/vm/runtime/javaCalls.hpp
+++ hotspot/src/share/vm/runtime/javaCalls.hpp
@@ -48,6 +48,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // A JavaCallWrapper is constructed before each JavaCall and destructed after the call.
 // Its purpose is to allocate/deallocate a new handle block and to save/restore the last
--- hotspot/src/share/vm/runtime/javaFrameAnchor.hpp
+++ hotspot/src/share/vm/runtime/javaFrameAnchor.hpp
@@ -44,6 +44,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "orderAccess_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "orderAccess_bsd_x86.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "orderAccess_bsd_zero.inline.hpp"
+#endif
 //
 // An object for encapsulating the machine/os dependent part of a JavaThread frame state
 //
--- hotspot/src/share/vm/runtime/jniHandles.cpp
+++ hotspot/src/share/vm/runtime/jniHandles.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 JNIHandleBlock* JNIHandles::_global_handles       = NULL;
--- hotspot/src/share/vm/runtime/memprofiler.cpp
+++ hotspot/src/share/vm/runtime/memprofiler.cpp
@@ -46,6 +46,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifndef PRODUCT
 
--- hotspot/src/share/vm/runtime/mutex.cpp
+++ hotspot/src/share/vm/runtime/mutex.cpp
@@ -39,6 +39,10 @@
 # include "mutex_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "mutex_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 // o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o
 //
--- hotspot/src/share/vm/runtime/mutexLocker.cpp
+++ hotspot/src/share/vm/runtime/mutexLocker.cpp
@@ -36,6 +36,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Mutexes used in the VM (see comment in mutexLocker.hpp):
 //
--- hotspot/src/share/vm/runtime/mutexLocker.hpp
+++ hotspot/src/share/vm/runtime/mutexLocker.hpp
@@ -36,6 +36,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 // Mutexes used in the VM.
 
--- hotspot/src/share/vm/runtime/objectMonitor.cpp
+++ hotspot/src/share/vm/runtime/objectMonitor.cpp
@@ -50,6 +50,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 #if defined(__GNUC__) && !defined(IA64)
   // Need to inhibit inlining for older versions of GCC to avoid build-time failures
--- hotspot/src/share/vm/runtime/os.cpp
+++ hotspot/src/share/vm/runtime/os.cpp
@@ -60,6 +60,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 # include <signal.h>
 
@@ -115,7 +119,11 @@
     assert(false, "Failed localtime_pd");
     return NULL;
   }
+#if defined(_ALLBSD_SOURCE)
+  const time_t zone = (time_t) time_struct.tm_gmtoff;
+#else
   const time_t zone = timezone;
+#endif
 
   // If daylight savings time is in effect,
   // we are 1 hour East of our time zone
--- hotspot/src/share/vm/runtime/os.hpp
+++ hotspot/src/share/vm/runtime/os.hpp
@@ -30,6 +30,9 @@
 #include "runtime/extendedPC.hpp"
 #include "runtime/handles.hpp"
 #include "utilities/top.hpp"
+#ifdef TARGET_OS_FAMILY_bsd
+# include "jvm_bsd.h"
+#endif
 #ifdef TARGET_OS_FAMILY_linux
 # include "jvm_linux.h"
 #endif
@@ -658,6 +661,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_linux_x86
 # include "os_linux_x86.hpp"
 #endif
@@ -676,6 +682,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "os_windows_x86.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "os_bsd_x86.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_linux_zero
+# include "os_bsd_zero.hpp"
+#endif
 
 
   // debugging support (mostly used by debug.cpp but also fatal error handler)
--- hotspot/src/share/vm/runtime/osThread.hpp
+++ hotspot/src/share/vm/runtime/osThread.hpp
@@ -109,6 +109,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "osThread_windows.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "osThread_bsd.hpp"
+#endif
 
 };
 
--- hotspot/src/share/vm/runtime/safepoint.cpp
+++ hotspot/src/share/vm/runtime/safepoint.cpp
@@ -70,6 +70,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/concurrentMarkSweepThread.hpp"
 #include "gc_implementation/shared/concurrentGCThread.hpp"
--- hotspot/src/share/vm/runtime/synchronizer.cpp
+++ hotspot/src/share/vm/runtime/synchronizer.cpp
@@ -51,6 +51,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 #if defined(__GNUC__) && !defined(IA64)
   // Need to inhibit inlining for older versions of GCC to avoid build-time failures
--- hotspot/src/share/vm/runtime/task.cpp
+++ hotspot/src/share/vm/runtime/task.cpp
@@ -39,6 +39,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 int PeriodicTask::_num_tasks = 0;
 PeriodicTask* PeriodicTask::_tasks[PeriodicTask::max_tasks];
--- hotspot/src/share/vm/runtime/thread.cpp
+++ hotspot/src/share/vm/runtime/thread.cpp
@@ -88,6 +88,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/concurrentMarkSweepThread.hpp"
 #include "gc_implementation/g1/concurrentMarkThread.inline.hpp"
--- hotspot/src/share/vm/runtime/thread.hpp
+++ hotspot/src/share/vm/runtime/thread.hpp
@@ -1598,6 +1598,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "thread_windows_x86.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "thread_bsd_x86.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "thread_bsd_zero.hpp"
+#endif
 
 
  public:
--- hotspot/src/share/vm/runtime/threadLocalStorage.cpp
+++ hotspot/src/share/vm/runtime/threadLocalStorage.cpp
@@ -36,6 +36,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 // static member initialization
 int ThreadLocalStorage::_thread_index = -1;
--- hotspot/src/share/vm/runtime/threadLocalStorage.hpp
+++ hotspot/src/share/vm/runtime/threadLocalStorage.hpp
@@ -62,6 +62,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "threadLS_windows_x86.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "threadLS_bsd_x86.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "threadLS_bsd_zero.hpp"
+#endif
 
 
  public:
--- hotspot/src/share/vm/runtime/timer.cpp
+++ hotspot/src/share/vm/runtime/timer.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 void elapsedTimer::add(elapsedTimer t) {
--- hotspot/src/share/vm/runtime/virtualspace.cpp
+++ hotspot/src/share/vm/runtime/virtualspace.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 // ReservedSpace
--- hotspot/src/share/vm/runtime/vmStructs.cpp
+++ hotspot/src/share/vm/runtime/vmStructs.cpp
@@ -118,6 +118,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_linux_x86
 # include "vmStructs_linux_x86.hpp"
 #endif
@@ -136,6 +139,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "vmStructs_windows_x86.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "vmStructs_bsd_x86.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "vmStructs_bsd_zero.hpp"
+#endif
 #ifndef SERIALGC
 #include "gc_implementation/concurrentMarkSweep/cmsPermGen.hpp"
 #include "gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.hpp"
--- hotspot/src/share/vm/runtime/vmThread.cpp
+++ hotspot/src/share/vm/runtime/vmThread.cpp
@@ -46,6 +46,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 HS_DTRACE_PROBE_DECL3(hotspot, vmops__request, char *, uintptr_t, int);
 HS_DTRACE_PROBE_DECL3(hotspot, vmops__begin, char *, uintptr_t, int);
--- hotspot/src/share/vm/runtime/vmThread.hpp
+++ hotspot/src/share/vm/runtime/vmThread.hpp
@@ -36,6 +36,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 //
 // Prioritized queue of VM operations.
--- hotspot/src/share/vm/runtime/vm_operations.cpp
+++ hotspot/src/share/vm/runtime/vm_operations.cpp
@@ -43,6 +43,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 #define VM_OP_NAME_INITIALIZE(name) #name,
 
--- hotspot/src/share/vm/runtime/vm_version.cpp
+++ hotspot/src/share/vm/runtime/vm_version.cpp
@@ -160,7 +160,8 @@
 
 #define OS       LINUX_ONLY("linux")             \
                  WINDOWS_ONLY("windows")         \
-                 SOLARIS_ONLY("solaris")
+                 SOLARIS_ONLY("solaris")         \
+                 BSD_ONLY("bsd")
 
 #ifdef ZERO
 #define CPU      ZERO_LIBARCH
--- hotspot/src/share/vm/utilities/accessFlags.cpp
+++ hotspot/src/share/vm/utilities/accessFlags.cpp
@@ -34,6 +34,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 void AccessFlags::atomic_set_bits(jint bits) {
--- hotspot/src/share/vm/utilities/array.cpp
+++ hotspot/src/share/vm/utilities/array.cpp
@@ -34,6 +34,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 #ifdef ASSERT
--- hotspot/src/share/vm/utilities/bitMap.cpp
+++ hotspot/src/share/vm/utilities/bitMap.cpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 
 BitMap::BitMap(bm_word_t* map, idx_t size_in_bits) :
--- hotspot/src/share/vm/utilities/debug.cpp
+++ hotspot/src/share/vm/utilities/debug.cpp
@@ -62,6 +62,10 @@
 # include "os_windows.inline.hpp"
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifndef ASSERT
 #  ifdef _DEBUG
--- hotspot/src/share/vm/utilities/elfFile.hpp
+++ hotspot/src/share/vm/utilities/elfFile.hpp
@@ -41,7 +41,9 @@
 typedef Elf64_Shdr      Elf_Shdr;
 typedef Elf64_Sym       Elf_Sym;
 
+#ifndef _ALLBSD_SOURCE
 #define ELF_ST_TYPE ELF64_ST_TYPE
+#endif
 
 #else
 
@@ -55,8 +57,10 @@
 typedef Elf32_Shdr      Elf_Shdr;
 typedef Elf32_Sym       Elf_Sym;
 
+#ifndef _ALLBSD_SOURCE
 #define ELF_ST_TYPE ELF32_ST_TYPE
 #endif
+#endif
 
 #include "globalDefinitions.hpp"
 #include "memory/allocation.hpp"
--- hotspot/src/share/vm/utilities/events.cpp
+++ hotspot/src/share/vm/utilities/events.cpp
@@ -38,6 +38,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 #ifndef PRODUCT
--- hotspot/src/share/vm/utilities/exceptions.cpp
+++ hotspot/src/share/vm/utilities/exceptions.cpp
@@ -42,6 +42,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 
 // Implementation of ThreadShadow
--- hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp
+++ hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp
@@ -76,13 +76,26 @@
 # include <sys/procfs.h>
 # endif
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #define __STDC_LIMIT_MACROS
 #include <inttypes.h>
 #include <signal.h>
+#ifndef __OpenBSD__
 #include <ucontext.h>
+#endif
+#ifdef __APPLE__
+  #include <AvailabilityMacros.h>
+  #if (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4)
+    // Mac OS X 10.4 defines EFL_AC and EFL_ID,
+    // which conflict with hotspot variable names.
+    //
+    // This has been fixed in Mac OS X 10.5.
+    #undef EFL_AC
+    #undef EFL_ID
+  #endif
+#endif
 #include <sys/time.h>
-#endif // LINUX
+#endif // LINUX || _ALLBSD_SOURCE
 
 // 4810578: varargs unsafe on 32-bit integer/64-bit pointer architectures
 // When __cplusplus is defined, NULL is defined as 0 (32-bit constant) in
@@ -118,7 +131,7 @@
 // pointer is stored as integer value.  On some platforms, sizeof(intptr_t) >
 // sizeof(void*), so here we want something which is integer type, but has the
 // same size as a pointer.
-#ifdef LINUX
+#ifdef __GNUC__
   #ifdef _LP64
     #define NULL_WORD  0L
   #else
@@ -130,7 +143,7 @@
   #define NULL_WORD  NULL
 #endif
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 // Compiler-specific primitive types
 typedef unsigned short     uint16_t;
 #ifndef _UINT32_T
@@ -150,7 +163,7 @@
 // prior definition of intptr_t, and add "&& !defined(XXX)" above.
 #endif // _SYS_INT_TYPES_H
 
-#endif // !LINUX
+#endif // !LINUX && !_ALLBSD_SOURCE
 
 // Additional Java basic types
 
@@ -242,7 +255,9 @@
 inline int g_isnan(float  f) { return isnand(f); }
 #endif
 inline int g_isnan(double f) { return isnand(f); }
-#elif LINUX
+#elif defined(__APPLE__)
+inline int g_isnan(double f) { return isnan(f); }
+#elif defined(LINUX) || defined(_ALLBSD_SOURCE)
 inline int g_isnan(float  f) { return isnanf(f); }
 inline int g_isnan(double f) { return isnan(f); }
 #else
--- hotspot/src/share/vm/utilities/growableArray.cpp
+++ hotspot/src/share/vm/utilities/growableArray.cpp
@@ -34,6 +34,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 #ifdef ASSERT
 void GenericGrowableArray::set_nesting() {
   if (on_stack()) {
--- hotspot/src/share/vm/utilities/hashtable.hpp
+++ hotspot/src/share/vm/utilities/hashtable.hpp
@@ -283,7 +283,7 @@
   }
 
   int index_for(symbolHandle name, Handle loader) {
-    return hash_to_index(compute_hash(name, loader));
+    return this->hash_to_index(compute_hash(name, loader));
   }
 };
 
--- hotspot/src/share/vm/utilities/histogram.hpp
+++ hotspot/src/share/vm/utilities/histogram.hpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 // This class provides a framework for collecting various statistics.
 // The current implementation is oriented towards counting invocations
--- hotspot/src/share/vm/utilities/macros.hpp
+++ hotspot/src/share/vm/utilities/macros.hpp
@@ -161,6 +161,14 @@
 #define NOT_WINDOWS(code) code
 #endif
 
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
+#define BSD_ONLY(code) code
+#define NOT_BSD(code)
+#else
+#define BSD_ONLY(code)
+#define NOT_BSD(code) code
+#endif
+
 #if defined(IA32) || defined(AMD64)
 #define X86
 #define X86_ONLY(code) code
--- hotspot/src/share/vm/utilities/ostream.cpp
+++ hotspot/src/share/vm/utilities/ostream.cpp
@@ -39,6 +39,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "os_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "os_bsd.inline.hpp"
+#endif
 
 extern "C" void jio_print(const char* s); // Declarationtion of jvm method
 
@@ -863,7 +866,7 @@
 
 #ifndef PRODUCT
 
-#if defined(SOLARIS) || defined(LINUX)
+#if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
--- hotspot/src/share/vm/utilities/preserveException.hpp
+++ hotspot/src/share/vm/utilities/preserveException.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // This file provides more support for exception handling; see also exceptions.hpp
 class PreserveExceptionMark {
--- hotspot/src/share/vm/utilities/taskqueue.cpp
+++ hotspot/src/share/vm/utilities/taskqueue.cpp
@@ -37,6 +37,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 #ifdef TRACESPINNING
 uint ParallelTaskTerminator::_total_yields = 0;
--- hotspot/src/share/vm/utilities/taskqueue.hpp
+++ hotspot/src/share/vm/utilities/taskqueue.hpp
@@ -47,6 +47,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "orderAccess_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "orderAccess_bsd_x86.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "orderAccess_bsd_zero.inline.hpp"
+#endif
 
 // Simple TaskQueue stats that are collected by default in debug builds.
 
--- hotspot/src/share/vm/utilities/vmError.cpp
+++ hotspot/src/share/vm/utilities/vmError.cpp
@@ -44,13 +44,18 @@
   "JAVA_HOME", "JRE_HOME", "JAVA_TOOL_OPTIONS", "_JAVA_OPTIONS", "CLASSPATH",
   "JAVA_COMPILER", "PATH", "USERNAME",
 
-  // Env variables that are defined on Solaris/Linux
+  // Env variables that are defined on Solaris/Linux/BSD
   "LD_LIBRARY_PATH", "LD_PRELOAD", "SHELL", "DISPLAY",
   "HOSTTYPE", "OSTYPE", "ARCH", "MACHTYPE",
 
   // defined on Linux
   "LD_ASSUME_KERNEL", "_JAVA_SR_SIGNUM",
 
+  // defined on Darwin
+  "DYLD_LIBRARY_PATH", "DYLD_FALLBACK_LIBRARY_PATH",
+  "DYLD_FRAMEWORK_PATH", "DYLD_FALLBACK_FRAMEWORK_PATH",
+  "DYLD_INSERT_LIBRARIES",
+
   // defined on Windows
   "OS", "PROCESSOR_IDENTIFIER", "_ALT_JAVA_HOME_DIR",
 
@@ -922,7 +927,7 @@
     const char* ptr = OnError;
     while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){
       out.print_raw   ("#   Executing ");
-#if defined(LINUX)
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
       out.print_raw   ("/bin/sh -c ");
 #elif defined(SOLARIS)
       out.print_raw   ("/usr/bin/sh -c ");
--- hotspot/src/share/vm/utilities/workgroup.hpp
+++ hotspot/src/share/vm/utilities/workgroup.hpp
@@ -35,6 +35,9 @@
 #ifdef TARGET_OS_FAMILY_windows
 # include "thread_windows.inline.hpp"
 #endif
+#ifdef TARGET_OS_FAMILY_bsd
+# include "thread_bsd.inline.hpp"
+#endif
 
 // Forward declarations of classes defined here
 
--- jdk/make/com/sun/java/pack/Makefile
+++ jdk/make/com/sun/java/pack/Makefile
@@ -61,6 +61,7 @@
 
 
 ifeq ($(STANDALONE),true)
+ ifneq ($(SYSTEM_ZLIB),true)
   ZIPOBJDIR = $(OUTPUTDIR)/tmp/sun/java.util.zip/zip/$(OBJDIRNAME)
 
   ZIPOBJS =  $(ZIPOBJDIR)/zcrc32.$(OBJECT_SUFFIX) \
@@ -78,6 +79,10 @@
   ZINCLUDE=-I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
   OTHER_CXXFLAGS += $(ZINCLUDE)
   LDDFLAGS += $(ZIPOBJS)
+ else
+  LDDFLAGS += -lz
+  OTHER_CXXFLAGS += -DSYSTEM_ZLIB
+ endif
 else
   OTHER_CXXFLAGS += -DNO_ZLIB -DUNPACK_JNI
   OTHER_LDLIBS += $(JVMLIB)
@@ -102,7 +107,11 @@
   COMPILER_WARNINGS_FATAL=false
 else
   LDOUTPUT = -o #Have a space 
+ifeq ($(PLATFORM), bsd)
+  LDDFLAGS += -pthread
+else
   LDDFLAGS += -lc
+endif
   OTHER_LDLIBS  += $(LIBCXX)
 # setup the list of libraries to link in...
 ifeq ($(PLATFORM), linux)
--- jdk/make/com/sun/security/auth/module/Makefile
+++ jdk/make/com/sun/security/auth/module/Makefile
@@ -70,7 +70,7 @@
   include FILES_c_solaris.gmk
 endif # solaris
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   LIBRARY = jaas_unix
   include FILES_export_unix.gmk
   include FILES_c_unix.gmk
--- jdk/make/com/sun/tools/attach/Exportedfiles.gmk
+++ jdk/make/com/sun/tools/attach/Exportedfiles.gmk
@@ -43,5 +43,7 @@
 	sun/tools/attach/LinuxVirtualMachine.java
 endif
 
-
-
+ifeq ($(PLATFORM), bsd)
+FILES_export = \
+	sun/tools/attach/BsdVirtualMachine.java
+endif
--- jdk/make/com/sun/tools/attach/FILES_c.gmk
+++ jdk/make/com/sun/tools/attach/FILES_c.gmk
@@ -39,4 +39,7 @@
 	LinuxVirtualMachine.c
 endif
 
-
+ifeq ($(PLATFORM),bsd)
+FILES_c = \
+	BsdVirtualMachine.c
+endif
--- jdk/make/com/sun/tools/attach/FILES_java.gmk
+++ jdk/make/com/sun/tools/attach/FILES_java.gmk
@@ -43,6 +43,11 @@
 	sun/tools/attach/LinuxAttachProvider.java
 endif
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+	sun/tools/attach/BsdAttachProvider.java
+endif
+
 #
 # Files that need to be copied
 #
--- jdk/make/com/sun/tools/attach/Makefile
+++ jdk/make/com/sun/tools/attach/Makefile
@@ -36,6 +36,9 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 
 #
--- jdk/make/com/sun/tools/attach/mapfile-bsd
+++ jdk/make/com/sun/tools/attach/mapfile-bsd
@@ -30,14 +30,12 @@
 	    Java_sun_tools_attach_BsdVirtualMachine_checkPermissions;
 	    Java_sun_tools_attach_BsdVirtualMachine_close;
 	    Java_sun_tools_attach_BsdVirtualMachine_connect;
-	    Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager;
-	    Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads;
 	    Java_sun_tools_attach_BsdVirtualMachine_open;
 	    Java_sun_tools_attach_BsdVirtualMachine_sendQuitTo;
-            Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf;
 	    Java_sun_tools_attach_BsdVirtualMachine_socket;
 	    Java_sun_tools_attach_BsdVirtualMachine_read;
 	    Java_sun_tools_attach_BsdVirtualMachine_write;
+	    Java_sun_tools_attach_BsdVirtualMachine_createAttachFile;
 	local:
 		*;
 };
--- jdk/make/common/Defs-bsd.gmk
+++ jdk/make/common/Defs-bsd.gmk
@@ -43,12 +43,6 @@
 # Get shared JDK settings
 include $(JDK_MAKE_SHARED_DIR)/Defs.gmk
 
-# Part of INCREMENTAL_BUILD mechanism.
-#   Compiler emits things like:  path/file.o: file.h
-#   We want something like: relative_path/file.o relative_path/file.d: file.h
-CC_DEPEND	 = -MM
-CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
-
 ifndef PLATFORM_SRC
   PLATFORM_SRC = $(BUILDDIR)/../src/solaris
 endif # PLATFORM_SRC
@@ -61,7 +55,7 @@
 endif
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -104,6 +98,10 @@
 #    as the default.
 CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
@@ -201,7 +199,7 @@
   CPP_ARCH_FLAGS += -D_$(ARCH)_
 endif
 
-CPPFLAGS_COMMON = $(CPP_ARCH_FLAGS) -DLINUX $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = $(CPP_ARCH_FLAGS) -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -211,33 +209,15 @@
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -Xlinker -z -Xlinker defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
-LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+
+ifneq ($(OS_VENDOR), Apple)
+LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -259,9 +239,9 @@
 ifeq ($(VARIANT), OPT)
   ifneq ($(NO_STRIP), true)
     ifneq ($(DEBUG_BINARIES), true)
-      # Debug 'strip -g' leaves local function Elf symbols (better stack
+      # Debug 'strip -S' leaves local function Elf symbols (better stack
       # traces)
-      POST_STRIP_PROCESS = $(STRIP) -g
+      POST_STRIP_PROCESS = $(STRIP) -S
     endif
   endif
 endif
@@ -271,13 +251,9 @@
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
-#
-# Support for Quantify.
-#
-ifdef QUANTIFY
-QUANTIFY_CMD = quantify
-QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
-LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
 endif
 
 #
@@ -306,7 +282,9 @@
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
@@ -317,13 +295,9 @@
 override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
-override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override NO_INTERRUPTIBLE_IO     = false
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
@@ -344,6 +318,14 @@
 # DPS (Displayable PostScript) is available on Solaris machines
 HAVE_DPS = no
 
+ifeq ($(OS_VENDOR), FreeBSD)
+  SYSTEM_ZLIB = true
+endif
+
+ifeq ($(OS_VENDOR), OpenBSD)
+  SYSTEM_ZLIB = true
+endif
+
 #
 # Japanese manpages
 #
--- jdk/make/common/Defs-linux.gmk
+++ jdk/make/common/Defs-linux.gmk
@@ -318,7 +318,7 @@
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
--- jdk/make/common/Defs.gmk
+++ jdk/make/common/Defs.gmk
@@ -117,6 +117,24 @@
 _OUTPUTDIR=$(JDK_TOPDIR)/build/$(PLATFORM)-$(ARCH)
 endif
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -152,6 +170,7 @@
 
   ifdef ALT_FREETYPE_LIB_PATH
     FREETYPE_LIB_PATH = $(ALT_FREETYPE_LIB_PATH)
+    USING_SYSTEM_FT_LIB=true
   else
     ifeq ($(DEVTOOLS_FT_DIR_EXISTS), true)
       FREETYPE_LIB_PATH = $(DEVTOOLS_FT_DIR)/lib
@@ -216,6 +235,10 @@
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
+
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
--- jdk/make/common/Program.gmk
+++ jdk/make/common/Program.gmk
@@ -67,11 +67,27 @@
 # Create a dependency on libjli (Java Launcher Infrastructure)
 #
 # On UNIX, this is a relative dependency using $ORIGIN. Unfortunately, to
-# do this reliably on Linux takes a different syntax than Solaris.
+# do this reliably on Linux takes a different syntax than Solaris. BSD's
+# don't support $ORIGIN so build an archive instead.
 #
 # On Windows, this is done by using the same directory as the executable
 # itself, as with all the Windows libraries.
 #
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+# Work-around an dlsym(RTLD_DEFAULT) bug in at least FreeBSD & OpenBSD
+    LDFLAGS += -Wl,--export-dynamic
+  endif
+  ifeq ($(SYSTEM_ZLIB),true)
+      OTHER_LDLIBS += -lz
+  endif
+endif
 ifneq (,$(findstring $(PLATFORM), linux solaris))	# UNIX systems
     LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
     OTHER_LDLIBS += -ljli
@@ -166,6 +182,10 @@
   THREADLIBS = $(LIBTHREAD)
 endif # USE_PTHREADS
 
+ifeq ($(PLATFORM), bsd)
+THREADLIBS = -pthread
+endif
+
 #
 # This rule only applies on unix.  It supports quantify and its ilk.
 #
@@ -221,15 +241,19 @@
 
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRTIME=true
 endif
+endif
 
 ifeq ($(HAVE_GETHRTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRTIME
 endif
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)/bin -I$(LAUNCHER_PLATFORM_SRC)/bin
+ifneq ($(SYSTEM_ZLIB),true)
 OTHER_INCLUDES += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 
 OTHER_CPPFLAGS += -DPROGNAME='"$(PROGRAM)"'
 VERSION_DEFINES += -DFULL_VERSION='"$(FULL_VERSION)"'
--- jdk/make/common/Release.gmk
+++ jdk/make/common/Release.gmk
@@ -145,14 +145,13 @@
 	tnameserv.1     \
 	unpack200.1
 
-ifeq ($(ARCH_DATA_MODEL),32)
+ifeq ($(BUILD_DEPLOY), true)
   JRE_MAN_PAGES += javaws.1
 endif
 
 JDK_MAN_PAGES =            \
 	$(JRE_MAN_PAGES)   \
 	appletviewer.1     \
-        apt.1              \
 	extcheck.1         \
 	idlj.1             \
 	jar.1              \
@@ -191,6 +190,11 @@
   JA_DIRNAME=ja_JP.$(JA_SOURCE_ENCODING)
 endif # linux
 
+ifeq ($(PLATFORM), bsd)
+  MANBASEDIRS=$(JDK_TOPDIR)/src/bsd/doc $(IMPORTDOCDIR)
+  MAN1SUBDIR = man
+endif
+
 define copy-man-pages
 $(MKDIR) -p $1/man/man1
 for manbase in $(MANBASEDIRS:%=%/$(MAN1SUBDIR)) ; do \
@@ -313,6 +317,12 @@
   SOURCE_DIRS += $(CLOSED_SRC)/share/classes
 endif
 
+ifeq ($(OS_VENDOR), OpenBSD)
+  FILES_FROM_ARG=-I
+else
+  FILES_FROM_ARG=-T
+endif
+
 
 #
 # Specific files and directories that will be filtered out from above areas.
@@ -629,6 +639,8 @@
 	$(BOOT_JAVA_CMD) -jar $(JARSPLIT_JARFILE) \
 		$(TOTAL_JAR_FILELIST) \
 		-o  $(RT_JAR_FILELIST) $(RES_JAR_FILELIST)
+	$(EGREP) -v hotspot.log $(RES_JAR_FILELIST) > $(RES_JAR_FILELIST).temp
+	$(MV) $(RES_JAR_FILELIST).temp $(RES_JAR_FILELIST)
 	@$(java-vm-cleanup)
 
 # Create the manifest file.
@@ -974,7 +986,7 @@
 	@# generated by the more efficient solaris/windows method of copying files.
 	@# So for Linux, make use of the -T option (like Solaris' -I option) of
 	@# obtaining the list of files from a file. MKS tar has no such option.
-  ifeq ($(PLATFORM), linux)
+  ifneq (,$(findstring $(PLATFORM), linux bsd))
 	for d in $(SOURCE_DIRS); do \
 	  $(RM) $(ABS_TEMPDIR)/src-files.list; \
 	  ($(CD) $$d &&  \
@@ -987,7 +999,7 @@
 	    done ; \
 	  ) ; \
 	  if [ -f  $(ABS_TEMPDIR)/src-files.list ] ; then \
-	    ($(CD) $$d && $(TAR) cf - -T $(ABS_TEMPDIR)/src-files.list ) \
+	    ($(CD) $$d && $(TAR) cf - $(FILES_FROM_ARG) $(ABS_TEMPDIR)/src-files.list ) \
 	       | ($(CD) $(JDK_IMAGE_DIR)/src && $(TAR) xf -); \
 	  fi; \
 	done
--- jdk/make/common/shared/Compiler-gcc.gmk
+++ jdk/make/common/shared/Compiler-gcc.gmk
@@ -99,6 +99,24 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+
+  # Settings specific to BSD
+  CC             ?= $(COMPILER_PATH)gcc
+  CPP            ?= $(COMPILER_PATH)gcc -E
+  CXX            ?= $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.2
+
+  # Option used to create a shared library
+  # Option used to create a shared library
+  ifeq ($(OS_VENDOR), Apple)
+    SHARED_LIBRARY_FLAG = -dynamiclib 
+  else
+    SHARED_LIBRARY_FLAG = -shared
+  endif
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- jdk/make/common/shared/Compiler.gmk
+++ jdk/make/common/shared/Compiler.gmk
@@ -37,8 +37,8 @@
   override CC_VERSION = sun
 endif
 
-# Linux uses GNU compilers by default
-ifeq ($(PLATFORM), linux)
+# Linux  & BSD uses GNU compilers by default
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   override CC_VERSION = gcc
 endif
 
--- jdk/make/common/shared/Defs-bsd.gmk
+++ jdk/make/common/shared/Defs-bsd.gmk
@@ -70,7 +70,7 @@
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH = $(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -123,7 +123,7 @@
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
@@ -162,16 +162,12 @@
 endif
 MOTIF_INCLUDE = $(MOTIF_DIR)/include
 
-# GCC29_COMPILER_PATH: is the path to where the gcc 2.9 compiler is installed
-#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
-ifneq "$(origin ALT_GCC29_COMPILER_PATH)" "undefined"
-  GCC29_COMPILER_PATH :=$(call PrefixPath,$(ALT_GCC29_COMPILER_PATH))
+ifeq ($(OS_VENDOR), Apple)
+  _CUPS_HEADERS_PATH=/usr/include
 else
-  GCC29_COMPILER_PATH = $(JDK_DEVTOOLS_DIR)/$(PLATFORM)/gcc29/usr/
+  _CUPS_HEADERS_PATH=$(PACKAGE_PATH)/include
 endif
 
-_CUPS_HEADERS_PATH=/usr/include
-
 # Import JDK images allow for partial builds, components not built are
 #    imported (or copied from) these import areas when needed.
 
--- jdk/make/common/shared/Defs-java.gmk
+++ jdk/make/common/shared/Defs-java.gmk
@@ -42,7 +42,7 @@
   #   Suspect this may not be needed anymore.
   JAVA_MEM_FLAGS   += -Xms$(MAX_VM_MEMORY)m -XX:-Inline
 else
-  JAVA_MEM_FLAGS   += -Xms$(MIN_VM_MEMORY)m -XX:PermSize=32m -XX:MaxPermSize=160m
+  JAVA_MEM_FLAGS   += -Xms$(MIN_VM_MEMORY)m
 endif
 
 # 
--- jdk/make/common/shared/Defs-utils.gmk
+++ jdk/make/common/shared/Defs-utils.gmk
@@ -80,6 +80,13 @@
   endif
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 # Utilities
 ADB            = $(UTILS_COMMAND_PATH)adb
 AR             = $(UTILS_CCS_BIN_PATH)ar
@@ -201,3 +208,32 @@
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
--- jdk/make/common/shared/Defs.gmk
+++ jdk/make/common/shared/Defs.gmk
@@ -143,7 +143,7 @@
         echo older; \
       else \
 	if [ $(call MajorVersion,$1) -eq $(call MajorVersion,$2) -a \
-	     $(call MinorVersion,$1) -lt $(call MinorVersion,$2) ]; then \
+	     `echo $(call MinorVersion,$1) | sed -e 's/\([0-9]*\)\(.*\)/\1/'` -lt $(call MinorVersion,$2) ]; then \
           echo older; \
         else \
           echo newer; \
--- jdk/make/common/shared/Platform.gmk
+++ jdk/make/common/shared/Platform.gmk
@@ -264,6 +264,76 @@
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+  REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+  REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586 and sparc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -413,6 +483,13 @@
 #    system swapping during the build.
 #    If we don't know, assume 512. Subtract 128 from MB for VM MAX.
 #    Don't set VM max over 1024-128=896.
+#    736 is the max for OpenBSD.
+ifeq ($(OS_VENDOR), OpenBSD)
+  ABS_MAX_MEMORY := "736"
+else
+  ABS_MAX_MEMORY := "896"
+endif
+
 ifneq ($(MB_OF_MEMORY),)
   LOW_MEMORY_MACHINE := $(shell \
     if [ $(MB_OF_MEMORY) -le 512 ] ; then \
@@ -424,7 +501,7 @@
     if [ $(MB_OF_MEMORY) -le 1024 ] ; then \
       expr $(MB_OF_MEMORY) '-' 128 ; \
     else \
-      echo "896"; \
+      echo $(ABS_MAX_MEMORY); \
     fi)
   MIN_VM_MEMORY := $(shell \
     if [ $(MAX_VM_MEMORY) -le 128 ] ; then \
@@ -476,6 +553,15 @@
   ARCH_VM_SUBDIR=jre/lib/$(LIBARCH)
 endif
 
+# Darwin-specific Overrides
+ifeq ($(SYSTEM_UNAME),Darwin)
+  # The suffix applied to runtime libraries
+  LIBRARY_SUFFIX = dylib
+  # The suffix applied to link libraries
+  LIB_SUFFIX = dylib
+endif
+
+
 # If blanks in the username, use the first 4 words and pack them together
 _USER1:=$(subst ', ,$(_USER))
 _USER2:=$(subst ", ,$(_USER1))
--- jdk/make/common/shared/Sanity-Settings.gmk
+++ jdk/make/common/shared/Sanity-Settings.gmk
@@ -242,6 +242,7 @@
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_HEADERS_PATH)
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_LIB_PATH)
 endif
+ALL_SETTINGS+=$(call addAltSetting,X11_PATH)
 ALL_SETTINGS+=$(call addOptionalSetting,PLUG_LIBRARY_NAMES)
 
 ifdef OPENJDK
--- jdk/make/common/shared/Sanity.gmk
+++ jdk/make/common/shared/Sanity.gmk
@@ -90,6 +90,11 @@
     $(EGREP) "\#define" | $(NAWK) '{print $$3}')
 endif
 
+ifeq ($(PLATFORM), bsd)
+  FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(OUTPUTDIR) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+  TEMP_FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(TEMP_DISK) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+endif
+
 # Get the version numbers of what we are using
 _MAKE_VER  :=$(shell $(MAKE) --version 2>&1 | $(HEAD) -n 1)
 _ZIP_VER   :=$(shell $(ZIPEXE) -help 2>&1 | $(HEAD) -n 4 | $(EGREP) '^Zip')
--- jdk/make/java/Makefile
+++ jdk/make/java/Makefile
@@ -49,7 +49,7 @@
   endif
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   SUBDIRS += jexec
 endif # PLATFORM
 
--- jdk/make/java/hpi/hpi_common.gmk
+++ jdk/make/java/hpi/hpi_common.gmk
@@ -86,5 +86,9 @@
 # Things that must be linked in.
 #
 ifneq ($(PLATFORM), windows)
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(LIBM)
+else
 OTHER_LDLIBS += $(LIBSOCKET) -lnsl $(LIBM) -ldl
 endif
+endif
--- jdk/make/java/hpi/native/Makefile
+++ jdk/make/java/hpi/native/Makefile
@@ -72,11 +72,18 @@
 ifeq ($(MOOT_PRIORITIES),true)
 OTHER_CPPFLAGS += -DMOOT_PRIORITIES
 endif
+ifeq ($(PLATFORM), bsd)
+LIBPOSIX4      =
+OTHER_LDLIBS   += -pthread
+else
 LIBPOSIX4	= -lposix4
 OTHER_LDLIBS   += -lpthread $(LIBPOSIX4)
 endif
+endif
 
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRVTIME=true
+endif
 ifeq ($(HAVE_GETHRVTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRVTIME
 endif
--- jdk/make/java/instrument/Makefile
+++ jdk/make/java/instrument/Makefile
@@ -102,6 +102,21 @@
   # equivalent of strcasecmp is stricmp on Windows
   CPPFLAGS_COMMON += -Dstrcasecmp=stricmp
 else
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+  endif
+
+  ICONV_PATH = $(PACKAGE_PATH)
+# Use CPPFLAGS instead of OTHER_INCLUDES to force this last
+  CPPFLAGS += -I$(ICONV_PATH)/include
+  OTHER_LDLIBS += -L$(ICONV_PATH)/lib -liconv
+else
   LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
   OTHER_LDLIBS += -ljli
   OTHER_LDLIBS += -ldl 
@@ -114,6 +129,7 @@
     LDFLAGS += -Wl,-rpath -Wl,\$$ORIGIN/jli
   endif
 endif
+endif
 
 #
 # Library to compile.
--- jdk/make/java/java/Makefile
+++ jdk/make/java/java/Makefile
@@ -167,8 +167,10 @@
 # Is the altzone extern documented in ctime(3C) available?
 #
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_ALTZONE=true
 endif
+endif
 
 ifeq ($(HAVE_ALTZONE),true)
 OTHER_CPPFLAGS += -DHAVE_ALTZONE
@@ -205,9 +207,14 @@
 OTHER_LDLIBS += $(JVMLIB) -libpath:$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) fdlibm.lib \
 		       -libpath:$(OBJDIR)/../../../verify/$(OBJDIRNAME) verify.lib
 else
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(JVMLIB) -lverify \
+		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
+else
 OTHER_LDLIBS += $(JVMLIB) -lverify $(LIBSOCKET) -lnsl -ldl \
 		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
 endif
+endif
 
 #
 # Rules.
--- jdk/make/java/java/genlocales.gmk
+++ jdk/make/java/java/genlocales.gmk
@@ -76,11 +76,16 @@
 $(LocaleDataMetaInfo_Dest):$(LocaleDataMetaInfo_Src) $(LOCALEGEN_SH)
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 	@$(prep-target) 
-	@$(ECHO) $(subst .properties,'\n',$(Euro_Resources_properties)) > $@.tmp.euro;
-	@$(ECHO) $(subst .java,'\n',$(Euro_Resources_java)) >> $@.tmp.euro;	
-	@$(ECHO) $(subst .properties,'\n',$(NonEuro_Resources_properties)) > $@.tmp.noneuro;
-	@$(ECHO) $(subst .java,'\n',$(NonEuro_Resources_java)) >> $@.tmp.noneuro;
-	NAWK="$(NAWK)" SED="$(SED)" $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
+	@$(ECHO) $(Euro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.euro;
+	@$(ECHO) $(Euro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.euro;
+	@$(ECHO) $(NonEuro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.noneuro;
+	@$(ECHO) $(NonEuro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.noneuro;
+	NAWK="$(NAWK)" SED="$(SED)" SORT="$(SORT)" \
+	     $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
 		$@.tmp.noneuro $< $@
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 	
--- jdk/make/java/java/localegen.sh
+++ jdk/make/java/java/localegen.sh
@@ -29,7 +29,7 @@
 # This script is to generate the supported locale list string and replace the
 # LocaleDataMetaInfo-XLocales.java in <ws>/src/share/classes/sun/util
 # 
-# NAWK & SED is passed in as environment variables.
+# SORT, NAWK & SED is passed in as environment variables.
 #
 
 # A list of resource base name list;
@@ -47,7 +47,7 @@
 localelist=
 getlocalelist() {
     localelist=""
-    localelist=`$NAWK -F$1_ '{print $2}' $2 | sort`
+    localelist=`$NAWK -F$1_ '{print $2}' $2 | $SORT`
 }
 
 sed_script="$SED -e \"s@^#warn .*@// -- This file was mechanically generated: Do not edit! -- //@\" " 
@@ -55,9 +55,9 @@
 for FILE in $RESOURCE_NAMES 
 do
     getlocalelist $FILE $EURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_EuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_EuroLocales#@$localelist@g\" "
     getlocalelist $FILE $NONEURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_NonEuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_NonEuroLocales#@$localelist@g\" "
 done
 
 sed_script=$sed_script"$INPUT_FILE > $OUTPUT_FILE"
--- jdk/make/java/java_hprof_demo/Makefile
+++ jdk/make/java/java_hprof_demo/Makefile
@@ -83,8 +83,10 @@
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS += wsock32.lib winmm.lib
 else
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += $(LIBSOCKET) -lnsl -ldl
 endif
+endif
 
 #
 # Tell library.gmk to copy the txt file first
--- jdk/make/java/jli/Makefile
+++ jdk/make/java/jli/Makefile
@@ -44,8 +44,10 @@
 
 include $(BUILDDIR)/common/Defs.gmk
 
+ifneq ($(SYSTEM_ZLIB),true)
 ZLIB_VERSION = 1.1.3
 ZIP_SRC = $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+endif
 LAUNCHER_SHARE_SRC = $(SHARE_SRC)/bin
 LAUNCHER_PLATFORM_SRC = $(PLATFORM_SRC)/bin
 
@@ -56,7 +58,10 @@
 	parse_manifest.c \
 	version_comp.c \
 	wildcard.c \
-	jli_util.c \
+	jli_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	inflate.c \
 	infblock.c \
 	inftrees.c \
@@ -65,6 +70,7 @@
 	infutil.c \
 	zadler32.c \
 	zutil.c
+endif
 
 OTHER_CPPFLAGS += -DEXPAND_CLASSPATH_WILDCARDS
 
@@ -98,7 +104,11 @@
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)
 OTHER_INCLUDES += -I$(LAUNCHER_PLATFORM_SRC)
-OTHER_INCLUDES += -I$(ZIP_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  OTHER_INCLUDES += -I$(ZIP_SRC)
+else
+  LDLIBS += -lz
+endif
 
 #
 # Library to compile.
@@ -136,8 +146,29 @@
 
 endif	# PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+
+STATIC_LIBRARY_DIR = $(OBJDIR)/static
+STATIC_LIBRARY_NAME = lib$(LIBRARY).a
+STATIC_LIBRARY = $(STATIC_LIBRARY_DIR)/$(STATIC_LIBRARY_NAME)
+
+$(STATIC_LIBRARY_DIR): $(OBJDIR)
+	@$(MKDIR) $(STATIC_LIBRARY_DIR)
+
+$(STATIC_LIBRARY): $(STATIC_LIBRARY_DIR)
+	@$(prep-target)
+	$(AR) -r $@ $(FILES_o)
+
+library:: $(STATIC_LIBRARY)
+
+endif  # PLATFORM
+
 #
 # Add to ambient vpath so we pick up the library files
 #
-vpath %.c $(LAUNCHER_SHARE_SRC) $(ZIP_SRC)
+vpath %.c $(LAUNCHER_SHARE_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c $(ZIP_SRC)
+endif
+
 
--- jdk/make/java/management/Makefile
+++ jdk/make/java/management/Makefile
@@ -85,6 +85,11 @@
 OTHER_INCLUDES += \
   -I$(SHARE_SRC)/native/sun/management 
 
+ifeq ($(PLATFORM),bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB)
 endif
--- jdk/make/java/net/FILES_c.gmk
+++ jdk/make/java/net/FILES_c.gmk
@@ -43,6 +43,10 @@
     FILES_c += linux_close.c
 endif
 
+ifeq ($(OS_VENDOR), FreeBSD)
+    FILES_c += bsd_close.c
+endif
+
 ifeq ($(PLATFORM), windows)
     FILES_c += TwoStacksPlainSocketImpl.c
     FILES_c += DualStackPlainSocketImpl.c
--- jdk/make/java/net/Makefile
+++ jdk/make/java/net/Makefile
@@ -92,6 +92,12 @@
 
 include $(BUILDDIR)/common/Library.gmk
 
+ifeq ($(PLATFORM), bsd)
+  ifdef DONT_ENABLE_IPV6
+    OTHER_CFLAGS += -DDONT_ENABLE_IPV6
+  endif
+  OTHER_LDLIBS = $(JVMLIB) -pthread
+else
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = ws2_32.lib $(JVMLIB)
   # Will not compile at warning level 3 if warnings are fatal
@@ -102,6 +108,7 @@
 ifeq ($(PLATFORM), linux)
   OTHER_LDLIBS += -lpthread
 endif
+endif # PLATFORM == bsd
 
 CLASSES.export += java.lang.Integer java.io.FileDescriptor java.net.InetAddressImplFactory java.net.Inet4AddressImpl java.net.Inet6AddressImpl
 
--- jdk/make/java/nio/Makefile
+++ jdk/make/java/nio/Makefile
@@ -104,6 +104,28 @@
 	sun/nio/ch/NativeThread.java
 endif # PLATFORM = linux
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+	sun/nio/ch/AbstractPollSelectorImpl.java \
+	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/KqueueArrayWrapper.java \
+	sun/nio/ch/KqueueSelectorProvider.java \
+	sun/nio/ch/KqueueSelectorImpl.java \
+	sun/nio/ch/PollSelectorProvider.java \
+	sun/nio/ch/PollSelectorImpl.java
+
+FILES_c += \
+	KqueueArrayWrapper.c \
+	PollArrayWrapper.c \
+	InheritedChannel.c \
+	NativeThread.c
+
+FILES_export += \
+	sun/nio/ch/KqueueArrayWrapper.java \
+	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/NativeThread.java
+endif # PLATFORM = bsd
+
 # Find platform-specific C source files
 #
 vpath %.c $(PLATFORM_SRC)/native/sun/nio/ch
@@ -126,6 +148,11 @@
   -I$(PLATFORM_SRC)/native/java/net \
   -I$(CLASSHDRDIR)/../../../java.lang/java/CClassHeaders
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB) ws2_32.lib \
      -libpath:$(LIBDIR) java.lib \
@@ -137,6 +164,9 @@
 COMPILER_WARNINGS_FATAL=true
 OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -lpthread -ldl
 endif
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -pthread
+endif
 ifeq ($(PLATFORM), solaris)
 OTHER_LDLIBS += $(JVMLIB) $(LIBSOCKET) -lposix4 -ldl \
 		-L$(LIBDIR)/$(LIBARCH) -ljava -lnet
@@ -159,6 +189,9 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 include $(BUILDDIR)/common/Library.gmk
 
--- jdk/make/java/npt/Makefile
+++ jdk/make/java/npt/Makefile
@@ -70,6 +70,18 @@
   OTHER_LCF += -export:nptInitialize -export:nptTerminate
 endif
 
+# Add location of iconv headers & libs
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    OTHER_LDLIBS += -liconv
+  else
+    ifneq ($(OS_NAME), netbsd)
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
+  endif
+endif
+
 #
 # Add to ambient vpath so we pick up the library files
 #
--- jdk/make/java/redist/FILES.gmk
+++ jdk/make/java/redist/FILES.gmk
@@ -38,6 +38,14 @@
 	$(LIBDIR)/fonts/LucidaSansDemiBold.ttf       	\
 
 ifeq ($(PLATFORM), linux)
+NEED_OBLIQUE_FONTS = true
+endif
+
+ifeq ($(PLATFORM), bsd)
+NEED_OBLIQUE_FONTS = true
+endif
+
+ifeq ($(NEED_OBLIQUE_FONTS), true)
 
 # The oblique versions of the font are derived from the base versions
 # and since 2D can do this derivation on the fly at run time there is no
--- jdk/make/java/redist/Makefile
+++ jdk/make/java/redist/Makefile
@@ -311,7 +311,7 @@
 $(FONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.fonts.dir
 	$(install-file)
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique fonts are only needed/wanted on Linux.
 
@@ -325,7 +325,7 @@
 $(OBLFONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.oblique-fonts.dir
 	$(install-file)
 
-endif # linux
+endif # linux || bsd
 endif # !OPENJDK
 
 # Import internal files (ones that are stashed in this source tree)
--- jdk/make/java/security/Makefile
+++ jdk/make/java/security/Makefile
@@ -51,7 +51,15 @@
   ifneq ($(ARCH_DATA_MODEL), 64)
     PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-windows
   endif
+
+else # windows
+
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), OpenBSD)
+    PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-openbsd
+  endif
 endif
+endif # windows
 endif # PLATFORM
 
 
--- jdk/make/java/zip/FILES_c.gmk
+++ jdk/make/java/zip/FILES_c.gmk
@@ -30,6 +30,10 @@
 	Inflater.c \
 	ZipFile.c \
 	ZipEntry.c \
+	zip_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	zadler32.c \
 	zcrc32.c \
 	deflate.c \
@@ -40,5 +44,5 @@
 	inftrees.c \
 	infcodes.c \
 	infutil.c \
-	inffast.c \
-	zip_util.c
+	inffast.c
+endif
--- jdk/make/java/zip/Makefile
+++ jdk/make/java/zip/Makefile
@@ -72,16 +72,24 @@
 CPPFLAGS += -UDEBUG 
 endif
 
-CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 CPPFLAGS += -I$(SHARE_SRC)/native/java/io
 CPPFLAGS += -I$(PLATFORM_SRC)/native/java/io
 
+ifneq ($(SYSTEM_ZLIB),true)
+CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+
 #
 # Add to ambient vpath so we pick up the library files
 #
 vpath %.c $(SHARE_SRC)/native/$(PKGDIR)/zlib-$(ZLIB_VERSION)
+endif
 
 #
 # Link to JVM library for JVM_Zip* functions
 #
+ifeq ($(SYSTEM_ZLIB),true)
+OTHER_LDLIBS = -lz
+else
 OTHER_LDLIBS = $(JVMLIB)
+endif
+
--- jdk/make/javax/sound/FILES_c.gmk
+++ jdk/make/javax/sound/FILES_c.gmk
@@ -34,6 +34,8 @@
 
 FILES_linux = 
 
+FILES_bsd =
+
 FILES_windows = \
 	PLATFORM_API_WinOS_MidiIn.c \
 	PLATFORM_API_WinOS_MidiOut.c \
--- jdk/make/javax/sound/SoundDefs.gmk
+++ jdk/make/javax/sound/SoundDefs.gmk
@@ -40,6 +40,10 @@
   CPPFLAGS += -DX_PLATFORM=X_LINUX
 endif # PLATFORM linux
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -DX_PLATFORM=X_BSD
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -DX_PLATFORM=X_SOLARIS
 
--- jdk/make/javax/sound/jsoundalsa/Makefile
+++ jdk/make/javax/sound/jsoundalsa/Makefile
@@ -65,6 +65,15 @@
 	$(MIDIFILES_export) \
 	$(PORTFILES_export)
 
+ifeq ($(PLATFORM), bsd)
+LDFLAGS  += -L$(PACKAGE_PATH)/lib -lasound
+
+CPPFLAGS += \
+	-DUSE_DAUDIO=TRUE \
+	-DUSE_PORTS=TRUE  \
+	-I$(PACKAGE_PATH)/include \
+	-I$(SHARE_SRC)/native/com/sun/media/sound
+else
 LDFLAGS += -lasound
 
 CPPFLAGS += \
@@ -73,6 +82,7 @@
 	-DUSE_PLATFORM_MIDI_OUT=TRUE \
 	-DUSE_PLATFORM_MIDI_IN=TRUE \
 	-I$(SHARE_SRC)/native/com/sun/media/sound
+endif
 
 #
 # Add to the ambient VPATH.
--- jdk/make/jpda/back/Makefile
+++ jdk/make/jpda/back/Makefile
@@ -49,8 +49,10 @@
                  -I$(GENNATIVESRCDIR)/jdwp
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += -ldl
 endif # PLATFORM
+endif # PLATFORM
 
 #
 # This turns off all assert() checking in the optimized library
--- jdk/make/sun/awt/Makefile
+++ jdk/make/sun/awt/Makefile
@@ -129,6 +129,14 @@
 OTHER_LDLIBS = $(JVMLIB) $(LIBM) -ldl
 endif
 
+ifeq  ($(PLATFORM), bsd)
+FILES_c = $(FILES_2D_c)
+FILES_c += awt_LoadLibrary.c
+OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
+OTHER_CFLAGS += -DMOTIF_VERSION=2
+OTHER_LDLIBS = $(JVMLIB) $(LIBM)
+endif
+
 FILES_c += initIDs.c
 
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS/LINUX
@@ -241,7 +249,7 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ WINDOWS
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv LINUX
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/../java2d/opengl
@@ -421,6 +429,19 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS
 endif # PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BSD
+
+FONTCONFIGS_SRC = $(PLATFORM_SRC)/classes/sun/awt/fontconfigs
+_FONTCONFIGS   = \
+       fontconfig.properties
+
+FONTCONFIGS_SRC_PREFIX = $(PLATFORM).
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ BSD
+endif # PLATFORM
+
+
 FONTCONFIGS     = $(_FONTCONFIGS:%=$(LIBDIR)/%.src)
 BINARYFONTCONFIGS = $(_FONTCONFIGS:%.properties=$(LIBDIR)/%.bfc)
 
@@ -514,6 +535,9 @@
             -I$(OPENWIN_HOME)/include/X11/extensions \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
 endif
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
+endif
 CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/../font \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../font \
@@ -535,7 +559,13 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR) \
 	    $(EVENT_MODEL)
 
-ifeq ($(PLATFORM), linux)
+# include these last so we don't pick up unintentional includes
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(OPENWIN_HOME)/include \
+            -I$(OPENWIN_HOME)/include/X11/extensions
+endif
+
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 LDFLAGS += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
 endif
 
--- jdk/make/sun/awt/mawt.gmk
+++ jdk/make/sun/awt/mawt.gmk
@@ -174,7 +174,7 @@
 OTHER_LDLIBS = $(LIBXM) -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
 endif
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
 OTHER_CFLAGS += -DMOTIF_VERSION=2
 OTHER_CFLAGS += -DXMSTRINGDEFINES=1
@@ -185,7 +185,11 @@
 # !HEADLESS
 
 OTHER_LDLIBS += $(JVMLIB) $(LIBCXX) \
-                -lawt $(LIBM) -ldl
+                -lawt $(LIBM)
+
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
 
 #
 # Sun CC with -Xa misdefines __STDC__ to 0 (zero).
@@ -229,16 +233,33 @@
         -I$(PLATFORM_SRC)/native/$(PKGDIR) \
         $(EVENT_MODEL)
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
+ifndef HEADLESS
+CPPFLAGS += -I$(MOTIF_DIR)/include \
+            -I$(OPENWIN_HOME)/include 
+LDFLAGS  += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
+
+endif # !HEADLESS
+
 ifeq ($(PLATFORM), linux)
 # Checking for the X11/extensions headers at the additional location
   CPPFLAGS += -I/X11R6/include/X11/extensions \
               -I/usr/include/X11/extensions
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
+              -I$(OPENWIN_HOME)/include 
+endif
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions
 endif
 
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
 
 LDFLAGS += -L$(LIBDIR)/$(LIBARCH)/$(TSOBJDIR) \
 	   $(AWT_RUNPATH)
--- jdk/make/sun/font/Makefile
+++ jdk/make/sun/font/Makefile
@@ -177,6 +177,15 @@
 # Libraries to link, and other C flags.
 #
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += -I$(X11_PATH)/include
+OTHER_LDLIBS  += -lawt $(LIBM) $(LIBCXX)
+ ifeq ($(OS_VENDOR),Apple)
+   # XXXDARWIN Match BSD/Linux behavior -- the mawt.dylib symbols will
+   # be available at runtime.
+   OTHER_LDLIBS += -flat_namespace -undefined suppress
+ endif
+else
 ifeq ($(PLATFORM), solaris)
   # Note that on Solaris, fontmanager is built against the headless library.
   LDFLAGS      += -L$(LIBDIR)/$(LIBARCH)/headless
@@ -187,6 +196,7 @@
     OTHER_LDLIBS  += -Wl,-Bstatic -lgcc_eh -Wl,-Bdynamic
   endif                           
 endif
+endif
 
 endif # PLATFORM
 
--- jdk/make/sun/image/generic/Makefile
+++ jdk/make/sun/image/generic/Makefile
@@ -69,5 +69,9 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/medialib 
 
 OTHER_CFLAGS += -D__USE_J2D_NAMES -D__MEDIALIB_OLD_NAMES
-OTHER_LDLIBS = $(LIBM) -ldl
+OTHER_LDLIBS = $(LIBM)
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
+
 
--- jdk/make/sun/jawt/Makefile
+++ jdk/make/sun/jawt/Makefile
@@ -98,9 +98,7 @@
 #
 # Other extra flags needed for compiling.
 #
-CPPFLAGS += -I$(OPENWIN_HOME)/include \
-	    -I$(MOTIF_DIR)/include \
-	    -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/image \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/image/cvutils \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/alphacomposite \
@@ -114,6 +112,8 @@
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/doe \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/path \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../jdga \
+	    -I$(OPENWIN_HOME)/include \
+	    -I$(MOTIF_DIR)/include \
 	    $(EVENT_MODEL)
 #
 # Libraries to link in.
@@ -122,7 +122,7 @@
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -L$(OPENWIN_LIB) -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -lawt -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
--- jdk/make/sun/security/jgss/wrapper/Makefile
+++ jdk/make/sun/security/jgss/wrapper/Makefile
@@ -71,6 +71,10 @@
 #
 # Libraries to link
 #
-ifneq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), linux solaris))
   OTHER_LDLIBS = -ldl $(JVMLIB)
 endif
+
+ifeq ($(PLATFORM), bsd)
+  OTHER_LDLIBS = $(JVMLIB)
+endif
--- jdk/make/sun/security/pkcs11/Makefile
+++ jdk/make/sun/security/pkcs11/Makefile
@@ -156,7 +156,7 @@
 #
 # Libraries to link
 #
-ifeq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), windows bsd))
   OTHER_LDLIBS = $(JVMLIB)
 else
   OTHER_LDLIBS = -ldl $(JVMLIB)
--- jdk/make/sun/security/smartcardio/Makefile
+++ jdk/make/sun/security/smartcardio/Makefile
@@ -75,6 +75,10 @@
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = $(JVMLIB) winscard.lib
 else
-  OTHER_LDLIBS = -ldl $(JVMLIB)
+  ifeq ($(PLATFORM), bsd)
+    OTHER_LDLIBS = $(JVMLIB)
+  else
+    OTHER_LDLIBS = -ldl $(JVMLIB)
+  endif
   OTHER_CFLAGS = -D__sun_jdk
 endif
--- jdk/make/sun/splashscreen/FILES_c.gmk
+++ jdk/make/sun/splashscreen/FILES_c.gmk
@@ -49,20 +49,6 @@
 	dgif_lib.c \
 	gif_err.c \
 	gifalloc.c \
-	compress.c \
-	deflate.c \
-	gzio.c \
-	infblock.c \
-	infcodes.c \
-	inffast.c \
-	inflate.c \
-	inftrees.c \
-	infutil.c \
-	trees.c \
-	uncompr.c \
-	zadler32.c \
-	zcrc32.c \
-	zutil.c \
 	jcomapi.c \
 	jdapimin.c \
 	jdapistd.c \
@@ -108,3 +94,20 @@
 	jfdctfst.c \
 	jfdctint.c
 
+ifneq ($(SYSTEM_ZLIB),true)
+  FILES_c += \
+	compress.c \
+	deflate.c \
+	gzio.c \
+	infblock.c \
+	infcodes.c \
+	inffast.c \
+	inflate.c \
+	inftrees.c \
+	infutil.c \
+	trees.c \
+	uncompr.c \
+	zadler32.c \
+	zcrc32.c \
+	zutil.c
+endif
--- jdk/make/sun/splashscreen/Makefile
+++ jdk/make/sun/splashscreen/Makefile
@@ -61,10 +61,26 @@
 
 CFLAGS += -DSPLASHSCREEN
 
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
+ifneq ($(SYSTEM_ZLIB),true)
+  CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
+
+
 ifneq ($(PLATFORM), windows)
   CFLAGS += -DWITH_X11
-  CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
-  OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  ifeq ($(PLATFORM), bsd)
+    CFLAGS += -DPNG_NO_MMX_CODE
+    ICONV_PATH = $(PACKAGE_PATH)
+    CPPFLAGS += -I$(OPENWIN_HOME)/include \
+                -I$(OPENWIN_HOME)/include/X11/extensions \
+                -I$(ICONV_PATH)/include
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext -L$(ICONV_PATH)/lib -liconv $(LIBM) -pthread
+  else
+    CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  endif
 else # PLATFORM
   CFLAGS += -DWITH_WIN32
   OTHER_LDLIBS += kernel32.lib user32.lib gdi32.lib 
@@ -77,14 +93,13 @@
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/splashscreen
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/giflib
-vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/libpng
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen
 
-CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
-CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
-
 ifeq ($(PLATFORM), linux)
   ifeq ($(ARCH_DATA_MODEL), 64)
     # 64-bit gcc has problems compiling MMX instructions.
--- jdk/make/sun/xawt/Makefile
+++ jdk/make/sun/xawt/Makefile
@@ -53,6 +53,11 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
+ifeq ($(PLATFORM), bsd)
+LDFLAGS += -pthread
+dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
+endif
+
 # Since this library will be living in a subdirectory below the other libraries
 #   we need to add an extra runpath so that libraries in the upper directory
 #   are found at runtime.
@@ -86,7 +91,12 @@
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/x11
 
-OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 -ldl \
+ifeq ($(PLATFORM), bsd)
+LIBDL=
+else
+LIBDL=-ldl
+endif
+OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 $(LIBDL) \
                    $(LDFLAGS_COMMON) $(AWT_RUNPATH) $(OTHER_LDFLAGS) -lXtst -lXi
 
 ifeq  ($(PLATFORM), solaris)
@@ -94,8 +104,6 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
-CPPFLAGS += -I$(CUPS_HEADERS_PATH)
-
 CPPFLAGS += -DXAWT -DXAWT_HACK \
         -I$(TEMPDIR)/../../sun.awt/awt/CClassHeaders \
         -I$(PLATFORM_SRC)/native/sun/awt \
@@ -122,9 +130,11 @@
         -I$(SHARE_SRC)/native/sun/awt \
         -I$(PLATFORM_SRC)/native/sun/awt 
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
 ifeq ($(PLATFORM), linux)
 # Allows for builds on Debian GNU Linux, X11 is in a different place 
-  CPPFLAGS += -I/usr/X11R6/include/X11/extensions \
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
               -I/usr/include/X11/extensions \
               -I$(MOTIF_DIR)/include \
               -I$(OPENWIN_HOME)/include 
@@ -134,6 +144,14 @@
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(MOTIF_DIR)/include 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(OPENWIN_HOME)/include
+endif
+
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
+
 ifeq ($(MILESTONE), internal)
   CPPFLAGS += -DINTERNAL_BUILD
 endif
--- jdk/make/tools/freetypecheck/Makefile
+++ jdk/make/tools/freetypecheck/Makefile
@@ -60,8 +60,12 @@
   #add runtime lib search path to ensure test will be runnable
   ifeq ($(PLATFORM), solaris)
     FT_OPTIONS += -R $(FT_LIB) -lfreetype
-  else #linux
-      FT_OPTIONS += -Wl,-rpath -Wl,$(FT_LIB) -lfreetype
+  else 
+    ifeq ($(PLATFORM), bsd)
+      FT_OPTIONS += -lfreetype -lz
+    else # linux
+        FT_OPTIONS += -Wl,-rpath -Wl,$(FREETYPE_LIB_PATH) -lfreetype
+    endif
   endif
 endif
 
--- jdk/src/share/back/commonRef.c
+++ jdk/src/share/back/commonRef.c
@@ -23,6 +23,10 @@
  * questions.
  */
 
+#if defined(_ALLBSD_SOURCE)
+#include <stdint.h>			/* for uintptr_t */
+#endif
+
 #include "util.h"
 #include "commonRef.h"
 
--- jdk/src/share/bin/java.c
+++ jdk/src/share/bin/java.c
@@ -104,6 +104,11 @@
 static char *launchername;
 jboolean _launcher_debug = JNI_FALSE;
 
+#ifdef __APPLE__
+static jboolean continueInSameThread = JNI_FALSE; /* start VM in current thread */
+#endif
+
+
 /*
  * Entries for splash screen environment variables.
  * putenv is performed in SelectVersion. We need
@@ -146,6 +151,10 @@
 static void SetPaths(int argc, char **argv);
 
 
+#ifdef __APPLE__
+static int ContinueInSameThread(InvocationFunctions* ifn, int argc, char **argv, char *jarfile, char *classname, int ret);
+#endif
+
 /* Maximum supported entries from jvm.cfg. */
 #define INIT_MAX_KNOWN_VMS      10
 /* Values for vmdesc.flag */
@@ -184,13 +193,13 @@
 
 int JNICALL JavaMain(void * args); /* entry point                  */
 
-struct JavaMainArgs {
+typedef struct {
   int     argc;
   char ** argv;
   char *  jarfile;
   char *  classname;
   InvocationFunctions ifn;
-};
+} JavaMainArgs;
 
 /*
  * Entry point.
@@ -332,49 +341,24 @@
     /* Show the splash screen if needed */
     ShowSplashScreen();
 
-    /*
-     * Done with all command line processing and potential re-execs so
-     * clean up the environment.
-     */
-    (void)UnsetEnv(ENV_ENTRY);
-    (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
-    (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
-
-    JLI_MemFree(splash_jar_entry);
-    JLI_MemFree(splash_file_entry);
 
-    /*
-     * If user doesn't specify stack size, check if VM has a preference.
-     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
-     * return its default stack size through the init args structure.
-     */
-    if (threadStackSize == 0) {
-      struct JDK1_1InitArgs args1_1;
-      memset((void*)&args1_1, 0, sizeof(args1_1));
-      args1_1.version = JNI_VERSION_1_1;
-      ifn.GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
-      if (args1_1.javaStackSize > 0) {
-         threadStackSize = args1_1.javaStackSize;
+#ifdef __APPLE__
+      if (continueInSameThread == JNI_TRUE) {
+        return ContinueInSameThread(&ifn, argc, argv, jarfile, classname, ret);
+      } else {
+        return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
       }
-    }
-
-    { /* Create a new thread to create JVM and invoke main method */
-      struct JavaMainArgs args;
+#else
 
-      args.argc = argc;
-      args.argv = argv;
-      args.jarfile = jarfile;
-      args.classname = classname;
-      args.ifn = ifn;
+      return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
+#endif
 
-      return ContinueInNewThread(JavaMain, threadStackSize, (void*)&args, ret);
-    }
 }
 
 int JNICALL
 JavaMain(void * _args)
 {
-    struct JavaMainArgs *args = (struct JavaMainArgs *)_args;
+    JavaMainArgs *args = (JavaMainArgs *)_args;
     int argc = args->argc;
     char **argv = args->argv;
     char *jarfile = args->jarfile;
@@ -1159,6 +1143,10 @@
         } else if (strcmp(arg, "-X") == 0) {
             printXUsage = JNI_TRUE;
             return JNI_TRUE;
+#ifdef __APPLE__
+        } else if (JLI_StrCmp(arg, "-XstartOnFirstThread") == 0) {
+            continueInSameThread = JNI_TRUE;
+#endif            
 /*
  * The following case provide backward compatibility with old-style
  * command line options.
@@ -1979,6 +1967,84 @@
     return -1;
 }
 
+static int
+ContinueInNewThread(InvocationFunctions* ifn, int argc,
+                     char **argv, char *jarfile, char *classname, int ret)
+{
+
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+      struct JDK1_1InitArgs args1_1;
+      memset((void*)&args1_1, 0, sizeof(args1_1));
+      args1_1.version = JNI_VERSION_1_1;
+      ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+      if (args1_1.javaStackSize > 0) {
+         threadStackSize = args1_1.javaStackSize;
+      }
+    }
+
+    { /* Create a new thread to create JVM and invoke main method */
+      JavaMainArgs args;
+      int rslt;
+
+      args.argc = argc;
+      args.argv = argv;
+      args.jarfile = jarfile;
+      args.classname = classname;
+      args.ifn = *ifn;
+
+      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&args);
+      /* If the caller has deemed there is an error we
+       * simply return that, otherwise we return the value of
+       * the callee
+       */
+      return (ret != 0) ? ret : rslt;
+    }
+}
+
+
+#ifdef __APPLE__
+static int
+ContinueInSameThread(InvocationFunctions* ifn, int argc,
+                    char **argv, char *jarfile, char *classname, int ret)
+{
+        
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+        struct JDK1_1InitArgs args1_1;
+        memset((void*)&args1_1, 0, sizeof(args1_1));
+        args1_1.version = JNI_VERSION_1_1;
+        ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+        if (args1_1.javaStackSize > 0) {
+            threadStackSize = args1_1.javaStackSize;
+        }
+    }
+    
+    { /* Create create JVM and invoke main method */
+        JavaMainArgs args;
+        int rslt;
+        
+        args.argc = argc;
+        args.argv = argv;
+        args.jarfile = jarfile;
+        args.classname = classname;
+        args.ifn = *ifn;
+        
+        rslt = JavaMain((void*)&args);
+        
+        return (ret != 0) ? ret : rslt;
+    }
+}
+#endif
+
 static void
 FreeKnownVMs()
 {
--- jdk/src/share/bin/java.h
+++ jdk/src/share/bin/java.h
@@ -91,11 +91,17 @@
 void PrintMachineDependentOptions();
 
 const char *jlong_format_specifier();
+
 /*
  * Block current thread and continue execution in new thread
  */
-int ContinueInNewThread(int (JNICALL *continuation)(void *),
-                        jlong stack_size, void * args, int ret);
+int ContinueInNewThread0(int (JNICALL *continuation)(void *),
+                        jlong stack_size, void * args);
+
+
+ static int ContinueInNewThread(InvocationFunctions* ifn, int argc, char** argv,
+                         char* jarfile, char* classname, int ret);
+
 
 /* sun.java.launcher.* platform properties. */
 void SetJavaLauncherPlatformProps(void);
--- jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java
+++ jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java
@@ -477,6 +477,10 @@
                 String[] dirs = new String[] {
                     userHome + sep + ".themes",
                     System.getProperty("swing.metacitythemedir"),
+		    "/usr/X11R6/share/themes",
+		    "/usr/X11R6/share/gnome/themes",
+		    "/usr/local/share/themes",
+		    "/usr/local/share/gnome/themes",
                     "/usr/share/themes",
                     "/usr/gnome/share/themes",  // Debian/Redhat/Solaris
                     "/opt/gnome2/share/themes"  // SuSE
--- jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java
+++ jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java
@@ -78,6 +78,9 @@
      */
     public long            timeStamp ;
 
+    // TODO: IcedTea: I am a stub.
+    static public int trapAuthenticationFailure = 0;
+
 
 
     /**
--- jdk/src/share/classes/java/awt/Font.java
+++ jdk/src/share/classes/java/awt/Font.java
@@ -449,18 +449,19 @@
      */
     private AttributeValues getAttributeValues() {
         if (values == null) {
-            values = new AttributeValues();
-            values.setFamily(name);
-            values.setSize(pointSize); // expects the float value.
+            AttributeValues valuesTmp = new AttributeValues();
+            valuesTmp.setFamily(name);
+            valuesTmp.setSize(pointSize); // expects the float value.
 
             if ((style & BOLD) != 0) {
-                values.setWeight(2); // WEIGHT_BOLD
+                valuesTmp.setWeight(2); // WEIGHT_BOLD
             }
 
             if ((style & ITALIC) != 0) {
-                values.setPosture(.2f); // POSTURE_OBLIQUE
+                valuesTmp.setPosture(.2f); // POSTURE_OBLIQUE
             }
-            values.defineAll(PRIMARY_MASK); // for streaming compatibility
+            valuesTmp.defineAll(PRIMARY_MASK); // for streaming compatibility
+            values = valuesTmp;
         }
 
         return values;
--- jdk/src/share/classes/java/awt/GraphicsEnvironment.java
+++ jdk/src/share/classes/java/awt/GraphicsEnvironment.java
@@ -148,7 +148,12 @@
                         } else {
                             String osName = System.getProperty("os.name");
                             headless = defaultHeadless =
-                                Boolean.valueOf(("Linux".equals(osName) || "SunOS".equals(osName)) &&
+                                Boolean.valueOf(("Linux".equals(osName) ||
+                                                "SunOS".equals(osName) ||
+                                                "FreeBSD".equals(osName) ||
+                                                "NetBSD".equals(osName) ||
+                                                "OpenBSD".equals(osName) ||
+                                                "Darwin".equals(osName)) &&
                                                 (System.getenv("DISPLAY") == null));
                         }
                     } else if (nm.equals("true")) {
--- jdk/src/share/classes/java/util/TimeZone.java
+++ jdk/src/share/classes/java/util/TimeZone.java
@@ -833,15 +833,13 @@
         }
         int gmtOffset =  (hours * 60 + num) * 60 * 1000;
 
+        zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         if (gmtOffset == 0) {
-            zi = ZoneInfoFile.getZoneInfo(GMT_ID);
             if (negative) {
                 zi.setID("GMT-00:00");
             } else {
                 zi.setID("GMT+00:00");
             }
-        } else {
-            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         }
         return zi;
     }
--- jdk/src/share/classes/sun/awt/FontConfiguration.java
+++ jdk/src/share/classes/sun/awt/FontConfiguration.java
@@ -1073,7 +1073,7 @@
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!environment.isLinux) {
+        if (!environment.isLinuxOrBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
@@ -1309,7 +1309,7 @@
                                    + "<filename."
                                    + getString(table_componentFontNameIDs[ii])
                                    + "> entry is missing!!!");
-                if (!osName.contains("Linux")) {
+                if (!osName.contains("Linux") && !osName.contains("BSD") && !osName.contains("Darwin")) {
                     errors++;
                 }
             }
--- jdk/src/share/classes/sun/font/TrueTypeFont.java
+++ jdk/src/share/classes/sun/font/TrueTypeFont.java
@@ -160,6 +160,13 @@
     private boolean supportsJA;
     private boolean supportsCJK;
 
+    /* These are for faster access to the name of the font as
+     * typically exposed via API to applications.
+     */
+    private Locale nameLocale;
+    private String localeFamilyName;
+    private String localeFullName;
+
     /**
      * - does basic verification of the file
      * - reads the header table for this font (within a collection)
@@ -1061,6 +1068,10 @@
              * greater than 32767, so read and store those as ints
              */
             int stringPtr = sbuffer.get() & 0xffff;
+
+            nameLocale = sun.awt.SunToolkit.getStartupLocale();
+            short nameLocaleID = FontManager.getLCIDFromLocale(nameLocale);
+
             for (int i=0; i<numRecords; i++) {
                 short platformID = sbuffer.get();
                 if (platformID != MS_PLATFORM_ID) {
@@ -1072,15 +1083,24 @@
                 short nameID     = sbuffer.get();
                 int nameLen    = ((int) sbuffer.get()) & 0xffff;
                 int namePtr    = (((int) sbuffer.get()) & 0xffff) + stringPtr;
-
+                String tmpName = null;
                 switch (nameID) {
 
                 case FAMILY_NAME_ID:
 
-                    if (familyName == null || langID == ENGLISH_LOCALE_ID) {
+                    if (familyName == null || langID == ENGLISH_LOCALE_ID ||
+                        langID == nameLocaleID)
+                    {
                         buffer.position(namePtr);
                         buffer.get(name, 0, nameLen);
-                        familyName = makeString(name, nameLen, encodingID);
+                        tmpName = makeString(name, nameLen, encodingID);
+
+                        if (familyName == null || langID == ENGLISH_LOCALE_ID){
+                            familyName = tmpName;
+                        }
+                        if (langID == nameLocaleID) {
+                            localeFamilyName = tmpName;
+                        }
                     }
 /*
                     for (int ii=0;ii<nameLen;ii++) {
@@ -1098,15 +1118,29 @@
 
                 case FULL_NAME_ID:
 
-                    if (fullName == null || langID == ENGLISH_LOCALE_ID) {
+                    if (fullName == null || langID == ENGLISH_LOCALE_ID ||
+                        langID == nameLocaleID)
+                    {
                         buffer.position(namePtr);
                         buffer.get(name, 0, nameLen);
-                        fullName = makeString(name, nameLen, encodingID);
+                        tmpName = makeString(name, nameLen, encodingID);
+
+                        if (fullName == null || langID == ENGLISH_LOCALE_ID) {
+                            fullName = tmpName;
+                        }
+                        if (langID == nameLocaleID) {
+                            localeFullName = tmpName;
+                        }
                     }
                     break;
-
                 }
             }
+            if (localeFamilyName == null) {
+                localeFamilyName = familyName;
+            }
+            if (localeFullName == null) {
+                localeFullName = fullName;
+            }
         }
     }
 
@@ -1189,6 +1223,8 @@
     public String getFontName(Locale locale) {
         if (locale == null) {
             return fullName;
+        } else if (locale.equals(nameLocale) && localeFullName != null) {
+            return localeFullName;
         } else {
             short localeID = FontManager.getLCIDFromLocale(locale);
             String name = lookupName(localeID, FULL_NAME_ID);
@@ -1203,11 +1239,13 @@
     public String getFamilyName(Locale locale) {
         if (locale == null) {
             return familyName;
+        } else if (locale.equals(nameLocale) && localeFamilyName != null) {
+            return localeFamilyName;
         } else {
             short localeID = FontManager.getLCIDFromLocale(locale);
             String name = lookupName(localeID, FAMILY_NAME_ID);
             if (name == null) {
-                return familyName;
+               return familyName;
             } else {
                 return name;
             }
--- jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java
+++ jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java
@@ -76,7 +76,7 @@
 public abstract class SunGraphicsEnvironment extends GraphicsEnvironment
     implements FontSupport, DisplayChangedListener {
 
-    public static boolean isLinux;
+    public static boolean isLinuxOrBSD;
     public static boolean isSolaris;
     public static boolean isWindows;
     public static boolean noType1Font;
@@ -164,7 +164,15 @@
             public Object run() {
                 String osName = System.getProperty("os.name");
                 if ("Linux".equals(osName)) {
-                    isLinux = true;
+                    isLinuxOrBSD = true;
+                } else if ("FreeBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("Darwin".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("NetBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("OpenBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
                 } else if ("SunOS".equals(osName)) {
                     isSolaris = true;
                 } else if ("Windows".equals(osName)) {
@@ -227,8 +235,8 @@
                  * Pass "true" to registerFonts method as on-screen these
                  * JRE fonts always go through the T2K rasteriser.
                  */
-                if (isLinux) {
-                    /* Linux font configuration uses these fonts */
+                if (isLinuxOrBSD) {
+                    /* Linux/BSD font configuration uses these fonts */
                     registerFontDir(jreFontDirName);
                 }
                 registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,
--- jdk/src/share/classes/sun/nio/ch/KqueueSelectorProvider.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/src/share/classes/sun/nio/ch/KqueueSelectorProvider.java
@@ -0,0 +1,17 @@
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+public class KqueueSelectorProvider
+    extends SelectorProviderImpl
+{
+    public AbstractSelector openSelector() throws IOException {
+	return new KqueueSelectorImpl(this);
+    }
+
+    public Channel inheritedChannel() throws IOException {
+	return InheritedChannel.getChannel();
+    }
+}
--- jdk/src/share/classes/sun/print/PSPrinterJob.java
+++ jdk/src/share/classes/sun/print/PSPrinterJob.java
@@ -1531,7 +1531,9 @@
             pFlags |= NOSHEET;
             ncomps+=1;
         }
-       if (System.getProperty("os.name").equals("Linux")) {
+
+       String osname = System.getProperty("os.name");
+       if (osname.equals("Linux") || osname.equals("FreeBSD") || osname.equals("NetBSD") || osname.equals("OpenBSD") || osname.equals("Darwin")) {
             execCmd = new String[ncomps];
             execCmd[n++] = "/usr/bin/lpr";
             if ((pFlags & PRINTER) != 0) {
--- jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java
+++ jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java
@@ -49,8 +49,12 @@
             AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
                     public Boolean run() {
                             String osname = System.getProperty("os.name");
-                            if (osname.startsWith("SunOS") ||
-                                osname.startsWith("Linux")) {
+                            if (osname.startsWith("SunOS")
+                                    || osname.startsWith("Linux")
+                                    || osname.startsWith("FreeBSD")
+                                    || osname.startsWith("NetBSD")
+                                    || osname.startsWith("OpenBSD")
+                                    || osname.startsWith("Darwin")) {
                                 return new Boolean(System.getProperty
                                     (USE_NATIVE_PROP));
                             }
--- jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
+++ jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java
@@ -82,7 +82,11 @@
                             String osname = System.getProperty("os.name");
                             if (osname.startsWith("SunOS")) {
                                 gssLib = "libgss.so";
-                            } else if (osname.startsWith("Linux")) {
+                            } else if (osname.startsWith("Linux")
+                                    || osname.startsWith("FreeBSD")
+                                    || osname.startsWith("NetBSD")
+                                    || osname.startsWith("OpenBSD")
+                                    || osname.startsWith("Darwin")) {
                                 gssLib = "libgssapi.so";
                             }
                         }
--- jdk/src/share/classes/sun/security/krb5/Config.java
+++ jdk/src/share/classes/sun/security/krb5/Config.java
@@ -711,7 +711,11 @@
                     }
                 } else if (osname.startsWith("SunOS")) {
                     name =  "/etc/krb5/krb5.conf";
-                } else if (osname.startsWith("Linux")) {
+                } else if (osname.startsWith("Linux")
+                        || osname.startsWith("FreeBSD")
+                        || osname.startsWith("NetBSD")
+                        || osname.startsWith("OpenBSD")
+                        || osname.startsWith("Darwin")) {
                     name =  "/etc/krb5.conf";
                 }
             }
--- jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java
+++ jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java
@@ -386,8 +386,12 @@
             String uidStr = null;
             long uid = 0;
 
-            if (osname.startsWith("SunOS") ||
-                (osname.startsWith("Linux"))) {
+            if (osname.startsWith("SunOS")
+                    || osname.startsWith("Linux")
+                    || osname.startsWith("FreeBSD")
+                    || osname.startsWith("NetBSD")
+                    || osname.startsWith("OpenBSD")
+                    || osname.startsWith("Darwin")) {
                 try {
                     Class<?> c = Class.forName
                         ("com.sun.security.auth.module.UnixSystem");
--- jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider
+++ jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider
@@ -30,3 +30,4 @@
 #[solaris]sun.tools.attach.SolarisAttachProvider
 #[windows]sun.tools.attach.WindowsAttachProvider
 #[linux]sun.tools.attach.LinuxAttachProvider
+#[bsd]sun.tools.attach.BsdAttachProvider
--- jdk/src/share/classes/sun/tools/jar/Main.java
+++ jdk/src/share/classes/sun/tools/jar/Main.java
@@ -48,6 +48,7 @@
     String zname = "";
     String[] files;
     String rootjar = null;
+    String cwd;
 
     // An entryName(path)->File map generated during "expand", it helps to
     // decide whether or not an existing entry in a jar file needs to be
@@ -249,6 +250,16 @@
                     }
                 }
             } else if (xflag) {
+                // Current working directory
+                cwd = System.getProperty("user.dir");
+                if (cwd == null) {
+                    fatalError(getMsg("error.no.cwd"));
+                }
+                cwd = (new File(cwd)).getCanonicalPath();
+                if (!cwd.endsWith(File.separator)) {
+                    cwd += File.separator;
+                }
+                // Extract the files
                 replaceFSC(files);
                 if (fname != null && files != null) {
                     extract(fname, files);
@@ -921,6 +932,10 @@
         ZipEntry rc = null;
         String name = e.getName();
         File f = new File(e.getName().replace('/', File.separatorChar));
+        if (!f.getCanonicalPath().startsWith(cwd)) {
+            output(formatMsg("out.ignore.entry", name));
+            return null;
+        }
         if (e.isDirectory()) {
             if (f.exists()) {
                 if (!f.isDirectory()) {
@@ -942,6 +957,10 @@
         } else {
             if (f.getParent() != null) {
                 File d = new File(f.getParent());
+                if (!d.getCanonicalPath().startsWith(cwd)) {
+                    output(formatMsg("out.ignore.entry", name));
+                    return null;
+                }
                 if (!d.exists() && !d.mkdirs() || !d.isDirectory()) {
                     throw new IOException(formatMsg(
                         "error.create.dir", d.getPath()));
--- jdk/src/share/classes/sun/tools/jar/resources/jar.properties
+++ jdk/src/share/classes/sun/tools/jar/resources/jar.properties
@@ -44,6 +44,8 @@
         {0} : could not create directory
 error.incorrect.length=\
         incorrect length while processing: {0}
+error.no.cwd=\
+	{0} : could not determine current working directory
 out.added.manifest=\
         added manifest
 out.update.manifest=\
--- jdk/src/share/hpi/include/hpi_impl.h
+++ jdk/src/share/hpi/include/hpi_impl.h
@@ -138,7 +138,11 @@
 int sysBind(int fd, struct sockaddr *him, int len);
 int sysAccept(int fd, struct sockaddr *him, int *len);
 int sysGetSockName(int fd, struct sockaddr *him, int *len);
-#ifdef _LP64
+#if defined(_LP64) || defined(_ALLBSD_SOURCE)
+// XXXBSD: The implementations all use ssize_t, except on Windows,
+// regardless of _LP64. The resulting mismatch between "int" and "ssize_t"
+// causes gcc on Darwin to report a conflicting types error.
+// Appears to be an upstream issue introduced in 1.7
 ssize_t sysSendTo(int fd, char *buf, int len, int flags, struct sockaddr *to,
               int tolen);
 ssize_t sysRecvFrom(int fd, char *buf, int nbytes, int flags,
--- jdk/src/share/native/com/sun/java/util/jar/pack/defines.h
+++ jdk/src/share/native/com/sun/java/util/jar/pack/defines.h
@@ -32,6 +32,10 @@
 #include <unistd.h>
 #endif
 
+#ifndef NO_ZLIB
+#      include <zconf.h>
+#endif
+
 #ifndef FULL
 #define FULL 1 /* Adds <500 bytes to the zipped final product. */
 #endif
@@ -89,11 +93,13 @@
 // bytes and byte arrays
 
 typedef unsigned int uint;
+#ifdef NO_ZLIB
 #ifdef _LP64
 typedef unsigned int uLong; // Historical zlib, should be 32-bit.
 #else
 typedef unsigned long uLong;
 #endif
+#endif
 #ifdef _MSC_VER 
 typedef LONGLONG 	jlong;
 typedef DWORDLONG 	julong;
--- jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp
+++ jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp
@@ -33,9 +33,14 @@
 #include <limits.h>
 #include <time.h>
 
+/* !PRODUCT needs intptr_t */
+#if defined(_ALLBSD_SOURCE) && !defined(PRODUCT)
+#include <stdint.h>
+#endif
+
 #if defined(unix) && !defined(PRODUCT)
 #include "pthread.h"
-#define THREAD_SELF ((int)pthread_self())
+#define THREAD_SELF ((intptr_t) pthread_self())
 #endif
 
 #include "defines.h"
@@ -58,9 +63,9 @@
 // Single-threaded, implementation, not reentrant.
 // Includes a weak error check against MT access.
 #ifndef THREAD_SELF
-#define THREAD_SELF (0)
+#define THREAD_SELF ((intptr_t) 0)
 #endif
-NOT_PRODUCT(static int uThread = -1;)
+NOT_PRODUCT(static intptr_t uThread = -1;)
 
 unpacker* unpacker::non_mt_current = null;
 unpacker* unpacker::current() {
@@ -69,7 +74,7 @@
 }
 static void set_current_unpacker(unpacker* u) {
   unpacker::non_mt_current = u;
-  assert(((uThread = (u == null) ? -1 : THREAD_SELF),
+  assert(((uThread = (u == null) ? ((intptr_t) -1) : THREAD_SELF),
           true));
 }
 
--- jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c
+++ jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c
@@ -33,7 +33,11 @@
 
 #include <jni.h>
 // for malloc
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "SoundDefs.h"
 #include "DirectAudio.h"
 #include "Utilities.h"
--- jdk/src/share/native/com/sun/media/sound/SoundDefs.h
+++ jdk/src/share/native/com/sun/media/sound/SoundDefs.h
@@ -31,6 +31,7 @@
 #define X_WINDOWS       1
 #define X_SOLARIS       2
 #define X_LINUX         3
+#define X_BSD           4
 
 // types for X_ARCH
 #define X_I586          1
@@ -50,7 +51,7 @@
 
 
 // following is needed for _LP64
-#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX))
+#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX) || (X_PLATFORM == X_BSD))
 #include <sys/types.h>
 #endif
 
@@ -130,4 +131,9 @@
 #endif
 
 
+#if X_PLATFORM == X_BSD
+#define INLINE          inline
+#endif
+
+
 #endif  // __SOUNDDEFS_INCLUDED__
--- jdk/src/share/native/common/check_code.c
+++ jdk/src/share/native/common/check_code.c
@@ -1069,7 +1069,7 @@
  * Make sure that branches don't go into the middle of nowhere.
  */
 
-static jint ntohl(jint n)
+static jint _ck_ntohl(jint n)
 {
     unsigned char *p = (unsigned char *)&n;
     return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
@@ -1148,26 +1148,26 @@
             }
         }
         if (opcode == opc_tableswitch) {
-            keys = ntohl(lpc[2]) -  ntohl(lpc[1]) + 1;
+            keys = _ck_ntohl(lpc[2]) -  _ck_ntohl(lpc[1]) + 1;
             delta = 1;
         } else {
-            keys = ntohl(lpc[1]); /* number of pairs */
+            keys = _ck_ntohl(lpc[1]); /* number of pairs */
             delta = 2;
             /* Make sure that the tableswitch items are sorted */
             for (k = keys - 1, lptr = &lpc[2]; --k >= 0; lptr += 2) {
-                int this_key = ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
-                int next_key = ntohl(lptr[2]);
+                int this_key = _ck_ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
+                int next_key = _ck_ntohl(lptr[2]);
                 if (this_key >= next_key) {
                     CCerror(context, "Unsorted lookup switch");
                 }
             }
         }
         saved_operand = NEW(int, keys + 2);
-        if (!isLegalTarget(context, offset + ntohl(lpc[0])))
+        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))
             CCerror(context, "Illegal default target in switch");
-        saved_operand[keys + 1] = code_data[offset + ntohl(lpc[0])];
+        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];
         for (k = keys, lptr = &lpc[3]; --k >= 0; lptr += delta) {
-            int target = offset + ntohl(lptr[0]);
+            int target = offset + _ck_ntohl(lptr[0]);
             if (!isLegalTarget(context, target))
                 CCerror(context, "Illegal branch in opc_tableswitch");
             saved_operand[k + 1] = code_data[target];
@@ -1615,7 +1615,7 @@
             if (lpc + 2 >= (int *)end) {
                 return -1; /* do not read pass the end */
             }
-            index = ntohl(lpc[2]) - ntohl(lpc[1]);
+	    index = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]);
             if ((index < 0) || (index > 65535)) {
                 return -1;      /* illegal */
             } else {
@@ -1628,7 +1628,7 @@
             int npairs;
             if (lpc + 1 >= (int *)end)
                 return -1; /* do not read pass the end */
-            npairs = ntohl(lpc[1]);
+	    npairs = _ck_ntohl(lpc[1]);
             /* There can't be more than 64K labels because of the limit
              * on per-method byte code length.
              */
--- jdk/src/share/native/java/io/io_util.h
+++ jdk/src/share/native/java/io/io_util.h
@@ -29,7 +29,15 @@
 extern jfieldID IO_fd_fdID;
 extern jfieldID IO_handle_fdID;
 
-#if !defined(O_DSYNC) || !defined(O_SYNC)
+#ifdef _ALLBSD_SOURCE
+#include <fcntl.h>
+#ifndef O_SYNC
+#define O_SYNC  O_FSYNC
+#endif
+#ifndef O_DSYNC
+#define O_DSYNC O_FSYNC
+#endif
+#elif !defined(O_DSYNC) || !defined(O_SYNC)
 #define O_SYNC  (0x0800)
 #define O_DSYNC (0x2000)
 #endif
--- jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h
+++ jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h
@@ -25,6 +25,10 @@
  * questions.
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include "jfdlibm.h"
 
 #ifdef __NEWVALID       /* special setup for Sun test regime */
@@ -47,11 +51,13 @@
 #define __LOp(x) *(1+(int*)x)
 #endif
 
+#ifndef __P
 #ifdef __STDC__
 #define __P(p)  p
 #else
 #define __P(p)  ()
 #endif
+#endif
 
 /*
  * ANSI/POSIX
--- jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h
+++ jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h
@@ -61,7 +61,7 @@
 #define log1p   jlog1p
 #define expm1   jexpm1
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define __ieee754_sqrt          __j__ieee754_sqrt
 #define __ieee754_acos          __j__ieee754_acos
 #define __ieee754_acosh         __j__ieee754_acosh
--- jdk/src/share/native/java/util/zip/Inflater.c
+++ jdk/src/share/native/java/util/zip/Inflater.c
@@ -65,6 +65,10 @@
 	return jlong_zero;
     } else {
 	char *msg;
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+	strm->adler = 1;
+#endif
 	switch (inflateInit2(strm, nowrap ? -MAX_WBITS : MAX_WBITS)) {
 	  case Z_OK:
 	    return ptr_to_jlong(strm);
@@ -197,6 +201,10 @@
     if (inflateReset(jlong_to_ptr(addr)) != Z_OK) {
 	JNU_ThrowInternalError(env, 0);
     }
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+    ((z_stream *)jlong_to_ptr(strm))->adler = 1;
+#endif
 }
 
 JNIEXPORT void JNICALL
--- jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h
+++ jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h
@@ -42,44 +42,49 @@
 /* for _LP64 */
 #include <sys/types.h>
 
+/**
+ * Privatise the symbols to the JDK.
+ */
+#define Z_PREFIX
+
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
  */
 #ifdef Z_PREFIX
-#  define deflateInit_  z_deflateInit_
-#  define deflate       z_deflate
-#  define deflateEnd    z_deflateEnd
-#  define inflateInit_  z_inflateInit_
-#  define inflate       z_inflate
-#  define inflateEnd    z_inflateEnd
-#  define deflateInit2_ z_deflateInit2_
-#  define deflateSetDictionary z_deflateSetDictionary
-#  define deflateCopy   z_deflateCopy
-#  define deflateReset  z_deflateReset
-#  define deflateParams z_deflateParams
-#  define inflateInit2_ z_inflateInit2_
-#  define inflateSetDictionary z_inflateSetDictionary
-#  define inflateSync   z_inflateSync
-#  define inflateSyncPoint z_inflateSyncPoint
-#  define inflateReset  z_inflateReset
-#  define compress      z_compress
-#  define compress2     z_compress2
-#  define uncompress    z_uncompress
-#  define adler32       z_adler32
-#  define crc32         z_crc32
-#  define get_crc_table z_get_crc_table
-
-#  define Byte          z_Byte
-#  define uInt          z_uInt
-#  define uLong         z_uLong
-#  define Bytef         z_Bytef
-#  define charf         z_charf
-#  define intf          z_intf
-#  define uIntf         z_uIntf
-#  define uLongf        z_uLongf
-#  define voidpf        z_voidpf
-#  define voidp         z_voidp
+#  define deflateInit_  _java_z_deflateInit_
+#  define deflate       _java_z_deflate
+#  define deflateEnd    _java_z_deflateEnd
+#  define inflateInit_  _java_z_inflateInit_
+#  define inflate       _java_z_inflate
+#  define inflateEnd    _java_z_inflateEnd
+#  define deflateInit2_ _java_z_deflateInit2_
+#  define deflateSetDictionary _java_z_deflateSetDictionary
+#  define deflateCopy   _java_z_deflateCopy
+#  define deflateReset  _java_z_deflateReset
+#  define deflateParams _java_z_deflateParams
+#  define inflateInit2_ _java_z_inflateInit2_
+#  define inflateSetDictionary _java_z_inflateSetDictionary
+#  define inflateSync   _java_z_inflateSync
+#  define inflateSyncPoint _java_z_inflateSyncPoint
+#  define inflateReset  _java_z_inflateReset
+#  define compress      _java_z_compress
+#  define compress2     _java_z_compress2
+#  define uncompress    _java_z_uncompress
+#  define adler32       _java_z_adler32
+#  define crc32         _java_z_crc32
+#  define get_crc_table _java_z_get_crc_table
+
+#  define Byte          _java_z_Byte
+#  define uInt          _java_z_uInt
+#  define uLong         _java_z_uLong
+#  define Bytef         _java_z_Bytef
+#  define charf         _java_z_charf
+#  define intf          _java_z_intf
+#  define uIntf         _java_z_uIntf
+#  define uLongf        _java_z_uLongf
+#  define voidpf        _java_z_voidpf
+#  define voidp         _java_z_voidp
 #endif
 
 #if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
--- jdk/src/share/native/sun/awt/debug/debug_util.h
+++ jdk/src/share/native/sun/awt/debug/debug_util.h
@@ -50,7 +50,9 @@
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <malloc.h>
+#endif
 #include <limits.h>
 
 /* keep these after the other headers */
--- jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c
+++ jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c
@@ -24,7 +24,11 @@
  */
 
 #include "BufImgSurfaceData.h"
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "sun_awt_image_BufImgSurfaceData.h"
 
--- jdk/src/share/native/sun/awt/image/DataBufferNative.c
+++ jdk/src/share/native/sun/awt/image/DataBufferNative.c
@@ -23,7 +23,11 @@
  * questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "SurfaceData.h"
 #include "sun_awt_image_DataBufferNative.h"
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c
@@ -86,7 +86,7 @@
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c
@@ -95,7 +95,7 @@
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -612,7 +612,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -622,12 +622,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -637,7 +637,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -645,7 +645,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -655,12 +655,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -670,7 +670,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -718,7 +718,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -732,14 +732,14 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -753,7 +753,7 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -763,7 +763,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -777,14 +777,14 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -798,7 +798,7 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -851,7 +851,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -861,12 +861,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -876,12 +876,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -891,12 +891,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -906,7 +906,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -914,7 +914,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -924,12 +924,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -939,12 +939,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -954,12 +954,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -969,7 +969,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c
@@ -88,7 +88,7 @@
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
--- jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c
@@ -275,11 +275,11 @@
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
--- jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* BYTE_ORDER == ... */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- jdk/src/share/native/sun/awt/medialib/mlib_image.h
+++ jdk/src/share/native/sun/awt/medialib/mlib_image.h
@@ -27,6 +27,11 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
+
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
--- jdk/src/share/native/sun/awt/medialib/mlib_sys.c
+++ jdk/src/share/native/sun/awt/medialib/mlib_sys.c
@@ -26,9 +26,15 @@
 
 #include <stdlib.h>
 #include <string.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#endif
 #include <mlib_types.h>
 #include <mlib_sys_proto.h>
 #include "mlib_SysMath.h"
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#endif
 
 /***************************************************************/
 
@@ -86,7 +92,12 @@
    * alignment. -- from stdlib.h of MS VC++5.0.
    */
   return (void *) malloc(size);
-#else /* _MSC_VER */
+#elif defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
+#elif defined(_ALLBSD_SOURCE)
+  return valloc(size);
+#else
   return (void *) memalign(8, size);
 #endif /* _MSC_VER */
 }
--- jdk/src/share/native/sun/awt/medialib/mlib_types.h
+++ jdk/src/share/native/sun/awt/medialib/mlib_types.h
@@ -59,7 +59,10 @@
 
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(__GNUC__)
 
-#if defined(__linux__)
+#if defined(_ALLBSD_SOURCE)
+#include <stddef.h>                     /* for ptrdiff_t */
+#include <stdint.h>                     /* for uintptr_t */
+#elif defined(__linux__)
 #include <stdint.h>                     /* for uintptr_t */
 #include <malloc.h>                     /* for ptrdiff_t */
 #else
--- jdk/src/share/native/sun/font/AccelGlyphCache.c
+++ jdk/src/share/native/sun/font/AccelGlyphCache.c
@@ -23,7 +23,11 @@
  * questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "jni.h"
 #include "AccelGlyphCache.h"
 #include "Trace.h"
--- jdk/src/share/native/sun/font/DrawGlyphList.c
+++ jdk/src/share/native/sun/font/DrawGlyphList.c
@@ -26,7 +26,11 @@
 #include "jlong.h"
 #include "math.h"
 #include "string.h"
+#ifdef _ALLBSD_SOURCE
+#include "stdlib.h"
+#else
 #include "malloc.h"
+#endif
 #include "sunfontids.h"
 #include "fontscalerdefs.h"
 #include "glyphblitting.h"
--- jdk/src/share/native/sun/font/sunFont.c
+++ jdk/src/share/native/sun/font/sunFont.c
@@ -24,7 +24,9 @@
  */
 
 #include "stdlib.h"
+#ifndef _ALLBSD_SOURCE
 #include "malloc.h"
+#endif
 #include "string.h"
 #include "gdefs.h"
 #include "jlong.h"
--- jdk/src/share/native/sun/java2d/SurfaceData.c
+++ jdk/src/share/native/sun/java2d/SurfaceData.c
@@ -28,7 +28,11 @@
 #include "jni_util.h"
 #include "Disposer.h"
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 #include "string.h"
 
 /**
--- jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h
+++ jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h
@@ -26,6 +26,9 @@
 #ifndef OGLFuncs_h_Included
 #define OGLFuncs_h_Included
 
+#ifdef _ALLBSD_SOURCE
+#include <dlfcn.h>
+#endif
 #include "jni.h"
 #include "J2D_GL/gl.h"
 #include "J2D_GL/glext.h"
--- jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c
+++ jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "sun_java2d_pipe_BufferedOpCodes.h"
 
--- jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c
+++ jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <math.h>
 #include <jlong.h>
 
--- jdk/src/share/transport/socket/socketTransport.c
+++ jdk/src/share/transport/socket/socketTransport.c
@@ -65,6 +65,9 @@
 #define HEADER_SIZE     11
 #define MAX_DATA_SIZE 1000
 
+static jint recv_fully(int, char *, int);
+static jint send_fully(int, char *, int);
+
 /*
  * Record the last error for this thread.
  */
@@ -155,7 +158,7 @@
         }
         buf = b;
         buf += received;
-        n = dbgsysRecv(fd, buf, helloLen-received, 0);
+        n = recv_fully(fd, buf, helloLen-received);
         if (n == 0) {
             setLastError(0, "handshake failed - connection prematurally closed");
             return JDWPTRANSPORT_ERROR_IO_ERROR;
@@ -180,7 +183,7 @@
         return JDWPTRANSPORT_ERROR_IO_ERROR;
     }
 
-    if (dbgsysSend(fd, (char*)hello, helloLen, 0) != helloLen) {
+    if (send_fully(fd, hello,  helloLen) != helloLen) {
         RETURN_IO_ERROR("send failed during handshake");
     }
     return JDWPTRANSPORT_ERROR_NONE;
@@ -555,19 +558,19 @@
     /* Do one send for short packets, two for longer ones */
     if (data_len <= MAX_DATA_SIZE) {
         memcpy(header + HEADER_SIZE, data, data_len);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + data_len, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + data_len) != 
             HEADER_SIZE + data_len) {
             RETURN_IO_ERROR("send failed");
         }
     } else {
         memcpy(header + HEADER_SIZE, data, MAX_DATA_SIZE);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE) != 
             HEADER_SIZE + MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
         /* Send the remaining data bytes right out of the data area. */
-        if (dbgsysSend(socketFD, (char *)data + MAX_DATA_SIZE,
-                       data_len - MAX_DATA_SIZE, 0) != data_len - MAX_DATA_SIZE) {
+        if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE, 
+                       data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
     }
@@ -575,13 +578,33 @@
     return JDWPTRANSPORT_ERROR_NONE;
 }
 
-static jint
+jint
 recv_fully(int f, char *buf, int len)
 {
     int nbytes = 0;
     while (nbytes < len) {
         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
         if (res < 0) {
+	    if (errno == EINTR)
+		continue;
+            return res;
+        } else if (res == 0) {
+            break; /* eof, return nbytes which is less than len */
+        }
+        nbytes += res;
+    }
+    return nbytes;
+}
+
+jint
+send_fully(int f, char *buf, int len)
+{
+    int nbytes = 0;
+    while (nbytes < len) {
+        int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
+        if (res < 0) {
+	    if (errno == EINTR)
+		continue;
             return res;
         } else if (res == 0) {
             break; /* eof, return nbytes which is less than len */
--- jdk/src/solaris/back/exec_md.c
+++ jdk/src/solaris/back/exec_md.c
@@ -30,7 +30,7 @@
 #include "sys.h"
 #include "util.h"
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   /* Linux */
   #define FORK() fork()
 #else
--- jdk/src/solaris/back/linker_md.c
+++ jdk/src/solaris/back/linker_md.c
@@ -48,6 +48,12 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -77,9 +83,9 @@
     }
 
     if (pnamelen == 0) {
-        (void)snprintf(holder, holderlen, "lib%s.so", fname);
+        (void)snprintf(holder, holderlen, "lib%s." LIB_SUFFIX, fname);
     } else {
-        (void)snprintf(holder, holderlen, "%s/lib%s.so", pname, fname);
+        (void)snprintf(holder, holderlen, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
--- jdk/src/solaris/back/util_md.h
+++ jdk/src/solaris/back/util_md.h
@@ -29,7 +29,7 @@
 #include <stddef.h>
 
 /* To get uintptr_t */
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
 #else
 /* The file stdint.h is not on Solaris 8 machines. */
@@ -40,6 +40,7 @@
 
 #include <limits.h>
 #include <sys/types.h>
+#include <machine/endian.h>
 
 #ifdef _LP64
 typedef unsigned long UNSIGNED_JLONG;
@@ -55,7 +56,7 @@
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
--- jdk/src/solaris/bin/java_md.c
+++ jdk/src/solaris/bin/java_md.c
@@ -24,6 +24,7 @@
  */
 
 #include "java.h"
+#include "jvm_md.h"
 #include <dirent.h>
 #include <dlfcn.h>
 #include <fcntl.h>
@@ -34,17 +35,33 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/time.h>
+#endif
+#ifndef _SC_PHYS_PAGES
+#include <sys/sysctl.h>
+#endif
+
 #include "manifest_info.h"
 #include "version_comp.h"
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #else
 #include <thread.h>
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+/* FALLBACK avoids naming conflicts with system libraries
+ * (eg, ImageIO's libJPEG.dylib) */
+#define LD_LIBRARY_PATH "DYLD_FALLBACK_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 /*
  * If a processor / os combination has the ability to run binaries of
@@ -75,14 +92,31 @@
 #endif
 
 /* pointer to environment */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char **environ;
+#endif
 
 /*
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __linux__
-static const char *system_dir   = "/usr/java";
+#if defined(__FreeBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__NetBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__OpenBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__APPLE__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__linux__)
+static const char *system_dir   = "/usr/local/java";
 static const char *user_dir     = "/java";
 #else /* Solaris */
 static const char *system_dir   = "/usr/jdk";
@@ -404,10 +438,10 @@
        * If not on Solaris, assume only a single LD_LIBRARY_PATH
        * variable.
        */
-      runpath = getenv("LD_LIBRARY_PATH");
+      runpath = getenv(LD_LIBRARY_PATH);
 #endif /* __sun */
 
-#ifdef __linux
+#if defined(__linux__)
       /*
        * On linux, if a binary is running as sgid or suid, glibc sets
        * LD_LIBRARY_PATH to the empty string for security purposes.  (In
@@ -423,6 +457,22 @@
       if((getgid() != getegid()) || (getuid() != geteuid()) ) {
         return;
       }
+#elif defined(_ALLBSD_SOURCE)
+      /*
+       * On BSD, if a binary is running as sgid or suid, libc sets
+       * LD_LIBRARY_PATH to the empty string for security purposes.  (In
+       * contrast, on Solaris the LD_LIBRARY_PATH variable for a
+       * privileged binary does not lose its settings; but the dynamic
+       * linker does apply more scrutiny to the path.) The launcher uses
+       * the value of LD_LIBRARY_PATH to prevent an exec loop.
+       * Therefore, if we are running sgid or suid, this function's
+       * setting of LD_LIBRARY_PATH will be ineffective and we should
+       * return from the function now.  Getting the right libraries to
+       * be found must be handled through other mechanisms.
+       */
+      if(issetugid()) {
+        return;
+      }
 #endif
 
       /* runpath contains current effective LD_LIBRARY_PATH setting */
@@ -431,7 +481,7 @@
       new_runpath = JLI_MemAlloc( ((runpath!=NULL)?strlen(runpath):0) +
                               2*strlen(jrepath) + 2*strlen(arch) +
                               strlen(jvmpath) + 52);
-      newpath = new_runpath + strlen("LD_LIBRARY_PATH=");
+      newpath = new_runpath + strlen(LD_LIBRARY_PATH "=");
 
 
       /*
@@ -446,7 +496,7 @@
 
         /* jvmpath, ((running != wanted)?((wanted==64)?"/"LIBARCH64NAME:"/.."):""), */
 
-        sprintf(new_runpath, "LD_LIBRARY_PATH="
+        sprintf(new_runpath, LD_LIBRARY_PATH "="
                 "%s:"
                 "%s/lib/%s:"
                 "%s/../lib/%s",
@@ -721,7 +771,7 @@
 jboolean
 GetApplicationHome(char *buf, jint bufsize)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     char *execname = GetExecname();
     if (execname) {
         strncpy(buf, execname, bufsize-1);
@@ -878,9 +928,13 @@
             }
         }
     }
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(_ALLBSD_SOURCE)
     {
+#ifdef __FreeBSD__
+        const char* self = "/proc/curproc/file";
+#else
         const char* self = "/proc/self/exe";
+#endif
         char buf[PATH_MAX+1];
         int len = readlink(self, buf, PATH_MAX);
         if (len >= 0) {
@@ -888,7 +942,7 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__sun && !__linux */
+#else /* !__sun && !__linux && !_ALLBSD_SOURCE */
     {
         /* Not implemented */
     }
@@ -977,6 +1031,7 @@
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+#ifdef _SC_PHYS_PAGES
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
   const uint64_t result    = pages * page_size;
@@ -988,6 +1043,28 @@
            "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   }
+#else
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+  uint64_t result;
+# define UINT64_FORMAT "%" PRIu64
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+       physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  if (_launcher_debug) {
+    printf("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  }
+#endif
   return result;
 }
 
@@ -1083,7 +1160,7 @@
 
 #endif /* __sun && i586 */
 
-#if defined(__linux__) && defined(i586)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(i586)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -1148,7 +1225,7 @@
 #endif
 }
 
-#endif /* __linux__ && i586 */
+#endif /* (__linux__ || _ALLBSD_SOURCE) && i586 */
 
 #ifdef i586
 /*
@@ -1360,6 +1437,39 @@
 
 #endif /* __linux__ && i586 */
 
+#if defined(_ALLBSD_SOURCE) && defined(i586)
+
+/* The definition of a server-class machine for bsd-i586 */
+jboolean
+bsd_i586_ServerClassMachine(void) {
+  jboolean            result            = JNI_FALSE;
+  /* How big is a server class machine? */
+  const unsigned long server_processors = 2UL;
+  const uint64_t      server_memory     = 2UL * GB;
+  /*
+   * We seem not to get our full complement of memory.
+   *     We allow some part (1/8?) of the memory to be "missing",
+   *     based on the sizes of DIMMs, and maybe graphics cards.
+   */
+  const uint64_t      missing_memory    = 256UL * MB;
+  const uint64_t      actual_memory     = physical_memory();
+
+  /* Is this a server class machine? */
+  if (actual_memory >= (server_memory - missing_memory)) {
+    const unsigned long actual_processors = physical_processors();
+    if (actual_processors >= server_processors) {
+      result = JNI_TRUE;
+    }
+  }
+  if (_launcher_debug) {
+    printf("bsd_" LIBARCHNAME "_ServerClassMachine: %s\n",
+           (result == JNI_TRUE ? "true" : "false"));
+  }
+  return result;
+}
+
+#endif /* _ALLBSD_SOURCE && i586 */
+
 /* Dispatch to the platform-specific definition of "server-class" */
 jboolean
 ServerClassMachine(void) {
@@ -1374,6 +1484,8 @@
   result = solaris_i586_ServerClassMachine();
 #elif defined(__linux__) && defined(i586)
   result = linux_i586_ServerClassMachine();
+#elif defined(_ALLBSD_SOURCE) && defined(i586)
+  result = bsd_i586_ServerClassMachine();
 #else
   if (_launcher_debug) {
     printf("ServerClassMachine: returns default value of %s\n",
@@ -1514,7 +1626,7 @@
     while (dp != NULL) {
         cp = strchr(dp, (int)':');
         if (cp != NULL)
-            *cp = (char)NULL;
+            *cp = '\0';
         if ((target = ProcessDir(info, dp)) != NULL)
             break;
         dp = cp;
@@ -1692,9 +1804,29 @@
     return(borrowed_unsetenv(name));
 }
 
+#if defined(_ALLBSD_SOURCE)
+/*
+ * BSD's implementation of CounterGet()
+ */
+int64_t
+CounterGet()
+{
+#ifdef __FreeBSD__
+	struct timespec tp;
+	clock_gettime(CLOCK_MONOTONIC, &tp);
+	return (uint64_t)tp.tv_sec * 1000000 + tp.tv_nsec / 1000;
+#else
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (uint64_t)tv.tv_sec * 1000000 + tv.tv_usec;
+#endif
+}
+#endif
+
+
 /* --- Splash Screen shared library support --- */
 
-static const char* SPLASHSCREEN_SO = "libsplashscreen.so";
+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME("splashscreen");
 
 static void* hSplashLib = NULL;
 
@@ -1722,13 +1854,15 @@
     return "%lld";
 }
 
+
+
 /*
  * Block current thread and continue execution in a new thread
  */
 int
-ContinueInNewThread(int (JNICALL *continuation)(void *), jlong stack_size, void * args, int ret) {
+ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
     int rslt;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pthread_t tid;
     pthread_attr_t attr;
     pthread_attr_init(&attr);
@@ -1741,7 +1875,7 @@
     if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) {
       void * tmp;
       pthread_join(tid, &tmp);
-      rslt = (int)tmp;
+      rslt = (int)(intptr_t)tmp;
     } else {
      /*
       * Continue execution in current thread if for some reason (e.g. out of
@@ -1759,25 +1893,23 @@
     if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {
       void * tmp;
       thr_join(tid, NULL, &tmp);
-      rslt = (int)tmp;
+      rslt = (int)(intptr_t)tmp;
     } else {
       /* See above. Continue in current thread if thr_create() failed */
       rslt = continuation(args);
     }
 #endif
-    /* If the caller has deemed there is an error we
-     * simply return that, otherwise we return the value of
-     * the callee
-     */
-    return (ret != 0) ? ret : rslt;
+    return rslt;
 }
 
+
+
 /* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */
 #define MAX_PID_STR_SZ   20
 
 void SetJavaLauncherPlatformProps() {
-   /* Linux only */
-#ifdef __linux__
+   /* Linux and BSDs only */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     const char *substr = "-Dsun.java.launcher.pid=";
     char *pid_prop_str = (char *)JLI_MemAlloc(strlen(substr) + MAX_PID_STR_SZ + 1);
     sprintf(pid_prop_str, "%s%d", substr, getpid());
--- jdk/src/solaris/bin/java_md.h
+++ jdk/src/solaris/bin/java_md.h
@@ -58,10 +58,14 @@
 #include <sys/time.h>
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
+#elif defined(_ALLBSD_SOURCE)
+/* CounterGet() is implemented in java_md.c */
+int64_t CounterGet(void);
+#define Counter2Micros(counts)    (counts)
 #else
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
-#endif /* HAVE_GETHRTIME */
+#endif /* HAVE_GETHRTIME || _ALLBSD_SOURCE */
 
 /*
  * Function prototypes.
--- jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java
+++ jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java
@@ -403,7 +403,7 @@
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && isLinux && !isOpenJDK()) {
+            if (fileName == null && isLinuxOrBSD && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -639,7 +639,7 @@
         if (fontConfigDirs == null) {
             return;
         }
-        if (isLinux) {
+        if (isLinuxOrBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
--- jdk/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
+++ jdk/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
@@ -47,6 +47,10 @@
     public static SelectorProvider create() {
         String osname = AccessController.doPrivileged(
             new GetPropertyAction("os.name"));
+	if ("FreeBSD".equals(osname)) {
+            return new sun.nio.ch.KqueueSelectorProvider();
+        }
+
         if ("SunOS".equals(osname)) {
             return new sun.nio.ch.DevPollSelectorProvider();
         }
--- jdk/src/solaris/classes/sun/nio/ch/KqueueArrayWrapper.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/src/solaris/classes/sun/nio/ch/KqueueArrayWrapper.java
@@ -0,0 +1,231 @@
+/*
+ * Scratched by davidxu@freebsd.org
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.Arrays;
+
+class KqueueArrayWrapper {
+
+    // Event masks copied from class AbstractPollArrayWrapper
+    static final short POLLIN       = 0x0001;
+    static final short POLLOUT      = 0x0004;
+    static final short POLLERR      = 0x0008;
+    static final short POLLHUP      = 0x0010;
+    static final short POLLNVAL     = 0x0020;
+    static final short POLLREMOVE   = 0x0800;
+
+    // Kevent filters
+    static final short EVFILT_READ  = -1;
+    static final short EVFILT_WRITE = -2;
+
+    // Kevent flags
+    static final short EV_ADD       = 0x0001;
+    static final short EV_DELETE    = 0x0002;
+    static final short EV_ERROR     = 0x4000;
+
+    // Miscellaneous constants
+    static final int SIZE_KEVENT   = keventSize();
+
+    // Zero mask to unregister events from kqueue
+    static final Integer ZERO_MASK = new Integer(0);
+
+    // Capacity increment of some arrays
+    static final int capacityIncr = 100;
+
+    KqueueArrayWrapper() {
+	int allocationSize;
+
+	// initial size of event array
+	pollKeventSize = capacityIncr * 2;
+	allocationSize = pollKeventSize * SIZE_KEVENT;
+	pollKeventArray = new AllocatedNativeObject(allocationSize, true);
+	kqfd = kqueue();
+    }
+
+    // Machinery for remembering fd registration changes
+    private HashMap<Integer, Integer> updateMap = new HashMap<Integer, Integer>();
+    private int[] oldMasks = new int[capacityIncr];
+
+    // kevent array to receive
+    private AllocatedNativeObject pollKeventArray;
+
+    // current size of pollKeventArray
+    int pollKeventSize;
+
+    // the pollKeventSize should be larger than this
+    int nextKeventSize;
+
+    // The fd of the kqueue()
+    int kqfd;
+
+    // The fd of the interrupt line going out
+    int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    int incomingInterruptFD;
+
+    // The index of the interrupt FD
+    int interruptedIndex;
+
+    // Number of updated kevent entries
+    int updated;
+
+    // ensure some array sizes are large enough with a given file handle
+    void ensureFd(int fd) {
+	ensureNextEventFd(fd);
+	if (oldMasks.length < fd+1)
+	    oldMasks = Arrays.copyOf(oldMasks, fd + capacityIncr);
+    }
+
+    void ensureNextEventFd(int fd) {
+	// each file handle may have two filters, read and write.
+	if (nextKeventSize / 2 < fd+1)
+		nextKeventSize = (fd+1) * 2;
+    }
+
+    void resizeEventBuffer() {
+	if (nextKeventSize > pollKeventSize) {
+	    pollKeventArray.free();
+	    pollKeventSize = nextKeventSize + capacityIncr * 2;
+	    int allocationSize = pollKeventSize * SIZE_KEVENT;
+	    pollKeventArray = new AllocatedNativeObject(allocationSize, true);
+	}
+    }
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+	ensureFd(fd0);
+	register(kqfd, fd0, EVFILT_READ);
+    }
+
+    int getReventOps(int i) {
+	short filter = getKeventFilter(pollKeventArray.address(), i);
+	short flags = getKeventFlags(pollKeventArray.address(), i);
+	if ((flags & EV_ERROR) != 0)
+		return POLLERR;
+	if (filter == EVFILT_READ)
+		return POLLIN;
+	if (filter == EVFILT_WRITE)
+		return POLLOUT;
+	return (0);
+    }
+
+    int getDescriptor(int i) {
+	return getKeventIdent(pollKeventArray.address(), i);
+    }
+
+    void setInterest(int fd, int mask) {
+	if (fd <0)
+	    throw new IndexOutOfBoundsException("file handle less than 0");
+        synchronized (updateMap) {
+	    ensureFd(fd);
+	    updateMap.put(new Integer(fd), new Integer(mask));
+        }
+    }
+
+    void release(int fd) {
+        synchronized (updateMap) {
+            updateMap.put(new Integer(fd), ZERO_MASK);
+        }
+    }
+
+    void closeKqueueFD() throws IOException {
+        FileDispatcher.closeIntFD(kqfd);
+        pollKeventArray.free();
+    }
+
+    int poll(long timeout) {
+	int changeCount = updateRegistrations();
+        updated = kevent(kqfd, pollKeventArray.address(), changeCount,
+	    pollKeventArray.address(), pollKeventSize, timeout);
+        for (int i = 0; i < updated; i++) {
+            if (getDescriptor(i) == incomingInterruptFD) {
+                interruptedIndex = i;
+                interrupted = true;
+                break;
+            }
+        }
+        return updated;
+    }
+
+    int updateRegistrations() {
+	int index = 0;
+	synchronized (updateMap) {
+	    resizeEventBuffer();
+
+	    Set<Integer> s = updateMap.keySet();
+	    /*
+             * Because resizeEventBuffer may reallocate event buffer,
+             * we must retrieve fresh address here.
+             */
+	    long address = pollKeventArray.address();
+
+	    for (Integer fd : s) {
+		Integer newmask = updateMap.get(fd);
+		int oldmask = oldMasks[fd];
+		if ((oldmask & POLLIN) != 0) {
+			if ((newmask & POLLIN) == 0) {
+		    		putKevent(address, index, fd.intValue(), EV_DELETE, EVFILT_READ);
+				index++;
+			}
+		} else {
+			if ((newmask & POLLIN) != 0) {
+			    putKevent(address, index, fd.intValue(), EV_ADD, EVFILT_READ);
+			    index++;
+			}
+		}
+
+		if ((oldmask & POLLOUT) != 0) {
+			if ((newmask & POLLOUT) == 0) {
+		    		putKevent(address, index, fd.intValue(), EV_DELETE, EVFILT_WRITE);
+				index++;
+			}
+		} else {
+			if ((newmask & POLLOUT) != 0) {
+		    		putKevent(address, index, fd.intValue(), EV_ADD, EVFILT_WRITE);
+				index++;
+			}
+		}
+		oldMasks[fd] = newmask;
+	    }
+	    updateMap.clear();
+	}
+	return index;
+    }
+
+    boolean interrupted = false;
+
+    public void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    public int interruptedIndex() {
+        return interruptedIndex;
+    }
+
+    boolean interrupted() { 
+        return interrupted;
+    }
+
+    void clearInterrupted() {
+        interrupted = false;
+    }
+
+    private static native int  kqueue();
+    private static native void register(int kqfd, int fd, short filter);
+    private static native int  kevent(int kqfd, long changeList, int nchanges, long eventList,
+	int nevents, long timeout);
+    private static native int  keventSize();
+    private static native void interrupt(int fd);
+    private static native void putKevent(long address, int index, int fd, short flag, short filter);
+    private static native short getKeventFilter(long address, int index);
+    private static native short getKeventFlags(long address, int index);
+    private static native int getKeventIdent(long address, int index);
+}
--- jdk/src/solaris/classes/sun/nio/ch/KqueueSelectorImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/src/solaris/classes/sun/nio/ch/KqueueSelectorImpl.java
@@ -0,0 +1,205 @@
+/*
+ * scratched by davidxu@freebsd.org
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+
+/**
+ * An implementation of Selector for FreeBSD.
+ */
+class KqueueSelectorImpl
+    extends SelectorImpl
+{
+
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The kqueue object
+    KqueueArrayWrapper kqueueWrapper;
+
+    // The number of valid channels in this Selector's poll array
+    private int totalChannels;
+
+    // Maps from file descriptors to keys
+    private HashMap fdToKey;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    // Trace number of file handles are updated.
+    private BitSet updatedSet;
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    KqueueSelectorImpl(SelectorProvider sp) {
+	super(sp);
+	int[] fdes = new int[2];
+	IOUtil.initPipe(fdes, false);
+	fd0 = fdes[0];
+	fd1 = fdes[1];
+	kqueueWrapper = new KqueueArrayWrapper();
+	totalChannels = 1;
+	kqueueWrapper.initInterrupt(fd0, fd1);
+	updatedSet = new BitSet();
+	fdToKey = new HashMap();
+    }
+
+    protected int doSelect(long timeout)
+	throws IOException
+    {
+	if (closed)
+		throw new ClosedSelectorException();
+	processDeregisterQueue();
+	try {
+	    begin();
+	    kqueueWrapper.poll(timeout);
+	} finally {
+	    end();
+	}
+	processDeregisterQueue();
+	int numKeysUpdated = updateSelectedKeys();
+	if (kqueueWrapper.interrupted()) {
+	    // Clear the wakeup pipe
+	    synchronized (interruptLock) {
+		kqueueWrapper.clearInterrupted();
+		IOUtil.drain(fd0);
+		interruptTriggered = false;
+	    }
+	}
+	return numKeysUpdated;
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by the kqueue.
+     * Add the ready keys to the ready queue.
+     */
+    private int updateSelectedKeys() {
+        int entries = kqueueWrapper.updated;
+        int numKeysUpdated = 0;
+        SelectionKeyImpl ski;
+	int fd;
+	int i;
+
+	updatedSet.clear();
+	for (i = 0; i < entries; i++) {
+	    fd = kqueueWrapper.getDescriptor(i);
+            ski = (SelectionKeyImpl) fdToKey.get(new Integer(fd));
+            // ski is null in the case of an interrupt
+	    if (ski != null)
+		ski.nioReadyOps(0);
+	}
+
+	for (i = 0; i < entries; i++) {
+            fd = kqueueWrapper.getDescriptor(i);
+            ski = (SelectionKeyImpl) fdToKey.get(new Integer(fd));
+            // ski is null in the case of an interrupt
+            if (ski != null) {
+                int rOps = kqueueWrapper.getReventOps(i);
+                if (selectedKeys.contains(ski)) {
+                    if (ski.channel.translateAndUpdateReadyOps(rOps, ski)) {
+			if (!updatedSet.get(fd)) {
+			    updatedSet.set(fd);
+                            numKeysUpdated++;
+			}
+                    }
+                } else {
+                    ski.channel.translateAndUpdateReadyOps(rOps, ski);
+                    if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                        selectedKeys.add(ski);
+			if (!updatedSet.get(fd)) {
+			    updatedSet.set(fd);
+                            numKeysUpdated++;
+			}
+                    }
+                }
+            }
+        }
+        return numKeysUpdated;
+    }
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+            FileDispatcher.closeIntFD(fd0);
+            FileDispatcher.closeIntFD(fd1);
+            if (kqueueWrapper != null) {
+                kqueueWrapper.release(fd0);
+                kqueueWrapper.closeKqueueFD();
+                kqueueWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+		Iterator i = keys.iterator();
+		while (i.hasNext()) {
+		    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+		    deregister(ski);
+		    SelectableChannel selch = ski.channel();
+		    if (!selch.isOpen() && !selch.isRegistered())
+			((SelChImpl)selch).kill();
+		    i.remove();
+		}
+                totalChannels = 0;
+
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdToKey.put(new Integer(fd), ski);
+        totalChannels++;
+        keys.add(ski);
+    }
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        int i = ski.getIndex();
+        assert (i >= 0);
+        int fd = ski.channel.getFDVal();
+        fdToKey.remove(new Integer(fd));
+        kqueueWrapper.release(fd);
+        totalChannels--;
+        ski.setIndex(-1);
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+	deregister((AbstractSelectionKey)ski);
+	SelectableChannel selch = ski.channel();
+	if (!selch.isOpen() && !selch.isRegistered())
+	    ((SelChImpl)selch).kill();
+    }
+
+    void putEventOps(SelectionKeyImpl sk, int ops) {
+        int fd = IOUtil.fdVal(sk.channel.getFD());
+        kqueueWrapper.setInterest(fd, ops);
+    }
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                kqueueWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+	return this;
+    }
+
+    static {
+        Util.load();
+    }
+
+}
--- jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java
+++ jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java
@@ -119,7 +119,11 @@
     }
 
     static boolean isBSD() {
-        return osname.equals("Linux");
+	return (osname.equals("Linux") ||
+		osname.equals("FreeBSD") ||
+		osname.equals("Darwin") ||
+		osname.equals("NetBSD") ||
+		osname.equals("OpenBSD"));
     }
 
     static final int UNINITIALIZED = -1;
--- jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java
+++ jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java
@@ -38,9 +38,6 @@
  */
 public class BsdVirtualMachine extends HotSpotVirtualMachine {
 
-    // Indicates if this machine uses the old BsdThreads
-    static boolean isBsdThreads;
-
     // The patch to the socket file created by the target VM
     String path;
 
@@ -65,25 +62,10 @@
         // Then we attempt to find the socket file again.
         path = findSocketFile(pid);
         if (path == null) {
-            File f = createAttachFile(pid);
+            File f = new File("/tmp/.attach_pid" + pid);
+	    createAttachFile(f.getPath());
             try {
-                // On BsdThreads each thread is a process and we don't have the
-                // pid of the VMThread which has SIGQUIT unblocked. To workaround
-                // this we get the pid of the "manager thread" that is created
-                // by the first call to pthread_create. This is parent of all
-                // threads (except the initial thread).
-                if (isBsdThreads) {
-                    int mpid;
-                    try {
-                        mpid = getBsdThreadsManager(pid);
-                    } catch (IOException x) {
-                        throw new AttachNotSupportedException(x.getMessage());
-                    }
-                    assert(mpid >= 1);
-                    sendQuitToChildrenOf(mpid);
-                } else {
-                    sendQuitTo(pid);
-                }
+                sendQuitTo(pid);
 
                 // give the target VM time to start the attach mechanism
                 int i = 0;
@@ -265,37 +247,14 @@
         // First check for a .java_pid<pid> file in the working directory
         // of the target process
         String fn = ".java_pid" + pid;
-        String path = "/proc/" + pid + "/cwd/" + fn;
+        String path = "/tmp/" + fn;
         File f = new File(path);
         if (!f.exists()) {
-            // Not found, so try /tmp
-            path = "/tmp/" + fn;
-            f = new File(path);
-            if (!f.exists()) {
-                return null;            // not found
-            }
+            return null;            // not found
         }
         return path;
     }
 
-    // On Solaris/Bsd a simple handshake is used to start the attach mechanism
-    // if not already started. The client creates a .attach_pid<pid> file in the
-    // target VM's working directory (or /tmp), and the SIGQUIT handler checks
-    // for the file.
-    private File createAttachFile(int pid) throws IOException {
-        String fn = ".attach_pid" + pid;
-        String path = "/proc/" + pid + "/cwd/" + fn;
-        File f = new File(path);
-        try {
-            f.createNewFile();
-        } catch (IOException x) {
-            path = "/tmp/" + fn;
-            f = new File(path);
-            f.createNewFile();
-        }
-        return f;
-    }
-
     /*
      * Write/sends the given to the target VM. String is transmitted in
      * UTF-8 encoding.
@@ -318,12 +277,6 @@
 
     //-- native methods
 
-    static native boolean isBsdThreads();
-
-    static native int getBsdThreadsManager(int pid) throws IOException;
-
-    static native void sendQuitToChildrenOf(int pid) throws IOException;
-
     static native void sendQuitTo(int pid) throws IOException;
 
     static native void checkPermissions(String path) throws IOException;
@@ -338,8 +291,9 @@
 
     static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;
 
+    static native void createAttachFile(String path);
+
     static {
         System.loadLibrary("attach");
-        isBsdThreads = isBsdThreads();
     }
 }
--- jdk/src/solaris/demo/jvmti/hprof/hprof_md.c
+++ jdk/src/solaris/demo/jvmti/hprof/hprof_md.c
@@ -33,7 +33,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 #include <procfs.h>
 #endif
 
@@ -76,7 +76,7 @@
 void
 md_init(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     /* No Hi-Res timer option? */
 #else
     if ( gdata->micro_state_accounting ) {
@@ -238,7 +238,7 @@
 jlong
 md_get_microsecs(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return (jlong)(md_timeofday() * (jlong)1000); /* Milli to micro */
 #else
     return (jlong)(gethrtime()/(hrtime_t)1000); /* Nano seconds to micro seconds */
@@ -256,7 +256,7 @@
 jlong
 md_get_thread_cpu_timemillis(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return md_timeofday();
 #else
     return (jlong)(gethrvtime()/1000); /* Nano seconds to milli seconds */
@@ -271,7 +271,7 @@
     Dl_info dlinfo;
 
     libdir[0] = 0;
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     addr = (void*)&Agent_OnLoad;
 #else
     /* Just using &Agent_OnLoad will get the first external symbol with
--- jdk/src/solaris/hpi/include/interrupt.h
+++ jdk/src/solaris/hpi/include/interrupt.h
@@ -75,7 +75,7 @@
  *      N_INTERRUPTS  - The number of interrupt channels.  These
  *                      are numbered from 0 to (N_INTERRUPTS - 1).
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 #define       N_INTERRUPTS    NSIG    /* 0 to NSIG - 1*/
 #else
 #define N_INTERRUPTS    32      /* 0 to 31 */
@@ -111,6 +111,10 @@
 #error signal.h has not been included?
 #endif
 
+#if defined(__FreeBSD__) && !defined(SA_SIGINFO)
+#error signal.h has not been included?
+#endif
+
 #ifdef SA_SIGINFO
 /* Thread implementation dependent interrupt dispatcher. */
 void intrDispatchMD(int sig, siginfo_t *info, void *uc);
--- jdk/src/solaris/hpi/include/largefile.h
+++ jdk/src/solaris/hpi/include/largefile.h
@@ -34,6 +34,10 @@
 #include "largefile_linux.h"
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include "largefile_bsd.h"
+#endif
+
 /*
  * Prototypes for wrappers that we define.  These wrapper functions
  * are low-level I/O routines that will use 64 bit versions if
--- jdk/src/solaris/hpi/include/largefile_bsd.h
+++ jdk/src/solaris/hpi/include/largefile_bsd.h
@@ -23,14 +23,28 @@
  * questions.
  */
 
-#ifndef _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_
-#define _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_
-
-/*
- * For building on glibc-2.0 we need to define stat64 here.
- */
+#ifndef _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
+#define _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
 
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#endif /* _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_ */
+/* define compatibility macros */
+#define                off64_t         off_t
+#define                stat64          stat
+
+#define                F_SETLK64       F_SETLK
+#define                F_SETLKW64      F_SETLKW
+
+#define                lseek64         lseek
+#define                ftruncate64     ftruncate
+#define                open64          open
+#define                fstat64         fstat
+#define                flock64         flock
+#define                mmap64          mmap
+#define                fdatasync       fsync
+
+#define                pread64         pread
+#define                pwrite64        pwrite
+
+#endif /* _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_ */
--- jdk/src/solaris/hpi/native_threads/include/threads_md.h
+++ jdk/src/solaris/hpi/native_threads/include/threads_md.h
@@ -36,6 +36,8 @@
 #define N_TRACED_REGS 12
 #elif i386
 #define N_TRACED_REGS 7
+#elif i586			/* BSDNOTE: just in case */
+#define N_TRACED_REGS 7
 #elif amd64
 #define N_TRACED_REGS 15
 #elif ppc
@@ -51,10 +53,12 @@
 #define N_TRACED_REGS 32
 #endif
 
+#if !defined(_ALLBSD_SOURCE)
 /* Turn on if we want all java threads to be bound tolwps */
 /* #define BOUND_THREADS */
 /* Use /proc soln to stop lwps in place of siglwp soln */
 #define PROCLWP
+#endif
 
 /*
  * Thread C stack overflow check
@@ -132,7 +136,7 @@
     lwpid_t lwpid;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     void *sp;
 #else
     unsigned long  sp;   /* sp at time of last (native) thread switch */
@@ -186,12 +190,14 @@
 
 #define SYS_THREAD_NULL         ((sys_thread_t *) 0)
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * following macro copied from sys/signal.h since inside #ifdef _KERNEL there.
  */
 #ifndef sigmask
 #define sigmask(n)      ((unsigned int)1 << (((n) - 1) & (32 - 1)))
 #endif
+#endif
 
 #ifdef __linux__
 extern thread_key_t intrJmpbufkey;
--- jdk/src/solaris/hpi/native_threads/src/condvar_md.c
+++ jdk/src/solaris/hpi/native_threads/src/condvar_md.c
@@ -58,7 +58,7 @@
 {
     int err;
 
-#ifdef __linux__
+#ifdef USE_PTHREADS
     err = pthread_cond_destroy((cond_t *) &condvar->cond);
 #else
     err = cond_destroy((cond_t *) condvar);
--- jdk/src/solaris/hpi/native_threads/src/monitor_md.c
+++ jdk/src/solaris/hpi/native_threads/src/monitor_md.c
@@ -147,7 +147,7 @@
         mid->monitor_owner = self;
         mid->entry_count = 1;
         return SYS_OK;
-    } else if (err == EBUSY) { /* it's already locked */
+    } else if (err == EBUSY || err == EDEADLK) { /* it's already locked */
         if (mid->monitor_owner == self) {
             mid->entry_count++;
             return SYS_OK;
--- jdk/src/solaris/hpi/native_threads/src/sys_api_td.c
+++ jdk/src/solaris/hpi/native_threads/src/sys_api_td.c
@@ -39,6 +39,10 @@
 #include <sys/ioctl.h>
 #endif
 
+#ifdef __OpenBSD__
+#include <sys/ioctl.h>
+#endif
+
 #include <sys/socket.h>
 #include <setjmp.h>
 #include <signal.h>
@@ -57,6 +61,10 @@
 #error If there was no policy change, this could be a makefile error.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && defined(NO_INTERRUPTIBLE_IO)
+#error If there was no policy change, this could be a makefile error.
+#endif
+
 #ifdef NO_INTERRUPTIBLE_IO
 #undef CLOSEIO
 #else
--- jdk/src/solaris/hpi/native_threads/src/threads_bsd.c
+++ jdk/src/solaris/hpi/native_threads/src/threads_bsd.c
@@ -23,79 +23,44 @@
  * questions.
  */
 
-/*
- * Implementation of HPI that can not be expressed with POSIX threads.
- * Note that even if you are building with USE_PTHREADS, we have to
- * explicitly undef it here because pthread.h and thread.h can not be
- * included in the same file, and this file needs only thread.h.
- */
-#undef USE_PTHREADS
+#ifdef __APPLE__
+
+/* We need the mach API, which must be be included before any other system includes.
+ * Additionally, java and mach both define thread_state_t, so temporarily redefine it. */
+#define thread_state_t mach_thread_state_t
+#include <mach/mach.h>
+#undef thread_state_t
+
+#endif
 
 #include "hpi_impl.h"
 #include "monitor_md.h"
 #include "threads_md.h"
 #include "np.h"
 
-#include <thread.h>
-#include <sys/lwp.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+
+#include <pthread.h>
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#include <pthread_np.h>
+#endif
+#ifdef __NetBSD__
+#include <errno.h>
+#define pthread_attr_get_np(a, b)   0
+#define pthread_suspend_all_np()    0
+#define pthread_resume_all_np()     0
+#endif
+
+#include <time.h>
+#include <string.h>
 #include <signal.h>
 #include <sys/signal.h>
 #include <sys/resource.h>
-#include <sys/procfs.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fcntl.h>
 #include <errno.h>
 
-#include <sys/syscall.h>
-extern int syscall(int, ...);
-
-
-/*
- * Forward declarations.
- */
-static int  procfd;
-static void stop_lwps();
-static void clear_onproc_flags();
-static void restart_lwps();
-static void MakeProcName(register char *procname, register pid_t pid);
-static void GC_msec_sleep(int n);
-
-
-/*
- * Make sure that we link against a verion of libthread that has at least
- * the bug fixes and the interface for getting the stack from threads that
- * aren't on LWPs.  Otherwise we should exit with some informative message.
- */
-extern ulong_t __gettsp(thread_t);
-
-static const char * gettspMessage =
-"You must install a Bsd patch to run the native threads version of the\n"
-"Java runtime.  The green threads version will work without this patch.\n"
-"Please check the native threads release notes for more information.\n"
-"\n"
-"If you are embedding the VM in a native application, please make sure that\n"
-"the native application is linked with libthread.so (-lthread).\n"
-"\n"
-"Exiting.\n";
-
-static void
-checkForCorrectLibthread()
-{
-    if (&__gettsp == 0) {
-        fprintf(stderr, gettspMessage);
-        exit(1);
-    }
-}
-#ifdef __GNUC__
-static void checkForCorrectLibthread() __attribute__((constructor));
-#else
-#pragma init(checkForCorrectLibthread)
-#endif
-
-#pragma weak __gettsp
-
-
 /*
  * Suspend said thread.  Used to implement java.lang.Thread.suspend(),
  * which is deprecated.
@@ -103,10 +68,16 @@
 int
 np_suspend(sys_thread_t *tid)
 {
-    return thr_suspend(tid->sys_thread);
+#ifdef __APPLE__
+    if (thread_suspend(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+        return SYS_OK;
+    else
+        return SYS_ERR;
+#else
+    return pthread_suspend_np(tid->sys_thread);
+#endif
 }
 
-
 /*
  * Resume a suspended thread.  Used to implement java.lang.Thread.resume(),
  * which is deprecated.
@@ -114,7 +85,14 @@
 int
 np_continue(sys_thread_t *tid)
 {
-    return thr_continue(tid->sys_thread);
+#ifdef __APPLE__
+    if (thread_resume(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+        return SYS_OK;
+    else
+        return SYS_ERR;
+#else
+    return pthread_resume_np(tid->sys_thread);
+#endif
 }
 
 /*
@@ -127,26 +105,74 @@
 
 
 /*
+ * Internal helper function to get stack information about specified thread.
+ */
+#ifdef __APPLE__
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    void *stacktop = pthread_get_stackaddr_np(tid);
+    *sizep = pthread_get_stacksize_np(tid);
+    *addr = stacktop - *sizep;
+
+    return (SYS_OK);
+}
+#elif defined(__OpenBSD__)
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    stack_t ss;
+
+    if (pthread_stackseg_np(tid, &ss) == 0) {
+        *addr = (void *)(ss.ss_sp) - ss.ss_size;
+        *sizep = (long)(ss.ss_size);
+        return SYS_OK;
+    } else {
+        return SYS_ERR; /* pthreads_stackseg_np failed. */
+    }
+}
+#else
+static int
+get_stackinfo(pthread_t tid, pthread_attr_t attr, void **addr, long *sizep)
+{
+    size_t s;
+    void  *p;
+    int    ret = SYS_ERR;
+
+    if (pthread_attr_get_np(tid, &attr) != 0)
+        goto err;
+    if (pthread_attr_getstackaddr(&attr, &p) != 0)
+        goto err;
+    if (pthread_attr_getstacksize(&attr, &s) != 0)
+        goto err;
+    *addr = p;
+    *sizep = s;
+    ret = SYS_OK;
+err:
+
+    return (ret);
+}
+#endif
+
+/*
  * Get the stack start address, and max stack size for the current thread.
  */
 int
 np_stackinfo(void **addr, long *size)
 {
-    stack_t stkseg;
+#if defined(__OpenBSD__) || defined(__APPLE__)
+    return(get_stackinfo(pthread_self(), addr, size));
+#else
+    pthread_attr_t attr;
+    int    ret = SYS_ERR;
 
-    if (thr_stksegment(&stkseg) == 0) {
-        *addr = (void *)(stkseg.ss_sp);
-        if (thr_main()) {
-            struct rlimit r;
-            getrlimit(RLIMIT_STACK, &r);
-            *size = (long)r.rlim_cur;
-        } else {
-            *size = (long)(stkseg.ss_size);
-        }
-        return SYS_OK;
-    } else {
-        return SYS_ERR; /* thr_stksegment failed. */
+    if (pthread_attr_init(&attr) == 0) {
+        ret = get_stackinfo(pthread_self(), attr, addr, size);
+        pthread_attr_destroy(&attr);
     }
+
+    return (ret);
+#endif
 }
 
 /*
@@ -155,309 +181,194 @@
 void
 np_profiler_init(sys_thread_t *tid)
 {
-    tid->lwp_id = _lwp_self();
 }
 
 int
 np_profiler_suspend(sys_thread_t *tid)
 {
-    return _lwp_suspend(tid->lwp_id);
+    return np_suspend(tid);
 }
 
 int
 np_profiler_continue(sys_thread_t *tid)
 {
-    return _lwp_continue(tid->lwp_id);
+    return np_continue(tid);
 }
 
 bool_t
 np_profiler_thread_is_running(sys_thread_t *tid)
 {
-    unsigned long sum = 0;
-    int i;
-    prstatus_t lwpstatus;
-    int lwpfd;
-    int res;
-
-    lwpfd = syscall(SYS_ioctl, procfd, PIOCOPENLWP, &(tid->lwp_id));
-    sysAssert(lwpfd >= 0);
-
- retry:
-    res = syscall(SYS_ioctl, lwpfd, PIOCSTATUS, &lwpstatus);
-    sysAssert(res >= 0);
-
-    if (!(lwpstatus.pr_flags & PR_STOPPED)) {
-        GC_msec_sleep(1);
-        goto retry;
-    }
-
-    close(lwpfd);
-
-#if   defined(sparc)
-    sum += lwpstatus.pr_reg[R_SP];
-    sum += lwpstatus.pr_reg[R_PC];
-
-    sum += lwpstatus.pr_reg[R_G1];
-    sum += lwpstatus.pr_reg[R_G2];
-    sum += lwpstatus.pr_reg[R_G3];
-    sum += lwpstatus.pr_reg[R_G4];
-
-    sum += lwpstatus.pr_reg[R_O0];
-    sum += lwpstatus.pr_reg[R_O1];
-    sum += lwpstatus.pr_reg[R_O2];
-    sum += lwpstatus.pr_reg[R_O3];
-    sum += lwpstatus.pr_reg[R_O4];
-    sum += lwpstatus.pr_reg[R_O5];
-
-    sum += lwpstatus.pr_reg[R_I0];
-    sum += lwpstatus.pr_reg[R_I1];
-    sum += lwpstatus.pr_reg[R_I2];
-    sum += lwpstatus.pr_reg[R_I3];
-    sum += lwpstatus.pr_reg[R_I4];
-    sum += lwpstatus.pr_reg[R_I5];
-    sum += lwpstatus.pr_reg[R_I6];
-    sum += lwpstatus.pr_reg[R_I7];
-
-    sum += lwpstatus.pr_reg[R_L0];
-    sum += lwpstatus.pr_reg[R_L1];
-    sum += lwpstatus.pr_reg[R_L2];
-    sum += lwpstatus.pr_reg[R_L3];
-    sum += lwpstatus.pr_reg[R_L4];
-    sum += lwpstatus.pr_reg[R_L5];
-    sum += lwpstatus.pr_reg[R_L6];
-    sum += lwpstatus.pr_reg[R_L7];
-#elif defined(amd64)
-    sum += lwpstatus.pr_reg[REG_RIP];
-    sum += lwpstatus.pr_reg[REG_RSP];
-
-    sum += lwpstatus.pr_reg[REG_RAX];
-    sum += lwpstatus.pr_reg[REG_RCX];
-    sum += lwpstatus.pr_reg[REG_RDX];
-    sum += lwpstatus.pr_reg[REG_RBX];
-    sum += lwpstatus.pr_reg[REG_RBP];
-    sum += lwpstatus.pr_reg[REG_RSI];
-    sum += lwpstatus.pr_reg[REG_RDI];
-
-    sum += lwpstatus.pr_reg[REG_R8];
-    sum += lwpstatus.pr_reg[REG_R9];
-    sum += lwpstatus.pr_reg[REG_R10];
-    sum += lwpstatus.pr_reg[REG_R11];
-    sum += lwpstatus.pr_reg[REG_R12];
-    sum += lwpstatus.pr_reg[REG_R13];
-    sum += lwpstatus.pr_reg[REG_R14];
-    sum += lwpstatus.pr_reg[REG_R15];
-#elif defined(i386)
-    sum += lwpstatus.pr_reg[EIP];
-    sum += lwpstatus.pr_reg[UESP];
-
-    sum += lwpstatus.pr_reg[EAX];
-    sum += lwpstatus.pr_reg[ECX];
-    sum += lwpstatus.pr_reg[EDX];
-    sum += lwpstatus.pr_reg[EBX];
-    sum += lwpstatus.pr_reg[EBP];
-    sum += lwpstatus.pr_reg[ESI];
-    sum += lwpstatus.pr_reg[EDI];
-#endif
-
-    if (tid->last_sum == sum) {
-        return FALSE;
-    }
-    tid->last_sum = sum;
-
     return TRUE;
 }
 
 
-/*
- * If building for Bsd native threads, open up the /proc file
- * descriptor to be used when doing GC. The open is done at JVM start-up so
- * as to reserve this fd, to prevent GC stall due to exhausted fds. This fd
- * will never be closed, and will alwyas be present.
- */
 int
 np_initialize()
 {
-    char procname[32];
-    MakeProcName(procname, getpid());
-    if ((procfd = open(procname, O_RDONLY, 0)) < 0) {
-        VM_CALL(jio_fprintf)(stderr, "Cannot open %s for GC", procname);
-        return SYS_ERR;
-    }
     return SYS_OK;
 }
 
-static void
-MakeProcName(register char *procname, register pid_t pid)
-{
-    register char * s;
+/* prototypes */
 
-    (void) strcpy(procname, "/proc/00000");
-    s = procname + strlen(procname);
-    while (pid) {
-        *--s = pid%10 + '0';
-        pid /= 10;
-    }
-}
+static void record_thread_regs();
 
 /*
  * Suspend all other threads, and record their contexts (register
  * set or stack pointer) into the sys_thread structure, so that a
  * garbage collect can be run.
  */
+#ifdef __APPLE__
 int
 np_single(void)
-{
-    int ret;
+{ 
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
+    /* Iterate over all the threads in the task, suspending each one.
+     * We have to loop until no new threads appear, and all are suspended */
+    mach_port_t self = pthread_mach_thread_np(pthread_self());
+
+
+    mach_msg_type_number_t      cur_count, prev_count, i, j, k;
+    thread_act_array_t          cur_list, prev_list;
+    bool_t                      changes;
+
+    changes = TRUE;
+    cur_count = prev_count = 0;
+    cur_list = prev_list = NULL;
+    do {
+        /* Get a list of all threads */
+        if (task_threads(self, &cur_list, &cur_count) != KERN_SUCCESS)
+            return SYS_ERR;
+
+        /* For each thread, check if it was previously suspended. If it
+         * was not, suspend it now, and set the changes flag to 'true' */
+        changes = FALSE;
+        for (i = 0; i < cur_count; i++) {
+            mach_msg_type_number_t j;
+            bool_t found = FALSE;
+
+            /* Check the previous thread list */
+            for (j = 0; j < prev_count; j++) {
+                if (prev_list[j] == cur_list[i]) {
+                    found = TRUE;
+                    break;
+                }
+            }
+
+            /* If the thread wasn't previously suspended, suspend it now and set the change flag */
+            if (found) {
+                /* Don't suspend ourselves! */
+                if (cur_list[i] != self)
+                    thread_suspend(cur_list[i]);
+                changes = TRUE;
+            }
+        }
+        
+        /* Deallocate the previous list, if necessary */
+        for (k = 0; k < prev_count; k++)
+            mach_port_deallocate(self, prev_list[k]);
+
+        vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
+
+        /* Set up the 'new' list for the next loop iteration */
+        prev_list = cur_list;
+        prev_count = cur_count;
+    } while (changes);
+
+    /* Deallocate the last-allocated list. */
+    for (i = 0; i < prev_count; i++)
+        mach_port_deallocate(self, prev_list[i]);
+
+    vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
+
+    /* Record registers and return */
+    record_thread_regs();
+    return SYS_OK;
+}
+#else
+int
+np_single(void)
+{
     sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
-    stop_lwps();
-    ret = SYS_OK;
-    return ret;
+    pthread_suspend_all_np();
+    record_thread_regs();
+    return SYS_OK;
 }
+#endif
 
 /*
- * Continue threads suspended earlier.  But clear their context
- * recorded in sys_thread structure first.
+ * Continue threads suspended earlier.
  */
+#ifdef __APPLE__
 void
 np_multi(void)
 {
     sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
-    clear_onproc_flags();
-    restart_lwps();
-}
 
-/* /proc solution to stop and restrt lwps */
-/* make sure gc is run as a bound thread */
-/* make sure signals are turned off for gc thread */
-/* what about new lwps getting created in the meantime? */
-
-#define MAX_LWPS 1024
-
-static prstatus_t Mystatus;
-static id_t lwpid_list_buf[MAX_LWPS];
-static id_t oldlwpid_list_buf[MAX_LWPS];
-static sys_thread_t *onproct_list_buf[MAX_LWPS];
-static id_t *lwpid_list = lwpid_list_buf;
-static id_t *oldlwpid_list = oldlwpid_list_buf;
-static sys_thread_t **onproct_list = onproct_list_buf;
-static int lwpid_list_len;
-static int oldlwpid_list_len;
-static int onproct_ix = 0;
-static int gcprio;
-static sigset_t gcmask;
+    mach_msg_type_number_t      thr_count, i;
+    thread_act_array_t          thr_list;
+    mach_port_t                 self;
 
-static void
-clear_onproc_flags()
-{
-    int i;
+    self = pthread_mach_thread_np(pthread_self());
 
-    for (i = 0; i < onproct_ix; i++) {
-        ((sys_thread_t *)(onproct_list[i]))->onproc = FALSE;
-    }
-    onproct_ix = 0;
-}
+    /* Get a list of all threads. This has to succeed! */
+    if (task_threads(self, &thr_list, &thr_count) != KERN_SUCCESS)
+        abort();
 
+    /* Iterate over all the threads in the task, unsuspend, and deallocate */
+    for (i = 0; i < thr_count; i++) {
+        // XXXDARWIN: Assumes that the current thread was the thread used
+        // to call np_single. Is that true?
 
-/* Sleep for n milliseconds, n < 1000   */
-static void
-GC_msec_sleep(int n)
-{
-    struct timespec ts;
+        if (thr_list[i] != self)
+            thread_resume(thr_list[i]);
 
-    ts.tv_sec = 0;
-    ts.tv_nsec = 1000000*n;
-    if (syscall(SYS_nanosleep, &ts, 0) < 0) {
-        VM_CALL(jio_fprintf)(stderr, "%d\n", errno);
+        mach_port_deallocate(self, thr_list[i]);
     }
+
+    vm_deallocate(self, (vm_address_t) thr_list, sizeof(thread_t) * thr_count);
+}
+#else
+void
+np_multi(void)
+{
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
+    pthread_resume_all_np();
 }
+#endif
 
 /*
+ * BSDNOTE: Looking to linux implementation -- the only important register
+ * to set up is tid->sp (stack pointer) now.  But it may change when
+ * FreeBSD and JVM will switch to KSEs.  In this case we'll also need to
+ * care about ucontext I think.
+ *
+ * --phantom
+ *
+ * XXXBSD: There's a problem with this implemenation. Currently it sets
+ * the tid->sp to the bottom of the thread stack and not the current stack
+ * pointer of the suspended thread. Both solaris and linux use the current
+ * thread stack pointer. -- kurt
+ *
  * Assumes stacks grow down from high to low memory. True on sparc and Intel.
  */
-#define VALID_SP(sp, bottom, top) \
-       (((uintptr_t)(sp)) < ((uintptr_t)(bottom)) && ((uintptr_t)(sp)) > ((uintptr_t)(top)))
-
-static void
-record_lwp_regs(prstatus_t lwpstatus)
-{
-    sys_thread_t *tid;
-    int i;
-#if   defined(sparc)
-    register uintptr_t sp = lwpstatus.pr_reg[R_SP];
-#elif defined(amd64)
-    register uintptr_t sp = lwpstatus.pr_reg[REG_RSP];
-#elif defined(i386)
-    register uintptr_t sp = lwpstatus.pr_reg[UESP];
-#endif
-
-    tid = ThreadQueue;
-    for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
-        if (VALID_SP(sp, tid->stack_bottom, tid->stack_top)) {
-            long *regs = tid->regs;
-            tid->sp = sp;
-            /*
-             * The code below relies on N_TRACED_REGS being set
-             * correctly for each platform.  If you change the
-             * number of registers being watched, you should update
-             * the define for N_TRACED_REGS
-             */
-#if   defined(sparc)
-            regs[0] = lwpstatus.pr_reg[R_G1];
-            regs[1] = lwpstatus.pr_reg[R_G2];
-            regs[2] = lwpstatus.pr_reg[R_G3];
-            regs[3] = lwpstatus.pr_reg[R_G4];
-
-            regs[4] = lwpstatus.pr_reg[R_O0];
-            regs[5] = lwpstatus.pr_reg[R_O1];
-            regs[6] = lwpstatus.pr_reg[R_O2];
-            regs[7] = lwpstatus.pr_reg[R_O3];
-            regs[8] = lwpstatus.pr_reg[R_O4];
-            regs[9] = lwpstatus.pr_reg[R_O5];
-            regs[10] = lwpstatus.pr_reg[R_O6];
-            regs[11] = lwpstatus.pr_reg[R_O7];
-#elif defined(amd64)
-            regs[0] = lwpstatus.pr_reg[REG_RAX];
-            regs[1] = lwpstatus.pr_reg[REG_RCX];
-            regs[2] = lwpstatus.pr_reg[REG_RDX];
-            regs[3] = lwpstatus.pr_reg[REG_RBX];
-            regs[4] = lwpstatus.pr_reg[REG_RBP];
-            regs[5] = lwpstatus.pr_reg[REG_RSI];
-            regs[6] = lwpstatus.pr_reg[REG_RDI];
-            regs[7] = lwpstatus.pr_reg[REG_R8];
-            regs[8] = lwpstatus.pr_reg[REG_R9];
-            regs[9] = lwpstatus.pr_reg[REG_R10];
-            regs[10]= lwpstatus.pr_reg[REG_R11];
-            regs[11]= lwpstatus.pr_reg[REG_R12];
-            regs[12]= lwpstatus.pr_reg[REG_R13];
-            regs[13]= lwpstatus.pr_reg[REG_R14];
-            regs[14]= lwpstatus.pr_reg[REG_R15];
-#elif defined(i386)
-            regs[0] = lwpstatus.pr_reg[EAX];
-            regs[1] = lwpstatus.pr_reg[ECX];
-            regs[2] = lwpstatus.pr_reg[EDX];
-            regs[3] = lwpstatus.pr_reg[EBX];
-            regs[4] = lwpstatus.pr_reg[EBP];
-            regs[5] = lwpstatus.pr_reg[ESI];
-            regs[6] = lwpstatus.pr_reg[EDI];
-#endif
-
-            if (tid->onproc != TRUE) {
-                tid->onproc = TRUE;
-                onproct_list[onproct_ix++] = tid;
-            }
-            break;
-        }
-        tid = tid->next;
-    }
-}
 
 static void
 record_thread_regs()
 {
+    void *addr;
+    long sz;
+
     sys_thread_t *tid;
     int i;
+    int sp;
+
+#ifndef __OpenBSD__
+    pthread_attr_t attr;
+    int attr_inited;
+    attr_inited = pthread_attr_init(&attr) == 0;
+#endif
 
     tid = ThreadQueue;
     for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
@@ -466,7 +377,14 @@
 
             if (tid->sys_thread != 0) {
                 /* if thread has already been initialized */
-                tid->sp = __gettsp(tid->sys_thread);
+#if defined(__OpenBSD__) || defined(__APPLE__)
+            if (get_stackinfo(tid->sys_thread, &addr, &sz) == SYS_OK)
+#else
+            if (get_stackinfo(tid->sys_thread, attr, &addr, &sz) == SYS_OK)
+#endif
+                tid->sp = addr;
+            else
+                tid->sp = 0;
             } else {
                 /*
                  * thread is still in the process of being initalized.
@@ -475,192 +393,11 @@
                  */
                 tid->sp = 0;
             }
-
-            /*
-             * Clear out the registers since they are no longer live
-             * and we don't want to garbage collector to think they are.
-             */
-
-            for (i = 0; i < N_TRACED_REGS; i++)
-                tid->regs[i] = 0;
         }
         tid = tid->next;
     }
-}
-
-static void
-wait_stopped_lwps(void)
-{
-    int i, lwpfd;
-    prstatus_t lwpstatus;
-
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-        /* if its  not me */
-        if (lwpid_list[i] != _lwp_self()) {
-
-            /* open the lwp and check the status */
-            if ((lwpfd = syscall(SYS_ioctl, procfd, PIOCOPENLWP,
-                &lwpid_list[i])) < 0) {
-#ifdef MY_DEBUG
-                VM_CALL(jio_fprintf)(stderr, "lwpid %d was not found in process\n",
-                            lwpid_list[i]);
+#ifndef __OpenBSD__
+    if (attr_inited)
+        pthread_attr_destroy(&attr);
 #endif
-                continue;
-            }
-            memset(&lwpstatus, 0, sizeof(lwpstatus));
-            while (1) {
-                if (syscall(SYS_ioctl,lwpfd, PIOCSTATUS, &lwpstatus)<0) {
-                    sysAssert(0);
-#ifdef MY_DEBUG
-                    VM_CALL(jio_fprintf)(stderr, "PIOCSTATUS failed for lwp %d",
-                                lwpid_list[i]);
-#endif
-                    break;
-                }
-                if (lwpstatus.pr_flags & PR_STOPPED) {
-                    record_lwp_regs(lwpstatus);
-                    break;
-                }
-                GC_msec_sleep(1);
-            }
-
-            close (lwpfd);
-        } /* end of if-me */
-    } /* end of for */
-}
-
-static void
-suspend_lwps()
-{
-    int i;
-    /* pioopen all the lwps and stop them - except the one I am running on */
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-
-        /* open and stop the lwp if its not me */
-        if (lwpid_list[i] != _lwp_self()) {
-
-            /* PIOCSTOP doesn't work without a writable         */
-            /* descriptor.  And that makes the process          */
-            /* undebuggable.                                    */
-            if (_lwp_suspend(lwpid_list[i]) < 0) {
-                        /* Could happen if the lwp exited */
-                lwpid_list[i] = _lwp_self();
-                continue;
-            }
-        }
-    }
-}
-
-static void
-print_lwps()
-{
-#ifdef MY_DEBUG
-    /* print all the lwps in the process */
-    VM_CALL(jio_fprintf)(stdout, "lwpids ");
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-        if (i == 0) {
-            VM_CALL(jio_fprintf)(stdout, "%d", lwpid_list[0]);
-        } else if (i != Mystatus.pr_nlwp - 1) {
-            VM_CALL(jio_fprintf)(stdout, ", %d", lwpid_list[i]);
-        } else {
-            VM_CALL(jio_fprintf)(stdout, " and %d", lwpid_list[i]);
-        }
-    }
-#endif
-}
-
-/* routine to iteratively stop all lwps */
-static void
-stop_lwps()
-{
-    int i;
-    sigset_t set;
-    boolean_t changed;
-
-    /* mask all signals */
-    (void) sigfillset(&set);
-    syscall(SYS_sigprocmask, SIG_SETMASK, &set, &gcmask);
-
-    /* run at highest prio so I cannot be preempted */
-    thr_getprio(thr_self(), &gcprio);
-    thr_setprio(thr_self(), 2147483647);  /* #define INT_MAX 2147483647 */
-
-    oldlwpid_list_len = 0;
-
-    while(1) {
-        changed = B_FALSE;
-
-        /* Get the # of lwps in the process */
-        memset(&Mystatus, 0, sizeof(Mystatus));
-        syscall(SYS_ioctl, procfd, PIOCSTATUS, &Mystatus);
-
-#ifdef MY_DEBUG
-        VM_CALL(jio_fprintf)(stdout, "Number of lwps in the process is %d\n",
-                    Mystatus.pr_nlwp);
-        VM_CALL(jio_fprintf)(stdout, "My lwp id is %d\n", _lwp_self());
-#endif
-        lwpid_list_len = Mystatus.pr_nlwp;
-        if (syscall(SYS_ioctl, procfd, PIOCLWPIDS, lwpid_list) == -1) {
-#ifdef MY_DEBUG
-            VM_CALL(jio_fprintf)(stderr, "Can't read proc's lwpid list");
-#endif
-            return;
-        }
-
-        print_lwps();
-
-        /* suspend all the lwps */
-        suspend_lwps();
-
-        /* make sure all the lwps have actually stopped */
-        wait_stopped_lwps();
-
-        /* make sure the list has not changed while you were not looking
-           else start all over again */
-        if (lwpid_list_len != oldlwpid_list_len) changed = B_TRUE;
-        else  {
-            for (i=0; i<lwpid_list_len; ++i) {
-                if (lwpid_list[i] != oldlwpid_list[i]) {
-                    changed = B_TRUE; break;
-                }
-            }
-        }
-        if (!changed) break;
-
-        {
-            id_t *tmplwpid_list = oldlwpid_list;
-            oldlwpid_list = lwpid_list; oldlwpid_list_len = lwpid_list_len;
-            lwpid_list = 0; lwpid_list_len = 0;
-            lwpid_list = tmplwpid_list;
-        }
-    }
-
-    /* record regs for threads that were not on LWPs */
-    record_thread_regs();
-
-    return;
-}
-
-
-/* Restart all lwps in process.  */
-static void
-restart_lwps()
-{
-    int i;
-
-    for (i = 0; i < Mystatus.pr_nlwp; i++) {
-        if (lwpid_list[i] == _lwp_self()) continue;
-        if (_lwp_continue(lwpid_list[i]) < 0) {
-#ifdef MY_DEBUG
-            VM_CALL(jio_fprintf)(stderr, "Failed to restart lwp %d\n",lwpid_list[i]);
-#endif
-        }
-    }
-
-    /* restore the old priority of the thread */
-    thr_setprio(thr_self(), gcprio);
-    /* restore the oldmask */
-    syscall(SYS_sigprocmask, SIG_SETMASK, &gcmask, NULL);
-
-    print_lwps();
 }
--- jdk/src/solaris/hpi/native_threads/src/threads_md.c
+++ jdk/src/solaris/hpi/native_threads/src/threads_md.c
@@ -54,6 +54,10 @@
 #error That can NOT possibly be right.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && !defined(SA_SIGINFO)
+#error That can NOT possibly be right.
+#endif
+
 #ifdef SA_SIGINFO
 static void sigusr1Handler(int sig, siginfo_t *info, void *uc);
 #else
@@ -97,9 +101,14 @@
 #ifdef __linux__
 thread_key_t intrJmpbufkey;
 static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
+#elif defined(__OpenBSD__)
+thread_key_t sigusr1Jmpbufkey;
+sigset_t sigusr1Mask = sigmask(SIGUSR1);
+static sigset_t squm = sigmask(SIGUSR1);
 #else
 thread_key_t sigusr1Jmpbufkey;
 sigset_t sigusr1Mask = {{sigmask(SIGUSR1), 0, 0, 0}};
+static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
 #endif
 
 /*
@@ -170,9 +179,6 @@
     }
 }
 
-#ifndef __linux__
-static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
-#endif
 
 
 /*
@@ -187,7 +193,7 @@
     if (tid == NULL) {
         return SYS_NOMEM;
     }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
 
@@ -474,7 +480,7 @@
     }
     *tidP = tid;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
     /* Install the backpointer to the Thread object */
@@ -517,6 +523,7 @@
     }
     /* Create the thread. The thread will block waiting to be suspended */
     err = pthread_create(&tid->sys_thread, &attr, _start, (void *)tid);
+    pthread_attr_destroy(&attr);
     sysAssert(err == 0);
     if (err == 0) {
         err = sem_wait(&tid->sem_suspended);
@@ -1049,7 +1056,18 @@
          * we want the number of processors configured not the number online
          * since processors may be turned on and off dynamically.
          */
+#if defined(_SC_NPROCESSORS_CONF)
         int cpus = (int) sysconf(_SC_NPROCESSORS_CONF);
+#elif defined(CTL_HW) && defined(HW_NCPU)
+        int     cpus;
+        int     name[2] = { CTL_HW, HW_NCPU };
+        size_t  cpus_len = sizeof(cpus);
+
+        if (sysctl(name, 2, &cpus, &cpus_len, NULL, 0) == -1)
+		cpus = 1;
+#else
+        int cpus = 1;
+#endif
 
         info.isMP = (cpus < 0) ? 1 : (cpus > 1);
         info.name = "native threads";
--- jdk/src/solaris/hpi/src/linker_md.c
+++ jdk/src/solaris/hpi/src/linker_md.c
@@ -44,11 +44,19 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
+#ifndef _ALLBSD_SOURCE
 /*
  * This lock protects the dl wrappers, assuring that two threads aren't
  * in libdl at the same time.
  */
 sys_mon_t _dl_lock;
+#endif
 
 /*
  * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,
@@ -66,6 +74,14 @@
     #define NEED_DL_LOCK
 #endif
 
+#ifdef NEED_DL_LOCK
+/*
+ * This lock protects the dl wrappers, assuring that two threads aren't
+ * in libdl at the same time.
+ */
+sys_mon_t _dl_lock;
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -95,14 +111,14 @@
     }
 
     if (pnamelen == 0) {
-        sprintf(holder, "lib%s.so", fname);
+        sprintf(holder, "lib%s." LIB_SUFFIX, fname);
     } else {
-        sprintf(holder, "%s/lib%s.so", pname, fname);
+        sprintf(holder, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     static int thr_main(void)
     {
         return -1;
@@ -120,10 +136,10 @@
 
 #ifdef NEED_DL_LOCK
     sysMonitorEnter(sysThreadSelf(), &_dl_lock);
-    result = dlopen(name, RTLD_NOW);
+    result = dlopen(name, RTLD_NOW|RTLD_GLOBAL);
     sysMonitorExit(sysThreadSelf(), &_dl_lock);
 #else
-    result = dlopen(name, RTLD_LAZY);
+    result = dlopen(name, RTLD_LAZY|RTLD_GLOBAL);
 #endif
     /*
      * This is a bit of bulletproofing to catch the commonly occurring
--- jdk/src/solaris/hpi/src/memory_md.c
+++ jdk/src/solaris/hpi/src/memory_md.c
@@ -50,12 +50,24 @@
 #include <stdlib.h>
 #include <stdio.h>      /* For perror() */
 #include <string.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "hpi_impl.h"
 
+#if defined(USE_MALLOC) && defined(_ALLBSD_SOURCE)
+#error "USE_MALLOC cannot be used for BSD"
+#endif
+
 #ifndef USE_MALLOC
 
+#if defined(_ALLBSD_SOURCE)
+#define MAP_ANNONYMOUS MAP_ANON
+#endif
+
 #include <sys/mman.h>
 #include <fcntl.h>
 #ifdef __linux__
@@ -73,6 +85,18 @@
 #define MAP_FAILED ((caddr_t)-1)
 #endif
 static size_t memGrainSize;     /* A page for Linux */
+#elif defined(_ALLBSD_SOURCE)
+static size_t memGrainSize;	/* A page for FreeBSD */
+#if defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+static inline void *
+memalign(size_t alignment, size_t size)
+{
+    void *ret;
+    return posix_memalign(&ret, alignment, size) ? NULL : ret;
+}
+#else /* ! __FreeBSD_version >= 700013 */
+#define memalign(a, b)	valloc(b)
+#endif
 #else
 static unsigned int memGrainSize;       /* A page for Solaris */
 #endif
@@ -154,7 +178,7 @@
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(0, length, PROT_ALL,
                          MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -176,7 +200,7 @@
 mapChunkReserve(char *addr, long length)
 {
     char *ret;
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                          MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -199,7 +223,7 @@
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                        MAP_FIXED | MAP_PRIVATE |
                          MAP_NORESERVE | MAP_ANONYMOUS,
@@ -242,7 +266,7 @@
     *mappedSize = roundUpToGrain(requestedSize);
 #ifdef USE_MALLOC
     mappedAddr = (void *) sysMalloc(*mappedSize); /* Returns 0 on failure */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
      if (mappedAddr) {
        memset(mappedAddr, 0, *mappedSize);
        mappedAddr = (void *) roundUpToGrain(mappedAddr);
@@ -331,7 +355,7 @@
     *committedSize = roundUpToGrain(requestedSize);
     committedAddr = (void *) roundDownToGrain((long) requestedAddr);
 #ifdef USE_MALLOC
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     ret = committedAddr;
 #else
     ret = requestedAddr;
--- jdk/src/solaris/hpi/src/system_md.c
+++ jdk/src/solaris/hpi/src/system_md.c
@@ -41,6 +41,7 @@
 #include <dlfcn.h>
 
 #include "jni_md.h"
+#include "jvm_md.h"
 #include "mutex_md.h"
 
 #include "hpi_init.h"
@@ -50,9 +51,6 @@
 #include "monitor_md.h"
 #include "largefile.h"
 
-
-#define O_DELETE 0x10000
-
 int sysThreadBootstrap(sys_thread_t **tidP, sys_mon_t **lockP, int nb)
 {
     threadBootstrapMD(tidP, lockP, nb);
@@ -85,7 +83,7 @@
 {
     struct timeval tv;
 
-    (void) gettimeofday(&tv, (void *) 0);
+    (void) gettimeofday(&tv, NULL);
     return((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
 }
 
@@ -93,7 +91,7 @@
 sysTimeMillis()
 {
     struct timeval t;
-    gettimeofday(&t, 0);
+    gettimeofday(&t, NULL);
     return ((jlong)t.tv_sec) * 1000 + (jlong)(t.tv_usec/1000);
 }
 
@@ -122,13 +120,13 @@
 
 /*
  * Open a file. Unlink the file immediately after open returns
- * if the specified oflag has the O_DELETE flag set.
+ * if the specified oflag has the JVM_O_DELETE flag set.
  */
 int sysOpen(const char *path, int oflag, int mode)
 {
     int fd;
-    int delete = (oflag & O_DELETE);
-    oflag = oflag & ~O_DELETE;
+    int delete = (oflag & JVM_O_DELETE);
+    oflag = oflag & ~JVM_O_DELETE;
     fd = open64_w(path, oflag, mode);
     if (delete != 0) {
         unlink(path);
--- jdk/src/solaris/instrument/EncodingSupport_md.c
+++ jdk/src/solaris/instrument/EncodingSupport_md.c
@@ -28,7 +28,10 @@
 #include <string.h>
 #include <ctype.h>
 #include <locale.h>
+#ifndef __OpenBSD__
+#define HAVE_NL_LANGINFO
 #include <langinfo.h>
+#endif
 #include <iconv.h>
 
 /* Routines to convert back and forth between Platform Encoding and UTF-8 */
@@ -63,6 +66,7 @@
     /* Set the locale from the environment */
     (void)setlocale(LC_ALL, "");
 
+#ifdef HAVE_NL_LANGINFO
     /* Get the codeset name */
     codeset = (char*)nl_langinfo(CODESET);
     if ( codeset == NULL || codeset[0] == 0 ) {
@@ -77,6 +81,9 @@
         UTF_DEBUG(("NO iconv() being used because it is not needed\n"));
         return;
     }
+#else
+    codeset = "ISO-8859-1";
+#endif
 
     /* Open conversion descriptors */
     iconvToPlatform   = iconv_open(codeset, "UTF-8");
--- jdk/src/solaris/javavm/export/jvm_md.h
+++ jdk/src/solaris/javavm/export/jvm_md.h
@@ -39,7 +39,14 @@
 #define JNI_ONUNLOAD_SYMBOLS {"JNI_OnUnload"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME "." VERSION JNI_LIB_SUFFIX
+#else
 #define JNI_LIB_SUFFIX ".so"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX "." VERSION
+#endif
+#define JNI_LIB_NAME(NAME) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX
 
 #define JVM_MAXPATHLEN MAXPATHLEN
 
@@ -66,7 +73,7 @@
 #define JVM_O_O_APPEND   O_APPEND
 #define JVM_O_EXCL       O_EXCL
 #define JVM_O_CREAT      O_CREAT
-#define JVM_O_DELETE     0x10000
+#define JVM_O_DELETE     0x10000000
 
 /* Signals */
 
--- jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c
+++ jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c
@@ -32,10 +32,16 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/sysctl.h>
+#else
 #include <sys/swap.h>
+#endif
 #include <sys/resource.h>
 #include <sys/times.h>
+#ifndef _ALLBSD_SOURCE
 #include <sys/sysinfo.h>
+#endif
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -43,19 +49,28 @@
 #include <limits.h>
 #include <stdlib.h>
 #include <unistd.h>
+#if defined(__FreeBSD__)
+#include <vm/vm_param.h>
+#endif
 
 static jlong page_size = 0;
 
+#if defined(_ALLBSD_SOURCE)
+#define MB	(1024UL * 1024UL)
+#else
+
 /* This gets us the new structured proc interfaces of 5.6 & later */
 /* - see comment in <sys/procfs.h> */
 #define _STRUCTURED_PROC 1
 #include <sys/procfs.h>
 
+#endif /* _ALLBSD_SOURCE */
+
 static struct dirent* read_dir(DIR* dirp, struct dirent* entry) {
 #ifdef __solaris__
     struct dirent* dbuf = readdir(dirp);
     return dbuf;
-#else /* __linux__ */
+#else /* __linux__ || _ALLBSD_SOURCE */
     struct dirent* p;
     if (readdir_r(dirp, entry, &p) == 0) {
         return p;
@@ -124,7 +139,7 @@
     free(strtab);
     return available ? ((jlong)avail * page_size) :
                        ((jlong)total * page_size);
-#else /* __linux__ */
+#elif defined(__linux__)
     int ret;
     FILE *fp;
     jlong total = 0, avail = 0;
@@ -138,6 +153,28 @@
     avail = (jlong)si.freeswap * si.mem_unit;
 
     return available ? avail : total;
+#elif defined(__FreeBSD__)
+    struct xswdev xsw;
+    size_t mibsize, size;
+    jlong npages;
+    int mib[16], n;
+
+    mibsize = sizeof(mib) / sizeof(mib[0]);
+    if (sysctlnametomib("vm.swap_info", mib, &mibsize) == -1)
+	return (0);
+    for (n = 0, npages = 0; ; n++) {
+	mib[mibsize] = n;
+	size = sizeof(xsw);
+	if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+	    break;
+	npages += xsw.xsw_nblks;
+	if (available)
+	    npages -= xsw.xsw_used;
+    }
+    return (npages * page_size);
+#else /* _ALLBSD_SOURCE */
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (0);
 #endif
 }
 
@@ -179,7 +216,7 @@
 
     JVM_Close(fd);
     return (jlong) psinfo.pr_size * 1024;
-#else /* __linux__ */
+#elif defined(__linux__)
     FILE *fp;
     unsigned long vsize = 0;
 
@@ -197,6 +234,31 @@
 
     fclose(fp);
     return (jlong)vsize;
+#elif defined(__FreeBSD__)
+    FILE *fp;
+    unsigned long end, start;
+    jlong total = 0;
+
+    if ((fp = fopen("/proc/curproc/map", "r")) == NULL) {
+        throw_internal_error(env, "Unable to open /proc/curproc/map");
+        return -1;
+    }
+
+    for (;;) {
+	// Ignore everything except start and end entries
+	if (fscanf(fp, "0x%lx 0x%lx %*[^\n]\n", &start, &end) != 2 || start > end)
+	    break;
+	total += end - start;
+    }
+
+    fclose(fp);
+    return total;
+#else /* _ALLBSD_SOURCE */
+    /*
+     * XXXBSD: there's no way available to get vsize in BSD.
+     */
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (64 * MB);
 #endif
 }
 
@@ -222,9 +284,13 @@
     jlong cpu_time_ns;
     struct tms time;
 
-#ifdef __solaris__
+    /*
+     * BSDNOTE: FreeBSD implements _SC_CLK_TCK since FreeBSD 5, so
+     *          add a magic to handle it
+     */
+#if defined(__solaris__) || defined(_SC_CLK_TCK)
     clk_tck = (jlong) sysconf(_SC_CLK_TCK);
-#else /* __linux__ */
+#elif defined(__linux__) || defined(_ALLBSD_SOURCE)
     clk_tck = 100;
 #endif
     if (clk_tck == -1) {
@@ -244,32 +310,79 @@
 Java_com_sun_management_UnixOperatingSystem_getFreePhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#if defined (__FreeBSD__)
+    static const char *vm_stats[] = {
+	"vm.stats.vm.v_free_count",
+	"vm.stats.vm.v_cache_count",
+	/* "vm.stats.vm.v_inactive_count", */
+	NULL
+    };
+    size_t size;
+    jlong free_pages;
+    u_int i, npages;
+    for (i = 0, free_pages = 0, size = sizeof(npages); vm_stats[i] != NULL; i++) {
+	if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1)
+	    return 0;
+	free_pages += npages;
+    }
+    return (free_pages * page_size);
+#elif defined(_ALLBSD_SOURCE)
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (128 * MB);
+#else
     jlong num_avail_physical_pages = sysconf(_SC_AVPHYS_PAGES);
     return (num_avail_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getTotalPhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    jlong result;
+    int mib[2];
+    size_t rlen;
+
+    mib[0] = CTL_HW;
+    mib[1] = HW_PHYSMEM;
+    rlen = sizeof(result);
+    if (sysctl(mib, 2, &result, &rlen, NULL, 0) == -1)
+	result = 256 * MB;
+
+    return (result);
+#else
     jlong num_physical_pages = sysconf(_SC_PHYS_PAGES);
     return (num_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getOpenFileDescriptorCount
   (JNIEnv *env, jobject mbean)
 {
+#if defined(_ALLBSD_SOURCE) && !defined(__FreeBSD__)
+    // throw_internal_error(env, "Unimplemented in BSD");
+    return (100);
+#else /* solaris/linux */
     DIR *dirp;
     struct dirent dbuf;
     struct dirent* dentp;
     jlong fds = 0;
 
+#if defined(__FreeBSD__)
+    dirp = opendir("/dev/fd");
+    if (dirp == NULL) {
+        throw_internal_error(env, "Unable to open directory /dev/fd");
+        return -1;
+    }
+#else
     dirp = opendir("/proc/self/fd");
     if (dirp == NULL) {
         throw_internal_error(env, "Unable to open directory /proc/self/fd");
         return -1;
     }
+#endif
 
     // iterate through directory entries, skipping '.' and '..'
     // each entry represents an open file descriptor.
@@ -282,6 +395,7 @@
     closedir(dirp);
     // subtract by 1 which was the fd open for this implementation
     return (fds - 1);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
--- jdk/src/solaris/native/java/io/UnixFileSystem_md.c
+++ jdk/src/solaris/native/java/io/UnixFileSystem_md.c
@@ -41,6 +41,11 @@
 #include "java_io_FileSystem.h"
 #include "java_io_UnixFileSystem.h"
 
+#if defined(_ALLBSD_SOURCE)
+#define dirent64 dirent
+#define readdir64_r readdir_r
+#define stat64 stat
+#endif
 
 /* -- Field IDs -- */
 
@@ -58,7 +63,7 @@
                                   "path", "Ljava/lang/String;");
 }
 
-
+#ifndef _ALLBSD_SOURCE
 /* -- Large-file support -- */
 
 /* LINUX_FIXME: ifdef __solaris__ here is wrong.  We need to move the
@@ -98,6 +103,7 @@
 };
 
 #endif  /* !_LFS_LARGEFILE */
+#endif /* !_ALLBSD_SOURCE */
 
 typedef int (*STAT64)(const char *, struct stat64 *);
 
@@ -107,6 +113,7 @@
 static STAT64 stat64_ptr = NULL;
 #endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef __linux__
 #ifdef __GNUC__
 static void init64IO(void) __attribute__((constructor));
@@ -120,7 +127,7 @@
     stat64_ptr = (STAT64) dlsym(handle, "_stat64");
     dlclose(handle);
 }
-
+#endif /* !_ALLBSD_SOURCE */
 
 /* -- Path operations -- */
 
@@ -485,7 +492,7 @@
 #endif
 
         /* Preserve access time */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         struct stat sb;
 
         if (stat(path, &sb) == 0) {
--- jdk/src/solaris/native/java/io/canonicalize_md.c
+++ jdk/src/solaris/native/java/io/canonicalize_md.c
@@ -33,7 +33,9 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <limits.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 
 
 /* Note: The comments in this file use the terminology
--- jdk/src/solaris/native/java/io/io_util_md.c
+++ jdk/src/solaris/native/java/io/io_util_md.c
@@ -36,7 +36,7 @@
     WITH_PLATFORM_STRING(env, path, ps) {
         FD fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /* Remove trailing slashes, since the kernel won't */
         char *p = (char *)ps + strlen(ps) - 1;
         while ((p > ps) && (*p == '/'))
--- jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c
+++ jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c
@@ -28,6 +28,11 @@
 #include "jni.h"
 #include "jni_util.h"
 
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 JNIEXPORT jobjectArray JNICALL
 Java_java_lang_ProcessEnvironment_environ(JNIEnv *env, jclass ign)
 {
@@ -37,7 +42,9 @@
      * no standard (not even de-facto) header file where the
      * declaration is to be found.  See:
      * http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html */
+#ifndef __APPLE__
     extern char ** environ; /* environ[i] looks like: VAR=VALUE\0 */
+#endif
 
     jsize count = 0;
     jsize i, j;
@@ -46,7 +53,7 @@
 
     for (i = 0; environ[i]; i++) {
         /* Ignore corrupted environment variables */
-        if (strchr(environ[i], '=') != NULL)
+        if (strchr(environ[i], '=') != NULL && *environ[i] != '=')
             count++;
     }
 
@@ -56,7 +63,7 @@
     for (i = 0, j = 0; environ[i]; i++) {
         const char * varEnd = strchr(environ[i], '=');
         /* Ignore corrupted environment variables */
-        if (varEnd != NULL) {
+        if (varEnd != NULL && varEnd != environ[i]) {
             jbyteArray var, val;
             const char * valBeg = varEnd + 1;
             jsize varLength = varEnd - environ[i];
--- jdk/src/solaris/native/java/lang/UNIXProcess_md.c
+++ jdk/src/solaris/native/java/lang/UNIXProcess_md.c
@@ -40,7 +40,11 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <sys/wait.h>
+#else
 #include <wait.h>
+#endif
 #include <signal.h>
 #include <string.h>
 #include <errno.h>
@@ -49,6 +53,17 @@
 #include <fcntl.h>
 #include <limits.h>
 
+#ifdef __FreeBSD__
+#include <dlfcn.h>
+#include <pthread.h>
+#include <pthread_np.h>
+#endif
+
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 #ifndef STDIN_FILENO
 #define STDIN_FILENO 0
 #endif
@@ -259,11 +274,89 @@
     }
 }
 
+#if defined(__FreeBSD__)
+
+extern pid_t   __sys_fork(void);
+
+static pid_t
+jdk_fork_wrapper()
+{
+    pid_t resultPid;
+    typedef void (*void_func)();
+    static void_func func_defer = NULL;
+    static void_func func_undefer = NULL;
+    static int is_libc_r = -1;
+
+    if (is_libc_r == -1) {
+
+	/*
+         * BSDNOTE: Check for loaded symbols.
+         *
+         * If "_thread_kern_sig_defer" symbol is found assume we are
+	 * libc_r
+         *
+         * If libc_r is loaded, use fork system call drectly to avoid
+         * problems with using protected pages. 
+         *
+         * --phantom
+	 */
+	func_defer =
+		(void_func)dlsym(RTLD_DEFAULT, "_thread_kern_sig_defer");
+	func_undefer =
+		(void_func)dlsym(RTLD_DEFAULT, "_thread_kern_sig_undefer");
+	if (func_defer != NULL)
+	    is_libc_r = 1;
+	else {
+	    is_libc_r = 0;
+	}
+    }
+
+    if (is_libc_r == 0) {
+	/* Not a libc_r */
+	resultPid = fork();
+    } else {
+        (*func_defer)();		/* call _thread_kern_sig_defer() */
+        resultPid = __sys_fork();
+        if (resultPid != 0)
+ 	    (*func_undefer)();		/* call _thread_kern_sig_undefer() */
+	/* leave child with signals disabled, but reenable in parent */
+    }
+
+    return resultPid;
+}
+#endif /* __FreeBSD__ */
+
+#if defined(__OpenBSD__)
+/*
+ * Directly call _thread_sys_closefrom() so the child process
+ * doesn't reset the parrent's file descriptors to be blocking.
+ * This function is only called from the child process which
+ * is single threaded and about to call execvp() so it is
+ * safe to bypass the threaded closefrom().
+ */
+int _thread_sys_closefrom(int);
+
+static int
+closeDescriptors(void)
+{
+    return _thread_sys_closefrom(FAIL_FILENO + 1);
+}
+
+#else
+
+#ifdef _ALLBSD_SOURCE                                                          
+#define FD_DIR "/dev/fd"
+#else
+#define dirent dirent64                                                        
+#define readdir readdir64                                                      
+#define FD_DIR "/proc/self/fd"
+#endif
+
 static int
 closeDescriptors(void)
 {
     DIR *dp;
-    struct dirent64 *dirp;
+    struct dirent *dirp;
     int from_fd = FAIL_FILENO + 1;
 
     /* We're trying to close all file descriptors, but opendir() might
@@ -276,13 +369,13 @@
     close(from_fd);             /* for possible use by opendir() */
     close(from_fd + 1);         /* another one for good luck */
 
-    if ((dp = opendir("/proc/self/fd")) == NULL)
+    if ((dp = opendir(FD_DIR)) == NULL)
         return 0;
 
     /* We use readdir64 instead of readdir to work around Solaris bug
      * 6395699: /proc/self/fd fails to report file descriptors >= 1024 on Solaris 9
      */
-    while ((dirp = readdir64(dp)) != NULL) {
+    while ((dirp = readdir(dp)) != NULL) {
         int fd;
         if (isdigit(dirp->d_name[0]) &&
             (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)
@@ -293,6 +386,7 @@
 
     return 1;
 }
+#endif /* !__OpenBSD__ */
 
 static void
 moveDescriptor(int fd_from, int fd_to)
@@ -449,7 +543,9 @@
      * "All identifiers in this volume of IEEE Std 1003.1-2001, except
      * environ, are defined in at least one of the headers" (!)
      */
+#ifndef __APPLE__
     extern char **environ;
+#endif
 
     if (envp != NULL)
         environ = (char **) envp;
@@ -513,10 +609,15 @@
     }
 }
 
+#if defined(__FreeBSD__)
+#undef fork1
+#define fork1() jdk_fork_wrapper()
+#else
 #ifndef __solaris__
 #undef fork1
 #define fork1() fork()
 #endif
+#endif
 
 JNIEXPORT jint JNICALL
 Java_java_lang_UNIXProcess_forkAndExec(JNIEnv *env,
@@ -578,6 +679,30 @@
     if (resultPid == 0) {
         /* Child process */
 
+
+#ifdef __OpenBSD__
+// XXXBSD: Work-around userland pthread implementation issue.
+// Closing file descriptors will reset them to be blocking.
+// This is problematic for the parent when it attemts to use
+// the blocking fd and deadlocks. Setting them to non-blocking
+// in the child prevents the close/dup2 from resetting them.
+    {
+ int flags;
+ flags = fcntl(STDIN_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);
+
+ flags = fcntl(STDOUT_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDOUT_FILENO, F_SETFL, flags | O_NONBLOCK);
+
+ flags = fcntl(STDERR_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDOUT_FILENO, F_SETFL, flags | O_NONBLOCK);
+    }
+#endif
+
+
         /* Close the parent sides of the pipe.
            Give the child sides of the pipes the right fileno's.
            Closing pipe fds here is redundant, since closeDescriptors()
--- jdk/src/solaris/native/java/lang/java_props_md.c
+++ jdk/src/solaris/native/java/lang/java_props_md.c
@@ -23,7 +23,7 @@
  * questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdio.h>
 #include <ctype.h>
 #endif
@@ -42,9 +42,17 @@
 #include <time.h>
 #include <errno.h>
 
+#if defined(_ALLBSD_SOURCE)
+#if !defined(P_tmpdir)
+#include <paths.h>
+#define P_tmpdir _PATH_VARTMP
+#endif
+#endif
+
 #include "locale_str.h"
 #include "java_props.h"
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
 #define CODESET _NL_CTYPE_CODESET_NAME
 #else
@@ -52,6 +60,7 @@
 #define CODESET ALT_CODESET_KEY
 #endif
 #endif
+#endif /* !_ALLBSD_SOURCE */
 
 /* Take an array of string pairs (map of key->value) and a string (key).
  * Examine each pair in the map to see if the first string (key) matches the
@@ -188,7 +197,12 @@
     {
         char *lc;
         lc = setlocale(LC_CTYPE, "");
-#ifndef __linux__
+#if defined(_ALLBSD_SOURCE)
+	if (lc == NULL) {
+	    lc = "C";
+	}
+	{
+#elif !defined(__linux__)
         if (lc == NULL) {
             /*
              * 'lc == null' means system doesn't support user's environment
@@ -219,7 +233,7 @@
             char *p, encoding_variant[64];
             int i, found;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
             /*
              * Workaround for Solaris bug 4201684: Xlib doesn't like @euro
              * locales. Since we don't depend on the libc @euro behavior,
@@ -236,6 +250,13 @@
                 *p = '\0';
             setlocale(LC_ALL, temp);
 #endif
+	    if (lc == NULL) {
+		strncpy(temp, "C", sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    } else {
+		strncpy(temp, lc, sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    }
 
             strcpy(temp, lc);
 
@@ -316,6 +337,9 @@
             else
                 p = nl_langinfo(CODESET);
 
+	    if (p == NULL || !strcmp(p, "C") || !strcmp(p, "US-ASCII"))
+		p = ""; // use default
+
             /* Convert the bare "646" used on Solaris to a proper IANA name */
             if (strcmp(p, "646") == 0)
                 p = "ISO646-US";
@@ -325,6 +349,7 @@
             std_encoding = (*p != '\0') ? p : "ISO8859-1";
 
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
             /*
              * Remap the encoding string to a different value for japanese
@@ -355,11 +380,19 @@
                     std_encoding = "Big5_Solaris";
             }
 #endif
+#endif /* !_ALLBSD_SOURCE */
             sprops.encoding = std_encoding;
             sprops.sun_jnu_encoding = sprops.encoding;
         }
     }
 
+#ifdef _ALLBSD_SOURCE
+#if BYTE_ORDER == _LITTLE_ENDIAN
+     sprops.unicode_encoding = "UnicodeLittle";
+ #else
+     sprops.unicode_encoding = "UnicodeBig";
+ #endif
+#else /* !_ALLBSD_SOURCE */
 #ifdef __linux__
 #if __BYTE_ORDER == __LITTLE_ENDIAN
     sprops.unicode_encoding = "UnicodeLittle";
@@ -369,6 +402,7 @@
 #else
     sprops.unicode_encoding = "UnicodeBig";
 #endif
+#endif /* _ALLBSD_SOURCE */
 
     /* user properties */
     {
@@ -405,12 +439,14 @@
     sprops.path_separator = ":";
     sprops.line_separator = "\n";
 
+#if !defined(_ALLBSD_SOURCE)
     /* Append CDE message and resource search path to NLSPATH and
      * XFILESEARCHPATH, in order to pick localized message for
      * FileSelectionDialog window (Bug 4173641).
      */
     setPathEnvironment("NLSPATH=/usr/dt/lib/nls/msg/%L/%N.cat");
     setPathEnvironment("XFILESEARCHPATH=/usr/dt/app-defaults/%L/Dt");
+#endif
 
     return &sprops;
 }
--- jdk/src/solaris/native/java/net/Inet4AddressImpl.c
+++ jdk/src/solaris/native/java/net/Inet4AddressImpl.c
@@ -35,17 +35,293 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#include <sys/param.h>
+#endif
+
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
 
 #include "java_net_Inet4AddressImpl.h"
 
+#if defined(__GLIBC__) || (defined(__FreeBSD__) && (__FreeBSD_version >= 601104))
+#define HAS_GLIBC_GETHOSTBY_R	1
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R)
+/* Use getaddrinfo(3), which is thread safe */
+/************************************************************************
+ * Inet4AddressImpl
+ */
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getLocalHostName
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getLocalHostName(JNIEnv *env, jobject this) {
+    char hostname[NI_MAXHOST+1];
+
+    hostname[0] = '\0';
+    if (JVM_GetHostName(hostname, NI_MAXHOST)) {
+	/* Something went wrong, maybe networking is not setup? */
+	strcpy(hostname, "localhost");
+    } else {
+	 struct addrinfo  hints, *res;
+	 int error;
+
+	 memset(&hints, 0, sizeof(hints));
+	 hints.ai_flags = AI_CANONNAME;
+	 hints.ai_family = AF_UNSPEC;
+
+	 error = getaddrinfo(hostname, NULL, &hints, &res);
+
+	 if (error == 0) {
+	     /* host is known to name service */
+	     error = getnameinfo(res->ai_addr,
+				 res->ai_addrlen,
+				 hostname,
+				 NI_MAXHOST,
+				 NULL,
+				 0,
+				 NI_NAMEREQD);
+
+	     /* if getnameinfo fails hostname is still the value
+	        from gethostname */
+
+	     freeaddrinfo(res);
+	}
+    }
+    return (*env)->NewStringUTF(env, hostname);
+}
+
+static jclass ni_iacls;
+static jclass ni_ia4cls;
+static jmethodID ni_ia4ctrID;
+static jfieldID ni_iaaddressID;
+static jfieldID ni_iahostID;
+static jfieldID ni_iafamilyID;
+static int initialized = 0;
+
+/*
+ * Find an internet address for a given hostname.  Note that this
+ * code only works for addresses of type INET. The translation
+ * of %d.%d.%d.%d to an address (int) occurs in java now, so the
+ * String "host" shouldn't *ever* be a %d.%d.%d.%d string
+ *
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    lookupAllHostAddr
+ * Signature: (Ljava/lang/String;)[[B
+ */
+
+JNIEXPORT jobjectArray JNICALL
+Java_java_net_Inet4AddressImpl_lookupAllHostAddr(JNIEnv *env, jobject this,
+						jstring host) {
+    const char *hostname;
+    jobject name;
+    jobjectArray ret = 0;
+    int retLen = 0;
+
+    int error=0;
+    struct addrinfo hints, *res, *resNew = NULL;
+
+    if (!initialized) {
+      ni_iacls = (*env)->FindClass(env, "java/net/InetAddress");
+      ni_iacls = (*env)->NewGlobalRef(env, ni_iacls);
+      ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
+      ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
+      ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
+      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
+      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
+      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
+      initialized = 1;
+    }
+
+    if (IS_NULL(host)) {
+	JNU_ThrowNullPointerException(env, "host is null");
+	return 0;
+    }
+    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);
+    CHECK_NULL_RETURN(hostname, NULL);
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_flags = AI_CANONNAME;
+    hints.ai_family = AF_INET;
+
+    /*
+     * Workaround for Solaris bug 4160367 - if a hostname contains a
+     * white space then 0.0.0.0 is returned
+     */
+    if (isspace(hostname[0])) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    }
+	
+    error = getaddrinfo(hostname, NULL, &hints, &res);
+	
+    if (error) {
+	/* report error */
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    } else {
+	int i = 0;
+	struct addrinfo *itr, *last, *iterator = res;
+	while (iterator != NULL) {
+	    int skip = 0;
+	    itr = resNew;
+
+	    while (itr != NULL) {
+		struct sockaddr_in *addr1, *addr2;
+
+		addr1 = (struct sockaddr_in *)iterator->ai_addr;
+		addr2 = (struct sockaddr_in *)itr->ai_addr;
+		if (addr1->sin_addr.s_addr ==
+		    addr2->sin_addr.s_addr) {
+		    skip = 1;
+		    break;
+		}
+		     
+		itr = itr->ai_next;
+	    }
+		
+	    if (!skip) {
+		struct addrinfo *next
+	            = (struct addrinfo*) malloc(sizeof(struct addrinfo));
+		if (!next) {
+		    JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
+		    ret = NULL;
+		    goto cleanupAndReturn;
+		}
+		memcpy(next, iterator, sizeof(struct addrinfo));
+		next->ai_next = NULL;
+		if (resNew == NULL) {
+		    resNew = next;
+		} else {
+		    last->ai_next = next;
+		}
+		last = next;
+		i++;
+	    }
+	    iterator = iterator->ai_next;
+	}
+
+	retLen = i;
+	iterator = resNew;
+	i = 0;
+
+        name = (*env)->NewStringUTF(env, hostname);
+        if (IS_NULL(name)) {
+          goto cleanupAndReturn;
+        }
+
+	ret = (*env)->NewObjectArray(env, retLen, ni_iacls, NULL);
+	if (IS_NULL(ret)) {
+	    /* we may have memory to free at the end of this */
+	    goto cleanupAndReturn;
+	}
+
+	while (iterator != NULL) {
+	    /* We need 4 bytes to store ipv4 address; */
+	    int len = 4;
+		
+            jobject iaObj = (*env)->NewObject(env, ni_ia4cls, ni_ia4ctrID);
+	    if (IS_NULL(iaObj)) {
+		/* we may have memory to free at the end of this */
+		ret = NULL;
+		goto cleanupAndReturn;
+	    }
+            (*env)->SetIntField(env, iaObj, ni_iaaddressID,
+                                ntohl(((struct sockaddr_in*)(iterator->ai_addr))->sin_addr.s_addr));
+            (*env)->SetObjectField(env, iaObj, ni_iahostID, name);
+            (*env)->SetObjectArrayElement(env, ret, retLen - i -1, iaObj);
+	    i++;
+	    iterator = iterator->ai_next;
+	}
+    }
+    
+cleanupAndReturn:
+    {
+	struct addrinfo *iterator, *tmp;
+	iterator = resNew;
+	while (iterator != NULL) {
+	    tmp = iterator;
+	    iterator = iterator->ai_next;
+	    free(tmp);
+	}
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+    }
+   
+    freeaddrinfo(res);
+    
+    return ret;
+
+}
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getHostByAddr
+ * Signature: (I)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getHostByAddr(JNIEnv *env, jobject this,
+					    jbyteArray addrArray) {
+    jstring ret = NULL;
+
+    char host[NI_MAXHOST+1];
+    jfieldID fid;
+    int error = 0;
+    jint family;
+    struct sockaddr *him ; 
+    int len = 0;
+    jbyte caddr[4];
+    jint addr;
+
+    struct sockaddr_in him4;
+    struct sockaddr *sa;
+
+    /* 
+	 * For IPv4 addresses construct a sockaddr_in structure.
+	 */
+    (*env)->GetByteArrayRegion(env, addrArray, 0, 4, caddr);
+    addr = ((caddr[0]<<24) & 0xff000000);
+    addr |= ((caddr[1] <<16) & 0xff0000);
+    addr |= ((caddr[2] <<8) & 0xff00);
+    addr |= (caddr[3] & 0xff);
+    memset((char *) &him4, 0, sizeof(him4));
+    him4.sin_addr.s_addr = (uint32_t) htonl(addr);
+    him4.sin_family = AF_INET;
+    sa = (struct sockaddr *) &him4;
+    len = sizeof(him4);
+    
+    error = getnameinfo(sa, len, host, NI_MAXHOST, NULL, 0,
+			       NI_NAMEREQD);
+
+    if (!error) {
+	ret = (*env)->NewStringUTF(env, host);
+    }
+
+    if (ret == NULL) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException", NULL);
+    }
+
+    return ret;
+
+}
+
+#else /* defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R) */
+
 /* the initial size of our hostent buffers */
 #define HENT_BUF_SIZE 1024
 #define BIG_HENT_BUF_SIZE 10240  /* a jumbo-sized one */
 
-#ifndef __GLIBC__
+#if !defined(__GLIBC__) && !defined(_ALLBSD_SOURCE)
 /* gethostname() is in libc.so but I can't find a header file for it */
 extern int gethostname(char *buf, int buf_len);
 #endif
@@ -85,13 +361,13 @@
         char buf2[HENT_BUF_SIZE];
         int h_error=0;
 
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
         gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
         hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
 #endif
         if (hp) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r(hp->h_addr, hp->h_length, AF_INET,
                             &res2, buf2, sizeof(buf2), &hp, &h_error);
 #else
@@ -178,7 +454,7 @@
     }
 
     /* Try once, with our static buffer. */
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
     hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
@@ -191,7 +467,7 @@
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyname_r(hostname, &res, tmp, BIG_HENT_BUF_SIZE,
                             &hp, &h_error);
 #else
@@ -281,7 +557,7 @@
     addr |= ((caddr[2] <<8) & 0xff00);
     addr |= (caddr[3] & 0xff);
     addr = htonl(addr);
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET, &hent,
                     buf, sizeof(buf), &hp, &h_error);
 #else
@@ -295,7 +571,7 @@
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET,
                             &hent, tmp, BIG_HENT_BUF_SIZE, &hp, &h_error);
 #else
@@ -317,6 +593,8 @@
     return ret;
 }
 
+#endif /* _ALLBSD_SOURCE */
+
 #define SET_NONBLOCKING(fd) {           \
         int flags = fcntl(fd, F_GETFL); \
         flags |= O_NONBLOCK;            \
--- jdk/src/solaris/native/java/net/Inet6AddressImpl.c
+++ jdk/src/solaris/native/java/net/Inet6AddressImpl.c
@@ -32,6 +32,9 @@
 #include <strings.h>
 #include <stdlib.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h> /* gethostname */
+#endif
 
 #include "jvm.h"
 #include "jni_util.h"
@@ -48,7 +51,7 @@
 #define NI_MAXHOST 1025
 #endif
 
-#ifndef __GLIBC__
+#if !defined(__GLIBC__) && !defined(_ALLBSD_SOURCE)
 /* gethostname() is in libc.so but I can't find a header file for it */
 extern int gethostname(char *buf, int buf_len);
 #endif
@@ -71,10 +74,18 @@
         /* Something went wrong, maybe networking is not setup? */
         strcpy(hostname, "localhost");
     } else {
-#ifdef __linux__
-        /* On Linux gethostname() says "host.domain.sun.com".  On
+#if defined(__linux__) && defined(_ALLBSD_SOURCE)
+	/* On Linux/FreeBSD gethostname() says "host.domain.sun.com".  On
          * Solaris gethostname() says "host", so extra work is needed.
          */
+        /*
+         * XXXBSD: Though on FreeBSD it's possible case then hostname does
+         * not contain '.' (depends on previous sethostname() call).  Maybe
+         * we need to proceed with Solaris way, but using getnameinfo()
+         * in conjunction with gethostby*() breaks thread-safeness, so
+         * we need to protect all calls to gethostby*() and getnameinfo()
+         * using same mutex.
+         */
 #else
         /* Solaris doesn't want to give us a fully qualified domain name.
          * We do a reverse lookup to try and get one.  This works
@@ -110,7 +121,7 @@
             }
         }
 #endif /* AF_INET6 */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
     }
     return (*env)->NewStringUTF(env, hostname);
 }
--- jdk/src/solaris/native/java/net/NetworkInterface.c
+++ jdk/src/solaris/native/java/net/NetworkInterface.c
@@ -23,13 +23,13 @@
  * questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <strings.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -47,6 +47,19 @@
 #else
 #include <sys/sockio.h>
 #endif
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#if defined(__FreeBSD__) || defined(__APPLE__)
+#include <net/ethernet.h>
+#include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#endif
+#include <net/if_dl.h>
+#include <netinet/in_var.h>
+#include <ifaddrs.h>
+#endif
 
 #ifdef __linux__
 #define ifr_index ifr_ifindex
@@ -584,6 +597,7 @@
 }
 
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * Enumerates and returns all IPv4 interfaces
  */
@@ -694,6 +708,176 @@
     return ifs;
 }
 
+#else /* _ALLBSD_SOURCE */
+ 
+/*
+ * Enumerates and returns all IPv4 interfaces
+ *
+ * WARNING! Make sure that it's correctly synchronized on future JDK
+ * versions imports!
+ */
+static netif *enumIPv4Interfaces(JNIEnv *env, netif *ifs)
+{
+    int sock;
+    struct ifaddrs *ifa, *origifa;
+
+    sock = JVM_Socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock < 0) {
+	/*
+	 * If EPROTONOSUPPORT is returned it means we don't have
+	 * IPv4 support so don't throw an exception.
+	 */
+	if (errno != EPROTONOSUPPORT) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "Socket creation failed");
+	}
+	return ifs;
+    }
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	close(sock);
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET)
+	    continue;
+
+	/*
+	 * Add to the list.
+	 *
+	 * BSDNOTE: in order to optimize code, interface index detection
+	 * logic was added directly to addif().
+	 */
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET,
+		    ifa->ifa_addr, sizeof(struct sockaddr_in), 0);
+
+	/*
+	 * If an exception occurred then free the list.
+	 */
+	if ((*env)->ExceptionOccurred(env)) {
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and buffer
+     */
+    close(sock);
+    freeifaddrs(origifa);
+    return ifs;
+}
+
+#if defined(AF_INET6)
+/*
+ * Determines the prefix on BSD for IPv6 interfaces.
+ */
+static
+int prefix(void *val, int size) {
+    u_char *name = (u_char *)val;
+    int byte, bit, plen = 0;
+
+    for (byte = 0; byte < size; byte++, plen += 8)
+        if (name[byte] != 0xff)
+            break;
+    if (byte == size)
+        return (plen);
+    for (bit = 7; bit != 0; bit--, plen++)
+        if (!(name[byte] & (1 << bit)))
+            break;
+    for (; bit != 0; bit--)
+        if (name[byte] & (1 << bit))
+            return (0);
+    byte++;
+    for (; byte < size; byte++)
+        if (name[byte])
+            return (0);
+    return (plen);
+}
+
+/*
+ * Enumerates and returns all IPv6 interfaces on FreeBSD
+ *
+ * BSDNOTE: it's done in same as IPv4 enumeration and should be carefully
+ *          reviewed with each JDK update (according to Solaris/Linux version)
+ */
+static netif *enumIPv6Interfaces(JNIEnv *env, netif *ifs) {
+
+    int sock;
+    struct ifaddrs *ifa, *origifa;
+    struct sockaddr_in6 *sin6;
+    struct in6_ifreq ifr6;
+
+    // Open IPv6 UDP socket.
+    sock = JVM_Socket(AF_INET6, SOCK_DGRAM, 0);
+    if (sock < 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                     "Failed to create IPv6 socket");
+        return ifs;
+    }
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	close(sock);
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET6 entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET6)
+	    continue;
+
+	memset(&ifr6, 0, sizeof(ifr6));
+	strlcpy(ifr6.ifr_name, ifa->ifa_name, sizeof(ifr6.ifr_name));
+	memcpy(&ifr6.ifr_addr, ifa->ifa_addr, MIN(sizeof(ifr6.ifr_addr), ifa->ifa_addr->sa_len));
+
+	if (ioctl(sock, SIOCGIFNETMASK_IN6, (caddr_t)&ifr6) < 0) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "ioctl SIOCGIFNETMASK_IN6 failed");
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+
+	/* Add to the list.  */
+	sin6 = (struct sockaddr_in6 *)&ifr6.ifr_addr;
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET6,
+	            ifa->ifa_addr, sizeof(struct sockaddr_in6),
+		    prefix(&sin6->sin6_addr, sizeof(struct in6_addr)));
+
+	/* If an exception occurred then free the list.  */
+	if ((*env)->ExceptionOccurred(env)) {
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and ifaddrs buffer
+     */
+    close(sock);
+    freeifaddrs(origifa);
+    return ifs;
+}
+#endif /* AF_INET6 */
+
+#endif /* !_ALLBSD_SOURCE */
 
 #if defined(__solaris__) && defined(AF_INET6)
 /*
@@ -1014,7 +1198,13 @@
             JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
             return ifs;
         }
+#if defined(_ALLBSD_SOURCE)
+	currif->index = if_nametoindex(name);
+	if (currif->index == 0)
+	    currif->index = -1;
+#else
         currif->index = index;
+#endif
         currif->addr = NULL;
         currif->childs = NULL;
         currif->virtual = isVirtual;
@@ -1302,6 +1492,31 @@
    * All bytes to 0 means no hardware address.
    */
   return -1;
+#elif defined(_ALLBSD_SOURCE)
+  struct ifaddrs *ifa0, *ifa;
+  struct sockaddr *saddr;
+  int i;
+
+  /* Grab the interface list */
+  if (!getifaddrs(&ifa0)) {
+    /* Cycle through the interfaces */
+    for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next, i++) {
+      saddr = ifa->ifa_addr;
+      /* Link layer contains the MAC address */
+      if (saddr->sa_family == AF_LINK && !strcmp(ifname, ifa->ifa_name)) {
+        struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
+        /* Check the address is the correct length */
+        if (sadl->sdl_alen == ETHER_ADDR_LEN) {
+           memcpy(buf, (sadl->sdl_data + sadl->sdl_nlen), ETHER_ADDR_LEN);
+           freeifaddrs(ifa0);
+           return ETHER_ADDR_LEN;
+        }
+      }
+    }
+    freeifaddrs(ifa0);
+  }
+
+  return -1;
 #else
   struct arpreq arpreq;
   struct sockaddr_in* sin;
@@ -1467,7 +1682,7 @@
                                  "Socket creation failed");
   } else {
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *) &if2, 0, sizeof(if2));
     strcpy(if2.ifr_name, name_utf);
 
--- jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c
+++ jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c
@@ -23,12 +23,12 @@
  * questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 
 #ifdef __solaris__
 #include <fcntl.h>
@@ -335,7 +335,7 @@
     /* The fdObj'fd */
     jint fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     SOCKADDR addr;
     int len;
 #endif
@@ -345,26 +345,39 @@
     }
     fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
 
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #ifdef __linux__
     if (isOldKernel) {
         int t = 1;
         setsockopt(fd, SOL_SOCKET, SO_BSDCOMPAT, (char*) &t, sizeof(int));
     } else {
+#endif /* __linux__ */
         memset(&addr, 0, sizeof(addr));
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&addr;
+#ifdef __FreeBSD__
+            him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&addr;
+#ifdef __FreeBSD__
+            him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
         JVM_Connect(fd, (struct sockaddr *)&addr, len);
+	/* XXXBSD: here we can get EADDRNOTAVAIL which need to be ignored
+	   but since return value is not checked, ignore it */
 
+#ifdef __linux__
         // After disconnecting a UDP socket, Linux kernel will set
         // local port to zero if the port number comes from implicit
         // bind. Successive send/recv on the same socket will fail.
@@ -387,6 +400,7 @@
             NET_Bind(fd, (struct sockaddr *)&addr, len);
         }
     }
+#endif
 #else
     JVM_Connect(fd, 0, 0);
 #endif
@@ -1057,31 +1071,38 @@
 Java_java_net_PlainDatagramSocketImpl_datagramSocketCreate(JNIEnv *env,
                                                            jobject this) {
     jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);
-    int fd;
-
-    int arg = -1;
-    int t = 1;
+    int fd, t = 1;
+#ifdef AF_INET6
+    int domain = ipv6_available() ? AF_INET6 : AF_INET;
+#else
+    int domain = AF_INET;
+#endif
 
     if (IS_NULL(fdObj)) {
         JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Socket closed");
         return;
-    } else {
-#ifdef AF_INET6
-        if (ipv6_available()) {
-            fd =  JVM_Socket(AF_INET6, SOCK_DGRAM, 0);
-        } else
-#endif /* AF_INET6 */
-            {
-                fd =  JVM_Socket(AF_INET, SOCK_DGRAM, 0);
-            }
     }
-    if (fd == JVM_IO_ERR) {
+
+    if ((fd = JVM_Socket(domain, SOCK_DGRAM, 0)) == JVM_IO_ERR) {
         NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException",
                        "Error creating socket");
         return;
     }
 
+#ifdef AF_INET6
+    /* Disable IPV6_V6ONLY to ensure dual-socket support */
+    if (domain == AF_INET6) {
+        int arg = 0;
+        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,
+                       sizeof(int)) < 0) {
+            NET_ThrowNew(env, errno, "cannot set IPPROTO_IPV6");
+            close(fd);
+            return;
+        }
+    }
+#endif /* AF_INET6 */
+
      setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (char*) &t, sizeof(int));
 
 #ifdef __linux__
@@ -1094,7 +1115,7 @@
      * On Linux for IPv6 sockets we must set the hop limit
      * to 1 to be compatible with default ttl of 1 for IPv4 sockets.
      */
-    if (ipv6_available()) {
+    if (domain == AF_INET6) {
         int ttl = 1;
         setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char *)&ttl,
                    sizeof(ttl));
@@ -1317,7 +1338,7 @@
         /*
          * value is an InetAddress.
          */
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
         if (ipv6_available()) {
             mcast_set_if_by_addr_v6(env, this, fd, value);
         } else {
@@ -1336,7 +1357,7 @@
         /*
          * value is a NetworkInterface.
          */
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
         if (ipv6_available()) {
             mcast_set_if_by_if_v6(env, this, fd, value);
         } else {
@@ -1413,7 +1434,7 @@
  */
 static void setMulticastLoopbackMode(JNIEnv *env, jobject this, int fd,
                                   jint opt, jobject value) {
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
     if (ipv6_available()) {
         mcast_set_loop_v6(env, this, fd, value);
     } else {
@@ -1981,7 +2002,7 @@
         fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
     }
     /* setsockopt to be correct ttl */
-#ifdef __solaris__
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
     if (ipv6_available()) {
         setHopLimit(env, fd, ttl);
     } else {
@@ -2374,18 +2395,30 @@
             mname6.ipv6mr_interface = idx;
         }
 
+#if defined(_ALLBSD_SOURCE)
+#define ADD_MEMBERSHIP		IPV6_JOIN_GROUP
+#define DRP_MEMBERSHIP		IPV6_LEAVE_GROUP
+#define S_ADD_MEMBERSHIP	"IPV6_JOIN_GROUP"
+#define S_DRP_MEMBERSHIP	"IPV6_LEAVE_GROUP"
+#else
+#define ADD_MEMBERSHIP		IPV6_ADD_MEMBERSHIP
+#define DRP_MEMBERSHIP		IPV6_DROP_MEMBERSHIP
+#define S_ADD_MEMBERSHIP	"IPV6_ADD_MEMBERSHIP"
+#define S_DRP_MEMBERSHIP	"IPV6_DROP_MEMBERSHIP"
+#endif
+
         /* Join the multicast group */
-        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP),
+        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),
                            (char *) &mname6, sizeof (mname6)) < 0) {
 
             if (join) {
-                NET_ThrowCurrent(env, "setsockopt IPV6_ADD_MEMBERSHIP failed");
+                NET_ThrowCurrent(env, "setsockopt " S_ADD_MEMBERSHIP " failed");
             } else {
                 if (errno == ENOENT) {
                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Not a member of the multicast group");
                 } else {
-                    NET_ThrowCurrent(env, "setsockopt IPV6_DROP_MEMBERSHIP failed");
+                    NET_ThrowCurrent(env, "setsockopt " S_DRP_MEMBERSHIP " failed");
                 }
             }
         }
--- jdk/src/solaris/native/java/net/PlainSocketImpl.c
+++ jdk/src/solaris/native/java/net/PlainSocketImpl.c
@@ -253,7 +253,12 @@
                                            jboolean stream) {
     jobject fdObj, ssObj;
     int fd;
-    int arg = -1;
+    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);
+#ifdef AF_INET6
+    int domain = ipv6_available() ? AF_INET6 : AF_INET;
+#else
+    int domain = AF_INET;
+#endif
 
     if (socketExceptionCls == NULL) {
         jclass c = (*env)->FindClass(env, "java/net/SocketException");
@@ -267,25 +272,29 @@
         (*env)->ThrowNew(env, socketExceptionCls, "null fd object");
         return;
     }
-#ifdef AF_INET6
-    if (ipv6_available()) {
-        fd = JVM_Socket(AF_INET6, (stream ? SOCK_STREAM: SOCK_DGRAM), 0);
-    } else
-#endif /* AF_INET6 */
-        {
-            fd = JVM_Socket(AF_INET, (stream ? SOCK_STREAM: SOCK_DGRAM), 0);
-        }
-    if (fd == JVM_IO_ERR) {
+
+    if ((fd = JVM_Socket(domain, type, 0)) == JVM_IO_ERR) {
         /* note: if you run out of fds, you may not be able to load
          * the exception class, and get a NoClassDefFoundError
          * instead.
          */
         NET_ThrowNew(env, errno, "can't create socket");
         return;
-    } else {
-        (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);
     }
 
+#ifdef AF_INET6
+    /* Disable IPV6_V6ONLY to ensure dual-socket support */
+    if (domain == AF_INET6) {
+        int arg = 0;
+        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,
+                       sizeof(int)) < 0) {
+            NET_ThrowNew(env, errno, "cannot set IPPROTO_IPV6");
+            close(fd);
+            return;
+        }
+    }
+#endif /* AF_INET6 */
+
     /*
      * If this is a server socket then enable SO_REUSEADDR
      * automatically and set to non blocking.
@@ -294,9 +303,15 @@
     if (ssObj != NULL) {
         int arg = 1;
         SET_NONBLOCKING(fd);
-        JVM_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
-            sizeof(arg));
+        if (JVM_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
+                           sizeof(arg)) < 0) {
+            NET_ThrowNew(env, errno, "cannot set SO_REUSEADDR");
+            close(fd);
+            return;
+        }
     }
+
+    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);
 }
 
 /*
@@ -528,9 +543,11 @@
         if (connect_rv == JVM_IO_INTR) {
             JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
                             "operation interrupted");
+#if defined(EPROTO)
         } else if (errno == EPROTO) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ProtocolException",
                            "Protocol error");
+#endif
         } else if (errno == ECONNREFUSED) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ConnectException",
                            "Connection refused");
--- jdk/src/solaris/native/java/net/bsd_close.c
+++ jdk/src/solaris/native/java/net/bsd_close.c
@@ -57,7 +57,7 @@
 /*
  * Signal to unblock thread
  */
-static int sigWakeup = (__SIGRTMAX - 2);
+static int sigWakeup = SIGIO;
 
 /*
  * The fd table and the number of file descriptors
--- jdk/src/solaris/native/java/net/net_util_md.c
+++ jdk/src/solaris/native/java/net/net_util_md.c
@@ -34,6 +34,15 @@
 #include <stdlib.h>
 #include <dlfcn.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
+
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -220,6 +229,14 @@
     return (*env)->GetFieldID(env, cls, "fd", "I");
 }
 
+#if defined(DONT_ENABLE_IPV6)
+jint  IPv6_supported()
+{
+    return JNI_FALSE;
+}
+
+#else /* !DONT_ENABLE_IPV6 */
+
 jint  IPv6_supported()
 {
 #ifndef AF_INET6
@@ -230,7 +247,7 @@
     int fd;
     void *ipv6_fn;
     SOCKADDR sa;
-    int sa_len = sizeof(sa);
+    socklen_t sa_len = sizeof(sa);
 
     fd = JVM_Socket(AF_INET6, SOCK_STREAM, 0) ;
     if (fd < 0) {
@@ -356,6 +373,7 @@
     close(fd);
     return JNI_TRUE;
 }
+#endif /* DONT_ENABLE_IPV6 */
 
 void
 NET_AllocSockaddr(struct sockaddr **him, int *len) {
@@ -710,6 +728,10 @@
         him6->sin6_family = AF_INET6;
         *len = sizeof(struct sockaddr_in6) ;
 
+#if defined(_ALLBSD_SOURCE) && defined(_AF_INET6)
+// XXXBSD: should we do something with scope id here ? see below linux comment
+#endif
+
         /*
          * On Linux if we are connecting to a link-local address
          * we need to specify the interface in the scope_id (2.4 kernel only)
@@ -1107,7 +1129,16 @@
     }
 #endif
 
+#ifdef __solaris__
     rv = getsockopt(fd, level, opt, result, len);
+#else
+    {
+        socklen_t socklen = *len;
+        rv = getsockopt(fd, level, opt, result, &socklen);
+        *len = socklen;
+    }
+#endif
+
     if (rv < 0) {
         return rv;
     }
@@ -1154,6 +1185,24 @@
 #define IPTOS_PREC_MASK 0xe0
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+#if defined(KIPC_MAXSOCKBUF)
+    int mib[3];
+    size_t rlen;
+#endif
+
+    int *bufsize;
+
+#ifdef __APPLE__
+    static int maxsockbuf = -1;
+#else
+    static long maxsockbuf = -1;
+#endif
+
+    int addopt;
+    struct linger *ling;
+#endif
+
     /*
      * IPPROTO/IP_TOS :-
      * 1. IPv6 on Solaris: no-op and will be set in flowinfo
@@ -1186,6 +1235,10 @@
         *iptos &= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
     }
 
+#if defined(AF_INET6) && defined(_ALLBSD_SOURCE)
+// XXXBSD: to be implemented ?
+#endif
+
     /*
      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris need to
      * ensure that value is <= max_buf as otherwise we get
@@ -1233,6 +1286,84 @@
     }
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+    /*
+     * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
+     * ensure that value is <= kern.ipc.maxsockbuf as otherwise we get
+     * an ENOBUFS error.
+     */
+    if (level == SOL_SOCKET) {
+        if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
+#ifdef KIPC_MAXSOCKBUF
+            if (maxsockbuf == -1) {
+               mib[0] = CTL_KERN;
+               mib[1] = KERN_IPC;
+               mib[2] = KIPC_MAXSOCKBUF;
+               rlen = sizeof(maxsockbuf);
+               if (sysctl(mib, 3, &maxsockbuf, &rlen, NULL, 0) == -1)
+                   maxsockbuf = 1024;
+
+#if 1
+               /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
+                  problem.  It should be removed when kern.ipc.maxsockbuf
+                  will be real value. */
+               maxsockbuf = (maxsockbuf/5)*4;
+#endif
+           }
+#elif defined(__OpenBSD__)
+	   maxsockbuf = SB_MAX;
+#else
+	   maxsockbuf = 64 * 1024;	/* XXX: NetBSD */
+#endif
+
+           bufsize = (int *)arg;
+           if (*bufsize > maxsockbuf) {
+               *bufsize = maxsockbuf;
+           }
+
+	   if (opt == SO_RCVBUF && *bufsize < 1024) {
+		*bufsize = 1024;
+	   }
+
+        }
+    }
+
+    /*
+     * On Solaris, SO_REUSEADDR will allow multiple datagram
+     * sockets to bind to the same port.  The network jck tests
+     * for this "feature", so we need to emulate it by turning on
+     * SO_REUSEPORT as well for that combination.
+     */
+    if (level == SOL_SOCKET && opt == SO_REUSEADDR) {
+        int sotype;
+        socklen_t arglen;
+
+        arglen = sizeof(sotype);
+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen) < 0) {
+            return -1;
+        }
+
+        if (sotype == SOCK_DGRAM) {
+            addopt = SO_REUSEPORT;
+            setsockopt(fd, level, addopt, arg, len);
+        }
+    }
+
+    /*
+     * Don't allow SO_LINGER value to be too big.
+     * Current max value (240) is empiric value based on tcp_timer.h's
+     * constant TCP_LINGERTIME, which was doubled.
+     *
+     * XXXBSD: maybe we should step it down to 120 ?
+     */
+    if (level == SOL_SOCKET && opt == SO_LINGER) {
+        ling = (struct linger *)arg;
+       if (ling->l_linger > 240 || ling->l_linger < 0) {
+           ling->l_linger = 240;
+       }
+    }
+#endif
+
     return setsockopt(fd, level, opt, arg, len);
 }
 
--- jdk/src/solaris/native/java/net/net_util_md.h
+++ jdk/src/solaris/native/java/net/net_util_md.h
@@ -37,7 +37,7 @@
 #endif
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 extern int NET_Timeout(int s, long timeout);
 extern int NET_Read(int s, void* buf, size_t len);
 extern int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
--- jdk/src/solaris/native/java/nio/MappedByteBuffer.c
+++ jdk/src/solaris/native/java/nio/MappedByteBuffer.c
@@ -38,7 +38,11 @@
                                         jlong address, jlong len)
 {
     jboolean loaded = JNI_TRUE;
+#if defined(_ALLBSD_SOURCE)
+    jint pageSize = getpagesize();
+#else
     jint pageSize = sysconf(_SC_PAGESIZE);
+#endif
     jint numPages = (len + pageSize - 1) / pageSize;
     int result = 0;
     int i = 0;
@@ -92,7 +96,11 @@
 Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jlong address,
                                       jlong len)
 {
+#if defined(_ALLBSD_SOURCE)
+    jlong pageSize = getpagesize();
+#else
     jlong pageSize = sysconf(_SC_PAGESIZE);
+#endif
     unsigned long lAddress = address;
 
     jlong offset = lAddress % pageSize;
--- jdk/src/solaris/native/java/util/FileSystemPreferences.c
+++ jdk/src/solaris/native/java/util/FileSystemPreferences.c
@@ -47,8 +47,11 @@
     return (jint) result;
 }
 
-
+#if defined(_ALLBSD_SOURCE)
+typedef struct flock FLOCK;
+#else
 typedef struct flock64 FLOCK;
+#endif
 
 /**
  * Try to open a named lock file.
@@ -86,7 +89,11 @@
     if (fd < 0) {
         result[0] = 0;
     } else {
+#if defined(_ALLBSD_SOURCE)
+        rc = fcntl(fd, F_SETLK, &fl); 
+#else
         rc = fcntl(fd, F_SETLK64, &fl);
+#endif
         result[1] = errno;
         if (rc < 0) {
             result[0]= 0;
@@ -116,7 +123,11 @@
     fl.l_start = 0;
     fl.l_type = F_UNLCK;
 
+#if defined(_ALLBSD_SOURCE)
+    rc = fcntl(fd, F_SETLK, &fl);
+#else
     rc = fcntl(fd, F_SETLK64, &fl);
+#endif
 
     if (rc < 0) {
         close(fd);
--- jdk/src/solaris/native/java/util/TimeZone_md.c
+++ jdk/src/solaris/native/java/util/TimeZone_md.c
@@ -31,7 +31,7 @@
 #include <errno.h>
 #include <stddef.h>
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #include <dirent.h>
 #include <sys/stat.h>
@@ -49,7 +49,7 @@
 #define fileclose       fclose
 #endif
 
-#ifdef __linux__
+#if defined(__linux__)  || defined(_ALLBSD_SOURCE)
 
 static const char *ETC_TIMEZONE_FILE = "/etc/timezone";
 static const char *ZONEINFO_DIR = "/usr/share/zoneinfo";
@@ -199,7 +199,9 @@
     int fd;
     char *buf;
     size_t size;
+    char zoneinfo_file[PATH_MAX+1];
 
+#ifdef __linux__
     /*
      * Try reading the /etc/timezone file for Debian distros. There's
      * no spec of the file format available. This parsing assumes that
@@ -223,6 +225,7 @@
             return tz;
         }
     }
+#endif /* __linux__ */
 
     /*
      * Next, try /etc/localtime to find the zone ID.
@@ -231,6 +234,9 @@
         return NULL;
     }
 
+    strlcpy(zoneinfo_file, DEFAULT_ZONEINFO_FILE, PATH_MAX+1);
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /*
      * If it's a symlink, get the link name and its zone ID part. (The
      * older versions of timeconfig created a symlink as described in
@@ -239,21 +245,25 @@
      * from /etc/localtime.)
      */
     if (S_ISLNK(statbuf.st_mode)) {
-        char linkbuf[PATH_MAX+1];
         int len;
 
-        if ((len = readlink(DEFAULT_ZONEINFO_FILE, linkbuf, sizeof(linkbuf)-1)) == -1) {
+        if ((len = readlink(DEFAULT_ZONEINFO_FILE, zoneinfo_file, sizeof(zoneinfo_file)-1)) == -1) {
             jio_fprintf(stderr, (const char *) "can't get a symlink of %s\n",
                         DEFAULT_ZONEINFO_FILE);
             return NULL;
         }
-        linkbuf[len] = '\0';
-        tz = getZoneName(linkbuf);
+        zoneinfo_file[len] = '\0';
+        tz = getZoneName(zoneinfo_file);
         if (tz != NULL) {
             tz = strdup(tz);
+            return tz;
+        } else {
+            if (lstat(zoneinfo_file, &statbuf) == -1) {
+                return NULL;
+            }
         }
-        return tz;
     }
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     /*
      * If it's a regular file, we need to find out the same zoneinfo file
@@ -264,7 +274,7 @@
     if (buf == NULL) {
         return NULL;
     }
-    if ((fd = open(DEFAULT_ZONEINFO_FILE, O_RDONLY)) == -1) {
+    if ((fd = open(zoneinfo_file, O_RDONLY)) == -1) {
         free((void *) buf);
         return NULL;
     }
@@ -493,7 +503,7 @@
 
     tz = getenv("TZ");
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (tz == NULL) {
 #else
 #ifdef __solaris__
@@ -532,19 +542,32 @@
 {
     time_t offset;
     char sign, buf[16];
+#if defined(_ALLBSD_SOURCE)
+    struct tm *local_tm;
+    time_t clock;
+ 
+    clock = time(NULL);
+    tzset();
+    local_tm = localtime(&clock);
+    if (local_tm->tm_gmtoff >= 0) {
+	offset = (time_t) local_tm->tm_gmtoff;
+	sign = '+';
+    } else {
+	offset = (time_t) -local_tm->tm_gmtoff;
+	sign = '-';
+    }
+#else
 
     if (timezone == 0) {
         return strdup("GMT");
-    }
-
-    /* Note that the time offset direction is opposite. */
-    if (timezone > 0) {
+    } else if (timezone > 0) {
         offset = timezone;
         sign = '-';
     } else {
         offset = -timezone;
         sign = '+';
     }
+#endif
     sprintf(buf, (const char *)"GMT%c%02d:%02d",
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
--- jdk/src/solaris/native/sun/awt/CUPSfuncs.c
+++ jdk/src/solaris/native/sun/awt/CUPSfuncs.c
@@ -25,6 +25,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 #include <cups/cups.h>
 #include <cups/ppd.h>
@@ -65,10 +66,11 @@
 JNIEXPORT jboolean JNICALL
 Java_sun_print_CUPSPrinter_initIDs(JNIEnv *env,
                                          jobject printObj) {
-  void *handle = dlopen("libcups.so.2", RTLD_LAZY | RTLD_GLOBAL);
+  void *handle = dlopen(VERSIONED_JNI_LIB_NAME("cups", "2"),
+                        RTLD_LAZY | RTLD_GLOBAL);
 
   if (handle == NULL) {
-    handle = dlopen("libcups.so", RTLD_LAZY | RTLD_GLOBAL);
+    handle = dlopen(JNI_LIB_NAME("cups"), RTLD_LAZY | RTLD_GLOBAL);
     if (handle == NULL) {
       return JNI_FALSE;
     }
--- jdk/src/solaris/native/sun/awt/VDrawingArea.c
+++ jdk/src/solaris/native/sun/awt/VDrawingArea.c
@@ -31,7 +31,11 @@
 #endif /* !HEADLESS */
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef __linux__
 /* XXX: Shouldn't be necessary. */
--- jdk/src/solaris/native/sun/awt/X11Color.c
+++ jdk/src/solaris/native/sun/awt/X11Color.c
@@ -33,7 +33,9 @@
 #include <math.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 #ifndef HEADLESS
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
--- jdk/src/solaris/native/sun/awt/XDrawingArea.c
+++ jdk/src/solaris/native/sun/awt/XDrawingArea.c
@@ -30,7 +30,11 @@
 #include <Xm/XmP.h>
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef DEBUG
 #include <jvm.h>  /* To get jio_fprintf() */
--- jdk/src/solaris/native/sun/awt/awt_Font.c
+++ jdk/src/solaris/native/sun/awt/awt_Font.c
@@ -334,7 +334,7 @@
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
--- jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c
+++ jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c
@@ -40,6 +40,7 @@
 #include <jni.h>
 #include <jni_util.h>
 #include <jvm.h>
+#include <jvm_md.h>
 #include <jlong.h>
 
 #include <stdlib.h>
@@ -51,6 +52,8 @@
 #include <dlfcn.h>
 #include "Trace.h"
 
+#include "jvm_md.h"
+
 #ifdef NETSCAPE
 #include <signal.h>
 extern int awt_init_xt;
@@ -122,7 +125,7 @@
  */
 
 #define MAXFRAMEBUFFERS 16
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -600,19 +603,22 @@
 #endif /* HEADLESS */
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXinerama.so.1";
+    void* libHandle = NULL;
     int32_t locNumScr = 0;
     XineramaScreenInfo *xinInfo;
     char* XineramaQueryScreensName = "XineramaQueryScreens";
     XineramaQueryScreensFunc* XineramaQueryScreens = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(VERSIONED_JNI_LIB_NAME("Xinerama", "1"),
+                       RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle == NULL) {
+        libHandle = dlopen(JNI_LIB_NAME("Xinerama"), RTLD_LAZY | RTLD_GLOBAL);
+    }
+    if (libHandle != NULL) {
         XineramaQueryScreens = (XineramaQueryScreensFunc*)
             dlsym(libHandle, XineramaQueryScreensName);
 
@@ -648,11 +654,10 @@
     }
 }
 #endif
-#ifndef __linux__ /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXext.so";
+    void* libHandle = NULL;
     unsigned char fbhints[MAXFRAMEBUFFERS];
     int32_t locNumScr = 0;
     /* load and run XineramaGetInfo */
@@ -661,8 +666,8 @@
     XineramaGetInfoFunc* XineramaSolarisFunc = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(JNI_LIB_NAME("Xext"), RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle != NULL) {
         XineramaSolarisFunc = (XineramaGetInfoFunc*)dlsym(libHandle, XineramaGetInfoName);
         XineramaSolarisCenterFunc =
             (XineramaGetCenterHintFunc*)dlsym(libHandle, XineramaGetCenterHintName);
@@ -709,11 +714,11 @@
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1568,7 +1573,7 @@
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1581,7 +1586,7 @@
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
@@ -1646,7 +1651,11 @@
 {
     int rr_maj_ver = 0, rr_min_ver = 0;
 
-    void *pLibRandR = dlopen("libXrandr.so.2", RTLD_LAZY | RTLD_LOCAL);
+    void *pLibRandR = dlopen(VERSIONED_JNI_LIB_NAME("Xrandr", "2"),
+                             RTLD_LAZY | RTLD_LOCAL);
+    if (pLibRandR == NULL) {
+        pLibRandR = dlopen(JNI_LIB_NAME("Xrandr"), RTLD_LAZY | RTLD_LOCAL);
+    }
     if (pLibRandR == NULL) {
         J2dRlsTraceLn(J2D_TRACE_ERROR,
                       "X11GD_InitXrandrFuncs: Could not open libXrandr.so.2");
--- jdk/src/solaris/native/sun/awt/awt_InputMethod.c
+++ jdk/src/solaris/native/sun/awt/awt_InputMethod.c
@@ -69,7 +69,7 @@
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -83,7 +83,7 @@
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -101,14 +101,14 @@
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -148,7 +148,7 @@
 #endif /* XAWT */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #else
 #ifndef XAWT
@@ -427,7 +427,7 @@
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -533,7 +533,7 @@
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -541,7 +541,7 @@
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -650,7 +650,7 @@
     return result;
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
 #ifdef XAWT
                                 Window parent) {
@@ -994,7 +994,7 @@
         }
     }
 }
-#endif  /*__linux__*/
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -1051,7 +1051,7 @@
         return FALSE ;
     }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -1064,7 +1064,7 @@
             break;
         }
     }
-#else /*! __linux__ */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
 #ifdef XAWT
     on_the_spot_styles |= XIMStatusNothing;
 #else /* !XAWT */
@@ -1087,7 +1087,7 @@
         on_the_spot_styles |= XIMStatusNothing;
 
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -1135,7 +1135,7 @@
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1157,7 +1157,7 @@
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
         if (on_the_spot_styles & XIMStatusArea) {
             Widget parent;
@@ -1185,7 +1185,7 @@
         }
 #endif /* XAWT */
         XFree((void *)preedit);
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
         pX11IMData->ic_passive = XCreateIC(X11im,
                                            XNClientWindow, XtWindow(w),
                                            XNFocusWindow, XtWindow(w),
@@ -1344,7 +1344,7 @@
 
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1412,7 +1412,7 @@
  finally:
     AWT_UNLOCK();
 }
-#endif /*__linux__*/
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1514,14 +1514,14 @@
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIMProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1585,13 +1585,13 @@
 #endif /* XAWT */
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#else /* __linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
     pX11IMData->statusWidget = (Widget) NULL;
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1738,14 +1738,14 @@
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  XtWindow(w);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1762,7 +1762,7 @@
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1859,7 +1859,7 @@
     X11InputMethodData *pX11IMData;
     XVaNestedList status;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
       /*do nothing for linux? */
 #else
     AWT_LOCK();
@@ -1965,7 +1965,7 @@
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
--- jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
+++ jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
@@ -260,7 +260,11 @@
         }
     }
 
+#ifdef __APPLE__ 
+    strcat(p, ".dylib");
+#else
     strcat(p, ".so");
+#endif
 
     JNU_CallStaticMethodByName(env, NULL, "java/lang/System", "load",
                                "(Ljava/lang/String;)V",
--- jdk/src/solaris/native/sun/awt/awt_MToolkit.c
+++ jdk/src/solaris/native/sun/awt/awt_MToolkit.c
@@ -63,8 +63,9 @@
 extern JavaVM *jvm;
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 extern void statusWindowEventHandler(XEvent event);
+Boolean awt_dnd_process_event(XEvent* event);
 #endif
 #endif /* !HEADLESS */
 
@@ -1642,7 +1643,7 @@
               */
               Widget widget=XtWindowToWidget(awt_display, xev.xany.window);
               eventNumber++;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
               statusWindowEventHandler(xev);
 #endif
               xembed_eventHandler(&xev);
--- jdk/src/solaris/native/sun/awt/awt_Mlib.c
+++ jdk/src/solaris/native/sun/awt/awt_Mlib.c
@@ -32,6 +32,7 @@
 #include <dlfcn.h>
 #include "jni.h"
 #include <jni_util.h>
+#include "jvm_md.h"
 #include "awt_Mlib.h"
 #include "java_awt_image_BufferedImage.h"
 
@@ -67,11 +68,11 @@
         ((strncmp(name.machine, "sun4v" , 5) == 0) &&
          (getenv("USE_VIS_ON_SUN4V") != NULL)))
     {
-        handle = dlopen("libmlib_image_v.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image_v"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
-        handle = dlopen("libmlib_image.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
--- jdk/src/solaris/native/sun/awt/awt_Robot.c
+++ jdk/src/solaris/native/sun/awt/awt_Robot.c
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
--- jdk/src/solaris/native/sun/awt/awt_util.h
+++ jdk/src/solaris/native/sun/awt/awt_util.h
@@ -187,15 +187,20 @@
 #ifdef __solaris__
 extern Widget awt_util_getXICStatusAreaWindow(Widget w);
 #else
+#if defined(_ALLBSD_SOURCE)
+int32_t awt_util_getIMStatusHeight(Widget vw);
+Widget awt_util_getXICStatusAreaWindow(Widget w);
+#else
 int32_t awt_util_getIMStatusHeight(Widget vw);
 XVaNestedList awt_util_getXICStatusAreaList(Widget w);
 Widget awt_util_getXICStatusAreaWindow(Widget w);
 #endif
+#endif
 
 
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct _XmImRefRec {
   Cardinal      num_refs;       /* Number of referencing widgets. */
   Cardinal      max_refs;       /* Maximum length of refs array. */
--- jdk/src/solaris/native/sun/awt/awt_wm.c
+++ jdk/src/solaris/native/sun/awt/awt_wm.c
@@ -121,12 +121,19 @@
 static Atom XA_KWM_WIN_MAXIMIZED;
 
 /* OpenLook */
+static Atom _XA_OL_DECOR_ADD;
 static Atom _XA_OL_DECOR_DEL;
 static Atom _XA_OL_DECOR_HEADER;
 static Atom _XA_OL_DECOR_RESIZE;
 static Atom _XA_OL_DECOR_PIN;
 static Atom _XA_OL_DECOR_CLOSE;
 
+/* AfterStep */
+static Atom _XA_AS_STYLE;
+
+/* WindowMaker */
+static Atom _XA_WINDOWMAKER_STATE;
+
 /* For _NET_WM_STATE ClientMessage requests */
 #define _NET_WM_STATE_REMOVE    0 /* remove/unset property */
 #define _NET_WM_STATE_ADD       1 /* add/set property      */
@@ -193,7 +200,12 @@
         { &_XA_OL_DECOR_HEADER,              "_OL_DECOR_HEADER"              },
         { &_XA_OL_DECOR_RESIZE,              "_OL_DECOR_RESIZE"              },
         { &_XA_OL_DECOR_PIN,                 "_OL_DECOR_PIN"                 },
-        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               }
+        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               },
+	{ &_XA_OL_DECOR_ADD,		     "_OL_DECOR_ADD"		     },
+
+	{ &_XA_AS_STYLE,		     "_XA_AS_STYLE"		     },
+
+	{ &_XA_WINDOWMAKER_STATE,	     "_XA_WINDOWMAKER_STATE"	     }
     };
 #define ATOM_LIST_LENGTH (sizeof(atom_list)/sizeof(atom_list[0]))
 
@@ -942,6 +954,39 @@
     return True;
 }
 
+/*
+ * Window Maker.
+ */
+static Boolean
+awt_wm_isWindowmaker()
+{
+    if (awt_wm_atomInterned(&_XA_WINDOWMAKER_STATE, "_WINDOWMAKER_STATE"))
+        return True;
+    return False;
+}
+
+/*
+ * Afterstep.
+ */
+static Boolean
+awt_wm_isAfterstep()
+{
+    if (awt_wm_atomInterned(&_XA_AS_STYLE, "_AS_STYLE"))
+        return True;
+    return False;
+}
+
+/*
+ * FVWM 2.
+ */
+static Boolean
+awt_wm_isFvwm2()
+{
+    if (awt_wm_atomInterned(&_XA_OL_DECOR_ADD, "_OL_DECOR_ADD")
+        && !awt_wm_atomInterned(&_XA_OL_DECOR_PIN, "_OL_DECOR_PIN"))
+        return True;
+    return False;
+}
 
 static Boolean
 awt_wm_isNetWMName(char *name)
@@ -1280,6 +1325,12 @@
     else if (awt_wm_isKDE2()) {
         awt_wmgr = KDE2_WM;
     }
+    else if (awt_wm_isWindowmaker()) {
+	awt_wmgr = WINDOWMAKER_WM;
+    }
+    else if (awt_wm_isAfterstep()) {
+	awt_wmgr = AFTERSTEP_WM;
+    }
     /*
      * We don't check for legacy WM when we already know that WM
      * supports WIN or _NET wm spec.
@@ -1302,6 +1353,9 @@
         awt_wmgr = MOTIF_WM;
     }
     else if (awt_wm_isOpenLook()) {
+	awt_wmgr = OPENLOOK_WM;
+    }
+    else if (awt_wm_isFvwm2()) {
         awt_wmgr = OPENLOOK_WM;
     }
     else {
--- jdk/src/solaris/native/sun/awt/awt_wm.h
+++ jdk/src/solaris/native/sun/awt/awt_wm.h
@@ -45,7 +45,10 @@
     KDE2_WM,
     SAWFISH_WM,
     ICE_WM,
-    METACITY_WM
+    METACITY_WM,
+    AFTERSTEP_WM,
+    WINDOWMAKER_WM,
+    FVWM2_WM
 };
 
 extern void awt_wm_init(void);
--- jdk/src/solaris/native/sun/awt/extutil.h
+++ jdk/src/solaris/native/sun/awt/extutil.h
@@ -58,7 +58,7 @@
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
--- jdk/src/solaris/native/sun/awt/fontpath.c
+++ jdk/src/solaris/native/sun/awt/fontpath.c
@@ -23,7 +23,7 @@
  * questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif /* __linux__ */
 #include <stdio.h>
@@ -40,6 +40,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <sun_font_FontManager.h>
 #ifndef HEADLESS
 #include <X11/Xlib.h>
@@ -58,10 +59,24 @@
 extern Display *awt_display;
 #endif /* !HEADLESS */
 
+#ifdef __APPLE__
+// XXXDARWIN: Hard-code the path to Apple's freetype, as it is
+// not included in the dyld search path by default, and 10.4
+// does not support -rpath.
+//
+// This ignores the build time setting of ALT_FREETYPE_LIB_PATH,
+// and should be replaced with -rpath/@rpath support on 10.5 or later,
+// or via support for a the FREETYPE_LIB_PATH define.
+#define FONTCONFIG_DLL_VERSIONED X11_PATH "/lib/" VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL X11_PATH "/lib/" JNI_LIB_NAME("fontconfig")
+#else
+#define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL JNI_LIB_NAME("fontconfig")
+#endif
 
 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 /*
  * This can be set in the makefile to "/usr/X11" if so desired.
  */
@@ -111,24 +126,40 @@
     NULL, /* terminates the list */
 };
 
+#elif _ALLBSD_SOURCE
+static char *fullBSDFontPath[] = {
+    X11_PATH "/lib/X11/fonts/TrueType",
+    X11_PATH "/lib/X11/fonts/truetype",
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/tt",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #else /* __linux */
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
  */
 static char *fullLinuxFontPath[] = {
-    "/usr/X11R6/lib/X11/fonts/TrueType",  /* RH 7.1+ */
-    "/usr/X11R6/lib/X11/fonts/truetype",  /* SuSE */
-    "/usr/X11R6/lib/X11/fonts/tt",
-    "/usr/X11R6/lib/X11/fonts/TTF",
-    "/usr/X11R6/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
-    "/usr/share/fonts/ja/TrueType",       /* RH 7.2+ */
-    "/usr/share/fonts/truetype",
-    "/usr/share/fonts/ko/TrueType",       /* RH 9.0 */
-    "/usr/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
-    "/usr/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/TrueType",  /* RH 7.1+ */
+    X11_PATH "/lib/X11/fonts/truetype",  /* SuSE */
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
+    PACKAGE_PATH "/share/fonts/ja/TrueType",       /* RH 7.2+ */
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/ko/TrueType",       /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
     "/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType", /* Debian */
-    "/usr/X11R6/lib/X11/fonts/Type1",
-    "/usr/share/fonts/default/Type1",     /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/default/Type1",     /* RH 9.0 */
     NULL, /* terminates the list */
 };
 #endif
@@ -351,7 +382,7 @@
 
 #endif /* !HEADLESS */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -476,8 +507,10 @@
      */
     fcdirs = getFontConfigLocations();
 
-#ifdef __linux__
+#if defined(__linux__)
     knowndirs = fullLinuxFontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #else /* IF SOLARIS */
     knowndirs = fullSolarisFontPath;
 #endif
@@ -488,7 +521,8 @@
      * be initialised.
      */
 #ifndef HEADLESS
-#ifdef __linux__        /* There's no headless build on linux ... */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    /* There's no headless build on linux ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
     AWT_LOCK();
@@ -496,7 +530,7 @@
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 #endif /* !HEADLESS */
@@ -608,7 +642,7 @@
 }
 
 #include <dlfcn.h>
-#ifndef __linux__ /* i.e. is solaris */
+#if !(defined(__linux__) || defined(__APPLE__))
 #include <link.h>
 #endif
 
@@ -654,9 +688,9 @@
      * certain symbols - and functionality - to be available.
      * Also add explicit search for .so.1 in case .so symlink doesn't exist.
      */
-    libfontconfig = dlopen("libfontconfig.so.1", RTLD_LOCAL|RTLD_LAZY);
+    libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);
     if (libfontconfig == NULL) {
-        libfontconfig = dlopen("libfontconfig.so", RTLD_LOCAL|RTLD_LAZY);
+        libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);
         if (libfontconfig == NULL) {
             return NULL;
         }
--- jdk/src/solaris/native/sun/awt/gtk2_interface.c
+++ jdk/src/solaris/native/sun/awt/gtk2_interface.c
@@ -30,8 +30,9 @@
 #include <string.h>
 #include "gtk2_interface.h"
 #include "java_awt_Transparency.h"
+#include "jvm_md.h"
 
-#define GTK2_LIB "libgtk-x11-2.0.so.0"
+#define GTK2_LIB VERSIONED_JNI_LIB_NAME("gtk-x11-2.0", "0")
 
 #define G_TYPE_INVALID                  G_TYPE_MAKE_FUNDAMENTAL (0)
 #define G_TYPE_NONE                     G_TYPE_MAKE_FUNDAMENTAL (1)
--- jdk/src/solaris/native/sun/awt/list.c
+++ jdk/src/solaris/native/sun/awt/list.c
@@ -66,7 +66,11 @@
   ----------------------------------------------------------------------- **/
 
 #include <stdio.h>
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "list.h"
 
 
--- jdk/src/solaris/native/sun/awt/robot_common.c
+++ jdk/src/solaris/native/sun/awt/robot_common.c
@@ -27,6 +27,9 @@
     #error This file should not be included in headless library
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#endif
 #include "robot_common.h"
 
 /*
--- jdk/src/solaris/native/sun/font/X11FontScaler.c
+++ jdk/src/solaris/native/sun/font/X11FontScaler.c
@@ -32,7 +32,11 @@
  * into X11FontScaler_md.c, which is compiled into another library.
  */
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <ctype.h>
 #include <sys/utsname.h>
 
--- jdk/src/solaris/native/sun/font/X11TextRenderer.c
+++ jdk/src/solaris/native/sun/font/X11TextRenderer.c
@@ -39,7 +39,11 @@
 #include "GraphicsPrimitiveMgr.h"
 #include "glyphblitting.h"
 #include "sunfontids.h"
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 
 JNIEXPORT void JNICALL AWTDrawGlyphList
--- jdk/src/solaris/native/sun/java2d/j2d_md.h
+++ jdk/src/solaris/native/sun/java2d/j2d_md.h
@@ -28,11 +28,11 @@
 #include <sys/types.h>
 
 /*
- * Linux version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's version of <sys/types.h> does not define intptr_t
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 typedef unsigned char   jubyte;
 typedef unsigned short  jushort;
--- jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c
+++ jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c
@@ -66,6 +66,10 @@
  *    MLIB_EDGE_SRC_PADDED
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include <mlib_image.h>
 #include <mlib_ImageZoom.h>
 
@@ -102,7 +106,7 @@
 
 /***************************************************************/
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -111,7 +115,7 @@
   0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
 };
 
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
@@ -120,7 +124,7 @@
   0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 /***************************************************************/
 
@@ -344,11 +348,11 @@
 #ifdef _NO_LONGLONG
 
 typedef struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   mlib_u32 uint1, uint0;
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
   mlib_u32 uint0, uint1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 } two_uint;
 
 /***************************************************************/
@@ -511,11 +515,11 @@
         DTYPE mask;
         MASK(mask);
         off *= 8;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         LSHIFT(dd_old, da[0], 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
         RSHIFT(dd_old, da[0], 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
@@ -540,30 +544,30 @@
 
           res = (res & 0xff) | (res >> 8);
           dd = gray_mask[res];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* *da++ = (dd_old >> (64 - off)) | (dd << off);*/
           RSHIFT(dd_old, dd_old, 64 - off);
           LSHIFT(dtmp, dd, off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* *da++ = (dd_old << (64 - off)) | (dd >> off);*/
           LSHIFT(dd_old, dd_old, 64 - off);
           RSHIFT(dtmp, dd, off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
           LOGIC(*da++, dd_old, dtmp, |);
           dd_old = dd;
         }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* da[0] = (dd_old >> (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) << off));*/
         LSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         RSHIFT(dtmp1, dd_old, 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* da[0] = (dd_old << (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) >> off));*/
         RSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         LSHIFT(dtmp1, dd_old, 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
         LOGIC(da[0], dtmp, dtmp1, |);
       }
       else {                                               /* aligned */
--- jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c
+++ jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c
@@ -794,7 +794,7 @@
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
--- jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h
+++ jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h
@@ -27,7 +27,10 @@
 #define OGLFuncs_md_h_Included
 
 #include <stdlib.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
+#include "jvm_md.h"
 #include "J2D_GL/glx.h"
 #include "OGLFuncMacros.h"
 
@@ -113,7 +116,7 @@
     { \
         char *libGLPath = getenv("J2D_ALT_LIBGL_PATH"); \
         if (libGLPath == NULL) { \
-            libGLPath = "libGL.so.1"; \
+            libGLPath = VERSIONED_JNI_LIB_NAME("GL", "1"); \
         } \
         OGL_LIB_HANDLE = dlopen(libGLPath, RTLD_LAZY | RTLD_LOCAL); \
     } \
--- jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c
+++ jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c
@@ -32,6 +32,7 @@
 #include "gdefs.h"
 
 #include "jni_util.h"
+#include "jvm_md.h"
 #include "awt_Component.h"
 #include "awt_GraphicsEnv.h"
 
@@ -128,7 +129,7 @@
 
     if (tryDGA && (getenv("NO_J2D_DGA") == NULL)) {
     /* we use RTLD_NOW because of bug 4032715 */
-        lib = dlopen("libsunwjdga.so", RTLD_NOW);
+        lib = dlopen(JNI_LIB_NAME("sunwjdga"), RTLD_NOW);
     }
     dgaAvailable = JNI_FALSE;
     if (lib != NULL) {
--- jdk/src/solaris/native/sun/jdga/dgalock.c
+++ jdk/src/solaris/native/sun/jdga/dgalock.c
@@ -44,6 +44,7 @@
 #include <X11/Xlib.h>
 
 #include "jni.h"
+#include "jvm_md.h"
 #include "jdga.h"
 #include "jdgadevice.h"
 
@@ -84,10 +85,10 @@
 static GetVirtualDrawableFunc * GetVirtualDrawable = GetVirtualDrawableStub;
 
 static void Solaris_DGA_XineramaInit(Display *display) {
-    void * handle = 0;
+    void * handle = NULL;
     if (IsXineramaOn == NULL) {
-        handle = dlopen("libxinerama.so", RTLD_NOW);
-        if (handle != 0) {
+        handle = dlopen(JNI_LIB_NAME("xinerama"), RTLD_NOW);
+        if (handle != NULL) {
             void *sym = dlsym(handle, "IsXineramaOn");
             IsXineramaOn = (IsXineramaOnFunc *)sym;
             if (IsXineramaOn != 0 && (*IsXineramaOn)(display)) {
--- jdk/src/solaris/native/sun/management/FileSystemImpl.c
+++ jdk/src/solaris/native/sun/management/FileSystemImpl.c
@@ -26,6 +26,10 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 #include "jni.h"
 #include "jni_util.h"
 #include "sun_management_FileSystemImpl.h"
--- jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c
+++ jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c
@@ -33,7 +33,7 @@
 #include <strings.h>
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif
 
--- jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c
+++ jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c
@@ -26,11 +26,12 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include "sun_net_spi_DefaultProxySelector.h"
 #include <dlfcn.h>
 #include <stdio.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #else
 #include <strings.h>
@@ -109,8 +110,9 @@
   /**
    * Let's try to load le GConf-2 library
    */
-  if (dlopen("libgconf-2.so", RTLD_GLOBAL | RTLD_LAZY) != NULL ||
-      dlopen("libgconf-2.so.4", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+  if (dlopen(JNI_LIB_NAME("gconf-2"), RTLD_GLOBAL | RTLD_LAZY) != NULL ||
+      dlopen(VERSIONED_JNI_LIB_NAME("gconf-2", "4"),
+             RTLD_GLOBAL | RTLD_LAZY) != NULL) {
     gconf_ver = 2;
   }
   if (gconf_ver > 0) {
--- jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c
+++ jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c
@@ -35,7 +35,7 @@
 #include <string.h>
 #include <errno.h>
 
-#if __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <netinet/in.h>
 #endif
 
@@ -86,7 +86,7 @@
     rv = connect(fd, 0, 0);
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     {
         int len;
         SOCKADDR sa;
@@ -96,17 +96,30 @@
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
 
         rv = connect(fd, (struct sockaddr *)&sa, len);
+
+#if defined(_ALLBSD_SOURCE)
+	if (rv < 0 && errno == EADDRNOTAVAIL)
+		rv = errno = 0;
+#endif
     }
 #endif
 
--- jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c
+++ jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c
@@ -72,7 +72,7 @@
     m.msg_accrightslen = 0;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     m.msg_control = NULL;
     m.msg_controllen = 0;
 #endif
@@ -120,7 +120,7 @@
     m.msg_accrightslen = 0;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     m.msg_control = NULL;
     m.msg_controllen = 0;
 #endif
--- jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c
+++ jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c
@@ -26,15 +26,21 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 #include "sun_nio_ch_FileChannelImpl.h"
 #include "java_lang_Integer.h"
 #include "nio.h"
 #include "nio_util.h"
 #include <dlfcn.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID chan_fd;        /* jobject 'fd' in sun.io.FileChannelImpl */
 
 #ifdef __solaris__
@@ -59,6 +65,24 @@
 typedef ssize_t sendfile64_func(int out_fd, int in_fd, off64_t *offset, size_t count);
 
 sendfile64_func* my_sendfile64_func = NULL;
+#elif defined(_ALLBSD_SOURCE)
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#ifdef __APPLE__
+typedef int sendfile_func(int fd, int s, off_t offset, off_t *len,
+                          struct sf_hdtr *hdtr, int flags);
+#elif defined(__FreeBSD__)
+typedef int sendfile_func(int fd, int s, off_t offset, size_t nbytes,
+                          struct sf_hdtr *hdtr, off_t *sbytes, int flags);
+#endif
+
+#if defined(__APPLE__) || defined(__FreeBSD__)
+sendfile_func* my_sendfile_func = NULL;
+#endif
 #endif
 
 JNIEXPORT jlong JNICALL
@@ -68,7 +92,8 @@
     chan_fd = (*env)->GetFieldID(env, clazz, "fd", "Ljava/io/FileDescriptor;");
 
 #ifdef __solaris__
-    if (dlopen("/usr/lib/libsendfile.so.1", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+    if (dlopen("/usr/lib/" VERSIONED_JNI_LIB_NAME("sendfile", "1"),
+               RTLD_GLOBAL | RTLD_LAZY) != NULL) {
         my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfilev64");
     }
 #endif
@@ -77,6 +102,10 @@
     my_sendfile64_func = (sendfile64_func*) dlsym(RTLD_DEFAULT, "sendfile64");
 #endif
 
+#if defined(__APPLE__) || defined(__FreeBSD__)
+    my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfile");
+#endif
+
     return pageSize;
 }
 
@@ -278,6 +307,48 @@
         return result;
     }
 #endif
+
+#ifdef _ALLBSD_SOURCE
+#if defined(__APPLE__) || defined(__FreeBSD__)
+    if (my_sendfile_func == NULL)
+        return IOS_UNSUPPORTED;
+
+    off_t numBytes;
+    int result;
+
+    numBytes = count;
+
+#ifdef __APPLE__
+    result = (*my_sendfile_func)(srcFD, dstFD, position,
+                                     &numBytes, NULL, 0);
+#elif defined(__FreeBSD__)
+    result = (*my_sendfile_func)(srcFD, dstFD, position,
+                                     count, NULL, &numBytes, 0);
+#else
+    Add an #elif for your BSD flavor
+#endif
+
+    if (numBytes > 0)
+        return numBytes;
+
+    if (result == -1) {
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)
+            return IOS_UNSUPPORTED_CASE;
+        if ((errno == EINVAL) && ((ssize_t)count >= 0))
+            return IOS_UNSUPPORTED_CASE;
+        if (errno == EINTR)
+            return IOS_INTERRUPTED;
+        JNU_ThrowIOExceptionWithLastError(env, "Transfer failed");
+        return IOS_THROWN;
+    }
+
+    return result;
+#else
+    return IOS_UNSUPPORTED;
+#endif
+#endif
 }
 
 JNIEXPORT jint JNICALL
@@ -329,6 +400,23 @@
     fl.l_start = (off64_t)pos;
     fl.l_type = F_UNLCK;
     lockResult = fcntl(fd, cmd, &fl);
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+    /* XXXFREEBSD:  While doing of preClose0() we're closing actual fd which
+       was locked, so here we'll get an error which need to be ignored to
+       satisfy TCK FileLock test */
+    /* XXXFREEBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EBADF)
+	lockResult = errno = 0;
+#endif
+#if defined(__NetBSD__)
+    /* XXXNETBSD: The dup2 in preClose0 is being done onto 1 end of a
+       socketpair which isn't a valid target for F_UNLCK. No good way to see
+       this vs. a bad lock setup so just return errno = 0 there
+       to pass JCK (lock will get removed once all fd's close anyways) */
+    /* XXXNETBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EINVAL)
+	lockResult = errno = 0;
+#endif
     if (lockResult < 0) {
         JNU_ThrowIOExceptionWithLastError(env, "Release failed");
     }
--- jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c
+++ jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c
@@ -32,8 +32,12 @@
 #include <sys/socket.h>
 #include <fcntl.h>
 #include <sys/uio.h>
+#include <unistd.h>
 #include "nio_util.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
 
 static int preCloseFD = -1;     /* File descriptor to which we dup other fd's
                                    before closing them for real */
--- jdk/src/solaris/native/sun/nio/ch/FileKey.c
+++ jdk/src/solaris/native/sun/nio/ch/FileKey.c
@@ -30,6 +30,10 @@
 #include "nio_util.h"
 #include "sun_nio_ch_FileKey.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID key_st_dev;    /* id for FileKey.st_dev */
 static jfieldID key_st_ino;    /* id for FileKey.st_ino */
 
--- jdk/src/solaris/native/sun/nio/ch/KqueueArrayWrapper.c	1969-12-31 19:00:00.000000000 -0500
+++ jdk/src/solaris/native/sun/nio/ch/KqueueArrayWrapper.c
@@ -0,0 +1,186 @@
+/*
+ * Scratched by davidxu@freebsd.org
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+
+#include "sun_nio_ch_KqueueArrayWrapper.h"
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static int
+restartable_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents);
+
+static int
+timeout_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents, int timo);
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_kqueue
+  (JNIEnv *env, jclass cls)
+{
+	int kqfd = kqueue();
+	if (kqfd < 0) {
+		JNU_ThrowIOExceptionWithLastError(env, "Error creating kqueue");
+		return -1;
+    	}
+	return kqfd;
+}
+
+JNIEXPORT void JNICALL Java_sun_nio_ch_KqueueArrayWrapper_register
+  (JNIEnv *env, jclass cls, jint kqfd, jint fd, jshort filter)
+{
+	struct kevent ev;
+	struct timespec ts;
+	
+	ev.ident = fd;
+	ev.filter = filter; 
+	ev.flags = EV_ADD; 
+	ev.fflags = 0;
+	ev.data = 0;  
+	ev.udata = NULL;
+	ts.tv_sec = 0;
+	ts.tv_nsec = 0;
+	if (kevent(kqfd, &ev, 1, NULL, 0, &ts) < 0) {
+		JNU_ThrowIOExceptionWithLastError(env, "Error register kqueue event");
+	}
+}
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_kevent
+  (JNIEnv *env, jclass cls, jint kqfd, jlong changelist_addr, jint nchanges,
+   jlong eventlist_addr, jint nevents, jlong timeout)
+{
+	struct kevent *changelist = (struct kevent *)jlong_to_ptr(changelist_addr);
+	struct kevent *eventlist = (struct kevent *)jlong_to_ptr(eventlist_addr);
+	int result;
+
+	if (timeout < 0) {
+		result = restartable_kevent(kqfd, changelist, nchanges,
+			eventlist, nevents);
+	} else {
+		result = timeout_kevent(kqfd, changelist, nchanges, eventlist,
+			nevents, timeout);
+	}
+
+	if (result < 0) {
+		JNU_ThrowIOExceptionWithLastError(env, "Error polling kevent");
+		return -1;
+	}
+	return result;
+}
+
+static int
+restartable_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents)
+{
+	int result;
+
+	for (;;) {
+		result = kevent(kqfd, changelist, nchanges, eventlist,
+			nevents, NULL);
+		if (result == -1 && errno == EINTR) {
+			continue;
+		} else {
+			return result;
+		}
+	}
+}
+
+static int
+timeout_kevent(int kqfd, struct kevent *changelist, int nchanges,
+	struct kevent *eventlist, int nevents, int timo)
+{
+	struct timeval timeout, now, end;
+	int result;
+
+	timeout.tv_sec = timo / 1000;
+	timeout.tv_usec = (timo % 1000) * 1000;
+	gettimeofday(&now, NULL);
+	timeradd(&now, &timeout, &end);
+
+	for (;;) {
+		struct timespec ts;
+		
+		ts.tv_sec = timeout.tv_sec;
+		ts.tv_nsec = timeout.tv_usec * 1000;
+		result = kevent(kqfd, changelist, nchanges, eventlist, nevents,
+			&ts);
+		if (result == -1 && (errno == EINTR)) {
+			gettimeofday(&now, NULL);
+			if (timercmp(&now, &end, >=))
+			    return 0;
+			timersub(&end, &now, &timeout);
+		} else {
+			return result;
+		}
+	}
+}
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_keventSize
+  (JNIEnv *env, jclass cls)
+{
+	return sizeof(struct kevent);
+}
+
+JNIEXPORT void JNICALL Java_sun_nio_ch_KqueueArrayWrapper_interrupt
+  (JNIEnv *env, jclass cls, jint fd)
+{
+	int fakebuf[1];
+
+	fakebuf[0] = 1;
+	if (write(fd, fakebuf, 1) < 0) {
+		JNU_ThrowIOExceptionWithLastError(env,
+                                          "Write to interrupt fd failed");
+	}
+}
+
+JNIEXPORT void JNICALL Java_sun_nio_ch_KqueueArrayWrapper_putKevent
+  (JNIEnv *env, jclass cls, jlong address, jint index, jint fd, jshort flags, jshort filter)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	ev[index].ident = fd;
+	ev[index].flags = flags;
+	ev[index].filter = filter;
+	ev[index].fflags = 0;
+	ev[index].data = 0;
+	ev[index].udata = NULL;
+}
+
+JNIEXPORT jshort JNICALL Java_sun_nio_ch_KqueueArrayWrapper_getKeventFilter
+  (JNIEnv *env, jclass cls, jlong address, jint index)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	return ev[index].filter;
+}
+
+JNIEXPORT jshort JNICALL Java_sun_nio_ch_KqueueArrayWrapper_getKeventFlags
+  (JNIEnv *env, jclass cls, jlong address, jint index)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	return ev[index].flags;
+}
+
+JNIEXPORT jint JNICALL Java_sun_nio_ch_KqueueArrayWrapper_getKeventIdent
+  (JNIEnv *env, jclass cls, jlong address, jint index)
+{
+	struct kevent *ev = (struct kevent *)jlong_to_ptr(address);
+
+	return (int)ev[index].ident;
+}
+
+#ifdef __cplusplus
+}
+#endif
--- jdk/src/solaris/native/sun/nio/ch/Net.c
+++ jdk/src/solaris/native/sun/nio/ch/Net.c
@@ -60,17 +60,33 @@
                             jboolean reuse)
 {
     int fd;
-
+    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);
 #ifdef AF_INET6
-    if (ipv6_available())
-        fd = socket(AF_INET6, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
-    else
-#endif /* AF_INET6 */
-        fd = socket(AF_INET, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
+    int domain = ipv6_available() ? AF_INET6 : AF_INET;
+#else
+    int domain = AF_INET;
+#endif
 
+    fd = socket(domain, type, 0);
     if (fd < 0) {
         return handleSocketError(env, errno);
     }
+
+#ifdef AF_INET6
+    /* Disable IPV6_V6ONLY to ensure dual-socket support */
+    if (domain == AF_INET6) {
+        int arg = 0;
+        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,
+                       sizeof(int)) < 0) {
+            JNU_ThrowByNameWithLastError(env,
+                                         JNU_JAVANETPKG "SocketException",
+                                         "sun.nio.ch.Net.setIntOption");
+            close(fd);
+            return -1;
+        }
+    }
+#endif
+
     if (reuse) {
         int arg = 1;
         if (NET_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,
@@ -138,10 +154,33 @@
 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
 {
     SOCKADDR sa;
-    int sa_len = SOCKADDR_LEN;
+    socklen_t sa_len = SOCKADDR_LEN;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+#ifdef _ALLBSD_SOURCE
+ /*
+  * XXXBSD:
+  * ECONNRESET is specific to the BSDs. We can not return an error,
+  * as the calling Java code with raise a java.lang.Error given the expectation
+  * that getsockname() will never fail. According to the Single UNIX Specification,
+  * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+  */
+ if (errno == ECONNRESET) {
+     struct sockaddr_in *sin;
+     sin = (struct sockaddr_in *) &sa;
+     bzero(sin, sizeof(*sin));
+     sin->sin_len  = sizeof(struct sockaddr_in);
+     sin->sin_family = AF_INET;
+     sin->sin_port = htonl(0);
+     sin->sin_addr.s_addr = INADDR_ANY;
+ } else {
+     handleSocketError(env, errno);
+     return -1;
+ }
+#else /* _ALLBSD_SOURCE */
         handleSocketError(env, errno);
         return -1;
+#endif /* _ALLBSD_SOURCE */
+
     }
     return NET_GetPortFromSockaddr((struct sockaddr *)&sa);
 }
@@ -150,15 +189,79 @@
 Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
 {
     SOCKADDR sa;
-    int sa_len = SOCKADDR_LEN;
+    socklen_t sa_len = SOCKADDR_LEN;
     int port;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
-        handleSocketError(env, errno);
-        return NULL;
+#ifdef _ALLBSD_SOURCE
+ /*
+  * XXXBSD:
+  * ECONNRESET is specific to the BSDs. We can not return an error,
+  * as the calling Java code with raise a java.lang.Error with the expectation
+  * that getsockname() will never fail. According to the Single UNIX Specification,
+  * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+  */
+ if (errno == ECONNRESET) {
+     struct sockaddr_in *sin;
+     sin = (struct sockaddr_in *) &sa;
+     bzero(sin, sizeof(*sin));
+     sin->sin_len  = sizeof(struct sockaddr_in);
+     sin->sin_family = AF_INET;
+     sin->sin_port = htonl(0);
+     sin->sin_addr.s_addr = INADDR_ANY;
+ } else {
+     handleSocketError(env, errno);
+     return NULL;
+ }
+#else /* _ALLBSD_SOURCE */
+          handleSocketError(env, errno);
+          return NULL;
+#endif /* _ALLBSD_SOURCE */
+
     }
     return NET_SockaddrToInetAddress(env, (struct sockaddr *)&sa, &port);
 }
 
+#ifdef _ALLBSD_SOURCE
+
+#ifndef IP_BLOCK_SOURCE
+
+#define IP_ADD_SOURCE_MEMBERSHIP        70   /* join a source-specific group */
+#define IP_DROP_SOURCE_MEMBERSHIP       71   /* drop a single source */
+#define IP_BLOCK_SOURCE                 72   /* block a source */
+#define IP_UNBLOCK_SOURCE               73   /* unblock a source */
+
+#endif  /* IP_BLOCK_SOURCE */
+
+#ifndef MCAST_BLOCK_SOURCE
+
+#define MCAST_JOIN_SOURCE_GROUP         82   /* join a source-specific group */
+#define MCAST_LEAVE_SOURCE_GROUP        83   /* leave a single source */
+#define MCAST_BLOCK_SOURCE              84   /* block a source */
+#define MCAST_UNBLOCK_SOURCE            85   /* unblock a source */
+
+#endif /* MCAST_BLOCK_SOURCE */
+
+#ifndef IPV6_ADD_MEMBERSHIP
+
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+
+#endif /* IPV6_ADD_MEMBERSHIP */
+
+struct my_ip_mreq_source {
+        struct in_addr  imr_multiaddr;
+        struct in_addr  imr_interface;
+        struct in_addr  imr_sourceaddr;
+};
+
+struct my_group_source_req {
+        uint32_t                gsr_interface;  /* interface index */
+        struct sockaddr_storage gsr_group;      /* group address */
+        struct sockaddr_storage gsr_source;     /* source address */
+};
+
+#endif   /* _ALLBSD_SOURCE */
+
 
 #ifdef NEEDED
 
@@ -304,9 +407,11 @@
     switch (errorValue) {
         case EINPROGRESS:       /* Non-blocking connect */
             return 0;
+#ifdef EPROTO
         case EPROTO:
             xn = JNU_JAVANETPKG "ProtocolException";
             break;
+#endif
         case ECONNREFUSED:
             xn = JNU_JAVANETPKG "ConnectException";
             break;
--- jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c
+++ jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c
@@ -26,7 +26,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 #include "NativeFunc.h"
 
 /* standard GSS method names (ordering is from mapfile) */
--- jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c
+++ jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c
@@ -28,12 +28,19 @@
 #include <string.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni_util.h>
 
 #include "j2secmod.h"
 
+#ifndef RTLD_NOLOAD
+/* A gross hack that will work if the NSS library is only opened once */
+static void *nssLibHandle = NULL;
+#endif
+
 void *findFunction(JNIEnv *env, jlong jHandle, const char *functionName) {
     void *hModule = (void*)jHandle;
     void *fAddress = dlsym(hModule, functionName);
@@ -51,7 +58,11 @@
 {
     const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);
     // look up existing handle only, do not load
+#ifdef RTLD_NOLOAD
     void *hModule = dlopen(libName, RTLD_NOLOAD);
+#else
+    void *hModule = nssLibHandle;
+#endif
     dprintf2("-handle for %s: %u\n", libName, hModule);
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     return (jlong)hModule;
@@ -65,6 +76,9 @@
 
     dprintf1("-lib %s\n", libName);
     hModule = dlopen(libName, RTLD_LAZY);
+#ifndef RTLD_NOLOAD
+    nssLibHandle = hModule;
+#endif
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     dprintf2("-handle: %u (0X%X)\n", hModule, hModule);
 
--- jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c
+++ jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c
@@ -64,7 +64,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni.h>
 
--- jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c
+++ jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c
@@ -29,7 +29,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <winscard.h>
 
--- jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c
+++ jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c
@@ -35,10 +35,10 @@
 #include <dirent.h>
 #include <ctype.h>
 #include <sys/types.h>
-#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/un.h>
+#include <fcntl.h>
 
 #include "sun_tools_attach_BsdVirtualMachine.h"
 
@@ -49,85 +49,6 @@
 } while(0)
 
 /*
- * Defines a callback that is invoked for each process
- */
-typedef void (*ProcessCallback)(const pid_t pid, void* user_data);
-
-/*
- * Invokes the callback function for each process
- */
-static void forEachProcess(ProcessCallback f, void* user_data) {
-    DIR* dir;
-    struct dirent* ptr;
-
-    /*
-     * To locate the children we scan /proc looking for files that have a
-     * position integer as a filename.
-     */
-    if ((dir = opendir("/proc")) == NULL) {
-        return;
-    }
-    while ((ptr = readdir(dir)) != NULL) {
-        pid_t pid;
-
-        /* skip current/parent directories */
-        if (strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0) {
-            continue;
-        }
-
-        /* skip files that aren't numbers */
-        pid = (pid_t)atoi(ptr->d_name);
-        if ((int)pid <= 0) {
-            continue;
-        }
-
-        /* invoke the callback */
-        (*f)(pid, user_data);
-    }
-    closedir(dir);
-}
-
-
-/*
- * Returns the parent pid of a given pid, or -1 if not found
- */
-static pid_t getParent(pid_t pid) {
-    char state;
-    FILE* fp;
-    char stat[2048];
-    int statlen;
-    char fn[32];
-    int i, p;
-    char* s;
-
-    /*
-     * try to open /proc/%d/stat
-     */
-    sprintf(fn, "/proc/%d/stat", pid);
-    fp = fopen(fn, "r");
-    if (fp == NULL) {
-        return -1;
-    }
-
-    /*
-     * The format is: pid (command) state ppid ...
-     * As the command could be anything we must find the right most
-     * ")" and then skip the white spaces that follow it.
-     */
-    statlen = fread(stat, 1, 2047, fp);
-    stat[statlen] = '\0';
-    fclose(fp);
-    s = strrchr(stat, ')');
-    if (s == NULL) {
-        return -1;
-    }
-    do s++; while (isspace(*s));
-    i = sscanf(s, "%c %d", &state, &p);
-    return (pid_t)p;
-}
-
-
-/*
  * Class:     sun_tools_attach_BsdVirtualMachine
  * Method:    socket
  * Signature: ()I
@@ -188,146 +109,6 @@
 
 /*
  * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    isBsdThreads
- * Signature: ()V
- */
-JNIEXPORT jboolean JNICALL Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads
-  (JNIEnv *env, jclass cls)
-{
-# ifndef _CS_GNU_LIBPTHREAD_VERSION
-# define _CS_GNU_LIBPTHREAD_VERSION 3
-# endif
-    size_t n;
-    char* s;
-    jboolean res;
-
-    n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-    if (n <= 0) {
-       /* glibc before 2.3.2 only has BsdThreads */
-       return JNI_TRUE;
-    }
-
-    s = (char *)malloc(n);
-    if (s == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "malloc failed");
-        return JNI_TRUE;
-    }
-    confstr(_CS_GNU_LIBPTHREAD_VERSION, s, n);
-
-    /*
-     * If the LIBPTHREAD version include "NPTL" then we know we
-     * have the new threads library and not BsdThreads
-     */
-    res = (jboolean)(strstr(s, "NPTL") == NULL);
-    free(s);
-    return res;
-}
-
-/*
- * Structure and callback function used to count the children of
- * a given process, and record the pid of the "manager thread".
- */
-typedef struct {
-    pid_t ppid;
-    int count;
-    pid_t mpid;
-} ChildCountContext;
-
-static void ChildCountCallback(const pid_t pid, void* user_data) {
-    ChildCountContext* context = (ChildCountContext*)user_data;
-    if (getParent(pid) == context->ppid) {
-        context->count++;
-        /*
-         * Remember the pid of the first child. If the final count is
-         * one then this is the pid of the BsdThreads manager.
-         */
-        if (context->count == 1) {
-            context->mpid = pid;
-        }
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    getBsdThreadsManager
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    ChildCountContext context;
-
-    /*
-     * Iterate over all processes to find how many children 'pid' has
-     */
-    context.ppid = pid;
-    context.count = 0;
-    context.mpid = (pid_t)0;
-    forEachProcess(ChildCountCallback, (void*)&context);
-
-    /*
-     * If there's no children then this is likely the pid of the primordial
-     * created by the launcher - in that case the BsdThreads manager is the
-     * parent of this process.
-     */
-    if (context.count == 0) {
-        pid_t parent = getParent(pid);
-        if ((int)parent > 0) {
-            return (jint)parent;
-        }
-    }
-
-    /*
-     * There's one child so this is likely the embedded VM case where the
-     * the primordial thread == BsdThreads initial thread. The BsdThreads
-     * manager in that case is the child.
-     */
-    if (context.count == 1) {
-        return (jint)context.mpid;
-    }
-
-    /*
-     * If we get here it's most likely we were given the wrong pid
-     */
-    JNU_ThrowIOException(env, "Unable to get pid of BsdThreads manager thread");
-    return -1;
-}
-
-/*
- * Structure and callback function used to send a QUIT signal to all
- * children of a given process
- */
-typedef struct {
-    pid_t ppid;
-} SendQuitContext;
-
-static void SendQuitCallback(const pid_t pid, void* user_data) {
-    SendQuitContext* context = (SendQuitContext*)user_data;
-    pid_t parent = getParent(pid);
-    if (parent == context->ppid) {
-        kill(pid, SIGQUIT);
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    sendQuitToChildrenOf
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    SendQuitContext context;
-    context.ppid = (pid_t)pid;
-
-    /*
-     * Iterate over all children of 'pid' and send a QUIT signal to each.
-     */
-    forEachProcess(SendQuitCallback, (void*)&context);
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
  * Method:    sendQuitTo
  * Signature: (I)V
  */
@@ -350,7 +131,7 @@
     jboolean isCopy;
     const char* p = GetStringPlatformChars(env, path, &isCopy);
     if (p != NULL) {
-        struct stat64 sb;
+        struct stat sb;
         uid_t uid, gid;
         int res;
 
@@ -361,7 +142,7 @@
         uid = geteuid();
         gid = getegid();
 
-        res = stat64(p, &sb);
+        res = stat(p, &sb);
         if (res != 0) {
             /* save errno */
             res = errno;
@@ -459,3 +240,40 @@
 
     } while (remaining > 0);
 }
+
+/*
+ * Class:     sun_tools_attach_BSDVirtualMachine
+ * Method:    createAttachFile
+ * Signature: (Ljava.lang.String;)V
+ */
+JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_createAttachFile(JNIEnv *env, jclass cls, jstring path)
+{
+    const char* _path;
+    jboolean isCopy;
+    int fd, rc;
+
+    _path = GetStringPlatformChars(env, path, &isCopy);
+    if (_path == NULL) {
+        JNU_ThrowIOException(env, "Must specify a path");
+        return;
+    }
+
+    RESTARTABLE(open(_path, O_CREAT | O_EXCL, S_IWUSR | S_IRUSR), fd);
+    if (fd == -1) {
+        /* release p here before we throw an I/O exception */
+        if (isCopy) {
+            JNU_ReleaseStringPlatformChars(env, path, _path);
+        }
+        JNU_ThrowIOExceptionWithLastError(env, "open");
+        return;
+    }
+
+    RESTARTABLE(chown(_path, geteuid(), getegid()), rc);
+
+    RESTARTABLE(close(fd), rc);
+
+    /* release p here */
+    if (isCopy) {
+        JNU_ReleaseStringPlatformChars(env, path, _path);
+    }
+}
--- jdk/src/solaris/native/sun/xawt/XWindow.c
+++ jdk/src/solaris/native/sun/xawt/XWindow.c
@@ -228,10 +228,10 @@
     {java_awt_event_KeyEvent_VK_DOWN, XK_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
 
     /* Keypad equivalents of Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_KP_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
 
     /* Other vendor-specific Triangular Navigation Block */
     {java_awt_event_KeyEvent_VK_LEFT, osfXK_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
@@ -865,7 +865,7 @@
 {
     KeySym originalKeysym = *keysym;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
--- jdk/src/solaris/native/sun/xawt/awt_Desktop.c
+++ jdk/src/solaris/native/sun/xawt/awt_Desktop.c
@@ -24,6 +24,7 @@
  */
 
 #include <jni.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 
 typedef int gboolean;
@@ -36,7 +37,7 @@
     gboolean (*gnome_vfs_init) (void);
     const char *errmsg;
 
-    vfs_handle = dlopen("libgnomevfs-2.so.0", RTLD_LAZY);
+    vfs_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnomevfs-2", "0"), RTLD_LAZY);
     if (vfs_handle == NULL) {
 #ifdef INTERNAL_BUILD
         fprintf(stderr, "can not load libgnomevfs-2.so\n");
@@ -54,7 +55,7 @@
     // call gonme_vfs_init()
     (*gnome_vfs_init)();
 
-    gnome_handle = dlopen("libgnome-2.so.0", RTLD_LAZY);
+    gnome_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnome-2", "0"), RTLD_LAZY);
     if (gnome_handle == NULL) {
 #ifdef INTERNAL_BUILD
         fprintf(stderr, "can not load libgnome-2.so\n");
--- jdk/src/solaris/npt/npt_md.h
+++ jdk/src/solaris/npt/npt_md.h
@@ -32,9 +32,10 @@
 #include <string.h>
 #include <errno.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
-
-#define NPT_LIBNAME "libnpt.so"
+#endif
+#include <jvm_md.h>
 
 #define NPT_INITIALIZE(pnpt,version,options)                            \
     {                                                                   \
@@ -43,7 +44,7 @@
                                                                         \
         if ( (pnpt) == NULL ) NPT_ERROR("NptEnv* is NULL");             \
         *(pnpt) = NULL;                                                 \
-        _handle =  dlopen(NPT_LIBNAME, RTLD_LAZY);                      \
+        _handle =  dlopen(JNI_LIB_NAME("npt"), RTLD_LAZY);              \
         if ( _handle == NULL ) NPT_ERROR("Cannot open library");        \
         _sym = dlsym(_handle, "nptInitialize");                         \
         if ( _sym == NULL ) NPT_ERROR("Cannot find nptInitialize");     \
--- jdk/src/solaris/transport/socket/socket_md.c
+++ jdk/src/solaris/transport/socket/socket_md.c
@@ -36,7 +36,7 @@
 #ifdef __solaris__
 #include <thread.h>
 #endif
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #include <sys/poll.h>
 #endif
@@ -283,7 +283,7 @@
 
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 int
 dbgsysTlsAlloc() {
     pthread_key_t key;
--- langtools/src/share/classes/com/sun/tools/javah/Util.java
+++ langtools/src/share/classes/com/sun/tools/javah/Util.java
@@ -180,6 +180,14 @@
             os = "win32";
         } else if (os.indexOf("Linux") >= 0) {
             os = "Linux";
+	} else if (os.indexOf("FreeBSD") >= 0) {
+	    os = "FreeBSD";
+	} else if (os.indexOf("Darwin") >= 0) {
+	    os = "Darwin";
+	} else if (os.indexOf("NetBSD") >= 0) {
+	    os = "NetBSD";
+	} else if (os.indexOf("OpenBSD") >= 0) {
+	    os = "OpenBSD";
         }
         String arch = System.getProperty("os.arch");
         String resname = "com.sun.tools.javah.resources." + os + "_" + arch;
