# HG changeset patch
# User coffeys
# Date 1354992561 0
# Node ID c5203e9e0e07559914a9c46dbba4fe85df945624
# Parent  7f904eacf818c104549b94b957f34896a8548d9b
8000631: Restrict access to class constructor
Reviewed-by: alanb, ahgross

diff --git a/make/com/sun/corba/minclude/com_sun_corba_se_impl_orbutil.jmk b/make/com/sun/corba/minclude/com_sun_corba_se_impl_orbutil.jmk
--- corba/make/com/sun/corba/minclude/com_sun_corba_se_impl_orbutil.jmk
+++ corba/make/com/sun/corba/minclude/com_sun_corba_se_impl_orbutil.jmk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -29,10 +29,6 @@ com_sun_corba_se_impl_orbutil_java = \
 	com/sun/corba/se/impl/orbutil/DenseIntMapImpl.java \
 	com/sun/corba/se/impl/orbutil/GetPropertyAction.java \
 	com/sun/corba/se/impl/orbutil/HexOutputStream.java \
-	com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java \
-	com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java \
-	com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java \
 	com/sun/corba/se/impl/orbutil/LegacyHookGetFields.java \
 	com/sun/corba/se/impl/orbutil/LegacyHookPutFields.java \
 	com/sun/corba/se/impl/orbutil/LogKeywords.java \
@@ -45,19 +41,11 @@ com_sun_corba_se_impl_orbutil_java = \
 	com/sun/corba/se/impl/orbutil/ORBUtility.java \
 	com/sun/corba/se/impl/orbutil/ORBClassLoader.java \
 	com/sun/corba/se/impl/orbutil/RepIdDelegator.java \
-	com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java \
-	com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java \
-	com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdStrings.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdUtility.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdInterface.java \
-	com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java \
 	com/sun/corba/se/impl/orbutil/StackImpl.java \
-	com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java \
 	com/sun/corba/se/impl/orbutil/closure/Future.java \
 	com/sun/corba/se/impl/orbutil/closure/Constant.java \
 	com/sun/corba/se/impl/orbutil/concurrent/Sync.java \
diff --git a/src/share/classes/com/sun/corba/se/impl/corba/AnyImpl.java b/src/share/classes/com/sun/corba/se/impl/corba/AnyImpl.java
--- corba/src/share/classes/com/sun/corba/se/impl/corba/AnyImpl.java
+++ corba/src/share/classes/com/sun/corba/se/impl/corba/AnyImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1218,7 +1218,7 @@ public class AnyImpl extends Any
         // See bug 4391648 for more info about the tcORB in this
         // case.
         RepositoryIdStrings repStrs
-            = RepositoryIdFactory.getRepIdStringsFactory(tcORB);
+            = RepositoryIdFactory.getRepIdStringsFactory();
 
 
         // Assertion: c instanceof Serializable?
@@ -1251,7 +1251,7 @@ public class AnyImpl extends Any
         // Anything else
         // We know that this is a TypeCodeImpl since it is our ORB
         classTC = (TypeCodeImpl)ValueUtility.createTypeCodeForClass(
-            tcORB, c, ORBUtility.createValueHandler(tcORB));
+            tcORB, c, ORBUtility.createValueHandler());
         // Intruct classTC to store its buffer
         classTC.setCaching(true);
         // Update the cache
diff --git a/src/share/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java b/src/share/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java
--- corba/src/share/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java
+++ corba/src/share/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -269,8 +269,8 @@ public class CDRInputStream_1_0 extends 
 
     private final void createRepositoryIdHandlers()
     {
-        repIdUtil = RepositoryIdFactory.getRepIdUtility(orb);
-        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory(orb);
+        repIdUtil = RepositoryIdFactory.getRepIdUtility();
+        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
     }
 
     public GIOPVersion getGIOPVersion() {
@@ -564,10 +564,7 @@ public class CDRInputStream_1_0 extends 
 
         checkForNegativeLength(len);
 
-        if (orb != null && ORBUtility.isLegacyORB((ORB)orb))
-            return legacyReadString(len);
-        else
-            return internalReadString(len);
+        return internalReadString(len);
     }
 
     private final String internalReadString(int len) {
@@ -586,54 +583,6 @@ public class CDRInputStream_1_0 extends 
         read_octet();
 
         return new String(result, 0, getCharConverter().getNumChars());
-    }
-
-    private final String legacyReadString(int len) {
-
-        //
-        // Workaround for ORBs which send string lengths of
-        // zero to mean empty string.
-        //
-        //
-        // IMPORTANT: Do not replace 'new String("")' with "", it may result
-        // in a Serialization bug (See serialization.zerolengthstring) and
-        // bug id: 4728756 for details
-        if (len == 0)
-            return new String("");
-
-        len--;
-        char[] c = new char[len];
-
-        int n = 0;
-        while (n < len) {
-            int avail;
-            int bytes;
-            int wanted;
-
-            avail = bbwi.buflen - bbwi.position();
-            if (avail <= 0) {
-                grow(1, 1);
-                avail = bbwi.buflen - bbwi.position();
-            }
-            wanted = len - n;
-            bytes = (wanted < avail) ? wanted : avail;
-            // Microbenchmarks are showing a loop of ByteBuffer.get(int) being
-            // faster than ByteBuffer.get(byte[], int, int).
-            for (int i=0; i<bytes; i++) {
-                c[n+i] = (char) (bbwi.byteBuffer.get(bbwi.position()+i) & 0xFF);
-            }
-            bbwi.position(bbwi.position() + bytes);
-            n += bytes;
-        }
-
-        //
-        // Skip past terminating null byte
-        //
-        if (bbwi.position() + 1 > bbwi.buflen)
-            alignAndCheck(1, 1);
-        bbwi.position(bbwi.position() + 1);
-
-        return new String(c);
     }
 
     public final String read_string() {
@@ -1045,7 +994,7 @@ public class CDRInputStream_1_0 extends 
 
                 try {
                     if (valueHandler == null)
-                        valueHandler = ORBUtility.createValueHandler(orb);
+                        valueHandler = ORBUtility.createValueHandler();
 
                     value = valueHandler.readValue(parent,
                                                    indirection,
diff --git a/src/share/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java b/src/share/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java
--- corba/src/share/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java
+++ corba/src/share/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -189,18 +189,8 @@ public class CDROutputStream_1_0 extends
 
     private final void createRepositoryIdHandlers()
     {
-        if (orb != null) {
-            // Get the appropriate versions based on the ORB version.  The
-            // ORB versioning info is only in the core ORB.
-            repIdUtil
-                = RepositoryIdFactory.getRepIdUtility(orb);
-            repIdStrs
-                = RepositoryIdFactory.getRepIdStringsFactory(orb);
-        } else {
-            // Get the latest versions
-            repIdUtil = RepositoryIdFactory.getRepIdUtility();
-            repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
-        }
+        repIdUtil = RepositoryIdFactory.getRepIdUtility();
+        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
     }
 
     public BufferManagerWrite getBufferManager()
@@ -705,7 +695,7 @@ public class CDROutputStream_1_0 extends
     private void writeArray(Serializable array, Class clazz) {
 
         if (valueHandler == null)
-            valueHandler = ORBUtility.createValueHandler(orb); //d11638
+            valueHandler = ORBUtility.createValueHandler(); //d11638
 
         // Write value_tag
         int indirection = writeValueTag(mustChunk, true,
@@ -768,7 +758,7 @@ public class CDROutputStream_1_0 extends
 
     private void writeRMIIIOPValueType(Serializable object, Class clazz) {
         if (valueHandler == null)
-            valueHandler = ORBUtility.createValueHandler(orb); //d11638
+            valueHandler = ORBUtility.createValueHandler(); //d11638
 
         Serializable key = object;
 
diff --git a/src/share/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java b/src/share/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java
--- corba/src/share/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java
+++ corba/src/share/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -86,7 +86,7 @@ public class FVDCodeBaseImpl extends _Co
             // default to using the current ORB version in case the
             // vhandler is not set
             if (vhandler == null) {
-                vhandler = new ValueHandlerImpl(false);
+                vhandler = ValueHandlerImpl.getInstance(false);
             }
 
             // Util.getCodebase may return null which would
@@ -120,7 +120,7 @@ public class FVDCodeBaseImpl extends _Co
                 // default to using the current ORB version in case the
                 // vhandler is not set
                 if (vhandler == null) {
-                    vhandler = new ValueHandlerImpl(false);
+                    vhandler = ValueHandlerImpl.getInstance(false);
                 }
 
                 try{
@@ -161,7 +161,7 @@ public class FVDCodeBaseImpl extends _Co
             // default to using the current ORB version in case the
             // vhandler is not set
             if (vhandler == null) {
-                vhandler = new ValueHandlerImpl(false);
+                vhandler = ValueHandlerImpl.getInstance(false);
             }
 
             Stack repIds = new Stack();
diff --git a/src/share/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.java b/src/share/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.java
--- corba/src/share/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.java
+++ corba/src/share/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -53,7 +53,7 @@ import com.sun.corba.se.impl.logging.OMG
 import com.sun.corba.se.impl.logging.OMGSystemException;
 import com.sun.corba.se.impl.logging.UtilSystemException;
 
-public class ValueHandlerImpl implements javax.rmi.CORBA.ValueHandlerMultiFormat {
+public final class ValueHandlerImpl implements javax.rmi.CORBA.ValueHandlerMultiFormat {
 
     // Property to override our maximum stream format version
     public static final String FORMAT_VERSION_PROPERTY
@@ -150,12 +150,20 @@ public class ValueHandlerImpl implements
         writeValueWithVersion(out, value, streamFormatVersion);
     }
 
-    public ValueHandlerImpl(){}
+    private ValueHandlerImpl(){}
 
-    public ValueHandlerImpl(boolean isInputStream) {
+    private ValueHandlerImpl(boolean isInputStream) {
         this();
         useHashtables = false;
         this.isInputStream = isInputStream;
+    }
+
+    static ValueHandlerImpl getInstance() {
+        return new ValueHandlerImpl();
+    }
+
+    static ValueHandlerImpl getInstance(boolean isInputStream) {
+        return new ValueHandlerImpl(isInputStream);
     }
 
     /**
@@ -458,12 +466,7 @@ public class ValueHandlerImpl implements
         return ObjectStreamClass.lookup(value.getClass()).writeReplace(value);
     }
 
-    /**
-     * Encapsulates writing of Java char arrays so that the 1.3 subclass
-     * can override it without exposing internals across packages.  This
-     * is a fix for bug 4367783.
-     */
-    protected void writeCharArray(org.omg.CORBA_2_3.portable.OutputStream out,
+    private void writeCharArray(org.omg.CORBA_2_3.portable.OutputStream out,
                                 char[] array,
                                 int offset,
                                 int length)
@@ -576,12 +579,7 @@ public class ValueHandlerImpl implements
         }
     }
 
-    /**
-     * Encapsulates reading of Java char arrays so that the 1.3 subclass
-     * can override it without exposing internals across packages.  This
-     * is a fix for bug 4367783.
-     */
-    protected void readCharArray(org.omg.CORBA_2_3.portable.InputStream in,
+    private void readCharArray(org.omg.CORBA_2_3.portable.InputStream in,
                                  char[] array,
                                  int offset,
                                  int length)
@@ -795,7 +793,7 @@ public class ValueHandlerImpl implements
         return RepositoryId.cache.getId(repId).isSequence();
     }
 
-    protected String getOutputStreamClassName() {
+    private String getOutputStreamClassName() {
         return "com.sun.corba.se.impl.io.IIOPOutputStream";
     }
 
@@ -843,29 +841,11 @@ public class ValueHandlerImpl implements
     private IIOPOutputStream createOutputStreamBuiltInNoPriv(
         final String name
     ) throws IOException {
-        return 
-            name.equals(
-                IIOPOutputStream
-                    .class.getName()
-            ) ?
-            new IIOPOutputStream() :
-
-            name.equals(
-                com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3
-                    .class.getName()
-            ) ?
-            new com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3() :
-
-            name.equals(
-                com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3_1
-                    .class.getName()
-            ) ?
-            new com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3_1() :
-
-            null;
+        return name.equals(IIOPOutputStream.class.getName()) ?
+                new IIOPOutputStream() : null;
     }
 
-    protected String getInputStreamClassName() {
+    private String getInputStreamClassName() {
         return "com.sun.corba.se.impl.io.IIOPInputStream";
     }
 
@@ -913,26 +893,8 @@ public class ValueHandlerImpl implements
      private IIOPInputStream createInputStreamBuiltInNoPriv(
          final String name
      ) throws IOException {
-         return 
-             name.equals(
-                 IIOPInputStream
-                     .class.getName()
-             ) ?
-             new IIOPInputStream() :
- 
-             name.equals(
-                 com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3
-                     .class.getName()
-             ) ?
-             new com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3() :
- 
-             name.equals(
-                 com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3_1
-                     .class.getName()
-             ) ?
-             new com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3_1() :
- 
-             null;
+         return name.equals(IIOPInputStream.class.getName()) ?
+                new IIOPInputStream() : null;
      }
 
      /**
@@ -958,12 +920,7 @@ public class ValueHandlerImpl implements
 
     }
 
-    /**
-     * Our JDK 1.3 and JDK 1.3.1 behavior subclasses override this.
-     * The correct behavior is for a Java char to map to a CORBA wchar,
-     * but our older code mapped it to a CORBA char.
-     */
-    protected TCKind getJavaCharTCKind() {
+    TCKind getJavaCharTCKind() {
         return TCKind.tk_wchar;
     }
 }
diff --git a/src/share/classes/com/sun/corba/se/impl/io/ValueUtility.java b/src/share/classes/com/sun/corba/se/impl/io/ValueUtility.java
--- corba/src/share/classes/com/sun/corba/se/impl/io/ValueUtility.java
+++ corba/src/share/classes/com/sun/corba/se/impl/io/ValueUtility.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -92,6 +92,14 @@ public class ValueUtility {
         null,       // tk_native       31
         null,       // tk_abstract_interface 32
     };
+
+    static {
+        sun.corba.SharedSecrets.setJavaCorbaAccess(new sun.corba.JavaCorbaAccess() {
+            public ValueHandlerImpl newValueHandlerImpl() {
+                return ValueHandlerImpl.getInstance();
+            }
+        });
+    }
 
     public static String getSignature(ValueMember member)
         throws ClassNotFoundException {
diff --git a/src/share/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.java b/src/share/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.java
--- corba/src/share/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.java
+++ corba/src/share/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.java
@@ -112,6 +112,9 @@ import com.sun.corba.se.impl.orbutil.ORB
 import com.sun.corba.se.impl.orbutil.ORBClassLoader;
 import com.sun.corba.se.impl.logging.UtilSystemException;
 import com.sun.corba.se.spi.logging.CORBALogDomains;
+import sun.corba.SharedSecrets;
+import sun.corba.JavaCorbaAccess;
+
 
 /**
  * Provides utility methods that can be used by stubs and ties to
@@ -125,7 +128,8 @@ public class Util implements javax.rmi.C
     // Maps targets to ties.
     private static IdentityHashtable exportedServants = new IdentityHashtable();
 
-    private static ValueHandlerImpl valueHandlerSingleton = new ValueHandlerImpl();
+    private static final ValueHandlerImpl valueHandlerSingleton =
+        SharedSecrets.getJavaCorbaAccess().newValueHandlerImpl();
 
     private UtilSystemException utilWrapper = UtilSystemException.get(
                                                   CORBALogDomains.RPC_ENCODING);
diff --git a/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java b/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java
--- corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java
+++ corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java
@@ -848,7 +848,7 @@ public class ORBImpl extends com.sun.cor
         // backward compatability 4365188
         CodeBase cb;
 
-        ValueHandler vh = ORBUtility.createValueHandler(this);
+        ValueHandler vh = ORBUtility.createValueHandler();
 
         cb = (CodeBase)vh.getRunTimeCodeBase();
         return ORBUtility.connectAndGetIOR( this, cb ) ;
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java b/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-import java.util.Hashtable;
-
-/**
- * Implements legacy behavior from before Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPInputStream_1_3 extends com.sun.corba.se.impl.io.IIOPInputStream
-{
-    // The newer version in the io package correctly reads a wstring instead.
-    // This concerns bug 4379597.
-    protected String internalReadUTF(org.omg.CORBA.portable.InputStream stream)
-    {
-        return stream.read_string();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectInputStream.GetField readFields()
-        throws IOException, ClassNotFoundException, NotActiveException {
-        Hashtable fields = (Hashtable)readObject();
-        return new LegacyHookGetFields(fields);
-    }
-
-    public IIOPInputStream_1_3()
-        throws java.io.IOException {
-        super();
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java b/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-import java.util.Hashtable;
-
-/**
- * Implements legacy behavior from Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPInputStream_1_3_1 extends com.sun.corba.se.impl.io.IIOPInputStream
-{
-    public IIOPInputStream_1_3_1()
-        throws java.io.IOException {
-        super();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectInputStream.GetField readFields()
-        throws IOException, ClassNotFoundException, NotActiveException {
-
-        Hashtable fields = (Hashtable)readObject();
-        return new LegacyHookGetFields(fields);
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java b/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-
-/**
- * Implements legacy behavior from before Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPOutputStream_1_3 extends com.sun.corba.se.impl.io.IIOPOutputStream
-{
-    // We can't assume that the superclass's putFields
-    // member will be non-private.  We must allow
-    // the RI to run on JDK 1.3.1 FCS as well as
-    // the JDK 1.3.1_01 patch.
-    private ObjectOutputStream.PutField putFields_1_3;
-
-    // The newer version in the io package correctly writes a wstring instead.
-    // This concerns bug 4379597.
-    protected void internalWriteUTF(org.omg.CORBA.portable.OutputStream stream,
-                                    String data)
-    {
-        stream.write_string(data);
-    }
-
-    public IIOPOutputStream_1_3()
-        throws java.io.IOException {
-        super();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectOutputStream.PutField putFields()
-        throws IOException {
-        putFields_1_3 = new LegacyHookPutFields();
-        return putFields_1_3;
-    }
-
-    public void writeFields()
-        throws IOException {
-        putFields_1_3.write(this);
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java b/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-import java.util.Hashtable;
-
-/**
- * Implements legacy behavior from Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPOutputStream_1_3_1 extends com.sun.corba.se.impl.io.IIOPOutputStream
-{
-    // We can't assume that the superclass's putFields
-    // member will be non-private.  We must allow
-    // the RI to run on JDK 1.3.1 FCS as well as
-    // the JDK 1.3.1_01 patch.
-    private ObjectOutputStream.PutField putFields_1_3_1;
-
-    public IIOPOutputStream_1_3_1()
-        throws java.io.IOException {
-        super();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectOutputStream.PutField putFields()
-        throws IOException {
-
-        putFields_1_3_1 = new LegacyHookPutFields();
-        return putFields_1_3_1;
-    }
-
-    public void writeFields()
-        throws IOException {
-
-        putFields_1_3_1.write(this);
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/ORBUtility.java b/src/share/classes/com/sun/corba/se/impl/orbutil/ORBUtility.java
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ORBUtility.java
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ORBUtility.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -160,42 +160,10 @@ public final class ORBUtility {
     }
 
     /**
-     * Creates the correct ValueHandler for the given ORB,
-     * querying ORBVersion information.  If the ORB or
-     * ORBVersion is null, gets the ValueHandler from
-     * Util.createValueHandler.
+     * Return default ValueHandler
      */
-    public static ValueHandler createValueHandler(ORB orb) {
-
-        if (orb == null)
-            return Util.createValueHandler();
-
-        ORBVersion version = orb.getORBVersion();
-
-        if (version == null)
-            return Util.createValueHandler();
-
-        if (version.equals(ORBVersionFactory.getOLD()))
-            return new ValueHandlerImpl_1_3();
-        if (version.equals(ORBVersionFactory.getNEW()))
-            return new ValueHandlerImpl_1_3_1();
-
+    public static ValueHandler createValueHandler() {
         return Util.createValueHandler();
-    }
-
-    /**
-     * Returns true if the given ORB could accurately be determined to be a
-     * Kestrel or earlier ORB.  Note: If passed the ORBSingleton, this will return
-     * false.
-     */
-    public static boolean isLegacyORB(ORB orb)
-    {
-        try {
-            ORBVersion currentORB = orb.getORBVersion();
-            return currentORB.equals( ORBVersionFactory.getOLD() ) ;
-        } catch (SecurityException se) {
-            return false;
-        }
     }
 
     /**
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import org.omg.CORBA.ORB;
-import java.io.Serializable;
-import java.util.Hashtable;
-import java.net.MalformedURLException;
-import com.sun.corba.se.impl.io.TypeMismatchException;
-import com.sun.corba.se.impl.util.RepositoryId;
-
-/**
- * Delegates to the RepositoryId_1_3 implementation in
- * com.sun.corba.se.impl.orbutil.  This is necessary to
- * overcome the fact that many of RepositoryId's methods
- * are static.
- */
-public final class RepIdDelegator_1_3
-    implements RepositoryIdStrings,
-               RepositoryIdUtility,
-               RepositoryIdInterface
-{
-    // RepositoryIdFactory methods
-
-    public String createForAnyType(Class type) {
-        return RepositoryId_1_3.createForAnyType(type);
-    }
-
-    public String createForJavaType(Serializable ser)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3.createForJavaType(ser);
-    }
-
-    public String createForJavaType(Class clz)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3.createForJavaType(clz);
-    }
-
-    public String createSequenceRepID(java.lang.Object ser) {
-        return RepositoryId_1_3.createSequenceRepID(ser);
-    }
-
-    public String createSequenceRepID(Class clazz) {
-        return RepositoryId_1_3.createSequenceRepID(clazz);
-    }
-
-    public RepositoryIdInterface getFromString(String repIdString) {
-        return new RepIdDelegator_1_3(RepositoryId_1_3.cache.getId(repIdString));
-    }
-
-    // RepositoryIdUtility methods
-
-    public boolean isChunkedEncoding(int valueTag) {
-        return RepositoryId.isChunkedEncoding(valueTag);
-    }
-
-    public boolean isCodeBasePresent(int valueTag) {
-        return RepositoryId.isCodeBasePresent(valueTag);
-    }
-
-    public String getClassDescValueRepId() {
-        return RepositoryId_1_3.kClassDescValueRepID;
-    }
-
-    public String getWStringValueRepId() {
-        return RepositoryId_1_3.kWStringValueRepID;
-    }
-
-    public int getTypeInfo(int valueTag) {
-        return RepositoryId.getTypeInfo(valueTag);
-    }
-
-    public int getStandardRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked_NoRep;
-    }
-
-    public int getCodeBaseRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked_NoRep;
-    }
-
-    public int getStandardRMIChunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked;
-    }
-
-    public int getCodeBaseRMIChunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked;
-    }
-
-    public int getStandardRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked;
-    }
-
-    public int getCodeBaseRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked;
-    }
-
-    public int getStandardRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked_NoRep;
-    }
-
-    public int getCodeBaseRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked_NoRep;
-    }
-
-    // RepositoryIdInterface methods
-
-    public Class getClassFromType() throws ClassNotFoundException {
-        return delegate.getClassFromType();
-    }
-
-    public Class getClassFromType(String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(codebaseURL);
-    }
-
-    public Class getClassFromType(Class expectedType,
-                                  String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(expectedType, codebaseURL);
-    }
-
-    public String getClassName() {
-        return delegate.getClassName();
-    }
-
-    // Constructor used for factory/utility cases
-    public RepIdDelegator_1_3() {}
-
-    // Constructor used by getIdFromString.  All non-static
-    // RepositoryId methods will use the provided delegate.
-    private RepIdDelegator_1_3(RepositoryId_1_3 _delegate) {
-        this.delegate = _delegate;
-    }
-
-    private RepositoryId_1_3 delegate = null;
-
-    public String toString() {
-        if (delegate != null)
-            return delegate.toString();
-        else
-            return this.getClass().getName();
-    }
-
-    public boolean equals(Object obj) {
-        if (delegate != null)
-            return delegate.equals(obj);
-        else
-            return super.equals(obj);
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import org.omg.CORBA.ORB;
-import java.io.Serializable;
-import java.util.Hashtable;
-import java.net.MalformedURLException;
-import com.sun.corba.se.impl.io.TypeMismatchException;
-import com.sun.corba.se.impl.util.RepositoryId;
-
-/**
- * Delegates to the RepositoryId_1_3_1 implementation in
- * com.sun.corba.se.impl.orbutil.  This is necessary to
- * overcome the fact that many of RepositoryId's methods
- * are static.
- */
-public final class RepIdDelegator_1_3_1
-    implements RepositoryIdStrings,
-               RepositoryIdUtility,
-               RepositoryIdInterface
-{
-    // RepositoryIdFactory methods
-
-    public String createForAnyType(Class type) {
-        return RepositoryId_1_3_1.createForAnyType(type);
-    }
-
-    public String createForJavaType(Serializable ser)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3_1.createForJavaType(ser);
-    }
-
-    public String createForJavaType(Class clz)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3_1.createForJavaType(clz);
-    }
-
-    public String createSequenceRepID(java.lang.Object ser) {
-        return RepositoryId_1_3_1.createSequenceRepID(ser);
-    }
-
-    public String createSequenceRepID(Class clazz) {
-        return RepositoryId_1_3_1.createSequenceRepID(clazz);
-    }
-
-    public RepositoryIdInterface getFromString(String repIdString) {
-        return new RepIdDelegator_1_3_1(RepositoryId_1_3_1.cache.getId(repIdString));
-    }
-
-    // RepositoryIdUtility methods
-
-    public boolean isChunkedEncoding(int valueTag) {
-        return RepositoryId.isChunkedEncoding(valueTag);
-    }
-
-    public boolean isCodeBasePresent(int valueTag) {
-        return RepositoryId.isCodeBasePresent(valueTag);
-    }
-
-    public String getClassDescValueRepId() {
-        return RepositoryId_1_3_1.kClassDescValueRepID;
-    }
-
-    public String getWStringValueRepId() {
-        return RepositoryId_1_3_1.kWStringValueRepID;
-    }
-
-    public int getTypeInfo(int valueTag) {
-        return RepositoryId.getTypeInfo(valueTag);
-    }
-
-    public int getStandardRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked_NoRep;
-    }
-
-    public int getCodeBaseRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked_NoRep;
-    }
-
-    public int getStandardRMIChunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked;
-    }
-
-    public int getCodeBaseRMIChunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked;
-    }
-
-    public int getStandardRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked;
-    }
-
-    public int getCodeBaseRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked;
-    }
-
-    public int getStandardRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked_NoRep;
-    }
-
-    public int getCodeBaseRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked_NoRep;
-    }
-
-    // RepositoryIdInterface methods
-
-    public Class getClassFromType() throws ClassNotFoundException {
-        return delegate.getClassFromType();
-    }
-
-    public Class getClassFromType(String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(codebaseURL);
-    }
-
-    public Class getClassFromType(Class expectedType,
-                                  String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(expectedType, codebaseURL);
-    }
-
-    public String getClassName() {
-        return delegate.getClassName();
-    }
-
-    // Constructor used for factory/utility cases
-    public RepIdDelegator_1_3_1() {}
-
-    // Constructor used by getIdFromString.  All non-static
-    // RepositoryId methods will use the provided delegate.
-    private RepIdDelegator_1_3_1(RepositoryId_1_3_1 _delegate) {
-        this.delegate = _delegate;
-    }
-
-    private RepositoryId_1_3_1 delegate = null;
-
-    public String toString() {
-        if (delegate != null)
-            return delegate.toString();
-        else
-            return this.getClass().getName();
-    }
-
-    public boolean equals(Object obj) {
-        if (delegate != null)
-            return delegate.equals(obj);
-        else
-            return super.equals(obj);
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-/*
- * Licensed Materials - Property of IBM
- * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
- *
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.Stack;
-import java.util.Hashtable;
-import java.util.EmptyStackException;
-import java.util.Enumeration;
-
-// Really limited pool - in this case just creating several at a time...
-class RepositoryIdPool_1_3 extends Stack {
-
-    private static int MAX_CACHE_SIZE = 4;
-    private RepositoryIdCache_1_3 cache;
-
-    public final synchronized RepositoryId_1_3 popId() {
-
-        try {
-            return (RepositoryId_1_3)super.pop();
-        }
-        catch(EmptyStackException e) {
-            increasePool(5);
-            return (RepositoryId_1_3)super.pop();
-        }
-
-    }
-
-    // Pool management
-    final void increasePool(int size) {
-        //if (cache.size() <= MAX_CACHE_SIZE)
-        for (int i = size; i > 0; i--)
-            push(new RepositoryId_1_3());
-        /*
-          // _REVISIT_ This will not work w/out either thread tracing or weak references.  I am
-          // betting that thread tracing almost completely negates benefit of reuse.  Until either
-          // 1.2 only inclusion or proof to the contrary, I'll leave it this way...
-          else {
-          int numToReclaim = cache.size() / 2;
-          Enumeration keys = cache.keys();
-          Enumeration elements = cache.elements();
-          for (int i = numToReclaim; i > 0; i--) {
-          Object key = keys.nextElement();
-          Object element = elements.nextElement();
-
-          push(element);
-          cache.remove(key);
-          }
-          }
-        */
-    }
-
-    final void setCaches(RepositoryIdCache_1_3 cache) {
-        this.cache = cache;
-    }
-
-}
-
-public class RepositoryIdCache_1_3 extends Hashtable {
-
-    private RepositoryIdPool_1_3 pool = new RepositoryIdPool_1_3();
-
-    public RepositoryIdCache_1_3() {
-        pool.setCaches(this);
-    }
-
-    public final synchronized RepositoryId_1_3 getId(String key) {
-        RepositoryId_1_3 repId = (RepositoryId_1_3)super.get(key);
-
-        if (repId != null)
-            return repId;
-        else {
-            //repId = pool.popId().init(key);
-            repId = new RepositoryId_1_3(key);
-            put(key, repId);
-            return repId;
-        }
-
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.Stack;
-import java.util.Hashtable;
-import java.util.EmptyStackException;
-import java.util.Enumeration;
-
-// Really limited pool - in this case just creating several at a time...
-class RepositoryIdPool_1_3_1 extends Stack {
-
-    private static int MAX_CACHE_SIZE = 4;
-    private RepositoryIdCache_1_3_1 cache;
-
-    public final synchronized RepositoryId_1_3_1 popId() {
-
-        try {
-            return (RepositoryId_1_3_1)super.pop();
-        }
-        catch(EmptyStackException e) {
-            increasePool(5);
-            return (RepositoryId_1_3_1)super.pop();
-        }
-
-    }
-
-    // Pool management
-    final void increasePool(int size) {
-        //if (cache.size() <= MAX_CACHE_SIZE)
-        for (int i = size; i > 0; i--)
-            push(new RepositoryId_1_3_1());
-        /*
-          // _REVISIT_ This will not work w/out either thread tracing or weak references.  I am
-          // betting that thread tracing almost completely negates benefit of reuse.  Until either
-          // 1.2 only inclusion or proof to the contrary, I'll leave it this way...
-          else {
-          int numToReclaim = cache.size() / 2;
-          Enumeration keys = cache.keys();
-          Enumeration elements = cache.elements();
-          for (int i = numToReclaim; i > 0; i--) {
-          Object key = keys.nextElement();
-          Object element = elements.nextElement();
-
-          push(element);
-          cache.remove(key);
-          }
-          }
-        */
-    }
-
-    final void setCaches(RepositoryIdCache_1_3_1 cache) {
-        this.cache = cache;
-    }
-
-}
-
-public class RepositoryIdCache_1_3_1 extends Hashtable {
-
-    private RepositoryIdPool_1_3_1 pool = new RepositoryIdPool_1_3_1();
-
-    public RepositoryIdCache_1_3_1() {
-        pool.setCaches(this);
-    }
-
-    public final synchronized RepositoryId_1_3_1 getId(String key) {
-        RepositoryId_1_3_1 repId = (RepositoryId_1_3_1)super.get(key);
-
-        if (repId != null)
-            return repId;
-        else {
-            //repId = pool.popId().init(key);
-            repId = new RepositoryId_1_3_1(key);
-            put(key, repId);
-            return repId;
-        }
-
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,12 +30,6 @@ import com.sun.corba.se.spi.orb.ORB;
 
 public abstract class RepositoryIdFactory
 {
-    private static final RepIdDelegator_1_3 legacyDelegator
-        = new RepIdDelegator_1_3();
-
-    private static final RepIdDelegator_1_3_1 ladybirdDelegator
-        = new RepIdDelegator_1_3_1();
-
     private static final RepIdDelegator currentDelegator
         = new RepIdDelegator();
 
@@ -48,29 +42,6 @@ public abstract class RepositoryIdFactor
     }
 
     /**
-     * Checks the version of the ORB and returns the appropriate
-     * RepositoryIdStrings instance.
-     */
-    public static RepositoryIdStrings getRepIdStringsFactory(ORB orb)
-    {
-        if (orb != null) {
-            switch (orb.getORBVersion().getORBType()) {
-                case ORBVersion.NEWER:
-                case ORBVersion.FOREIGN:
-                case ORBVersion.JDK1_3_1_01:
-                    return currentDelegator;
-                case ORBVersion.OLD:
-                    return legacyDelegator;
-                case ORBVersion.NEW:
-                    return ladybirdDelegator;
-                default:
-                    return currentDelegator;
-            }
-        } else
-            return currentDelegator;
-    }
-
-    /**
      * Returns the latest version RepositoryIdUtility instance
      */
     public static RepositoryIdUtility getRepIdUtility()
@@ -78,26 +49,4 @@ public abstract class RepositoryIdFactor
         return currentDelegator;
     }
 
-    /**
-     * Checks the version of the ORB and returns the appropriate
-     * RepositoryIdUtility instance.
-     */
-    public static RepositoryIdUtility getRepIdUtility(ORB orb)
-    {
-        if (orb != null) {
-            switch (orb.getORBVersion().getORBType()) {
-                case ORBVersion.NEWER:
-                case ORBVersion.FOREIGN:
-                case ORBVersion.JDK1_3_1_01:
-                    return currentDelegator;
-                case ORBVersion.OLD:
-                    return legacyDelegator;
-                case ORBVersion.NEW:
-                    return ladybirdDelegator;
-                default:
-                    return currentDelegator;
-            }
-        } else
-            return currentDelegator;
-    }
 }
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java
+++ /dev/null
@@ -1,990 +0,0 @@
-/*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-/*
- * Licensed Materials - Property of IBM
- * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
- *
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.StringTokenizer;
-import java.util.Hashtable;
-import java.io.IOException;
-import java.lang.reflect.Method;
-
-// Imports for using codebase URL to load class
-import java.net.MalformedURLException;
-import org.omg.CORBA.portable.ValueBase;
-import org.omg.CORBA.portable.IDLEntity;
-
-import com.sun.corba.se.impl.util.JDKBridge;
-import com.sun.corba.se.impl.util.Utility;
-import com.sun.corba.se.impl.util.PackagePrefixChecker;
-import com.sun.corba.se.impl.util.IdentityHashtable;
-import com.sun.corba.se.impl.io.ObjectStreamClass;
-
-import javax.rmi.CORBA.Util;
-
-// keeping the original RepositoryId class that was shipped in
-// JDK 1.3.  It has interoperability bugs
-
-public class RepositoryId_1_3 {
-
-    // Legal IDL Identifier characters (1 = legal). Note
-    // that '.' (2E) is marked as legal even though it is
-    // not legal in IDL. This allows us to treat a fully
-    // qualified Java name with '.' package separators
-    // uniformly, and is safe because that is the only
-    // legal use of '.' in a Java name.
-
-    public static final RepositoryIdCache_1_3 cache = new RepositoryIdCache_1_3();
-    private static final byte[] IDL_IDENTIFIER_CHARS = {
-
-        // 0 1 2 3  4 5 6 7  8 9 a b  c d e f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 00-0f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 10-1f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0, // 20-2f
-        1,1,1,1, 1,1,1,1, 1,1,0,0, 0,0,0,0, // 30-3f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 40-4f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,1, // 50-5f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 60-6f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,0, // 70-7f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 80-8f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 90-9f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // a0-af
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // b0-bf
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // c0-cf
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // d0-df
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // e0-ef
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // f0-ff
-    };
-
-    private static String defaultServerURL = null;
-    private static boolean useCodebaseOnly = false;
-
-    static {
-        if (defaultServerURL == null)
-            defaultServerURL = (String)JDKBridge.getLocalCodebase();
-        useCodebaseOnly = JDKBridge.useCodebaseOnly();
-
-    }
-
-    private static IdentityHashtable classToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classIDLToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classSeqToRepStr = new IdentityHashtable();
-
-    private static IdentityHashtable repStrToByteArray = new IdentityHashtable();
-    private static Hashtable repStrToClass = new Hashtable();
-
-    private String repId = null;
-    private boolean isSupportedFormat = true;
-    private String typeString = null;
-    private String versionString = null;
-    private boolean isSequence = false;
-    private boolean isRMIValueType = false;
-    private boolean isIDLType = false;
-    private String completeClassName = null;
-    private String unqualifiedName = null;
-    private String definedInId = null;
-    private Class clazz = null;
-    private String suid = null, actualSuid = null;
-    private long suidLong = ObjectStreamClass.kDefaultUID, actualSuidLong = ObjectStreamClass.kDefaultUID;
-
-    // Repository ID fragments
-    private static final String kValuePrefix = "RMI:";
-    private static final String kIDLPrefix = "IDL:";
-    private static final String kIDLNamePrefix = "omg.org/";
-    private static final String kIDLClassnamePrefix = "org.omg.";
-    private static final String kSequencePrefix = "[";
-    private static final String kCORBAPrefix = "CORBA/";
-    private static final String kArrayPrefix = kValuePrefix + kSequencePrefix + kCORBAPrefix;
-    private static final int kValuePrefixLength = kValuePrefix.length();
-    private static final int kIDLPrefixLength = kIDLPrefix.length();
-    private static final int kSequencePrefixLength = kSequencePrefix.length();
-    private static final String kInterfaceHashCode = ":0000000000000000";
-    private static final String kInterfaceOnlyHashStr = "0000000000000000";
-    private static final String kExternalizableHashStr = "0000000000000001";
-
-    // Value tag utility methods and constants
-    public static final int kInitialValueTag= 0x7fffff00;
-    public static final int kNoTypeInfo = 0;
-    public static final int kSingleRepTypeInfo = 0x02;
-    public static final int  kPartialListTypeInfo = 0x06;
-    public static final int  kChunkedMask = 0x08;
-
-    // Public, well known repository IDs
-
-    // _REVISIT_ : A table structure with a good search routine for all of this
-    // would be more efficient and easier to maintain...
-
-    // String
-    public static final String kWStringValueVersion = "1.0";
-    public static final String kWStringValueHash = ":"+kWStringValueVersion;
-    public static final String kWStringStubValue = "WStringValue";
-    public static final String kWStringTypeStr = "omg.org/CORBA/"+kWStringStubValue;
-    public static final String kWStringValueRepID = kIDLPrefix + kWStringTypeStr + kWStringValueHash;
-
-    // Any
-    public static final String kAnyRepID = kIDLPrefix + "omg.org/CORBA/Any";
-
-    // Class
-    public static final String kClassDescValueHash = ":" + Long.toHexString(
-       ObjectStreamClass.getSerialVersionUID(javax.rmi.CORBA.ClassDesc.class));
-    public static final String kClassDescStubValue = "ClassDesc";
-    public static final String kClassDescTypeStr = "javax.rmi.CORBA."+kClassDescStubValue;
-    public static final String kClassDescValueRepID = kValuePrefix + kClassDescTypeStr + kClassDescValueHash;
-
-    // Object
-    public static final String kObjectValueHash = ":1.0";
-    public static final String kObjectStubValue = "Object";
-
-    // Sequence
-    public static final String kSequenceValueHash = ":1.0";
-    public static final String kPrimitiveSequenceValueHash = ":0000000000000000";
-
-    // Serializable
-    public static final String kSerializableValueHash = ":1.0";
-    public static final String kSerializableStubValue = "Serializable";
-
-    // Externalizable
-    public static final String kExternalizableValueHash = ":1.0";
-    public static final String kExternalizableStubValue = "Externalizable";
-
-    // Remote (The empty string is used for java.rmi.Remote)
-    public static final String kRemoteValueHash = "";
-    public static final String kRemoteStubValue = "";
-    public static final String kRemoteTypeStr = "";
-    public static final String kRemoteValueRepID = "";
-
-    private static final Hashtable kSpecialArrayTypeStrings = new Hashtable();
-
-    static {
-        kSpecialArrayTypeStrings.put("CORBA.WStringValue", new StringBuffer(java.lang.String.class.getName()));
-        kSpecialArrayTypeStrings.put("javax.rmi.CORBA.ClassDesc", new StringBuffer(java.lang.Class.class.getName()));
-        kSpecialArrayTypeStrings.put("CORBA.Object", new StringBuffer(java.rmi.Remote.class.getName()));
-
-    }
-
-    private static final Hashtable kSpecialCasesRepIDs = new Hashtable();
-
-    static {
-        kSpecialCasesRepIDs.put(java.lang.String.class, kWStringValueRepID);
-        kSpecialCasesRepIDs.put(java.lang.Class.class, kClassDescValueRepID);
-        kSpecialCasesRepIDs.put(java.rmi.Remote.class, kRemoteValueRepID);
-    }
-
-    private static final Hashtable kSpecialCasesStubValues = new Hashtable();
-
-    static {
-        kSpecialCasesStubValues.put(java.lang.String.class, kWStringStubValue);
-        kSpecialCasesStubValues.put(java.lang.Class.class, kClassDescStubValue);
-        kSpecialCasesStubValues.put(java.lang.Object.class, kObjectStubValue);
-        kSpecialCasesStubValues.put(java.io.Serializable.class, kSerializableStubValue);
-        kSpecialCasesStubValues.put(java.io.Externalizable.class, kExternalizableStubValue);
-        kSpecialCasesStubValues.put(java.rmi.Remote.class, kRemoteStubValue);
-    }
-
-
-    private static final Hashtable kSpecialCasesVersions = new Hashtable();
-
-    static {
-        kSpecialCasesVersions.put(java.lang.String.class, kWStringValueHash);
-        kSpecialCasesVersions.put(java.lang.Class.class, kClassDescValueHash);
-        kSpecialCasesVersions.put(java.lang.Object.class, kObjectValueHash);
-        kSpecialCasesVersions.put(java.io.Serializable.class, kSerializableValueHash);
-        kSpecialCasesVersions.put(java.io.Externalizable.class, kExternalizableValueHash);
-        kSpecialCasesVersions.put(java.rmi.Remote.class, kRemoteValueHash);
-    }
-
-    private static final Hashtable kSpecialCasesClasses = new Hashtable();
-
-    static {
-        kSpecialCasesClasses.put(kWStringTypeStr, java.lang.String.class);
-        kSpecialCasesClasses.put(kClassDescTypeStr, java.lang.Class.class);
-        kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-
-        kSpecialCasesClasses.put("org.omg.CORBA.WStringValue", java.lang.String.class);
-        kSpecialCasesClasses.put("javax.rmi.CORBA.ClassDesc", java.lang.Class.class);
-        //kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-    }
-
-    private static final Hashtable kSpecialCasesArrayPrefix = new Hashtable();
-
-    static {
-        kSpecialCasesArrayPrefix.put(java.lang.String.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-        kSpecialCasesArrayPrefix.put(java.lang.Class.class, kValuePrefix + kSequencePrefix + "javax/rmi/CORBA/");
-        kSpecialCasesArrayPrefix.put(java.lang.Object.class, kValuePrefix + kSequencePrefix + "java/lang/");
-        kSpecialCasesArrayPrefix.put(java.io.Serializable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.io.Externalizable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.rmi.Remote.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-    }
-
-    private static final Hashtable kSpecialPrimitives = new Hashtable();
-
-    static {
-        kSpecialPrimitives.put("int","long");
-        kSpecialPrimitives.put("long","longlong");
-        kSpecialPrimitives.put("byte","octet");
-    }
-
-    /**
-     * Used to convert ascii to hex.
-     */
-    private static final byte ASCII_HEX[] =     {
-        (byte)'0',
-        (byte)'1',
-        (byte)'2',
-        (byte)'3',
-        (byte)'4',
-        (byte)'5',
-        (byte)'6',
-        (byte)'7',
-        (byte)'8',
-        (byte)'9',
-        (byte)'A',
-        (byte)'B',
-        (byte)'C',
-        (byte)'D',
-        (byte)'E',
-        (byte)'F',
-    };
-
-
-    // Interface Rep ID Strings
-    public static final String kjava_rmi_Remote = createForAnyType(java.rmi.Remote.class);
-    public static final String korg_omg_CORBA_Object = createForAnyType(org.omg.CORBA.Object.class);
-
-    // Dummy arguments for getIdFromHelper method
-    public static final Class kNoParamTypes[] ={};
-    public static final Object kNoArgs[] = {};
-
-
-    RepositoryId_1_3(){}
-
-    RepositoryId_1_3(String aRepId){
-        init(aRepId);
-    }
-
-    RepositoryId_1_3 init(String aRepId){
-
-        this.repId = aRepId;
-
-        // Special case for remote
-        if (aRepId.length() == 0) {
-            clazz = java.rmi.Remote.class;
-            typeString = "";
-            isRMIValueType = true;
-            suid = kInterfaceOnlyHashStr;
-            return this;
-        }
-        else if (aRepId.equals(kWStringValueRepID)) {
-            clazz = java.lang.String.class;
-            typeString = kWStringTypeStr;
-            isIDLType = true;
-            versionString = kWStringValueVersion;
-            return this;
-        }
-        else {
-
-        String repId = convertFromISOLatin1(aRepId);
-
-        versionString = repId.substring(repId.indexOf(':', repId.indexOf(':')+1));
-        if (repId.startsWith(kIDLPrefix)) {
-            typeString =
-                repId.substring(kIDLPrefixLength, repId.indexOf(':', kIDLPrefixLength));
-            isIDLType = true;
-            if (typeString.startsWith(kIDLNamePrefix))
-                completeClassName = kIDLClassnamePrefix +
-                    typeString.substring(kIDLNamePrefix.length()).replace('/','.');
-            else completeClassName = typeString.replace('/','.');
-
-        }
-        else if (repId.startsWith(kValuePrefix)) {
-            typeString =
-                repId.substring(kValuePrefixLength, repId.indexOf(':', kValuePrefixLength));
-            isRMIValueType = true;
-
-            if (versionString.indexOf('.') == -1) {
-                    actualSuid = versionString.substring(1);
-                    suid = actualSuid;  // default if not explicitly specified
-
-                    if (actualSuid.indexOf(':') != -1){
-                    // we have a declared hash also
-                        int pos = actualSuid.indexOf(':')+1;
-                        // actualSuid = suid.substring(pos);
-                        // suid = suid.substring(0, pos-1);
-                        suid = actualSuid.substring(pos);
-                        actualSuid = actualSuid.substring(0, pos-1);
-                }
-
-            }
-            else {
-                    // _REVISIT_ : Special case version failure ?
-            }
-        }
-        else isSupportedFormat = false;
-
-        if (typeString.startsWith(kSequencePrefix)) {
-            isSequence = true;
-        }
-
-
-        return this;
-    }
-    }
-
-    public final String getUnqualifiedName() {
-        if (unqualifiedName == null){
-            String className = getClassName();
-            int index = (className != null) ? className.lastIndexOf('.') : -1;
-            if (index == -1){
-                unqualifiedName = className;
-                definedInId = "IDL::1.0";
-            }
-            else {
-                unqualifiedName = className.substring(index);
-                definedInId = "IDL:" + className.substring(0, index).replace('.','/') + ":1.0";
-            }
-        }
-
-        return unqualifiedName;
-    }
-
-    public final String getDefinedInId() {
-        if (definedInId == null){
-            getUnqualifiedName();
-        }
-
-        return definedInId;
-    }
-
-    public final String getTypeString() {
-        return typeString;
-    }
-
-    public final String getVersionString() {
-        return versionString;
-    }
-
-    public final String getSerialVersionUID() {
-        return suid;
-    }
-
-    public final String getActualSerialVersionUID() {
-        return actualSuid;
-    }
-    public final long getSerialVersionUIDAsLong() {
-        return suidLong;
-    }
-
-    public final long getActualSerialVersionUIDAsLong() {
-        return actualSuidLong;
-    }
-
-    public final boolean isRMIValueType() {
-        return isRMIValueType;
-    }
-
-    public final boolean isIDLType() {
-        return isIDLType;
-    }
-
-    public final String getRepositoryId() {
-        return repId;
-    }
-
-    public static byte[] getByteArray(String repStr) {
-        synchronized (repStrToByteArray){
-            return (byte[]) repStrToByteArray.get(repStr);
-        }
-    }
-
-    public static void setByteArray(String repStr, byte[] repStrBytes) {
-        synchronized (repStrToByteArray){
-            repStrToByteArray.put(repStr, repStrBytes);
-        }
-    }
-
-    public final boolean isSequence() {
-        return isSequence;
-    }
-
-    public final boolean isSupportedFormat() {
-        return isSupportedFormat;
-    }
-
-
-    // This method will return the classname from the typestring OR if the classname turns out to be
-    // a special class "pseudo" name, then the matching real classname is returned.
-    public final String getClassName() {
-
-        if (isRMIValueType)
-            return typeString;
-        else if (isIDLType)
-            return completeClassName;
-        else return null;
-
-    }
-
-    // This method calls getClazzFromType() and falls back to the repStrToClass
-    // cache if no class was found.  It's used where any class matching the
-    // given repid is an acceptable result.
-    public final Class getAnyClassFromType() throws ClassNotFoundException {
-        try {
-            return getClassFromType();
-        } catch (ClassNotFoundException cnfe) {
-            Class clz = (Class)repStrToClass.get(repId);
-            if (clz != null)
-                return clz;
-            else
-                throw cnfe;
-        }
-    }
-
-    public final Class getClassFromType()
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        }
-        else
-            {
-                try{
-                    return Util.loadClass(getClassName(), null, null);
-                }
-                catch(ClassNotFoundException cnfe){
-                    if (defaultServerURL != null) {
-                        try{
-                            return getClassFromType(defaultServerURL);
-                        }
-                        catch(MalformedURLException mue){
-                            throw cnfe;
-                        }
-                    }
-                    else throw cnfe;
-                }
-            }
-
-    }
-
-    public final Class getClassFromType(Class expectedType, String codebase)
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        } else {
-            ClassLoader expectedTypeClassLoader = (expectedType == null ? null : expectedType.getClassLoader());
-            return loadClassOfType(getClassName(),
-                                            codebase,
-                                            expectedTypeClassLoader,
-                                            expectedType,
-                                            expectedTypeClassLoader);
-        }
-
-    }
-
-    public final Class getClassFromType(String url)
-        throws ClassNotFoundException, MalformedURLException {
-        return Util.loadClass(getClassName(), url, null);
-    }
-
-    public final String toString() {
-        return repId;
-    }
-
-    private static String createHashString(java.io.Serializable ser) {
-
-        return createHashString(ser.getClass());
-    }
-
-    private static String createHashString(java.lang.Class clazz) {
-
-        if (clazz.isInterface() || !java.io.Serializable.class.isAssignableFrom(clazz))
-            return kInterfaceHashCode;
-
-
-        long actualLong = ObjectStreamClassUtil_1_3.computeStructuralUID(false, clazz);
-        String hash = null;
-        if (actualLong == 0)
-            hash = kInterfaceOnlyHashStr;
-        else if (actualLong == 1)
-            hash = kExternalizableHashStr;
-        else
-            hash = Long.toHexString(actualLong).toUpperCase();
-        while(hash.length() < 16){
-            hash = "0" + hash;
-        }
-
-        long declaredLong = ObjectStreamClassUtil_1_3.computeSerialVersionUID(clazz);
-        String declared = null;
-        if (declaredLong == 0)
-            declared = kInterfaceOnlyHashStr;
-        else if (declaredLong == 1)
-            declared = kExternalizableHashStr;
-        else
-            declared = Long.toHexString(declaredLong).toUpperCase();
-        while (declared.length() < 16){
-            declared = "0" + declared;
-    }
-        hash = hash + ":" + declared;
-
-        return ":" + hash;
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a rep id for a sequence of zero
-     * length.  This would be an error.
-     * @param ser The Java object to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Object ser){
-        return createSequenceRepID(ser.getClass());
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a malformed rep id.
-     * @param clazz The Java class to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Class clazz){
-        synchronized (classSeqToRepStr){
-
-        String repid = (String)classSeqToRepStr.get(clazz);
-        if (repid != null)
-            return repid;
-
-        Class originalClazz = clazz;
-
-        Class type = null;
-        int numOfDims = 0;
-
-        while ((type = clazz.getComponentType()) != null) {
-            numOfDims++;
-            clazz = type;
-        }
-
-        if (clazz.isPrimitive())
-            repid = kValuePrefix + originalClazz.getName() + kPrimitiveSequenceValueHash;
-        else {
-            StringBuffer buf = new StringBuffer();
-            buf.append(kValuePrefix);
-            while(numOfDims-- > 0) {
-                buf.append("[");
-            }
-            buf.append("L");
-            buf.append(convertToISOLatin1(clazz.getName()));
-            buf.append(";");
-            buf.append(createHashString(clazz));
-            repid = buf.toString();
-        }
-        classSeqToRepStr.put(originalClazz,repid);
-        return repid;
-        }
-
-    }
-
-
-    public static String createForSpecialCase(java.lang.Class clazz){
-        if (clazz.isArray()){
-            return createSequenceRepID(clazz);
-        }
-        else {
-            return (String)kSpecialCasesRepIDs.get(clazz);
-        }
-    }
-
-    public static String createForSpecialCase(java.io.Serializable ser){
-        Class clazz = ser.getClass();
-        if (clazz.isArray()){
-            return createSequenceRepID(ser);
-        }
-        else
-            return createForSpecialCase(clazz);
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param ser The Java object to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(java.io.Serializable ser)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr) {
-        String repid = createForSpecialCase(ser);
-        if (repid != null)
-            return repid;
-        Class clazz = ser.getClass();
-        repid = (String)classToRepStr.get(clazz);
-
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clazz.getName()) +
-            createHashString(clazz);
-
-        classToRepStr.put(clazz, repid);
-            repStrToClass.put(repid, clazz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param clz The Java class to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(Class clz)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr){
-        String repid = createForSpecialCase(clz);
-        if (repid != null)
-            return repid;
-
-        repid = (String)classToRepStr.get(clz);
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clz.getName()) +
-            createHashString(clz);
-
-        classToRepStr.put(clz, repid);
-            repStrToClass.put(repid, clz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for an IDL Java Type.
-     * @param ser The IDL Value object to create a repository ID for
-     * @param major The major version number
-     * @param minor The minor version number
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser does not implement the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForIDLType(Class ser, int major, int minor)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classIDLToRepStr){
-        String repid = (String)classIDLToRepStr.get(ser);
-        if (repid != null)
-            return repid;
-
-        repid = kIDLPrefix + convertToISOLatin1(ser.getName()).replace('.','/') +
-            ":" + major + "." + minor;
-        classIDLToRepStr.put(ser, repid);
-        return repid;
-    }
-    }
-
-    private static String getIdFromHelper(Class clazz){
-        try {
-            Class helperClazz = Utility.loadClassForClass(clazz.getName()+"Helper", null,
-                                    clazz.getClassLoader(), clazz, clazz.getClassLoader());
-            Method idMethod = helperClazz.getDeclaredMethod("id", kNoParamTypes);
-            return (String)idMethod.invoke(null, kNoArgs);
-        }
-        catch(java.lang.ClassNotFoundException cnfe)
-            {
-                throw new org.omg.CORBA.MARSHAL(cnfe.toString());
-            }
-        catch(java.lang.NoSuchMethodException nsme)
-            {
-                throw new org.omg.CORBA.MARSHAL(nsme.toString());
-            }
-        catch(java.lang.reflect.InvocationTargetException ite)
-            {
-                throw new org.omg.CORBA.MARSHAL(ite.toString());
-            }
-        catch(java.lang.IllegalAccessException iae)
-            {
-                throw new org.omg.CORBA.MARSHAL(iae.toString());
-    }
-    }
-
-    /**
-     * Createa a repository ID for the type if it is either a java type
-     * or an IDL type.
-     * @param type The type to create rep. id for
-     * @return The rep. id.
-     **/
-    public static String createForAnyType(Class type) {
-        try{
-            if (type.isArray())
-                return createSequenceRepID(type);
-            else if (IDLEntity.class.isAssignableFrom(type))
-                {
-                    try{
-                        return getIdFromHelper(type);
-                    }
-                    catch(Throwable t) {
-                        return createForIDLType(type, 1, 0);
-                    }
-                }
-            else return createForJavaType(type);
-        }
-        catch(com.sun.corba.se.impl.io.TypeMismatchException e){
-            return null;
-        }
-
-    }
-
-    public static boolean isAbstractBase(Class clazz) {
-        return (clazz.isInterface() &&
-                IDLEntity.class.isAssignableFrom(clazz) &&
-                (!ValueBase.class.isAssignableFrom(clazz)) &&
-                (!org.omg.CORBA.Object.class.isAssignableFrom(clazz)));
-
-    }
-
-    /**
-     * Convert strings with illegal IDL identifier characters.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertToISOLatin1 (String name) {
-
-        int length = name.length();
-        if (length == 0) {
-            return name;
-        }
-        StringBuffer buffer = null;
-
-        for (int i = 0; i < length; i++) {
-
-            char c = name.charAt(i);
-
-            if (c > 255 || IDL_IDENTIFIER_CHARS[c] == 0) {
-
-                // We gotta convert. Have we already started?
-
-                if (buffer == null) {
-
-                    // No, so get set up...
-
-                    buffer = new StringBuffer(name.substring(0,i));
-                }
-
-                // Convert the character into the IDL escape syntax...
-                buffer.append(
-                              "\\U" +
-                              (char)ASCII_HEX[(c & 0xF000) >>> 12] +
-                              (char)ASCII_HEX[(c & 0x0F00) >>> 8] +
-                              (char)ASCII_HEX[(c & 0x00F0) >>> 4] +
-                              (char)ASCII_HEX[(c & 0x000F)]);
-
-            } else {
-                if (buffer != null) {
-                    buffer.append(c);
-                }
-            }
-        }
-
-        if (buffer != null) {
-            name = buffer.toString();
-        }
-
-        return name;
-    }
-
-    /**
-     * Convert strings with ISO Latin 1 escape sequences back to original strings.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertFromISOLatin1 (String name) {
-
-        int index = -1;
-        StringBuffer buf = new StringBuffer(name);
-
-        while ((index = buf.toString().indexOf("\\U")) != -1){
-            String str = "0000" + buf.toString().substring(index+2, index+6);
-
-            // Convert Hexadecimal
-            byte[] buffer = new byte[(str.length() - 4) / 2];
-            for (int i=4, j=0; i < str.length(); i +=2, j++) {
-                buffer[j] = (byte)((ORBUtility.hexOf(str.charAt(i)) << 4) & 0xF0);
-                buffer[j] |= (byte)((ORBUtility.hexOf(str.charAt(i+1)) << 0) & 0x0F);
-            }
-            buf = new StringBuffer(delete(buf.toString(), index, index+6));
-            buf.insert(index, (char)buffer[1]);
-        }
-
-        return buf.toString();
-
-
-    }
-
-    private static String delete(String str, int from, int to)
-    {
-        return str.substring(0, from) + str.substring(to, str.length());
-    }
-
-    private static String replace(String target, String arg, String source)
-    {
-        int i = 0;
-        i = target.indexOf(arg);
-
-        while(i != -1)
-            {
-                String left = target.substring(0, i);
-                String right = target.substring(i+arg.length());
-                target = new String(left+source+right);
-                i = target.indexOf(arg);
-            }
-        return target;
-    }
-
-    /*
-     * Load a class and check that it is assignable to a given type.
-     * @param className the class name.
-     * @param remoteCodebase the codebase to use. May be null.
-     * @param loader the class loader of last resort. May be null.
-     * @param expectedType the expected type. May be null.
-     * @return the loaded class.
-     */
-    private Class loadClassOfType (String className,
-                                  String remoteCodebase,
-                                  ClassLoader loader,
-                                  Class expectedType,
-                                  ClassLoader expectedTypeClassLoader)
-        throws ClassNotFoundException {
-
-        Class loadedClass = null;
-
-        try {
-            //Sequence finding of the stubs according to spec
-            try{
-                //If-else is put here for speed up of J2EE.
-                //According to the OMG spec, the if clause is not dead code.
-                //It can occur if some compiler has allowed generation
-                //into org.omg.stub hierarchy for non-offending
-                //classes. This will encourage people to
-                //produce non-offending class stubs in their own hierarchy.
-                if(!PackagePrefixChecker
-                   .hasOffendingPrefix(PackagePrefixChecker
-                                       .withoutPackagePrefix(className))){
-                    loadedClass = Util.loadClass
-                        (PackagePrefixChecker.withoutPackagePrefix(className),
-                         remoteCodebase,
-                         loader);
-                } else {
-                    loadedClass = Util.loadClass
-                        (className,
-                         remoteCodebase,
-                         loader);
-                }
-            } catch (ClassNotFoundException cnfe) {
-                loadedClass = Util.loadClass
-                    (className,
-                     remoteCodebase,
-                     loader);
-            }
-            if (expectedType == null)
-                return loadedClass;
-        } catch (ClassNotFoundException cnfe) {
-            if (expectedType == null)
-                throw cnfe;
-        }
-
-        // If no class was not loaded, or if the loaded class is not of the
-        // correct type, make a further attempt to load the correct class
-        // using the classloader of the expected type.
-        // _REVISIT_ Is this step necessary, or should the Util,loadClass
-        // algorithm always produce a valid class if the setup is correct?
-        // Does the OMG standard algorithm need to be changed to include
-        // this step?
-        if (loadedClass == null || !expectedType.isAssignableFrom(loadedClass)) {
-            if (expectedType.getClassLoader() != expectedTypeClassLoader)
-                throw new IllegalArgumentException("expectedTypeClassLoader not class loader of expectedType.");
-
-            if (expectedTypeClassLoader != null)
-                loadedClass = expectedTypeClassLoader.loadClass(className);
-            else
-                loadedClass = ORBClassLoader.loadClass(className);
-        }
-
-        return loadedClass;
-    }
-
-    /**
-     * Checks to see if the FullValueDescription should be retrieved.
-     * @exception Throws IOException if suids do not match or if the repositoryID
-     * is not an RMIValueType
-     */
-    public static boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws IOException{
-
-        String clazzRepIDStr = createForAnyType(clazz);
-
-        if (clazzRepIDStr.equals(repositoryID))
-            return false;
-
-        RepositoryId_1_3 targetRepid;
-        RepositoryId_1_3 clazzRepid;
-
-        synchronized(cache) {
-        // to avoid race condition where multiple threads could be
-        // accessing this method, and their access to the cache may
-        // be interleaved giving unexpected results
-
-            targetRepid = cache.getId(repositoryID);
-            clazzRepid = cache.getId(clazzRepIDStr);
-        }
-
-        if ((targetRepid.isRMIValueType()) && (clazzRepid.isRMIValueType())){
-            if (!targetRepid.getSerialVersionUID().equals(clazzRepid.getSerialVersionUID())) {
-
-                String mssg = "Mismatched serialization UIDs : Source (Rep. ID" +
-                    clazzRepid + ") = " +
-                    clazzRepid.getSerialVersionUID() + " whereas Target (Rep. ID " + repositoryID +
-                    ") = " + targetRepid.getSerialVersionUID();
-                throw new IOException(mssg);
-            } else {
-                return true;
-            }
-        } else {
-
-            throw new IOException("The repository ID is not of an RMI value type (Expected ID = " + clazzRepIDStr + "; Received ID = " + repositoryID +")");
-        }
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java b/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java
+++ /dev/null
@@ -1,1065 +0,0 @@
-/*
- * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.StringTokenizer;
-import java.util.Hashtable;
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.net.MalformedURLException;
-import org.omg.CORBA.portable.ValueBase;
-import org.omg.CORBA.portable.IDLEntity;
-
-//d11638 files in the same package, therefore remove their reference
-//import com.sun.corba.se.impl.util.JDKBridge;
-//import com.sun.corba.se.impl.util.IdentityHashtable;
-import com.sun.corba.se.impl.util.JDKBridge;
-import com.sun.corba.se.impl.util.Utility;
-import com.sun.corba.se.impl.util.PackagePrefixChecker;
-import com.sun.corba.se.impl.util.IdentityHashtable;
-
-import javax.rmi.CORBA.Util;
-
-/**
- * Because all methods in RepositoryId are static, we have
- * to duplicate all of this code, freezing it in its 1.3.1
- * form for backwards compatibility.
- *
- * For security reasons, we can't expose enough of
- * io/ObjectStreamClass, so it has to be duplicated in
- * orbutil.
- */
-public class RepositoryId_1_3_1 {
-
-    // Legal IDL Identifier characters (1 = legal). Note
-    // that '.' (2E) is marked as legal even though it is
-    // not legal in IDL. This allows us to treat a fully
-    // qualified Java name with '.' package separators
-    // uniformly, and is safe because that is the only
-    // legal use of '.' in a Java name.
-
-    private static final byte[] IDL_IDENTIFIER_CHARS = {
-
-        // 0 1 2 3  4 5 6 7  8 9 a b  c d e f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 00-0f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 10-1f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0, // 20-2f
-        1,1,1,1, 1,1,1,1, 1,1,0,0, 0,0,0,0, // 30-3f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 40-4f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,1, // 50-5f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 60-6f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,0, // 70-7f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 80-8f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 90-9f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // a0-af
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // b0-bf
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // c0-cf
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // d0-df
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // e0-ef
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // f0-ff
-    };
-
-
-    private static final long serialVersionUID = 123456789L;
-
-    private static String defaultServerURL = null;
-    private static boolean useCodebaseOnly = false;
-
-    static {
-        if (defaultServerURL == null)
-            defaultServerURL = (String)JDKBridge.getLocalCodebase();
-        useCodebaseOnly = JDKBridge.useCodebaseOnly();
-
-    }
-
-    private static IdentityHashtable classToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classIDLToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classSeqToRepStr = new IdentityHashtable();
-
-    private static IdentityHashtable repStrToByteArray = new IdentityHashtable();
-    private static Hashtable repStrToClass = new Hashtable();
-
-    private String repId = null;
-    private boolean isSupportedFormat = true;
-    private String typeString = null;
-    private String versionString = null;
-    private boolean isSequence = false;
-    private boolean isRMIValueType = false;
-    private boolean isIDLType = false;
-    private String completeClassName = null;
-    private String unqualifiedName = null;
-    private String definedInId = null;
-    private Class clazz = null;
-    private String suid = null, actualSuid = null;
-    private long suidLong = ObjectStreamClass_1_3_1.kDefaultUID, actualSuidLong = ObjectStreamClass_1_3_1.kDefaultUID;
-
-    // Repository ID fragments
-    private static final String kSequenceKeyword = "seq";
-    private static final String kValuePrefix = "RMI:";
-    private static final String kIDLPrefix = "IDL:";
-    private static final String kIDLNamePrefix = "omg.org/";
-    private static final String kIDLClassnamePrefix = "org.omg.";
-    private static final String kSequencePrefix = "[";
-    private static final String kCORBAPrefix = "CORBA/";
-    private static final String kArrayPrefix = kValuePrefix + kSequencePrefix + kCORBAPrefix;
-    private static final int kValuePrefixLength = kValuePrefix.length();
-    private static final int kIDLPrefixLength = kIDLPrefix.length();
-    private static final int kSequencePrefixLength = kSequencePrefix.length();
-    private static final String kInterfaceHashCode = ":0000000000000000";
-    private static final String kInterfaceOnlyHashStr = "0000000000000000";
-    private static final String kExternalizableHashStr = "0000000000000001";
-
-    // Value tag utility methods and constants
-    public static final int kInitialValueTag= 0x7fffff00;
-    public static final int kNoTypeInfo = 0;
-    public static final int kSingleRepTypeInfo = 0x02;
-    public static final int  kPartialListTypeInfo = 0x06;
-    public static final int  kChunkedMask = 0x08;
-    public static final int kPreComputed_StandardRMIUnchunked = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kSingleRepTypeInfo, false);
-    public static final int kPreComputed_CodeBaseRMIUnchunked = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kSingleRepTypeInfo, false);
-    public static final int kPreComputed_StandardRMIChunked = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kSingleRepTypeInfo, true);
-    public static final int kPreComputed_CodeBaseRMIChunked = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kSingleRepTypeInfo, true);
-
-    public static final int kPreComputed_StandardRMIUnchunked_NoRep = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kNoTypeInfo, false);
-    public static final int kPreComputed_CodeBaseRMIUnchunked_NoRep = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kNoTypeInfo, false);
-    public static final int kPreComputed_StandardRMIChunked_NoRep = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kNoTypeInfo, true);
-    public static final int kPreComputed_CodeBaseRMIChunked_NoRep = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kNoTypeInfo, true);
-
-    // Public, well known repository IDs
-
-    // _REVISIT_ : A table structure with a good search routine for all of this
-    // would be more efficient and easier to maintain...
-
-    // String
-    public static final String kWStringValueVersion = "1.0";
-    public static final String kWStringValueHash = ":"+kWStringValueVersion;
-    public static final String kWStringStubValue = "WStringValue";
-    public static final String kWStringTypeStr = "omg.org/CORBA/"+kWStringStubValue;
-    public static final String kWStringValueRepID = kIDLPrefix + kWStringTypeStr + kWStringValueHash;
-
-    // Any
-    public static final String kAnyRepID = kIDLPrefix + "omg.org/CORBA/Any";
-
-    // Class
-    // Anita4: convert to uppercase
-    public static final String kClassDescValueHash = ":" +
-       Long.toHexString(
-       ObjectStreamClass_1_3_1.getActualSerialVersionUID(javax.rmi.CORBA.ClassDesc.class)).toUpperCase() + ":" +
-      Long.toHexString(
-       ObjectStreamClass_1_3_1.getSerialVersionUID(javax.rmi.CORBA.ClassDesc.class)).toUpperCase();
-    public static final String kClassDescStubValue = "ClassDesc";
-    public static final String kClassDescTypeStr = "javax.rmi.CORBA."+kClassDescStubValue;
-    public static final String kClassDescValueRepID = kValuePrefix + kClassDescTypeStr + kClassDescValueHash;
-
-    // Object
-    public static final String kObjectValueHash = ":1.0";
-    public static final String kObjectStubValue = "Object";
-
-    // Sequence
-    public static final String kSequenceValueHash = ":1.0";
-    public static final String kPrimitiveSequenceValueHash = ":0000000000000000";
-
-    // Serializable
-    public static final String kSerializableValueHash = ":1.0";
-    public static final String kSerializableStubValue = "Serializable";
-
-    // Externalizable
-    public static final String kExternalizableValueHash = ":1.0";
-    public static final String kExternalizableStubValue = "Externalizable";
-
-    // Remote (The empty string is used for java.rmi.Remote)
-    public static final String kRemoteValueHash = "";
-    public static final String kRemoteStubValue = "";
-    public static final String kRemoteTypeStr = "";
-    public static final String kRemoteValueRepID = "";
-
-    private static final Hashtable kSpecialArrayTypeStrings = new Hashtable();
-
-    static {
-        kSpecialArrayTypeStrings.put("CORBA.WStringValue", new StringBuffer(java.lang.String.class.getName()));
-        kSpecialArrayTypeStrings.put("javax.rmi.CORBA.ClassDesc", new StringBuffer(java.lang.Class.class.getName()));
-        kSpecialArrayTypeStrings.put("CORBA.Object", new StringBuffer(java.rmi.Remote.class.getName()));
-
-    }
-
-    private static final Hashtable kSpecialCasesRepIDs = new Hashtable();
-
-    static {
-        kSpecialCasesRepIDs.put(java.lang.String.class, kWStringValueRepID);
-        kSpecialCasesRepIDs.put(java.lang.Class.class, kClassDescValueRepID);
-        kSpecialCasesRepIDs.put(java.rmi.Remote.class, kRemoteValueRepID);
-    }
-
-    private static final Hashtable kSpecialCasesStubValues = new Hashtable();
-
-    static {
-        kSpecialCasesStubValues.put(java.lang.String.class, kWStringStubValue);
-        kSpecialCasesStubValues.put(java.lang.Class.class, kClassDescStubValue);
-        kSpecialCasesStubValues.put(java.lang.Object.class, kObjectStubValue);
-        kSpecialCasesStubValues.put(java.io.Serializable.class, kSerializableStubValue);
-        kSpecialCasesStubValues.put(java.io.Externalizable.class, kExternalizableStubValue);
-        kSpecialCasesStubValues.put(java.rmi.Remote.class, kRemoteStubValue);
-    }
-
-
-    private static final Hashtable kSpecialCasesVersions = new Hashtable();
-
-    static {
-        kSpecialCasesVersions.put(java.lang.String.class, kWStringValueHash);
-        kSpecialCasesVersions.put(java.lang.Class.class, kClassDescValueHash);
-        kSpecialCasesVersions.put(java.lang.Object.class, kObjectValueHash);
-        kSpecialCasesVersions.put(java.io.Serializable.class, kSerializableValueHash);
-        kSpecialCasesVersions.put(java.io.Externalizable.class, kExternalizableValueHash);
-        kSpecialCasesVersions.put(java.rmi.Remote.class, kRemoteValueHash);
-    }
-
-    private static final Hashtable kSpecialCasesClasses = new Hashtable();
-
-    static {
-        kSpecialCasesClasses.put(kWStringTypeStr, java.lang.String.class);
-        kSpecialCasesClasses.put(kClassDescTypeStr, java.lang.Class.class);
-        kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-
-        kSpecialCasesClasses.put("org.omg.CORBA.WStringValue", java.lang.String.class);
-        kSpecialCasesClasses.put("javax.rmi.CORBA.ClassDesc", java.lang.Class.class);
-        //kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-    }
-
-    private static final Hashtable kSpecialCasesArrayPrefix = new Hashtable();
-
-    static {
-        kSpecialCasesArrayPrefix.put(java.lang.String.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-        kSpecialCasesArrayPrefix.put(java.lang.Class.class, kValuePrefix + kSequencePrefix + "javax/rmi/CORBA/");
-        kSpecialCasesArrayPrefix.put(java.lang.Object.class, kValuePrefix + kSequencePrefix + "java/lang/");
-        kSpecialCasesArrayPrefix.put(java.io.Serializable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.io.Externalizable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.rmi.Remote.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-    }
-
-    private static final Hashtable kSpecialPrimitives = new Hashtable();
-
-    static {
-        kSpecialPrimitives.put("int","long");
-        kSpecialPrimitives.put("long","longlong");
-        kSpecialPrimitives.put("byte","octet");
-    }
-
-    /**
-     * Used to convert ascii to hex.
-     */
-    private static final byte ASCII_HEX[] =     {
-        (byte)'0',
-        (byte)'1',
-        (byte)'2',
-        (byte)'3',
-        (byte)'4',
-        (byte)'5',
-        (byte)'6',
-        (byte)'7',
-        (byte)'8',
-        (byte)'9',
-        (byte)'A',
-        (byte)'B',
-        (byte)'C',
-        (byte)'D',
-        (byte)'E',
-        (byte)'F',
-    };
-
-
-    // bug fix for 4328952; to eliminate possibility of overriding this
-    // in a subclass.
-    public static final RepositoryIdCache_1_3_1 cache = new RepositoryIdCache_1_3_1();
-
-    // Interface Rep ID Strings
-    public static final String kjava_rmi_Remote = createForAnyType(java.rmi.Remote.class);
-    public static final String korg_omg_CORBA_Object = createForAnyType(org.omg.CORBA.Object.class);
-
-    // Dummy arguments for getIdFromHelper method
-    public static final Class kNoParamTypes[] ={};
-    public static final Object kNoArgs[] = {};
-
-
-    // To create a RepositoryID, use code similar to the following:
-    // RepositoryId.cache.getId( id );
-
-    RepositoryId_1_3_1(){}
-
-    RepositoryId_1_3_1(String aRepId){
-        init(aRepId);
-    }
-
-    RepositoryId_1_3_1 init(String aRepId){
-
-        this.repId = aRepId;
-
-        // Special case for remote
-        if (aRepId.length() == 0) {
-            clazz = java.rmi.Remote.class;
-            typeString = "";
-            isRMIValueType = true;
-            suid = kInterfaceOnlyHashStr;
-            return this;
-        }
-        else if (aRepId.equals(kWStringValueRepID)) {
-            clazz = java.lang.String.class;
-            typeString = kWStringTypeStr;
-            isIDLType = true;
-            // fix where Attempting to obtain a FullValueDescription
-            // for an RMI value type with a String field causes an exception.
-            completeClassName = "java.lang.String";
-            versionString = kWStringValueVersion;
-            return this;
-        }
-        else {
-
-        String repId = convertFromISOLatin1(aRepId);
-
-        versionString = repId.substring(repId.indexOf(':', repId.indexOf(':')+1));
-        if (repId.startsWith(kIDLPrefix)) {
-            typeString =
-                repId.substring(kIDLPrefixLength, repId.indexOf(':', kIDLPrefixLength));
-            isIDLType = true;
-            if (typeString.startsWith(kIDLNamePrefix))
-                completeClassName = kIDLClassnamePrefix +
-                    typeString.substring(kIDLNamePrefix.length()).replace('/','.');
-            else completeClassName = typeString.replace('/','.');
-
-        }
-        else if (repId.startsWith(kValuePrefix)) {
-            typeString =
-                repId.substring(kValuePrefixLength, repId.indexOf(':', kValuePrefixLength));
-            isRMIValueType = true;
-
-            if (versionString.indexOf('.') == -1) {
-                    actualSuid = versionString.substring(1);
-                    suid = actualSuid;  // default if not explicitly specified
-
-                    if (actualSuid.indexOf(':') != -1){
-                    // we have a declared hash also
-                        int pos = actualSuid.indexOf(':')+1;
-                        // actualSuid = suid.substring(pos);
-                        // suid = suid.substring(0, pos-1);
-                        suid = actualSuid.substring(pos);
-                        actualSuid = actualSuid.substring(0, pos-1);
-                }
-
-            }
-            else {
-                    // _REVISIT_ : Special case version failure ?
-            }
-        }
-        else isSupportedFormat = false;
-
-        if (typeString.startsWith(kSequencePrefix)) {
-            isSequence = true;
-        }
-
-
-        return this;
-    }
-    }
-
-    public final String getUnqualifiedName() {
-        if (unqualifiedName == null){
-            String className = getClassName();
-            int index = className.lastIndexOf('.');
-            if (index == -1){
-                unqualifiedName = className;
-                definedInId = "IDL::1.0";
-            }
-            else {
-                unqualifiedName = className.substring(index);
-                definedInId = "IDL:" + className.substring(0, index).replace('.','/') + ":1.0";
-            }
-        }
-
-        return unqualifiedName;
-    }
-
-    public final String getDefinedInId() {
-        if (definedInId == null){
-            getUnqualifiedName();
-        }
-
-        return definedInId;
-    }
-
-    public final String getTypeString() {
-        return typeString;
-    }
-
-    public final String getVersionString() {
-        return versionString;
-    }
-
-    public final String getSerialVersionUID() {
-        return suid;
-    }
-
-    public final String getActualSerialVersionUID() {
-        return actualSuid;
-    }
-    public final long getSerialVersionUIDAsLong() {
-        return suidLong;
-    }
-
-    public final long getActualSerialVersionUIDAsLong() {
-        return actualSuidLong;
-    }
-
-    public final boolean isRMIValueType() {
-        return isRMIValueType;
-    }
-
-    public final boolean isIDLType() {
-        return isIDLType;
-    }
-
-    public final String getRepositoryId() {
-        return repId;
-    }
-
-    public static byte[] getByteArray(String repStr) {
-        synchronized (repStrToByteArray){
-            return (byte[]) repStrToByteArray.get(repStr);
-        }
-    }
-
-    public static void setByteArray(String repStr, byte[] repStrBytes) {
-        synchronized (repStrToByteArray){
-            repStrToByteArray.put(repStr, repStrBytes);
-        }
-    }
-
-    public final boolean isSequence() {
-        return isSequence;
-    }
-
-    public final boolean isSupportedFormat() {
-        return isSupportedFormat;
-    }
-
-
-    // This method will return the classname from the typestring OR if the classname turns out to be
-    // a special class "pseudo" name, then the matching real classname is returned.
-    public final String getClassName() {
-
-        if (isRMIValueType)
-            return typeString;
-        else if (isIDLType)
-            return completeClassName;
-        else return null;
-
-    }
-
-    // This method calls getClazzFromType() and falls back to the repStrToClass
-    // cache if no class was found.  It's used where any class matching the
-    // given repid is an acceptable result.
-    public final Class getAnyClassFromType() throws ClassNotFoundException {
-        try {
-            return getClassFromType();
-        } catch (ClassNotFoundException cnfe) {
-            Class clz = (Class)repStrToClass.get(repId);
-            if (clz != null)
-                return clz;
-            else
-                throw cnfe;
-        }
-    }
-
-    public final Class getClassFromType()
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        }
-        else
-            {
-                try{
-                    return Util.loadClass(getClassName(), null, null);
-                }
-                catch(ClassNotFoundException cnfe){
-                    if (defaultServerURL != null) {
-                        try{
-                            return getClassFromType(defaultServerURL);
-                        }
-                        catch(MalformedURLException mue){
-                            throw cnfe;
-                        }
-                    }
-                    else throw cnfe;
-                }
-            }
-
-    }
-
-    public final Class getClassFromType(Class expectedType, String codebase)
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        } else {
-            ClassLoader expectedTypeClassLoader = (expectedType == null ? null : expectedType.getClassLoader());
-            return loadClassOfType(getClassName(),
-                                   codebase,
-                                   expectedTypeClassLoader,
-                                   expectedType,
-                                   expectedTypeClassLoader);
-        }
-
-    }
-
-    public final Class getClassFromType(String url)
-        throws ClassNotFoundException, MalformedURLException {
-        return Util.loadClass(getClassName(), url, null);
-    }
-
-    public final String toString() {
-        return repId;
-    }
-
-    /**
-     * Checks to see if the FullValueDescription should be retrieved.
-     * @exception Throws IOException if suids do not match or if the repositoryID
-     * is not an RMIValueType
-     */
-    public static boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws IOException{
-
-        String clazzRepIDStr = createForAnyType(clazz);
-
-        if (clazzRepIDStr.equals(repositoryID))
-            return false;
-
-        RepositoryId_1_3_1 targetRepid;
-        RepositoryId_1_3_1 clazzRepid;
-
-        synchronized(cache) {
-        // to avoid race condition where multiple threads could be
-        // accessing this method, and their access to the cache may
-        // be interleaved giving unexpected results
-
-            targetRepid = cache.getId(repositoryID);
-            clazzRepid = cache.getId(clazzRepIDStr);
-        }
-        //ObjectStreamClass osc = ObjectStreamClass.lookup(clazz);
-
-        if ((targetRepid.isRMIValueType()) && (clazzRepid.isRMIValueType())){
-            if (!targetRepid.getSerialVersionUID().equals(clazzRepid.getSerialVersionUID())) {
-
-                String mssg = "Mismatched serialization UIDs : Source (Rep. ID" +
-                    clazzRepid + ") = " +
-                    clazzRepid.getSerialVersionUID() + " whereas Target (Rep. ID " + repositoryID +
-                    ") = " + targetRepid.getSerialVersionUID();
-                                //com.sun.corba.se.impl.io.ValueUtility.log("RepositoryId",mssg);
-                throw new IOException(mssg);
-        }
-            else {
-                return true;
-            }
-        }
-        else {
-
-            throw new IOException("The repository ID is not of an RMI value type (Expected ID = " + clazzRepIDStr + "; Received ID = " + repositoryID +")");
-    }
-    }
-
-    private static String createHashString(java.io.Serializable ser) {
-
-        return createHashString(ser.getClass());
-    }
-
-    private static String createHashString(java.lang.Class clazz) {
-
-        if (clazz.isInterface() || !java.io.Serializable.class.isAssignableFrom(clazz))
-            return kInterfaceHashCode;
-
-        //ObjectStreamClass osc = ObjectStreamClass.lookup(clazz);
-
-        long actualLong = ObjectStreamClass_1_3_1.getActualSerialVersionUID(clazz);
-        String hash = null;
-        if (actualLong == 0)
-            hash = kInterfaceOnlyHashStr;
-        else if (actualLong == 1)
-            hash = kExternalizableHashStr;
-        else
-            hash = Long.toHexString(actualLong).toUpperCase();
-        while(hash.length() < 16){
-            hash = "0" + hash;
-        }
-
-        long declaredLong = ObjectStreamClass_1_3_1.getSerialVersionUID(clazz);
-        String declared = null;
-        if (declaredLong == 0)
-            declared = kInterfaceOnlyHashStr;
-        else if (declaredLong == 1)
-            declared = kExternalizableHashStr;
-        else
-            declared = Long.toHexString(declaredLong).toUpperCase();
-        while (declared.length() < 16){
-            declared = "0" + declared;
-    }
-        hash = hash + ":" + declared;
-
-        return ":" + hash;
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a rep id for a sequence of zero
-     * length.  This would be an error.
-     * @param ser The Java object to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Object ser){
-        return createSequenceRepID(ser.getClass());
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a malformed rep id.
-     * @param clazz The Java class to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Class clazz){
-        synchronized (classSeqToRepStr){
-
-        String repid = (String)classSeqToRepStr.get(clazz);
-        if (repid != null)
-            return repid;
-
-        Class originalClazz = clazz;
-
-        Class type = null;
-        int numOfDims = 0;
-
-        while ((type = clazz.getComponentType()) != null) {
-            numOfDims++;
-            clazz = type;
-        }
-
-        if (clazz.isPrimitive())
-            repid = kValuePrefix + originalClazz.getName() + kPrimitiveSequenceValueHash;
-        else {
-            StringBuffer buf = new StringBuffer();
-            buf.append(kValuePrefix);
-            while(numOfDims-- > 0) {
-                buf.append("[");
-            }
-            buf.append("L");
-            buf.append(convertToISOLatin1(clazz.getName()));
-            buf.append(";");
-            buf.append(createHashString(clazz));
-            repid = buf.toString();
-        }
-        classSeqToRepStr.put(originalClazz,repid);
-        return repid;
-        }
-
-    }
-
-
-    public static String createForSpecialCase(java.lang.Class clazz){
-        if (clazz.isArray()){
-            return createSequenceRepID(clazz);
-        }
-        else {
-            return (String)kSpecialCasesRepIDs.get(clazz);
-        }
-    }
-
-    public static String createForSpecialCase(java.io.Serializable ser){
-        Class clazz = ser.getClass();
-        if (clazz.isArray()){
-            return createSequenceRepID(ser);
-        }
-        else
-            return createForSpecialCase(clazz);
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param ser The Java object to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(java.io.Serializable ser)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr) {
-        String repid = createForSpecialCase(ser);
-        if (repid != null)
-            return repid;
-        Class clazz = ser.getClass();
-        repid = (String)classToRepStr.get(clazz);
-
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clazz.getName()) +
-            createHashString(clazz);
-
-        classToRepStr.put(clazz, repid);
-            repStrToClass.put(repid, clazz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param clz The Java class to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(Class clz)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr){
-        String repid = createForSpecialCase(clz);
-        if (repid != null)
-            return repid;
-
-        repid = (String)classToRepStr.get(clz);
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clz.getName()) +
-            createHashString(clz);
-
-        classToRepStr.put(clz, repid);
-            repStrToClass.put(repid, clz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for an IDL Java Type.
-     * @param ser The IDL Value object to create a repository ID for
-     * @param major The major version number
-     * @param minor The minor version number
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser does not implement the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForIDLType(Class ser, int major, int minor)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classIDLToRepStr){
-        String repid = (String)classIDLToRepStr.get(ser);
-        if (repid != null)
-            return repid;
-
-        repid = kIDLPrefix + convertToISOLatin1(ser.getName()).replace('.','/') +
-            ":" + major + "." + minor;
-        classIDLToRepStr.put(ser, repid);
-        return repid;
-    }
-    }
-
-    private static String getIdFromHelper(Class clazz){
-        try {
-            Class helperClazz = Utility.loadClassForClass(clazz.getName()+"Helper", null,
-                                    clazz.getClassLoader(), clazz, clazz.getClassLoader());
-            Method idMethod = helperClazz.getDeclaredMethod("id", kNoParamTypes);
-            return (String)idMethod.invoke(null, kNoArgs);
-        }
-        catch(java.lang.ClassNotFoundException cnfe)
-            {
-                throw new org.omg.CORBA.MARSHAL(cnfe.toString());
-            }
-        catch(java.lang.NoSuchMethodException nsme)
-            {
-                throw new org.omg.CORBA.MARSHAL(nsme.toString());
-            }
-        catch(java.lang.reflect.InvocationTargetException ite)
-            {
-                throw new org.omg.CORBA.MARSHAL(ite.toString());
-            }
-        catch(java.lang.IllegalAccessException iae)
-            {
-                throw new org.omg.CORBA.MARSHAL(iae.toString());
-    }
-    }
-
-    /**
-     * Createa a repository ID for the type if it is either a java type
-     * or an IDL type.
-     * @param type The type to create rep. id for
-     * @return The rep. id.
-     **/
-    public static String createForAnyType(Class type) {
-        try{
-            if (type.isArray())
-                return createSequenceRepID(type);
-            else if (IDLEntity.class.isAssignableFrom(type))
-                {
-                    try{
-                        return getIdFromHelper(type);
-                    }
-                    catch(Throwable t) {
-                        return createForIDLType(type, 1, 0);
-                    }
-                }
-            else return createForJavaType(type);
-        }
-        catch(com.sun.corba.se.impl.io.TypeMismatchException e){
-            return null;
-        }
-
-    }
-
-    public static boolean isAbstractBase(Class clazz) {
-        return (clazz.isInterface() &&
-                IDLEntity.class.isAssignableFrom(clazz) &&
-                (!ValueBase.class.isAssignableFrom(clazz)) &&
-                (!org.omg.CORBA.Object.class.isAssignableFrom(clazz)));
-
-    }
-
-    public static boolean isAnyRequired(Class clazz) {
-        return ((clazz == java.lang.Object.class) ||
-                (clazz == java.io.Serializable.class) ||
-                (clazz == java.io.Externalizable.class));
-    }
-
-    public static long fromHex(String hexNumber) {
-        if (hexNumber.startsWith("0x"))
-            return Long.valueOf(hexNumber.substring(2), 16).longValue();
-        else return Long.valueOf(hexNumber, 16).longValue();
-    }
-
-    /**
-     * Convert strings with illegal IDL identifier characters.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertToISOLatin1 (String name) {
-
-        int length = name.length();
-        if (length == 0) {
-            return name;
-        }
-        StringBuffer buffer = null;
-
-        for (int i = 0; i < length; i++) {
-
-            char c = name.charAt(i);
-
-            if (c > 255 || IDL_IDENTIFIER_CHARS[c] == 0) {
-
-                // We gotta convert. Have we already started?
-
-                if (buffer == null) {
-
-                    // No, so get set up...
-
-                    buffer = new StringBuffer(name.substring(0,i));
-                }
-
-                // Convert the character into the IDL escape syntax...
-                buffer.append(
-                              "\\U" +
-                              (char)ASCII_HEX[(c & 0xF000) >>> 12] +
-                              (char)ASCII_HEX[(c & 0x0F00) >>> 8] +
-                              (char)ASCII_HEX[(c & 0x00F0) >>> 4] +
-                              (char)ASCII_HEX[(c & 0x000F)]);
-
-            } else {
-                if (buffer != null) {
-                    buffer.append(c);
-                }
-            }
-        }
-
-        if (buffer != null) {
-            name = buffer.toString();
-        }
-
-        return name;
-    }
-
-    /**
-     * Convert strings with ISO Latin 1 escape sequences back to original strings.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertFromISOLatin1 (String name) {
-
-        int index = -1;
-        StringBuffer buf = new StringBuffer(name);
-
-        while ((index = buf.toString().indexOf("\\U")) != -1){
-            String str = "0000" + buf.toString().substring(index+2, index+6);
-
-            // Convert Hexadecimal
-            byte[] buffer = new byte[(str.length() - 4) / 2];
-            for (int i=4, j=0; i < str.length(); i +=2, j++) {
-                buffer[j] = (byte)((ORBUtility.hexOf(str.charAt(i)) << 4) & 0xF0);
-                buffer[j] |= (byte)((ORBUtility.hexOf(str.charAt(i+1)) << 0) & 0x0F);
-            }
-            buf = new StringBuffer(delete(buf.toString(), index, index+6));
-            buf.insert(index, (char)buffer[1]);
-        }
-
-        return buf.toString();
-
-
-    }
-
-    private static String delete(String str, int from, int to)
-    {
-        return str.substring(0, from) + str.substring(to, str.length());
-    }
-
-    private static String replace(String target, String arg, String source)
-    {
-        int i = 0;
-        i = target.indexOf(arg);
-
-        while(i != -1)
-            {
-                String left = target.substring(0, i);
-                String right = target.substring(i+arg.length());
-                target = new String(left+source+right);
-                i = target.indexOf(arg);
-            }
-        return target;
-    }
-
-    public static int computeValueTag(boolean codeBasePresent, int typeInfo, boolean chunkedEncoding){
-        int value_tag = kInitialValueTag;
-
-        if (codeBasePresent)
-            value_tag = value_tag | 0x00000001;
-
-        value_tag = value_tag | typeInfo;
-
-        if (chunkedEncoding)
-            value_tag = value_tag | kChunkedMask;
-
-        return value_tag;
-    }
-
-    public static boolean isCodeBasePresent(int value_tag){
-        return ((value_tag & 0x00000001) == 1);
-    }
-
-    public static int getTypeInfo(int value_tag){
-        return (value_tag & 0x00000006);
-    }
-
-    public static boolean isChunkedEncoding(int value_tag){
-        return ((value_tag & kChunkedMask) != 0);
-    }
-
-    public static String getServerURL(){
-        return defaultServerURL;
-    }
-
-    /*
-     * Load a class and check that it is assignable to a given type.
-     * @param className the class name.
-     * @param remoteCodebase the codebase to use. May be null.
-     * @param loader the class loader of last resort. May be null.
-     * @param expectedType the expected type. May be null.
-     * @return the loaded class.
-     */
-    private Class loadClassOfType (String className,
-                                  String remoteCodebase,
-                                  ClassLoader loader,
-                                  Class expectedType,
-                                  ClassLoader expectedTypeClassLoader)
-        throws ClassNotFoundException {
-
-        Class loadedClass = null;
-
-        try {
-            //Sequence finding of the stubs according to spec
-            try{
-                //If-else is put here for speed up of J2EE.
-                //According to the OMG spec, the if clause is not dead code.
-                //It can occur if some compiler has allowed generation
-                //into org.omg.stub hierarchy for non-offending
-                //classes. This will encourage people to
-                //produce non-offending class stubs in their own hierarchy.
-                if(!PackagePrefixChecker
-                   .hasOffendingPrefix(PackagePrefixChecker
-                                       .withoutPackagePrefix(className))){
-                    loadedClass = Util.loadClass
-                        (PackagePrefixChecker.withoutPackagePrefix(className),
-                         remoteCodebase,
-                         loader);
-                } else {
-                    loadedClass = Util.loadClass
-                        (className,
-                         remoteCodebase,
-                         loader);
-                }
-            } catch (ClassNotFoundException cnfe) {
-                loadedClass = Util.loadClass
-                    (className,
-                     remoteCodebase,
-                     loader);
-            }
-            if (expectedType == null)
-                return loadedClass;
-        } catch (ClassNotFoundException cnfe) {
-            if (expectedType == null)
-                throw cnfe;
-        }
-
-        // If no class was not loaded, or if the loaded class is not of the
-        // correct type, make a further attempt to load the correct class
-        // using the classloader of the expected type.
-        // _REVISIT_ Is this step necessary, or should the Util,loadClass
-        // algorithm always produce a valid class if the setup is correct?
-        // Does the OMG standard algorithm need to be changed to include
-        // this step?
-        if (loadedClass == null || !expectedType.isAssignableFrom(loadedClass)) {
-            if (expectedType.getClassLoader() != expectedTypeClassLoader)
-                throw new IllegalArgumentException("expectedTypeClassLoader not class loader of expectedType.");
-
-            if (expectedTypeClassLoader != null)
-                loadedClass = expectedTypeClassLoader.loadClass(className);
-            else
-                loadedClass = Class.forName(className);
-        }
-
-        return loadedClass;
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java b/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-/*
- * Licensed Materials - Property of IBM
- * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
- *
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import javax.rmi.CORBA.Util;
-import javax.rmi.PortableRemoteObject;
-
-import java.util.Hashtable;
-import java.util.Stack;
-import java.io.IOException;
-import java.util.EmptyStackException;
-
-import com.sun.corba.se.impl.util.Utility;
-import com.sun.corba.se.impl.io.IIOPInputStream;
-import com.sun.corba.se.impl.io.IIOPOutputStream;
-import com.sun.corba.se.impl.util.RepositoryId;
-import com.sun.corba.se.impl.util.Utility;
-
-import org.omg.CORBA.TCKind;
-import org.omg.CORBA.MARSHAL;
-import org.omg.CORBA.CompletionStatus;
-import org.omg.CORBA.portable.IndirectionException;
-import com.sun.org.omg.SendingContext.CodeBase;
-
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
-/**
- * This class overrides behavior of our current ValueHandlerImpl to
- * provide backwards compatibility with JDK 1.3.0.
- */
-public class ValueHandlerImpl_1_3 extends com.sun.corba.se.impl.io.ValueHandlerImpl {
-
-    public ValueHandlerImpl_1_3(){
-        super();
-    }
-
-    public ValueHandlerImpl_1_3(boolean isInputStream) {
-        super(isInputStream);
-    }
-
-    /**
-     * Writes the value to the stream using java semantics.
-     * @param out The stream to write the value to
-     * @param value The value to be written to the stream
-     **/
-    public void writeValue(org.omg.CORBA.portable.OutputStream _out, java.io.Serializable value) {
-        super.writeValue(_out, value);
-    }
-
-    /**
-     * Reads a value from the stream using java semantics.
-     * @param in The stream to read the value from
-     * @param clazz The type of the value to be read in
-     * @param sender The sending context runtime
-     **/
-    public java.io.Serializable readValue(org.omg.CORBA.portable.InputStream _in,
-                                          int offset,
-                                          java.lang.Class clazz,
-                                          String repositoryID,
-                                          org.omg.SendingContext.RunTime _sender)
-    {
-        return super.readValue(_in, offset, clazz, repositoryID, _sender);
-    }
-
-    /**
-     * Returns the repository ID for the given RMI value Class.
-     * @param clz The class to return a repository ID for.
-     * @return the repository ID of the Class.
-     **/
-    public java.lang.String getRMIRepositoryID(java.lang.Class clz) {
-        return RepositoryId_1_3.createForJavaType(clz);
-    }
-
-    /**
-     * Indicates whether the given Class performs custom or
-     * default marshaling.
-     * @param clz The class to test for custom marshaling.
-     * @return True if the class performs custom marshaling, false
-     * if it does not.
-     **/
-    public boolean isCustomMarshaled(java.lang.Class clz) {
-        return super.isCustomMarshaled(clz);
-    }
-
-    /**
-     * Returns the CodeBase for this ValueHandler.  This is used by
-     * the ORB runtime.  The server sends the service context containing
-     * the IOR for this CodeBase on the first GIOP reply.  The clients
-     * do the same on the first GIOP request.
-     * @return the SendingContext.CodeBase of this ValueHandler.
-     **/
-    public org.omg.SendingContext.RunTime getRunTimeCodeBase() {
-        return super.getRunTimeCodeBase();
-    }
-
-    /**
-     * If the value contains a writeReplace method then the result
-     * is returned.  Otherwise, the value itself is returned.
-     * @return the true value to marshal on the wire.
-     **/
-    public java.io.Serializable writeReplace(java.io.Serializable value) {
-        return super.writeReplace(value);
-    }
-
-    // methods supported for backward compatability so that the appropriate
-    // Rep-id calculations take place based on the ORB version
-
-    /**
-     *  Returns a boolean of whether or not RepositoryId indicates
-     *  FullValueDescriptor.
-     *  used for backward compatability
-     */
-
-     public boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws IOException
-
-     {
-        return RepositoryId_1_3.useFullValueDescription(clazz, repositoryID);
-     }
-
-     public String getClassName(String id)
-     {
-        RepositoryId_1_3 repID = RepositoryId_1_3.cache.getId(id);
-        return repID.getClassName();
-     }
-
-     public Class getClassFromType(String id)
-        throws ClassNotFoundException
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getClassFromType();
-     }
-
-     public Class getAnyClassFromType(String id)
-        throws ClassNotFoundException
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getAnyClassFromType();
-     }
-
-     public String createForAnyType(Class cl)
-     {
-        return RepositoryId_1_3.createForAnyType(cl);
-     }
-
-     public String getDefinedInId(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getDefinedInId();
-     }
-
-     public String getUnqualifiedName(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getUnqualifiedName();
-     }
-
-     public String getSerialVersionUID(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getSerialVersionUID();
-     }
-
-     public boolean isAbstractBase(Class clazz)
-     {
-        return RepositoryId_1_3.isAbstractBase(clazz);
-     }
-
-     public boolean isSequence(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.isSequence();
-     }
-
-    /**
-     * Preserves the incorrect 1.3 behavior which truncates Java chars in
-     * arrays to 8-bit CORBA chars.  Bug 4367783.  This enables us to
-     * continue interoperating with our legacy ORBs.  If this goes into
-     * Ladybird, then Ladybird and Kestrel will interoperate as long as
-     * people don't use chars greater than 8-bits.
-     */
-    protected void writeCharArray(org.omg.CORBA_2_3.portable.OutputStream out,
-                                char[] array,
-                                int offset,
-                                int length)
-    {
-        out.write_char_array(array, offset, length);
-    }
-
-    /**
-     * Preserves the incorrect 1.3 behavior which truncates Java chars in
-     * arrays to 8-bit CORBA chars.  Bug 4367783.  This enables us to
-     * continue interoperating with our legacy ORBs.  If this goes into
-     * Ladybird, then Ladybird and Kestrel will interoperate as long as
-     * people don't use chars greater than 8-bits.
-     */
-    protected void readCharArray(org.omg.CORBA_2_3.portable.InputStream in,
-                                 char[] array,
-                                 int offset,
-                                 int length)
-    {
-        in.read_char_array(array, offset, length);
-    }
-
-    protected final String getOutputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3";
-    }
-
-    protected final String getInputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3";
-    }
-
-    /**
-     * Our JDK 1.3 and JDK 1.3.1 behavior subclasses override this.
-     * The correct behavior is for a Java char to map to a CORBA wchar,
-     * but our older code mapped it to a CORBA char.
-     */
-    protected TCKind getJavaCharTCKind() {
-        return TCKind.tk_char;
-    }
-}
diff --git a/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java b/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java
deleted file mode 100644
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.orbutil;
-
-import org.omg.CORBA.TCKind;
-
-/**
- * This class overrides behavior of our current ValueHandlerImpl to
- * provide backwards compatibility with JDK 1.3.1.
- */
-public class ValueHandlerImpl_1_3_1
-    extends com.sun.corba.se.impl.io.ValueHandlerImpl
-{
-    public ValueHandlerImpl_1_3_1() {}
-
-    public ValueHandlerImpl_1_3_1(boolean isInputStream) {
-        super(isInputStream);
-    }
-
-    /**
-     * Our JDK 1.3 and JDK 1.3.1 behavior subclasses override this.
-     * The correct behavior is for a Java char to map to a CORBA wchar,
-     * but our older code mapped it to a CORBA char.
-     */
-    protected TCKind getJavaCharTCKind() {
-        return TCKind.tk_char;
-    }
-
-    /**
-     * RepositoryId_1_3_1 performs an incorrect repId calculation
-     * when using serialPersistentFields and one of the fields no longer
-     * exists on the class itself.
-     */
-    public boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws java.io.IOException
-    {
-        return RepositoryId_1_3_1.useFullValueDescription(clazz, repositoryID);
-    }
-
-    /**
-     * Installs the legacy IIOPOutputStream_1_3_1 which does
-     * PutFields/GetFields incorrectly.  Bug 4407244.
-     */
-    protected final String getOutputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3_1";
-    }
-
-    /**
-     * Installs the legacy IIOPInputStream_1_3_1 which does
-     * PutFields/GetFields incorrectly.  Bug 4407244.
-     */
-    protected final String getInputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3_1";
-    }
-}
diff --git a/src/share/classes/sun/corba/JavaCorbaAccess.java b/src/share/classes/sun/corba/JavaCorbaAccess.java
new file mode 100644
--- /dev/null
+++ corba/src/share/classes/sun/corba/JavaCorbaAccess.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.corba;
+
+import com.sun.corba.se.impl.io.ValueHandlerImpl;
+
+public interface JavaCorbaAccess {
+    public ValueHandlerImpl newValueHandlerImpl();
+}
diff --git a/src/share/classes/sun/corba/SharedSecrets.java b/src/share/classes/sun/corba/SharedSecrets.java
new file mode 100644
--- /dev/null
+++ corba/src/share/classes/sun/corba/SharedSecrets.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.corba;
+
+import com.sun.corba.se.impl.io.ValueUtility;
+import sun.misc.Unsafe;
+
+import java.security.AccessController;
+
+/** A repository of "shared secrets", which are a mechanism for
+    calling implementation-private methods in another package without
+    using reflection. A package-private class implements a public
+    interface and provides the ability to call package-private methods
+    within that package; the object implementing that interface is
+    provided through a third package to which access is restricted.
+    This framework avoids the primary disadvantage of using reflection
+    for this purpose, namely the loss of compile-time checking. */
+
+// SharedSecrets cloned in corba repo to avoid build issues
+public class SharedSecrets {
+    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static JavaCorbaAccess javaCorbaAccess;
+
+    public static JavaCorbaAccess getJavaCorbaAccess() {
+        if (javaCorbaAccess == null) {
+            // Ensure ValueUtility is initialized; we know that that class
+            // provides the shared secret
+            unsafe.ensureClassInitialized(ValueUtility.class);
+        }
+        return javaCorbaAccess;
+    }
+
+    public static void setJavaCorbaAccess(JavaCorbaAccess access) {
+        javaCorbaAccess = access;
+    }
+
+}
