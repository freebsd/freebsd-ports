--- ./common/autoconf/build-performance.m4	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/build-performance.m4	Sun May 01 23:37:49 2016 -0700
@@ -41,6 +41,10 @@
     # Looks like a MacOSX system
     NUM_CORES=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Cores' | awk  '{print [$]5}'`
     FOUND_CORES=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    NUM_CORES=`/sbin/sysctl -n hw.ncpu`
+    FOUND_CORES=yes
   elif test "x$OPENJDK_BUILD_OS" = xaix ; then
     NUM_CORES=`/usr/sbin/prtconf | grep "^Number Of Processors" | awk '{ print [$]4 }'`
     FOUND_CORES=yes
@@ -79,6 +83,15 @@
     MEMORY_SIZE=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Memory' | awk  '{print [$]2}'`
     MEMORY_SIZE=`expr $MEMORY_SIZE \* 1024`
     FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o OpenBSD)" = xOpenBSD; then
+    # Looks like an OpenBSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem | awk '{print int($NF / 1048576); }'`
+    FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem`
+    MEMORY_SIZE=`expr $MEMORY_SIZE / 1024 / 1024`
+    FOUND_MEM=yes
   elif test "x$OPENJDK_BUILD_OS" = xwindows; then
     # Windows, but without cygwin
     MEMORY_SIZE=`wmic computersystem get totalphysicalmemory -value | grep = | cut -d "=" -f 2-`
@@ -199,8 +212,8 @@
     # Only use ccache if it is 3.1.4 or later, which supports
     # precompiled headers.
     AC_MSG_CHECKING([if ccache supports precompiled headers])
-    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | grep -E 3.1.@<:@456789@:>@) 2> /dev/null`
-    if test "x$HAS_GOOD_CCACHE" = x; then
+    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | awk '{ split(@S|@3, a, "."); if (a@<:@1@:>@ >= 3 && (a@<:@2@:>@ > 1 || (a@<:@2@:>@ == 1 && a@<:@3@:>@ >= 4))) print "yes"; else print "no"; }') 2> /dev/null`
+    if test "x$HAS_GOOD_CCACHE" = xyes; then
       AC_MSG_RESULT([no, disabling ccache])
       CCACHE=
     else
--- ./common/autoconf/generated-configure.sh	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/generated-configure.sh	Sun May 01 23:37:49 2016 -0700
@@ -646,6 +646,8 @@
 LIBM
 LIBZIP_CAN_USE_MMAP
 USE_EXTERNAL_LIBZ
+GIFLIB_LDFLAGS
+GIFLIB_CFLAGS
 USE_EXTERNAL_LIBGIF
 USE_EXTERNAL_LIBJPEG
 ALSA_LIBS
@@ -819,6 +821,7 @@
 JDK_MAJOR_VERSION
 USER_RELEASE_SUFFIX
 COMPRESS_JARS
+BSD_STATIC_LIBJLI
 UNLIMITED_CRYPTO
 CACERTS_FILE
 TEST_IN_BUILD
@@ -895,6 +898,7 @@
 OPENJDK_TARGET_CPU_ARCH
 OPENJDK_TARGET_CPU
 OPENJDK_TARGET_OS_API
+OPENJDK_TARGET_OS_VENDOR
 OPENJDK_TARGET_OS
 OPENJDK_BUILD_CPU_ENDIAN
 OPENJDK_BUILD_CPU_BITS
@@ -1027,6 +1031,7 @@
 enable_hotspot_test_in_build
 with_cacerts_file
 enable_unlimited_crypto
+enable_static_libjli
 with_milestone
 with_update_version
 with_user_release_suffix
@@ -1053,6 +1058,7 @@
 with_extra_cflags
 with_extra_cxxflags
 with_extra_ldflags
+with_package_path
 enable_debug_symbols
 enable_zip_debug_info
 enable_macosx_runtime_support
@@ -1729,6 +1735,7 @@
                           run the Queens test after Hotspot build [disabled]
   --enable-unlimited-crypto
                           Enable unlimited crypto policy [disabled]
+  --enable-static-libjli  Enable staticly linking libjli on bsd [disabled]
   --disable-debug-symbols disable generation of debug symbols [enabled]
   --disable-zip-debug-info
                           disable zipping of debug-info files [enabled]
@@ -1825,6 +1832,8 @@
   --with-extra-cflags     extra flags to be used when compiling jdk c-files
   --with-extra-cxxflags   extra flags to be used when compiling jdk c++-files
   --with-extra-ldflags    extra flags to be used when linking jdk
+  --with-package-path     package path to be used for location of third party
+                          packages
   --with-x                use the X Window System
   --with-cups             specify prefix directory for the cups package
                           (expecting the headers under PATH/include)
@@ -3880,7 +3889,7 @@
 #CUSTOM_AUTOCONF_INCLUDE
 
 # Do not change or remove the following line, it is needed for consistency checks:
-DATE_WHEN_GENERATED=1449096260
+DATE_WHEN_GENERATED=1460430898
 
 ###############################################################################
 #
@@ -6808,11 +6817,27 @@
       as_fn_error $? "unsupported operating system $build_os" "$LINENO" 5
       ;;
   esac
+  # The BSD's have slight differences so determine which one we are building on.
+  # For the rest set VAR_OS_VENDOR to VAR_OS
+  case "$build_os" in
+    *openbsd*)
+      VAR_OS_VENDOR=openbsd
+      ;;
+    *netbsd*)
+      VAR_OS_VENDOR=netbsd
+      ;;
+    *freebsd*)
+      VAR_OS_VENDOR=freebsd
+      ;;
+    *)
+      VAR_OS_VENDOR="$VAR_OS"
+      ;;
+  esac
 
 
   # First argument is the cpu name from the trip/quad
   case "$build_cpu" in
-    x86_64)
+    amd64|x86_64)
       VAR_CPU=x86_64
       VAR_CPU_ARCH=x86
       VAR_CPU_BITS=64
@@ -6945,11 +6970,27 @@
       as_fn_error $? "unsupported operating system $host_os" "$LINENO" 5
       ;;
   esac
+  # The BSD's have slight differences so determine which one we are building on.
+  # For the rest set VAR_OS_VENDOR to VAR_OS
+  case "$host_os" in
+    *openbsd*)
+      VAR_OS_VENDOR=openbsd
+      ;;
+    *netbsd*)
+      VAR_OS_VENDOR=netbsd
+      ;;
+    *freebsd*)
+      VAR_OS_VENDOR=freebsd
+      ;;
+    *)
+      VAR_OS_VENDOR="$VAR_OS"
+      ;;
+  esac
 
 
   # First argument is the cpu name from the trip/quad
   case "$host_cpu" in
-    x86_64)
+    amd64|x86_64)
       VAR_CPU=x86_64
       VAR_CPU_ARCH=x86
       VAR_CPU_BITS=64
@@ -7022,6 +7063,7 @@
 
   # ... and setup our own variables. (Do this explicitely to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
+  OPENJDK_TARGET_OS_VENDOR="$VAR_OS_VENDOR"
   OPENJDK_TARGET_OS_API="$VAR_OS_API"
   OPENJDK_TARGET_OS_ENV="$VAR_OS_ENV"
   OPENJDK_TARGET_CPU="$VAR_CPU"
@@ -7035,6 +7077,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking openjdk-target os-cpu" >&5
 $as_echo_n "checking openjdk-target os-cpu... " >&6; }
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU" >&5
@@ -7163,8 +7206,8 @@
 
   # Setup OPENJDK_TARGET_CPU_OSARCH, which is used to set the os.arch Java system property
   OPENJDK_TARGET_CPU_OSARCH="$OPENJDK_TARGET_CPU"
-  if test "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
-    # On linux only, we replace x86 with i386.
+  if test "x$OPENJDK_TARGET_OS" = xbsd -o "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
+    # On Linux and BSD, we replace x86 with i386.
     OPENJDK_TARGET_CPU_OSARCH="i386"
   elif test "x$OPENJDK_TARGET_OS" != xmacosx && test "x$OPENJDK_TARGET_CPU" = xx86_64; then
     # On all platforms except macosx, we replace x86_64 with amd64.
@@ -11174,6 +11217,24 @@
 
   ###############################################################################
   #
+  # Enable or disable static linking of libjli on bsd only
+  #
+  # Check whether --enable-static-libjli was given.
+if test "${enable_static_libjli+set}" = set; then :
+  enableval=$enable_static_libjli;
+else
+  enable_static_libjli=no
+fi
+
+  if test "x$OPENJDK_TARGET_OS" = "xbsd" && test "x$enable_static_libjli" = "xyes"; then
+    BSD_STATIC_LIBJLI=bsd
+  else
+    BSD_STATIC_LIBJLI=
+  fi
+
+
+  ###############################################################################
+  #
   # Enable or disable the elliptic curve crypto implementation
   #
 
@@ -19397,6 +19458,8 @@
   elif test "x$OPENJDK_TARGET_OS" = "xaix"; then
     # Do not probe for cc on AIX.
     COMPILER_CHECK_LIST="xlc_r"
+  elif test "`uname -s`" = "FreeBSD"; then
+    COMPILER_CHECK_LIST="cc gcc"
   else
     COMPILER_CHECK_LIST="gcc cc"
   fi
@@ -20357,7 +20420,7 @@
   else
     COMPILER_VERSION_TEST=`$COMPILER --version 2>&1 | $HEAD -n 1`
     # Check that this is likely to be GCC.
-    $COMPILER --version 2>&1 | $GREP "Free Software Foundation" > /dev/null
+    $COMPILER --version 2>&1 | $GREP -E "(Free Software Foundation|clang)" > /dev/null
     if test $? -ne 0; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&5
 $as_echo "$as_me: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&6;}
@@ -21958,7 +22021,7 @@
   else
     COMPILER_VERSION_TEST=`$COMPILER --version 2>&1 | $HEAD -n 1`
     # Check that this is likely to be GCC.
-    $COMPILER --version 2>&1 | $GREP "Free Software Foundation" > /dev/null
+    $COMPILER --version 2>&1 | $GREP -E "(Free Software Foundation|clang)" > /dev/null
     if test $? -ne 0; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&5
 $as_echo "$as_me: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&6;}
@@ -27965,7 +28028,7 @@
 
   # objcopy is used for moving debug symbols to separate files when
   # full debug symbols are enabled.
-  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux; then
+  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux || test "x$OPENJDK_TARGET_OS" = xbsd ; then
     if test -n "$ac_tool_prefix"; then
   for ac_prog in gobjcopy objcopy
   do
@@ -29322,8 +29385,10 @@
       SET_SHARED_LIBRARY_NAME='-Xlinker -install_name -Xlinker @rpath/$1'
       SET_SHARED_LIBRARY_MAPFILE=''
       SET_SHARED_LIBRARY_ORIGIN='-Xlinker -rpath -Xlinker @loader_path/.'
+      POST_STRIP_CMD="$STRIP -S"
+    fi
+    if test "x$OPENJDK_TARGET_OS" = xbsd || test "x$OPENJDK_TARGET_OS" = xmacosx; then
       SET_EXECUTABLE_ORIGIN="$SET_SHARED_LIBRARY_ORIGIN"
-      POST_STRIP_CMD="$STRIP -S"
     fi
   else
     if test "x$OPENJDK_TARGET_OS" = xsolaris; then
@@ -29667,7 +29732,7 @@
   #
   case $COMPILER_NAME in
     gcc )
-      CCXXFLAGS_JDK="$CCXXFLAGS $CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses \
+      CCXXFLAGS_JDK="$CCXXFLAGS $CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses -Wno-sign-compare \
       -pipe \
       -D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE"
       case $OPENJDK_TARGET_CPU_ARCH in
@@ -29749,22 +29814,37 @@
   CCXXFLAGS_JDK="$CCXXFLAGS_JDK $ADD_LP64"
 
   # The package path is used only on macosx?
-  PACKAGE_PATH=/opt/local
+
+# Check whether --with-package-path was given.
+if test "${with_package_path+set}" = set; then :
+  withval=$with_package_path;
+fi
+
+  PACKAGE_PATH="$with_package_path"
+  if test "x$PACKAGE_PATH" = x; then
+    if test "`uname -s`" = "Darwin"; then
+      PACKAGE_PATH=/opt/local
+    fi
+
+    if test "`uname -s`" = "FreeBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+
+    if test "`uname -s`" = "NetBSD"; then
+      PACKAGE_PATH=/usr/pkg
+    fi
+
+    if test "`uname -s`" = "OpenBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+  fi
+
 
 
   if test "x$OPENJDK_TARGET_CPU_ENDIAN" = xlittle; then
-    # The macro _LITTLE_ENDIAN needs to be defined the same to avoid the
-    #   Sun C compiler warning message: warning: macro redefined: _LITTLE_ENDIAN
-    #   (The Solaris X86 system defines this in file /usr/include/sys/isa_defs.h).
-    #   Note: -Dmacro         is the same as    #define macro 1
-    #         -Dmacro=        is the same as    #define macro
-    if test "x$OPENJDK_TARGET_OS" = xsolaris; then
-      CCXXFLAGS_JDK="$CCXXFLAGS_JDK -D_LITTLE_ENDIAN="
-    else
-      CCXXFLAGS_JDK="$CCXXFLAGS_JDK -D_LITTLE_ENDIAN"
-    fi
-  else
-    CCXXFLAGS_JDK="$CCXXFLAGS_JDK -D_BIG_ENDIAN"
+    CCXXFLAGS_JDK="$CCXXFLAGS_JDK -DVM_LITTLE_ENDIAN"
+  else
+    CCXXFLAGS_JDK="$CCXXFLAGS_JDK -DVM_BIG_ENDIAN"
   fi
   if test "x$OPENJDK_TARGET_OS" = xlinux; then
     CCXXFLAGS_JDK="$CCXXFLAGS_JDK -DLINUX"
@@ -30261,11 +30341,18 @@
   fi
 
   if test "x$OPENJDK_TARGET_OS" = xbsd; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking what is not needed on bsd?" >&5
-$as_echo_n "checking what is not needed on bsd?... " >&6; }
-    ALSA_NOT_NEEDED=yes
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: alsa" >&5
-$as_echo "alsa" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking what is not needed on BSD?" >&5
+$as_echo_n "checking what is not needed on BSD?... " >&6; }
+    if test "x$OPENJDK_TARGET_OS_VENDOR" = xopenbsd; then
+      ALSA_NOT_NEEDED=yes
+      PULSE_NOT_NEEDED=yes
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: alsa pulse" >&5
+$as_echo "alsa pulse" >&6; }
+    else
+      PULSE_NOT_NEEDED=yes
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: pulse" >&5
+$as_echo "pulse" >&6; }
+    fi
   fi
 
   if test "x$OPENJDK" = "xfalse"; then
@@ -30301,14 +30388,18 @@
   # --x-libraries for the sysroot, if that seems to be correct.
   if test "x$SYS_ROOT" != "x/"; then
     if test "x$x_includes" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
+      if test -f "$SYS_ROOT/usr/X11R7/include/X11/Xlib.h"; then
+        x_includes="$SYS_ROOT/usr/X11R7/include"
+      elif test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/X11R6/include"
       elif test -f "$SYS_ROOT/usr/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/include"
       fi
     fi
     if test "x$x_libraries" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
+      if test -f "$SYS_ROOT/usr/X11R7/lib/libX11.so"; then
+        x_libraries="$SYS_ROOT/usr/X11R7/lib"
+      elif test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
         x_libraries="$SYS_ROOT/usr/X11R6/lib"
       elif test "$SYS_ROOT/usr/lib64/libX11.so" && test "x$OPENJDK_TARGET_CPU_BITS" = x64; then
         x_libraries="$SYS_ROOT/usr/lib64"
@@ -31355,6 +31446,10 @@
         # A CSW package seems to be installed!
         CUPS_FOUND=yes
         CUPS_CFLAGS="-I/opt/csw/include"
+      elif test -s ${PACKAGE_PATH}/include/cups/cups.h; then
+        # Standard package location for BSD
+        CUPS_FOUND=yes
+        CUPS_CFLAGS="-I${PACKAGE_PATH}/include"
       fi
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CUPS_FOUND" >&5
 $as_echo "$CUPS_FOUND" >&6; }
@@ -34520,7 +34615,7 @@
 
   ###############################################################################
   #
-  # Check for alsa headers and libraries. Used on Linux/GNU systems.
+  # Check for alsa headers and libraries. Used on Linux/GNU and BSD systems.
   #
 
 # Check whether --with-alsa was given.
@@ -34928,15 +35023,66 @@
 
   if test "x${with_giflib}" = "xbundled"; then
     USE_EXTERNAL_LIBGIF=false
+    GIFLIB_CFLAGS=
+    GIFLIB_LDFLAGS=
   elif test "x${with_giflib}" = "xsystem"; then
+    GIFLIB_H_FOUND=no
     ac_fn_cxx_check_header_mongrel "$LINENO" "gif_lib.h" "ac_cv_header_gif_lib_h" "$ac_includes_default"
 if test "x$ac_cv_header_gif_lib_h" = xyes; then :
 
-else
-   as_fn_error $? "--with-giflib=system specified, but gif_lib.h not found!" "$LINENO" 5
-fi
-
-
+           GIFLIB_H_FOUND=yes
+           GIFLIB_CFLAGS=
+
+
+fi
+
+
+    if test "x$GIFLIB_H_FOUND" = xno; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for giflib headers" >&5
+$as_echo_n "checking for giflib headers... " >&6; }
+      if test -s ${PACKAGE_PATH}/include/gif_lib.h; then
+        # Standard package location for BSD
+        GIFLIB_H_FOUND=yes
+        GIFLIB_CFLAGS="-I${PACKAGE_PATH}/include"
+      fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GIFLIB_H_FOUND" >&5
+$as_echo "$GIFLIB_H_FOUND" >&6; }
+    fi
+    if test "x$GIFLIB_H_FOUND" = xno; then
+
+  # Print a helpful message on how to acquire the necessary build dependency.
+  # giflib is the help tag: freetype, cups, pulse, alsa etc
+  MISSING_DEPENDENCY=giflib
+
+  if test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.cygwin"; then
+    cygwin_help $MISSING_DEPENDENCY
+  elif test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.msys"; then
+    msys_help $MISSING_DEPENDENCY
+  else
+    PKGHANDLER_COMMAND=
+
+    case $PKGHANDLER in
+      apt-get)
+        apt_help     $MISSING_DEPENDENCY ;;
+      yum)
+        yum_help     $MISSING_DEPENDENCY ;;
+      port)
+        port_help    $MISSING_DEPENDENCY ;;
+      pkgutil)
+        pkgutil_help $MISSING_DEPENDENCY ;;
+      pkgadd)
+        pkgadd_help  $MISSING_DEPENDENCY ;;
+    esac
+
+    if test "x$PKGHANDLER_COMMAND" != x; then
+      HELP_MSG="You might be able to fix this by running '$PKGHANDLER_COMMAND'."
+    fi
+  fi
+
+      as_fn_error $? "Could not find giflib headers! $HELP_MSG " "$LINENO" 5
+    fi
+
+    GIFLIB_LIB_FOUND=no
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for DGifGetCode in -lgif" >&5
 $as_echo_n "checking for DGifGetCode in -lgif... " >&6; }
 if ${ac_cv_lib_gif_DGifGetCode+:} false; then :
@@ -34974,16 +35120,96 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gif_DGifGetCode" >&5
 $as_echo "$ac_cv_lib_gif_DGifGetCode" >&6; }
 if test "x$ac_cv_lib_gif_DGifGetCode" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGIF 1
-_ACEOF
-
-  LIBS="-lgif $LIBS"
-
-else
-   as_fn_error $? "--with-giflib=system specified, but no giflib found!" "$LINENO" 5
-fi
-
+
+           GIFLIB_LIB_FOUND=yes
+           GIFLIB_LDFLAGS=
+
+
+fi
+
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+      save_LDFLAGS="$LDFLAGS"
+      LDFLAGS="$LDFLAGS -L${PACKAGE_PATH}/lib"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for DGifOpen in -lgif" >&5
+$as_echo_n "checking for DGifOpen in -lgif... " >&6; }
+if ${ac_cv_lib_gif_DGifOpen+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgif  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char DGifOpen ();
+int
+main ()
+{
+return DGifOpen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_gif_DGifOpen=yes
+else
+  ac_cv_lib_gif_DGifOpen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gif_DGifOpen" >&5
+$as_echo "$ac_cv_lib_gif_DGifOpen" >&6; }
+if test "x$ac_cv_lib_gif_DGifOpen" = xyes; then :
+
+             GIFLIB_LIB_FOUND=yes
+             GIFLIB_LDFLAGS="-L${PACKAGE_PATH}/lib"
+
+
+fi
+
+      LDFLAGS="$save_LDFLAGS"
+    fi
+
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+
+  # Print a helpful message on how to acquire the necessary build dependency.
+  # giflib is the help tag: freetype, cups, pulse, alsa etc
+  MISSING_DEPENDENCY=giflib
+
+  if test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.cygwin"; then
+    cygwin_help $MISSING_DEPENDENCY
+  elif test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.msys"; then
+    msys_help $MISSING_DEPENDENCY
+  else
+    PKGHANDLER_COMMAND=
+
+    case $PKGHANDLER in
+      apt-get)
+        apt_help     $MISSING_DEPENDENCY ;;
+      yum)
+        yum_help     $MISSING_DEPENDENCY ;;
+      port)
+        port_help    $MISSING_DEPENDENCY ;;
+      pkgutil)
+        pkgutil_help $MISSING_DEPENDENCY ;;
+      pkgadd)
+        pkgadd_help  $MISSING_DEPENDENCY ;;
+    esac
+
+    if test "x$PKGHANDLER_COMMAND" != x; then
+      HELP_MSG="You might be able to fix this by running '$PKGHANDLER_COMMAND'."
+    fi
+  fi
+
+      as_fn_error $? "Could not find giflib library! $HELP_MSG " "$LINENO" 5
+    fi
 
     USE_EXTERNAL_LIBGIF=true
   else
@@ -34991,6 +35217,8 @@
   fi
 
 
+
+
   ###############################################################################
   #
   # Check for the zlib library
@@ -35558,6 +35786,11 @@
     LIBCXX="-lstdc++"
   fi
 
+  # TODO better (platform agnostic) test
+  if test "x$OPENJDK_TARGET_OS" = xbsd && test "x$LIBCXX" = x && test "x$GCC" = xyes; then
+    LIBCXX="-lstdc++"
+  fi
+
 
 
 
@@ -35631,6 +35864,10 @@
     # Looks like a MacOSX system
     NUM_CORES=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Cores' | awk  '{print $5}'`
     FOUND_CORES=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    NUM_CORES=`/sbin/sysctl -n hw.ncpu`
+    FOUND_CORES=yes
   elif test "x$OPENJDK_BUILD_OS" = xaix ; then
     NUM_CORES=`/usr/sbin/prtconf | grep "^Number Of Processors" | awk '{ print $4 }'`
     FOUND_CORES=yes
@@ -35686,6 +35923,15 @@
     MEMORY_SIZE=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Memory' | awk  '{print $2}'`
     MEMORY_SIZE=`expr $MEMORY_SIZE \* 1024`
     FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o OpenBSD)" = xOpenBSD; then
+    # Looks like an OpenBSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem | awk '{print int($NF / 1048576); }'`
+    FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem`
+    MEMORY_SIZE=`expr $MEMORY_SIZE / 1024 / 1024`
+    FOUND_MEM=yes
   elif test "x$OPENJDK_BUILD_OS" = xwindows; then
     # Windows, but without cygwin
     MEMORY_SIZE=`wmic computersystem get totalphysicalmemory -value | grep = | cut -d "=" -f 2-`
@@ -36093,8 +36339,8 @@
     # precompiled headers.
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking if ccache supports precompiled headers" >&5
 $as_echo_n "checking if ccache supports precompiled headers... " >&6; }
-    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | grep -E 3.1.[456789]) 2> /dev/null`
-    if test "x$HAS_GOOD_CCACHE" = x; then
+    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | awk '{ split($3, a, "."); if (a[1] >= 3 && (a[2] > 1 || (a[2] == 1 && a[3] >= 4))) print "yes"; else print "no"; }') 2> /dev/null`
+    if test "x$HAS_GOOD_CCACHE" = xyes; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, disabling ccache" >&5
 $as_echo "no, disabling ccache" >&6; }
       CCACHE=
--- ./common/autoconf/jdk-options.m4	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/jdk-options.m4	Sun May 01 23:37:49 2016 -0700
@@ -410,6 +410,20 @@
 
   ###############################################################################
   #
+  # Enable or disable static linking of libjli on bsd only
+  #
+  AC_ARG_ENABLE(static-libjli, [AS_HELP_STRING([--enable-static-libjli],
+      [Enable staticly linking libjli on bsd @<:@disabled@:>@])],,
+      [enable_static_libjli=no])
+  if test "x$OPENJDK_TARGET_OS" = "xbsd" && test "x$enable_static_libjli" = "xyes"; then
+    BSD_STATIC_LIBJLI=bsd
+  else
+    BSD_STATIC_LIBJLI=
+  fi
+  AC_SUBST(BSD_STATIC_LIBJLI)
+
+  ###############################################################################
+  #
   # Enable or disable the elliptic curve crypto implementation
   #
   AC_DEFUN_ONCE([JDKOPT_DETECT_INTREE_EC],
--- ./common/autoconf/libraries.m4	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/libraries.m4	Sun May 01 23:37:49 2016 -0700
@@ -69,9 +69,15 @@
   fi
 
   if test "x$OPENJDK_TARGET_OS" = xbsd; then
-    AC_MSG_CHECKING([what is not needed on bsd?])
-    ALSA_NOT_NEEDED=yes
-    AC_MSG_RESULT([alsa])
+    AC_MSG_CHECKING([what is not needed on BSD?])
+    if test "x$OPENJDK_TARGET_OS_VENDOR" = xopenbsd; then
+      ALSA_NOT_NEEDED=yes
+      PULSE_NOT_NEEDED=yes
+      AC_MSG_RESULT([alsa pulse])
+    else
+      PULSE_NOT_NEEDED=yes
+      AC_MSG_RESULT([pulse])
+    fi
   fi
 
   if test "x$OPENJDK" = "xfalse"; then
@@ -99,14 +105,18 @@
   # --x-libraries for the sysroot, if that seems to be correct.
   if test "x$SYS_ROOT" != "x/"; then
     if test "x$x_includes" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
+      if test -f "$SYS_ROOT/usr/X11R7/include/X11/Xlib.h"; then
+        x_includes="$SYS_ROOT/usr/X11R7/include"
+      elif test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/X11R6/include"
       elif test -f "$SYS_ROOT/usr/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/include"
       fi
     fi
     if test "x$x_libraries" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
+      if test -f "$SYS_ROOT/usr/X11R7/lib/libX11.so"; then
+        x_libraries="$SYS_ROOT/usr/X11R7/lib"
+      elif test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
         x_libraries="$SYS_ROOT/usr/X11R6/lib"
       elif test "$SYS_ROOT/usr/lib64/libX11.so" && test "x$OPENJDK_TARGET_CPU_BITS" = x64; then
         x_libraries="$SYS_ROOT/usr/lib64"
@@ -232,6 +242,10 @@
         # A CSW package seems to be installed!
         CUPS_FOUND=yes
         CUPS_CFLAGS="-I/opt/csw/include"
+      elif test -s ${PACKAGE_PATH}/include/cups/cups.h; then
+        # Standard package location for BSD
+        CUPS_FOUND=yes
+        CUPS_CFLAGS="-I${PACKAGE_PATH}/include"
       fi
       AC_MSG_RESULT([$CUPS_FOUND])
     fi
@@ -525,7 +539,7 @@
 
   ###############################################################################
   #
-  # Check for alsa headers and libraries. Used on Linux/GNU systems.
+  # Check for alsa headers and libraries. Used on Linux/GNU and BSD systems.
   #
   AC_ARG_WITH(alsa, [AS_HELP_STRING([--with-alsa],
       [specify prefix directory for the alsa package
@@ -627,17 +641,61 @@
 
   if test "x${with_giflib}" = "xbundled"; then
     USE_EXTERNAL_LIBGIF=false
+    GIFLIB_CFLAGS=
+    GIFLIB_LDFLAGS=
   elif test "x${with_giflib}" = "xsystem"; then
-    AC_CHECK_HEADER(gif_lib.h, [],
-        [ AC_MSG_ERROR([--with-giflib=system specified, but gif_lib.h not found!])])
-    AC_CHECK_LIB(gif, DGifGetCode, [],
-        [ AC_MSG_ERROR([--with-giflib=system specified, but no giflib found!])])
+    GIFLIB_H_FOUND=no
+    AC_CHECK_HEADER(gif_lib.h,
+        [
+           GIFLIB_H_FOUND=yes
+           GIFLIB_CFLAGS=
+        ]
+    )
+    if test "x$GIFLIB_H_FOUND" = xno; then
+      AC_MSG_CHECKING([for giflib headers])
+      if test -s ${PACKAGE_PATH}/include/gif_lib.h; then
+        # Standard package location for BSD
+        GIFLIB_H_FOUND=yes
+        GIFLIB_CFLAGS="-I${PACKAGE_PATH}/include"
+      fi
+      AC_MSG_RESULT([$GIFLIB_H_FOUND])
+    fi
+    if test "x$GIFLIB_H_FOUND" = xno; then
+      HELP_MSG_MISSING_DEPENDENCY([giflib])
+      AC_MSG_ERROR([Could not find giflib headers! $HELP_MSG ])
+    fi
+
+    GIFLIB_LIB_FOUND=no
+    AC_CHECK_LIB(gif, DGifGetCode,
+        [
+           GIFLIB_LIB_FOUND=yes
+           GIFLIB_LDFLAGS=
+        ]
+    )
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+      save_LDFLAGS="$LDFLAGS"
+      LDFLAGS="$LDFLAGS -L${PACKAGE_PATH}/lib"
+      AC_CHECK_LIB(gif, DGifOpen,
+          [
+             GIFLIB_LIB_FOUND=yes
+             GIFLIB_LDFLAGS="-L${PACKAGE_PATH}/lib"
+          ]
+      )
+      LDFLAGS="$save_LDFLAGS"
+    fi
+
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+      HELP_MSG_MISSING_DEPENDENCY([giflib])
+      AC_MSG_ERROR([Could not find giflib library! $HELP_MSG ])
+    fi
 
     USE_EXTERNAL_LIBGIF=true
   else
     AC_MSG_ERROR([Invalid value of --with-giflib: ${with_giflib}, use 'system' or 'bundled'])
   fi
   AC_SUBST(USE_EXTERNAL_LIBGIF)
+  AC_SUBST(GIFLIB_CFLAGS)
+  AC_SUBST(GIFLIB_LDFLAGS)
 
   ###############################################################################
   #
@@ -872,5 +930,10 @@
     LIBCXX="-lstdc++"
   fi
 
+  # TODO better (platform agnostic) test
+  if test "x$OPENJDK_TARGET_OS" = xbsd && test "x$LIBCXX" = x && test "x$GCC" = xyes; then
+    LIBCXX="-lstdc++"
+  fi
+
   AC_SUBST(LIBCXX)
 ])
--- ./common/autoconf/platform.m4	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/platform.m4	Sun May 01 23:37:49 2016 -0700
@@ -30,7 +30,7 @@
 [
   # First argument is the cpu name from the trip/quad
   case "$1" in
-    x86_64)
+    amd64|x86_64)
       VAR_CPU=x86_64
       VAR_CPU_ARCH=x86
       VAR_CPU_BITS=64
@@ -147,6 +147,22 @@
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+  # The BSD's have slight differences so determine which one we are building on.
+  # For the rest set VAR_OS_VENDOR to VAR_OS
+  case "$1" in
+    *openbsd*)
+      VAR_OS_VENDOR=openbsd
+      ;;
+    *netbsd*)
+      VAR_OS_VENDOR=netbsd
+      ;;
+    *freebsd*)
+      VAR_OS_VENDOR=freebsd
+      ;;
+    *)
+      VAR_OS_VENDOR="$VAR_OS"
+      ;;
+  esac
 ])
 
 # Expects $host_os $host_cpu $build_os and $build_cpu
@@ -192,6 +208,7 @@
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
   # ... and setup our own variables. (Do this explicitely to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
+  OPENJDK_TARGET_OS_VENDOR="$VAR_OS_VENDOR"
   OPENJDK_TARGET_OS_API="$VAR_OS_API"
   OPENJDK_TARGET_OS_ENV="$VAR_OS_ENV"
   OPENJDK_TARGET_CPU="$VAR_CPU"
@@ -199,6 +216,7 @@
   OPENJDK_TARGET_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_TARGET_CPU_ENDIAN="$VAR_CPU_ENDIAN"
   AC_SUBST(OPENJDK_TARGET_OS)
+  AC_SUBST(OPENJDK_TARGET_OS_VENDOR)
   AC_SUBST(OPENJDK_TARGET_OS_API)
   AC_SUBST(OPENJDK_TARGET_CPU)
   AC_SUBST(OPENJDK_TARGET_CPU_ARCH)
@@ -308,8 +326,8 @@
 
   # Setup OPENJDK_TARGET_CPU_OSARCH, which is used to set the os.arch Java system property
   OPENJDK_TARGET_CPU_OSARCH="$OPENJDK_TARGET_CPU"
-  if test "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
-    # On linux only, we replace x86 with i386.
+  if test "x$OPENJDK_TARGET_OS" = xbsd -o "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
+    # On Linux and BSD, we replace x86 with i386.
     OPENJDK_TARGET_CPU_OSARCH="i386"
   elif test "x$OPENJDK_TARGET_OS" != xmacosx && test "x$OPENJDK_TARGET_CPU" = xx86_64; then
     # On all platforms except macosx, we replace x86_64 with amd64.
--- ./common/autoconf/spec.gmk.in	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/spec.gmk.in	Sun May 01 23:37:49 2016 -0700
@@ -76,6 +76,7 @@
 OPENJDK_TARGET_OS:=@OPENJDK_TARGET_OS@
 OPENJDK_TARGET_OS_API:=@OPENJDK_TARGET_OS_API@
 OPENJDK_TARGET_OS_ENV:=@OPENJDK_TARGET_OS_ENV@
+OPENJDK_TARGET_OS_VENDOR:=@OPENJDK_TARGET_OS_VENDOR@
 
 OPENJDK_TARGET_CPU:=@OPENJDK_TARGET_CPU@
 OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET_CPU_ARCH@
@@ -276,7 +277,7 @@
 ALSA_LIBS:=@ALSA_LIBS@
 ALSA_CFLAGS:=@ALSA_CFLAGS@
 
-PACKAGE_PATH=@PACKAGE_PATH@
+PACKAGE_PATH:=@PACKAGE_PATH@
 
 # Source file for cacerts
 CACERTS_FILE=@CACERTS_FILE@
@@ -284,6 +285,9 @@
 # Enable unlimited crypto policy
 UNLIMITED_CRYPTO=@UNLIMITED_CRYPTO@
 
+# Build static libjli on bsd
+BSD_STATIC_LIBJLI=@BSD_STATIC_LIBJLI@
+
 # Necessary additional compiler flags to compile X11
 X_CFLAGS:=@X_CFLAGS@
 X_LIBS:=@X_LIBS@
@@ -564,6 +568,8 @@
 ENABLE_INTREE_EC=@ENABLE_INTREE_EC@
 USE_EXTERNAL_LIBJPEG:=@USE_EXTERNAL_LIBJPEG@
 USE_EXTERNAL_LIBGIF:=@USE_EXTERNAL_LIBGIF@
+GIFLIB_CFLAGS:=@GIFLIB_CFLAGS@
+GIFLIB_LDFLAGS:=@GIFLIB_LDFLAGS@
 USE_EXTERNAL_LIBZ:=@USE_EXTERNAL_LIBZ@
 LIBZIP_CAN_USE_MMAP:=@LIBZIP_CAN_USE_MMAP@
 MSVCR_DLL:=@MSVCR_DLL@
--- ./common/autoconf/toolchain.m4	Tue Mar 22 11:03:36 2016 -0700
+++ ./common/autoconf/toolchain.m4	Sun May 01 23:37:49 2016 -0700
@@ -72,7 +72,7 @@
   else
     COMPILER_VERSION_TEST=`$COMPILER --version 2>&1 | $HEAD -n 1`
     # Check that this is likely to be GCC.
-    $COMPILER --version 2>&1 | $GREP "Free Software Foundation" > /dev/null
+    $COMPILER --version 2>&1 | $GREP -E "(Free Software Foundation|clang)" > /dev/null
     if test $? -ne 0; then
       AC_MSG_NOTICE([The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler.])
       AC_MSG_NOTICE([The result from running with --version was: "$COMPILER_VERSION_TEST"])
@@ -350,6 +350,8 @@
   elif test "x$OPENJDK_TARGET_OS" = "xaix"; then
     # Do not probe for cc on AIX.
     COMPILER_CHECK_LIST="xlc_r"
+  elif test "`uname -s`" = "FreeBSD"; then
+    COMPILER_CHECK_LIST="cc gcc"
   else
     COMPILER_CHECK_LIST="gcc cc"
   fi
@@ -571,7 +573,7 @@
 
   # objcopy is used for moving debug symbols to separate files when
   # full debug symbols are enabled.
-  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux; then
+  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux || test "x$OPENJDK_TARGET_OS" = xbsd ; then
     AC_CHECK_TOOLS(OBJCOPY, [gobjcopy objcopy])
     # Only call fixup if objcopy was found.
     if test -n "$OBJCOPY"; then
@@ -634,8 +636,10 @@
       SET_SHARED_LIBRARY_NAME='-Xlinker -install_name -Xlinker @rpath/[$]1'
       SET_SHARED_LIBRARY_MAPFILE=''
       SET_SHARED_LIBRARY_ORIGIN='-Xlinker -rpath -Xlinker @loader_path/.'
+      POST_STRIP_CMD="$STRIP -S"
+    fi
+    if test "x$OPENJDK_TARGET_OS" = xbsd || test "x$OPENJDK_TARGET_OS" = xmacosx; then
       SET_EXECUTABLE_ORIGIN="$SET_SHARED_LIBRARY_ORIGIN"
-      POST_STRIP_CMD="$STRIP -S"
     fi
   else
     if test "x$OPENJDK_TARGET_OS" = xsolaris; then
@@ -957,7 +961,7 @@
   #
   case $COMPILER_NAME in
     gcc )
-      CCXXFLAGS_JDK="$CCXXFLAGS $CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses \
+      CCXXFLAGS_JDK="$CCXXFLAGS $CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses -Wno-sign-compare \
       -pipe \
       -D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE"
       case $OPENJDK_TARGET_CPU_ARCH in
@@ -1039,22 +1043,33 @@
   CCXXFLAGS_JDK="$CCXXFLAGS_JDK $ADD_LP64"
 
   # The package path is used only on macosx?
-  PACKAGE_PATH=/opt/local
+  AC_ARG_WITH(package-path, [AS_HELP_STRING([--with-package-path],
+      [package path to be used for location of third party packages])])
+  PACKAGE_PATH="$with_package_path"
+  if test "x$PACKAGE_PATH" = x; then
+    if test "`uname -s`" = "Darwin"; then
+      PACKAGE_PATH=/opt/local
+    fi
+
+    if test "`uname -s`" = "FreeBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+
+    if test "`uname -s`" = "NetBSD"; then
+      PACKAGE_PATH=/usr/pkg
+    fi
+
+    if test "`uname -s`" = "OpenBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+  fi
+
   AC_SUBST(PACKAGE_PATH)
 
   if test "x$OPENJDK_TARGET_CPU_ENDIAN" = xlittle; then
-    # The macro _LITTLE_ENDIAN needs to be defined the same to avoid the
-    #   Sun C compiler warning message: warning: macro redefined: _LITTLE_ENDIAN
-    #   (The Solaris X86 system defines this in file /usr/include/sys/isa_defs.h).
-    #   Note: -Dmacro         is the same as    #define macro 1
-    #         -Dmacro=        is the same as    #define macro
-    if test "x$OPENJDK_TARGET_OS" = xsolaris; then
-      CCXXFLAGS_JDK="$CCXXFLAGS_JDK -D_LITTLE_ENDIAN="
-    else
-      CCXXFLAGS_JDK="$CCXXFLAGS_JDK -D_LITTLE_ENDIAN"
-    fi
+    CCXXFLAGS_JDK="$CCXXFLAGS_JDK -DVM_LITTLE_ENDIAN"
   else
-    CCXXFLAGS_JDK="$CCXXFLAGS_JDK -D_BIG_ENDIAN"
+    CCXXFLAGS_JDK="$CCXXFLAGS_JDK -DVM_BIG_ENDIAN"
   fi
   if test "x$OPENJDK_TARGET_OS" = xlinux; then
     CCXXFLAGS_JDK="$CCXXFLAGS_JDK -DLINUX"
--- ./configure	Tue Mar 22 11:03:36 2016 -0700
+++ ./configure	Sun May 01 23:37:49 2016 -0700
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 #
 # Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
--- ./make/Javadoc.gmk	Tue Mar 22 11:03:36 2016 -0700
+++ ./make/Javadoc.gmk	Sun May 01 23:37:49 2016 -0700
@@ -46,8 +46,18 @@
 
 BUILD_NUMBER=$(JDK_BUILD_NUMBER)
 
+ifeq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+  ifeq ($(OPENJDK_TARGET_CPU_BITS), 32)
+    JAVADOC_CMD_MEM = "-Xmx768m"
+  else
+    JAVADOC_CMD_MEM = "-Xmx1024m"
+  endif
+else
+  JAVADOC_CMD_MEM = "-Xmx1024m"
+endif
+
 JAVADOC_CMD = $(JAVA) \
-    -Xmx1024m \
+    $(JAVADOC_CMD_MEM) \
     -Djava.awt.headless=true \
     $(NEW_JAVADOC) \
     -bootclasspath $(JDK_OUTPUTDIR)/classes
--- ./make/Main.gmk	Tue Mar 22 11:03:36 2016 -0700
+++ ./make/Main.gmk	Sun May 01 23:37:49 2016 -0700
@@ -58,7 +58,11 @@
 
 # Setup number of jobs to use. -jN is unfortunately not available for us to parse from the command line,
 # hence this workaround.
+ifdef JOBS
+ifneq ($(JOBS),0)
 MAKE_ARGS:=$(MAKE_ARGS) -j$(JOBS)
+endif
+endif
 
 ### Main targets
 
--- ./make/common/MakeBase.gmk	Tue Mar 22 11:03:36 2016 -0700
+++ ./make/common/MakeBase.gmk	Sun May 01 23:37:49 2016 -0700
@@ -338,7 +338,7 @@
     # (and causing a crash on Cygwin).
     # Default shell seems to always be /bin/sh. Must override with bash to get this to work on Solaris.
     # Only use time if it's GNU time which supports format and output file.
-    WRAPPER_SHELL:=/bin/bash $$(SRC_ROOT)/common/bin/shell-tracer.sh $$(if $$(findstring yes,$$(IS_GNU_TIME)),$$(TIME),-) $$(OUTPUT_ROOT)/build-trace-time.log /bin/bash
+    WRAPPER_SHELL:=bash $$(SRC_ROOT)/common/bin/shell-tracer.sh $$(if $$(findstring yes,$$(IS_GNU_TIME)),$$(TIME),-) $$(OUTPUT_ROOT)/build-trace-time.log bash
     SHELL=$$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$<, (from $$<))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(WRAPPER_SHELL)
   endif
   # Never remove warning messages; this is just for completeness
@@ -365,8 +365,8 @@
 
 # This is to be called by all SetupFoo macros
 define LogSetupMacroEntry
-  $(if $(27),$(error Internal makefile error: Too many arguments to LogSetupMacroEntry, please update MakeBase.gmk))
-  $(if $(findstring $(LOG_LEVEL),debug trace), $(info $1 $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26,$(if $($i),$(NEWLINE) $(strip [$i] $($i))))))
+  $(if $(30),$(error Internal makefile error: Too many arguments to LogSetupMacroEntry, please update MakeBase.gmk))
+  $(if $(findstring $(LOG_LEVEL),debug trace), $(info $1 $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29,$(if $($i),$(NEWLINE) $(strip [$i] $($i))))))
 endef
 
 # Make directory without forking mkdir if not needed
--- ./make/common/NativeCompilation.gmk	Tue Mar 22 11:03:36 2016 -0700
+++ ./make/common/NativeCompilation.gmk	Sun May 01 23:37:49 2016 -0700
@@ -151,9 +151,9 @@
   #   CC the compiler to use, default is $(CC)
   #   LDEXE the linker to use for linking executables, default is $(LDEXE)
   #   OPTIMIZATION sets optimization level to NONE, LOW, HIGH, HIGHEST
-  $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26, $(if $($i),$1_$(strip $($i)))$(NEWLINE))
-  $(call LogSetupMacroEntry,SetupNativeCompilation($1),$2,$3,$4,$5,$6,$7,$8,$9,$(10),$(11),$(12),$(13),$(14),$(15),$(16),$(17),$(18),$(19),$(20),$(21),$(22),$(23),$(24),$(25),$(26))
-  $(if $(27),$(error Internal makefile error: Too many arguments to SetupNativeCompilation, please update NativeCompilation.gmk))
+  $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29, $(if $($i),$1_$(strip $($i)))$(NEWLINE))
+  $(call LogSetupMacroEntry,SetupNativeCompilation($1),$2,$3,$4,$5,$6,$7,$8,$9,$(10),$(11),$(12),$(13),$(14),$(15),$(16),$(17),$(18),$(19),$(20),$(21),$(22),$(23),$(24),$(25),$(26),$(27),$(28),$(29))
+  $(if $(30),$(error Internal makefile error: Too many arguments to SetupNativeCompilation, please update NativeCompilation.gmk))
 
   ifneq (,$$($1_BIN))
     $$(error BIN has been replaced with OBJECT_DIR)
--- ./hotspot/make/bsd/Makefile	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/Makefile	Mon May 09 17:15:53 2016 -0400
@@ -66,6 +66,10 @@
     FORCE_TIERED=1
   endif
 endif
+# C1 is not ported on ppc64, so we cannot build a tiered VM:
+ifeq ($(ARCH),ppc64)
+  FORCE_TIERED=0
+endif
 
 ifdef LP64
   ifeq ("$(filter $(LP64_ARCH),$(BUILDARCH))","")
--- ./hotspot/make/bsd/makefiles/build_vm_def.sh	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/build_vm_def.sh	Mon May 09 17:15:53 2016 -0400
@@ -1,12 +1,28 @@
 #!/bin/sh
 
 # If we're cross compiling use that path for nm
-if [ "$CROSS_COMPILE_ARCH" != "" ]; then 
-NM=$ALT_COMPILER_PATH/nm
+if [ "$CROSS_COMPILE_ARCH" != "" ]; then
+    NM=$ALT_COMPILER_PATH/nm
 else
-NM=nm
+    NM=nm
 fi
 
-$NM -Uj $* | awk '
-   { if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 }
-   '
+case "$(uname -s)" in
+Darwin )
+    $NM -Uj $@ | awk '{
+        if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3
+    }' ;;
+OpenBSD )
+    $NM $@ | awk '{
+        if ($2 == "U") next
+        if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 ";"
+        if ($3 ~ /^UseSharedSpaces$/) print "\t" $3 ";"
+        if ($3 ~ /^_ZN9Arguments17SharedArchivePathE$/) print "\t" $3 ";"
+    }' | sort -u ;;
+* )
+    $NM --defined-only $@ | awk '{
+        if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 ";"
+        if ($3 ~ /^UseSharedSpaces$/) print "\t" $3 ";"
+        if ($3 ~ /^_ZN9Arguments17SharedArchivePathE$/) print "\t" $3 ";"
+    }' | sort -u ;;
+esac
--- ./hotspot/make/bsd/makefiles/debug.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/debug.make	Mon May 09 17:15:53 2016 -0400
@@ -35,7 +35,10 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug
+ifeq ($(OS_VENDOR), Darwin)
+MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug$(MAPSUFX)
 
 VERSION = debug
 SYSDEFS += -DASSERT
--- ./hotspot/make/bsd/makefiles/defs.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/defs.make	Mon May 09 17:15:53 2016 -0400
@@ -29,7 +29,10 @@
 SLASH_JAVA ?= /java
 
 # Need PLATFORM (os-arch combo names) for jdk and hotspot, plus libarch name
-ARCH:=$(shell uname -m)
+# ARCH can be set explicitly in spec.gmk
+ifndef ARCH
+  ARCH := $(shell uname -m)
+endif
 PATH_SEP = :
 ifeq ($(LP64), 1)
   ARCH_DATA_MODEL ?= 64
@@ -124,6 +127,15 @@
   HS_ARCH          = ppc
 endif
 
+# PPC64
+ifeq ($(ARCH), ppc64)
+  ARCH_DATA_MODEL  = 64
+  MAKE_ARGS        += LP64=1
+  PLATFORM         = bsd-ppc64
+  VM_PLATFORM      = bsd_ppc64
+  HS_ARCH          = ppc
+endif
+
 # On 32 bit bsd we build server and client, on 64 bit just server.
 ifeq ($(JVM_VARIANTS),)
   ifeq ($(ARCH_DATA_MODEL), 32)
@@ -321,6 +333,18 @@
 ifeq ($(JVM_VARIANT_MINIMAL1),true)
   EXPORT_LIST += $(EXPORT_MINIMAL_DIR)/Xusage.txt
   EXPORT_LIST += $(EXPORT_MINIMAL_DIR)/libjvm.$(LIBRARY_SUFFIX)
+
+  ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+    ifeq ($(ZIP_DEBUGINFO_FILES),1)
+        EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.diz
+    else
+      ifeq ($(OS_VENDOR), Darwin)
+          EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX).dSYM
+      else
+          EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.debuginfo
+      endif
+    endif
+  endif
 endif
 
 # Serviceability Binaries
--- ./hotspot/make/bsd/makefiles/fastdebug.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/fastdebug.make	Mon May 09 17:15:53 2016 -0400
@@ -56,7 +56,10 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug
+ifeq ($(OS_VENDOR), Darwin)
+MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug$(MAPSUFX)
 
 VERSION = fastdebug
 SYSDEFS += -DASSERT -DCHECK_UNHANDLED_OOPS
--- ./hotspot/make/bsd/makefiles/gcc.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/gcc.make	Mon May 09 17:15:53 2016 -0400
@@ -168,6 +168,9 @@
   CFLAGS += -DDONT_USE_PRECOMPILED_HEADER
 endif
 
+# Allow for where third party packages are located
+CFLAGS+= -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+
 #------------------------------------------------------------------------
 # Compiler flags
 
@@ -201,12 +204,15 @@
 endif
 
 ifeq ($(USE_CLANG), true)
-  # Before Clang 3.1, we had to pass the stack alignment specification directly to llvm with the help of '-mllvm'
-  # Starting with version 3.1, Clang understands the '-mstack-alignment' (and rejects '-mllvm -stack-alignment')
-  ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 3 \) \| \( \( $(CC_VER_MAJOR) = 3 \) \& \( $(CC_VER_MINOR) \>= 1 \) \))" "0"
-    STACK_ALIGNMENT_OPT = -mno-omit-leaf-frame-pointer -mstack-alignment=16
-  else
-    STACK_ALIGNMENT_OPT = -mno-omit-leaf-frame-pointer -mllvm -stack-alignment=16
+  STACK_ALIGNMENT_OPT = -mno-omit-leaf-frame-pointer
+  ifeq ($(OS_VENDOR), Darwin)
+    # Before Clang 3.1, we had to pass the stack alignment specification directly to llvm with the help of '-mllvm'
+    # Starting with version 3.1, Clang understands the '-mstack-alignment' (and rejects '-mllvm -stack-alignment')
+    ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 3 \) \| \( \( $(CC_VER_MAJOR) = 3 \) \& \( $(CC_VER_MINOR) \>= 1 \) \))" "0"
+      STACK_ALIGNMENT_OPT += -mstack-alignment=16
+    else
+      STACK_ALIGNMENT_OPT += -mllvm -stack-alignment=16
+    endif
   endif
 endif
 
@@ -265,7 +271,7 @@
 ifeq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 3 \) \))" "0"
   # Since GCC 4.3, -Wconversion has changed its meanings to warn these implicit
   # conversions which might affect the values. Only enable it in earlier versions.
-  WARNING_FLAGS = -Wunused-function
+#  WARNING_FLAGS = -Wunused-function
   ifeq ($(USE_CLANG),)
     WARNING_FLAGS += -Wconversion
   endif
@@ -421,53 +427,43 @@
   CFLAGS += -flimit-debug-info
 endif
 
+# Use the stabs format for debugging information (this is the default
+# on gcc-2.91). It's good enough, has all the information about line
+# numbers and local variables, and libjvm.so is only about 16M.
+# Change this back to "-g" if you want the most expressive format.
+# (warning: that could easily inflate libjvm.so to 150M!)
+# Note: The Itanium gcc compiler crashes when using -gstabs.
+# Don't use stabs on gcc>=4.8 because it is incompatible with
+# pre-compiled-headers
+ifeq ($(USE_CLANG), true)
+  # Clang doesn't understand -gstabs
+  STABS_CFLAGS += -g
+else
+  ifeq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 8 \) \))" "1"
+    # GCC >= 4.8
+    STABS_CFLAGS += -g
+  else
+    STABS_CFLAGS/ia64  = -g
+    STABS_CFLAGS/arm   = -g
+    STABS_CFLAGS/ppc   = -g
+    ifeq ($(STABS_CFLAGS/$(BUILDARCH)),)
+      STABS_CFLAGS += -gstabs
+    else
+      STABS_CFLAGS += $(STABS_CFLAGS/$(BUILDARCH))
+    endif
+  endif
+endif
+
 # DEBUG_BINARIES uses full -g debug information for all configs
 ifeq ($(DEBUG_BINARIES), true)
   CFLAGS += -g
 else
-  # Use the stabs format for debugging information (this is the default
-  # on gcc-2.91). It's good enough, has all the information about line
-  # numbers and local variables, and libjvm.so is only about 16M.
-  # Change this back to "-g" if you want the most expressive format.
-  # (warning: that could easily inflate libjvm.so to 150M!)
-  # Note: The Itanium gcc compiler crashes when using -gstabs.
-  DEBUG_CFLAGS/ia64  = -g
-  DEBUG_CFLAGS/amd64 = -g
-  DEBUG_CFLAGS/arm   = -g
-  DEBUG_CFLAGS/ppc   = -g
-  DEBUG_CFLAGS += $(DEBUG_CFLAGS/$(BUILDARCH))
-  ifeq ($(DEBUG_CFLAGS/$(BUILDARCH)),)
-  DEBUG_CFLAGS += -gstabs
-  endif
+  DEBUG_CFLAGS += ${STABS_CFLAGS}
   
   ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
-    FASTDEBUG_CFLAGS/ia64  = -g
-    FASTDEBUG_CFLAGS/amd64 = -g
-    FASTDEBUG_CFLAGS/arm   = -g
-    FASTDEBUG_CFLAGS/ppc   = -g
-    FASTDEBUG_CFLAGS += $(FASTDEBUG_CFLAGS/$(BUILDARCH))
-    ifeq ($(FASTDEBUG_CFLAGS/$(BUILDARCH)),)
-      ifeq ($(USE_CLANG), true)
-        # Clang doesn't understand -gstabs
-        FASTDEBUG_CFLAGS += -g
-      else
-        FASTDEBUG_CFLAGS += -gstabs
-      endif
-    endif
+    FASTDEBUG_CFLAGS += ${STABS_CFLAGS}
   
-    OPT_CFLAGS/ia64  = -g
-    OPT_CFLAGS/amd64 = -g
-    OPT_CFLAGS/arm   = -g
-    OPT_CFLAGS/ppc   = -g
-    OPT_CFLAGS += $(OPT_CFLAGS/$(BUILDARCH))
-    ifeq ($(OPT_CFLAGS/$(BUILDARCH)),)
-      ifeq ($(USE_CLANG), true)
-        # Clang doesn't understand -gstabs
-        OPT_CFLAGS += -g
-      else
-        OPT_CFLAGS += -gstabs
-      endif
-    endif
+    OPT_CFLAGS += ${STABS_CFLAGS}
   endif
 endif
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/launcher.make	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,117 @@
+#
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+
+# Rules to build gamma launcher, used by vm.make
+
+
+LAUNCHER_SCRIPT = hotspot
+LAUNCHER   = gamma
+
+LAUNCHERDIR   := $(GAMMADIR)/src/os/posix/launcher
+LAUNCHERDIR_SHARE := $(GAMMADIR)/src/share/tools/launcher
+LAUNCHERFLAGS := $(ARCHFLAG) \
+                -I$(LAUNCHERDIR) -I$(GAMMADIR)/src/share/vm/prims \
+                -I$(LAUNCHERDIR_SHARE) \
+                -DFULL_VERSION=\"$(HOTSPOT_RELEASE_VERSION)\" \
+                -DJDK_MAJOR_VERSION=\"$(JDK_MAJOR_VERSION)\" \
+                -DJDK_MINOR_VERSION=\"$(JDK_MINOR_VERSION)\" \
+                -DARCH=\"$(LIBARCH)\" \
+                -DGAMMA \
+                -DLAUNCHER_TYPE=\"gamma\" \
+                -DLINK_INTO_$(LINK_INTO) \
+                $(TARGET_DEFINES)
+# Give the launcher task_for_pid() privileges so that it can be used to run JStack, JInfo, et al.
+ifeq ($(OS_VENDOR), Darwin)
+LFLAGS_LAUNCHER += -sectcreate __TEXT __info_plist $(GAMMADIR)/src/os/bsd/launcher/Info-privileged.plist
+endif
+
+ifeq ($(LINK_INTO),AOUT)
+  LAUNCHER.o                 = launcher.o $(JVM_OBJ_FILES)
+  LAUNCHER_MAPFILE           = mapfile_reorder
+  LFLAGS_LAUNCHER$(LDNOMAP) += $(MAPFLAG:FILENAME=$(LAUNCHER_MAPFILE))
+  LFLAGS_LAUNCHER           += $(SONAMEFLAG:SONAME=$(LIBJVM)) $(STATIC_LIBGCC)
+  LIBS_LAUNCHER             += $(STATIC_STDCXX) $(LIBS)
+else
+  LAUNCHER.o                 = launcher.o
+  LFLAGS_LAUNCHER           += -L`pwd`
+
+  # The gamma launcher runs the JDK from $JAVA_HOME, overriding the JVM with a
+  # freshly built JVM at ./libjvm.{so|dylib}.  This is accomplished by setting
+  # the library searchpath using ({DY}LD_LIBRARY_PATH) to find the local JVM
+  # first.  Gamma dlopen()s libjava from $JAVA_HOME/jre/lib{/$arch}, which is
+  # statically linked with CoreFoundation framework libs. Unfortunately, gamma's
+  # unique searchpath results in some unresolved symbols in the framework
+  # libraries, because JDK libraries are inadvertently discovered first on the
+  # searchpath, e.g. libjpeg.  On Mac OS X, filenames are case *insensitive*.
+  # So, the actual filename collision is libjpeg.dylib and libJPEG.dylib.
+  # To resolve this, gamma needs to also statically link with the CoreFoundation
+  # framework libraries.
+
+  ifeq ($(OS_VENDOR),Darwin)
+    LFLAGS_LAUNCHER         += -framework CoreFoundation
+  endif
+
+  LIBS_LAUNCHER             += -l$(JVM) $(LIBS)
+endif
+
+LINK_LAUNCHER = $(LINK.CC)
+
+LINK_LAUNCHER/PRE_HOOK  = $(LINK_LIB.CXX/PRE_HOOK)
+LINK_LAUNCHER/POST_HOOK = $(LINK_LIB.CXX/POST_HOOK)
+
+LAUNCHER_OUT = launcher
+
+SUFFIXES += .d
+
+SOURCES := $(shell find $(LAUNCHERDIR) -name "*.c")
+SOURCES_SHARE := $(shell find $(LAUNCHERDIR_SHARE) -name "*.c")
+
+OBJS := $(patsubst $(LAUNCHERDIR)/%.c,$(LAUNCHER_OUT)/%.o,$(SOURCES)) $(patsubst $(LAUNCHERDIR_SHARE)/%.c,$(LAUNCHER_OUT)/%.o,$(SOURCES_SHARE))
+
+DEPFILES := $(patsubst %.o,%.d,$(OBJS))
+-include $(DEPFILES)
+
+$(LAUNCHER_OUT)/%.o: $(LAUNCHERDIR_SHARE)/%.c
+	$(QUIETLY) [ -d $(LAUNCHER_OUT) ] || { mkdir -p $(LAUNCHER_OUT); }
+	$(QUIETLY) $(CC) -g -o $@ -c $< -MMD $(LAUNCHERFLAGS) $(CXXFLAGS)
+
+$(LAUNCHER_OUT)/%.o: $(LAUNCHERDIR)/%.c
+	$(QUIETLY) [ -d $(LAUNCHER_OUT) ] || { mkdir -p $(LAUNCHER_OUT); }
+	$(QUIETLY) $(CC) -g -o $@ -c $< -MMD $(LAUNCHERFLAGS) $(CXXFLAGS)
+
+$(LAUNCHER): $(OBJS) $(LIBJVM) $(LAUNCHER_MAPFILE)
+	$(QUIETLY) echo Linking launcher...
+	$(QUIETLY) $(LINK_LAUNCHER/PRE_HOOK)
+	$(QUIETLY) $(LINK_LAUNCHER) $(LFLAGS_LAUNCHER) -o $@ $(sort $(OBJS)) $(LIBS_LAUNCHER)
+	$(QUIETLY) $(LINK_LAUNCHER/POST_HOOK)
+	# Sign the launcher with the development certificate (if present) so that it can be used
+	# to run JStack, JInfo, et al.
+	$(QUIETLY) -codesign -s openjdk_codesign $@
+
+$(LAUNCHER): $(LAUNCHER_SCRIPT)
+
+$(LAUNCHER_SCRIPT): $(LAUNCHERDIR)/launcher.script
+	$(QUIETLY) sed -e 's/@@LIBARCH@@/$(LIBARCH)/g' $< > $@
+	$(QUIETLY) chmod +x $@
+
--- ./hotspot/make/bsd/makefiles/mapfile-vers-debug	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-debug	Mon May 09 17:15:53 2016 -0400
@@ -21,246 +21,254 @@
 # questions.
 #
 #
-# Only used for OSX/Darwin builds
 
 # Define public interface.
+
+SUNWprivate_1.1 {
+        global:
                 # _JNI
-                _JNI_CreateJavaVM
-                _JNI_GetCreatedJavaVMs
-                _JNI_GetDefaultJavaVMInitArgs
+                JNI_CreateJavaVM;
+                JNI_GetCreatedJavaVMs;
+                JNI_GetDefaultJavaVMInitArgs;
 
-                # _JVM
-                _JVM_Accept
-                _JVM_ActiveProcessorCount
-                _JVM_AllocateNewArray
-                _JVM_AllocateNewObject
-                _JVM_ArrayCopy
-                _JVM_AssertionStatusDirectives
-                _JVM_Available
-                _JVM_Bind
-                _JVM_ClassDepth
-                _JVM_ClassLoaderDepth
-                _JVM_Clone
-                _JVM_Close
-                _JVM_CX8Field
-                _JVM_CompileClass
-                _JVM_CompileClasses
-                _JVM_CompilerCommand
-                _JVM_Connect
-                _JVM_ConstantPoolGetClassAt
-                _JVM_ConstantPoolGetClassAtIfLoaded
-                _JVM_ConstantPoolGetDoubleAt
-                _JVM_ConstantPoolGetFieldAt
-                _JVM_ConstantPoolGetFieldAtIfLoaded
-                _JVM_ConstantPoolGetFloatAt
-                _JVM_ConstantPoolGetIntAt
-                _JVM_ConstantPoolGetLongAt
-                _JVM_ConstantPoolGetMethodAt
-                _JVM_ConstantPoolGetMethodAtIfLoaded
-                _JVM_ConstantPoolGetMemberRefInfoAt
-                _JVM_ConstantPoolGetSize
-                _JVM_ConstantPoolGetStringAt
-                _JVM_ConstantPoolGetUTF8At
-                _JVM_CountStackFrames
-                _JVM_CurrentClassLoader
-                _JVM_CurrentLoadedClass
-                _JVM_CurrentThread
-                _JVM_CurrentTimeMillis
-                _JVM_DefineClass
-                _JVM_DefineClassWithSource
-                _JVM_DefineClassWithSourceCond
-                _JVM_DesiredAssertionStatus
-                _JVM_DisableCompiler
-                _JVM_DoPrivileged
-                _JVM_DTraceGetVersion
-                _JVM_DTraceActivate
-                _JVM_DTraceIsProbeEnabled
-                _JVM_DTraceIsSupported
-                _JVM_DTraceDispose
-                _JVM_DumpAllStacks
-                _JVM_DumpThreads
-                _JVM_EnableCompiler
-                _JVM_Exit
-                _JVM_FillInStackTrace
-                _JVM_FindClassFromCaller
-                _JVM_FindClassFromClass
-                _JVM_FindClassFromClassLoader
-                _JVM_FindClassFromBootLoader
-                _JVM_FindLibraryEntry
-                _JVM_FindLoadedClass
-                _JVM_FindPrimitiveClass
-                _JVM_FindSignal
-                _JVM_FreeMemory
-                _JVM_GC
-                _JVM_GetAllThreads
-                _JVM_GetArrayElement
-                _JVM_GetArrayLength
-                _JVM_GetCPClassNameUTF
-                _JVM_GetCPFieldClassNameUTF
-                _JVM_GetCPFieldModifiers
-                _JVM_GetCPFieldNameUTF
-                _JVM_GetCPFieldSignatureUTF
-                _JVM_GetCPMethodClassNameUTF
-                _JVM_GetCPMethodModifiers
-                _JVM_GetCPMethodNameUTF
-                _JVM_GetCPMethodSignatureUTF
-                _JVM_GetCallerClass
-                _JVM_GetClassAccessFlags
-                _JVM_GetClassAnnotations
-                _JVM_GetClassCPEntriesCount
-                _JVM_GetClassCPTypes
-                _JVM_GetClassConstantPool
-                _JVM_GetClassContext
-                _JVM_GetClassDeclaredConstructors
-                _JVM_GetClassDeclaredFields
-                _JVM_GetClassDeclaredMethods
-                _JVM_GetClassFieldsCount
-                _JVM_GetClassInterfaces
-                _JVM_GetClassLoader
-                _JVM_GetClassMethodsCount
-                _JVM_GetClassModifiers
-                _JVM_GetClassName
-                _JVM_GetClassNameUTF
-                _JVM_GetClassSignature
-                _JVM_GetClassSigners
-                _JVM_GetClassTypeAnnotations
-                _JVM_GetComponentType
-                _JVM_GetDeclaredClasses
-                _JVM_GetDeclaringClass
-                _JVM_GetEnclosingMethodInfo
-                _JVM_GetFieldAnnotations
-                _JVM_GetFieldIxModifiers
-                _JVM_GetFieldTypeAnnotations
-                _JVM_GetHostName
-                _JVM_GetInheritedAccessControlContext
-                _JVM_GetInterfaceVersion
-                _JVM_GetLastErrorString
-                _JVM_GetManagement
-                _JVM_GetMethodAnnotations
-                _JVM_GetMethodDefaultAnnotationValue
-                _JVM_GetMethodIxArgsSize
-                _JVM_GetMethodIxByteCode
-                _JVM_GetMethodIxByteCodeLength
-                _JVM_GetMethodIxExceptionIndexes
-                _JVM_GetMethodIxExceptionTableEntry
-                _JVM_GetMethodIxExceptionTableLength
-                _JVM_GetMethodIxExceptionsCount
-                _JVM_GetMethodIxLocalsCount
-                _JVM_GetMethodIxMaxStack
-                _JVM_GetMethodIxModifiers
-                _JVM_GetMethodIxNameUTF
-                _JVM_GetMethodIxSignatureUTF
-                _JVM_GetMethodParameterAnnotations
-                _JVM_GetMethodParameters
-                _JVM_GetMethodTypeAnnotations
-                _JVM_GetPrimitiveArrayElement
-                _JVM_GetProtectionDomain
-                _JVM_GetSockName
-                _JVM_GetSockOpt
-                _JVM_GetStackAccessControlContext
-                _JVM_GetStackTraceDepth
-                _JVM_GetStackTraceElement
-                _JVM_GetSystemPackage
-                _JVM_GetSystemPackages
-                _JVM_GetTemporaryDirectory
-                _JVM_GetThreadStateNames
-                _JVM_GetThreadStateValues
-                _JVM_GetVersionInfo
-                _JVM_Halt
-                _JVM_HoldsLock
-                _JVM_IHashCode
-                _JVM_InitAgentProperties
-                _JVM_InitProperties
-                _JVM_InitializeCompiler
-                _JVM_InitializeSocketLibrary
-                _JVM_InternString
-                _JVM_Interrupt
-                _JVM_InvokeMethod
-                _JVM_IsArrayClass
-                _JVM_IsConstructorIx
-                _JVM_IsInterface
-                _JVM_IsInterrupted
-                _JVM_IsNaN
-                _JVM_IsPrimitiveClass
-                _JVM_IsSameClassPackage
-                _JVM_IsSilentCompiler
-                _JVM_IsSupportedJNIVersion
-                _JVM_IsThreadAlive
-                _JVM_IsVMGeneratedMethodIx
-                _JVM_KnownToNotExist
-                _JVM_GetResourceLookupCacheURLs
-                _JVM_GetResourceLookupCache
-                _JVM_LatestUserDefinedLoader
-                _JVM_Listen
-                _JVM_LoadClass0
-                _JVM_LoadLibrary
-                _JVM_Lseek
-                _JVM_MaxObjectInspectionAge
-                _JVM_MaxMemory
-                _JVM_MonitorNotify
-                _JVM_MonitorNotifyAll
-                _JVM_MonitorWait
-                _JVM_NanoTime
-                _JVM_NativePath
-                _JVM_NewArray
-                _JVM_NewInstanceFromConstructor
-                _JVM_NewMultiArray
-                _JVM_OnExit
-                _JVM_Open
-                _JVM_RaiseSignal
-                _JVM_RawMonitorCreate
-                _JVM_RawMonitorDestroy
-                _JVM_RawMonitorEnter
-                _JVM_RawMonitorExit
-                _JVM_Read
-                _JVM_Recv
-                _JVM_RecvFrom
-                _JVM_RegisterSignal
-                _JVM_ReleaseUTF
-                _JVM_ResolveClass
-                _JVM_ResumeThread
-                _JVM_Send
-                _JVM_SendTo
-                _JVM_SetArrayElement
-                _JVM_SetClassSigners
-                _JVM_SetLength
-                _JVM_SetNativeThreadName
-                _JVM_SetPrimitiveArrayElement
-                _JVM_SetSockOpt
-                _JVM_SetThreadPriority
-                _JVM_Sleep
-                _JVM_Socket
-                _JVM_SocketAvailable
-                _JVM_SocketClose
-                _JVM_SocketShutdown
-                _JVM_StartThread
-                _JVM_StopThread
-                _JVM_SuspendThread
-                _JVM_SupportsCX8
-                _JVM_Sync
-                _JVM_Timeout
-                _JVM_TotalMemory
-                _JVM_TraceInstructions
-                _JVM_TraceMethodCalls
-                _JVM_UnloadLibrary
-                _JVM_Write
-                _JVM_Yield
-                _JVM_handle_bsd_signal
+                # JVM
+                JVM_Accept;
+                JVM_ActiveProcessorCount;
+                JVM_AllocateNewArray;
+                JVM_AllocateNewObject;
+                JVM_ArrayCopy;
+                JVM_AssertionStatusDirectives;
+                JVM_Available;
+                JVM_Bind;
+                JVM_ClassDepth;
+                JVM_ClassLoaderDepth;
+                JVM_Clone;
+                JVM_Close;
+                JVM_CX8Field;
+                JVM_CompileClass;
+                JVM_CompileClasses;
+                JVM_CompilerCommand;
+                JVM_Connect;
+                JVM_ConstantPoolGetClassAt;
+                JVM_ConstantPoolGetClassAtIfLoaded;
+                JVM_ConstantPoolGetDoubleAt;
+                JVM_ConstantPoolGetFieldAt;
+                JVM_ConstantPoolGetFieldAtIfLoaded;
+                JVM_ConstantPoolGetFloatAt;
+                JVM_ConstantPoolGetIntAt;
+                JVM_ConstantPoolGetLongAt;
+                JVM_ConstantPoolGetMethodAt;
+                JVM_ConstantPoolGetMethodAtIfLoaded;
+                JVM_ConstantPoolGetMemberRefInfoAt;
+                JVM_ConstantPoolGetSize;
+                JVM_ConstantPoolGetStringAt;
+                JVM_ConstantPoolGetUTF8At;
+                JVM_CountStackFrames;
+                JVM_CurrentClassLoader;
+                JVM_CurrentLoadedClass;
+                JVM_CurrentThread;
+                JVM_CurrentTimeMillis;
+                JVM_DefineClass;
+                JVM_DefineClassWithSource;
+                JVM_DefineClassWithSourceCond;
+                JVM_DesiredAssertionStatus;
+                JVM_DisableCompiler;
+                JVM_DoPrivileged;
+                JVM_DTraceGetVersion;
+                JVM_DTraceActivate;
+                JVM_DTraceIsProbeEnabled;
+                JVM_DTraceIsSupported;
+                JVM_DTraceDispose;
+                JVM_DumpAllStacks;
+                JVM_DumpThreads;
+                JVM_EnableCompiler;
+                JVM_Exit;
+                JVM_FillInStackTrace;
+                JVM_FindClassFromCaller;
+                JVM_FindClassFromClass;
+                JVM_FindClassFromClassLoader;
+                JVM_FindClassFromBootLoader;
+                JVM_FindLibraryEntry;
+                JVM_FindLoadedClass;
+                JVM_FindPrimitiveClass;
+                JVM_FindSignal;
+                JVM_FreeMemory;
+                JVM_GC;
+                JVM_GetAllThreads;
+                JVM_GetArrayElement;
+                JVM_GetArrayLength;
+                JVM_GetCPClassNameUTF;
+                JVM_GetCPFieldClassNameUTF;
+                JVM_GetCPFieldModifiers;
+                JVM_GetCPFieldNameUTF;
+                JVM_GetCPFieldSignatureUTF;
+                JVM_GetCPMethodClassNameUTF;
+                JVM_GetCPMethodModifiers;
+                JVM_GetCPMethodNameUTF;
+                JVM_GetCPMethodSignatureUTF;
+                JVM_GetCallerClass;
+                JVM_GetClassAccessFlags;
+                JVM_GetClassAnnotations;
+                JVM_GetClassCPEntriesCount;
+                JVM_GetClassCPTypes;
+                JVM_GetClassConstantPool;
+                JVM_GetClassContext;
+                JVM_GetClassDeclaredConstructors;
+                JVM_GetClassDeclaredFields;
+                JVM_GetClassDeclaredMethods;
+                JVM_GetClassFieldsCount;
+                JVM_GetClassInterfaces;
+                JVM_GetClassLoader;
+                JVM_GetClassMethodsCount;
+                JVM_GetClassModifiers;
+                JVM_GetClassName;
+                JVM_GetClassNameUTF;
+                JVM_GetClassSignature;
+                JVM_GetClassSigners;
+                JVM_GetClassTypeAnnotations;
+                JVM_GetComponentType;
+                JVM_GetDeclaredClasses;
+                JVM_GetDeclaringClass;
+                JVM_GetEnclosingMethodInfo;
+                JVM_GetFieldAnnotations;
+                JVM_GetFieldIxModifiers;
+                JVM_GetFieldTypeAnnotations;
+                JVM_GetHostName;
+                JVM_GetInheritedAccessControlContext;
+                JVM_GetInterfaceVersion;
+                JVM_GetLastErrorString;
+                JVM_GetManagement;
+                JVM_GetMethodAnnotations;
+                JVM_GetMethodDefaultAnnotationValue;
+                JVM_GetMethodIxArgsSize;
+                JVM_GetMethodIxByteCode;
+                JVM_GetMethodIxByteCodeLength;
+                JVM_GetMethodIxExceptionIndexes;
+                JVM_GetMethodIxExceptionTableEntry;
+                JVM_GetMethodIxExceptionTableLength;
+                JVM_GetMethodIxExceptionsCount;
+                JVM_GetMethodIxLocalsCount;
+                JVM_GetMethodIxMaxStack;
+                JVM_GetMethodIxModifiers;
+                JVM_GetMethodIxNameUTF;
+                JVM_GetMethodIxSignatureUTF;
+                JVM_GetMethodParameterAnnotations;
+                JVM_GetMethodParameters;
+                JVM_GetMethodTypeAnnotations;
+                JVM_GetPrimitiveArrayElement;
+                JVM_GetProtectionDomain;
+                JVM_GetSockName;
+                JVM_GetSockOpt;
+                JVM_GetStackAccessControlContext;
+                JVM_GetStackTraceDepth;
+                JVM_GetStackTraceElement;
+                JVM_GetSystemPackage;
+                JVM_GetSystemPackages;
+                JVM_GetTemporaryDirectory;
+                JVM_GetThreadStateNames;
+                JVM_GetThreadStateValues;
+                JVM_GetVersionInfo;
+                JVM_Halt;
+                JVM_HoldsLock;
+                JVM_IHashCode;
+                JVM_InitAgentProperties;
+                JVM_InitProperties;
+                JVM_InitializeCompiler;
+                JVM_InitializeSocketLibrary;
+                JVM_InternString;
+                JVM_Interrupt;
+                JVM_InvokeMethod;
+                JVM_IsArrayClass;
+                JVM_IsConstructorIx;
+                JVM_IsInterface;
+                JVM_IsInterrupted;
+                JVM_IsNaN;
+                JVM_IsPrimitiveClass;
+                JVM_IsSameClassPackage;
+                JVM_IsSilentCompiler;
+                JVM_IsSupportedJNIVersion;
+                JVM_IsThreadAlive;
+                JVM_IsVMGeneratedMethodIx;
+                JVM_KnownToNotExist;
+                JVM_GetResourceLookupCacheURLs;
+                JVM_GetResourceLookupCache;
+                JVM_LatestUserDefinedLoader;
+                JVM_Listen;
+                JVM_LoadClass0;
+                JVM_LoadLibrary;
+                JVM_Lseek;
+                JVM_MaxObjectInspectionAge;
+                JVM_MaxMemory;
+                JVM_MonitorNotify;
+                JVM_MonitorNotifyAll;
+                JVM_MonitorWait;
+                JVM_NanoTime;
+                JVM_NativePath;
+                JVM_NewArray;
+                JVM_NewInstanceFromConstructor;
+                JVM_NewMultiArray;
+                JVM_OnExit;
+                JVM_Open;
+                JVM_RaiseSignal;
+                JVM_RawMonitorCreate;
+                JVM_RawMonitorDestroy;
+                JVM_RawMonitorEnter;
+                JVM_RawMonitorExit;
+                JVM_Read;
+                JVM_Recv;
+                JVM_RecvFrom;
+                JVM_RegisterSignal;
+                JVM_ReleaseUTF;
+                JVM_ResolveClass;
+                JVM_ResumeThread;
+                JVM_Send;
+                JVM_SendTo;
+                JVM_SetArrayElement;
+                JVM_SetClassSigners;
+                JVM_SetLength;
+                JVM_SetNativeThreadName;
+                JVM_SetPrimitiveArrayElement;
+                JVM_SetSockOpt;
+                JVM_SetThreadPriority;
+                JVM_Sleep;
+                JVM_Socket;
+                JVM_SocketAvailable;
+                JVM_SocketClose;
+                JVM_SocketShutdown;
+                JVM_StartThread;
+                JVM_StopThread;
+                JVM_SuspendThread;
+                JVM_SupportsCX8;
+                JVM_Sync;
+                JVM_Timeout;
+                JVM_TotalMemory;
+                JVM_TraceInstructions;
+                JVM_TraceMethodCalls;
+                JVM_UnloadLibrary;
+                JVM_Write;
+                JVM_Yield;
+                JVM_handle_bsd_signal;
 
-                # debug _JVM
-                _JVM_AccessVMBooleanFlag
-                _JVM_AccessVMIntFlag
-                _JVM_VMBreakPoint
+                # debug JVM
+                JVM_AccessVMBooleanFlag;
+                JVM_AccessVMIntFlag;
+                JVM_VMBreakPoint;
 
                 # miscellaneous functions
-                _jio_fprintf
-                _jio_printf
-                _jio_snprintf
-                _jio_vfprintf
-                _jio_vsnprintf
+                jio_fprintf;
+                jio_printf;
+                jio_snprintf;
+                jio_vfprintf;
+                jio_vsnprintf;
+		fork1;
+                numa_warn;
+                numa_error;
 
                 # This is for Forte Analyzer profiling support.
-                _AsyncGetCallTrace
+                AsyncGetCallTrace;
 
                 # INSERT VTABLE SYMBOLS HERE
 
+        local:
+                *;
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-debug.macosx	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,266 @@
+#
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+# Only used for OSX/Darwin builds
+
+# Define public interface.
+                # _JNI
+                _JNI_CreateJavaVM
+                _JNI_GetCreatedJavaVMs
+                _JNI_GetDefaultJavaVMInitArgs
+
+                # _JVM
+                _JVM_Accept
+                _JVM_ActiveProcessorCount
+                _JVM_AllocateNewArray
+                _JVM_AllocateNewObject
+                _JVM_ArrayCopy
+                _JVM_AssertionStatusDirectives
+                _JVM_Available
+                _JVM_Bind
+                _JVM_ClassDepth
+                _JVM_ClassLoaderDepth
+                _JVM_Clone
+                _JVM_Close
+                _JVM_CX8Field
+                _JVM_CompileClass
+                _JVM_CompileClasses
+                _JVM_CompilerCommand
+                _JVM_Connect
+                _JVM_ConstantPoolGetClassAt
+                _JVM_ConstantPoolGetClassAtIfLoaded
+                _JVM_ConstantPoolGetDoubleAt
+                _JVM_ConstantPoolGetFieldAt
+                _JVM_ConstantPoolGetFieldAtIfLoaded
+                _JVM_ConstantPoolGetFloatAt
+                _JVM_ConstantPoolGetIntAt
+                _JVM_ConstantPoolGetLongAt
+                _JVM_ConstantPoolGetMethodAt
+                _JVM_ConstantPoolGetMethodAtIfLoaded
+                _JVM_ConstantPoolGetMemberRefInfoAt
+                _JVM_ConstantPoolGetSize
+                _JVM_ConstantPoolGetStringAt
+                _JVM_ConstantPoolGetUTF8At
+                _JVM_CountStackFrames
+                _JVM_CurrentClassLoader
+                _JVM_CurrentLoadedClass
+                _JVM_CurrentThread
+                _JVM_CurrentTimeMillis
+                _JVM_DefineClass
+                _JVM_DefineClassWithSource
+                _JVM_DefineClassWithSourceCond
+                _JVM_DesiredAssertionStatus
+                _JVM_DisableCompiler
+                _JVM_DoPrivileged
+                _JVM_DTraceGetVersion
+                _JVM_DTraceActivate
+                _JVM_DTraceIsProbeEnabled
+                _JVM_DTraceIsSupported
+                _JVM_DTraceDispose
+                _JVM_DumpAllStacks
+                _JVM_DumpThreads
+                _JVM_EnableCompiler
+                _JVM_Exit
+                _JVM_FillInStackTrace
+                _JVM_FindClassFromCaller
+                _JVM_FindClassFromClass
+                _JVM_FindClassFromClassLoader
+                _JVM_FindClassFromBootLoader
+                _JVM_FindLibraryEntry
+                _JVM_FindLoadedClass
+                _JVM_FindPrimitiveClass
+                _JVM_FindSignal
+                _JVM_FreeMemory
+                _JVM_GC
+                _JVM_GetAllThreads
+                _JVM_GetArrayElement
+                _JVM_GetArrayLength
+                _JVM_GetCPClassNameUTF
+                _JVM_GetCPFieldClassNameUTF
+                _JVM_GetCPFieldModifiers
+                _JVM_GetCPFieldNameUTF
+                _JVM_GetCPFieldSignatureUTF
+                _JVM_GetCPMethodClassNameUTF
+                _JVM_GetCPMethodModifiers
+                _JVM_GetCPMethodNameUTF
+                _JVM_GetCPMethodSignatureUTF
+                _JVM_GetCallerClass
+                _JVM_GetClassAccessFlags
+                _JVM_GetClassAnnotations
+                _JVM_GetClassCPEntriesCount
+                _JVM_GetClassCPTypes
+                _JVM_GetClassConstantPool
+                _JVM_GetClassContext
+                _JVM_GetClassDeclaredConstructors
+                _JVM_GetClassDeclaredFields
+                _JVM_GetClassDeclaredMethods
+                _JVM_GetClassFieldsCount
+                _JVM_GetClassInterfaces
+                _JVM_GetClassLoader
+                _JVM_GetClassMethodsCount
+                _JVM_GetClassModifiers
+                _JVM_GetClassName
+                _JVM_GetClassNameUTF
+                _JVM_GetClassSignature
+                _JVM_GetClassSigners
+                _JVM_GetClassTypeAnnotations
+                _JVM_GetComponentType
+                _JVM_GetDeclaredClasses
+                _JVM_GetDeclaringClass
+                _JVM_GetEnclosingMethodInfo
+                _JVM_GetFieldAnnotations
+                _JVM_GetFieldIxModifiers
+                _JVM_GetFieldTypeAnnotations
+                _JVM_GetHostName
+                _JVM_GetInheritedAccessControlContext
+                _JVM_GetInterfaceVersion
+                _JVM_GetLastErrorString
+                _JVM_GetManagement
+                _JVM_GetMethodAnnotations
+                _JVM_GetMethodDefaultAnnotationValue
+                _JVM_GetMethodIxArgsSize
+                _JVM_GetMethodIxByteCode
+                _JVM_GetMethodIxByteCodeLength
+                _JVM_GetMethodIxExceptionIndexes
+                _JVM_GetMethodIxExceptionTableEntry
+                _JVM_GetMethodIxExceptionTableLength
+                _JVM_GetMethodIxExceptionsCount
+                _JVM_GetMethodIxLocalsCount
+                _JVM_GetMethodIxMaxStack
+                _JVM_GetMethodIxModifiers
+                _JVM_GetMethodIxNameUTF
+                _JVM_GetMethodIxSignatureUTF
+                _JVM_GetMethodParameterAnnotations
+                _JVM_GetMethodParameters
+                _JVM_GetMethodTypeAnnotations
+                _JVM_GetPrimitiveArrayElement
+                _JVM_GetProtectionDomain
+                _JVM_GetSockName
+                _JVM_GetSockOpt
+                _JVM_GetStackAccessControlContext
+                _JVM_GetStackTraceDepth
+                _JVM_GetStackTraceElement
+                _JVM_GetSystemPackage
+                _JVM_GetSystemPackages
+                _JVM_GetTemporaryDirectory
+                _JVM_GetThreadStateNames
+                _JVM_GetThreadStateValues
+                _JVM_GetVersionInfo
+                _JVM_Halt
+                _JVM_HoldsLock
+                _JVM_IHashCode
+                _JVM_InitAgentProperties
+                _JVM_InitProperties
+                _JVM_InitializeCompiler
+                _JVM_InitializeSocketLibrary
+                _JVM_InternString
+                _JVM_Interrupt
+                _JVM_InvokeMethod
+                _JVM_IsArrayClass
+                _JVM_IsConstructorIx
+                _JVM_IsInterface
+                _JVM_IsInterrupted
+                _JVM_IsNaN
+                _JVM_IsPrimitiveClass
+                _JVM_IsSameClassPackage
+                _JVM_IsSilentCompiler
+                _JVM_IsSupportedJNIVersion
+                _JVM_IsThreadAlive
+                _JVM_IsVMGeneratedMethodIx
+                _JVM_KnownToNotExist
+                _JVM_GetResourceLookupCacheURLs
+                _JVM_GetResourceLookupCache
+                _JVM_LatestUserDefinedLoader
+                _JVM_Listen
+                _JVM_LoadClass0
+                _JVM_LoadLibrary
+                _JVM_Lseek
+                _JVM_MaxObjectInspectionAge
+                _JVM_MaxMemory
+                _JVM_MonitorNotify
+                _JVM_MonitorNotifyAll
+                _JVM_MonitorWait
+                _JVM_NanoTime
+                _JVM_NativePath
+                _JVM_NewArray
+                _JVM_NewInstanceFromConstructor
+                _JVM_NewMultiArray
+                _JVM_OnExit
+                _JVM_Open
+                _JVM_RaiseSignal
+                _JVM_RawMonitorCreate
+                _JVM_RawMonitorDestroy
+                _JVM_RawMonitorEnter
+                _JVM_RawMonitorExit
+                _JVM_Read
+                _JVM_Recv
+                _JVM_RecvFrom
+                _JVM_RegisterSignal
+                _JVM_ReleaseUTF
+                _JVM_ResolveClass
+                _JVM_ResumeThread
+                _JVM_Send
+                _JVM_SendTo
+                _JVM_SetArrayElement
+                _JVM_SetClassSigners
+                _JVM_SetLength
+                _JVM_SetNativeThreadName
+                _JVM_SetPrimitiveArrayElement
+                _JVM_SetSockOpt
+                _JVM_SetThreadPriority
+                _JVM_Sleep
+                _JVM_Socket
+                _JVM_SocketAvailable
+                _JVM_SocketClose
+                _JVM_SocketShutdown
+                _JVM_StartThread
+                _JVM_StopThread
+                _JVM_SuspendThread
+                _JVM_SupportsCX8
+                _JVM_Sync
+                _JVM_Timeout
+                _JVM_TotalMemory
+                _JVM_TraceInstructions
+                _JVM_TraceMethodCalls
+                _JVM_UnloadLibrary
+                _JVM_Write
+                _JVM_Yield
+                _JVM_handle_bsd_signal
+
+                # debug _JVM
+                _JVM_AccessVMBooleanFlag
+                _JVM_AccessVMIntFlag
+                _JVM_VMBreakPoint
+
+                # miscellaneous functions
+                _jio_fprintf
+                _jio_printf
+                _jio_snprintf
+                _jio_vfprintf
+                _jio_vsnprintf
+
+                # This is for Forte Analyzer profiling support.
+                _AsyncGetCallTrace
+
+                # INSERT VTABLE SYMBOLS HERE
+
--- ./hotspot/make/bsd/makefiles/mapfile-vers-product	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-product	Mon May 09 17:15:53 2016 -0400
@@ -21,241 +21,249 @@
 # questions.
 #
 #
-# Only used for OSX/Darwin builds
 
 # Define public interface.
+
+SUNWprivate_1.1 {
+        global:
                 # _JNI
-                _JNI_CreateJavaVM
-                _JNI_GetCreatedJavaVMs
-                _JNI_GetDefaultJavaVMInitArgs
+                JNI_CreateJavaVM;
+                JNI_GetCreatedJavaVMs;
+                JNI_GetDefaultJavaVMInitArgs;
 
-                # _JVM
-                _JVM_Accept
-                _JVM_ActiveProcessorCount
-                _JVM_AllocateNewArray
-                _JVM_AllocateNewObject
-                _JVM_ArrayCopy
-                _JVM_AssertionStatusDirectives
-                _JVM_Available
-                _JVM_Bind
-                _JVM_ClassDepth
-                _JVM_ClassLoaderDepth
-                _JVM_Clone
-                _JVM_Close
-                _JVM_CX8Field
-                _JVM_CompileClass
-                _JVM_CompileClasses
-                _JVM_CompilerCommand
-                _JVM_Connect
-                _JVM_ConstantPoolGetClassAt
-                _JVM_ConstantPoolGetClassAtIfLoaded
-                _JVM_ConstantPoolGetDoubleAt
-                _JVM_ConstantPoolGetFieldAt
-                _JVM_ConstantPoolGetFieldAtIfLoaded
-                _JVM_ConstantPoolGetFloatAt
-                _JVM_ConstantPoolGetIntAt
-                _JVM_ConstantPoolGetLongAt
-                _JVM_ConstantPoolGetMethodAt
-                _JVM_ConstantPoolGetMethodAtIfLoaded
-                _JVM_ConstantPoolGetMemberRefInfoAt
-                _JVM_ConstantPoolGetSize
-                _JVM_ConstantPoolGetStringAt
-                _JVM_ConstantPoolGetUTF8At
-                _JVM_CountStackFrames
-                _JVM_CurrentClassLoader
-                _JVM_CurrentLoadedClass
-                _JVM_CurrentThread
-                _JVM_CurrentTimeMillis
-                _JVM_DefineClass
-                _JVM_DefineClassWithSource
-                _JVM_DefineClassWithSourceCond
-                _JVM_DesiredAssertionStatus
-                _JVM_DisableCompiler
-                _JVM_DoPrivileged
-                _JVM_DTraceGetVersion
-                _JVM_DTraceActivate
-                _JVM_DTraceIsProbeEnabled
-                _JVM_DTraceIsSupported
-                _JVM_DTraceDispose
-                _JVM_DumpAllStacks
-                _JVM_DumpThreads
-                _JVM_EnableCompiler
-                _JVM_Exit
-                _JVM_FillInStackTrace
-                _JVM_FindClassFromCaller
-                _JVM_FindClassFromClass
-                _JVM_FindClassFromClassLoader
-                _JVM_FindClassFromBootLoader
-                _JVM_FindLibraryEntry
-                _JVM_FindLoadedClass
-                _JVM_FindPrimitiveClass
-                _JVM_FindSignal
-                _JVM_FreeMemory
-                _JVM_GC
-                _JVM_GetAllThreads
-                _JVM_GetArrayElement
-                _JVM_GetArrayLength
-                _JVM_GetCPClassNameUTF
-                _JVM_GetCPFieldClassNameUTF
-                _JVM_GetCPFieldModifiers
-                _JVM_GetCPFieldNameUTF
-                _JVM_GetCPFieldSignatureUTF
-                _JVM_GetCPMethodClassNameUTF
-                _JVM_GetCPMethodModifiers
-                _JVM_GetCPMethodNameUTF
-                _JVM_GetCPMethodSignatureUTF
-                _JVM_GetCallerClass
-                _JVM_GetClassAccessFlags
-                _JVM_GetClassAnnotations
-                _JVM_GetClassCPEntriesCount
-                _JVM_GetClassCPTypes
-                _JVM_GetClassConstantPool
-                _JVM_GetClassContext
-                _JVM_GetClassDeclaredConstructors
-                _JVM_GetClassDeclaredFields
-                _JVM_GetClassDeclaredMethods
-                _JVM_GetClassFieldsCount
-                _JVM_GetClassInterfaces
-                _JVM_GetClassLoader
-                _JVM_GetClassMethodsCount
-                _JVM_GetClassModifiers
-                _JVM_GetClassName
-                _JVM_GetClassNameUTF
-                _JVM_GetClassSignature
-                _JVM_GetClassSigners
-                _JVM_GetClassTypeAnnotations
-                _JVM_GetComponentType
-                _JVM_GetDeclaredClasses
-                _JVM_GetDeclaringClass
-                _JVM_GetEnclosingMethodInfo
-                _JVM_GetFieldAnnotations
-                _JVM_GetFieldIxModifiers
-                _JVM_GetFieldTypeAnnotations
-                _JVM_GetHostName
-                _JVM_GetInheritedAccessControlContext
-                _JVM_GetInterfaceVersion
-                _JVM_GetLastErrorString
-                _JVM_GetManagement
-                _JVM_GetMethodAnnotations
-                _JVM_GetMethodDefaultAnnotationValue
-                _JVM_GetMethodIxArgsSize
-                _JVM_GetMethodIxByteCode
-                _JVM_GetMethodIxByteCodeLength
-                _JVM_GetMethodIxExceptionIndexes
-                _JVM_GetMethodIxExceptionTableEntry
-                _JVM_GetMethodIxExceptionTableLength
-                _JVM_GetMethodIxExceptionsCount
-                _JVM_GetMethodIxLocalsCount
-                _JVM_GetMethodIxMaxStack
-                _JVM_GetMethodIxModifiers
-                _JVM_GetMethodIxNameUTF
-                _JVM_GetMethodIxSignatureUTF
-                _JVM_GetMethodParameterAnnotations
-                _JVM_GetMethodParameters
-                _JVM_GetMethodTypeAnnotations
-                _JVM_GetPrimitiveArrayElement
-                _JVM_GetProtectionDomain
-                _JVM_GetSockName
-                _JVM_GetSockOpt
-                _JVM_GetStackAccessControlContext
-                _JVM_GetStackTraceDepth
-                _JVM_GetStackTraceElement
-                _JVM_GetSystemPackage
-                _JVM_GetSystemPackages
-                _JVM_GetTemporaryDirectory
-                _JVM_GetThreadStateNames
-                _JVM_GetThreadStateValues
-                _JVM_GetVersionInfo
-                _JVM_Halt
-                _JVM_HoldsLock
-                _JVM_IHashCode
-                _JVM_InitAgentProperties
-                _JVM_InitProperties
-                _JVM_InitializeCompiler
-                _JVM_InitializeSocketLibrary
-                _JVM_InternString
-                _JVM_Interrupt
-                _JVM_InvokeMethod
-                _JVM_IsArrayClass
-                _JVM_IsConstructorIx
-                _JVM_IsInterface
-                _JVM_IsInterrupted
-                _JVM_IsNaN
-                _JVM_IsPrimitiveClass
-                _JVM_IsSameClassPackage
-                _JVM_IsSilentCompiler
-                _JVM_IsSupportedJNIVersion
-                _JVM_IsThreadAlive
-                _JVM_IsVMGeneratedMethodIx
-                _JVM_KnownToNotExist
-                _JVM_GetResourceLookupCacheURLs
-                _JVM_GetResourceLookupCache
-                _JVM_LatestUserDefinedLoader
-                _JVM_Listen
-                _JVM_LoadClass0
-                _JVM_LoadLibrary
-                _JVM_Lseek
-                _JVM_MaxObjectInspectionAge
-                _JVM_MaxMemory
-                _JVM_MonitorNotify
-                _JVM_MonitorNotifyAll
-                _JVM_MonitorWait
-                _JVM_NanoTime
-                _JVM_NativePath
-                _JVM_NewArray
-                _JVM_NewInstanceFromConstructor
-                _JVM_NewMultiArray
-                _JVM_OnExit
-                _JVM_Open
-                _JVM_RaiseSignal
-                _JVM_RawMonitorCreate
-                _JVM_RawMonitorDestroy
-                _JVM_RawMonitorEnter
-                _JVM_RawMonitorExit
-                _JVM_Read
-                _JVM_Recv
-                _JVM_RecvFrom
-                _JVM_RegisterSignal
-                _JVM_ReleaseUTF
-                _JVM_ResolveClass
-                _JVM_ResumeThread
-                _JVM_Send
-                _JVM_SendTo
-                _JVM_SetArrayElement
-                _JVM_SetClassSigners
-                _JVM_SetLength
-                _JVM_SetNativeThreadName
-                _JVM_SetPrimitiveArrayElement
-                _JVM_SetSockOpt
-                _JVM_SetThreadPriority
-                _JVM_Sleep
-                _JVM_Socket
-                _JVM_SocketAvailable
-                _JVM_SocketClose
-                _JVM_SocketShutdown
-                _JVM_StartThread
-                _JVM_StopThread
-                _JVM_SuspendThread
-                _JVM_SupportsCX8
-                _JVM_Sync
-                _JVM_Timeout
-                _JVM_TotalMemory
-                _JVM_TraceInstructions
-                _JVM_TraceMethodCalls
-                _JVM_UnloadLibrary
-                _JVM_Write
-                _JVM_Yield
-                _JVM_handle_bsd_signal
+                # JVM
+                JVM_Accept;
+                JVM_ActiveProcessorCount;
+                JVM_AllocateNewArray;
+                JVM_AllocateNewObject;
+                JVM_ArrayCopy;
+                JVM_AssertionStatusDirectives;
+                JVM_Available;
+                JVM_Bind;
+                JVM_ClassDepth;
+                JVM_ClassLoaderDepth;
+                JVM_Clone;
+                JVM_Close;
+                JVM_CX8Field;
+                JVM_CompileClass;
+                JVM_CompileClasses;
+                JVM_CompilerCommand;
+                JVM_Connect;
+                JVM_ConstantPoolGetClassAt;
+                JVM_ConstantPoolGetClassAtIfLoaded;
+                JVM_ConstantPoolGetDoubleAt;
+                JVM_ConstantPoolGetFieldAt;
+                JVM_ConstantPoolGetFieldAtIfLoaded;
+                JVM_ConstantPoolGetFloatAt;
+                JVM_ConstantPoolGetIntAt;
+                JVM_ConstantPoolGetLongAt;
+                JVM_ConstantPoolGetMethodAt;
+                JVM_ConstantPoolGetMethodAtIfLoaded;
+                JVM_ConstantPoolGetMemberRefInfoAt;
+                JVM_ConstantPoolGetSize;
+                JVM_ConstantPoolGetStringAt;
+                JVM_ConstantPoolGetUTF8At;
+                JVM_CountStackFrames;
+                JVM_CurrentClassLoader;
+                JVM_CurrentLoadedClass;
+                JVM_CurrentThread;
+                JVM_CurrentTimeMillis;
+                JVM_DefineClass;
+                JVM_DefineClassWithSource;
+                JVM_DefineClassWithSourceCond;
+                JVM_DesiredAssertionStatus;
+                JVM_DisableCompiler;
+                JVM_DoPrivileged;
+                JVM_DTraceGetVersion;
+                JVM_DTraceActivate;
+                JVM_DTraceIsProbeEnabled;
+                JVM_DTraceIsSupported;
+                JVM_DTraceDispose;
+                JVM_DumpAllStacks;
+                JVM_DumpThreads;
+                JVM_EnableCompiler;
+                JVM_Exit;
+                JVM_FillInStackTrace;
+                JVM_FindClassFromCaller;
+                JVM_FindClassFromClass;
+                JVM_FindClassFromClassLoader;
+                JVM_FindClassFromBootLoader;
+                JVM_FindLibraryEntry;
+                JVM_FindLoadedClass;
+                JVM_FindPrimitiveClass;
+                JVM_FindSignal;
+                JVM_FreeMemory;
+                JVM_GC;
+                JVM_GetAllThreads;
+                JVM_GetArrayElement;
+                JVM_GetArrayLength;
+                JVM_GetCPClassNameUTF;
+                JVM_GetCPFieldClassNameUTF;
+                JVM_GetCPFieldModifiers;
+                JVM_GetCPFieldNameUTF;
+                JVM_GetCPFieldSignatureUTF;
+                JVM_GetCPMethodClassNameUTF;
+                JVM_GetCPMethodModifiers;
+                JVM_GetCPMethodNameUTF;
+                JVM_GetCPMethodSignatureUTF;
+                JVM_GetCallerClass;
+                JVM_GetClassAccessFlags;
+                JVM_GetClassAnnotations;
+                JVM_GetClassCPEntriesCount;
+                JVM_GetClassCPTypes;
+                JVM_GetClassConstantPool;
+                JVM_GetClassContext;
+                JVM_GetClassDeclaredConstructors;
+                JVM_GetClassDeclaredFields;
+                JVM_GetClassDeclaredMethods;
+                JVM_GetClassFieldsCount;
+                JVM_GetClassInterfaces;
+                JVM_GetClassLoader;
+                JVM_GetClassMethodsCount;
+                JVM_GetClassModifiers;
+                JVM_GetClassName;
+                JVM_GetClassNameUTF;
+                JVM_GetClassSignature;
+                JVM_GetClassSigners;
+                JVM_GetClassTypeAnnotations;
+                JVM_GetComponentType;
+                JVM_GetDeclaredClasses;
+                JVM_GetDeclaringClass;
+                JVM_GetEnclosingMethodInfo;
+                JVM_GetFieldAnnotations;
+                JVM_GetFieldIxModifiers;
+                JVM_GetFieldTypeAnnotations;
+                JVM_GetHostName;
+                JVM_GetInheritedAccessControlContext;
+                JVM_GetInterfaceVersion;
+                JVM_GetLastErrorString;
+                JVM_GetManagement;
+                JVM_GetMethodAnnotations;
+                JVM_GetMethodDefaultAnnotationValue;
+                JVM_GetMethodIxArgsSize;
+                JVM_GetMethodIxByteCode;
+                JVM_GetMethodIxByteCodeLength;
+                JVM_GetMethodIxExceptionIndexes;
+                JVM_GetMethodIxExceptionTableEntry;
+                JVM_GetMethodIxExceptionTableLength;
+                JVM_GetMethodIxExceptionsCount;
+                JVM_GetMethodIxLocalsCount;
+                JVM_GetMethodIxMaxStack;
+                JVM_GetMethodIxModifiers;
+                JVM_GetMethodIxNameUTF;
+                JVM_GetMethodIxSignatureUTF;
+                JVM_GetMethodParameterAnnotations;
+                JVM_GetMethodParameters;
+                JVM_GetMethodTypeAnnotations;
+                JVM_GetPrimitiveArrayElement;
+                JVM_GetProtectionDomain;
+                JVM_GetSockName;
+                JVM_GetSockOpt;
+                JVM_GetStackAccessControlContext;
+                JVM_GetStackTraceDepth;
+                JVM_GetStackTraceElement;
+                JVM_GetSystemPackage;
+                JVM_GetSystemPackages;
+                JVM_GetTemporaryDirectory;
+                JVM_GetThreadStateNames;
+                JVM_GetThreadStateValues;
+                JVM_GetVersionInfo;
+                JVM_Halt;
+                JVM_HoldsLock;
+                JVM_IHashCode;
+                JVM_InitAgentProperties;
+                JVM_InitProperties;
+                JVM_InitializeCompiler;
+                JVM_InitializeSocketLibrary;
+                JVM_InternString;
+                JVM_Interrupt;
+                JVM_InvokeMethod;
+                JVM_IsArrayClass;
+                JVM_IsConstructorIx;
+                JVM_IsInterface;
+                JVM_IsInterrupted;
+                JVM_IsNaN;
+                JVM_IsPrimitiveClass;
+                JVM_IsSameClassPackage;
+                JVM_IsSilentCompiler;
+                JVM_IsSupportedJNIVersion;
+                JVM_IsThreadAlive;
+                JVM_IsVMGeneratedMethodIx;
+                JVM_KnownToNotExist;
+                JVM_GetResourceLookupCacheURLs;
+                JVM_GetResourceLookupCache;
+                JVM_LatestUserDefinedLoader;
+                JVM_Listen;
+                JVM_LoadClass0;
+                JVM_LoadLibrary;
+                JVM_Lseek;
+                JVM_MaxObjectInspectionAge;
+                JVM_MaxMemory;
+                JVM_MonitorNotify;
+                JVM_MonitorNotifyAll;
+                JVM_MonitorWait;
+                JVM_NanoTime;
+                JVM_NativePath;
+                JVM_NewArray;
+                JVM_NewInstanceFromConstructor;
+                JVM_NewMultiArray;
+                JVM_OnExit;
+                JVM_Open;
+                JVM_RaiseSignal;
+                JVM_RawMonitorCreate;
+                JVM_RawMonitorDestroy;
+                JVM_RawMonitorEnter;
+                JVM_RawMonitorExit;
+                JVM_Read;
+                JVM_Recv;
+                JVM_RecvFrom;
+                JVM_RegisterSignal;
+                JVM_ReleaseUTF;
+                JVM_ResolveClass;
+                JVM_ResumeThread;
+                JVM_Send;
+                JVM_SendTo;
+                JVM_SetArrayElement;
+                JVM_SetClassSigners;
+                JVM_SetLength;
+                JVM_SetNativeThreadName;
+                JVM_SetPrimitiveArrayElement;
+                JVM_SetSockOpt;
+                JVM_SetThreadPriority;
+                JVM_Sleep;
+                JVM_Socket;
+                JVM_SocketAvailable;
+                JVM_SocketClose;
+                JVM_SocketShutdown;
+                JVM_StartThread;
+                JVM_StopThread;
+                JVM_SuspendThread;
+                JVM_SupportsCX8;
+                JVM_Sync;
+                JVM_Timeout;
+                JVM_TotalMemory;
+                JVM_TraceInstructions;
+                JVM_TraceMethodCalls;
+                JVM_UnloadLibrary;
+                JVM_Write;
+                JVM_Yield;
+                JVM_handle_bsd_signal;
 
                 # miscellaneous functions
-                _jio_fprintf
-                _jio_printf
-                _jio_snprintf
-                _jio_vfprintf
-                _jio_vsnprintf
+                jio_fprintf;
+                jio_printf;
+                jio_snprintf;
+                jio_vfprintf;
+                jio_vsnprintf;
+		fork1;
+                numa_warn;
+                numa_error;
 
                 # This is for Forte Analyzer profiling support.
-                _AsyncGetCallTrace
+                AsyncGetCallTrace;
 
                 # INSERT VTABLE SYMBOLS HERE
 
+        local:
+                *;
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-product.macosx	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,261 @@
+#
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+# Only used for OSX/Darwin builds
+
+# Define public interface.
+                # _JNI
+                _JNI_CreateJavaVM
+                _JNI_GetCreatedJavaVMs
+                _JNI_GetDefaultJavaVMInitArgs
+
+                # _JVM
+                _JVM_Accept
+                _JVM_ActiveProcessorCount
+                _JVM_AllocateNewArray
+                _JVM_AllocateNewObject
+                _JVM_ArrayCopy
+                _JVM_AssertionStatusDirectives
+                _JVM_Available
+                _JVM_Bind
+                _JVM_ClassDepth
+                _JVM_ClassLoaderDepth
+                _JVM_Clone
+                _JVM_Close
+                _JVM_CX8Field
+                _JVM_CompileClass
+                _JVM_CompileClasses
+                _JVM_CompilerCommand
+                _JVM_Connect
+                _JVM_ConstantPoolGetClassAt
+                _JVM_ConstantPoolGetClassAtIfLoaded
+                _JVM_ConstantPoolGetDoubleAt
+                _JVM_ConstantPoolGetFieldAt
+                _JVM_ConstantPoolGetFieldAtIfLoaded
+                _JVM_ConstantPoolGetFloatAt
+                _JVM_ConstantPoolGetIntAt
+                _JVM_ConstantPoolGetLongAt
+                _JVM_ConstantPoolGetMethodAt
+                _JVM_ConstantPoolGetMethodAtIfLoaded
+                _JVM_ConstantPoolGetMemberRefInfoAt
+                _JVM_ConstantPoolGetSize
+                _JVM_ConstantPoolGetStringAt
+                _JVM_ConstantPoolGetUTF8At
+                _JVM_CountStackFrames
+                _JVM_CurrentClassLoader
+                _JVM_CurrentLoadedClass
+                _JVM_CurrentThread
+                _JVM_CurrentTimeMillis
+                _JVM_DefineClass
+                _JVM_DefineClassWithSource
+                _JVM_DefineClassWithSourceCond
+                _JVM_DesiredAssertionStatus
+                _JVM_DisableCompiler
+                _JVM_DoPrivileged
+                _JVM_DTraceGetVersion
+                _JVM_DTraceActivate
+                _JVM_DTraceIsProbeEnabled
+                _JVM_DTraceIsSupported
+                _JVM_DTraceDispose
+                _JVM_DumpAllStacks
+                _JVM_DumpThreads
+                _JVM_EnableCompiler
+                _JVM_Exit
+                _JVM_FillInStackTrace
+                _JVM_FindClassFromCaller
+                _JVM_FindClassFromClass
+                _JVM_FindClassFromClassLoader
+                _JVM_FindClassFromBootLoader
+                _JVM_FindLibraryEntry
+                _JVM_FindLoadedClass
+                _JVM_FindPrimitiveClass
+                _JVM_FindSignal
+                _JVM_FreeMemory
+                _JVM_GC
+                _JVM_GetAllThreads
+                _JVM_GetArrayElement
+                _JVM_GetArrayLength
+                _JVM_GetCPClassNameUTF
+                _JVM_GetCPFieldClassNameUTF
+                _JVM_GetCPFieldModifiers
+                _JVM_GetCPFieldNameUTF
+                _JVM_GetCPFieldSignatureUTF
+                _JVM_GetCPMethodClassNameUTF
+                _JVM_GetCPMethodModifiers
+                _JVM_GetCPMethodNameUTF
+                _JVM_GetCPMethodSignatureUTF
+                _JVM_GetCallerClass
+                _JVM_GetClassAccessFlags
+                _JVM_GetClassAnnotations
+                _JVM_GetClassCPEntriesCount
+                _JVM_GetClassCPTypes
+                _JVM_GetClassConstantPool
+                _JVM_GetClassContext
+                _JVM_GetClassDeclaredConstructors
+                _JVM_GetClassDeclaredFields
+                _JVM_GetClassDeclaredMethods
+                _JVM_GetClassFieldsCount
+                _JVM_GetClassInterfaces
+                _JVM_GetClassLoader
+                _JVM_GetClassMethodsCount
+                _JVM_GetClassModifiers
+                _JVM_GetClassName
+                _JVM_GetClassNameUTF
+                _JVM_GetClassSignature
+                _JVM_GetClassSigners
+                _JVM_GetClassTypeAnnotations
+                _JVM_GetComponentType
+                _JVM_GetDeclaredClasses
+                _JVM_GetDeclaringClass
+                _JVM_GetEnclosingMethodInfo
+                _JVM_GetFieldAnnotations
+                _JVM_GetFieldIxModifiers
+                _JVM_GetFieldTypeAnnotations
+                _JVM_GetHostName
+                _JVM_GetInheritedAccessControlContext
+                _JVM_GetInterfaceVersion
+                _JVM_GetLastErrorString
+                _JVM_GetManagement
+                _JVM_GetMethodAnnotations
+                _JVM_GetMethodDefaultAnnotationValue
+                _JVM_GetMethodIxArgsSize
+                _JVM_GetMethodIxByteCode
+                _JVM_GetMethodIxByteCodeLength
+                _JVM_GetMethodIxExceptionIndexes
+                _JVM_GetMethodIxExceptionTableEntry
+                _JVM_GetMethodIxExceptionTableLength
+                _JVM_GetMethodIxExceptionsCount
+                _JVM_GetMethodIxLocalsCount
+                _JVM_GetMethodIxMaxStack
+                _JVM_GetMethodIxModifiers
+                _JVM_GetMethodIxNameUTF
+                _JVM_GetMethodIxSignatureUTF
+                _JVM_GetMethodParameterAnnotations
+                _JVM_GetMethodParameters
+                _JVM_GetMethodTypeAnnotations
+                _JVM_GetPrimitiveArrayElement
+                _JVM_GetProtectionDomain
+                _JVM_GetSockName
+                _JVM_GetSockOpt
+                _JVM_GetStackAccessControlContext
+                _JVM_GetStackTraceDepth
+                _JVM_GetStackTraceElement
+                _JVM_GetSystemPackage
+                _JVM_GetSystemPackages
+                _JVM_GetTemporaryDirectory
+                _JVM_GetThreadStateNames
+                _JVM_GetThreadStateValues
+                _JVM_GetVersionInfo
+                _JVM_Halt
+                _JVM_HoldsLock
+                _JVM_IHashCode
+                _JVM_InitAgentProperties
+                _JVM_InitProperties
+                _JVM_InitializeCompiler
+                _JVM_InitializeSocketLibrary
+                _JVM_InternString
+                _JVM_Interrupt
+                _JVM_InvokeMethod
+                _JVM_IsArrayClass
+                _JVM_IsConstructorIx
+                _JVM_IsInterface
+                _JVM_IsInterrupted
+                _JVM_IsNaN
+                _JVM_IsPrimitiveClass
+                _JVM_IsSameClassPackage
+                _JVM_IsSilentCompiler
+                _JVM_IsSupportedJNIVersion
+                _JVM_IsThreadAlive
+                _JVM_IsVMGeneratedMethodIx
+                _JVM_KnownToNotExist
+                _JVM_GetResourceLookupCacheURLs
+                _JVM_GetResourceLookupCache
+                _JVM_LatestUserDefinedLoader
+                _JVM_Listen
+                _JVM_LoadClass0
+                _JVM_LoadLibrary
+                _JVM_Lseek
+                _JVM_MaxObjectInspectionAge
+                _JVM_MaxMemory
+                _JVM_MonitorNotify
+                _JVM_MonitorNotifyAll
+                _JVM_MonitorWait
+                _JVM_NanoTime
+                _JVM_NativePath
+                _JVM_NewArray
+                _JVM_NewInstanceFromConstructor
+                _JVM_NewMultiArray
+                _JVM_OnExit
+                _JVM_Open
+                _JVM_RaiseSignal
+                _JVM_RawMonitorCreate
+                _JVM_RawMonitorDestroy
+                _JVM_RawMonitorEnter
+                _JVM_RawMonitorExit
+                _JVM_Read
+                _JVM_Recv
+                _JVM_RecvFrom
+                _JVM_RegisterSignal
+                _JVM_ReleaseUTF
+                _JVM_ResolveClass
+                _JVM_ResumeThread
+                _JVM_Send
+                _JVM_SendTo
+                _JVM_SetArrayElement
+                _JVM_SetClassSigners
+                _JVM_SetLength
+                _JVM_SetNativeThreadName
+                _JVM_SetPrimitiveArrayElement
+                _JVM_SetSockOpt
+                _JVM_SetThreadPriority
+                _JVM_Sleep
+                _JVM_Socket
+                _JVM_SocketAvailable
+                _JVM_SocketClose
+                _JVM_SocketShutdown
+                _JVM_StartThread
+                _JVM_StopThread
+                _JVM_SuspendThread
+                _JVM_SupportsCX8
+                _JVM_Sync
+                _JVM_Timeout
+                _JVM_TotalMemory
+                _JVM_TraceInstructions
+                _JVM_TraceMethodCalls
+                _JVM_UnloadLibrary
+                _JVM_Write
+                _JVM_Yield
+                _JVM_handle_bsd_signal
+
+                # miscellaneous functions
+                _jio_fprintf
+                _jio_printf
+                _jio_snprintf
+                _jio_vfprintf
+                _jio_vsnprintf
+
+                # This is for Forte Analyzer profiling support.
+                _AsyncGetCallTrace
+
+                # INSERT VTABLE SYMBOLS HERE
+
--- ./hotspot/make/bsd/makefiles/optimized.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/optimized.make	Mon May 09 17:15:53 2016 -0400
@@ -38,6 +38,9 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug
+ifeq ($(OS_VENDOR), Darwin)
+MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug$(MAPSUFX)
 
 VERSION = optimized
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/ppc64.make	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,102 @@
+#
+# Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2012, 2013 SAP AG. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+
+# make c code know it is on a 64 bit platform.
+CFLAGS += -D_LP64=1
+
+ifeq ($(origin OPENJDK_TARGET_CPU_ENDIAN),undefined)
+  # This can happen during hotspot standalone build. Set endianness from
+  # uname. We assume build and target machines are the same.
+  OPENJDK_TARGET_CPU_ENDIAN:=$(if $(filter ppc64le,$(shell uname -m)),little,big)
+endif
+
+ifeq ($(filter $(OPENJDK_TARGET_CPU_ENDIAN),big little),)
+  $(error OPENJDK_TARGET_CPU_ENDIAN value should be 'big' or 'little')
+endif
+
+ifeq ($(OPENJDK_TARGET_CPU_ENDIAN),big)
+  # fixes `relocation truncated to fit' error for gcc 4.1.
+  CFLAGS += -mminimal-toc
+
+  # finds use ppc64 instructions, but schedule for power5
+  CFLAGS += -mcpu=powerpc64 -mtune=power5 -minsert-sched-nops=regroup_exact -mno-multiple -mno-string
+else
+  # Little endian machine uses ELFv2 ABI.
+  CFLAGS += -DVM_LITTLE_ENDIAN -DABI_ELFv2
+
+  # Use Power8, this is the first CPU to support PPC64 LE with ELFv2 ABI.
+  CFLAGS += -mcpu=power7 -mtune=power8 -minsert-sched-nops=regroup_exact -mno-multiple -mno-string
+endif
+#
+# Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2012, 2013 SAP AG. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+
+# make c code know it is on a 64 bit platform.
+CFLAGS += -D_LP64=1
+
+ifeq ($(origin OPENJDK_TARGET_CPU_ENDIAN),undefined)
+  # This can happen during hotspot standalone build. Set endianness from
+  # uname. We assume build and target machines are the same.
+  OPENJDK_TARGET_CPU_ENDIAN:=$(if $(filter ppc64le,$(shell uname -m)),little,big)
+endif
+
+ifeq ($(filter $(OPENJDK_TARGET_CPU_ENDIAN),big little),)
+  $(error OPENJDK_TARGET_CPU_ENDIAN value should be 'big' or 'little')
+endif
+
+ifeq ($(OPENJDK_TARGET_CPU_ENDIAN),big)
+  # fixes `relocation truncated to fit' error for gcc 4.1.
+  CFLAGS += -mminimal-toc
+
+  # finds use ppc64 instructions, but schedule for power5
+  CFLAGS += -mcpu=powerpc64 -mtune=power5 -minsert-sched-nops=regroup_exact -mno-multiple -mno-string
+else
+  # Little endian machine uses ELFv2 ABI.
+  CFLAGS += -DVM_LITTLE_ENDIAN -DABI_ELFv2
+
+  # Use Power8, this is the first CPU to support PPC64 LE with ELFv2 ABI.
+  CFLAGS += -mcpu=power7 -mtune=power8 -minsert-sched-nops=regroup_exact -mno-multiple -mno-string
+endif
--- ./hotspot/make/bsd/makefiles/product.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/product.make	Mon May 09 17:15:53 2016 -0400
@@ -38,7 +38,10 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-product
+ifeq ($(OS_VENDOR), Darwin)
+  MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-product$(MAPSUFX)
 
 SYSDEFS += -DPRODUCT
 VERSION = optimized
--- ./hotspot/make/bsd/makefiles/rules.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/rules.make	Mon May 09 17:15:53 2016 -0400
@@ -34,7 +34,7 @@
 CC_COMPILE       = $(CC) $(CXXFLAGS) $(CFLAGS)
 CXX_COMPILE      = $(CXX) $(CXXFLAGS) $(CFLAGS)
 
-AS.S            = $(AS) $(ASFLAGS)
+AS.S            = $(AS) -x assembler-with-cpp $(ASFLAGS)
 
 COMPILE.CC       = $(CC_COMPILE) -c
 GENASM.CC        = $(CC_COMPILE) -S
--- ./hotspot/make/bsd/makefiles/vm.make	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/make/bsd/makefiles/vm.make	Mon May 09 17:15:53 2016 -0400
@@ -107,7 +107,7 @@
 # File specific flags
 CXXFLAGS += $(CXXFLAGS/BYFILE)
 
-ifdef DEFAULT_LIBPATH
+ifneq ($(DEFAULT_LIBPATH),)
 CXXFLAGS += -DDEFAULT_LIBPATH="\"$(DEFAULT_LIBPATH)\""
 endif
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/platform_ppc64	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,34 @@
+os_family = bsd
+
+arch = ppc
+
+arch_model = ppc_64
+
+os_arch = bsd_ppc
+
+os_arch_model = bsd_ppc_64
+
+lib_arch = ppc64
+
+compiler = gcc
+
+gnu_dis_arch = ppc64
+
+sysdefs = -DBSD -D_ALLBSD_SOURCE -D_GNU_SOURCE -DPPC64
+os_family = bsd
+
+arch = ppc
+
+arch_model = ppc_64
+
+os_arch = bsd_ppc
+
+os_arch_model = bsd_ppc_64
+
+lib_arch = ppc64
+
+compiler = gcc
+
+gnu_dis_arch = ppc64
+
+sysdefs = -DBSD -D_ALLBSD_SOURCE -D_GNU_SOURCE -DPPC64
--- ./hotspot/src/cpu/ppc/vm/bytes_ppc.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/cpu/ppc/vm/bytes_ppc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -277,5 +277,9 @@
 #if defined(TARGET_OS_ARCH_linux_ppc)
 #include "bytes_linux_ppc.inline.hpp"
 #endif
+#if defined(TARGET_OS_ARCH_bsd_ppc)
+#include "bytes_bsd_ppc.inline.hpp"
+#endif
+
 
 #endif // CPU_PPC_VM_BYTES_PPC_HPP
--- ./hotspot/src/cpu/ppc/vm/interpreter_ppc.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/cpu/ppc/vm/interpreter_ppc.cpp	Mon May 09 17:15:53 2016 -0400
@@ -307,6 +307,8 @@
   // Although AIX runs on big endian CPU, float is in most significant
   // word of an argument slot.
   __ stfs(floatSlot, 0, arg_c);
+#elif defined(BSD)
+  __ stfs(floatSlot, 4, arg_c);
 #else
 #error "unknown OS"
 #endif
--- ./hotspot/src/cpu/x86/vm/jni_x86.h	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/cpu/x86/vm/jni_x86.h	Mon May 09 17:15:53 2016 -0400
@@ -34,7 +34,7 @@
 #ifndef __has_attribute
   #define __has_attribute(x) 0
 #endif
-#if (defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2))) || __has_attribute(visibility)
+#if (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2)))) || __has_attribute(visibility)
   #define JNIEXPORT     __attribute__((visibility("default")))
   #define JNIIMPORT     __attribute__((visibility("default")))
 #else
--- ./hotspot/src/cpu/x86/vm/sharedRuntime_x86_32.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/cpu/x86/vm/sharedRuntime_x86_32.cpp	Mon May 09 17:15:53 2016 -0400
@@ -2266,7 +2266,7 @@
   if (!is_critical_native) {
     // reset handle block
     __ movptr(rcx, Address(thread, JavaThread::active_handles_offset()));
-    __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);
+    __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
 
     // Any exception pending?
     __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
--- ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_32.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_32.cpp	Mon May 09 17:15:53 2016 -0400
@@ -1293,7 +1293,7 @@
 
   // reset handle block
   __ movptr(t, Address(thread, JavaThread::active_handles_offset()));
-  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);
+  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
 
   // If result was an oop then unbox and save it in the frame
   { Label L;
--- ./hotspot/src/cpu/x86/vm/x86_32.ad	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/cpu/x86/vm/x86_32.ad	Mon May 09 17:15:53 2016 -0400
@@ -1250,6 +1250,7 @@
 
 
   Unimplemented();
+  return 0;
 }
 
 #ifndef PRODUCT
--- ./hotspot/src/os/aix/vm/os_aix.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/aix/vm/os_aix.cpp	Mon May 09 17:15:53 2016 -0400
@@ -5236,6 +5236,10 @@
     return 0;
   }
 
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
+
   return strlen(buffer);
 }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os/bsd/vm/decoder_bsd.cpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef __APPLE__
+#include "prims/jvm.h"
+#include "utilities/decoder_elf.hpp"
+
+#include <cxxabi.h>
+
+bool ElfDecoder::demangle(const char* symbol, char *buf, int buflen) {
+  int   status;
+  char* result;
+  size_t size = (size_t)buflen;
+
+#ifdef PPC64
+  // On PPC64 ElfDecoder::decode() may return a dot (.) prefixed name
+  // (see elfFuncDescTable.hpp for details)
+  if (symbol && *symbol == '.') symbol += 1;
+#endif
+
+  // Don't pass buf to __cxa_demangle. In case of the 'buf' is too small,
+  // __cxa_demangle will call system "realloc" for additional memory, which
+  // may use different malloc/realloc mechanism that allocates 'buf'.
+  if ((result = abi::__cxa_demangle(symbol, NULL, NULL, &status)) != NULL) {
+    jio_snprintf(buf, buflen, "%s", result);
+      // call c library's free
+      ::free(result);
+      return true;
+  }
+  return false;
+}
+#endif
--- ./hotspot/src/os/bsd/vm/jsig.c	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/jsig.c	Mon May 09 17:15:53 2016 -0400
@@ -165,9 +165,8 @@
 }
 
 sa_handler_t sigset(int sig, sa_handler_t disp) {
-  printf("sigset() is not supported by BSD");
-  exit(0);
- }
+  return set_signal(sig, disp, true);
+}
 
 static int call_os_sigaction(int sig, const struct sigaction  *act,
                              struct sigaction *oact) {
--- ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	Mon May 09 17:15:53 2016 -0400
@@ -50,6 +50,7 @@
     case INTERRUPT_SIGNAL:
     case SIGFPE:
     case SIGILL:
+    case SIGBUS:
     case SIGSEGV:
 
     /* The following signal is used by the VM to dump thread stacks unless
@@ -110,71 +111,29 @@
 JVM_END
 
 /*
-  All the defined signal names for Bsd.
+  All the defined signal names for BSD are defined by sys_signame[].
 
   NOTE that not all of these names are accepted by our Java implementation
 
   Via an existing claim by the VM, sigaction restrictions, or
   the "rules of Unix" some of these names will be rejected at runtime.
   For example the VM sets up to handle USR1, sigaction returns EINVAL for
-  STOP, and Bsd simply doesn't allow catching of KILL.
+  STOP, and BSD simply doesn't allow catching of KILL.
 
   Here are the names currently accepted by a user of sun.misc.Signal with
   1.4.1 (ignoring potential interaction with use of chaining, etc):
 
-    HUP, INT, TRAP, ABRT, IOT, BUS, USR2, PIPE, ALRM, TERM, STKFLT,
-    CLD, CHLD, CONT, TSTP, TTIN, TTOU, URG, XCPU, XFSZ, VTALRM, PROF,
-    WINCH, POLL, IO, PWR, SYS
-
+      HUP, INT, TRAP, ABRT, EMT, SYS, PIPE, ALRM, TERM, URG, TSTP, CONT,
+      CHLD, TTIN, TTOU, IO, XCPU, XFSZ, VTALRM, PROF, WINCH, INFO, USR2
 */
 
-struct siglabel {
-  const char *name;
-  int   number;
-};
-
-struct siglabel siglabels[] = {
-  /* derived from /usr/include/bits/signum.h on RH7.2 */
-   "HUP",       SIGHUP,         /* Hangup (POSIX).  */
-  "INT",        SIGINT,         /* Interrupt (ANSI).  */
-  "QUIT",       SIGQUIT,        /* Quit (POSIX).  */
-  "ILL",        SIGILL,         /* Illegal instruction (ANSI).  */
-  "TRAP",       SIGTRAP,        /* Trace trap (POSIX).  */
-  "ABRT",       SIGABRT,        /* Abort (ANSI).  */
-  "EMT",        SIGEMT,         /* EMT trap  */
-  "FPE",        SIGFPE,         /* Floating-point exception (ANSI).  */
-  "KILL",       SIGKILL,        /* Kill, unblockable (POSIX).  */
-  "BUS",        SIGBUS,         /* BUS error (4.2 BSD).  */
-  "SEGV",       SIGSEGV,        /* Segmentation violation (ANSI).  */
-  "SYS",        SIGSYS,         /* Bad system call. Only on some Bsden! */
-  "PIPE",       SIGPIPE,        /* Broken pipe (POSIX).  */
-  "ALRM",       SIGALRM,        /* Alarm clock (POSIX).  */
-  "TERM",       SIGTERM,        /* Termination (ANSI).  */
-  "URG",        SIGURG,         /* Urgent condition on socket (4.2 BSD).  */
-  "STOP",       SIGSTOP,        /* Stop, unblockable (POSIX).  */
-  "TSTP",       SIGTSTP,        /* Keyboard stop (POSIX).  */
-  "CONT",       SIGCONT,        /* Continue (POSIX).  */
-  "CHLD",       SIGCHLD,        /* Child status has changed (POSIX).  */
-  "TTIN",       SIGTTIN,        /* Background read from tty (POSIX).  */
-  "TTOU",       SIGTTOU,        /* Background write to tty (POSIX).  */
-  "IO",         SIGIO,          /* I/O now possible (4.2 BSD).  */
-  "XCPU",       SIGXCPU,        /* CPU limit exceeded (4.2 BSD).  */
-  "XFSZ",       SIGXFSZ,        /* File size limit exceeded (4.2 BSD).  */
-  "VTALRM",     SIGVTALRM,      /* Virtual alarm clock (4.2 BSD).  */
-  "PROF",       SIGPROF,        /* Profiling alarm clock (4.2 BSD).  */
-  "WINCH",      SIGWINCH,       /* Window size change (4.3 BSD, Sun).  */
-  "INFO",       SIGINFO,        /* Information request.  */
-  "USR1",       SIGUSR1,        /* User-defined signal 1 (POSIX).  */
-  "USR2",       SIGUSR2         /* User-defined signal 2 (POSIX).  */
-  };
-
 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
 
   /* find and return the named signal's number */
 
-  for(uint i=0; i<ARRAY_SIZE(siglabels); i++)
-    if(!strcmp(name, siglabels[i].name))
-      return siglabels[i].number;
+  for (int i = 1; i < NSIG; i++)
+    if (strcasecmp(name, sys_signame[i]) == 0)
+      return i;
 
   return -1;
 
@@ -182,11 +141,14 @@
 
 // used by os::exception_name()
 extern bool signal_name(int signo, char* buf, size_t len) {
-  for(uint i = 0; i < ARRAY_SIZE(siglabels); i++) {
-    if (signo == siglabels[i].number) {
-      jio_snprintf(buf, len, "SIG%s", siglabels[i].name);
-      return true;
-    }
-  }
-  return false;
+  if (signo <= 0 || signo >= NSIG)
+    return false;
+  char signame[8];
+  const char *s = sys_signame[signo];
+  uint i;
+  for (i = 0; i < sizeof(signame) - 1 && s[i] != '\0'; i++)
+    signame[i] = toupper(s[i]);
+  signame[i] = '\0';
+  jio_snprintf(buf, len, "SIG%s", signame);
+  return true;
 }
--- ./hotspot/src/os/bsd/vm/jvm_bsd.h	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.h	Mon May 09 17:15:53 2016 -0400
@@ -112,20 +112,6 @@
 #define SHUTDOWN2_SIGNAL SIGINT
 #define SHUTDOWN3_SIGNAL SIGTERM
 
-#ifndef SIGRTMIN
-#ifdef __OpenBSD__
-#define SIGRTMIN        1
-#else
-#define SIGRTMIN        33
-#endif
-#endif
-#ifndef SIGRTMAX
-#ifdef __OpenBSD__
-#define SIGRTMAX        31
-#else
-#define SIGRTMAX        63
-#endif
-#endif
 #endif /* JVM_MD_H */
 
 #endif // OS_BSD_VM_JVM_BSD_H
--- ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	Mon May 09 17:15:53 2016 -0400
@@ -30,7 +30,7 @@
 
 void OSThread::pd_initialize() {
   assert(this != NULL, "check");
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
   _thread_id        = 0;
 #else
   _thread_id        = NULL;
--- ./hotspot/src/os/bsd/vm/os_bsd.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.cpp	Mon May 09 17:15:53 2016 -0400
@@ -97,16 +97,31 @@
 # include <sys/shm.h>
 #ifndef __APPLE__
 # include <link.h>
+# include <stdlib.h>
 #endif
 # include <stdint.h>
 # include <inttypes.h>
 # include <sys/ioctl.h>
 # include <sys/syscall.h>
 
+#ifdef __FreeBSD__
+# if __FreeBSD_version > 900030
+#  include <pthread_np.h>
+# else
+#  include <sys/thr.h>
+# endif
+# include <sys/cpuset.h>
+# include <vm/vm_param.h>
+#endif
+
 #if defined(__FreeBSD__) || defined(__NetBSD__)
 # include <elf.h>
 #endif
 
+#ifdef __NetBSD__
+#include <lwp.h>
+#endif
+
 #ifdef __APPLE__
 # include <mach/mach.h> // semaphore_* API
 # include <mach-o/dyld.h>
@@ -136,6 +151,7 @@
 volatile uint64_t         os::Bsd::_max_abstime   = 0;
 #else
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+int (*os::Bsd::_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 #endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
@@ -169,6 +185,27 @@
 
 // available here means free
 julong os::Bsd::available_memory() {
+#ifdef __FreeBSD__
+  static const char *vm_stats[] = {
+    "vm.stats.vm.v_free_count",
+    "vm.stats.vm.v_cache_count",
+    "vm.stats.vm.v_inactive_count"
+  };
+  size_t size;
+  julong free_pages;
+  u_int i, npages;
+
+  for (i = 0, free_pages = 0; i < sizeof(vm_stats) / sizeof(vm_stats[0]); i++) {
+    size = sizeof(npages);
+    if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1) {
+      free_pages = 0;
+      break;
+    }
+    free_pages += npages;
+  }
+  if (free_pages > 0)
+    return free_pages * os::vm_page_size();
+#endif
   uint64_t available = physical_memory() >> 2;
 #ifdef __APPLE__
   mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;
@@ -208,7 +245,7 @@
   static bool init = false;
   static bool privileges = false;
   if (!init) {
-    privileges = (getuid() != geteuid()) || (getgid() != getegid());
+    privileges = issetugid();
     init = true;
   }
   return privileges;
@@ -229,6 +266,8 @@
 static char cpu_arch[] = "arm";
 #elif defined(PPC32)
 static char cpu_arch[] = "ppc";
+#elif defined(PPC64)
+static char cpu_arch[] = "ppc64";
 #elif defined(SPARC)
 #  ifdef _LP64
 static char cpu_arch[] = "sparcv9";
@@ -411,12 +450,21 @@
     const char *v = ::getenv("LD_LIBRARY_PATH");
     const char *v_colon = ":";
     if (v == NULL) { v = ""; v_colon = ""; }
+#ifdef __APPLE__
     // That's +1 for the colon and +1 for the trailing '\0'.
     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,
                                                      strlen(v) + 1 +
                                                      sizeof(SYS_EXT_DIR) + sizeof("/lib/") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,
                                                      mtInternal);
     sprintf(ld_library_path, "%s%s" SYS_EXT_DIR "/lib/%s:" DEFAULT_LIBPATH, v, v_colon, cpu_arch);
+#else
+    // That's +1 for the colon and +1 for the trailing '\0'.
+    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,
+                                                     strlen(v) + 1 +
+                                                     sizeof(PACKAGE_PATH) + sizeof("/lib") + 1,
+                                                     mtInternal);
+    sprintf(ld_library_path, "%s%s" PACKAGE_PATH "/lib", v, v_colon);
+#endif
     Arguments::set_library_path(ld_library_path);
     FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);
   }
@@ -591,6 +639,9 @@
   sigaddset(&unblocked_sigs, SIGSEGV);
   sigaddset(&unblocked_sigs, SIGBUS);
   sigaddset(&unblocked_sigs, SIGFPE);
+#if defined(PPC64)
+  sigaddset(&unblocked_sigs, SIGTRAP);
+#endif
   sigaddset(&unblocked_sigs, SR_signum);
 
   if (!ReduceSignalUsage) {
@@ -983,6 +1034,13 @@
 bool os::vtime_enabled()  { return false; }
 
 double os::elapsedVTime() {
+#ifdef RUSAGE_THREAD
+  struct rusage usage;
+  int retval = getrusage(RUSAGE_THREAD, &usage);
+  if (retval == 0) {
+    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
+  }
+#endif
   // better than nothing, but not much
   return elapsedTime();
 }
@@ -1013,6 +1071,7 @@
     // yes, monotonic clock is supported
     _clock_gettime = ::clock_gettime;
   }
+  _getcpuclockid = (int (*)(pthread_t, clockid_t *))dlsym(RTLD_DEFAULT, "pthread_getcpuclockid");
 }
 #endif
 
@@ -1190,35 +1249,38 @@
 pid_t os::Bsd::gettid() {
   int retval = -1;
 
-#ifdef __APPLE__ //XNU kernel
+#if defined(__APPLE__) //XNU kernel
   // despite the fact mach port is actually not a thread id use it
   // instead of syscall(SYS_thread_selfid) as it certainly fits to u4
   retval = ::pthread_mach_thread_np(::pthread_self());
   guarantee(retval != 0, "just checking");
   return retval;
 
+#elif defined(__FreeBSD__)
+#if __FreeBSD_version > 900030
+  return ::pthread_getthreadid_np();
 #else
-  #ifdef __FreeBSD__
-  retval = syscall(SYS_thr_self);
-  #else
-    #ifdef __OpenBSD__
+  long tid;
+  thr_self(&tid);
+  return (pid_t)tid;
+#endif
+#elif defined(__OpenBSD__)
   retval = syscall(SYS_getthrid);
-    #else
-      #ifdef __NetBSD__
-  retval = (pid_t) syscall(SYS__lwp_self);
-      #endif
-    #endif
-  #endif
+#elif defined(__NetBSD__)
+  retval = (pid_t) _lwp_self();
 #endif
 
   if (retval == -1) {
     return getpid();
   }
+  return retval;
 }
 
 intx os::current_thread_id() {
-#ifdef __APPLE__
+#if defined(__APPLE__)
   return (intx)::pthread_mach_thread_np(::pthread_self());
+#elif defined(__FreeBSD__)
+  return os::Bsd::gettid();
 #else
   return (intx)::pthread_self();
 #endif
@@ -1696,14 +1758,14 @@
 }
 
 void os::print_os_info_brief(outputStream* st) {
-  st->print("Bsd");
+  st->print_cr("BSD");
 
   os::Posix::print_uname_info(st);
 }
 
 void os::print_os_info(outputStream* st) {
   st->print("OS:");
-  st->print("Bsd");
+  st->print_cr("BSD");
 
   os::Posix::print_uname_info(st);
 
@@ -1716,6 +1778,29 @@
   // Nothing to do for now.
 }
 
+#ifdef __FreeBSD__
+static void get_swap_info(int *total_pages, int *used_pages) {
+  struct xswdev xsw;
+  size_t mibsize, size;
+  int mib[16];
+  int n, total = 0, used = 0;
+
+  mibsize = sizeof(mib) / sizeof(mib[0]);
+  if (sysctlnametomib("vm.swap_info", mib, &mibsize) != -1) {
+    for (n = 0; ; n++) {
+      mib[mibsize] = n;
+      size = sizeof(xsw);
+      if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+        break;
+      total += xsw.xsw_nblks;
+      used += xsw.xsw_used;
+    }
+  }
+  *total_pages = total;
+  *used_pages = used;
+}
+#endif
+
 void os::print_memory_info(outputStream* st) {
 
   st->print("Memory:");
@@ -1725,11 +1810,14 @@
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
-  st->cr();
-
-  // meminfo
-  st->print("\n/proc/meminfo:\n");
-  _print_ascii_file("/proc/meminfo", st);
+#ifdef __FreeBSD__
+  int total, used;
+  get_swap_info(&total, &used);
+  st->print(", swap " UINT64_FORMAT "k",
+            (total * os::vm_page_size()) >> 10);
+  st->print("(" UINT64_FORMAT "k free)",
+            ((total - used) * os::vm_page_size()) >> 10);
+#endif
   st->cr();
 }
 
@@ -1768,6 +1856,9 @@
   print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);
   print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);
   print_signal_handler(st, BREAK_SIGNAL, buf, buflen);
+#if defined(PPC64)
+  print_signal_handler(st, SIGTRAP, buf, buflen);
+#endif
 }
 
 static char saved_jvm_path[MAXPATHLEN] = {0};
@@ -1965,7 +2056,7 @@
     os_semaphore_t _semaphore;
 };
 
-Semaphore::Semaphore() : _semaphore(0) {
+Semaphore::Semaphore() {
   SEM_INIT(_semaphore, 0);
 }
 
@@ -2153,7 +2244,7 @@
       if (::write(fd, "", 1) == 1) {
         mmap(base, size,
              PROT_READ|PROT_WRITE|PROT_EXEC,
-             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
+             MAP_PRIVATE|MAP_FIXED, fd, 0);
       }
     }
     ::close(fd);
@@ -2263,7 +2354,7 @@
   return ::mprotect(addr, size, PROT_NONE) == 0;
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
-                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
+                MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
 #endif
 }
@@ -2290,7 +2381,7 @@
   char * addr;
   int flags;
 
-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+  flags = MAP_PRIVATE | MAP_ANONYMOUS;
   if (fixed) {
     assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, "unaligned address");
     flags |= MAP_FIXED;
@@ -2779,6 +2870,7 @@
   return OS_OK;
 #elif defined(__FreeBSD__)
   int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+  return (ret == 0) ? OS_OK : OS_ERR;
 #elif defined(__APPLE__) || defined(__NetBSD__)
   struct sched_param sp;
   int policy;
@@ -3325,6 +3417,9 @@
     set_signal_handler(SIGBUS, true);
     set_signal_handler(SIGILL, true);
     set_signal_handler(SIGFPE, true);
+#if defined(PPC64)
+    set_signal_handler(SIGTRAP, true);
+#endif
     set_signal_handler(SIGXFSZ, true);
 
 #if defined(__APPLE__)
@@ -3373,18 +3468,6 @@
   }
 }
 
-
-/////
-// glibc on Bsd platform uses non-documented flag
-// to indicate, that some special sort of signal
-// trampoline is used.
-// We will never set this flag, and we should
-// ignore this flag in our diagnostic
-#ifdef SIGNIFICANT_SIGNAL_MASK
-#undef SIGNIFICANT_SIGNAL_MASK
-#endif
-#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
-
 static const char* get_signal_handler_name(address handler,
                                            char* buf, int buflen) {
   int offset;
@@ -3408,9 +3491,6 @@
 
   sigaction(sig, NULL, &sa);
 
-  // See comment for SIGNIFICANT_SIGNAL_MASK define
-  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;
-
   st->print("%s: ", os::exception_name(sig, buf, buflen));
 
   address handler = (sa.sa_flags & SA_SIGINFO)
@@ -3432,7 +3512,7 @@
   // May be, handler was resetted by VMError?
   if(rh != NULL) {
     handler = rh;
-    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;
+    sa.sa_flags = VMError::get_resetted_sigflags(sig);
   }
 
   st->print(", sa_flags=");
@@ -3474,6 +3554,9 @@
   DO_SIGNAL_CHECK(SIGBUS);
   DO_SIGNAL_CHECK(SIGPIPE);
   DO_SIGNAL_CHECK(SIGXFSZ);
+#if defined(PPC64)
+  DO_SIGNAL_CHECK(SIGTRAP);
+#endif
 
 
   // ReduceSignalUsage allows the user to override these handlers
@@ -3508,8 +3591,6 @@
   os_sigaction(sig, (struct sigaction*)NULL, &act);
 
 
-  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;
-
   address thisHandler = (act.sa_flags & SA_SIGINFO)
     ? CAST_FROM_FN_PTR(address, act.sa_sigaction)
     : CAST_FROM_FN_PTR(address, act.sa_handler) ;
@@ -3574,6 +3655,14 @@
 
 extern bool signal_name(int signo, char* buf, size_t len);
 
+#ifndef SIGRTMAX
+#ifdef __OpenBSD__
+#define SIGRTMAX        31
+#else
+#define SIGRTMAX        63
+#endif
+#endif
+
 const char* os::exception_name(int exception_code, char* buf, size_t size) {
   if (0 < exception_code && exception_code <= SIGRTMAX) {
     // signal
@@ -3770,6 +3859,19 @@
 };
 
 int os::active_processor_count() {
+#ifdef __FreeBSD__
+  int online_cpus = 0;
+  cpuset_t mask;
+  if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(mask),
+      &mask) == 0)
+    for (u_int i = 0; i < sizeof(mask) / sizeof(long); i++)
+      online_cpus += __builtin_popcountl(((long *)&mask)[i]);
+  if (online_cpus > 0 && online_cpus <= _processor_count)
+    return online_cpus;
+  online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
+  if (online_cpus >= 1)
+    return online_cpus;
+#endif
   return _processor_count;
 }
 
@@ -3981,7 +4083,10 @@
   }
   int fd;
   int o_delete = (oflag & O_DELETE);
-  oflag = oflag & ~O_DELETE;
+  oflag &= ~O_DELETE;
+#ifdef O_CLOEXEC
+  oflag |= O_CLOEXEC;
+#endif
 
   fd = ::open(path, oflag, mode);
   if (fd == -1) return -1;
@@ -4026,7 +4131,7 @@
      * 4843136: (process) pipe file descriptor from Runtime.exec not being closed
      * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9
      */
-#ifdef FD_CLOEXEC
+#if !defined(O_CLOEXEC) && defined(FD_CLOEXEC)
     {
         int flags = ::fcntl(fd, F_GETFD);
         if (flags != -1)
@@ -4166,8 +4271,9 @@
 #ifdef __APPLE__
   return os::thread_cpu_time(Thread::current(), true /* user + sys */);
 #else
-  Unimplemented();
-  return 0;
+  if (Bsd::_getcpuclockid != NULL)
+    return os::thread_cpu_time(Thread::current(), true /* user + sys */);
+  return -1;
 #endif
 }
 
@@ -4175,8 +4281,9 @@
 #ifdef __APPLE__
   return os::thread_cpu_time(thread, true /* user + sys */);
 #else
-  Unimplemented();
-  return 0;
+  if (Bsd::_getcpuclockid != NULL)
+    return os::thread_cpu_time(thread, true /* user + sys */);
+  return -1;
 #endif
 }
 
@@ -4184,8 +4291,9 @@
 #ifdef __APPLE__
   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
 #else
-  Unimplemented();
-  return 0;
+  if (Bsd::_getcpuclockid != NULL)
+    return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
+  return -1;
 #endif
 }
 
@@ -4210,8 +4318,41 @@
     return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
   }
 #else
-  Unimplemented();
-  return 0;
+  if (user_sys_cpu_time && Bsd::_getcpuclockid != NULL) {
+    struct timespec tp;
+    clockid_t clockid;
+    int ret;
+
+    /*
+     * XXX This is essentially a copy of the Linux implementation,
+     *     but with fewer indirections.
+     */
+    ret = Bsd::_getcpuclockid(thread->osthread()->pthread_id(), &clockid);
+    if (ret != 0)
+      return -1;
+    /* NB: _clock_gettime only needs to be valid for CLOCK_MONOTONIC. */
+    ret = ::clock_gettime(clockid, &tp);
+    if (ret != 0)
+      return -1;
+    return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;
+  }
+#ifdef RUSAGE_THREAD
+  if (thread == Thread::current()) {
+    struct rusage usage;
+    jlong nanos;
+
+    if (getrusage(RUSAGE_THREAD, &usage) != 0)
+      return -1;
+    nanos = (jlong)usage.ru_utime.tv_sec * NANOSECS_PER_SEC;
+    nanos += (jlong)usage.ru_utime.tv_usec * 1000;
+    if (user_sys_cpu_time) {
+      nanos += (jlong)usage.ru_stime.tv_sec * NANOSECS_PER_SEC;
+      nanos += (jlong)usage.ru_stime.tv_usec * 1000;
+    }
+    return nanos;
+  }
+#endif
+  return -1;
 #endif
 }
 
@@ -4234,7 +4375,7 @@
 #ifdef __APPLE__
   return true;
 #else
-  return false;
+  return (Bsd::_getcpuclockid != NULL);
 #endif
 }
 
@@ -4822,13 +4963,29 @@
 
 // Get the default path to the core file
 // Returns the length of the string
-int os::get_core_path(char* buffer, size_t bufferSize) {
-  int n = jio_snprintf(buffer, bufferSize, "/cores");
-
-  // Truncate if theoretical string was longer than bufferSize
-  n = MIN2(n, (int)bufferSize);
-
-  return n;
+int os::get_core_path(char *buffer, size_t bufferSize) {
+#ifdef __APPLE__
+  jio_snprintf(buffer, bufferSize, "/cores/core.%d", current_process_id());
+#else
+  const char *p = get_current_directory(buffer, bufferSize);
+
+  if (p == NULL) {
+    assert(p != NULL, "failed to get current directory");
+    return 0;
+  }
+
+  const char *q = getprogname();
+
+  if (q == NULL) {
+    assert(q != NULL, "failed to get progname");
+    return 0;
+  }
+
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/%s.core", q);
+#endif
+  return strlen(buffer);
 }
 
 #ifndef PRODUCT
--- ./hotspot/src/os/bsd/vm/os_bsd.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.hpp	Mon May 09 17:15:53 2016 -0400
@@ -58,12 +58,16 @@
   // For signal flags diagnostics
   static int sigflags[MAXSIGNUM];
 
+  static address   _initial_thread_stack_bottom;
+  static uintptr_t _initial_thread_stack_size;
+
 #ifdef __APPLE__
   // mach_absolute_time
   static mach_timebase_info_data_t _timebase_info;
   static volatile uint64_t         _max_abstime;
 #else
   static int (*_clock_gettime)(clockid_t, struct timespec *);
+  static int (*_getcpuclockid)(pthread_t, clockid_t *);
 #endif
 
   static GrowableArray<int>* _cpu_to_node;
@@ -95,6 +99,9 @@
   static bool is_initial_thread(void);
   static pid_t gettid();
 
+  static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
+  static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
+
   static int page_size(void)                                        { return _page_size; }
   static void set_page_size(int val)                                { _page_size = val; }
 
--- ./hotspot/src/os/bsd/vm/vmError_bsd.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/bsd/vm/vmError_bsd.cpp	Mon May 09 17:15:53 2016 -0400
@@ -33,30 +33,50 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <signal.h>
+#ifdef __FreeBSD__
+#include <limits.h>
+#include <sys/sysctl.h>
+#endif
+
+#define GDB_CMD "gdb"
+
+static void set_debugger(char *buf, int buflen) {
+  int pid = os::current_process_id();
+#ifdef __FreeBSD__
+  char cmd[PATH_MAX+1];
+  int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, pid };
+  size_t len = sizeof(cmd);
+  if (sysctl(name, 4, cmd, &len, NULL, 0) == 0 && len > 0) {
+    cmd[len] = '\0';
+    jio_snprintf(buf, buflen, "%s %s %d", GDB_CMD, cmd, pid);
+  } else
+#endif
+  jio_snprintf(buf, buflen, "%s /proc/%d/file %d", GDB_CMD, pid, pid);
+}
 
 void VMError::show_message_box(char *buf, int buflen) {
   bool yes;
   do {
-    error_string(buf, buflen);
-    int len = (int)strlen(buf);
+    intx tid = os::current_thread_id();
+    set_debugger(buf, buflen);
+    int len = (int)strlen(buf) + 1;
+    char *msg = &buf[len];
+    error_string(msg, buflen - len);
+    len += (int)strlen(msg);
     char *p = &buf[len];
 
     jio_snprintf(p, buflen - len,
                "\n\n"
                "Do you want to debug the problem?\n\n"
-               "To debug, run 'gdb /proc/%d/exe %d'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
-               "Enter 'yes' to launch gdb automatically (PATH must include gdb)\n"
+               "To debug, run '%s'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
+               "Enter 'yes' to launch " GDB_CMD " automatically (PATH must include " GDB_CMD ")\n"
                "Otherwise, press RETURN to abort...",
-               os::current_process_id(), os::current_process_id(),
-               os::current_thread_id(), os::current_thread_id());
+               buf, tid, tid);
 
-    yes = os::message_box("Unexpected Error", buf);
+    yes = os::message_box("Unexpected Error", msg);
 
     if (yes) {
       // yes, user asked VM to launch debugger
-      jio_snprintf(buf, buflen, "gdb /proc/%d/exe %d",
-                   os::current_process_id(), os::current_process_id());
-
       os::fork_and_exec(buf);
       yes = false;
     }
--- ./hotspot/src/os/linux/vm/os_linux.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/linux/vm/os_linux.cpp	Mon May 09 17:15:53 2016 -0400
@@ -6048,6 +6048,10 @@
     return 0;
   }
 
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
+
   return strlen(buffer);
 }
 
--- ./hotspot/src/os/posix/vm/os_posix.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/posix/vm/os_posix.cpp	Mon May 09 17:15:53 2016 -0400
@@ -53,12 +53,11 @@
   n = get_core_path(buffer, bufferSize);
 
   if (getrlimit(RLIMIT_CORE, &rlim) != 0) {
-    jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d (may not exist)", current_process_id());
+    jio_snprintf(buffer + n, bufferSize - n, " (may not exist)");
     success = true;
   } else {
     switch(rlim.rlim_cur) {
       case RLIM_INFINITY:
-        jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
         success = true;
         break;
       case 0:
@@ -66,7 +65,7 @@
         success = false;
         break;
       default:
-        jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d (max size %lu kB). To ensure a full core dump, try \"ulimit -c unlimited\" before starting Java again", current_process_id(), (unsigned long)(rlim.rlim_cur >> 10));
+        jio_snprintf(buffer + n, bufferSize - n, " (max size %lu kB). To ensure a full core dump, try \"ulimit -c unlimited\" before starting Java again", (unsigned long)(rlim.rlim_cur >> 10));
         success = true;
         break;
     }
@@ -201,8 +200,13 @@
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifdef __OpenBSD__
+  st->print(", DATA ");
+  getrlimit(RLIMIT_DATA, &rlim);
+#else
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
+#endif
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%uk", rlim.rlim_cur >> 10);
   st->cr();
@@ -222,7 +226,11 @@
 
 bool os::has_allocatable_memory_limit(julong* limit) {
   struct rlimit rlim;
+#ifdef __OpenBSD__
+  int getrlimit_res = getrlimit(RLIMIT_DATA, &rlim);
+#else
   int getrlimit_res = getrlimit(RLIMIT_AS, &rlim);
+#endif
   // if there was an error when calling getrlimit, assume that there is no limitation
   // on virtual memory.
   bool result;
@@ -706,8 +714,12 @@
     { SI_USER,      "SI_USER",     "Signal sent by kill()." },
     { SI_QUEUE,     "SI_QUEUE",    "Signal sent by the sigqueue()." },
     { SI_TIMER,     "SI_TIMER",    "Signal generated by expiration of a timer set by timer_settime()." },
+#ifdef SI_ASYNCIO
     { SI_ASYNCIO,   "SI_ASYNCIO",  "Signal generated by completion of an asynchronous I/O request." },
+#endif
+#ifdef SI_MESGQ
     { SI_MESGQ,     "SI_MESGQ",    "Signal generated by arrival of a message on an empty message queue." },
+#endif
     // Linux specific
 #ifdef SI_TKILL
     { SI_TKILL,     "SI_TKILL",    "Signal sent by tkill (pthread_kill)" },
--- ./hotspot/src/os/solaris/vm/os_solaris.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/os/solaris/vm/os_solaris.cpp	Mon May 09 17:15:53 2016 -0400
@@ -6375,6 +6375,10 @@
     return 0;
   }
 
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
+
   return strlen(buffer);
 }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/atomic_bsd_ppc.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,800 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+
+#include "runtime/atomic.hpp"
+#include "runtime/os.hpp"
+#include "vm_version_ppc.hpp"
+
+#ifndef PPC64
+#error "Atomic currently only implemented for PPC64"
+#endif
+
+// Implementation of class atomic
+
+inline void Atomic::store    (jbyte    store_value, jbyte*    dest) { *dest = store_value; }
+inline void Atomic::store    (jshort   store_value, jshort*   dest) { *dest = store_value; }
+inline void Atomic::store    (jint     store_value, jint*     dest) { *dest = store_value; }
+inline void Atomic::store    (jlong    store_value, jlong*    dest) { *dest = store_value; }
+inline void Atomic::store_ptr(intptr_t store_value, intptr_t* dest) { *dest = store_value; }
+inline void Atomic::store_ptr(void*    store_value, void*     dest) { *(void**)dest = store_value; }
+
+inline void Atomic::store    (jbyte    store_value, volatile jbyte*    dest) { *dest = store_value; }
+inline void Atomic::store    (jshort   store_value, volatile jshort*   dest) { *dest = store_value; }
+inline void Atomic::store    (jint     store_value, volatile jint*     dest) { *dest = store_value; }
+inline void Atomic::store    (jlong    store_value, volatile jlong*    dest) { *dest = store_value; }
+inline void Atomic::store_ptr(intptr_t store_value, volatile intptr_t* dest) { *dest = store_value; }
+inline void Atomic::store_ptr(void*    store_value, volatile void*     dest) { *(void* volatile *)dest = store_value; }
+
+inline jlong Atomic::load(volatile jlong* src) { return *src; }
+
+//
+// machine barrier instructions:
+//
+// - sync            two-way memory barrier, aka fence
+// - lwsync          orders  Store|Store,
+//                            Load|Store,
+//                            Load|Load,
+//                   but not Store|Load
+// - eieio           orders memory accesses for device memory (only)
+// - isync           invalidates speculatively executed instructions
+//                   From the POWER ISA 2.06 documentation:
+//                    "[...] an isync instruction prevents the execution of
+//                   instructions following the isync until instructions
+//                   preceding the isync have completed, [...]"
+//                   From IBM's AIX assembler reference:
+//                    "The isync [...] instructions causes the processor to
+//                   refetch any instructions that might have been fetched
+//                   prior to the isync instruction. The instruction isync
+//                   causes the processor to wait for all previous instructions
+//                   to complete. Then any instructions already fetched are
+//                   discarded and instruction processing continues in the
+//                   environment established by the previous instructions."
+//
+// semantic barrier instructions:
+// (as defined in orderAccess.hpp)
+//
+// - release         orders Store|Store,       (maps to lwsync)
+//                           Load|Store
+// - acquire         orders  Load|Store,       (maps to lwsync)
+//                           Load|Load
+// - fence           orders Store|Store,       (maps to sync)
+//                           Load|Store,
+//                           Load|Load,
+//                          Store|Load
+//
+
+#define strasm_sync                       "\n  sync    \n"
+#define strasm_lwsync                     "\n  lwsync  \n"
+#define strasm_isync                      "\n  isync   \n"
+#define strasm_release                    strasm_lwsync
+#define strasm_acquire                    strasm_lwsync
+#define strasm_fence                      strasm_sync
+#define strasm_nobarrier                  ""
+#define strasm_nobarrier_clobber_memory   ""
+
+inline jint     Atomic::add    (jint     add_value, volatile jint*     dest) {
+
+  unsigned int result;
+
+  __asm__ __volatile__ (
+    strasm_lwsync
+    "1: lwarx   %0,  0, %2    \n"
+    "   add     %0, %0, %1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_isync
+    : /*%0*/"=&r" (result)
+    : /*%1*/"r" (add_value), /*%2*/"r" (dest)
+    : "cc", "memory" );
+
+  return (jint) result;
+}
+
+
+inline intptr_t Atomic::add_ptr(intptr_t add_value, volatile intptr_t* dest) {
+
+  long result;
+
+  __asm__ __volatile__ (
+    strasm_lwsync
+    "1: ldarx   %0,  0, %2    \n"
+    "   add     %0, %0, %1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_isync
+    : /*%0*/"=&r" (result)
+    : /*%1*/"r" (add_value), /*%2*/"r" (dest)
+    : "cc", "memory" );
+
+  return (intptr_t) result;
+}
+
+inline void*    Atomic::add_ptr(intptr_t add_value, volatile void*     dest) {
+  return (void*)add_ptr(add_value, (volatile intptr_t*)dest);
+}
+
+
+inline void Atomic::inc    (volatile jint*     dest) {
+
+  unsigned int temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: lwarx   %0,  0, %2    \n"
+    "   addic   %0, %0,  1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::inc_ptr(volatile intptr_t* dest) {
+
+  long temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: ldarx   %0,  0, %2    \n"
+    "   addic   %0, %0,  1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::inc_ptr(volatile void*     dest) {
+  inc_ptr((volatile intptr_t*)dest);
+}
+
+
+inline void Atomic::dec    (volatile jint*     dest) {
+
+  unsigned int temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: lwarx   %0,  0, %2    \n"
+    "   addic   %0, %0, -1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::dec_ptr(volatile intptr_t* dest) {
+
+  long temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: ldarx   %0,  0, %2    \n"
+    "   addic   %0, %0, -1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::dec_ptr(volatile void*     dest) {
+  dec_ptr((volatile intptr_t*)dest);
+}
+
+inline jint Atomic::xchg(jint exchange_value, volatile jint* dest) {
+
+  // Note that xchg_ptr doesn't necessarily do an acquire
+  // (see synchronizer.cpp).
+
+  unsigned int old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* lwsync */
+    strasm_lwsync
+    /* atomic loop */
+    "1:                                                 \n"
+    "   lwarx   %[old_value], %[dest], %[zero]          \n"
+    "   stwcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* isync */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jint) old_value;
+}
+
+inline intptr_t Atomic::xchg_ptr(intptr_t exchange_value, volatile intptr_t* dest) {
+
+  // Note that xchg_ptr doesn't necessarily do an acquire
+  // (see synchronizer.cpp).
+
+  long old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* lwsync */
+    strasm_lwsync
+    /* atomic loop */
+    "1:                                                 \n"
+    "   ldarx   %[old_value], %[dest], %[zero]          \n"
+    "   stdcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* isync */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (intptr_t) old_value;
+}
+
+inline void* Atomic::xchg_ptr(void* exchange_value, volatile void* dest) {
+  return (void*)xchg_ptr((intptr_t)exchange_value, (volatile intptr_t*)dest);
+}
+
+inline jint Atomic::cmpxchg(jint exchange_value, volatile jint* dest, jint compare_value) {
+
+  // Note that cmpxchg guarantees a two-way memory barrier across
+  // the cmpxchg, so it's really a a 'fence_cmpxchg_acquire'
+  // (see atomic.hpp).
+
+  unsigned int old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* fence */
+    strasm_sync
+    /* simple guard */
+    "   lwz     %[old_value], 0(%[dest])                \n"
+    "   cmpw    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    /* atomic loop */
+    "1:                                                 \n"
+    "   lwarx   %[old_value], %[dest], %[zero]          \n"
+    "   cmpw    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    "   stwcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* acquire */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [compare_value]   "r"     (compare_value),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jint) old_value;
+}
+
+inline jlong Atomic::cmpxchg(jlong exchange_value, volatile jlong* dest, jlong compare_value) {
+
+  // Note that cmpxchg guarantees a two-way memory barrier across
+  // the cmpxchg, so it's really a a 'fence_cmpxchg_acquire'
+  // (see atomic.hpp).
+
+  long old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* fence */
+    strasm_sync
+    /* simple guard */
+    "   ld      %[old_value], 0(%[dest])                \n"
+    "   cmpd    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    /* atomic loop */
+    "1:                                                 \n"
+    "   ldarx   %[old_value], %[dest], %[zero]          \n"
+    "   cmpd    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    "   stdcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* acquire */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [compare_value]   "r"     (compare_value),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jlong) old_value;
+}
+
+inline intptr_t Atomic::cmpxchg_ptr(intptr_t exchange_value, volatile intptr_t* dest, intptr_t compare_value) {
+  return (intptr_t)cmpxchg((jlong)exchange_value, (volatile jlong*)dest, (jlong)compare_value);
+}
+
+inline void* Atomic::cmpxchg_ptr(void* exchange_value, volatile void* dest, void* compare_value) {
+  return (void*)cmpxchg((jlong)exchange_value, (volatile jlong*)dest, (jlong)compare_value);
+}
+
+#undef strasm_sync
+#undef strasm_lwsync
+#undef strasm_isync
+#undef strasm_release
+#undef strasm_acquire
+#undef strasm_fence
+#undef strasm_nobarrier
+#undef strasm_nobarrier_clobber_memory
+
+#endif // OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+
+#include "runtime/atomic.hpp"
+#include "runtime/os.hpp"
+#include "vm_version_ppc.hpp"
+
+#ifndef PPC64
+#error "Atomic currently only implemented for PPC64"
+#endif
+
+// Implementation of class atomic
+
+inline void Atomic::store    (jbyte    store_value, jbyte*    dest) { *dest = store_value; }
+inline void Atomic::store    (jshort   store_value, jshort*   dest) { *dest = store_value; }
+inline void Atomic::store    (jint     store_value, jint*     dest) { *dest = store_value; }
+inline void Atomic::store    (jlong    store_value, jlong*    dest) { *dest = store_value; }
+inline void Atomic::store_ptr(intptr_t store_value, intptr_t* dest) { *dest = store_value; }
+inline void Atomic::store_ptr(void*    store_value, void*     dest) { *(void**)dest = store_value; }
+
+inline void Atomic::store    (jbyte    store_value, volatile jbyte*    dest) { *dest = store_value; }
+inline void Atomic::store    (jshort   store_value, volatile jshort*   dest) { *dest = store_value; }
+inline void Atomic::store    (jint     store_value, volatile jint*     dest) { *dest = store_value; }
+inline void Atomic::store    (jlong    store_value, volatile jlong*    dest) { *dest = store_value; }
+inline void Atomic::store_ptr(intptr_t store_value, volatile intptr_t* dest) { *dest = store_value; }
+inline void Atomic::store_ptr(void*    store_value, volatile void*     dest) { *(void* volatile *)dest = store_value; }
+
+inline jlong Atomic::load(volatile jlong* src) { return *src; }
+
+//
+// machine barrier instructions:
+//
+// - sync            two-way memory barrier, aka fence
+// - lwsync          orders  Store|Store,
+//                            Load|Store,
+//                            Load|Load,
+//                   but not Store|Load
+// - eieio           orders memory accesses for device memory (only)
+// - isync           invalidates speculatively executed instructions
+//                   From the POWER ISA 2.06 documentation:
+//                    "[...] an isync instruction prevents the execution of
+//                   instructions following the isync until instructions
+//                   preceding the isync have completed, [...]"
+//                   From IBM's AIX assembler reference:
+//                    "The isync [...] instructions causes the processor to
+//                   refetch any instructions that might have been fetched
+//                   prior to the isync instruction. The instruction isync
+//                   causes the processor to wait for all previous instructions
+//                   to complete. Then any instructions already fetched are
+//                   discarded and instruction processing continues in the
+//                   environment established by the previous instructions."
+//
+// semantic barrier instructions:
+// (as defined in orderAccess.hpp)
+//
+// - release         orders Store|Store,       (maps to lwsync)
+//                           Load|Store
+// - acquire         orders  Load|Store,       (maps to lwsync)
+//                           Load|Load
+// - fence           orders Store|Store,       (maps to sync)
+//                           Load|Store,
+//                           Load|Load,
+//                          Store|Load
+//
+
+#define strasm_sync                       "\n  sync    \n"
+#define strasm_lwsync                     "\n  lwsync  \n"
+#define strasm_isync                      "\n  isync   \n"
+#define strasm_release                    strasm_lwsync
+#define strasm_acquire                    strasm_lwsync
+#define strasm_fence                      strasm_sync
+#define strasm_nobarrier                  ""
+#define strasm_nobarrier_clobber_memory   ""
+
+inline jint     Atomic::add    (jint     add_value, volatile jint*     dest) {
+
+  unsigned int result;
+
+  __asm__ __volatile__ (
+    strasm_lwsync
+    "1: lwarx   %0,  0, %2    \n"
+    "   add     %0, %0, %1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_isync
+    : /*%0*/"=&r" (result)
+    : /*%1*/"r" (add_value), /*%2*/"r" (dest)
+    : "cc", "memory" );
+
+  return (jint) result;
+}
+
+
+inline intptr_t Atomic::add_ptr(intptr_t add_value, volatile intptr_t* dest) {
+
+  long result;
+
+  __asm__ __volatile__ (
+    strasm_lwsync
+    "1: ldarx   %0,  0, %2    \n"
+    "   add     %0, %0, %1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_isync
+    : /*%0*/"=&r" (result)
+    : /*%1*/"r" (add_value), /*%2*/"r" (dest)
+    : "cc", "memory" );
+
+  return (intptr_t) result;
+}
+
+inline void*    Atomic::add_ptr(intptr_t add_value, volatile void*     dest) {
+  return (void*)add_ptr(add_value, (volatile intptr_t*)dest);
+}
+
+
+inline void Atomic::inc    (volatile jint*     dest) {
+
+  unsigned int temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: lwarx   %0,  0, %2    \n"
+    "   addic   %0, %0,  1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::inc_ptr(volatile intptr_t* dest) {
+
+  long temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: ldarx   %0,  0, %2    \n"
+    "   addic   %0, %0,  1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::inc_ptr(volatile void*     dest) {
+  inc_ptr((volatile intptr_t*)dest);
+}
+
+
+inline void Atomic::dec    (volatile jint*     dest) {
+
+  unsigned int temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: lwarx   %0,  0, %2    \n"
+    "   addic   %0, %0, -1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::dec_ptr(volatile intptr_t* dest) {
+
+  long temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: ldarx   %0,  0, %2    \n"
+    "   addic   %0, %0, -1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::dec_ptr(volatile void*     dest) {
+  dec_ptr((volatile intptr_t*)dest);
+}
+
+inline jint Atomic::xchg(jint exchange_value, volatile jint* dest) {
+
+  // Note that xchg_ptr doesn't necessarily do an acquire
+  // (see synchronizer.cpp).
+
+  unsigned int old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* lwsync */
+    strasm_lwsync
+    /* atomic loop */
+    "1:                                                 \n"
+    "   lwarx   %[old_value], %[dest], %[zero]          \n"
+    "   stwcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* isync */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jint) old_value;
+}
+
+inline intptr_t Atomic::xchg_ptr(intptr_t exchange_value, volatile intptr_t* dest) {
+
+  // Note that xchg_ptr doesn't necessarily do an acquire
+  // (see synchronizer.cpp).
+
+  long old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* lwsync */
+    strasm_lwsync
+    /* atomic loop */
+    "1:                                                 \n"
+    "   ldarx   %[old_value], %[dest], %[zero]          \n"
+    "   stdcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* isync */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (intptr_t) old_value;
+}
+
+inline void* Atomic::xchg_ptr(void* exchange_value, volatile void* dest) {
+  return (void*)xchg_ptr((intptr_t)exchange_value, (volatile intptr_t*)dest);
+}
+
+inline jint Atomic::cmpxchg(jint exchange_value, volatile jint* dest, jint compare_value) {
+
+  // Note that cmpxchg guarantees a two-way memory barrier across
+  // the cmpxchg, so it's really a a 'fence_cmpxchg_acquire'
+  // (see atomic.hpp).
+
+  unsigned int old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* fence */
+    strasm_sync
+    /* simple guard */
+    "   lwz     %[old_value], 0(%[dest])                \n"
+    "   cmpw    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    /* atomic loop */
+    "1:                                                 \n"
+    "   lwarx   %[old_value], %[dest], %[zero]          \n"
+    "   cmpw    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    "   stwcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* acquire */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [compare_value]   "r"     (compare_value),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jint) old_value;
+}
+
+inline jlong Atomic::cmpxchg(jlong exchange_value, volatile jlong* dest, jlong compare_value) {
+
+  // Note that cmpxchg guarantees a two-way memory barrier across
+  // the cmpxchg, so it's really a a 'fence_cmpxchg_acquire'
+  // (see atomic.hpp).
+
+  long old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* fence */
+    strasm_sync
+    /* simple guard */
+    "   ld      %[old_value], 0(%[dest])                \n"
+    "   cmpd    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    /* atomic loop */
+    "1:                                                 \n"
+    "   ldarx   %[old_value], %[dest], %[zero]          \n"
+    "   cmpd    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    "   stdcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* acquire */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [compare_value]   "r"     (compare_value),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jlong) old_value;
+}
+
+inline intptr_t Atomic::cmpxchg_ptr(intptr_t exchange_value, volatile intptr_t* dest, intptr_t compare_value) {
+  return (intptr_t)cmpxchg((jlong)exchange_value, (volatile jlong*)dest, (jlong)compare_value);
+}
+
+inline void* Atomic::cmpxchg_ptr(void* exchange_value, volatile void* dest, void* compare_value) {
+  return (void*)cmpxchg((jlong)exchange_value, (volatile jlong*)dest, (jlong)compare_value);
+}
+
+#undef strasm_sync
+#undef strasm_lwsync
+#undef strasm_isync
+#undef strasm_release
+#undef strasm_acquire
+#undef strasm_fence
+#undef strasm_nobarrier
+#undef strasm_nobarrier_clobber_memory
+
+#endif // OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/bytes_bsd_ppc.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2014 Google Inc.  All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+
+#if defined(VM_LITTLE_ENDIAN)
+#include <byteswap.h>
+
+// Efficient swapping of data bytes from Java byte
+// ordering to native byte ordering and vice versa.
+inline u2 Bytes::swap_u2(u2 x) { return bswap_16(x); }
+inline u4 Bytes::swap_u4(u4 x) { return bswap_32(x); }
+inline u8 Bytes::swap_u8(u8 x) { return bswap_64(x); }
+#endif // VM_LITTLE_ENDIAN
+
+#endif // OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2014 Google Inc.  All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+
+#if defined(VM_LITTLE_ENDIAN)
+#include <byteswap.h>
+
+// Efficient swapping of data bytes from Java byte
+// ordering to native byte ordering and vice versa.
+inline u2 Bytes::swap_u2(u2 x) { return bswap_16(x); }
+inline u4 Bytes::swap_u4(u4 x) { return bswap_32(x); }
+inline u8 Bytes::swap_u8(u8 x) { return bswap_64(x); }
+#endif // VM_LITTLE_ENDIAN
+
+#endif // OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/globals_bsd_ppc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+
+// Sets the default values for platform dependent flags used by the runtime system.
+// (see globals.hpp)
+
+define_pd_global(bool, DontYieldALot,            false);
+define_pd_global(intx, ThreadStackSize,          2048); // 0 => use system default
+define_pd_global(intx, VMThreadStackSize,        2048);
+
+// if we set CompilerThreadStackSize to a value different than 0, it will
+// be used in os::create_thread(). Otherwise, due the strange logic in os::create_thread(),
+// the stack size for compiler threads will default to VMThreadStackSize, although it
+// is defined to 4M in os::Bsd::default_stack_size()!
+define_pd_global(intx, CompilerThreadStackSize,  4096);
+
+// Allow extra space in DEBUG builds for asserts.
+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+
+define_pd_global(intx, StackYellowPages,         6);
+define_pd_global(intx, StackRedPages,            1);
+define_pd_global(intx, StackShadowPages,         6 DEBUG_ONLY(+2));
+
+// Only used on 64 bit platforms
+define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+// Only used on 64 bit Windows platforms
+define_pd_global(bool, UseVectoredExceptions,    false);
+
+#endif // OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+
+// Sets the default values for platform dependent flags used by the runtime system.
+// (see globals.hpp)
+
+define_pd_global(bool, DontYieldALot,            false);
+define_pd_global(intx, ThreadStackSize,          2048); // 0 => use system default
+define_pd_global(intx, VMThreadStackSize,        2048);
+
+// if we set CompilerThreadStackSize to a value different than 0, it will
+// be used in os::create_thread(). Otherwise, due the strange logic in os::create_thread(),
+// the stack size for compiler threads will default to VMThreadStackSize, although it
+// is defined to 4M in os::Bsd::default_stack_size()!
+define_pd_global(intx, CompilerThreadStackSize,  4096);
+
+// Allow extra space in DEBUG builds for asserts.
+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+
+define_pd_global(intx, StackYellowPages,         6);
+define_pd_global(intx, StackRedPages,            1);
+define_pd_global(intx, StackShadowPages,         6 DEBUG_ONLY(+2));
+
+// Only used on 64 bit platforms
+define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+// Only used on 64 bit Windows platforms
+define_pd_global(bool, UseVectoredExceptions,    false);
+
+#endif // OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/orderAccess_bsd_ppc.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+
+#include "runtime/orderAccess.hpp"
+#include "vm_version_ppc.hpp"
+
+#ifndef PPC64
+#error "OrderAccess currently only implemented for PPC64"
+#endif
+
+// Implementation of class OrderAccess.
+
+//
+// Machine barrier instructions:
+//
+// - sync            Two-way memory barrier, aka fence.
+// - lwsync          orders  Store|Store,
+//                            Load|Store,
+//                            Load|Load,
+//                   but not Store|Load
+// - eieio           orders  Store|Store
+// - isync           Invalidates speculatively executed instructions,
+//                   but isync may complete before storage accesses
+//                   associated with instructions preceding isync have
+//                   been performed.
+//
+// Semantic barrier instructions:
+// (as defined in orderAccess.hpp)
+//
+// - release         orders Store|Store,       (maps to lwsync)
+//                           Load|Store
+// - acquire         orders  Load|Store,       (maps to lwsync)
+//                           Load|Load
+// - fence           orders Store|Store,       (maps to sync)
+//                           Load|Store,
+//                           Load|Load,
+//                          Store|Load
+//
+
+#define inlasm_sync()     __asm__ __volatile__ ("sync"   : : : "memory");
+#define inlasm_lwsync()   __asm__ __volatile__ ("lwsync" : : : "memory");
+#define inlasm_eieio()    __asm__ __volatile__ ("eieio"  : : : "memory");
+#define inlasm_isync()    __asm__ __volatile__ ("isync"  : : : "memory");
+#define inlasm_release()  inlasm_lwsync();
+#define inlasm_acquire()  inlasm_lwsync();
+// Use twi-isync for load_acquire (faster than lwsync).
+#define inlasm_acquire_reg(X) __asm__ __volatile__ ("twi 0,%0,0\n isync\n" : : "r" (X) : "memory");
+#define inlasm_fence()    inlasm_sync();
+
+inline void     OrderAccess::loadload()   { inlasm_lwsync();  }
+inline void     OrderAccess::storestore() { inlasm_lwsync();  }
+inline void     OrderAccess::loadstore()  { inlasm_lwsync();  }
+inline void     OrderAccess::storeload()  { inlasm_fence();   }
+
+inline void     OrderAccess::acquire()    { inlasm_acquire(); }
+inline void     OrderAccess::release()    { inlasm_release(); }
+inline void     OrderAccess::fence()      { inlasm_fence();   }
+
+inline jbyte    OrderAccess::load_acquire(volatile jbyte*   p) { register jbyte t = *p;   inlasm_acquire_reg(t); return t; }
+inline jshort   OrderAccess::load_acquire(volatile jshort*  p) { register jshort t = *p;  inlasm_acquire_reg(t); return t; }
+inline jint     OrderAccess::load_acquire(volatile jint*    p) { register jint t = *p;    inlasm_acquire_reg(t); return t; }
+inline jlong    OrderAccess::load_acquire(volatile jlong*   p) { register jlong t = *p;   inlasm_acquire_reg(t); return t; }
+inline jubyte   OrderAccess::load_acquire(volatile jubyte*  p) { register jubyte t = *p;  inlasm_acquire_reg(t); return t; }
+inline jushort  OrderAccess::load_acquire(volatile jushort* p) { register jushort t = *p; inlasm_acquire_reg(t); return t; }
+inline juint    OrderAccess::load_acquire(volatile juint*   p) { register juint t = *p;   inlasm_acquire_reg(t); return t; }
+inline julong   OrderAccess::load_acquire(volatile julong*  p) { return (julong)load_acquire((volatile jlong*)p); }
+inline jfloat   OrderAccess::load_acquire(volatile jfloat*  p) { register jfloat t = *p;  inlasm_acquire(); return t; }
+inline jdouble  OrderAccess::load_acquire(volatile jdouble* p) { register jdouble t = *p; inlasm_acquire(); return t; }
+
+inline intptr_t OrderAccess::load_ptr_acquire(volatile intptr_t*   p) { return (intptr_t)load_acquire((volatile jlong*)p); }
+inline void*    OrderAccess::load_ptr_acquire(volatile void*       p) { return (void*)   load_acquire((volatile jlong*)p); }
+inline void*    OrderAccess::load_ptr_acquire(const volatile void* p) { return (void*)   load_acquire((volatile jlong*)p); }
+
+inline void     OrderAccess::release_store(volatile jbyte*   p, jbyte   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jshort*  p, jshort  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jint*    p, jint    v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jlong*   p, jlong   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jubyte*  p, jubyte  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jushort* p, jushort v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile juint*   p, juint   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile julong*  p, julong  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jfloat*  p, jfloat  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jdouble* p, jdouble v) { inlasm_release(); *p = v; }
+
+inline void     OrderAccess::release_store_ptr(volatile intptr_t* p, intptr_t v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store_ptr(volatile void*     p, void*    v) { inlasm_release(); *(void* volatile *)p = v; }
+
+inline void     OrderAccess::store_fence(jbyte*   p, jbyte   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jshort*  p, jshort  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jint*    p, jint    v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jlong*   p, jlong   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jubyte*  p, jubyte  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jushort* p, jushort v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(juint*   p, juint   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(julong*  p, julong  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jfloat*  p, jfloat  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jdouble* p, jdouble v) { *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::store_ptr_fence(intptr_t* p, intptr_t v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_ptr_fence(void**    p, void*    v) { *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::release_store_fence(volatile jbyte*   p, jbyte   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jshort*  p, jshort  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jint*    p, jint    v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jlong*   p, jlong   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jubyte*  p, jubyte  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jushort* p, jushort v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile juint*   p, juint   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile julong*  p, julong  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jfloat*  p, jfloat  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jdouble* p, jdouble v) { inlasm_release(); *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::release_store_ptr_fence(volatile intptr_t* p, intptr_t v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_ptr_fence(volatile void*     p, void*    v) { inlasm_release(); *(void* volatile *)p = v; inlasm_fence(); }
+
+#undef inlasm_sync
+#undef inlasm_lwsync
+#undef inlasm_eieio
+#undef inlasm_isync
+#undef inlasm_release
+#undef inlasm_acquire
+#undef inlasm_fence
+
+#endif // OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+
+#include "runtime/orderAccess.hpp"
+#include "vm_version_ppc.hpp"
+
+#ifndef PPC64
+#error "OrderAccess currently only implemented for PPC64"
+#endif
+
+// Implementation of class OrderAccess.
+
+//
+// Machine barrier instructions:
+//
+// - sync            Two-way memory barrier, aka fence.
+// - lwsync          orders  Store|Store,
+//                            Load|Store,
+//                            Load|Load,
+//                   but not Store|Load
+// - eieio           orders  Store|Store
+// - isync           Invalidates speculatively executed instructions,
+//                   but isync may complete before storage accesses
+//                   associated with instructions preceding isync have
+//                   been performed.
+//
+// Semantic barrier instructions:
+// (as defined in orderAccess.hpp)
+//
+// - release         orders Store|Store,       (maps to lwsync)
+//                           Load|Store
+// - acquire         orders  Load|Store,       (maps to lwsync)
+//                           Load|Load
+// - fence           orders Store|Store,       (maps to sync)
+//                           Load|Store,
+//                           Load|Load,
+//                          Store|Load
+//
+
+#define inlasm_sync()     __asm__ __volatile__ ("sync"   : : : "memory");
+#define inlasm_lwsync()   __asm__ __volatile__ ("lwsync" : : : "memory");
+#define inlasm_eieio()    __asm__ __volatile__ ("eieio"  : : : "memory");
+#define inlasm_isync()    __asm__ __volatile__ ("isync"  : : : "memory");
+#define inlasm_release()  inlasm_lwsync();
+#define inlasm_acquire()  inlasm_lwsync();
+// Use twi-isync for load_acquire (faster than lwsync).
+#define inlasm_acquire_reg(X) __asm__ __volatile__ ("twi 0,%0,0\n isync\n" : : "r" (X) : "memory");
+#define inlasm_fence()    inlasm_sync();
+
+inline void     OrderAccess::loadload()   { inlasm_lwsync();  }
+inline void     OrderAccess::storestore() { inlasm_lwsync();  }
+inline void     OrderAccess::loadstore()  { inlasm_lwsync();  }
+inline void     OrderAccess::storeload()  { inlasm_fence();   }
+
+inline void     OrderAccess::acquire()    { inlasm_acquire(); }
+inline void     OrderAccess::release()    { inlasm_release(); }
+inline void     OrderAccess::fence()      { inlasm_fence();   }
+
+inline jbyte    OrderAccess::load_acquire(volatile jbyte*   p) { register jbyte t = *p;   inlasm_acquire_reg(t); return t; }
+inline jshort   OrderAccess::load_acquire(volatile jshort*  p) { register jshort t = *p;  inlasm_acquire_reg(t); return t; }
+inline jint     OrderAccess::load_acquire(volatile jint*    p) { register jint t = *p;    inlasm_acquire_reg(t); return t; }
+inline jlong    OrderAccess::load_acquire(volatile jlong*   p) { register jlong t = *p;   inlasm_acquire_reg(t); return t; }
+inline jubyte   OrderAccess::load_acquire(volatile jubyte*  p) { register jubyte t = *p;  inlasm_acquire_reg(t); return t; }
+inline jushort  OrderAccess::load_acquire(volatile jushort* p) { register jushort t = *p; inlasm_acquire_reg(t); return t; }
+inline juint    OrderAccess::load_acquire(volatile juint*   p) { register juint t = *p;   inlasm_acquire_reg(t); return t; }
+inline julong   OrderAccess::load_acquire(volatile julong*  p) { return (julong)load_acquire((volatile jlong*)p); }
+inline jfloat   OrderAccess::load_acquire(volatile jfloat*  p) { register jfloat t = *p;  inlasm_acquire(); return t; }
+inline jdouble  OrderAccess::load_acquire(volatile jdouble* p) { register jdouble t = *p; inlasm_acquire(); return t; }
+
+inline intptr_t OrderAccess::load_ptr_acquire(volatile intptr_t*   p) { return (intptr_t)load_acquire((volatile jlong*)p); }
+inline void*    OrderAccess::load_ptr_acquire(volatile void*       p) { return (void*)   load_acquire((volatile jlong*)p); }
+inline void*    OrderAccess::load_ptr_acquire(const volatile void* p) { return (void*)   load_acquire((volatile jlong*)p); }
+
+inline void     OrderAccess::release_store(volatile jbyte*   p, jbyte   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jshort*  p, jshort  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jint*    p, jint    v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jlong*   p, jlong   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jubyte*  p, jubyte  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jushort* p, jushort v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile juint*   p, juint   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile julong*  p, julong  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jfloat*  p, jfloat  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jdouble* p, jdouble v) { inlasm_release(); *p = v; }
+
+inline void     OrderAccess::release_store_ptr(volatile intptr_t* p, intptr_t v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store_ptr(volatile void*     p, void*    v) { inlasm_release(); *(void* volatile *)p = v; }
+
+inline void     OrderAccess::store_fence(jbyte*   p, jbyte   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jshort*  p, jshort  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jint*    p, jint    v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jlong*   p, jlong   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jubyte*  p, jubyte  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jushort* p, jushort v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(juint*   p, juint   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(julong*  p, julong  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jfloat*  p, jfloat  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jdouble* p, jdouble v) { *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::store_ptr_fence(intptr_t* p, intptr_t v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_ptr_fence(void**    p, void*    v) { *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::release_store_fence(volatile jbyte*   p, jbyte   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jshort*  p, jshort  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jint*    p, jint    v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jlong*   p, jlong   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jubyte*  p, jubyte  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jushort* p, jushort v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile juint*   p, juint   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile julong*  p, julong  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jfloat*  p, jfloat  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jdouble* p, jdouble v) { inlasm_release(); *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::release_store_ptr_fence(volatile intptr_t* p, intptr_t v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_ptr_fence(volatile void*     p, void*    v) { inlasm_release(); *(void* volatile *)p = v; inlasm_fence(); }
+
+#undef inlasm_sync
+#undef inlasm_lwsync
+#undef inlasm_eieio
+#undef inlasm_isync
+#undef inlasm_release
+#undef inlasm_acquire
+#undef inlasm_fence
+
+#endif // OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/os_bsd_ppc.cpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,1332 @@
+/*
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// no precompiled headers
+#include "assembler_ppc.inline.hpp"
+#include "classfile/classLoader.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/vmSymbols.hpp"
+#include "code/icBuffer.hpp"
+#include "code/vtableStubs.hpp"
+#include "interpreter/interpreter.hpp"
+#include "jvm_bsd.h"
+#include "memory/allocation.inline.hpp"
+#include "mutex_bsd.inline.hpp"
+#include "nativeInst_ppc.hpp"
+#include "os_share_bsd.hpp"
+#include "prims/jniFastGetField.hpp"
+#include "prims/jvm.h"
+#include "prims/jvm_misc.hpp"
+#include "runtime/arguments.hpp"
+#include "runtime/extendedPC.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/interfaceSupport.hpp"
+#include "runtime/java.hpp"
+#include "runtime/javaCalls.hpp"
+#include "runtime/mutexLocker.hpp"
+#include "runtime/osThread.hpp"
+#include "runtime/sharedRuntime.hpp"
+#include "runtime/stubRoutines.hpp"
+#include "runtime/thread.inline.hpp"
+#include "runtime/timer.hpp"
+#include "utilities/events.hpp"
+#include "utilities/vmError.hpp"
+#ifdef COMPILER1
+#include "c1/c1_Runtime1.hpp"
+#endif
+#ifdef COMPILER2
+#include "opto/runtime.hpp"
+#endif
+
+// put OS-includes here
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <pthread.h>
+# include <signal.h>
+# include <errno.h>
+# include <dlfcn.h>
+# include <stdlib.h>
+# include <stdio.h>
+# include <unistd.h>
+# include <sys/resource.h>
+# include <pthread_np.h>
+# include <sys/stat.h>
+# include <sys/time.h>
+# include <sys/utsname.h>
+# include <sys/socket.h>
+# include <sys/wait.h>
+# include <pwd.h>
+# include <poll.h>
+# include <ucontext.h>
+
+
+address os::current_stack_pointer() {
+  intptr_t* csp;
+
+  // inline assembly `mr regno(csp), R1_SP':
+  __asm__ __volatile__ ("mr %0, 1":"=r"(csp):);
+
+  return (address) csp;
+}
+
+char* os::non_memory_address_word() {
+  // Must never look like an address returned by reserve_memory,
+  // even in its subfields (as defined by the CPU immediate fields,
+  // if the CPU splits constants across multiple instructions).
+
+  return (char*) -1;
+}
+
+void os::initialize_thread(Thread *thread) { }
+
+address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
+  guarantee(uc->uc_mcontext.mc_gpr != NULL, "only use ucontext_get_pc in sigaction context");
+  return (address)uc->uc_mcontext.mc_srr0;
+}
+
+intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
+  return (intptr_t*)uc->uc_mcontext.mc_gpr[1/*REG_SP*/];
+}
+
+intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
+  return NULL;
+}
+
+ExtendedPC os::fetch_frame_from_context(void* ucVoid,
+                    intptr_t** ret_sp, intptr_t** ret_fp) {
+
+  ExtendedPC  epc;
+  ucontext_t* uc = (ucontext_t*)ucVoid;
+
+  if (uc != NULL) {
+    epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));
+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
+  } else {
+    // construct empty ExtendedPC for return value checking
+    epc = ExtendedPC(NULL);
+    if (ret_sp) *ret_sp = (intptr_t *)NULL;
+    if (ret_fp) *ret_fp = (intptr_t *)NULL;
+  }
+
+  return epc;
+}
+
+frame os::fetch_frame_from_context(void* ucVoid) {
+  intptr_t* sp;
+  intptr_t* fp;
+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);
+  return frame(sp, epc.pc());
+}
+
+frame os::get_sender_for_C_frame(frame* fr) {
+  if (*fr->sp() == 0) {
+    // fr is the last C frame
+    return frame(NULL, NULL);
+  }
+  return frame(fr->sender_sp(), fr->sender_pc());
+}
+
+
+frame os::current_frame() {
+  intptr_t* csp = (intptr_t*) *((intptr_t*) os::current_stack_pointer());
+  // hack.
+  frame topframe(csp, (address)0x8);
+  // return sender of current topframe which hopefully has pc != NULL.
+  return os::get_sender_for_C_frame(&topframe);
+}
+
+// Utility functions
+
+extern "C" JNIEXPORT int
+JVM_handle_bsd_signal(int sig, siginfo_t* info, void* ucVoid, int abort_if_unrecognized) {
+
+  ucontext_t* uc = (ucontext_t*) ucVoid;
+
+  Thread* t = ThreadLocalStorage::get_thread_slow();   // slow & steady
+
+  SignalHandlerMark shm(t);
+
+  // Note: it's not uncommon that JNI code uses signal/sigset to install
+  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
+  // or have a SIGILL handler when detecting CPU type). When that happens,
+  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
+  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
+  // that do not require siginfo/ucontext first.
+
+  if (sig == SIGPIPE) {
+    if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+      return 1;
+    } else {
+      if (PrintMiscellaneous && (WizardMode || Verbose)) {
+        warning("Ignoring SIGPIPE - see bug 4229104");
+      }
+      return 1;
+    }
+  }
+
+  JavaThread* thread = NULL;
+  VMThread* vmthread = NULL;
+  if (os::Bsd::signal_handlers_are_installed) {
+    if (t != NULL) {
+      if(t->is_Java_thread()) {
+        thread = (JavaThread*)t;
+      }
+      else if(t->is_VM_thread()) {
+        vmthread = (VMThread *)t;
+      }
+    }
+  }
+
+  // Decide if this trap can be handled by a stub.
+  address stub = NULL;
+
+  // retrieve program counter
+  address const pc = uc ? os::Bsd::ucontext_get_pc(uc) : NULL;
+
+  // retrieve crash address
+  address const addr = info ? (const address) info->si_addr : NULL;
+
+  // SafeFetch 32 handling:
+  // - make it work if _thread is null
+  // - make it use the standard os::...::ucontext_get/set_pc APIs
+  if (uc) {
+    address const pc = os::Bsd::ucontext_get_pc(uc);
+    if (pc && StubRoutines::is_safefetch_fault(pc)) {
+      uc->uc_mcontext.mc_srr0 = (unsigned long)StubRoutines::continuation_for_safefetch_fault(pc);
+      return true;
+    }
+  }
+
+  // Handle SIGDANGER right away. AIX would raise SIGDANGER whenever available swap
+  // space falls below 30%. This is only a chance for the process to gracefully abort.
+  // We can't hope to proceed after SIGDANGER since SIGKILL tailgates.
+  // if (sig == SIGDANGER) {
+  //  goto report_and_die;
+  // }
+
+  if (info == NULL || uc == NULL || thread == NULL && vmthread == NULL) {
+    goto run_chained_handler;
+  }
+
+  // If we are a java thread...
+  if (thread != NULL) {
+
+    // Handle ALL stack overflow variations here
+    if (sig == SIGSEGV && (addr < thread->stack_base() &&
+                           addr >= thread->stack_base() - thread->stack_size())) {
+      // stack overflow
+      //
+      // If we are in a yellow zone and we are inside java, we disable the yellow zone and
+      // throw a stack overflow exception.
+      // If we are in native code or VM C code, we report-and-die. The original coding tried
+      // to continue with yellow zone disabled, but that doesn't buy us much and prevents
+      // hs_err_pid files.
+      if (thread->in_stack_yellow_zone(addr)) {
+        thread->disable_stack_yellow_zone();
+        if (thread->thread_state() == _thread_in_Java) {
+          // Throw a stack overflow exception.
+          // Guard pages will be reenabled while unwinding the stack.
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
+          goto run_stub;
+        } else {
+          // Thread was in the vm or native code. Return and try to finish.
+          return 1;
+        }
+      } else if (thread->in_stack_red_zone(addr)) {
+        // Fatal red zone violation. Disable the guard pages and fall through
+        // to handle_unexpected_exception way down below.
+        thread->disable_stack_red_zone();
+        tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+        goto report_and_die;
+      } else {
+        // This means a segv happened inside our stack, but not in
+        // the guarded zone. I'd like to know when this happens,
+        tty->print_raw_cr("SIGSEGV happened inside stack but outside yellow and red zone.");
+        goto report_and_die;
+      }
+
+    } // end handle SIGSEGV inside stack boundaries
+
+    if (thread->thread_state() == _thread_in_Java) {
+      // Java thread running in Java code
+
+      // The following signals are used for communicating VM events:
+      //
+      // SIGILL: the compiler generates illegal opcodes
+      //   at places where it wishes to interrupt the VM:
+      //   Safepoints, Unreachable Code, Entry points of Zombie methods,
+      //    This results in a SIGILL with (*pc) == inserted illegal instruction.
+      //
+      //   (so, SIGILLs with a pc inside the zero page are real errors)
+      //
+      // SIGTRAP:
+      //   The ppc trap instruction raises a SIGTRAP and is very efficient if it
+      //   does not trap. It is used for conditional branches that are expected
+      //   to be never taken. These are:
+      //     - zombie methods
+      //     - IC (inline cache) misses.
+      //     - null checks leading to UncommonTraps.
+      //     - range checks leading to Uncommon Traps.
+      //   On Bsd, these are especially null checks, as the ImplicitNullCheck
+      //   optimization works only in rare cases, as the page at address 0 is only
+      //   write protected.      //
+      //   Note: !UseSIGTRAP is used to prevent SIGTRAPS altogether, to facilitate debugging.
+      //
+      // SIGSEGV:
+      //   used for safe point polling:
+      //     To notify all threads that they have to reach a safe point, safe point polling is used:
+      //     All threads poll a certain mapped memory page. Normally, this page has read access.
+      //     If the VM wants to inform the threads about impending safe points, it puts this
+      //     page to read only ("poisens" the page), and the threads then reach a safe point.
+      //   used for null checks:
+      //     If the compiler finds a store it uses it for a null check. Unfortunately this
+      //     happens rarely.  In heap based and disjoint base compressd oop modes also loads
+      //     are used for null checks.
+
+      // A VM-related SIGILL may only occur if we are not in the zero page.
+      // On AIX, we get a SIGILL if we jump to 0x0 or to somewhere else
+      // in the zero page, because it is filled with 0x0. We ignore
+      // explicit SIGILLs in the zero page.
+      if (sig == SIGILL && (pc < (address) 0x200)) {
+        if (TraceTraps) {
+          tty->print_raw_cr("SIGILL happened inside zero page.");
+        }
+        goto report_and_die;
+      }
+
+      // Handle signal from NativeJump::patch_verified_entry().
+      if (( TrapBasedNotEntrantChecks && sig == SIGTRAP && nativeInstruction_at(pc)->is_sigtrap_zombie_not_entrant()) ||
+          (!TrapBasedNotEntrantChecks && sig == SIGILL  && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant())) {
+        if (TraceTraps) {
+          tty->print_cr("trap: zombie_not_entrant (%s)", (sig == SIGTRAP) ? "SIGTRAP" : "SIGILL");
+        }
+        stub = SharedRuntime::get_handle_wrong_method_stub();
+        goto run_stub;
+      }
+
+      else if (sig == SIGSEGV && os::is_poll_address(addr)) {
+        if (TraceTraps) {
+          tty->print_cr("trap: safepoint_poll at " INTPTR_FORMAT " (SIGSEGV)", pc);
+        }
+        stub = SharedRuntime::get_poll_stub(pc);
+        goto run_stub;
+      }
+
+      // SIGTRAP-based ic miss check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedICMissChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_ic_miss_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: ic_miss_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::get_ic_miss_stub();
+        goto run_stub;
+      }
+
+      // SIGTRAP-based implicit null check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedNullChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_null_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: null_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+        goto run_stub;
+      }
+
+      // SIGSEGV-based implicit null check in compiled code.
+      else if (sig == SIGSEGV && ImplicitNullChecks &&
+               CodeCache::contains((void*) pc) &&
+               !MacroAssembler::needs_explicit_null_check((intptr_t) info->si_addr)) {
+        if (TraceTraps) {
+          tty->print_cr("trap: null_check at " INTPTR_FORMAT " (SIGSEGV)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+      }
+
+#ifdef COMPILER2
+      // SIGTRAP-based implicit range check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedRangeChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_range_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: range_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+        goto run_stub;
+      }
+#endif
+
+      else if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
+        if (TraceTraps) {
+          tty->print_raw_cr("Fix SIGFPE handler, trying divide by zero handler.");
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
+        goto run_stub;
+      }
+
+      else if (sig == SIGBUS) {
+        // BugId 4454115: A read from a MappedByteBuffer can fault here if the
+        // underlying file has been truncated. Do not crash the VM in such a case.
+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
+        nmethod* nm = cb->is_nmethod() ? (nmethod*)cb : NULL;
+        if (nm != NULL && nm->has_unsafe_access()) {
+          // We don't really need a stub here! Just set the pending exeption and
+          // continue at the next instruction after the faulting read. Returning
+          // garbage from this read is ok.
+          thread->set_pending_unsafe_access_error();
+          uc->uc_mcontext.mc_srr0 = ((unsigned long)pc) + 4;
+          return 1;
+        }
+      }
+    }
+
+    else { // thread->thread_state() != _thread_in_Java
+      // Detect CPU features. This is only done at the very start of the VM. Later, the
+      // VM_Version::is_determine_features_test_running() flag should be false.
+
+      if (sig == SIGILL && VM_Version::is_determine_features_test_running()) {
+        // SIGILL must be caused by VM_Version::determine_features().
+        *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
+                        // flushing of icache is not necessary.
+        stub = pc + 4;  // continue with next instruction.
+        goto run_stub;
+      }
+      else if (thread->thread_state() == _thread_in_vm &&
+               sig == SIGBUS && thread->doing_unsafe_access()) {
+        // We don't really need a stub here! Just set the pending exeption and
+        // continue at the next instruction after the faulting read. Returning
+        // garbage from this read is ok.
+        thread->set_pending_unsafe_access_error();
+        uc->uc_mcontext.mc_srr0 = ((unsigned long)pc) + 4;
+        return 1;
+      }
+    }
+
+    // Check to see if we caught the safepoint code in the
+    // process of write protecting the memory serialization page.
+    // It write enables the page immediately after protecting it
+    // so we can just return to retry the write.
+    if ((sig == SIGSEGV) &&
+        os::is_memory_serialize_page(thread, addr)) {
+      // Synchronization problem in the pseudo memory barrier code (bug id 6546278)
+      // Block current thread until the memory serialize page permission restored.
+      os::block_on_serialize_page_trap();
+      return true;
+    }
+  }
+
+run_stub:
+
+  // One of the above code blocks ininitalized the stub, so we want to
+  // delegate control to that stub.
+  if (stub != NULL) {
+    // Save all thread context in case we need to restore it.
+    if (thread != NULL) thread->set_saved_exception_pc(pc);
+    uc->uc_mcontext.mc_srr0 = (unsigned long)stub;
+    return 1;
+  }
+
+run_chained_handler:
+
+  // signal-chaining
+  if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+    return 1;
+  }
+  if (!abort_if_unrecognized) {
+    // caller wants another chance, so give it to him
+    return 0;
+  }
+
+report_and_die:
+
+  // Use sigthreadmask instead of sigprocmask on AIX and unmask current signal.
+  sigset_t newset;
+  sigemptyset(&newset);
+  sigaddset(&newset, sig);
+  sigprocmask(SIG_UNBLOCK, &newset, NULL);
+
+  VMError err(t, sig, pc, info, ucVoid);
+  err.report_and_die();
+
+  ShouldNotReachHere();
+  return 0;
+}
+
+void os::Bsd::init_thread_fpu_state(void) {
+  // Disable FP exceptions.
+  __asm__ __volatile__ ("mtfsfi 6,0");
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// thread stack
+
+size_t os::Bsd::min_stack_allowed = 128*K;
+
+bool os::Bsd::supports_variable_stack_size() { return true; }
+
+// return default stack size for thr_type
+size_t os::Bsd::default_stack_size(os::ThreadType thr_type) {
+  // default stack size (compiler thread needs larger stack)
+  // Notice that the setting for compiler threads here have no impact
+  // because of the strange 'fallback logic' in os::create_thread().
+  // Better set CompilerThreadStackSize in globals_<os_cpu>.hpp if you want to
+  // specify a different stack size for compiler threads!
+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1024 * K);
+  return s;
+}
+
+size_t os::Bsd::default_guard_size(os::ThreadType thr_type) {
+  return 2 * page_size();
+}
+
+// Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\  JavaThread created by VM does not have glibc
+//    |    glibc guard page    | - guard, attached Java thread usually has
+//    |                        |/  1 page glibc guard.
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |  HotSpot Guard Pages   | - red and yellow pages
+//    |                        |/
+//    +------------------------+ JavaThread::stack_yellow_zone_base()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// Non-Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\
+//    |  glibc guard page      | - usually 1 page
+//    |                        |/
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
+//    pthread_attr_getstack()
+
+static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  // workaround for OS X 10.9.0 (Mavericks)
+  // pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages
+  if (pthread_main_np() == 1) {
+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {
+      char kern_osrelease[256];
+      size_t kern_osrelease_size = sizeof(kern_osrelease);
+      int ret = sysctlbyname("kern.osrelease", kern_osrelease, &kern_osrelease_size, NULL, 0);
+      if (ret == 0) {
+        // get the major number, atoi will ignore the minor amd micro portions of the version string
+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {
+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());
+        }
+      }
+    }
+  }
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_stackseg_np failed with err = %d", rslt));
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#else
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_init failed with err = %d", rslt));
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_get_np failed with err = %d", rslt));
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#endif
+  assert(os::current_stack_pointer() >= *bottom &&
+         os::current_stack_pointer() < *bottom + *size, "just checking");
+}
+
+address os::current_stack_base() {
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return (bottom + size);
+}
+
+size_t os::current_stack_size() {
+  // stack size includes normal stack and HotSpot guard pages
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// helper functions for fatal error handler
+
+void os::print_context(outputStream *st, void *context) {
+  if (context == NULL) return;
+
+  ucontext_t* uc = (ucontext_t*)context;
+
+  st->print_cr("Registers:");
+  st->print("pc =" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_srr0);
+  st->print("lr =" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_lr);
+  st->print("ctr=" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_ctr);
+  st->cr();
+  for (int i = 0; i < 32; i++) {
+    st->print("r%-2d=" INTPTR_FORMAT "  ", i, uc->uc_mcontext.mc_gpr[i]);
+    if (i % 3 == 2) st->cr();
+  }
+  st->cr();
+  st->cr();
+
+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);
+  st->print_cr("Top of Stack: (sp=" PTR_FORMAT ")", p2i(sp));
+  print_hex_dump(st, (address)sp, (address)(sp + 128), sizeof(intptr_t));
+  st->cr();
+
+  // Note: it may be unsafe to inspect memory near pc. For example, pc may
+  // point to garbage if entry point in an nmethod is corrupted. Leave
+  // this at the end, and hope for the best.
+  address pc = os::Bsd::ucontext_get_pc(uc);
+  st->print_cr("Instructions: (pc=" PTR_FORMAT ")", p2i(pc));
+  print_hex_dump(st, pc - 64, pc + 64, /*instrsize=*/4);
+  st->cr();
+}
+
+void os::print_register_info(outputStream *st, void *context) {
+  if (context == NULL) return;
+
+  ucontext_t *uc = (ucontext_t*)context;
+
+  st->print_cr("Register to memory mapping:");
+  st->cr();
+
+  // this is only for the "general purpose" registers
+  for (int i = 0; i < 32; i++) {
+    st->print("r%-2d=", i);
+    print_location(st, uc->uc_mcontext.mc_gpr[i]);
+  }
+  st->cr();
+}
+
+extern "C" {
+  int SpinPause() {
+    return 0;
+  }
+}
+
+#ifndef PRODUCT
+void os::verify_stack_alignment() {
+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, "incorrect stack alignment");
+}
+#endif
+/*
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// no precompiled headers
+#include "assembler_ppc.inline.hpp"
+#include "classfile/classLoader.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/vmSymbols.hpp"
+#include "code/icBuffer.hpp"
+#include "code/vtableStubs.hpp"
+#include "interpreter/interpreter.hpp"
+#include "jvm_bsd.h"
+#include "memory/allocation.inline.hpp"
+#include "mutex_bsd.inline.hpp"
+#include "nativeInst_ppc.hpp"
+#include "os_share_bsd.hpp"
+#include "prims/jniFastGetField.hpp"
+#include "prims/jvm.h"
+#include "prims/jvm_misc.hpp"
+#include "runtime/arguments.hpp"
+#include "runtime/extendedPC.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/interfaceSupport.hpp"
+#include "runtime/java.hpp"
+#include "runtime/javaCalls.hpp"
+#include "runtime/mutexLocker.hpp"
+#include "runtime/osThread.hpp"
+#include "runtime/sharedRuntime.hpp"
+#include "runtime/stubRoutines.hpp"
+#include "runtime/thread.inline.hpp"
+#include "runtime/timer.hpp"
+#include "utilities/events.hpp"
+#include "utilities/vmError.hpp"
+#ifdef COMPILER1
+#include "c1/c1_Runtime1.hpp"
+#endif
+#ifdef COMPILER2
+#include "opto/runtime.hpp"
+#endif
+
+// put OS-includes here
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <pthread.h>
+# include <signal.h>
+# include <errno.h>
+# include <dlfcn.h>
+# include <stdlib.h>
+# include <stdio.h>
+# include <unistd.h>
+# include <sys/resource.h>
+# include <pthread_np.h>
+# include <sys/stat.h>
+# include <sys/time.h>
+# include <sys/utsname.h>
+# include <sys/socket.h>
+# include <sys/wait.h>
+# include <pwd.h>
+# include <poll.h>
+# include <ucontext.h>
+
+
+address os::current_stack_pointer() {
+  intptr_t* csp;
+
+  // inline assembly `mr regno(csp), R1_SP':
+  __asm__ __volatile__ ("mr %0, 1":"=r"(csp):);
+
+  return (address) csp;
+}
+
+char* os::non_memory_address_word() {
+  // Must never look like an address returned by reserve_memory,
+  // even in its subfields (as defined by the CPU immediate fields,
+  // if the CPU splits constants across multiple instructions).
+
+  return (char*) -1;
+}
+
+void os::initialize_thread(Thread *thread) { }
+
+address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
+  guarantee(uc->uc_mcontext.mc_gpr != NULL, "only use ucontext_get_pc in sigaction context");
+  return (address)uc->uc_mcontext.mc_srr0;
+}
+
+intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
+  return (intptr_t*)uc->uc_mcontext.mc_gpr[1/*REG_SP*/];
+}
+
+intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
+  return NULL;
+}
+
+ExtendedPC os::fetch_frame_from_context(void* ucVoid,
+                    intptr_t** ret_sp, intptr_t** ret_fp) {
+
+  ExtendedPC  epc;
+  ucontext_t* uc = (ucontext_t*)ucVoid;
+
+  if (uc != NULL) {
+    epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));
+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
+  } else {
+    // construct empty ExtendedPC for return value checking
+    epc = ExtendedPC(NULL);
+    if (ret_sp) *ret_sp = (intptr_t *)NULL;
+    if (ret_fp) *ret_fp = (intptr_t *)NULL;
+  }
+
+  return epc;
+}
+
+frame os::fetch_frame_from_context(void* ucVoid) {
+  intptr_t* sp;
+  intptr_t* fp;
+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);
+  return frame(sp, epc.pc());
+}
+
+frame os::get_sender_for_C_frame(frame* fr) {
+  if (*fr->sp() == 0) {
+    // fr is the last C frame
+    return frame(NULL, NULL);
+  }
+  return frame(fr->sender_sp(), fr->sender_pc());
+}
+
+
+frame os::current_frame() {
+  intptr_t* csp = (intptr_t*) *((intptr_t*) os::current_stack_pointer());
+  // hack.
+  frame topframe(csp, (address)0x8);
+  // return sender of current topframe which hopefully has pc != NULL.
+  return os::get_sender_for_C_frame(&topframe);
+}
+
+// Utility functions
+
+extern "C" JNIEXPORT int
+JVM_handle_bsd_signal(int sig, siginfo_t* info, void* ucVoid, int abort_if_unrecognized) {
+
+  ucontext_t* uc = (ucontext_t*) ucVoid;
+
+  Thread* t = ThreadLocalStorage::get_thread_slow();   // slow & steady
+
+  SignalHandlerMark shm(t);
+
+  // Note: it's not uncommon that JNI code uses signal/sigset to install
+  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
+  // or have a SIGILL handler when detecting CPU type). When that happens,
+  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
+  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
+  // that do not require siginfo/ucontext first.
+
+  if (sig == SIGPIPE) {
+    if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+      return 1;
+    } else {
+      if (PrintMiscellaneous && (WizardMode || Verbose)) {
+        warning("Ignoring SIGPIPE - see bug 4229104");
+      }
+      return 1;
+    }
+  }
+
+  JavaThread* thread = NULL;
+  VMThread* vmthread = NULL;
+  if (os::Bsd::signal_handlers_are_installed) {
+    if (t != NULL) {
+      if(t->is_Java_thread()) {
+        thread = (JavaThread*)t;
+      }
+      else if(t->is_VM_thread()) {
+        vmthread = (VMThread *)t;
+      }
+    }
+  }
+
+  // Decide if this trap can be handled by a stub.
+  address stub = NULL;
+
+  // retrieve program counter
+  address const pc = uc ? os::Bsd::ucontext_get_pc(uc) : NULL;
+
+  // retrieve crash address
+  address const addr = info ? (const address) info->si_addr : NULL;
+
+  // SafeFetch 32 handling:
+  // - make it work if _thread is null
+  // - make it use the standard os::...::ucontext_get/set_pc APIs
+  if (uc) {
+    address const pc = os::Bsd::ucontext_get_pc(uc);
+    if (pc && StubRoutines::is_safefetch_fault(pc)) {
+      uc->uc_mcontext.mc_srr0 = (unsigned long)StubRoutines::continuation_for_safefetch_fault(pc);
+      return true;
+    }
+  }
+
+  // Handle SIGDANGER right away. AIX would raise SIGDANGER whenever available swap
+  // space falls below 30%. This is only a chance for the process to gracefully abort.
+  // We can't hope to proceed after SIGDANGER since SIGKILL tailgates.
+  // if (sig == SIGDANGER) {
+  //  goto report_and_die;
+  // }
+
+  if (info == NULL || uc == NULL || thread == NULL && vmthread == NULL) {
+    goto run_chained_handler;
+  }
+
+  // If we are a java thread...
+  if (thread != NULL) {
+
+    // Handle ALL stack overflow variations here
+    if (sig == SIGSEGV && (addr < thread->stack_base() &&
+                           addr >= thread->stack_base() - thread->stack_size())) {
+      // stack overflow
+      //
+      // If we are in a yellow zone and we are inside java, we disable the yellow zone and
+      // throw a stack overflow exception.
+      // If we are in native code or VM C code, we report-and-die. The original coding tried
+      // to continue with yellow zone disabled, but that doesn't buy us much and prevents
+      // hs_err_pid files.
+      if (thread->in_stack_yellow_zone(addr)) {
+        thread->disable_stack_yellow_zone();
+        if (thread->thread_state() == _thread_in_Java) {
+          // Throw a stack overflow exception.
+          // Guard pages will be reenabled while unwinding the stack.
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
+          goto run_stub;
+        } else {
+          // Thread was in the vm or native code. Return and try to finish.
+          return 1;
+        }
+      } else if (thread->in_stack_red_zone(addr)) {
+        // Fatal red zone violation. Disable the guard pages and fall through
+        // to handle_unexpected_exception way down below.
+        thread->disable_stack_red_zone();
+        tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+        goto report_and_die;
+      } else {
+        // This means a segv happened inside our stack, but not in
+        // the guarded zone. I'd like to know when this happens,
+        tty->print_raw_cr("SIGSEGV happened inside stack but outside yellow and red zone.");
+        goto report_and_die;
+      }
+
+    } // end handle SIGSEGV inside stack boundaries
+
+    if (thread->thread_state() == _thread_in_Java) {
+      // Java thread running in Java code
+
+      // The following signals are used for communicating VM events:
+      //
+      // SIGILL: the compiler generates illegal opcodes
+      //   at places where it wishes to interrupt the VM:
+      //   Safepoints, Unreachable Code, Entry points of Zombie methods,
+      //    This results in a SIGILL with (*pc) == inserted illegal instruction.
+      //
+      //   (so, SIGILLs with a pc inside the zero page are real errors)
+      //
+      // SIGTRAP:
+      //   The ppc trap instruction raises a SIGTRAP and is very efficient if it
+      //   does not trap. It is used for conditional branches that are expected
+      //   to be never taken. These are:
+      //     - zombie methods
+      //     - IC (inline cache) misses.
+      //     - null checks leading to UncommonTraps.
+      //     - range checks leading to Uncommon Traps.
+      //   On Bsd, these are especially null checks, as the ImplicitNullCheck
+      //   optimization works only in rare cases, as the page at address 0 is only
+      //   write protected.      //
+      //   Note: !UseSIGTRAP is used to prevent SIGTRAPS altogether, to facilitate debugging.
+      //
+      // SIGSEGV:
+      //   used for safe point polling:
+      //     To notify all threads that they have to reach a safe point, safe point polling is used:
+      //     All threads poll a certain mapped memory page. Normally, this page has read access.
+      //     If the VM wants to inform the threads about impending safe points, it puts this
+      //     page to read only ("poisens" the page), and the threads then reach a safe point.
+      //   used for null checks:
+      //     If the compiler finds a store it uses it for a null check. Unfortunately this
+      //     happens rarely.  In heap based and disjoint base compressd oop modes also loads
+      //     are used for null checks.
+
+      // A VM-related SIGILL may only occur if we are not in the zero page.
+      // On AIX, we get a SIGILL if we jump to 0x0 or to somewhere else
+      // in the zero page, because it is filled with 0x0. We ignore
+      // explicit SIGILLs in the zero page.
+      if (sig == SIGILL && (pc < (address) 0x200)) {
+        if (TraceTraps) {
+          tty->print_raw_cr("SIGILL happened inside zero page.");
+        }
+        goto report_and_die;
+      }
+
+      // Handle signal from NativeJump::patch_verified_entry().
+      if (( TrapBasedNotEntrantChecks && sig == SIGTRAP && nativeInstruction_at(pc)->is_sigtrap_zombie_not_entrant()) ||
+          (!TrapBasedNotEntrantChecks && sig == SIGILL  && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant())) {
+        if (TraceTraps) {
+          tty->print_cr("trap: zombie_not_entrant (%s)", (sig == SIGTRAP) ? "SIGTRAP" : "SIGILL");
+        }
+        stub = SharedRuntime::get_handle_wrong_method_stub();
+        goto run_stub;
+      }
+
+      else if (sig == SIGSEGV && os::is_poll_address(addr)) {
+        if (TraceTraps) {
+          tty->print_cr("trap: safepoint_poll at " INTPTR_FORMAT " (SIGSEGV)", pc);
+        }
+        stub = SharedRuntime::get_poll_stub(pc);
+        goto run_stub;
+      }
+
+      // SIGTRAP-based ic miss check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedICMissChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_ic_miss_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: ic_miss_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::get_ic_miss_stub();
+        goto run_stub;
+      }
+
+      // SIGTRAP-based implicit null check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedNullChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_null_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: null_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+        goto run_stub;
+      }
+
+      // SIGSEGV-based implicit null check in compiled code.
+      else if (sig == SIGSEGV && ImplicitNullChecks &&
+               CodeCache::contains((void*) pc) &&
+               !MacroAssembler::needs_explicit_null_check((intptr_t) info->si_addr)) {
+        if (TraceTraps) {
+          tty->print_cr("trap: null_check at " INTPTR_FORMAT " (SIGSEGV)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+      }
+
+#ifdef COMPILER2
+      // SIGTRAP-based implicit range check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedRangeChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_range_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: range_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+        goto run_stub;
+      }
+#endif
+
+      else if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
+        if (TraceTraps) {
+          tty->print_raw_cr("Fix SIGFPE handler, trying divide by zero handler.");
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
+        goto run_stub;
+      }
+
+      else if (sig == SIGBUS) {
+        // BugId 4454115: A read from a MappedByteBuffer can fault here if the
+        // underlying file has been truncated. Do not crash the VM in such a case.
+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
+        nmethod* nm = cb->is_nmethod() ? (nmethod*)cb : NULL;
+        if (nm != NULL && nm->has_unsafe_access()) {
+          // We don't really need a stub here! Just set the pending exeption and
+          // continue at the next instruction after the faulting read. Returning
+          // garbage from this read is ok.
+          thread->set_pending_unsafe_access_error();
+          uc->uc_mcontext.mc_srr0 = ((unsigned long)pc) + 4;
+          return 1;
+        }
+      }
+    }
+
+    else { // thread->thread_state() != _thread_in_Java
+      // Detect CPU features. This is only done at the very start of the VM. Later, the
+      // VM_Version::is_determine_features_test_running() flag should be false.
+
+      if (sig == SIGILL && VM_Version::is_determine_features_test_running()) {
+        // SIGILL must be caused by VM_Version::determine_features().
+        *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
+                        // flushing of icache is not necessary.
+        stub = pc + 4;  // continue with next instruction.
+        goto run_stub;
+      }
+      else if (thread->thread_state() == _thread_in_vm &&
+               sig == SIGBUS && thread->doing_unsafe_access()) {
+        // We don't really need a stub here! Just set the pending exeption and
+        // continue at the next instruction after the faulting read. Returning
+        // garbage from this read is ok.
+        thread->set_pending_unsafe_access_error();
+        uc->uc_mcontext.mc_srr0 = ((unsigned long)pc) + 4;
+        return 1;
+      }
+    }
+
+    // Check to see if we caught the safepoint code in the
+    // process of write protecting the memory serialization page.
+    // It write enables the page immediately after protecting it
+    // so we can just return to retry the write.
+    if ((sig == SIGSEGV) &&
+        os::is_memory_serialize_page(thread, addr)) {
+      // Synchronization problem in the pseudo memory barrier code (bug id 6546278)
+      // Block current thread until the memory serialize page permission restored.
+      os::block_on_serialize_page_trap();
+      return true;
+    }
+  }
+
+run_stub:
+
+  // One of the above code blocks ininitalized the stub, so we want to
+  // delegate control to that stub.
+  if (stub != NULL) {
+    // Save all thread context in case we need to restore it.
+    if (thread != NULL) thread->set_saved_exception_pc(pc);
+    uc->uc_mcontext.mc_srr0 = (unsigned long)stub;
+    return 1;
+  }
+
+run_chained_handler:
+
+  // signal-chaining
+  if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+    return 1;
+  }
+  if (!abort_if_unrecognized) {
+    // caller wants another chance, so give it to him
+    return 0;
+  }
+
+report_and_die:
+
+  // Use sigthreadmask instead of sigprocmask on AIX and unmask current signal.
+  sigset_t newset;
+  sigemptyset(&newset);
+  sigaddset(&newset, sig);
+  sigprocmask(SIG_UNBLOCK, &newset, NULL);
+
+  VMError err(t, sig, pc, info, ucVoid);
+  err.report_and_die();
+
+  ShouldNotReachHere();
+  return 0;
+}
+
+void os::Bsd::init_thread_fpu_state(void) {
+  // Disable FP exceptions.
+  __asm__ __volatile__ ("mtfsfi 6,0");
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// thread stack
+
+size_t os::Bsd::min_stack_allowed = 128*K;
+
+bool os::Bsd::supports_variable_stack_size() { return true; }
+
+// return default stack size for thr_type
+size_t os::Bsd::default_stack_size(os::ThreadType thr_type) {
+  // default stack size (compiler thread needs larger stack)
+  // Notice that the setting for compiler threads here have no impact
+  // because of the strange 'fallback logic' in os::create_thread().
+  // Better set CompilerThreadStackSize in globals_<os_cpu>.hpp if you want to
+  // specify a different stack size for compiler threads!
+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1024 * K);
+  return s;
+}
+
+size_t os::Bsd::default_guard_size(os::ThreadType thr_type) {
+  return 2 * page_size();
+}
+
+// Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\  JavaThread created by VM does not have glibc
+//    |    glibc guard page    | - guard, attached Java thread usually has
+//    |                        |/  1 page glibc guard.
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |  HotSpot Guard Pages   | - red and yellow pages
+//    |                        |/
+//    +------------------------+ JavaThread::stack_yellow_zone_base()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// Non-Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\
+//    |  glibc guard page      | - usually 1 page
+//    |                        |/
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
+//    pthread_attr_getstack()
+
+static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  // workaround for OS X 10.9.0 (Mavericks)
+  // pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages
+  if (pthread_main_np() == 1) {
+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {
+      char kern_osrelease[256];
+      size_t kern_osrelease_size = sizeof(kern_osrelease);
+      int ret = sysctlbyname("kern.osrelease", kern_osrelease, &kern_osrelease_size, NULL, 0);
+      if (ret == 0) {
+        // get the major number, atoi will ignore the minor amd micro portions of the version string
+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {
+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());
+        }
+      }
+    }
+  }
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_stackseg_np failed with err = %d", rslt));
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#else
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_init failed with err = %d", rslt));
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_get_np failed with err = %d", rslt));
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#endif
+  assert(os::current_stack_pointer() >= *bottom &&
+         os::current_stack_pointer() < *bottom + *size, "just checking");
+}
+
+address os::current_stack_base() {
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return (bottom + size);
+}
+
+size_t os::current_stack_size() {
+  // stack size includes normal stack and HotSpot guard pages
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// helper functions for fatal error handler
+
+void os::print_context(outputStream *st, void *context) {
+  if (context == NULL) return;
+
+  ucontext_t* uc = (ucontext_t*)context;
+
+  st->print_cr("Registers:");
+  st->print("pc =" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_srr0);
+  st->print("lr =" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_lr);
+  st->print("ctr=" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_ctr);
+  st->cr();
+  for (int i = 0; i < 32; i++) {
+    st->print("r%-2d=" INTPTR_FORMAT "  ", i, uc->uc_mcontext.mc_gpr[i]);
+    if (i % 3 == 2) st->cr();
+  }
+  st->cr();
+  st->cr();
+
+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);
+  st->print_cr("Top of Stack: (sp=" PTR_FORMAT ")", p2i(sp));
+  print_hex_dump(st, (address)sp, (address)(sp + 128), sizeof(intptr_t));
+  st->cr();
+
+  // Note: it may be unsafe to inspect memory near pc. For example, pc may
+  // point to garbage if entry point in an nmethod is corrupted. Leave
+  // this at the end, and hope for the best.
+  address pc = os::Bsd::ucontext_get_pc(uc);
+  st->print_cr("Instructions: (pc=" PTR_FORMAT ")", p2i(pc));
+  print_hex_dump(st, pc - 64, pc + 64, /*instrsize=*/4);
+  st->cr();
+}
+
+void os::print_register_info(outputStream *st, void *context) {
+  if (context == NULL) return;
+
+  ucontext_t *uc = (ucontext_t*)context;
+
+  st->print_cr("Register to memory mapping:");
+  st->cr();
+
+  // this is only for the "general purpose" registers
+  for (int i = 0; i < 32; i++) {
+    st->print("r%-2d=", i);
+    print_location(st, uc->uc_mcontext.mc_gpr[i]);
+  }
+  st->cr();
+}
+
+extern "C" {
+  int SpinPause() {
+    return 0;
+  }
+}
+
+#ifndef PRODUCT
+void os::verify_stack_alignment() {
+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, "incorrect stack alignment");
+}
+#endif
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/os_bsd_ppc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+
+  static void setup_fpu() {}
+
+  // Used to register dynamic code cache area with the OS
+  // Note: Currently only used in 64 bit Windows implementations
+  static bool register_code_area(char *low, char *high) { return true; }
+
+#endif // OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+
+  static void setup_fpu() {}
+
+  // Used to register dynamic code cache area with the OS
+  // Note: Currently only used in 64 bit Windows implementations
+  static bool register_code_area(char *low, char *high) { return true; }
+
+#endif // OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/prefetch_bsd_ppc.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+
+#include "runtime/prefetch.hpp"
+
+
+inline void Prefetch::read(void *loc, intx interval) {
+  __asm__ __volatile__ (
+    "   dcbt   0, %0       \n"
+    :
+    : /*%0*/"r" ( ((address)loc) +((long)interval) )
+    //:
+    );
+}
+
+inline void Prefetch::write(void *loc, intx interval) {
+  __asm__ __volatile__ (
+    "   dcbtst 0, %0       \n"
+    :
+    : /*%0*/"r" ( ((address)loc) +((long)interval) )
+    //:
+    );
+}
+
+#endif // OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+
+#include "runtime/prefetch.hpp"
+
+
+inline void Prefetch::read(void *loc, intx interval) {
+  __asm__ __volatile__ (
+    "   dcbt   0, %0       \n"
+    :
+    : /*%0*/"r" ( ((address)loc) +((long)interval) )
+    //:
+    );
+}
+
+inline void Prefetch::write(void *loc, intx interval) {
+  __asm__ __volatile__ (
+    "   dcbtst 0, %0       \n"
+    :
+    : /*%0*/"r" ( ((address)loc) +((long)interval) )
+    //:
+    );
+}
+
+#endif // OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/threadLS_bsd_ppc.cpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/threadLocalStorage.hpp"
+
+void ThreadLocalStorage::generate_code_for_get_thread() {
+    // nothing we can do here for user-level thread
+}
+
+void ThreadLocalStorage::pd_init() {
+  // Nothing to do
+}
+
+void ThreadLocalStorage::pd_set_thread(Thread* thread) {
+  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);
+}
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/threadLocalStorage.hpp"
+
+void ThreadLocalStorage::generate_code_for_get_thread() {
+    // nothing we can do here for user-level thread
+}
+
+void ThreadLocalStorage::pd_init() {
+  // Nothing to do
+}
+
+void ThreadLocalStorage::pd_set_thread(Thread* thread) {
+  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/threadLS_bsd_ppc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+
+  // Processor dependent parts of ThreadLocalStorage
+
+public:
+  static Thread* thread() {
+    return (Thread *) os::thread_local_storage_at(thread_index());
+  }
+
+#endif // OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+
+  // Processor dependent parts of ThreadLocalStorage
+
+public:
+  static Thread* thread() {
+    return (Thread *) os::thread_local_storage_at(thread_index());
+  }
+
+#endif // OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/thread_bsd_ppc.cpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2014 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/frame.hpp"
+#include "runtime/thread.hpp"
+
+// Forte Analyzer AsyncGetCallTrace profiling support is not implemented on Bsd/PPC.
+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava) {
+  Unimplemented();
+  return false;
+}
+
+void JavaThread::cache_global_variables() { }
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2014 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/frame.hpp"
+#include "runtime/thread.hpp"
+
+// Forte Analyzer AsyncGetCallTrace profiling support is not implemented on Bsd/PPC.
+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava) {
+  Unimplemented();
+  return false;
+}
+
+void JavaThread::cache_global_variables() { }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/thread_bsd_ppc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+
+ private:
+
+  void pd_initialize() {
+    _anchor.clear();
+    _last_interpreter_fp = NULL;
+  }
+
+  // The `last' frame is the youngest Java frame on the thread's stack.
+  frame pd_last_frame() {
+    assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
+
+    intptr_t* sp = last_Java_sp();
+    address pc = _anchor.last_Java_pc();
+
+    // Last_Java_pc ist not set, if we come here from compiled code.
+    if (pc == NULL) {
+      pc = (address) *(sp + 2);
+    }
+
+    return frame(sp, pc);
+  }
+
+ public:
+
+  void set_base_of_stack_pointer(intptr_t* base_sp) {}
+  intptr_t* base_of_stack_pointer() { return NULL; }
+  void record_base_of_stack_pointer() {}
+
+  // These routines are only used on cpu architectures that
+  // have separate register stacks (Itanium).
+  static bool register_stack_overflow() { return false; }
+  static void enable_register_stack_guard() {}
+  static void disable_register_stack_guard() {}
+
+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava);
+
+ protected:
+
+  // -Xprof support
+  //
+  // In order to find the last Java fp from an async profile
+  // tick, we store the current interpreter fp in the thread.
+  // This value is only valid while we are in the C++ interpreter
+  // and profiling.
+  intptr_t *_last_interpreter_fp;
+
+ public:
+
+  static ByteSize last_interpreter_fp_offset() {
+    return byte_offset_of(JavaThread, _last_interpreter_fp);
+  }
+
+  intptr_t* last_interpreter_fp() { return _last_interpreter_fp; }
+
+#endif // OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+
+ private:
+
+  void pd_initialize() {
+    _anchor.clear();
+    _last_interpreter_fp = NULL;
+  }
+
+  // The `last' frame is the youngest Java frame on the thread's stack.
+  frame pd_last_frame() {
+    assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
+
+    intptr_t* sp = last_Java_sp();
+    address pc = _anchor.last_Java_pc();
+
+    // Last_Java_pc ist not set, if we come here from compiled code.
+    if (pc == NULL) {
+      pc = (address) *(sp + 2);
+    }
+
+    return frame(sp, pc);
+  }
+
+ public:
+
+  void set_base_of_stack_pointer(intptr_t* base_sp) {}
+  intptr_t* base_of_stack_pointer() { return NULL; }
+  void record_base_of_stack_pointer() {}
+
+  // These routines are only used on cpu architectures that
+  // have separate register stacks (Itanium).
+  static bool register_stack_overflow() { return false; }
+  static void enable_register_stack_guard() {}
+  static void disable_register_stack_guard() {}
+
+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava);
+
+ protected:
+
+  // -Xprof support
+  //
+  // In order to find the last Java fp from an async profile
+  // tick, we store the current interpreter fp in the thread.
+  // This value is only valid while we are in the C++ interpreter
+  // and profiling.
+  intptr_t *_last_interpreter_fp;
+
+ public:
+
+  static ByteSize last_interpreter_fp_offset() {
+    return byte_offset_of(JavaThread, _last_interpreter_fp);
+  }
+
+  intptr_t* last_interpreter_fp() { return _last_interpreter_fp; }
+
+#endif // OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/vmStructs_bsd_ppc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+
+// These are the OS and CPU-specific fields, types and integer
+// constants required by the Serviceability Agent. This file is
+// referenced by vmStructs.cpp.
+
+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \
+                                                                                                                                     \
+  /******************************/                                                                                                   \
+  /* Threads (NOTE: incomplete) */                                                                                                   \
+  /******************************/                                                                                                   \
+  nonstatic_field(OSThread,                      _thread_id,                                      pid_t)                             \
+  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)
+
+
+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \
+                                                                          \
+  /**********************/                                                \
+  /* Posix Thread IDs   */                                                \
+  /**********************/                                                \
+                                                                          \
+  declare_integer_type(pid_t)                                             \
+  declare_unsigned_integer_type(pthread_t)
+
+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#endif // OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+
+// These are the OS and CPU-specific fields, types and integer
+// constants required by the Serviceability Agent. This file is
+// referenced by vmStructs.cpp.
+
+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \
+                                                                                                                                     \
+  /******************************/                                                                                                   \
+  /* Threads (NOTE: incomplete) */                                                                                                   \
+  /******************************/                                                                                                   \
+  nonstatic_field(OSThread,                      _thread_id,                                      pid_t)                             \
+  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)
+
+
+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \
+                                                                          \
+  /**********************/                                                \
+  /* Posix Thread IDs   */                                                \
+  /**********************/                                                \
+                                                                          \
+  declare_integer_type(pid_t)                                             \
+  declare_unsigned_integer_type(pthread_t)
+
+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#endif // OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
--- ./hotspot/src/share/vm/opto/node.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/opto/node.cpp	Mon May 09 17:15:53 2016 -0400
@@ -286,6 +286,10 @@
 #ifdef _MSC_VER // the IDX_INIT hack falls foul of warning C4355
 #pragma warning( disable:4355 ) // 'this' : used in base member initializer list
 #endif
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#endif
 
 // Out-of-line code from node constructors.
 // Executed only when extra debug info. is being passed around.
@@ -493,6 +497,10 @@
   _in[6] = n6; if (n6 != NULL) n6->add_out((Node *)this);
 }
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 
 //------------------------------clone------------------------------------------
 // Clone a Node.
--- ./hotspot/src/share/vm/runtime/atomic.inline.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/atomic.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -63,6 +63,9 @@
 #endif
 
 // BSD
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "atomic_bsd_ppc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "atomic_bsd_x86.inline.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/globals.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/globals.hpp	Mon May 09 17:15:53 2016 -0400
@@ -94,6 +94,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "globals_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "globals_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "globals_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/orderAccess.inline.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/orderAccess.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -64,6 +64,9 @@
 #endif
 
 // BSD
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "orderAccess_bsd_ppc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "orderAccess_bsd_x86.inline.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/os.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/os.cpp	Mon May 09 17:15:53 2016 -0400
@@ -420,15 +420,6 @@
     if (_native_java_library == NULL) {
       vm_exit_during_initialization("Unable to load native library", ebuf);
     }
-
-#if defined(__OpenBSD__)
-    // Work-around OpenBSD's lack of $ORIGIN support by pre-loading libnet.so
-    // ignore errors
-    if (dll_build_name(buffer, sizeof(buffer), Arguments::get_dll_dir(),
-                       "net")) {
-      dll_load(buffer, ebuf, sizeof(ebuf));
-    }
-#endif
   }
   static jboolean onLoaded = JNI_FALSE;
   if (onLoaded) {
--- ./hotspot/src/share/vm/runtime/os.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/os.hpp	Mon May 09 17:15:53 2016 -0400
@@ -835,6 +835,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "os_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "os_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "os_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/prefetch.inline.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/prefetch.inline.hpp	Mon May 09 17:15:53 2016 -0400
@@ -63,6 +63,9 @@
 #endif
 
 // BSD
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "prefetch_bsd_ppc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "prefetch_bsd_x86.inline.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/thread.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/thread.hpp	Mon May 09 17:15:53 2016 -0400
@@ -1732,6 +1732,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "thread_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "thread_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "thread_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/threadLocalStorage.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/threadLocalStorage.hpp	Mon May 09 17:15:53 2016 -0400
@@ -75,6 +75,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "threadLS_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "threadLS_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "threadLS_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/vmStructs.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/runtime/vmStructs.cpp	Mon May 09 17:15:53 2016 -0400
@@ -146,6 +146,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "vmStructs_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "vmStructs_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "vmStructs_bsd_x86.hpp"
 #endif
@@ -2553,6 +2556,8 @@
   /**********************/                                                \
   /* frame              */                                                \
   /**********************/                                                \
+  NOT_ZERO(PPC64_ONLY(declare_constant(frame::abi_minframe_size)))        \
+  NOT_ZERO(PPC64_ONLY(declare_constant(frame::entry_frame_locals_size)))  \
                                                                           \
   NOT_ZERO(X86_ONLY(declare_constant(frame::entry_frame_call_wrapper_offset)))      \
   declare_constant(frame::pc_return_offset)                               \
--- ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	Mon May 09 17:15:53 2016 -0400
@@ -30,6 +30,11 @@
 // This file holds compiler-dependent includes,
 // globally used constants & types, class (forward)
 // declarations and a few frequently used utility functions.
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif // __STDC_LIMIT_MACROS
+#endif
 
 #include <ctype.h>
 #include <string.h>
@@ -69,9 +74,6 @@
 # endif
 
 #if defined(LINUX) || defined(_ALLBSD_SOURCE)
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS
-#endif // __STDC_LIMIT_MACROS
 #include <inttypes.h>
 #include <signal.h>
 #ifndef __OpenBSD__
@@ -242,7 +244,7 @@
 #endif
 
 // GCC 4.3 does not allow 0.0/0.0 to produce a NAN value
-#if (__GNUC__ == 4) && (__GNUC_MINOR__ > 2)
+#if defined(__clang__) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 2))
 #define CAN_USE_NAN_DEFINE 1
 #endif
 
--- ./hotspot/src/share/vm/utilities/vmError.cpp	Tue Mar 22 11:05:52 2016 -0700
+++ ./hotspot/src/share/vm/utilities/vmError.cpp	Mon May 09 17:15:53 2016 -0400
@@ -22,7 +22,6 @@
  *
  */
 
-#include <fcntl.h>
 #include "precompiled.hpp"
 #include "compiler/compileBroker.hpp"
 #include "gc_interface/collectedHeap.hpp"
--- ./jdk/make/CompileDemos.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/CompileDemos.gmk	Mon May 09 17:18:41 2016 -0400
@@ -323,7 +323,7 @@
 $(eval $(call SetupJVMTIDemo,hprof, java_crw_demo, \
     -I$(JDK_TOPDIR)/src/share/npt -I$(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/npt \
     $(BUILD_LIBHPROF_AIX_EXTRA_CFLAGS), C, \
-    -ldl, ws2_32.lib winmm.lib, -lsocket -lnsl, -lpthread, $(BUILD_LIBHPROF_AIX_EXTRA_SRC)))
+    $(LIBDL), ws2_32.lib winmm.lib, -lsocket -lnsl, -lpthread, $(BUILD_LIBHPROF_AIX_EXTRA_SRC)))
 
 $(eval $(call SetupJVMTIDemo,minst, agent_util java_crw_demo))
 $(eval $(call SetupJVMTIDemo,mtrace, agent_util java_crw_demo))
--- ./jdk/make/CompileJavaClasses.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/CompileJavaClasses.gmk	Mon May 09 17:18:41 2016 -0400
@@ -128,23 +128,32 @@
       sun/nio/fs/LinuxFileStore.java \
       sun/nio/fs/LinuxFileSystem.java \
       sun/nio/fs/LinuxFileSystemProvider.java \
-      sun/nio/fs/MagicFileTypeDetector.java \
       sun/nio/fs/LinuxNativeDispatcher.java \
       sun/nio/fs/LinuxUserDefinedFileAttributeView.java \
       sun/nio/fs/LinuxWatchService.java
 endif
 
+ifeq (, $(filter $(OPENJDK_TARGET_OS), linux bsd))
+  EXFILES += sun/nio/fs/MagicFileTypeDetector.java
+endif
+
 ifneq ($(OPENJDK_TARGET_OS), macosx)
+  EXFILES += sun/nio/fs/MacOSXFileSystemProvider.java \
+      sun/nio/fs/MacOSXFileSystem.java \
+      sun/nio/fs/MacOSXNativeDispatcher.java
+endif
+
+ifeq (, $(filter $(OPENJDK_TARGET_OS), bsd macosx))
   EXFILES += sun/nio/ch/BsdAsynchronousChannelProvider.java \
       sun/nio/ch/KQueue.java \
+      sun/nio/ch/KQueueArrayWrapper.java \
       sun/nio/ch/KQueuePort.java \
+      sun/nio/ch/KQueueSelectorImpl.java \
+      sun/nio/ch/KQueueSelectorProvider.java \
       sun/nio/fs/BsdFileStore.java \
       sun/nio/fs/BsdFileSystem.java \
       sun/nio/fs/BsdFileSystemProvider.java \
       sun/nio/fs/BsdNativeDispatcher.java \
-      sun/nio/fs/MacOSXFileSystemProvider.java \
-      sun/nio/fs/MacOSXFileSystem.java \
-      sun/nio/fs/MacOSXNativeDispatcher.java \
       sun/tools/attach/BsdAttachProvider.java \
       sun/tools/attach/BsdVirtualMachine.java
 endif
@@ -231,9 +240,9 @@
 # Exclude another implicitly not included file.
 EXFILES += sun/util/locale/AsciiUtil.java
 
-ifeq (, $(filter $(OPENJDK_TARGET_OS), solaris macosx aix))
+ifeq (, $(filter $(OPENJDK_TARGET_OS), solaris bsd macosx aix))
   #
-  # only solaris, macosx and aix
+  # only solaris, BSD, macosx and aix
   #
   EXFILES += sun/nio/fs/PollingWatchService.java
 endif
@@ -268,21 +277,26 @@
       $(wildcard $(JDK_TOPDIR)/src/closed/$(OPENJDK_TARGET_OS_API_DIR)/classes)
 endif
 
-MACOSX_SRC_DIRS :=
+BSD_SRC_DIRS :=
+ifneq (, $(filter $(OPENJDK_TARGET_OS), bsd macosx))
+  BSD_SRC_DIRS += $(JDK_TOPDIR)/src/bsd/classes
+
+  # these files are duplicated in BSD_SRC_DIRS
+  EXFILES += $(JDK_TOPDIR)/src/solaris/classes/java/net/DefaultInterface.java \
+      $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
+endif
+
 ifeq ($(OPENJDK_TARGET_OS), macosx)
-  MACOSX_SRC_DIRS += $(JDK_TOPDIR)/src/macosx/classes
+  BSD_SRC_DIRS += $(JDK_TOPDIR)/src/macosx/classes
 
-  # this files are duplicated in MACOSX_SRC_DIRS
-  EXFILES += $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java \
-      $(JDK_TOPDIR)/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java \
-      $(JDK_TOPDIR)/src/solaris/classes/java/net/DefaultInterface.java \
+  # these files are duplicated in BSD_SRC_DIRS
+  EXFILES += $(JDK_TOPDIR)/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java \
       $(JDK_TOPDIR)/src/solaris/classes/java/lang/ClassLoaderHelper.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/util/locale/provider/HostLocaleProviderAdapterImpl.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/fs/GnomeFileTypeDetector.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/sctp/SctpChannelImpl.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/sctp/SctpMultiChannelImpl.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/sctp/SctpServerChannelImpl.java
-
 endif
 
 # The security classes should not end up in the classes directory as that will prevent them
@@ -332,6 +346,7 @@
     SRC:=$(JDK_TOPDIR)/src/share/classes \
         $(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/classes \
         $(MACOSX_SRC_DIRS) \
+        $(BSD_SRC_DIRS) \
         $(AIX_SRC_DIRS) \
         $(JDK_OUTPUTDIR)/gensrc \
         $(JDK_OUTPUTDIR)/gensrc_no_srczip \
@@ -351,7 +366,7 @@
     SETUP := GENERATE_JDKBYTECODE, \
     SRC := $(JDK_TOPDIR)/src/share/classes \
         $(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/classes \
-        $(MACOSX_SRC_DIRS) \
+        $(BSD_SRC_DIRS) \
         $(CLOSED_SRC_DIRS), \
     INCLUDES := $(SECURITY_PKGS), \
     EXCLUDES := $(EXCLUDES), \
--- ./jdk/make/CompileLaunchers.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/CompileLaunchers.gmk	Mon May 09 17:18:41 2016 -0400
@@ -49,7 +49,7 @@
   ORIGIN_ROOT := /..
 endif
 
-ifeq ($(OPENJDK_TARGET_OS), macosx)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx), )
   ORIGIN_ARG := $(call SET_EXECUTABLE_ORIGIN)
 else
   ORIGIN_ARG := $(call SET_EXECUTABLE_ORIGIN,$(ORIGIN_ROOT)/lib$(OPENJDK_TARGET_CPU_LIBDIR)/jli)
@@ -60,7 +60,7 @@
 # System.loadLibrary("jawt") first. This was the behaviour described in the
 # devloper documentation of JAWT and what worked with OpenJDK6.
 #
-ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris bsd), )
   ORIGIN_ARG += $(call SET_EXECUTABLE_ORIGIN,$(ORIGIN_ROOT)/lib$(OPENJDK_TARGET_CPU_LIBDIR))
 endif
 
@@ -89,6 +89,18 @@
 
   $1_LDFLAGS := $3
   $1_LDFLAGS_SUFFIX :=
+  ifeq ($(OPENJDK_TARGET_OS), bsd)
+    ifeq ($(BSD_STATIC_LIBJLI), bsd)
+      $1_LDFLAGS += -Wl,--whole-archive $(JDK_OUTPUTDIR)/objs/libjli_static.a \
+          -Wl,--no-whole-archive
+      $1_LDFLAGS_SUFFIX += -pthread
+    else
+      $1_LDFLAGS += \
+          $(call SET_SHARED_LIBRARY_NAME,$(LIBRARY_PREFIX)$(SHARED_LIBRARY_SUFFIX))
+      $1_LDFLAGS_SUFFIX += -L$(JDK_OUTPUTDIR)/lib$(OPENJDK_TARGET_CPU_LIBDIR)/jli -ljli -pthread
+    endif
+  endif
+
   ifeq ($(OPENJDK_TARGET_OS), macosx)
     $1_PLIST_FILE := Info-cmdline.plist
     ifneq ($(11), )
@@ -162,9 +174,11 @@
           -DLIBARCHNAME='"$(OPENJDK_TARGET_CPU_LEGACY)"' \
           -DLAUNCHER_NAME='"$(LAUNCHER_NAME)"' \
           -DPROGNAME='"$1"' $(DPACKAGEPATH) \
+          -DPACKAGE_PATH='"$(PACKAGE_PATH)"' \
           $2, \
       CFLAGS_linux := -fPIC, \
       CFLAGS_solaris := -KPIC -DHAVE_GETHRTIME, \
+      CFLAGS_bsd := -fPIC, \
       LDFLAGS := $(LDFLAGS_JDKEXE) \
           $(ORIGIN_ARG) \
           $$($1_LDFLAGS), \
@@ -195,7 +209,7 @@
 
   BUILD_LAUNCHERS += $$(BUILD_LAUNCHER_$1)
 
-  ifneq (,$(filter $(OPENJDK_TARGET_OS), macosx aix))
+  ifneq (,$(filter $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx aix))
     $$(BUILD_LAUNCHER_$1): $(JDK_OUTPUTDIR)/objs/libjli_static.a
   endif
 
@@ -476,6 +490,7 @@
     CFLAGS_release := -DPRODUCT, \
     CFLAGS_linux := -fPIC, \
     CFLAGS_solaris := -KPIC, \
+    CFLAGS_bsd := -fPIC, \
     CFLAGS_macosx := -fPIC, \
     MAPFILE := $(UNPACK_MAPFILE),\
     LDFLAGS := $(UNPACKEXE_ZIPOBJS), \
@@ -538,7 +553,7 @@
   endif
 endif
 
-ifeq ($(OPENJDK_TARGET_OS), linux)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux bsd), )
   BUILD_JEXEC := 1
 endif # OPENJDK_TARGET_OS
 
@@ -574,6 +589,7 @@
           $(BUILD_JEXEC_INC), \
       CFLAGS_linux := -fPIC, \
       CFLAGS_solaris := -KPIC, \
+      CFLAGS_bsd := -fPIC, \
       LDFLAGS := $(LDFLAGS_JDKEXE) \
           $(call SET_SHARED_LIBRARY_NAME,$(LIBRARY_PREFIX)$(SHARED_LIBRARY_SUFFIX)), \
       OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/jexec_obj, \
@@ -590,10 +606,7 @@
 # The java-rmi.cgi script in bin/ only gets delivered in certain situations
 #
 JAVA_RMI_CGI := $(JDK_OUTPUTDIR)/bin$(OUTPUT_SUBDIR)/java-rmi.cgi
-ifeq ($(OPENJDK_TARGET_OS), linux)
-  BUILD_LAUNCHERS += $(JAVA_RMI_CGI)
-endif
-ifeq ($(OPENJDK_TARGET_OS), solaris)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris bsd), )
   BUILD_LAUNCHERS += $(JAVA_RMI_CGI)
 endif
 
@@ -621,7 +634,7 @@
 LINK_JSPAWNHELPER_OBJECTS := $(JDK_OUTPUTDIR)/objs/libjava/childproc.o
 LINK_JSPAWNHELPER_FLAGS :=
 
-ifneq ($(findstring $(OPENJDK_TARGET_OS), macosx solaris aix), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), bsd macosx solaris aix), )
   BUILD_JSPAWNHELPER := 1
 endif
 
--- ./jdk/make/CopyFiles.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/CopyFiles.gmk	Mon May 09 17:18:41 2016 -0400
@@ -29,6 +29,8 @@
 
 ifeq ($(OPENJDK_TARGET_OS), windows)
   OPENJDK_TARGET_OS_INCLUDE = $(INCLUDEDIR)/win32
+else ifeq ($(OPENJDK_TARGET_OS), bsd)
+  OPENJDK_TARGET_OS_INCLUDE = $(INCLUDEDIR)/$(shell uname -s | ${TR} "[:upper:]" "[:lower:]")
 else ifeq ($(OPENJDK_TARGET_OS), macosx)
   OPENJDK_TARGET_OS_INCLUDE = $(INCLUDEDIR)/darwin
 endif
@@ -323,23 +325,23 @@
 	$(RM) $(@)
         # Now check for other permutations
         ifeq ($(JVM_VARIANT_SERVER), true)
-	  $(PRINTF) "-server KNOWN\n">>$(@)
-	  $(PRINTF) "-client ALIASED_TO -server\n">>$(@)
+	  $(PRINTF) -- "-server KNOWN\n">>$(@)
+	  $(PRINTF) -- "-client ALIASED_TO -server\n">>$(@)
           ifeq ($(JVM_VARIANT_MINIMAL1), true)
-	    $(PRINTF) "-minimal KNOWN\n">>$(@)
+	    $(PRINTF) -- "-minimal KNOWN\n">>$(@)
           endif
         else
           ifeq ($(JVM_VARIANT_CLIENT), true)
-	    $(PRINTF) "-client KNOWN\n">>$(@)
-	    $(PRINTF) "-server ALIASED_TO -client\n">>$(@)
+	    $(PRINTF) -- "-client KNOWN\n">>$(@)
+	    $(PRINTF) -- "-server ALIASED_TO -client\n">>$(@)
             ifeq ($(JVM_VARIANT_MINIMAL1), true)
-	      $(PRINTF) "-minimal KNOWN\n">>$(@)
+	      $(PRINTF) -- "-minimal KNOWN\n">>$(@)
             endif
           else
             ifeq ($(JVM_VARIANT_MINIMAL1), true)
-	      $(PRINTF) "-minimal KNOWN\n">>$(@)
-	      $(PRINTF) "-server ALIASED_TO -minimal\n">>$(@)
-	      $(PRINTF) "-client ALIASED_TO -minimal\n">>$(@)
+	      $(PRINTF) -- "-minimal KNOWN\n">>$(@)
+	      $(PRINTF) -- "-server ALIASED_TO -minimal\n">>$(@)
+	      $(PRINTF) -- "-client ALIASED_TO -minimal\n">>$(@)
             endif
           endif
         endif
--- ./jdk/make/Images.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/Images.gmk	Mon May 09 17:18:41 2016 -0400
@@ -236,11 +236,11 @@
 endif
 
 JDK_LIB_FILES := $(NOT_JRE_LIB_FILES)
-ifeq ($(OPENJDK_TARGET_OS), linux)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux bsd),)
   JDK_LIB_FILES += jexec
 endif
 
-ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris),) # If Linux or Solaris
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris bsd),) # If Linux, Solaris, or BSD
     JDK_LIB_FILES += $(LIBRARY_PREFIX)jli$(SHARED_LIBRARY_SUFFIX) \
 		     $(LIBRARY_PREFIX)jawt$(SHARED_LIBRARY_SUFFIX)
 endif
@@ -391,7 +391,7 @@
     MAN_SRC_DIR = $(MAN_SRC_BASEDIR)/solaris/doc
     MAN1_SUBDIR = sun/man/man1
   endif
-  ifeq ($(OPENJDK_TARGET_OS), macosx)
+  ifneq ($(findstring $(OPENJDK_TARGET_OS), bsd macosx),)
     MAN_SRC_DIR = $(MAN_SRC_BASEDIR)/bsd/doc
     MAN1_SUBDIR = man
   endif
@@ -447,7 +447,7 @@
 	$(install-file)
   endif
 
-  ifeq ($(OPENJDK_TARGET_OS), linux)
+  ifneq ($(findstring $(OPENJDK_TARGET_OS), linux bsd macosx),)
     $(JRE_IMAGE_DIR)/man/ja:
 	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
 	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
@@ -455,19 +455,7 @@
     $(JDK_IMAGE_DIR)/man/ja:
 	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
 	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
-  endif
 
-  ifeq ($(OPENJDK_TARGET_OS), macosx)
-    $(JRE_IMAGE_DIR)/man/ja:
-	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
-	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
-
-    $(JDK_IMAGE_DIR)/man/ja:
-	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
-	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
-  endif
-
-  ifeq ($(OPENJDK_TARGET_OS), linux)
     JRE_MAN_PAGE_LIST = $(addprefix $(JRE_IMAGE_DIR)/man/man1/, $(JRE_MAN_PAGES)) \
         $(addprefix $(JRE_IMAGE_DIR)/man/ja_JP.UTF-8/man1/, $(JRE_MAN_PAGES)) \
         $(JRE_IMAGE_DIR)/man/ja
@@ -489,16 +477,6 @@
         $(addprefix $(JDK_IMAGE_DIR)/man/ja_JP.PCK/man1/, $(JDK_MAN_PAGES))
   endif
 
-  ifeq ($(OPENJDK_TARGET_OS), macosx)
-    JRE_MAN_PAGE_LIST = $(addprefix $(JRE_IMAGE_DIR)/man/man1/, $(JRE_MAN_PAGES)) \
-        $(addprefix $(JRE_IMAGE_DIR)/man/ja_JP.UTF-8/man1/, $(JRE_MAN_PAGES)) \
-        $(JRE_IMAGE_DIR)/man/ja
-
-    JDK_MAN_PAGE_LIST = $(addprefix $(JDK_IMAGE_DIR)/man/man1/, $(JDK_MAN_PAGES)) \
-        $(addprefix $(JDK_IMAGE_DIR)/man/ja_JP.UTF-8/man1/, $(JDK_MAN_PAGES)) \
-        $(JDK_IMAGE_DIR)/man/ja
-  endif
-
 endif # Windows
 
 ################################################################################
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/data/classlist/classlist.bsd	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,2559 @@
+java/lang/Object
+java/lang/String
+java/io/Serializable
+java/lang/Comparable
+java/lang/CharSequence
+java/lang/Class
+java/lang/reflect/GenericDeclaration
+java/lang/reflect/AnnotatedElement
+java/lang/reflect/Type
+java/lang/Cloneable
+java/lang/ClassLoader
+java/lang/System
+java/lang/Throwable
+java/lang/Error
+java/lang/ThreadDeath
+java/lang/Exception
+java/lang/RuntimeException
+java/lang/SecurityManager
+java/security/ProtectionDomain
+java/security/AccessControlContext
+java/security/SecureClassLoader
+java/lang/ClassNotFoundException
+java/lang/ReflectiveOperationException
+java/lang/NoClassDefFoundError
+java/lang/LinkageError
+java/lang/ClassCastException
+java/lang/ArrayStoreException
+java/lang/VirtualMachineError
+java/lang/OutOfMemoryError
+java/lang/StackOverflowError
+java/lang/IllegalMonitorStateException
+java/lang/ref/Reference
+java/lang/ref/SoftReference
+java/lang/ref/WeakReference
+java/lang/ref/FinalReference
+java/lang/ref/PhantomReference
+sun/misc/Cleaner
+java/lang/ref/Finalizer
+java/lang/Thread
+java/lang/Runnable
+java/lang/ThreadGroup
+java/lang/Thread$UncaughtExceptionHandler
+java/util/Properties
+java/util/Hashtable
+java/util/Map
+java/util/Dictionary
+java/lang/reflect/AccessibleObject
+java/lang/reflect/Field
+java/lang/reflect/Member
+java/lang/reflect/Parameter
+java/lang/reflect/Method
+java/lang/reflect/Executable
+java/lang/reflect/Constructor
+sun/reflect/MagicAccessorImpl
+sun/reflect/MethodAccessorImpl
+sun/reflect/MethodAccessor
+sun/reflect/ConstructorAccessorImpl
+sun/reflect/ConstructorAccessor
+sun/reflect/DelegatingClassLoader
+sun/reflect/ConstantPool
+sun/reflect/UnsafeStaticFieldAccessorImpl
+sun/reflect/UnsafeFieldAccessorImpl
+sun/reflect/FieldAccessorImpl
+sun/reflect/FieldAccessor
+sun/reflect/CallerSensitive
+java/lang/annotation/Annotation
+java/lang/invoke/DirectMethodHandle
+java/lang/invoke/MethodHandle
+java/lang/invoke/MemberName
+java/lang/invoke/MethodHandleNatives
+java/lang/invoke/LambdaForm
+java/lang/invoke/MethodType
+java/lang/BootstrapMethodError
+java/lang/invoke/CallSite
+java/lang/invoke/ConstantCallSite
+java/lang/invoke/MutableCallSite
+java/lang/invoke/VolatileCallSite
+java/lang/StringBuffer
+java/lang/AbstractStringBuilder
+java/lang/Appendable
+java/lang/StringBuilder
+sun/misc/Unsafe
+java/io/ByteArrayInputStream
+java/io/InputStream
+java/io/Closeable
+java/lang/AutoCloseable
+java/io/File
+java/net/URLClassLoader
+java/net/URL
+java/util/jar/Manifest
+sun/misc/Launcher
+sun/misc/Launcher$AppClassLoader
+sun/misc/Launcher$ExtClassLoader
+java/security/CodeSource
+java/lang/StackTraceElement
+java/nio/Buffer
+java/lang/Boolean
+java/lang/Character
+java/lang/Float
+java/lang/Number
+java/lang/Double
+java/lang/Byte
+java/lang/Short
+java/lang/Integer
+java/lang/Long
+java/lang/NullPointerException
+java/lang/ArithmeticException
+java/io/ObjectStreamField
+java/lang/String$CaseInsensitiveComparator
+java/util/Comparator
+java/lang/RuntimePermission
+java/security/BasicPermission
+java/security/Permission
+java/security/Guard
+java/security/AccessController
+java/lang/reflect/ReflectPermission
+sun/reflect/ReflectionFactory$GetReflectionFactoryAction
+java/security/PrivilegedAction
+java/security/cert/Certificate
+java/util/Vector
+java/util/List
+java/util/Collection
+java/lang/Iterable
+java/util/RandomAccess
+java/util/AbstractList
+java/util/AbstractCollection
+java/util/Stack
+sun/reflect/ReflectionFactory
+java/lang/ref/Reference$Lock
+java/lang/ref/Reference$ReferenceHandler
+java/lang/ref/ReferenceQueue
+java/lang/ref/ReferenceQueue$Null
+java/lang/ref/ReferenceQueue$Lock
+java/lang/ref/Finalizer$FinalizerThread
+sun/misc/VM
+java/util/Hashtable$Entry
+java/util/Map$Entry
+java/lang/Math
+java/nio/charset/Charset
+sun/nio/cs/StandardCharsets
+sun/nio/cs/FastCharsetProvider
+java/nio/charset/spi/CharsetProvider
+sun/nio/cs/StandardCharsets$Aliases
+sun/util/PreHashedMap
+java/util/AbstractMap
+sun/nio/cs/StandardCharsets$Classes
+sun/nio/cs/StandardCharsets$Cache
+java/lang/ThreadLocal
+java/util/concurrent/atomic/AtomicInteger
+java/lang/NoSuchMethodError
+java/lang/IncompatibleClassChangeError
+java/util/ArrayList
+java/util/Collections
+java/util/Collections$EmptySet
+java/util/AbstractSet
+java/util/Set
+java/util/Collections$EmptyList
+java/util/Collections$EmptyMap
+java/util/Collections$UnmodifiableRandomAccessList
+java/util/Collections$UnmodifiableList
+java/util/Collections$UnmodifiableCollection
+sun/reflect/Reflection
+java/util/HashMap
+java/util/HashMap$Node
+java/lang/Class$3
+java/lang/Class$ReflectionData
+java/lang/Class$Atomic
+sun/reflect/generics/repository/ClassRepository
+sun/reflect/generics/repository/GenericDeclRepository
+sun/reflect/generics/repository/AbstractRepository
+java/lang/Class$AnnotationData
+sun/reflect/annotation/AnnotationType
+java/lang/ClassValue$ClassValueMap
+java/util/WeakHashMap
+java/lang/reflect/Modifier
+java/lang/reflect/ReflectAccess
+sun/reflect/LangReflectAccess
+java/util/Arrays
+sun/nio/cs/UTF_8
+sun/nio/cs/Unicode
+sun/nio/cs/HistoricallyNamedCharset
+java/lang/Class$1
+sun/reflect/ReflectionFactory$1
+sun/reflect/NativeConstructorAccessorImpl
+sun/reflect/DelegatingConstructorAccessorImpl
+java/lang/StringCoding
+java/lang/ThreadLocal$ThreadLocalMap
+java/lang/ThreadLocal$ThreadLocalMap$Entry
+java/lang/StringCoding$StringDecoder
+sun/nio/cs/UTF_8$Decoder
+sun/nio/cs/ArrayDecoder
+java/nio/charset/CharsetDecoder
+java/nio/charset/CodingErrorAction
+java/util/Hashtable$EntrySet
+java/util/Collections$SynchronizedSet
+java/util/Collections$SynchronizedCollection
+java/util/Objects
+java/util/Hashtable$Enumerator
+java/util/Enumeration
+java/util/Iterator
+java/lang/Runtime
+sun/misc/Version
+java/io/FileInputStream
+java/io/FileDescriptor
+java/io/FileDescriptor$1
+sun/misc/JavaIOFileDescriptorAccess
+sun/misc/SharedSecrets
+java/io/FileOutputStream
+java/io/OutputStream
+java/io/Flushable
+java/io/BufferedInputStream
+java/io/FilterInputStream
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl$1
+java/security/PrivilegedExceptionAction
+sun/reflect/misc/ReflectUtil
+java/io/PrintStream
+java/io/FilterOutputStream
+java/io/BufferedOutputStream
+java/io/OutputStreamWriter
+java/io/Writer
+sun/nio/cs/StreamEncoder
+sun/security/action/GetPropertyAction
+sun/nio/cs/UTF_8$Encoder
+sun/nio/cs/ArrayEncoder
+java/nio/charset/CharsetEncoder
+java/nio/ByteBuffer
+java/nio/HeapByteBuffer
+java/nio/Bits
+java/nio/ByteOrder
+java/nio/Bits$1
+sun/misc/JavaNioAccess
+java/io/BufferedWriter
+java/io/DefaultFileSystem
+java/io/UnixFileSystem
+java/io/FileSystem
+java/io/ExpiringCache
+java/io/ExpiringCache$1
+java/util/LinkedHashMap
+java/io/File$PathStatus
+java/lang/Enum
+java/nio/file/Path
+java/nio/file/Watchable
+java/lang/StringCoding$StringEncoder
+java/lang/ClassLoader$3
+java/io/ExpiringCache$Entry
+java/util/LinkedHashMap$Entry
+java/lang/ClassLoader$NativeLibrary
+java/lang/Terminator
+java/lang/Terminator$1
+sun/misc/SignalHandler
+sun/misc/Signal
+sun/misc/NativeSignalHandler
+java/lang/Integer$IntegerCache
+sun/misc/OSEnvironment
+java/lang/System$2
+sun/misc/JavaLangAccess
+java/lang/IllegalArgumentException
+java/lang/Compiler
+java/lang/Compiler$1
+sun/misc/Launcher$Factory
+java/net/URLStreamHandlerFactory
+sun/security/util/Debug
+java/lang/ClassLoader$ParallelLoaders
+java/util/WeakHashMap$Entry
+java/util/Collections$SetFromMap
+java/util/WeakHashMap$KeySet
+java/net/URLClassLoader$7
+sun/misc/JavaNetAccess
+java/util/StringTokenizer
+sun/misc/Launcher$ExtClassLoader$1
+sun/misc/MetaIndex
+java/io/BufferedReader
+java/io/Reader
+java/lang/Readable
+java/io/FileReader
+java/io/InputStreamReader
+sun/nio/cs/StreamDecoder
+java/nio/CharBuffer
+java/nio/HeapCharBuffer
+java/nio/charset/CoderResult
+java/nio/charset/CoderResult$1
+java/nio/charset/CoderResult$Cache
+java/nio/charset/CoderResult$2
+java/lang/reflect/Array
+java/io/FileInputStream$1
+sun/net/www/ParseUtil
+java/util/BitSet
+java/util/Locale
+java/util/Locale$Cache
+sun/util/locale/LocaleObjectCache
+java/util/concurrent/ConcurrentHashMap
+java/util/concurrent/ConcurrentMap
+java/util/concurrent/ConcurrentHashMap$Segment
+java/util/concurrent/locks/ReentrantLock
+java/util/concurrent/locks/Lock
+java/util/concurrent/ConcurrentHashMap$Node
+java/util/concurrent/ConcurrentHashMap$CounterCell
+java/util/concurrent/ConcurrentHashMap$KeySetView
+java/util/concurrent/ConcurrentHashMap$CollectionView
+java/util/concurrent/ConcurrentHashMap$ValuesView
+java/util/concurrent/ConcurrentHashMap$EntrySetView
+sun/util/locale/BaseLocale
+sun/util/locale/BaseLocale$Cache
+sun/util/locale/BaseLocale$Key
+sun/util/locale/LocaleObjectCache$CacheEntry
+java/util/Locale$LocaleKey
+sun/util/locale/LocaleUtils
+java/lang/CharacterData
+java/lang/CharacterDataLatin1
+java/net/Parts
+sun/net/www/protocol/file/Handler
+java/net/URLStreamHandler
+java/util/HashMap$TreeNode
+java/security/ProtectionDomain$JavaSecurityAccessImpl
+sun/misc/JavaSecurityAccess
+java/security/ProtectionDomain$2
+sun/misc/JavaSecurityProtectionDomainAccess
+java/security/ProtectionDomain$Key
+java/security/Principal
+java/util/HashSet
+sun/misc/URLClassPath
+sun/net/www/protocol/jar/Handler
+sun/misc/Launcher$AppClassLoader$1
+java/lang/SystemClassLoaderAction
+java/lang/invoke/MethodHandleImpl
+java/lang/invoke/MethodHandleImpl$1
+java/lang/invoke/MethodHandleImpl$2
+java/util/function/Function
+java/lang/invoke/MethodHandleImpl$3
+java/lang/invoke/MethodHandleImpl$4
+java/lang/ClassValue
+java/lang/ClassValue$Entry
+java/lang/ClassValue$Identity
+java/lang/ClassValue$Version
+java/lang/invoke/MemberName$Factory
+java/lang/invoke/MethodHandleStatics
+java/lang/invoke/MethodHandleStatics$1
+sun/misc/PostVMInitHook
+sun/usagetracker/UsageTrackerClient
+java/util/concurrent/atomic/AtomicBoolean
+sun/usagetracker/UsageTrackerClient$1
+sun/usagetracker/UsageTrackerClient$4
+sun/usagetracker/UsageTrackerClient$3
+java/io/FileOutputStream$1
+sun/launcher/LauncherHelper
+java/net/URLClassLoader$1
+sun/net/util/URLUtil
+sun/misc/URLClassPath$3
+sun/misc/URLClassPath$JarLoader
+sun/misc/URLClassPath$Loader
+java/util/zip/ZipFile
+java/util/zip/ZipConstants
+java/util/zip/ZipFile$1
+sun/misc/JavaUtilZipFileAccess
+sun/misc/URLClassPath$JarLoader$1
+sun/misc/FileURLMapper
+java/util/jar/JarFile
+java/util/jar/JavaUtilJarAccessImpl
+sun/misc/JavaUtilJarAccess
+java/nio/charset/StandardCharsets
+sun/nio/cs/US_ASCII
+sun/nio/cs/ISO_8859_1
+sun/nio/cs/UTF_16BE
+sun/nio/cs/UTF_16LE
+sun/nio/cs/UTF_16
+java/util/ArrayDeque
+java/util/Deque
+java/util/Queue
+java/util/zip/ZipCoder
+sun/misc/PerfCounter
+sun/misc/Perf$GetPerfAction
+sun/misc/Perf
+sun/misc/PerfCounter$CoreCounters
+sun/nio/ch/DirectBuffer
+java/nio/DirectByteBuffer
+java/nio/MappedByteBuffer
+java/nio/DirectLongBufferU
+java/nio/LongBuffer
+sun/misc/JarIndex
+sun/misc/ExtensionDependency
+java/util/zip/ZipEntry
+java/util/jar/JarFile$JarFileEntry
+java/util/jar/JarEntry
+java/util/zip/ZipFile$ZipFileInputStream
+java/util/zip/Inflater
+java/util/zip/ZStreamRef
+java/util/zip/ZipFile$ZipFileInflaterInputStream
+java/util/zip/InflaterInputStream
+sun/misc/IOUtils
+sun/misc/URLClassPath$JarLoader$2
+sun/misc/Resource
+sun/nio/ByteBuffered
+java/security/Permissions
+java/security/PermissionCollection
+sun/net/www/protocol/file/FileURLConnection
+sun/net/www/URLConnection
+java/net/URLConnection
+sun/net/www/MessageHeader
+java/io/FilePermission
+java/io/FilePermission$1
+java/io/FilePermissionCollection
+java/security/AllPermission
+java/security/UnresolvedPermission
+java/security/BasicPermissionCollection
+javax/swing/JLabel
+javax/swing/SwingConstants
+javax/accessibility/Accessible
+javax/swing/JComponent
+javax/swing/TransferHandler$HasGetTransferHandler
+java/awt/Container
+java/awt/Component
+java/awt/image/ImageObserver
+java/awt/MenuContainer
+sun/launcher/LauncherHelper$FXHelper
+java/lang/Class$MethodArray
+java/lang/InterruptedException
+javax/swing/JFrame
+javax/swing/WindowConstants
+javax/swing/RootPaneContainer
+java/awt/Frame
+java/awt/Window
+java/util/concurrent/ConcurrentHashMap$ForwardingNode
+java/awt/Graphics
+java/lang/Void
+sun/util/logging/PlatformLogger
+sun/util/logging/PlatformLogger$Level
+sun/util/logging/PlatformLogger$1
+sun/util/logging/PlatformLogger$DefaultLoggerProxy
+sun/util/logging/PlatformLogger$LoggerProxy
+sun/util/logging/PlatformLogger$JavaLoggerProxy
+sun/util/logging/LoggingSupport
+sun/util/logging/LoggingSupport$1
+java/util/logging/LoggingProxyImpl
+sun/util/logging/LoggingProxy
+sun/reflect/UnsafeFieldAccessorFactory
+sun/reflect/UnsafeQualifiedStaticObjectFieldAccessorImpl
+sun/reflect/UnsafeQualifiedStaticFieldAccessorImpl
+java/util/HashMap$EntrySet
+java/util/HashMap$EntryIterator
+java/util/HashMap$HashIterator
+sun/util/logging/LoggingSupport$2
+java/util/Date
+sun/util/calendar/CalendarSystem
+sun/util/calendar/Gregorian
+sun/util/calendar/BaseCalendar
+sun/util/calendar/AbstractCalendar
+java/awt/Component$AWTTreeLock
+java/awt/Toolkit
+java/awt/Toolkit$4
+sun/awt/AWTAccessor$ToolkitAccessor
+sun/awt/AWTAccessor
+java/awt/Toolkit$5
+sun/util/CoreResourceBundleControl
+java/util/ResourceBundle$Control
+java/util/Arrays$ArrayList
+java/util/ResourceBundle$Control$CandidateListCache
+java/util/ResourceBundle
+java/util/ResourceBundle$1
+java/util/spi/ResourceBundleControlProvider
+java/util/ServiceLoader
+java/util/ServiceLoader$LazyIterator
+java/util/ServiceLoader$1
+java/util/LinkedHashMap$LinkedEntrySet
+java/util/LinkedHashMap$LinkedEntryIterator
+java/util/LinkedHashMap$LinkedHashIterator
+sun/misc/Launcher$BootClassPathHolder
+sun/misc/Launcher$BootClassPathHolder$1
+sun/misc/URLClassPath$2
+java/lang/ClassLoader$2
+sun/misc/URLClassPath$1
+java/net/URLClassLoader$3
+sun/misc/CompoundEnumeration
+java/io/FileNotFoundException
+java/io/IOException
+java/security/PrivilegedActionException
+java/net/URLClassLoader$3$1
+java/util/ResourceBundle$RBClassLoader
+java/util/ResourceBundle$RBClassLoader$1
+java/util/ResourceBundle$CacheKey
+java/util/ResourceBundle$LoaderReference
+java/util/ResourceBundle$CacheKeyReference
+java/util/ResourceBundle$SingleFormatControl
+java/util/LinkedList
+java/util/AbstractSequentialList
+java/util/LinkedList$Node
+sun/awt/resources/awt
+java/util/ListResourceBundle
+java/awt/Toolkit$3
+java/awt/GraphicsEnvironment
+java/lang/invoke/LambdaMetafactory
+java/lang/invoke/MethodHandles$Lookup
+java/lang/invoke/MethodType$ConcurrentWeakInternSet
+java/lang/invoke/MethodTypeForm
+java/lang/invoke/Invokers
+java/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry
+java/lang/invoke/MethodHandles
+sun/invoke/util/Wrapper
+sun/invoke/util/Wrapper$Format
+java/lang/Byte$ByteCache
+java/lang/Short$ShortCache
+java/lang/Character$CharacterCache
+java/lang/Long$LongCache
+sun/invoke/util/VerifyAccess
+sun/invoke/util/ValueConversions
+java/lang/NoSuchMethodException
+java/lang/invoke/LambdaForm$BasicType
+java/lang/invoke/LambdaForm$Name
+java/lang/invoke/LambdaForm$NamedFunction
+java/lang/invoke/SimpleMethodHandle
+java/lang/invoke/BoundMethodHandle
+java/lang/invoke/BoundMethodHandle$SpeciesData
+java/lang/invoke/BoundMethodHandle$Factory
+java/lang/invoke/BoundMethodHandle$Species_L
+java/util/HashMap$Values
+java/util/HashMap$ValueIterator
+sun/invoke/util/BytecodeDescriptor
+java/lang/invoke/DirectMethodHandle$Lazy
+java/lang/InstantiationException
+java/util/Collections$UnmodifiableCollection$1
+java/util/AbstractList$Itr
+java/lang/invoke/InvokerBytecodeGenerator
+jdk/internal/org/objectweb/asm/ClassWriter
+jdk/internal/org/objectweb/asm/ClassVisitor
+jdk/internal/org/objectweb/asm/ByteVector
+jdk/internal/org/objectweb/asm/Item
+jdk/internal/org/objectweb/asm/MethodWriter
+jdk/internal/org/objectweb/asm/MethodVisitor
+jdk/internal/org/objectweb/asm/Type
+jdk/internal/org/objectweb/asm/Label
+jdk/internal/org/objectweb/asm/Frame
+jdk/internal/org/objectweb/asm/AnnotationWriter
+jdk/internal/org/objectweb/asm/AnnotationVisitor
+java/lang/invoke/MethodHandleImpl$Intrinsic
+java/lang/invoke/InvokerBytecodeGenerator$2
+sun/invoke/util/VerifyType
+sun/invoke/empty/Empty
+java/lang/NoSuchFieldException
+java/lang/invoke/InvokerBytecodeGenerator$CpPatch
+java/lang/invoke/DirectMethodHandle$Accessor
+java/util/ArrayList$Itr
+java/util/RandomAccessSubList
+java/util/SubList
+java/util/SubList$1
+java/util/ListIterator
+java/util/AbstractList$ListItr
+java/lang/invoke/MethodHandleImpl$AsVarargsCollector
+java/lang/invoke/DelegatingMethodHandle
+java/lang/invoke/WrongMethodTypeException
+java/lang/invoke/MethodHandleImpl$Lazy
+java/lang/invoke/MethodHandleImpl$IntrinsicMethodHandle
+java/lang/NoSuchFieldError
+java/lang/IllegalAccessException
+java/lang/invoke/LambdaFormEditor
+java/lang/invoke/LambdaFormEditor$Transform$Kind
+java/lang/invoke/LambdaFormEditor$Transform
+java/lang/invoke/LambdaFormBuffer
+jdk/internal/org/objectweb/asm/FieldWriter
+jdk/internal/org/objectweb/asm/FieldVisitor
+java/lang/invoke/InnerClassLambdaMetafactory
+java/lang/invoke/AbstractValidatingLambdaMetafactory
+java/util/PropertyPermission
+java/security/AccessController$1
+sun/security/util/SecurityConstants
+java/net/NetPermission
+java/security/SecurityPermission
+java/net/SocketPermission
+sun/security/action/GetBooleanAction
+java/security/AllPermissionCollection
+java/lang/invoke/InfoFromMemberName
+java/lang/invoke/MethodHandleInfo
+java/lang/invoke/InnerClassLambdaMetafactory$ForwardingMethodGenerator
+java/lang/invoke/TypeConvertingMethodAdapter
+java/lang/invoke/InnerClassLambdaMetafactory$1
+java/lang/ProcessEnvironment
+java/lang/ProcessEnvironment$Variable
+java/lang/ProcessEnvironment$ExternalData
+java/lang/ProcessEnvironment$Value
+java/lang/ProcessEnvironment$StringEnvironment
+java/util/Collections$UnmodifiableMap
+java/awt/Toolkit$1
+java/awt/event/KeyEvent
+java/awt/event/InputEvent
+java/awt/event/ComponentEvent
+java/awt/AWTEvent
+java/util/EventObject
+java/awt/AWTEvent$1
+sun/awt/AWTAccessor$AWTEventAccessor
+java/awt/event/NativeLibLoader
+java/awt/event/NativeLibLoader$1
+java/awt/event/InputEvent$1
+sun/awt/AWTAccessor$InputEventAccessor
+java/awt/event/KeyEvent$1
+sun/awt/AWTAccessor$KeyEventAccessor
+java/awt/Component$1
+sun/awt/AWTAccessor$ComponentAccessor
+java/awt/Component$DummyRequestFocusController
+sun/awt/RequestFocusController
+java/awt/LayoutManager
+java/awt/LightweightDispatcher
+java/awt/event/AWTEventListener
+java/util/EventListener
+java/awt/Dimension
+java/awt/geom/Dimension2D
+java/awt/Container$1
+sun/awt/AWTAccessor$ContainerAccessor
+javax/swing/JComponent$1
+java/awt/ComponentOrientation
+java/awt/Component$3
+sun/awt/AppContext
+java/util/IdentityHashMap
+java/util/Collections$SynchronizedMap
+sun/awt/AppContext$GetAppContextLock
+sun/awt/AppContext$6
+sun/misc/JavaAWTAccess
+sun/awt/AppContext$3
+sun/awt/AppContext$2
+sun/awt/SunToolkit
+sun/awt/WindowClosingSupport
+sun/awt/WindowClosingListener
+sun/awt/ComponentFactory
+sun/awt/InputMethodSupport
+sun/awt/KeyboardFocusManagerPeerProvider
+java/util/concurrent/locks/ReentrantLock$NonfairSync
+java/util/concurrent/locks/ReentrantLock$Sync
+java/util/concurrent/locks/AbstractQueuedSynchronizer
+java/util/concurrent/locks/AbstractOwnableSynchronizer
+java/util/concurrent/locks/AbstractQueuedSynchronizer$Node
+java/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject
+java/util/concurrent/locks/Condition
+sun/misc/SoftCache
+sun/awt/AppContext$State
+sun/awt/AppContext$1
+java/awt/EventQueue
+java/awt/EventQueue$1
+java/awt/EventQueue$2
+sun/awt/AWTAccessor$EventQueueAccessor
+java/awt/Queue
+sun/awt/MostRecentKeyValue
+sun/awt/PostEventQueue
+javax/swing/event/EventListenerList
+javax/swing/SwingUtilities
+javax/swing/RepaintManager
+javax/swing/RepaintManager$DisplayChangedHandler
+sun/awt/DisplayChangedListener
+javax/swing/RepaintManager$1
+sun/swing/SwingAccessor$RepaintManagerAccessor
+sun/swing/SwingAccessor
+sun/awt/X11GraphicsEnvironment
+sun/java2d/SunGraphicsEnvironment
+sun/awt/X11GraphicsEnvironment$1
+sun/awt/X11/XErrorHandlerUtil
+sun/awt/X11/XlibWrapper
+sun/java2d/UnixSurfaceManagerFactory
+sun/java2d/SurfaceManagerFactory
+sun/awt/SunDisplayChanger
+sun/java2d/SunGraphicsEnvironment$1
+sun/misc/FloatingDecimal
+sun/misc/FloatingDecimal$ExceptionalBinaryToASCIIBuffer
+sun/misc/FloatingDecimal$BinaryToASCIIConverter
+sun/misc/FloatingDecimal$BinaryToASCIIBuffer
+sun/misc/FloatingDecimal$1
+sun/misc/FloatingDecimal$PreparedASCIIToBinaryBuffer
+sun/misc/FloatingDecimal$ASCIIToBinaryConverter
+java/lang/NumberFormatException
+java/lang/StringIndexOutOfBoundsException
+java/lang/IndexOutOfBoundsException
+java/awt/Font
+java/awt/Font$FontAccessImpl
+sun/font/FontAccess
+java/awt/geom/AffineTransform
+sun/font/AttributeValues
+sun/font/EAttribute
+java/text/AttributedCharacterIterator$Attribute
+java/lang/Class$4
+sun/reflect/NativeMethodAccessorImpl
+sun/reflect/DelegatingMethodAccessorImpl
+java/awt/font/TextAttribute
+java/awt/Toolkit$2
+sun/awt/X11/XToolkit
+sun/awt/UNIXToolkit
+java/util/TreeMap
+java/util/NavigableMap
+java/util/SortedMap
+java/awt/GraphicsDevice
+sun/awt/X11GraphicsDevice
+sun/awt/X11GraphicsConfig
+sun/awt/image/SurfaceManager$ProxiedGraphicsConfig
+java/awt/GraphicsConfiguration
+java/awt/ImageCapabilities
+sun/java2d/x11/X11SurfaceData
+sun/java2d/x11/XSurfaceData
+sun/java2d/SurfaceData
+java/awt/Transparency
+sun/java2d/DisposerTarget
+sun/java2d/StateTrackable
+sun/java2d/Surface
+sun/java2d/InvalidPipeException
+java/lang/IllegalStateException
+sun/java2d/NullSurfaceData
+sun/java2d/StateTrackable$State
+sun/java2d/loops/SurfaceType
+sun/awt/image/PixelConverter
+sun/awt/image/PixelConverter$Xrgb
+sun/awt/image/PixelConverter$Argb
+sun/awt/image/PixelConverter$ArgbPre
+sun/awt/image/PixelConverter$Xbgr
+sun/awt/image/PixelConverter$Rgba
+sun/awt/image/PixelConverter$RgbaPre
+sun/awt/image/PixelConverter$Ushort565Rgb
+sun/awt/image/PixelConverter$Ushort555Rgb
+sun/awt/image/PixelConverter$Ushort555Rgbx
+sun/awt/image/PixelConverter$Ushort4444Argb
+sun/awt/image/PixelConverter$ByteGray
+sun/awt/image/PixelConverter$UshortGray
+sun/awt/image/PixelConverter$Rgbx
+sun/awt/image/PixelConverter$Bgrx
+sun/awt/image/PixelConverter$ArgbBm
+java/awt/image/ColorModel
+java/awt/image/ColorModel$1
+java/awt/image/DirectColorModel
+java/awt/image/PackedColorModel
+java/awt/color/ColorSpace
+java/awt/color/ICC_Profile
+sun/java2d/cmm/ProfileDeferralInfo
+sun/java2d/cmm/ProfileDeferralMgr
+java/awt/color/ICC_ProfileRGB
+java/awt/color/ICC_Profile$1
+sun/java2d/cmm/ProfileActivator
+java/awt/color/ICC_ColorSpace
+sun/java2d/StateTrackableDelegate
+sun/java2d/StateTrackableDelegate$2
+sun/java2d/pipe/NullPipe
+sun/java2d/pipe/PixelDrawPipe
+sun/java2d/pipe/PixelFillPipe
+sun/java2d/pipe/ShapeDrawPipe
+sun/java2d/pipe/TextPipe
+sun/java2d/pipe/DrawImagePipe
+java/awt/image/IndexColorModel
+sun/java2d/pipe/LoopPipe
+sun/java2d/pipe/ParallelogramPipe
+sun/java2d/pipe/LoopBasedPipe
+sun/java2d/pipe/RenderingEngine
+sun/java2d/pipe/RenderingEngine$1
+sun/dc/DuctusRenderingEngine
+sun/java2d/pipe/OutlineTextRenderer
+sun/java2d/pipe/SolidTextRenderer
+sun/java2d/pipe/GlyphListLoopPipe
+sun/java2d/pipe/GlyphListPipe
+sun/java2d/pipe/AATextRenderer
+sun/java2d/pipe/LCDTextRenderer
+sun/java2d/pipe/AlphaColorPipe
+sun/java2d/pipe/CompositePipe
+sun/java2d/SurfaceData$PixelToShapeLoopConverter
+sun/java2d/pipe/PixelToShapeConverter
+sun/java2d/SurfaceData$PixelToPgramLoopConverter
+sun/java2d/pipe/PixelToParallelogramConverter
+sun/java2d/pipe/TextRenderer
+sun/java2d/pipe/SpanClipRenderer
+sun/java2d/pipe/Region
+sun/java2d/pipe/RegionIterator
+sun/java2d/pipe/Region$ImmutableRegion
+sun/java2d/pipe/AAShapePipe
+sun/java2d/pipe/AlphaPaintPipe
+sun/java2d/pipe/SpanShapeRenderer$Composite
+sun/java2d/pipe/SpanShapeRenderer
+sun/java2d/pipe/GeneralCompositePipe
+sun/java2d/pipe/DrawImage
+sun/java2d/loops/RenderCache
+sun/java2d/loops/RenderCache$Entry
+sun/java2d/loops/XORComposite
+java/awt/Composite
+sun/font/X11TextRenderer
+sun/java2d/loops/GraphicsPrimitive
+sun/java2d/x11/X11PMBlitLoops
+sun/java2d/loops/Blit
+sun/java2d/loops/GraphicsPrimitiveMgr
+sun/java2d/loops/CompositeType
+sun/java2d/SunGraphics2D
+sun/awt/ConstrainableGraphics
+sun/java2d/DestSurfaceProvider
+java/awt/Graphics2D
+java/awt/Color
+java/awt/Paint
+java/awt/AlphaComposite
+java/awt/geom/Path2D
+java/awt/Shape
+java/awt/geom/Path2D$Float
+sun/awt/SunHints
+sun/java2d/loops/BlitBg
+sun/java2d/loops/ScaledBlit
+sun/java2d/loops/FillRect
+sun/java2d/loops/FillSpans
+sun/java2d/loops/FillParallelogram
+sun/java2d/loops/DrawParallelogram
+sun/java2d/loops/DrawLine
+sun/java2d/loops/DrawRect
+sun/java2d/loops/DrawPolygons
+sun/java2d/loops/DrawPath
+sun/java2d/loops/FillPath
+sun/java2d/loops/MaskBlit
+sun/java2d/loops/MaskFill
+sun/java2d/loops/DrawGlyphList
+sun/java2d/loops/DrawGlyphListAA
+sun/java2d/loops/DrawGlyphListLCD
+sun/java2d/loops/TransformHelper
+java/awt/BasicStroke
+java/awt/Stroke
+sun/misc/PerformanceLogger
+sun/misc/PerformanceLogger$TimeData
+sun/java2d/pipe/ValidatePipe
+sun/awt/SunHints$Key
+java/awt/RenderingHints$Key
+sun/awt/SunHints$Value
+sun/awt/SunHints$LCDContrastKey
+sun/java2d/loops/CustomComponent
+sun/java2d/loops/GraphicsPrimitiveProxy
+sun/java2d/loops/GeneralRenderer
+sun/java2d/loops/GraphicsPrimitiveMgr$1
+sun/java2d/loops/GraphicsPrimitiveMgr$2
+sun/java2d/x11/X11PMBlitLoops$DelegateBlitLoop
+sun/java2d/x11/X11PMBlitBgLoops
+sun/java2d/x11/X11SurfaceData$LazyPipe
+sun/awt/X11GraphicsConfig$X11GCDisposerRecord
+sun/java2d/DisposerRecord
+sun/java2d/Disposer
+sun/java2d/Disposer$1
+sun/misc/ThreadGroupUtils
+sun/awt/X11/XModifierKeymap
+sun/awt/X11/XWrapperBase
+sun/awt/X11/Native
+sun/awt/X11/Native$1
+sun/awt/X11/XToolkit$3
+sun/awt/X11/XToolkit$4
+sun/awt/X11/XEventDispatcher
+java/awt/Toolkit$DesktopPropertyChangeSupport
+java/beans/PropertyChangeSupport
+java/beans/PropertyChangeSupport$PropertyChangeListenerMap
+java/beans/ChangeListenerMap
+java/beans/PropertyChangeListener
+sun/awt/SunToolkit$ModalityListenerList
+sun/awt/ModalityListener
+sun/font/FontConfigManager
+sun/font/FontConfigManager$FontConfigInfo
+sun/awt/X11/AwtScreenData
+sun/awt/X11/XToolkit$1
+java/lang/invoke/DirectMethodHandle$Special
+sun/awt/X11/XToolkit$2
+java/lang/ApplicationShutdownHooks
+java/lang/ApplicationShutdownHooks$1
+java/lang/Shutdown
+java/lang/Shutdown$Lock
+sun/awt/X11/XWM
+sun/awt/X11/XAtom
+java/awt/Insets
+sun/awt/X11/XWM$1
+sun/awt/X11/XErrorHandler$XBaseErrorHandler
+sun/awt/X11/XErrorHandler
+sun/awt/X11/XSetWindowAttributes
+sun/awt/X11/XNETProtocol
+sun/awt/X11/XStateProtocol
+sun/awt/X11/XLayerProtocol
+sun/awt/X11/XProtocol
+sun/awt/X11/WindowPropertyGetter
+sun/awt/X11/UnsafeXDisposerRecord
+sun/awt/X11/XPropertyCache
+sun/awt/X11/XWINProtocol
+sun/awt/X11/XAtomList
+java/awt/Rectangle
+java/awt/geom/Rectangle2D
+sun/awt/X11/XEvent
+java/awt/geom/RectangularShape
+javax/swing/RepaintManager$ProcessingRunnable
+com/sun/java/swing/SwingUtilities3
+javax/swing/UIManager
+javax/swing/UIManager$LookAndFeelInfo
+sun/awt/OSInfo
+sun/awt/OSInfo$WindowsVersion
+sun/awt/OSInfo$1
+sun/awt/OSInfo$OSType
+sun/swing/SwingUtilities2
+java/awt/font/FontRenderContext
+java/awt/RenderingHints
+sun/swing/StringUIClientPropertyKey
+sun/swing/UIClientPropertyKey
+sun/swing/SwingUtilities2$LSBCacheEntry
+javax/swing/UIManager$LAFState
+javax/swing/UIDefaults
+javax/swing/MultiUIDefaults
+javax/swing/UIManager$1
+javax/swing/plaf/metal/MetalLookAndFeel
+javax/swing/plaf/basic/BasicLookAndFeel
+javax/swing/LookAndFeel
+sun/swing/DefaultLookup
+javax/swing/plaf/metal/OceanTheme
+javax/swing/plaf/metal/DefaultMetalTheme
+javax/swing/plaf/metal/MetalTheme
+javax/swing/plaf/ColorUIResource
+javax/swing/plaf/UIResource
+sun/swing/PrintColorUIResource
+javax/swing/plaf/metal/DefaultMetalTheme$FontDelegate
+javax/swing/plaf/FontUIResource
+sun/swing/SwingLazyValue
+javax/swing/UIDefaults$LazyValue
+javax/swing/UIDefaults$ActiveValue
+javax/swing/plaf/InsetsUIResource
+javax/swing/plaf/BorderUIResource$EmptyBorderUIResource
+javax/swing/border/EmptyBorder
+javax/swing/border/AbstractBorder
+javax/swing/border/Border
+sun/swing/SwingUtilities2$2
+javax/swing/plaf/basic/BasicLookAndFeel$2
+javax/swing/plaf/DimensionUIResource
+javax/swing/UIDefaults$LazyInputMap
+javax/swing/plaf/metal/MetalLookAndFeel$FontActiveValue
+sun/swing/SwingUtilities2$AATextInfo
+sun/awt/HeadlessToolkit
+sun/awt/X11/XAWTXSettings
+sun/awt/X11/XMSelectionListener
+sun/awt/XSettings
+sun/awt/X11/XMSelection
+sun/awt/X11/XMSelection$1
+sun/awt/X11/XMSelection$3
+sun/awt/X11/XErrorHandler$IgnoreBadWindowHandler
+sun/awt/XSettings$Update
+java/beans/PropertyChangeEvent
+java/awt/Toolkit$DesktopPropertyChangeSupport$1
+java/util/IdentityHashMap$Values
+java/util/IdentityHashMap$ValueIterator
+java/util/IdentityHashMap$IdentityHashMapIterator
+java/util/HashMap$KeySet
+java/util/HashMap$KeyIterator
+javax/swing/plaf/metal/MetalLookAndFeel$AATextListener
+java/beans/PropertyChangeListenerProxy
+java/util/EventListenerProxy
+javax/swing/plaf/metal/OceanTheme$1
+javax/swing/plaf/metal/OceanTheme$2
+javax/swing/plaf/metal/OceanTheme$3
+javax/swing/plaf/metal/OceanTheme$4
+javax/swing/plaf/metal/OceanTheme$5
+javax/swing/plaf/metal/OceanTheme$6
+javax/swing/SwingPaintEventDispatcher
+sun/awt/PaintEventDispatcher
+java/awt/KeyboardFocusManager
+java/awt/KeyEventDispatcher
+java/awt/KeyEventPostProcessor
+java/awt/KeyboardFocusManager$1
+sun/awt/AWTAccessor$KeyboardFocusManagerAccessor
+java/awt/AWTKeyStroke
+java/awt/AWTKeyStroke$1
+java/awt/DefaultKeyboardFocusManager
+java/awt/DefaultKeyboardFocusManager$1
+sun/awt/AWTAccessor$DefaultKeyboardFocusManagerAccessor
+java/awt/DefaultFocusTraversalPolicy
+java/awt/ContainerOrderFocusTraversalPolicy
+java/awt/FocusTraversalPolicy
+java/util/Collections$UnmodifiableSet
+sun/awt/X11/XKeyboardFocusManagerPeer
+sun/awt/KeyboardFocusManagerPeerImpl
+java/awt/peer/KeyboardFocusManagerPeer
+javax/swing/UIManager$2
+javax/swing/JRootPane
+javax/swing/UIDefaults$TextAndMnemonicHashMap
+com/sun/swing/internal/plaf/metal/resources/metal
+sun/util/ResourceBundleEnumeration
+com/sun/swing/internal/plaf/basic/resources/basic
+javax/swing/plaf/metal/MetalLabelUI
+javax/swing/plaf/basic/BasicLabelUI
+javax/swing/plaf/LabelUI
+javax/swing/plaf/ComponentUI
+sun/reflect/misc/MethodUtil
+sun/reflect/misc/MethodUtil$1
+sun/net/www/protocol/jar/JarURLConnection
+java/net/JarURLConnection
+sun/net/www/protocol/jar/JarFileFactory
+sun/net/www/protocol/jar/URLJarFile$URLJarFileCloseController
+java/net/HttpURLConnection
+sun/net/www/protocol/jar/URLJarFile
+sun/net/www/protocol/jar/URLJarFile$URLJarFileEntry
+sun/net/www/protocol/jar/JarURLConnection$JarURLInputStream
+java/lang/UnsupportedOperationException
+java/lang/reflect/InvocationTargetException
+javax/swing/plaf/metal/DefaultMetalTheme$FontDelegate$1
+javax/swing/plaf/basic/BasicHTML
+sun/awt/util/IdentityArrayList
+java/awt/Window$1
+sun/awt/AWTAccessor$WindowAccessor
+java/awt/Frame$1
+sun/awt/AWTAccessor$FrameAccessor
+java/awt/Window$Type
+java/awt/Cursor
+java/awt/Cursor$1
+sun/awt/AWTAccessor$CursorAccessor
+java/awt/BorderLayout
+java/awt/LayoutManager2
+sun/awt/X11/XlibUtil
+java/util/concurrent/locks/LockSupport
+sun/nio/ch/Interruptible
+java/awt/Dialog$ModalExclusionType
+java/awt/Window$WindowDisposerRecord
+javax/swing/JPanel
+java/awt/FlowLayout
+javax/swing/plaf/basic/BasicPanelUI
+javax/swing/plaf/PanelUI
+java/awt/Component$BaselineResizeBehavior
+sun/swing/SwingLazyValue$1
+javax/swing/JLayeredPane
+javax/swing/JRootPane$1
+javax/swing/ArrayTable
+javax/swing/JRootPane$RootLayout
+javax/swing/BufferStrategyPaintManager
+javax/swing/RepaintManager$PaintManager
+javax/swing/FocusManager
+javax/swing/LayoutFocusTraversalPolicy
+javax/swing/SortingFocusTraversalPolicy
+javax/swing/InternalFrameFocusTraversalPolicy
+javax/swing/SwingContainerOrderFocusTraversalPolicy
+javax/swing/SortingFocusTraversalPolicy$1
+java/util/Spliterator$OfLong
+java/util/Spliterator$OfPrimitive
+java/util/Spliterator
+java/util/Spliterator$OfInt
+java/util/Spliterator$OfDouble
+java/util/stream/IntStream
+java/util/stream/BaseStream
+java/util/stream/Stream
+java/util/stream/DoubleStream
+java/util/stream/LongStream
+java/util/function/DoubleBinaryOperator
+java/util/function/IntBinaryOperator
+java/util/function/LongBinaryOperator
+java/util/function/BinaryOperator
+java/util/function/BiFunction
+java/util/function/IntToDoubleFunction
+java/util/function/IntFunction
+java/util/function/IntToLongFunction
+java/util/function/IntUnaryOperator
+javax/swing/SwingDefaultFocusTraversalPolicy
+javax/swing/LayoutComparator
+javax/swing/plaf/metal/MetalRootPaneUI
+javax/swing/plaf/basic/BasicRootPaneUI
+javax/swing/plaf/RootPaneUI
+javax/swing/plaf/basic/BasicRootPaneUI$RootPaneInputMap
+javax/swing/plaf/ComponentInputMapUIResource
+javax/swing/ComponentInputMap
+javax/swing/InputMap
+javax/swing/plaf/InputMapUIResource
+javax/swing/KeyStroke
+java/awt/VKCollection
+sun/reflect/UnsafeQualifiedStaticIntegerFieldAccessorImpl
+javax/swing/plaf/basic/LazyActionMap
+javax/swing/plaf/ActionMapUIResource
+javax/swing/ActionMap
+sun/awt/X11/XFramePeer
+java/awt/peer/FramePeer
+java/awt/peer/WindowPeer
+java/awt/peer/ContainerPeer
+java/awt/peer/ComponentPeer
+sun/awt/X11/XDecoratedPeer
+sun/awt/X11/XWindowPeer
+sun/awt/X11/XPanelPeer
+java/awt/peer/PanelPeer
+sun/awt/X11/XCanvasPeer
+java/awt/peer/CanvasPeer
+sun/awt/X11/XComponentPeer
+java/awt/dnd/peer/DropTargetPeer
+sun/java2d/BackBufferCapsProvider
+sun/awt/X11/XWindow
+sun/awt/X11ComponentPeer
+sun/awt/X11/XBaseWindow
+sun/awt/X11/XCreateWindowParams
+sun/awt/X11/XBaseWindow$InitialiseState
+sun/awt/X11/XBaseWindow$StateLock
+sun/awt/X11/AwtGraphicsConfigData
+sun/awt/X11/XVisualInfo
+java/awt/SystemColor
+sun/awt/AWTAccessor$SystemColorAccessor
+sun/awt/X11/MotifColorUtilities
+sun/awt/X11/XRepaintArea
+sun/awt/RepaintArea
+sun/awt/X11/XWindowAttributesData
+sun/awt/X11/WindowDimensions
+java/awt/Point
+java/awt/geom/Point2D
+java/util/TreeMap$Entry
+sun/awt/X11/XSizeHints
+sun/awt/X11/XRootWindow
+sun/awt/X11/XRootWindow$LazyHolder
+sun/nio/cs/ISO_8859_1$Encoder
+sun/nio/cs/Surrogate$Parser
+sun/nio/cs/Surrogate
+sun/java2d/x11/X11SurfaceData$X11WindowSurfaceData
+sun/awt/X11/XDropTargetEventProcessor
+sun/java2d/loops/RenderLoops
+sun/awt/X11/XDragSourceContextPeer
+sun/java2d/loops/GraphicsPrimitiveMgr$PrimitiveSpec
+sun/awt/X11/XDragSourceProtocolListener
+java/util/Arrays$LegacyMergeSort
+sun/awt/dnd/SunDragSourceContextPeer
+java/awt/dnd/peer/DragSourceContextPeer
+java/util/TimSort
+sun/awt/X11/XAnyEvent
+sun/awt/X11/XAwtState
+sun/awt/X11/XBaseWindow$1
+sun/awt/X11/XPropertyEvent
+sun/java2d/DefaultDisposerRecord
+sun/java2d/SurfaceDataProxy
+sun/awt/image/SurfaceManager$FlushableCacheData
+sun/java2d/SurfaceDataProxy$1
+sun/java2d/StateTracker
+sun/java2d/StateTracker$1
+sun/java2d/StateTracker$2
+sun/java2d/x11/X11Renderer
+sun/awt/X11/XGlobalCursorManager
+sun/awt/GlobalCursorManager
+sun/awt/IconInfo
+sun/awt/AWTIcon32_java_icon16_png
+sun/awt/AWTIcon32_java_icon24_png
+sun/awt/AWTIcon32_java_icon32_png
+sun/awt/AWTIcon32_java_icon48_png
+sun/awt/X11/XClientMessageEvent
+sun/awt/X11/XContentWindow
+sun/awt/X11/XFocusProxyWindow
+sun/awt/X11/XWMHints
+java/util/LinkedList$ListItr
+sun/awt/AWTAutoShutdown
+java/awt/peer/LightweightPeer
+sun/awt/NullComponentPeer
+java/awt/SplashScreen
+java/awt/Dialog
+java/awt/Dialog$ModalityType
+sun/awt/X11/PropMwmHints
+sun/awt/X11/XWindowPeer$4
+sun/awt/GlobalCursorManager$NativeUpdater
+java/awt/event/WindowEvent
+java/awt/EventQueue$5
+java/awt/EventDispatchThread
+sun/awt/PeerEvent
+java/awt/EventDispatchThread$1
+java/awt/Conditional
+java/awt/event/InvocationEvent
+java/awt/ActiveEvent
+java/awt/EventDispatchThread$HierarchyEventFilter
+java/awt/EventFilter
+java/awt/event/PaintEvent
+sun/awt/X11/XReparentEvent
+java/awt/event/MouseEvent
+java/awt/ModalEventFilter
+sun/awt/EventQueueItem
+sun/awt/EventQueueDelegate
+java/awt/EventFilter$FilterAction
+java/awt/EventQueue$3
+java/awt/EventQueue$4
+sun/awt/dnd/SunDropTargetEvent
+sun/awt/X11/XConfigureEvent
+java/awt/event/InputMethodEvent
+java/awt/event/ActionEvent
+java/awt/event/FocusEvent
+java/util/Vector$Itr
+java/awt/event/InvocationEvent$1
+sun/awt/X11/XWindowPeer$2
+sun/awt/AWTAccessor$InvocationEventAccessor
+java/applet/Applet
+java/awt/Panel
+sun/awt/X11/XVisibilityEvent
+sun/awt/X11/XExposeEvent
+sun/awt/event/IgnorePaintEvent
+sun/awt/X11/XTranslateCoordinates
+sun/awt/X11/XFocusChangeEvent
+java/awt/SequencedEvent
+java/awt/SequencedEvent$1
+sun/awt/AWTAccessor$SequencedEventAccessor
+sun/awt/X11/XComponentPeer$1
+java/awt/MenuComponent
+java/awt/TrayIcon
+java/util/IdentityHashMap$KeySet
+java/util/IdentityHashMap$KeyIterator
+javax/swing/RepaintManager$4
+java/awt/GraphicsCallback$PaintCallback
+java/awt/GraphicsCallback
+sun/awt/SunGraphicsCallback
+javax/swing/BufferStrategyPaintManager$BufferInfo
+java/awt/event/WindowListener
+java/awt/event/ComponentAdapter
+java/awt/event/ComponentListener
+java/awt/AWTEventMulticaster
+java/awt/event/ContainerListener
+java/awt/event/FocusListener
+java/awt/event/KeyListener
+java/awt/event/MouseListener
+java/awt/event/MouseMotionListener
+java/awt/event/WindowFocusListener
+java/awt/event/WindowStateListener
+java/awt/event/ActionListener
+java/awt/event/ItemListener
+java/awt/event/AdjustmentListener
+java/awt/event/TextListener
+java/awt/event/InputMethodListener
+java/awt/event/HierarchyListener
+java/awt/event/HierarchyBoundsListener
+java/awt/event/MouseWheelListener
+java/awt/BufferCapabilities
+java/awt/Component$BltSubRegionBufferStrategy
+sun/awt/SubRegionShowable
+java/awt/Component$BltBufferStrategy
+java/awt/image/BufferStrategy
+java/awt/image/VolatileImage
+java/awt/Image
+sun/awt/image/SunVolatileImage
+java/awt/Image$1
+sun/awt/image/SurfaceManager$ImageAccessor
+sun/awt/image/SurfaceManager
+sun/awt/image/BufferedImageGraphicsConfig
+sun/print/PrinterGraphicsConfig
+sun/java2d/opengl/GLXGraphicsConfig
+sun/java2d/opengl/OGLGraphicsConfig
+sun/java2d/pipe/hw/AccelGraphicsConfig
+sun/java2d/pipe/hw/BufferedContextProvider
+sun/java2d/xr/XRGraphicsConfig
+sun/java2d/x11/X11VolatileSurfaceManager
+sun/awt/image/VolatileSurfaceManager
+sun/java2d/x11/X11SurfaceData$X11PixmapSurfaceData
+sun/font/FontDesignMetrics
+java/awt/FontMetrics
+sun/font/SunFontManager
+sun/java2d/FontSupport
+sun/font/FontManagerForSGE
+sun/font/FontManager
+sun/font/SunFontManager$TTFilter
+java/io/FilenameFilter
+sun/font/SunFontManager$T1Filter
+sun/font/SunFontManager$1
+sun/font/FontManagerNativeLibrary
+sun/font/FontManagerNativeLibrary$1
+sun/font/FontUtilities
+sun/font/FontUtilities$1
+sun/font/TrueTypeFont
+sun/font/FileFont
+sun/font/PhysicalFont
+sun/font/Font2D
+sun/font/Type1Font
+java/awt/geom/Point2D$Float
+sun/font/StrikeMetrics
+java/awt/geom/Rectangle2D$Float
+java/awt/geom/GeneralPath
+sun/font/CharToGlyphMapper
+sun/font/PhysicalStrike
+sun/font/FontStrike
+sun/font/StrikeCache
+sun/font/StrikeCache$1
+sun/font/GlyphList
+sun/font/FontManagerFactory
+sun/font/FontManagerFactory$1
+sun/awt/X11FontManager
+sun/font/CompositeFont
+sun/font/SunFontManager$2
+java/io/StreamTokenizer
+sun/font/SunFontManager$FontRegistrationInfo
+sun/awt/motif/MFontConfiguration
+sun/awt/FontConfiguration
+sun/awt/FontDescriptor
+java/util/Properties$LineReader
+sun/font/FcFontConfiguration
+java/net/InetAddress
+java/net/InetAddress$1
+java/net/InetAddress$InetAddressHolder
+java/net/InetAddress$Cache
+java/net/InetAddress$Cache$Type
+java/net/InetAddressImplFactory
+java/net/Inet4AddressImpl
+java/net/InetAddressImpl
+java/net/InetAddress$2
+sun/net/spi/nameservice/NameService
+java/net/Inet4Address
+java/net/Inet6Address
+java/net/Inet6Address$Inet6AddressHolder
+sun/net/InetAddressCachePolicy
+sun/net/InetAddressCachePolicy$1
+java/security/Security
+java/security/Security$1
+sun/net/InetAddressCachePolicy$2
+java/util/LinkedHashMap$LinkedKeySet
+java/util/LinkedHashMap$LinkedKeyIterator
+java/net/InetAddress$CacheEntry
+sun/font/FontConfigManager$FcCompFont
+sun/font/FontConfigManager$FontConfigFont
+sun/font/CompositeFontDescriptor
+sun/font/Font2DHandle
+sun/font/FontFamily
+sun/font/SunFontManager$3
+sun/font/FontDesignMetrics$MetricsKey
+sun/font/FontStrikeDesc
+sun/font/CompositeStrike
+sun/font/FontStrikeDisposer
+sun/java2d/Disposer$PollDisposable
+sun/font/StrikeCache$SoftDisposerRef
+sun/font/StrikeCache$DisposableStrike
+sun/font/TrueTypeFont$TTDisposerRecord
+sun/font/TrueTypeFont$1
+java/io/RandomAccessFile
+java/io/DataOutput
+java/io/DataInput
+sun/nio/ch/FileChannelImpl
+java/nio/channels/FileChannel
+java/nio/channels/SeekableByteChannel
+java/nio/channels/ByteChannel
+java/nio/channels/ReadableByteChannel
+java/nio/channels/Channel
+java/nio/channels/WritableByteChannel
+java/nio/channels/GatheringByteChannel
+java/nio/channels/ScatteringByteChannel
+java/nio/channels/spi/AbstractInterruptibleChannel
+java/nio/channels/InterruptibleChannel
+java/nio/file/attribute/FileAttribute
+sun/nio/ch/IOUtil
+sun/nio/ch/IOUtil$1
+sun/nio/ch/NativeThreadSet
+sun/nio/ch/FileDispatcherImpl
+sun/nio/ch/FileDispatcher
+sun/nio/ch/NativeDispatcher
+java/nio/channels/spi/AbstractInterruptibleChannel$1
+sun/nio/ch/NativeThread
+sun/nio/ch/IOStatus
+sun/nio/ch/Util
+sun/nio/ch/Util$1
+sun/nio/ch/Util$BufferCache
+java/nio/DirectByteBuffer$Deallocator
+java/nio/ByteBufferAsIntBufferB
+java/nio/IntBuffer
+sun/font/TrueTypeFont$DirectoryEntry
+java/nio/ByteBufferAsShortBufferB
+java/nio/ShortBuffer
+sun/nio/cs/UTF_16$Decoder
+sun/nio/cs/UnicodeDecoder
+sun/font/FileFontStrike
+sun/font/FontScaler
+sun/font/T2KFontScaler
+sun/font/T2KFontScaler$1
+sun/font/TrueTypeGlyphMapper
+sun/font/CMap
+sun/font/CMap$NullCMapClass
+sun/font/CMap$CMapFormat12
+sun/font/FontDesignMetrics$KeyReference
+sun/font/CompositeGlyphMapper
+java/awt/print/PrinterGraphics
+java/awt/PrintGraphics
+sun/java2d/loops/FontInfo
+sun/awt/X11/XSystemTrayPeer
+java/awt/peer/SystemTrayPeer
+java/util/jar/Attributes
+java/util/jar/Manifest$FastInputStream
+java/util/jar/Attributes$Name
+sun/misc/ASCIICaseInsensitiveComparator
+java/util/jar/JarVerifier
+java/security/CodeSigner
+java/util/jar/JarVerifier$3
+java/io/ByteArrayOutputStream
+java/lang/Package
+sun/security/util/SignatureFileVerifier
+sun/security/util/ManifestEntryVerifier
+java/util/MissingResourceException
+javax/swing/JDialog
+javax/swing/text/JTextComponent
+javax/swing/Scrollable
+javax/swing/JTextArea
+javax/swing/JScrollPane
+javax/swing/ScrollPaneConstants
+javax/swing/AbstractButton
+java/awt/ItemSelectable
+javax/swing/JButton
+java/io/StringWriter
+java/lang/SecurityException
+javax/swing/JWindow
+java/io/UnsupportedEncodingException
+sun/misc/URLClassPath$FileLoader
+java/lang/CloneNotSupportedException
+java/lang/InternalError
+java/net/UnknownHostException
+java/net/Socket
+java/net/SocketAddress
+java/nio/channels/SocketChannel
+java/nio/channels/NetworkChannel
+java/nio/channels/spi/AbstractSelectableChannel
+java/nio/channels/SelectableChannel
+java/net/SocketException
+java/net/SocketImplFactory
+java/net/InetSocketAddress
+java/net/InetSocketAddress$InetSocketAddressHolder
+java/net/Proxy
+java/net/SocketImpl
+java/net/SocketOptions
+java/net/SocksSocketImpl
+java/net/SocksConsts
+java/net/PlainSocketImpl
+java/net/AbstractPlainSocketImpl
+java/net/AbstractPlainSocketImpl$1
+sun/net/util/IPAddressUtil
+java/net/SocksSocketImpl$3
+java/net/ProxySelector
+sun/net/spi/DefaultProxySelector
+sun/net/spi/DefaultProxySelector$1
+sun/net/NetProperties
+sun/net/NetProperties$1
+java/net/URI
+java/net/URI$Parser
+sun/net/spi/DefaultProxySelector$NonProxyInfo
+sun/net/spi/DefaultProxySelector$3
+java/net/Proxy$Type
+sun/net/NetHooks
+sun/net/sdp/SdpProvider
+sun/net/NetHooks$Provider
+java/net/ConnectException
+java/net/MalformedURLException
+java/lang/UnsatisfiedLinkError
+javax/swing/UnsupportedLookAndFeelException
+sun/misc/FloatingDecimal$ASCIIToBinaryBuffer
+sun/misc/FDBigInteger
+java/util/ResourceBundle$Control$1
+java/net/URLClassLoader$2
+java/util/PropertyResourceBundle
+java/util/ResourceBundle$BundleReference
+java/util/logging/Level
+java/util/logging/Level$KnownLevel
+java/util/logging/Logger
+java/util/logging/Handler
+java/util/logging/Logger$LoggerBundle
+java/util/concurrent/CopyOnWriteArrayList
+java/util/logging/LogManager
+java/util/logging/LogManager$1
+java/util/logging/LogManager$SystemLoggerContext
+java/util/logging/LogManager$LoggerContext
+java/util/logging/LogManager$LogNode
+java/util/logging/LoggingPermission
+java/util/logging/LogManager$Cleaner
+java/util/logging/LogManager$2
+java/util/logging/LogManager$3
+java/util/logging/LogManager$LoggerWeakRef
+java/util/logging/LogManager$LoggerContext$1
+java/util/logging/LogManager$RootLogger
+java/util/logging/LogManager$5
+java/util/logging/Logger$1
+sun/util/logging/resources/logging
+javax/swing/Box
+javax/swing/Box$Filler
+javax/swing/Icon
+javax/swing/BoxLayout
+javax/swing/plaf/basic/BasicPopupMenuUI
+javax/swing/plaf/PopupMenuUI
+javax/swing/ImageIcon
+javax/swing/ImageIcon$1
+javax/swing/ImageIcon$2
+javax/swing/ImageIcon$2$1
+java/awt/dnd/DropTarget
+java/awt/dnd/DropTargetListener
+javax/accessibility/AccessibleContext
+sun/reflect/UnsafeObjectFieldAccessorImpl
+java/awt/MediaTracker
+sun/misc/SoftCache$ValueCell
+sun/awt/image/URLImageSource
+sun/awt/image/InputStreamImageSource
+java/awt/image/ImageProducer
+sun/awt/image/ImageFetchable
+sun/awt/image/ToolkitImage
+sun/awt/image/NativeLibLoader
+sun/awt/image/NativeLibLoader$1
+javax/swing/ImageIcon$3
+java/awt/ImageMediaEntry
+java/awt/MediaEntry
+sun/awt/image/MultiResolutionToolkitImage
+sun/awt/image/MultiResolutionImage
+sun/awt/image/ImageRepresentation
+java/awt/image/ImageConsumer
+sun/awt/image/ImageWatched
+sun/awt/image/ImageWatched$Link
+sun/awt/image/ImageWatched$WeakLink
+sun/awt/image/ImageConsumerQueue
+sun/awt/image/ImageFetcher
+sun/awt/image/FetcherInfo
+sun/awt/image/ImageFetcher$1
+sun/net/ProgressMonitor
+sun/net/DefaultProgressMeteringPolicy
+sun/net/ProgressMeteringPolicy
+sun/net/www/MimeTable
+java/net/FileNameMap
+sun/net/www/MimeTable$1
+sun/net/www/MimeTable$DefaultInstanceHolder
+sun/net/www/MimeTable$DefaultInstanceHolder$1
+sun/net/www/MimeEntry
+java/net/URLConnection$1
+java/text/SimpleDateFormat
+java/text/DateFormat
+java/text/Format
+java/text/DateFormat$Field
+java/text/Format$Field
+java/util/TimeZone
+sun/util/calendar/ZoneInfo
+sun/util/calendar/ZoneInfoFile
+sun/util/calendar/ZoneInfoFile$1
+java/io/DataInputStream
+sun/util/calendar/ZoneInfoFile$ZoneOffsetTransitionRule
+sun/util/calendar/ZoneInfoFile$Checksum
+java/util/zip/CRC32
+java/util/zip/Checksum
+java/util/TimeZone$1
+java/util/Calendar
+sun/util/spi/CalendarProvider
+java/util/spi/LocaleServiceProvider
+sun/util/locale/provider/LocaleProviderAdapter
+sun/util/locale/provider/JRELocaleProviderAdapter
+sun/util/locale/provider/ResourceBundleBasedAdapter
+sun/util/locale/provider/SPILocaleProviderAdapter
+sun/util/locale/provider/AuxLocaleProviderAdapter
+sun/util/locale/provider/AuxLocaleProviderAdapter$NullProvider
+sun/util/locale/provider/LocaleProviderAdapter$Type
+sun/util/locale/provider/LocaleProviderAdapter$1
+sun/util/locale/provider/CalendarProviderImpl
+sun/util/locale/provider/AvailableLanguageTags
+sun/util/locale/provider/LocaleDataMetaInfo
+sun/util/locale/provider/JRELocaleProviderAdapter$1
+java/util/Calendar$Builder
+java/util/GregorianCalendar
+sun/util/locale/provider/CalendarDataUtility
+java/util/spi/CalendarDataProvider
+sun/util/locale/provider/LocaleServiceProviderPool
+java/text/spi/BreakIteratorProvider
+java/text/spi/CollatorProvider
+java/text/spi/DateFormatProvider
+java/text/spi/DateFormatSymbolsProvider
+java/text/spi/DecimalFormatSymbolsProvider
+java/text/spi/NumberFormatProvider
+java/util/spi/CurrencyNameProvider
+java/util/spi/LocaleNameProvider
+java/util/spi/TimeZoneNameProvider
+sun/util/locale/provider/CalendarDataProviderImpl
+sun/util/locale/provider/SPILocaleProviderAdapter$1
+sun/util/locale/provider/CalendarDataUtility$CalendarWeekParameterGetter
+sun/util/locale/provider/LocaleServiceProviderPool$LocalizedObjectGetter
+sun/util/locale/provider/LocaleResources
+sun/util/resources/LocaleData
+sun/util/resources/LocaleData$1
+sun/util/resources/LocaleData$LocaleDataResourceBundleControl
+sun/util/locale/LanguageTag
+java/util/Collections$EmptyIterator
+sun/util/resources/CalendarData
+sun/util/resources/LocaleNamesBundle
+sun/util/resources/OpenListResourceBundle
+sun/util/resources/en/CalendarData_en
+sun/util/locale/provider/LocaleResources$ResourceReference
+sun/util/calendar/Gregorian$Date
+sun/util/calendar/BaseCalendar$Date
+sun/util/calendar/CalendarDate
+sun/util/calendar/CalendarUtils
+java/text/DateFormatSymbols
+sun/util/locale/provider/DateFormatSymbolsProviderImpl
+sun/text/resources/FormatData
+sun/util/resources/ParallelListResourceBundle
+java/util/concurrent/atomic/AtomicMarkableReference
+java/util/concurrent/atomic/AtomicMarkableReference$Pair
+sun/text/resources/en/FormatData_en
+sun/text/resources/en/FormatData_en_US
+sun/util/resources/ParallelListResourceBundle$KeySet
+java/text/NumberFormat
+sun/util/locale/provider/NumberFormatProviderImpl
+java/text/DecimalFormatSymbols
+sun/util/locale/provider/DecimalFormatSymbolsProviderImpl
+java/util/Currency
+java/util/Currency$1
+sun/util/locale/provider/CurrencyNameProviderImpl
+java/util/Currency$CurrencyNameGetter
+sun/util/resources/CurrencyNames
+sun/util/resources/en/CurrencyNames_en_US
+java/text/DecimalFormat
+java/text/FieldPosition
+java/text/DigitList
+java/math/RoundingMode
+java/text/DontCareFieldPosition
+java/text/DontCareFieldPosition$1
+java/text/Format$FieldDelegate
+sun/awt/image/GifImageDecoder
+sun/awt/image/ImageDecoder
+sun/awt/image/GifFrame
+java/awt/image/Raster
+java/awt/image/DataBufferByte
+java/awt/image/DataBuffer
+java/awt/image/DataBuffer$1
+sun/awt/image/SunWritableRaster$DataStealer
+sun/awt/image/SunWritableRaster
+java/awt/image/WritableRaster
+java/awt/image/PixelInterleavedSampleModel
+java/awt/image/ComponentSampleModel
+java/awt/image/SampleModel
+sun/awt/image/ByteInterleavedRaster
+sun/awt/image/ByteComponentRaster
+java/awt/image/BufferedImage
+java/awt/image/WritableRenderedImage
+java/awt/image/RenderedImage
+java/awt/image/BufferedImage$1
+sun/awt/image/IntegerComponentRaster
+sun/awt/image/BytePackedRaster
+javax/swing/plaf/BorderUIResource
+javax/swing/BorderFactory
+javax/swing/border/BevelBorder
+javax/swing/border/EtchedBorder
+javax/swing/plaf/metal/MetalIconFactory
+javax/swing/plaf/metal/MetalIconFactory$TreeFolderIcon
+javax/swing/plaf/metal/MetalIconFactory$FolderIcon16
+java/util/zip/ZipInputStream
+java/io/PushbackInputStream
+java/util/zip/ZipUtils
+java/io/RandomAccessFile$1
+java/lang/Thread$State
+javax/swing/SwingUtilities$SharedOwnerFrame
+sun/awt/X11/XWindowAttributes
+javax/swing/border/LineBorder
+javax/swing/SizeRequirements
+java/util/ArrayList$ListItr
+javax/swing/CellRendererPane
+javax/swing/RepaintManager$3
+javax/swing/JRadioButton
+javax/swing/JToggleButton
+java/lang/ClassFormatError
+java/io/ObjectInputStream
+java/io/ObjectInput
+java/io/ObjectStreamConstants
+sun/awt/image/BufImgSurfaceManager
+sun/awt/image/BufImgSurfaceData
+sun/awt/image/BufImgSurfaceData$ICMColorData
+sun/java2d/x11/X11SurfaceDataProxy
+sun/java2d/x11/X11SurfaceDataProxy$Bitmask
+sun/java2d/StateTrackableDelegate$1
+javax/swing/JTabbedPane
+java/awt/geom/RectIterator
+java/awt/geom/PathIterator
+javax/swing/event/ChangeListener
+java/awt/Polygon
+javax/swing/event/MenuListener
+javax/swing/DefaultSingleSelectionModel
+javax/swing/SingleSelectionModel
+javax/swing/JTabbedPane$ModelListener
+javax/swing/plaf/metal/MetalTabbedPaneUI
+javax/swing/plaf/basic/BasicTabbedPaneUI
+javax/swing/plaf/TabbedPaneUI
+javax/swing/plaf/metal/MetalTabbedPaneUI$TabbedPaneLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$TabbedPaneLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$TabbedPaneScrollLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$Handler
+sun/reflect/MethodAccessorGenerator
+sun/reflect/AccessorGenerator
+sun/reflect/ClassFileConstants
+sun/reflect/ByteVectorFactory
+sun/reflect/ByteVectorImpl
+sun/reflect/ByteVector
+sun/reflect/ClassFileAssembler
+sun/reflect/UTF8
+sun/reflect/Label
+sun/reflect/Label$PatchInfo
+sun/reflect/MethodAccessorGenerator$1
+sun/reflect/ClassDefiner
+sun/reflect/ClassDefiner$1
+sun/reflect/BootstrapConstructorAccessorImpl
+javax/swing/JTextField
+javax/swing/JViewport
+java/awt/CardLayout
+javax/swing/text/Document
+javax/swing/text/JTextComponent$1
+sun/swing/SwingAccessor$JTextComponentAccessor
+javax/swing/text/JTextComponent$4
+com/sun/beans/util/Cache
+com/sun/beans/util/Cache$Kind
+com/sun/beans/util/Cache$Kind$1
+com/sun/beans/util/Cache$Kind$2
+com/sun/beans/util/Cache$Kind$3
+com/sun/beans/util/Cache$CacheEntry
+javax/swing/Action
+javax/swing/JTextField$NotifyAction
+javax/swing/text/TextAction
+javax/swing/AbstractAction
+java/lang/ArrayIndexOutOfBoundsException
+javax/swing/DropMode
+javax/swing/text/JTextComponent$MutableCaretEvent
+javax/swing/event/CaretEvent
+javax/swing/plaf/metal/MetalTextFieldUI
+javax/swing/plaf/basic/BasicTextFieldUI
+javax/swing/plaf/basic/BasicTextUI
+javax/swing/text/ViewFactory
+javax/swing/plaf/TextUI
+javax/swing/plaf/basic/BasicTextUI$BasicCursor
+javax/swing/text/DefaultEditorKit
+javax/swing/text/EditorKit
+javax/swing/text/DefaultEditorKit$InsertContentAction
+javax/swing/text/DefaultEditorKit$DeletePrevCharAction
+javax/swing/text/DefaultEditorKit$DeleteNextCharAction
+javax/swing/text/DefaultEditorKit$ReadOnlyAction
+javax/swing/text/DefaultEditorKit$DeleteWordAction
+javax/swing/text/DefaultEditorKit$WritableAction
+javax/swing/text/DefaultEditorKit$CutAction
+javax/swing/text/DefaultEditorKit$CopyAction
+javax/swing/text/DefaultEditorKit$PasteAction
+javax/swing/text/DefaultEditorKit$VerticalPageAction
+javax/swing/text/DefaultEditorKit$PageAction
+javax/swing/text/DefaultEditorKit$InsertBreakAction
+javax/swing/text/DefaultEditorKit$BeepAction
+javax/swing/text/DefaultEditorKit$NextVisualPositionAction
+javax/swing/text/DefaultEditorKit$BeginWordAction
+javax/swing/text/DefaultEditorKit$EndWordAction
+javax/swing/text/DefaultEditorKit$PreviousWordAction
+javax/swing/text/DefaultEditorKit$NextWordAction
+javax/swing/text/DefaultEditorKit$BeginLineAction
+javax/swing/text/DefaultEditorKit$EndLineAction
+javax/swing/text/DefaultEditorKit$BeginParagraphAction
+javax/swing/text/DefaultEditorKit$EndParagraphAction
+javax/swing/text/DefaultEditorKit$BeginAction
+javax/swing/text/DefaultEditorKit$EndAction
+javax/swing/text/DefaultEditorKit$DefaultKeyTypedAction
+javax/swing/text/DefaultEditorKit$InsertTabAction
+javax/swing/text/DefaultEditorKit$SelectWordAction
+javax/swing/text/DefaultEditorKit$SelectLineAction
+javax/swing/text/DefaultEditorKit$SelectParagraphAction
+javax/swing/text/DefaultEditorKit$SelectAllAction
+javax/swing/text/DefaultEditorKit$UnselectAction
+javax/swing/text/DefaultEditorKit$ToggleComponentOrientationAction
+javax/swing/text/DefaultEditorKit$DumpModelAction
+javax/swing/plaf/basic/BasicTextUI$TextTransferHandler
+javax/swing/TransferHandler
+javax/swing/TransferHandler$TransferAction
+sun/swing/UIAction
+javax/swing/text/Position$Bias
+javax/swing/plaf/basic/BasicTextUI$RootView
+javax/swing/text/View
+javax/swing/plaf/basic/BasicTextUI$UpdateHandler
+javax/swing/event/DocumentListener
+javax/swing/plaf/basic/BasicTextUI$DragListener
+javax/swing/plaf/basic/DragRecognitionSupport$BeforeDrag
+javax/swing/event/MouseInputAdapter
+javax/swing/event/MouseInputListener
+java/awt/event/MouseAdapter
+javax/swing/plaf/metal/MetalBorders
+javax/swing/plaf/BorderUIResource$CompoundBorderUIResource
+javax/swing/border/CompoundBorder
+javax/swing/plaf/metal/MetalBorders$TextFieldBorder
+javax/swing/plaf/metal/MetalBorders$Flush3DBorder
+javax/swing/plaf/basic/BasicBorders$MarginBorder
+javax/swing/plaf/basic/BasicTextUI$BasicCaret
+javax/swing/text/DefaultCaret
+javax/swing/text/Caret
+javax/swing/text/DefaultCaret$Handler
+java/awt/datatransfer/ClipboardOwner
+javax/swing/Timer
+javax/swing/Timer$DoPostEvent
+javax/swing/plaf/basic/BasicTextUI$BasicHighlighter
+javax/swing/text/DefaultHighlighter
+javax/swing/text/LayeredHighlighter
+javax/swing/text/Highlighter
+javax/swing/text/Highlighter$Highlight
+javax/swing/text/DefaultHighlighter$DefaultHighlightPainter
+javax/swing/text/LayeredHighlighter$LayerPainter
+javax/swing/text/Highlighter$HighlightPainter
+javax/swing/text/DefaultHighlighter$SafeDamager
+javax/swing/ClientPropertyKey
+javax/swing/ClientPropertyKey$1
+sun/awt/AWTAccessor$ClientPropertyKeyAccessor
+javax/swing/TransferHandler$SwingDropTarget
+java/awt/dnd/DropTargetContext
+java/awt/datatransfer/SystemFlavorMap
+java/awt/datatransfer/FlavorMap
+java/awt/datatransfer/FlavorTable
+java/awt/datatransfer/SystemFlavorMap$SoftCache
+javax/swing/TransferHandler$DropHandler
+javax/swing/TransferHandler$TransferSupport
+javax/swing/text/PlainDocument
+javax/swing/text/AbstractDocument
+javax/swing/text/GapContent
+javax/swing/text/AbstractDocument$Content
+javax/swing/text/GapVector
+javax/swing/text/GapContent$MarkVector
+javax/swing/text/GapContent$MarkData
+javax/swing/text/StyleContext
+javax/swing/text/AbstractDocument$AttributeContext
+javax/swing/text/StyleConstants
+javax/swing/text/StyleConstants$CharacterConstants
+javax/swing/text/AttributeSet$CharacterAttribute
+javax/swing/text/StyleConstants$FontConstants
+javax/swing/text/AttributeSet$FontAttribute
+javax/swing/text/StyleConstants$ColorConstants
+javax/swing/text/AttributeSet$ColorAttribute
+javax/swing/text/StyleConstants$ParagraphConstants
+javax/swing/text/AttributeSet$ParagraphAttribute
+javax/swing/text/StyleContext$FontKey
+javax/swing/text/SimpleAttributeSet
+javax/swing/text/MutableAttributeSet
+javax/swing/text/AttributeSet
+javax/swing/text/SimpleAttributeSet$EmptyAttributeSet
+javax/swing/text/StyleContext$NamedStyle
+javax/swing/text/Style
+java/util/Collections$EmptyEnumeration
+javax/swing/text/StyleContext$SmallAttributeSet
+java/util/Collections$3
+javax/swing/text/AbstractDocument$BidiRootElement
+javax/swing/text/AbstractDocument$BranchElement
+javax/swing/text/AbstractDocument$AbstractElement
+javax/swing/text/Element
+javax/swing/tree/TreeNode
+javax/swing/text/AbstractDocument$1
+javax/swing/text/AbstractDocument$BidiElement
+javax/swing/text/AbstractDocument$LeafElement
+javax/swing/text/GapContent$StickyPosition
+javax/swing/text/Position
+javax/swing/text/StyleContext$KeyEnumeration
+javax/swing/text/FieldView
+javax/swing/text/PlainView
+javax/swing/text/TabExpander
+javax/swing/text/JTextComponent$DefaultKeymap
+javax/swing/text/Keymap
+javax/swing/text/JTextComponent$KeymapWrapper
+javax/swing/text/JTextComponent$KeymapActionMap
+javax/swing/plaf/basic/BasicTextUI$FocusAction
+javax/swing/plaf/basic/BasicTextUI$TextActionWrapper
+javax/swing/plaf/synth/SynthUI
+javax/swing/plaf/synth/SynthConstants
+javax/swing/JEditorPane
+javax/swing/DefaultBoundedRangeModel
+javax/swing/BoundedRangeModel
+javax/swing/JTextField$ScrollRepainter
+javax/swing/DefaultButtonModel
+javax/swing/ButtonModel
+javax/swing/AbstractButton$Handler
+javax/swing/plaf/basic/BasicButtonUI
+javax/swing/plaf/ButtonUI
+javax/swing/plaf/metal/MetalBorders$ButtonBorder
+javax/swing/plaf/basic/BasicButtonListener
+javax/swing/event/AncestorListener
+java/beans/VetoableChangeListener
+javax/swing/plaf/metal/MetalComboBoxButton
+javax/swing/plaf/basic/BasicArrowButton
+javax/swing/plaf/metal/MetalScrollButton
+sun/swing/ImageIconUIResource
+javax/swing/GrayFilter
+java/awt/image/RGBImageFilter
+java/awt/image/ImageFilter
+java/awt/image/FilteredImageSource
+javax/swing/plaf/basic/BasicGraphicsUtils
+javax/swing/ButtonGroup
+org/w3c/dom/Node
+org/xml/sax/SAXException
+javax/xml/parsers/ParserConfigurationException
+org/xml/sax/EntityResolver
+java/security/NoSuchAlgorithmException
+java/security/GeneralSecurityException
+java/util/zip/GZIPInputStream
+java/util/zip/DeflaterOutputStream
+java/io/StringReader
+org/xml/sax/InputSource
+javax/xml/parsers/DocumentBuilderFactory
+javax/xml/parsers/FactoryFinder
+javax/xml/parsers/SecuritySupport
+javax/xml/parsers/SecuritySupport$2
+javax/xml/parsers/SecuritySupport$5
+javax/xml/parsers/FactoryFinder$1
+javax/xml/parsers/DocumentBuilder
+org/xml/sax/ErrorHandler
+org/w3c/dom/Document
+org/xml/sax/helpers/DefaultHandler
+org/xml/sax/DTDHandler
+org/xml/sax/ContentHandler
+org/xml/sax/SAXNotRecognizedException
+org/xml/sax/SAXNotSupportedException
+org/xml/sax/Locator
+org/xml/sax/SAXParseException
+org/w3c/dom/NodeList
+org/w3c/dom/events/EventTarget
+org/w3c/dom/traversal/DocumentTraversal
+org/w3c/dom/events/DocumentEvent
+org/w3c/dom/ranges/DocumentRange
+org/w3c/dom/Element
+org/w3c/dom/CharacterData
+org/w3c/dom/CDATASection
+org/w3c/dom/Text
+org/w3c/dom/Entity
+org/xml/sax/AttributeList
+org/w3c/dom/DOMException
+org/w3c/dom/DocumentType
+org/w3c/dom/Attr
+org/w3c/dom/EntityReference
+org/w3c/dom/DocumentFragment
+org/w3c/dom/ProcessingInstruction
+org/w3c/dom/Notation
+org/w3c/dom/Comment
+org/w3c/dom/events/EventException
+org/w3c/dom/events/Event
+org/w3c/dom/events/MutationEvent
+org/w3c/dom/traversal/TreeWalker
+org/w3c/dom/ranges/Range
+org/w3c/dom/traversal/NodeIterator
+org/w3c/dom/NamedNodeMap
+java/awt/GridLayout
+javax/swing/JToggleButton$ToggleButtonModel
+javax/swing/plaf/metal/MetalRadioButtonUI
+javax/swing/plaf/basic/BasicRadioButtonUI
+javax/swing/plaf/basic/BasicToggleButtonUI
+javax/swing/plaf/basic/BasicBorders
+javax/swing/plaf/basic/BasicBorders$RadioButtonBorder
+javax/swing/plaf/basic/BasicBorders$ButtonBorder
+javax/swing/plaf/metal/MetalIconFactory$RadioButtonIcon
+javax/swing/plaf/basic/BasicRadioButtonUI$KeyHandler
+javax/swing/plaf/basic/BasicRadioButtonUI$SelectPreviousBtn
+javax/swing/plaf/basic/BasicRadioButtonUI$SelectNextBtn
+javax/swing/event/ChangeEvent
+java/awt/event/ItemEvent
+javax/swing/ToolTipManager
+javax/swing/ToolTipManager$insideTimerAction
+javax/swing/ToolTipManager$outsideTimerAction
+javax/swing/ToolTipManager$stillInsideTimerAction
+javax/swing/ToolTipManager$MoveBeforeEnterListener
+java/awt/event/MouseMotionAdapter
+javax/swing/ToolTipManager$AccessibilityKeyListener
+java/awt/event/KeyAdapter
+java/awt/CardLayout$Card
+javax/swing/JComboBox
+javax/swing/event/ListDataListener
+javax/swing/JCheckBox
+javax/swing/JPopupMenu
+javax/swing/MenuElement
+javax/swing/DefaultComboBoxModel
+javax/swing/MutableComboBoxModel
+javax/swing/ComboBoxModel
+javax/swing/ListModel
+javax/swing/AbstractListModel
+javax/swing/JComboBox$1
+javax/swing/AncestorNotifier
+javax/swing/plaf/metal/MetalComboBoxUI
+javax/swing/plaf/basic/BasicComboBoxUI
+javax/swing/plaf/ComboBoxUI
+javax/swing/plaf/metal/MetalComboBoxUI$MetalComboBoxLayoutManager
+javax/swing/plaf/basic/BasicComboBoxUI$ComboBoxLayoutManager
+javax/swing/plaf/basic/BasicComboPopup
+javax/swing/plaf/basic/ComboPopup
+javax/swing/plaf/basic/BasicComboPopup$EmptyListModelClass
+javax/swing/plaf/basic/BasicLookAndFeel$AWTEventHelper
+java/awt/event/AWTEventListenerProxy
+java/awt/Toolkit$SelectiveAWTEventListener
+java/awt/Toolkit$ToolkitEventMulticaster
+javax/swing/plaf/basic/BasicLookAndFeel$1
+javax/swing/plaf/basic/DefaultMenuLayout
+javax/swing/plaf/metal/MetalBorders$PopupMenuBorder
+javax/swing/plaf/basic/BasicPopupMenuUI$BasicPopupMenuListener
+javax/swing/event/PopupMenuListener
+javax/swing/plaf/basic/BasicPopupMenuUI$BasicMenuKeyListener
+javax/swing/event/MenuKeyListener
+javax/swing/plaf/basic/BasicPopupMenuUI$MouseGrabber
+javax/swing/MenuSelectionManager
+javax/swing/plaf/basic/BasicPopupMenuUI$MenuKeyboardHelper
+javax/swing/plaf/basic/BasicPopupMenuUI$MenuKeyboardHelper$1
+java/awt/event/FocusAdapter
+javax/swing/plaf/basic/BasicComboPopup$1
+javax/swing/JList
+javax/swing/DefaultListSelectionModel
+javax/swing/ListSelectionModel
+javax/swing/plaf/basic/BasicListUI
+javax/swing/plaf/ListUI
+javax/swing/plaf/basic/BasicListUI$ListTransferHandler
+javax/swing/DefaultListCellRenderer$UIResource
+javax/swing/DefaultListCellRenderer
+javax/swing/ListCellRenderer
+javax/swing/plaf/basic/BasicListUI$Handler
+javax/swing/event/ListSelectionListener
+javax/swing/JMenu
+javax/swing/JMenuItem
+javax/swing/event/ListSelectionEvent
+javax/swing/plaf/basic/BasicComboPopup$Handler
+javax/swing/ScrollPaneLayout$UIResource
+javax/swing/ScrollPaneLayout
+javax/swing/ViewportLayout
+javax/swing/plaf/basic/BasicViewportUI
+javax/swing/plaf/ViewportUI
+javax/swing/JScrollPane$ScrollBar
+javax/swing/JScrollBar
+java/awt/Adjustable
+javax/swing/JScrollBar$ModelListener
+javax/swing/plaf/metal/MetalScrollBarUI
+javax/swing/plaf/basic/BasicScrollBarUI
+javax/swing/plaf/ScrollBarUI
+javax/swing/plaf/metal/MetalBumps
+javax/swing/plaf/basic/BasicScrollBarUI$TrackListener
+javax/swing/plaf/basic/BasicScrollBarUI$ArrowButtonListener
+javax/swing/plaf/basic/BasicScrollBarUI$ModelListener
+javax/swing/plaf/metal/MetalScrollBarUI$ScrollBarListener
+javax/swing/plaf/basic/BasicScrollBarUI$PropertyChangeHandler
+javax/swing/plaf/basic/BasicScrollBarUI$Handler
+javax/swing/plaf/basic/BasicScrollBarUI$ScrollListener
+javax/swing/JViewport$ViewListener
+javax/swing/plaf/metal/MetalScrollPaneUI
+javax/swing/plaf/basic/BasicScrollPaneUI
+javax/swing/plaf/ScrollPaneUI
+javax/swing/plaf/metal/MetalBorders$ScrollPaneBorder
+javax/swing/plaf/basic/BasicScrollPaneUI$Handler
+javax/swing/plaf/metal/MetalScrollPaneUI$1
+javax/swing/plaf/basic/BasicComboBoxRenderer$UIResource
+javax/swing/plaf/basic/BasicComboBoxRenderer
+javax/swing/plaf/metal/MetalComboBoxEditor$UIResource
+javax/swing/plaf/metal/MetalComboBoxEditor
+javax/swing/plaf/basic/BasicComboBoxEditor
+javax/swing/ComboBoxEditor
+javax/swing/plaf/basic/BasicComboBoxEditor$BorderlessTextField
+javax/swing/plaf/basic/BasicComboBoxEditor$UIResource
+javax/swing/text/Segment
+java/text/CharacterIterator
+javax/swing/plaf/metal/MetalComboBoxEditor$1
+javax/swing/plaf/metal/MetalComboBoxEditor$EditorBorder
+javax/swing/JToolBar
+javax/swing/plaf/metal/MetalComboBoxUI$MetalPropertyChangeListener
+javax/swing/plaf/basic/BasicComboBoxUI$PropertyChangeHandler
+javax/swing/plaf/basic/BasicComboBoxUI$Handler
+javax/swing/plaf/metal/MetalComboBoxIcon
+javax/swing/plaf/metal/MetalComboBoxButton$1
+javax/swing/plaf/basic/BasicComboBoxUI$DefaultKeySelectionManager
+javax/swing/JComboBox$KeySelectionManager
+javax/swing/plaf/metal/MetalCheckBoxUI
+javax/swing/plaf/metal/MetalIconFactory$CheckBoxIcon
+java/lang/ExceptionInInitializerError
+com/sun/java/swing/plaf/windows/WindowsTabbedPaneUI
+javax/swing/JProgressBar
+javax/swing/JProgressBar$ModelListener
+javax/swing/plaf/metal/MetalProgressBarUI
+javax/swing/plaf/basic/BasicProgressBarUI
+javax/swing/plaf/ProgressBarUI
+javax/swing/plaf/BorderUIResource$LineBorderUIResource
+javax/swing/plaf/basic/BasicProgressBarUI$Handler
+javax/swing/JTable
+javax/swing/event/TableModelListener
+javax/swing/event/TableColumnModelListener
+javax/swing/event/CellEditorListener
+javax/swing/event/RowSorterListener
+javax/swing/tree/TreeModel
+javax/swing/table/JTableHeader
+javax/swing/table/AbstractTableModel
+javax/swing/table/TableModel
+javax/swing/table/TableCellRenderer
+javax/swing/event/TreeExpansionListener
+javax/swing/table/DefaultTableCellRenderer
+javax/swing/JCheckBoxMenuItem
+javax/swing/JTree
+javax/swing/tree/TreeSelectionModel
+javax/swing/tree/DefaultTreeCellRenderer
+javax/swing/tree/TreeCellRenderer
+javax/swing/table/TableCellEditor
+javax/swing/CellEditor
+javax/swing/JToolTip
+javax/swing/table/TableColumn
+javax/swing/table/DefaultTableColumnModel
+javax/swing/table/TableColumnModel
+javax/swing/table/DefaultTableModel
+javax/swing/event/TableModelEvent
+sun/swing/table/DefaultTableCellHeaderRenderer
+sun/swing/table/DefaultTableCellHeaderRenderer$EmptyIcon
+javax/swing/plaf/basic/BasicTableHeaderUI
+javax/swing/plaf/TableHeaderUI
+javax/swing/plaf/basic/BasicTableHeaderUI$1
+javax/swing/plaf/basic/BasicTableHeaderUI$MouseInputHandler
+javax/swing/DefaultCellEditor
+javax/swing/tree/TreeCellEditor
+javax/swing/AbstractCellEditor
+javax/swing/plaf/basic/BasicTableUI
+javax/swing/plaf/TableUI
+javax/swing/plaf/basic/BasicTableUI$TableTransferHandler
+javax/swing/plaf/basic/BasicTableUI$Handler
+javax/swing/tree/DefaultTreeSelectionModel
+javax/swing/tree/TreePath
+javax/swing/plaf/metal/MetalTreeUI
+javax/swing/plaf/basic/BasicTreeUI
+javax/swing/plaf/TreeUI
+javax/swing/plaf/basic/BasicTreeUI$Actions
+javax/swing/plaf/basic/BasicTreeUI$TreeTransferHandler
+javax/swing/plaf/metal/MetalTreeUI$LineListener
+javax/swing/plaf/basic/BasicTreeUI$Handler
+javax/swing/event/TreeModelListener
+javax/swing/event/TreeSelectionListener
+javax/swing/event/SwingPropertyChangeSupport
+javax/swing/tree/VariableHeightLayoutCache
+javax/swing/tree/AbstractLayoutCache
+javax/swing/tree/RowMapper
+javax/swing/plaf/basic/BasicTreeUI$NodeDimensionsHandler
+javax/swing/tree/AbstractLayoutCache$NodeDimensions
+javax/swing/JTree$TreeModelHandler
+javax/swing/tree/VariableHeightLayoutCache$TreeStateNode
+javax/swing/tree/DefaultMutableTreeNode
+javax/swing/tree/MutableTreeNode
+javax/swing/tree/DefaultMutableTreeNode$PreorderEnumeration
+java/util/Vector$1
+javax/swing/event/TableColumnModelEvent
+javax/swing/JPopupMenu$Separator
+javax/swing/JSeparator
+java/text/ParseException
+java/text/NumberFormat$Field
+javax/swing/text/GapContent$InsertUndo
+javax/swing/undo/AbstractUndoableEdit
+javax/swing/undo/UndoableEdit
+javax/swing/text/AbstractDocument$DefaultDocumentEvent
+javax/swing/event/DocumentEvent
+javax/swing/undo/CompoundEdit
+javax/swing/event/DocumentEvent$EventType
+javax/swing/text/Utilities
+javax/swing/text/SegmentCache
+javax/swing/text/SegmentCache$CachedSegment
+javax/swing/event/DocumentEvent$ElementChange
+javax/swing/event/UndoableEditEvent
+javax/swing/event/UndoableEditListener
+java/awt/Canvas
+java/util/Locale$Category
+java/util/Locale$1
+javax/swing/filechooser/FileFilter
+java/io/FileWriter
+javax/swing/tree/DefaultTreeModel
+javax/swing/tree/DefaultTreeCellEditor
+javax/swing/tree/DefaultTreeCellEditor$1
+javax/swing/tree/DefaultTreeCellEditor$DefaultTextField
+javax/swing/DefaultCellEditor$1
+javax/swing/DefaultCellEditor$EditorDelegate
+javax/swing/tree/DefaultTreeCellEditor$EditorContainer
+javax/swing/JTree$TreeSelectionRedirector
+javax/swing/JMenuItem$MenuItemFocusListener
+javax/swing/plaf/basic/BasicMenuItemUI
+javax/swing/plaf/MenuItemUI
+javax/swing/plaf/metal/MetalBorders$MenuItemBorder
+javax/swing/plaf/metal/MetalIconFactory$MenuItemArrowIcon
+sun/swing/MenuItemLayoutHelper
+javax/swing/plaf/basic/BasicMenuItemUI$Handler
+javax/swing/event/MenuDragMouseListener
+javax/swing/event/TreeModelEvent
+javax/swing/JSplitPane
+javax/swing/plaf/metal/MetalSplitPaneUI
+javax/swing/plaf/basic/BasicSplitPaneUI
+javax/swing/plaf/SplitPaneUI
+javax/swing/plaf/basic/BasicSplitPaneDivider
+javax/swing/plaf/basic/BasicBorders$SplitPaneBorder
+javax/swing/plaf/metal/MetalSplitPaneDivider
+javax/swing/plaf/basic/BasicSplitPaneDivider$DividerLayout
+javax/swing/plaf/basic/BasicSplitPaneDivider$MouseHandler
+javax/swing/plaf/basic/BasicBorders$SplitPaneDividerBorder
+javax/swing/plaf/basic/BasicSplitPaneUI$BasicHorizontalLayoutManager
+javax/swing/plaf/basic/BasicSplitPaneUI$1
+javax/swing/plaf/basic/BasicSplitPaneUI$Handler
+javax/swing/plaf/metal/MetalSplitPaneDivider$1
+javax/swing/plaf/basic/BasicSplitPaneDivider$OneTouchActionHandler
+javax/swing/plaf/metal/MetalSplitPaneDivider$2
+javax/swing/border/TitledBorder
+javax/swing/plaf/basic/BasicTextAreaUI
+javax/swing/text/AbstractDocument$ElementEdit
+java/util/Random
+java/util/concurrent/atomic/AtomicLong
+java/io/InterruptedIOException
+java/net/NoRouteToHostException
+java/net/BindException
+javax/swing/tree/PathPlaceHolder
+javax/swing/event/TreeSelectionEvent
+javax/swing/JList$3
+javax/swing/JList$ListSelectionHandler
+javax/swing/JSlider
+javax/swing/JSlider$ModelListener
+javax/swing/plaf/metal/MetalSliderUI
+javax/swing/plaf/basic/BasicSliderUI
+javax/swing/plaf/SliderUI
+javax/swing/plaf/basic/BasicSliderUI$Actions
+javax/swing/plaf/metal/MetalIconFactory$HorizontalSliderThumbIcon
+javax/swing/plaf/metal/MetalIconFactory$VerticalSliderThumbIcon
+javax/swing/plaf/basic/BasicSliderUI$TrackListener
+javax/swing/plaf/basic/BasicSliderUI$Handler
+javax/swing/plaf/basic/BasicSliderUI$ScrollListener
+javax/swing/plaf/metal/MetalSliderUI$MetalPropertyListener
+javax/swing/plaf/basic/BasicSliderUI$PropertyChangeHandler
+java/util/concurrent/ConcurrentHashMap$KeyIterator
+java/util/concurrent/ConcurrentHashMap$BaseIterator
+java/util/concurrent/ConcurrentHashMap$Traverser
+sun/font/Type1Font$1
+java/nio/channels/FileChannel$MapMode
+sun/nio/ch/FileChannelImpl$Unmapper
+sun/nio/ch/Util$4
+java/nio/DirectByteBufferR
+sun/nio/cs/US_ASCII$Decoder
+sun/font/SunFontManager$10
+java/util/concurrent/ConcurrentHashMap$ValueIterator
+javax/swing/DefaultListModel
+javax/swing/event/ListDataEvent
+javax/sound/sampled/DataLine
+javax/sound/sampled/Line
+javax/sound/sampled/LineUnavailableException
+javax/sound/sampled/UnsupportedAudioFileException
+javax/sound/sampled/Line$Info
+javax/sound/sampled/DataLine$Info
+javax/sound/sampled/Control$Type
+javax/sound/sampled/FloatControl$Type
+javax/swing/JMenuBar
+javax/swing/plaf/basic/BasicMenuBarUI
+javax/swing/plaf/MenuBarUI
+javax/swing/plaf/metal/MetalBorders$MenuBarBorder
+javax/swing/plaf/basic/BasicMenuBarUI$Handler
+javax/swing/KeyboardManager
+javax/swing/JRadioButtonMenuItem
+javax/swing/JMenu$MenuChangeListener
+javax/swing/plaf/basic/BasicMenuUI
+javax/swing/plaf/metal/MetalIconFactory$MenuArrowIcon
+javax/swing/plaf/basic/BasicMenuUI$Handler
+javax/swing/JMenuItem$AccessibleJMenuItem
+javax/swing/AbstractButton$AccessibleAbstractButton
+javax/accessibility/AccessibleAction
+javax/accessibility/AccessibleValue
+javax/accessibility/AccessibleText
+javax/accessibility/AccessibleExtendedComponent
+javax/accessibility/AccessibleComponent
+javax/swing/JComponent$AccessibleJComponent
+java/awt/Container$AccessibleAWTContainer
+java/awt/Component$AccessibleAWTComponent
+javax/accessibility/AccessibleContext$1
+sun/awt/AWTAccessor$AccessibleContextAccessor
+javax/accessibility/AccessibleRelationSet
+javax/swing/JMenu$WinListener
+java/awt/event/WindowAdapter
+javax/swing/plaf/metal/MetalPopupMenuSeparatorUI
+javax/swing/plaf/metal/MetalSeparatorUI
+javax/swing/plaf/basic/BasicSeparatorUI
+javax/swing/plaf/SeparatorUI
+javax/accessibility/AccessibleState
+javax/accessibility/AccessibleBundle
+javax/swing/plaf/basic/BasicCheckBoxMenuItemUI
+javax/swing/plaf/metal/MetalIconFactory$CheckBoxMenuItemIcon
+javax/swing/JCheckBoxMenuItem$AccessibleJCheckBoxMenuItem
+javax/swing/plaf/basic/BasicRadioButtonMenuItemUI
+javax/swing/plaf/metal/MetalIconFactory$RadioButtonMenuItemIcon
+java/awt/event/ContainerEvent
+sun/awt/image/ImageDecoder$1
+java/awt/im/InputContext
+sun/awt/im/InputMethodContext
+java/awt/im/spi/InputMethodContext
+java/awt/im/InputMethodRequests
+sun/awt/im/InputContext
+sun/awt/im/InputMethodManager
+sun/awt/im/ExecutableInputMethodManager
+sun/awt/X11/XInputMethodDescriptor
+sun/awt/X11InputMethodDescriptor
+java/awt/im/spi/InputMethodDescriptor
+sun/awt/im/InputMethodLocator
+sun/awt/im/ExecutableInputMethodManager$3
+javax/swing/JTabbedPane$Page
+java/net/DatagramSocket
+java/net/MulticastSocket
+java/net/DatagramPacket
+java/net/DatagramPacket$1
+java/net/DefaultDatagramSocketImplFactory
+java/net/PlainDatagramSocketImpl
+java/net/AbstractPlainDatagramSocketImpl
+java/net/DatagramSocketImpl
+java/net/AbstractPlainDatagramSocketImpl$1
+java/net/NetworkInterface
+java/net/NetworkInterface$1
+java/net/InterfaceAddress
+java/net/DefaultInterface
+java/net/DatagramSocket$1
+java/net/SocketOption
+sun/net/ResourceManager
+java/text/Collator
+sun/util/locale/provider/CollatorProviderImpl
+java/util/Collections$UnmodifiableList$1
+sun/text/resources/CollationData
+java/text/RuleBasedCollator
+java/text/RBCollationTables
+java/net/ServerSocket
+java/text/RBTableBuilder
+java/text/RBCollationTables$BuildAPI
+sun/text/IntHashtable
+sun/text/UCompactIntArray
+sun/text/normalizer/NormalizerImpl
+sun/text/normalizer/ICUData
+sun/text/normalizer/NormalizerDataReader
+sun/text/normalizer/ICUBinary$Authenticate
+sun/text/normalizer/ICUBinary
+sun/text/normalizer/NormalizerImpl$FCDTrieImpl
+sun/text/normalizer/Trie$DataManipulate
+sun/text/normalizer/NormalizerImpl$NormTrieImpl
+sun/text/normalizer/NormalizerImpl$AuxTrieImpl
+sun/text/normalizer/IntTrie
+sun/text/normalizer/Trie
+sun/text/normalizer/CharTrie
+sun/text/normalizer/CharTrie$FriendAgent
+sun/text/normalizer/UnicodeSet
+sun/text/normalizer/UnicodeMatcher
+sun/text/normalizer/NormalizerImpl$DecomposeArgs
+java/text/MergeCollation
+java/text/PatternEntry$Parser
+java/text/PatternEntry
+java/text/EntryPair
+sun/text/ComposedCharIter
+sun/text/normalizer/UTF16
+sun/net/www/protocol/http/Handler
+java/security/SignatureException
+java/security/InvalidKeyException
+java/security/KeyException
+java/security/Signature
+java/security/SignatureSpi
+java/io/ObjectInputStream$BlockDataInputStream
+java/io/ObjectInputStream$PeekInputStream
+java/io/ObjectInputStream$HandleTable
+java/io/ObjectInputStream$HandleTable$HandleList
+java/io/ObjectInputStream$ValidationList
+java/io/Bits
+java/io/ObjectStreamClass
+java/io/ObjectOutputStream
+java/io/ObjectOutput
+sun/security/provider/DSAPublicKey
+java/security/interfaces/DSAPublicKey
+java/security/interfaces/DSAKey
+java/security/PublicKey
+java/security/Key
+sun/security/x509/X509Key
+java/io/ObjectStreamClass$Caches
+java/io/ObjectStreamClass$WeakClassKey
+java/io/ObjectStreamClass$EntryFuture
+java/lang/reflect/Proxy
+java/lang/reflect/InvocationHandler
+java/lang/reflect/WeakCache
+java/lang/reflect/Proxy$KeyFactory
+java/lang/reflect/Proxy$ProxyClassFactory
+java/io/Externalizable
+java/io/ObjectStreamClass$2
+java/util/ComparableTimSort
+sun/security/x509/AlgorithmId
+sun/security/util/DerEncoder
+sun/reflect/SerializationConstructorAccessorImpl
+sun/security/util/BitArray
+sun/reflect/UnsafeQualifiedStaticLongFieldAccessorImpl
+java/io/ObjectStreamClass$FieldReflectorKey
+java/io/ObjectStreamClass$FieldReflector
+java/io/ObjectStreamClass$1
+java/io/DataOutputStream
+java/io/ObjectStreamClass$MemberSignature
+java/io/ObjectStreamClass$3
+sun/security/util/DerOutputStream
+java/io/ObjectStreamClass$4
+java/io/ObjectStreamClass$5
+sun/security/util/DerValue
+java/security/MessageDigest
+java/security/MessageDigestSpi
+sun/security/jca/GetInstance
+sun/security/jca/Providers
+java/lang/InheritableThreadLocal
+sun/security/jca/ProviderList
+sun/security/jca/ProviderConfig
+java/math/BigInteger
+java/security/Provider
+sun/security/jca/ProviderList$3
+sun/security/jca/ProviderList$1
+java/security/Provider$ServiceKey
+java/security/Provider$EngineDescription
+java/security/interfaces/DSAParams
+sun/security/jca/ProviderList$2
+sun/security/jca/ProviderConfig$2
+java/io/ObjectStreamClass$ClassDataSlot
+sun/security/provider/Sun
+java/io/SerialCallbackContext
+sun/security/provider/SunEntries
+sun/security/provider/SunEntries$1
+sun/security/provider/NativePRNG
+java/security/SecureRandomSpi
+sun/security/provider/NativePRNG$Variant
+sun/security/util/DerInputStream
+sun/security/provider/NativePRNG$1
+sun/security/provider/NativePRNG$2
+sun/security/provider/NativePRNG$RandomIO
+sun/security/util/DerInputBuffer
+sun/security/provider/NativePRNG$Blocking
+sun/security/provider/NativePRNG$NonBlocking
+sun/security/util/ObjectIdentifier
+java/security/Provider$Service
+java/security/Provider$UString
+sun/security/provider/SHA
+sun/security/provider/DigestBase
+sun/security/jca/GetInstance$Instance
+java/security/MessageDigest$Delegate
+sun/security/provider/ByteArrayAccess
+java/io/ObjectOutputStream$BlockDataOutputStream
+java/security/AlgorithmParameters
+java/io/ObjectOutputStream$HandleTable
+java/io/ObjectOutputStream$ReplaceTable
+java/security/AlgorithmParametersSpi
+sun/security/provider/DSAParameters
+sun/security/util/ByteArrayLexOrder
+sun/security/util/ByteArrayTagOrder
+sun/security/util/DerIndefLenConverter
+java/io/ObjectStreamClass$ExceptionInfo
+java/io/ObjectInputStream$GetFieldImpl
+java/io/ObjectInputStream$GetField
+java/math/BigInteger$UnsafeHolder
+sun/security/jca/ServiceId
+sun/security/jca/ProviderList$ServiceList
+sun/security/jca/ProviderList$ServiceList$1
+java/security/Signature$Delegate
+java/util/ArrayList$SubList
+java/util/ArrayList$SubList$1
+java/security/interfaces/DSAPrivateKey
+java/security/PrivateKey
+javax/security/auth/Destroyable
+sun/security/provider/DSA$SHA1withDSA
+sun/security/provider/DSA$LegacyDSA
+sun/security/provider/DSA
+java/security/spec/DSAParameterSpec
+java/security/spec/AlgorithmParameterSpec
+java/math/MutableBigInteger
+java/math/SignedMutableBigInteger
+javax/swing/TimerQueue
+java/util/concurrent/DelayQueue
+java/util/concurrent/BlockingQueue
+java/util/AbstractQueue
+java/util/PriorityQueue
+javax/swing/TimerQueue$1
+javax/swing/TimerQueue$DelayedTimer
+java/util/concurrent/Delayed
+java/util/concurrent/TimeUnit
+java/util/concurrent/TimeUnit$1
+java/util/concurrent/TimeUnit$2
+java/util/concurrent/TimeUnit$3
+java/util/concurrent/TimeUnit$4
+java/util/concurrent/TimeUnit$5
+java/util/concurrent/TimeUnit$6
+java/util/concurrent/TimeUnit$7
+java/awt/Window$1DisposeAction
+java/awt/EventQueue$1AWTInvocationLock
+sun/awt/X11/XUnmapEvent
+java/awt/LightweightDispatcher$2
+java/awt/Component$FlipBufferStrategy
+java/awt/SentEvent
+sun/java2d/cmm/CMSManager
+java/awt/image/DataBufferInt
+java/awt/image/SinglePixelPackedSampleModel
+sun/awt/image/IntegerInterleavedRaster
+sun/awt/X11/XDropTargetRegistry
+sun/awt/X11/XEmbeddedFramePeer
+sun/awt/X11/XDragAndDropProtocols
+sun/awt/X11/XDropTargetContextPeer
+sun/awt/dnd/SunDropTargetContextPeer
+java/awt/dnd/peer/DropTargetContextPeer
+java/awt/datatransfer/Transferable
+sun/awt/X11/XDropTargetContextPeer$XDropTargetProtocolListenerImpl
+sun/awt/X11/XDropTargetProtocolListener
+sun/awt/X11/XDnDDragSourceProtocol
+sun/awt/X11/XDragSourceProtocol
+sun/awt/X11/MotifDnDDragSourceProtocol
+sun/awt/X11/XDnDDropTargetProtocol
+sun/awt/X11/XDropTargetProtocol
+sun/awt/X11/MotifDnDDropTargetProtocol
+sun/awt/X11/XErrorHandler$VerifyChangePropertyHandler
+sun/awt/X11/XDnDConstants
+sun/awt/X11/XSelection
+sun/awt/X11/XSelection$IncrementalTransferHandler
+sun/awt/X11/XSelection$SelectionEventHandler
+sun/awt/X11/MotifDnDConstants
+javax/swing/JLayer
+javax/swing/JInternalFrame
+javax/swing/KeyboardManager$ComponentKeyStrokePair
+sun/awt/EmbeddedFrame
+sun/swing/MenuItemLayoutHelper$RectSize
+javax/swing/JTable$2
+javax/swing/JTable$Resizable3
+javax/swing/JTable$Resizable2
+javax/swing/JTable$5
+javax/swing/event/AncestorEvent
+java/awt/Label
+sun/awt/X11/XLabelPeer
+java/awt/peer/LabelPeer
+sun/awt/TimedWindowEvent
+java/awt/DefaultKeyboardFocusManager$DefaultKeyboardFocusManagerSentEvent
+sun/awt/CausedFocusEvent$Cause
+java/awt/KeyboardFocusManager$HeavyweightFocusRequest
+java/awt/DefaultKeyboardFocusManager$TypeAheadMarker
+java/awt/KeyboardFocusManager$LightweightFocusRequest
+sun/awt/CausedFocusEvent
+java/awt/KeyboardFocusManager$3
+sun/awt/X11/XInputMethod
+sun/awt/X11InputMethod
+sun/awt/im/InputMethodAdapter
+java/awt/im/spi/InputMethod
+java/awt/Event
+java/net/Authenticator
+java/lang/Throwable$WrappedPrintStream
+java/lang/Throwable$PrintStreamOrWriter
+sun/awt/image/PNGImageDecoder
+sun/awt/image/PNGFilterInputStream
+sun/util/locale/provider/TimeZoneNameUtility
+sun/util/locale/provider/TimeZoneNameProviderImpl
+sun/util/locale/provider/TimeZoneNameUtility$TimeZoneNameGetter
+sun/util/resources/TimeZoneNames
+sun/util/resources/TimeZoneNamesBundle
+sun/util/resources/en/TimeZoneNames_en
+sun/awt/image/OffScreenImage
+java/lang/ProcessBuilder
+java/lang/ProcessImpl
+java/lang/UNIXProcess
+java/lang/Process
+java/lang/UNIXProcess$Platform
+java/lang/UNIXProcess$LaunchMechanism
+java/util/EnumSet
+java/util/RegularEnumSet
+sun/java2d/x11/X11SurfaceDataProxy$Opaque
+java/lang/UNIXProcess$1
+java/util/concurrent/Executor
+java/util/concurrent/ThreadFactory
+java/util/concurrent/Executors
+java/util/concurrent/ThreadPoolExecutor
+java/util/concurrent/AbstractExecutorService
+java/util/concurrent/ExecutorService
+java/util/concurrent/ThreadPoolExecutor$AbortPolicy
+java/util/concurrent/RejectedExecutionHandler
+java/util/concurrent/SynchronousQueue
+java/util/concurrent/SynchronousQueue$TransferStack
+java/util/concurrent/SynchronousQueue$Transferer
+java/util/concurrent/SynchronousQueue$TransferStack$SNode
+java/lang/UNIXProcess$ProcessPipeOutputStream
+java/lang/UNIXProcess$ProcessPipeInputStream
+java/util/concurrent/ThreadPoolExecutor$Worker
+java/lang/ProcessBuilder$NullOutputStream
+java/io/FilterReader
+sun/awt/X11/XClipboard
+sun/awt/X11/OwnershipListener
+sun/awt/datatransfer/SunClipboard
+java/awt/datatransfer/Clipboard
+java/io/EOFException
+java/util/jar/JarFile$JarEntryIterator
+java/util/zip/ZipFile$ZipEntryIterator
+java/lang/IllegalAccessError
+java/text/MessageFormat
+java/text/MessageFormat$Field
+java/util/Hashtable$ValueCollection
+javax/swing/event/CaretListener
+javax/swing/plaf/metal/MetalButtonUI
+javax/swing/plaf/metal/MetalToggleButtonUI
+javax/swing/plaf/metal/MetalBorders$ToggleButtonBorder
+javax/swing/event/MenuEvent
+javax/swing/border/MatteBorder
+sun/font/StandardGlyphVector
+java/awt/font/GlyphVector
+sun/font/StandardGlyphVector$GlyphStrike
+sun/font/CoreMetrics
+sun/font/FontLineMetrics
+java/awt/font/LineMetrics
+javax/swing/JToolBar$DefaultToolBarLayout
+javax/swing/plaf/metal/MetalToolBarUI
+javax/swing/plaf/basic/BasicToolBarUI
+javax/swing/plaf/ToolBarUI
+javax/swing/plaf/metal/MetalBorders$ToolBarBorder
+javax/swing/plaf/metal/MetalBorders$RolloverButtonBorder
+javax/swing/plaf/metal/MetalBorders$RolloverMarginBorder
+javax/swing/plaf/basic/BasicBorders$RolloverMarginBorder
+javax/swing/plaf/metal/MetalToolBarUI$MetalDockingListener
+javax/swing/plaf/basic/BasicToolBarUI$DockingListener
+javax/swing/plaf/basic/BasicToolBarUI$Handler
+javax/swing/JToolBar$Separator
+javax/swing/plaf/basic/BasicToolBarSeparatorUI
+java/awt/event/AdjustmentEvent
+java/awt/MenuBar
+sun/awt/X11/XErrorEvent
+# eea35d9d56e0006e
--- ./jdk/make/gendata/GendataFontConfig.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/gendata/GendataFontConfig.gmk	Mon May 09 17:18:41 2016 -0400
@@ -73,6 +73,13 @@
   GENDATA_FONT_CONFIG_SRC_PREFIX := aix.
 endif
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  GENDATA_FONT_CONFIG_SRC_DIR := \
+      $(JDK_TOPDIR)/src/solaris/classes/sun/awt/fontconfigs
+  GENDATA_FONT_CONFIG_SRC_FILES := fontconfig.properties
+  GENDATA_FONT_CONFIG_SRC_PREFIX := bsd.
+endif
+
 ###
 
 $(GENDATA_FONT_CONFIG_DST)/%.src: \
--- ./jdk/make/lib/Awt2dLibraries.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/lib/Awt2dLibraries.gmk	Mon May 09 17:18:41 2016 -0400
@@ -309,7 +309,7 @@
     debug_trace.c \
     debug_util.c
 
-ifneq (, $(filter $(OPENJDK_TARGET_OS), solaris linux aix))
+ifneq (, $(filter $(OPENJDK_TARGET_OS), bsd solaris linux aix))
   LIBAWT_FILES += awt_LoadLibrary.c initIDs.c img_colors.c
 endif
 
@@ -481,6 +481,7 @@
     LDFLAGS_SUFFIX_linux := -ljvm $(LIBM) $(LIBDL) -ljava, \
     LDFLAGS_SUFFIX_solaris := -ljvm $(LIBM) $(LIBDL) -ljava -lc, \
     LDFLAGS_SUFFIX_aix :=-ljvm $(LIBM) $(LIBDL) -ljava -lm,\
+    LDFLAGS_SUFFIX_bsd := -ljvm $(LIBM) -ljava, \
     LDFLAGS_SUFFIX_macosx := -lmlib_image -ljvm $(LIBM) \
         -framework Cocoa \
         -framework OpenGL \
@@ -557,6 +558,16 @@
       endif
     endif
 
+    ifeq ($(OPENJDK_TARGET_OS), bsd)
+      ifndef OPENJDK
+        include $(JDK_TOPDIR)/make/closed/xawt.gmk
+      endif
+
+      ifeq ($(DISABLE_XRENDER), true)
+        LIBAWT_XAWT_CFLAGS += -DDISABLE_XRENDER_BY_DEFAULT=true
+      endif
+    endif
+
     ifeq ($(MILESTONE), internal)
       LIBAWT_XAWT_CFLAGS += -DINTERNAL_BUILD
     endif
@@ -625,6 +636,11 @@
       LIBAWT_XAWT_LDFLAGS += -lpthread
     endif
 
+    ifeq ($(OPENJDK_TARGET_OS), bsd)
+      # To match old build, add this to LDFLAGS instead of suffix.
+      LIBAWT_XAWT_LDFLAGS += -pthread
+    endif
+
     $(eval $(call SetupNativeCompilation,BUILD_LIBAWT_XAWT, \
         LIBRARY := awt_xawt, \
         OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -646,6 +662,7 @@
             -R/usr/dt/lib$(OPENJDK_TARGET_CPU_ISADIR) \
             $(call SET_SHARED_LIBRARY_ORIGIN) \
             $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
+        LDFLAGS_bsd := $(call SET_SHARED_LIBRARY_ORIGIN), \
         LDFLAGS_SUFFIX := $(LIBAWT_XAWT_LDFLAGS_SUFFIX), \
         VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
         RC_FLAGS := $(RC_FLAGS) \
@@ -689,6 +706,7 @@
     LDFLAGS_SUFFIX_macosx := $(LIBM) -lawt -ljava -ljvm, \
     LDFLAGS_SUFFIX_linux := -lm -lawt -ljava -ljvm, \
     LDFLAGS_SUFFIX_aix := -lm -lawt -ljava -ljvm,\
+    LDFLAGS_SUFFIX_bsd := -lm -lawt -ljava -ljvm, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
         -D "JDK_FNAME=lcms.dll" \
@@ -847,6 +865,7 @@
         LDFLAGS_SUFFIX_linux := -ljvm -lawt -lm $(LIBDL) -ljava, \
         LDFLAGS_SUFFIX_aix := -ljvm -lawt -ljava,\
         LDFLAGS_SUFFIX_solaris := $(LIBDL) -ljvm -lawt -lm -ljava $(LIBCXX) -lc, \
+	LDFLAGS_SUFFIX_bsd := -ljvm -lawt -lm -ljava, \
         OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libawt_headless, \
         DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))
 
@@ -924,6 +943,7 @@
     LDFLAGS_SUFFIX_linux := -lawt $(LIBM) $(LIBCXX) -ljava -ljvm -lc, \
     LDFLAGS_SUFFIX_solaris := -lawt -lawt_headless -lc $(LIBM) $(LIBCXX) -ljava -ljvm, \
     LDFLAGS_SUFFIX_aix := -lawt -lawt_headless $(LIBM) $(LIBCXX) -ljava -ljvm,\
+    LDFLAGS_SUFFIX_bsd := -lawt $(LIBM) $(LIBCXX) -ljava -ljvm -lc, \
     LDFLAGS_SUFFIX_macosx := -lawt $(LIBM) $(LIBCXX) -undefined dynamic_lookup \
         -ljava -ljvm, \
     LDFLAGS_SUFFIX_windows := $(WIN_JAVA_LIB) advapi32.lib user32.lib gdi32.lib \
@@ -1067,6 +1087,7 @@
       OPTIMIZATION := LOW, \
       CFLAGS := $(CFLAGS_JDKLIB), \
       CFLAGS_linux := $(HEADLESS_CFLAG), \
+      CFLAGS_bsd := $(HEADLESS_CFLAG), \
       CFLAGS_macosx := -I$(JDK_TOPDIR)/src/solaris/native/sun/awt, \
       MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libjawt/mapfile-vers, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
@@ -1075,6 +1096,7 @@
       LDFLAGS_SUFFIX_linux := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX), \
       LDFLAGS_SUFFIX_aix := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX),\
       LDFLAGS_SUFFIX_solaris := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX) -lXrender, \
+      LDFLAGS_SUFFIX_bsd := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX), \
       LDFLAGS_SUFFIX_macosx := -Xlinker -rpath -Xlinker @loader_path $(JAWT_LIBS) \
           -framework Cocoa $(LDFLAGS_JDKLIB_SUFFIX), \
       OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libjawt, \
@@ -1193,7 +1215,7 @@
     $(JDK_TOPDIR)/src/share/native/sun/awt/splashscreen
 
   ifeq ($(USE_EXTERNAL_LIBGIF), true)
-    GIFLIB_LDFLAGS := -lgif
+    GIFLIB_LDFLAGS += -lgif
   else
     LIBSPLASHSCREEN_DIRS += $(JDK_TOPDIR)/src/share/native/sun/awt/giflib
     GIFLIB_CFLAGS := -I$(JDK_TOPDIR)/src/share/native/sun/awt/giflib
@@ -1226,6 +1248,11 @@
     LIBSPLASHSCREEN_CFLAGS += -DWITH_WIN32
   else ifeq ($(OPENJDK_TARGET_OS), solaris)
     LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+  else ifeq ($(OPENJDK_TARGET_OS), bsd)
+    LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 $(X_CFLAGS) -I$(PACKAGE_PATH)/include
+    ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+      LIBSPLASHSCREEN_CFLAGS += -DLIBICONV_PLUG
+    endif
   else
     LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 $(X_CFLAGS)
   endif
@@ -1248,6 +1275,8 @@
   else ifeq ($(OPENJDK_TARGET_OS), solaris)
     # Solaris still uses OPENWIN_LIB ..
     LIBSPLASHSCREEN_LDFLAGS_SUFFIX += -L$(OPENWIN_LIB)$(OPENJDK_TARGET_CPU_ISADIR) -lX11 -lXext $(LIBM) -lpthread
+  else ifeq ($(OPENJDK_TARGET_OS), bsd)
+    LIBSPLASHSCREEN_LDFLAGS_SUFFIX += $(X_LIBS) -lX11 -lXext $(LIBM) -L$(PACKAGE_PATH)/lib -liconv -pthread
   else	# .. all other Unixes can use X_LIBS
     LIBSPLASHSCREEN_LDFLAGS_SUFFIX += $(X_LIBS) -lX11 -lXext $(LIBM) -lpthread
   endif
--- ./jdk/make/lib/CoreLibraries.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/lib/CoreLibraries.gmk	Mon May 09 17:18:41 2016 -0400
@@ -82,7 +82,7 @@
 endif
 
 LIBVERIFY_OPTIMIZATION := HIGH
-ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux bsd), )
   ifeq ($(ENABLE_DEBUG_SYMBOLS), true)
     LIBVERIFY_OPTIMIZATION := LOW
   endif
@@ -200,6 +200,7 @@
     LDFLAGS_SUFFIX_solaris := -lsocket -lnsl -lscf $(LIBDL) $(BUILD_LIBFDLIBM) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBDL) $(BUILD_LIBFDLIBM), \
     LDFLAGS_SUFFIX_aix := $(LIBDL) $(BUILD_LIBFDLIBM) -lm,\
+    LDFLAGS_SUFFIX_bsd := $(BUILD_LIBFDLIBM), \
     LDFLAGS_SUFFIX_macosx := -L$(JDK_OUTPUTDIR)/objs/ -lfdlibm \
         -framework CoreFoundation \
         -framework Foundation \
@@ -270,6 +271,7 @@
     LDFLAGS_SUFFIX_linux := -ljvm -ljava $(LIBZ), \
     LDFLAGS_SUFFIX_solaris := -ljvm -ljava $(LIBZ) -lc, \
     LDFLAGS_SUFFIX_aix := -ljvm -ljava $(LIBZ),\
+    LDFLAGS_SUFFIX_bsd := -ljvm -ljava $(LIBZ), \
     LDFLAGS_SUFFIX_macosx := $(LIBZ) -ljava -ljvm, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
@@ -380,7 +382,7 @@
 # Append defines depending on target platform
 LIBJLI_CFLAGS += $(OPENJDK_TARGET_CPU_JLI_CFLAGS)
 
-ifeq ($(OPENJDK_TARGET_OS), macosx)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), bsd macosx), )
   LIBJLI_CFLAGS += -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
 endif
 
@@ -415,11 +417,13 @@
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_linux := $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
     LDFLAGS_solaris := $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
+    LDFLAGS_bsd := $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
     LDFLAGS_macosx := -framework Cocoa -framework Security -framework ApplicationServices, \
     LDFLAGS_SUFFIX_solaris := $(LIBZ) $(LIBDL) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBZ) $(LIBDL) -lc -lpthread, \
     LDFLAGS_SUFFIX_aix := $(LIBZ) $(LIBDL),\
     LDFLAGS_SUFFIX_macosx := $(LIBZ), \
+    LDFLAGS_SUFFIX_bsd := $(LIBZ) -pthread, \
     LDFLAGS_SUFFIX_windows := \
         -export:JLI_Launch \
         -export:JLI_ManifestIterate \
@@ -463,9 +467,9 @@
 
   BUILD_LIBRARIES += $(BUILD_LIBJLI_STATIC)
 
-else ifeq ($(OPENJDK_TARGET_OS), macosx)
+else ifneq ($(findstring $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx), )
   #
-  # On macosx they do partial (incremental) linking of libjli_static.a
+  # On BSD they do partial (incremental) linking of libjli_static.a
   # code it here...rather than add support to NativeCompilation
   # as this is first time I see it
   $(eval $(call SetupNativeCompilation,BUILD_LIBJLI_STATIC, \
@@ -504,6 +508,13 @@
 
 ##########################################################################################
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  BSD_ICONV_CFLAGS:= -I$(PACKAGE_PATH)/include
+  ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+    BSD_ICONV_CFLAGS += -DLIBICONV_PLUG
+  endif
+endif
+
 $(eval $(call SetupNativeCompilation,BUILD_LIBNPT, \
     LIBRARY := npt, \
     OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -513,9 +524,11 @@
     CFLAGS := $(CFLAGS_JDKLIB) \
         -I$(JDK_TOPDIR)/src/share/npt \
         -I$(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/npt, \
+    CFLAGS_bsd := $(BSD_ICONV_CFLAGS), \
     MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libnpt/mapfile-vers, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
+    LDFLAGS_bsd := -L$(PACKAGE_PATH)/lib -liconv, \
     LDFLAGS_macosx := -liconv, \
     LDFLAGS_SUFFIX_windows := -export:nptInitialize -export:nptTerminate, \
     LDFLAGS_SUFFIX_solaris := -lc, \
--- ./jdk/make/lib/NetworkingLibraries.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/lib/NetworkingLibraries.gmk	Mon May 09 17:18:41 2016 -0400
@@ -42,7 +42,7 @@
   LIBNET_EXCLUDE_FILES += linux_close.c
 endif
 
-ifneq ($(OPENJDK_TARGET_OS), macosx)
+ifeq (,$(findstring $(OPENJDK_TARGET_OS), bsd macosx))
   LIBNET_EXCLUDE_FILES += bsd_close.c
 endif
 
@@ -58,6 +58,10 @@
       NTLMAuthSequence.c NetworkInterface_winXP.c
 endif
 
+ifneq ($(DONT_ENABLE_IPV6),)
+  LIBNET_CFLAGS += -DDONT_ENABLE_IPV6
+endif
+
 $(eval $(call SetupNativeCompilation,BUILD_LIBNET, \
     LIBRARY := net, \
     OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -74,6 +78,7 @@
     LDFLAGS_SUFFIX_solaris := -ljvm -ljava -lnsl -lsocket $(LIBDL) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBDL) -ljvm -lpthread -ljava, \
     LDFLAGS_SUFFIX_aix := $(LIBDL) -ljvm -ljava,\
+    LDFLAGS_SUFFIX_bsd := -ljvm -pthread -ljava, \
     LDFLAGS_SUFFIX_windows := ws2_32.lib jvm.lib secur32.lib iphlpapi.lib \
         delayimp.lib $(WIN_JAVA_LIB) advapi32.lib \
         -DELAYLOAD:secur32.dll -DELAYLOAD:iphlpapi.dll, \
--- ./jdk/make/lib/NioLibraries.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/lib/NioLibraries.gmk	Mon May 09 17:18:41 2016 -0400
@@ -77,9 +77,28 @@
       UnixNativeDispatcher.c
 endif
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  BUILD_LIBNIO_MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libnio/mapfile-$(OPENJDK_TARGET_OS)
+  BUILD_LIBNIO_SRC += $(JDK_TOPDIR)/src/bsd/native/sun/nio/ch
+  BUILD_LIBNIO_FILES += \
+      BsdNativeDispatcher.c \
+      GnomeFileTypeDetector.c \
+      InheritedChannel.c \
+      KQueue.c \
+      KQueueArrayWrapper.c \
+      KQueuePort.c \
+      MagicFileTypeDetector.c \
+      NativeThread.c \
+      PollArrayWrapper.c \
+      UnixAsynchronousServerSocketChannelImpl.c \
+      UnixAsynchronousSocketChannelImpl.c \
+      UnixCopyFile.c \
+      UnixNativeDispatcher.c
+endif
+
 ifeq ($(OPENJDK_TARGET_OS), macosx)
   BUILD_LIBNIO_MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libnio/mapfile-$(OPENJDK_TARGET_OS)
-  BUILD_LIBNIO_SRC += $(JDK_TOPDIR)/src/macosx/native/sun/nio/ch
+  BUILD_LIBNIO_SRC += $(JDK_TOPDIR)/src/bsd/native/sun/nio/ch
   BUILD_LIBNIO_FILES += \
       InheritedChannel.c \
       NativeThread.c \
@@ -149,6 +168,7 @@
     LDFLAGS_SUFFIX_windows := jvm.lib ws2_32.lib $(WIN_JAVA_LIB) \
         $(JDK_OUTPUTDIR)/objs/libnet/net.lib \
         advapi32.lib, \
+    LDFLAGS_SUFFIX_bsd := -ljava -lnet -pthread, \
     LDFLAGS_SUFFIX_macosx := -ljava -lnet -pthread -framework CoreFoundation, \
     LDFLAGS_SUFFIX :=, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
@@ -168,6 +188,7 @@
 ifeq ($(OPENJDK_TARGET_OS_API), posix)
 
   ifeq (, $(filter $(OPENJDK_TARGET_OS), macosx aix))
+  ifeq (, $(filter $(OPENJDK_TARGET_OS_VENDOR), netbsd openbsd))
 
     # Suppress unused parameters required by exported JNI functions.
     SCTP_WERROR := -Werror -Wno-error=unused-parameter
@@ -194,6 +215,7 @@
         LDFLAGS_SUFFIX_linux := -lpthread $(LIBDL) -ljava -ljvm, \
         LDFLAGS_SUFFIX_posix := -lnio -lnet, \
         LDFLAGS_SUFFIX_solaris := -lsocket -ljava -ljvm -lc, \
+        LDFLAGS_SUFFIX_bsd := -pthread -ljava -ljvm, \
         LDFLAGS_SUFFIX_macosx := -ljava -ljvm, \
         OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libsctp, \
         DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))
@@ -202,4 +224,5 @@
 
     $(BUILD_LIBSCTP): $(BUILD_LIBNIO)
   endif
+  endif
 endif
--- ./jdk/make/lib/ServiceabilityLibraries.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/lib/ServiceabilityLibraries.gmk	Mon May 09 17:18:41 2016 -0400
@@ -34,7 +34,7 @@
 ifneq ($(OPENJDK_TARGET_OS), linux)
   LIBATTACH_EXCLUDE_FILES += LinuxVirtualMachine.c
 endif
-ifneq ($(OPENJDK_TARGET_OS), macosx)
+ifeq (,$(findstring $(OPENJDK_TARGET_OS), bsd macosx))
   LIBATTACH_EXCLUDE_FILES += BsdVirtualMachine.c
 endif
 ifneq ($(OPENJDK_TARGET_OS),aix)
@@ -94,6 +94,7 @@
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_SUFFIX_linux := -lpthread, \
     LDFLAGS_SUFFIX_solaris := -lnsl -lsocket -lc, \
+    LDFLAGS_SUFFIX_bsd := -pthread, \
     LDFLAGS_SUFFIX_windows := $(LDFLAGS_JDKLIB_SUFFIX) -export:jdwpTransport_OnLoad ws2_32.lib, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
@@ -245,6 +246,19 @@
   LIBINSTRUMENT_CFLAGS += -Dstrcasecmp=stricmp
 endif
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  ifeq ($(BSD_STATIC_LIBJLI), bsd)
+    LIBINSTRUMENT_LDFLAGS += -Xlinker --whole-archive $(JDK_OUTPUTDIR)/objs/libjli_static.a \
+        -Xlinker --no-whole-archive 
+  else
+    LIBINSTRUMENT_LDFLAGS += $(call SET_SHARED_LIBRARY_ORIGIN,/jli)
+  endif
+  BSD_ICONV_CFLAGS:= -I$(PACKAGE_PATH)/include
+  ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+    BSD_ICONV_CFLAGS += -DLIBICONV_PLUG
+  endif
+endif
+
 $(eval $(call SetupNativeCompilation,BUILD_LIBINSTRUMENT, \
     LIBRARY := instrument, \
     OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -255,6 +269,7 @@
     CFLAGS := $(LIBINSTRUMENT_CFLAGS), \
     CFLAGS_debug := -DJPLIS_LOGGING, \
     CFLAGS_release := -DNO_JPLIS_LOGGING, \
+    CFLAGS_bsd := $(BSD_ICONV_CFLAGS), \
     MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libinstrument/mapfile-vers, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN) \
@@ -268,6 +283,7 @@
     LDFLAGS_SUFFIX_solaris := $(LIBZ) -L $(INSTALL_LIBRARIES_HERE)/jli -ljli $(LIBDL) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBZ) -L $(INSTALL_LIBRARIES_HERE)/jli -ljli $(LIBDL), \
     LDFLAGS_SUFFIX_aix := $(LIBZ) -L$(JDK_OUTPUTDIR)/objs -ljli_static $(LIBDL),\
+    LDFLAGS_SUFFIX_bsd := -L$(PACKAGE_PATH)/lib -liconv $(LIBZ), \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
         -D "JDK_FNAME=instrument.dll" \
@@ -276,7 +292,7 @@
     OBJECT_DIR := $(LIBINSTRUMENT_DIR), \
     DEBUG_SYMBOLS := true))
 
-ifneq (, $(findstring $(OPENJDK_TARGET_OS), macosx windows aix))
+ifneq (, $(findstring $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx windows aix))
   $(BUILD_LIBINSTRUMENT): $(JDK_OUTPUTDIR)/objs/$(LIBRARY_PREFIX)jli_static$(STATIC_LIBRARY_SUFFIX)
 else
   $(BUILD_LIBINSTRUMENT): $(INSTALL_LIBRARIES_HERE)/jli/$(LIBRARY_PREFIX)jli$(SHARED_LIBRARY_SUFFIX)
@@ -302,12 +318,16 @@
   BUILD_LIBMANAGEMENT_EXCLUDES += LinuxOperatingSystem.c
 endif
 
+ifneq ($(OPENJDK_TARGET_OS), bsd)
+  BUILD_LIBMANAGEMENT_EXCLUDES += BsdOperatingSystem.c
+endif
+
 ifneq ($(OPENJDK_TARGET_OS), macosx)
   BUILD_LIBMANAGEMENT_EXCLUDES += MacosxOperatingSystem.c
 endif
 
 LIBMANAGEMENT_OPTIMIZATION := HIGH
-ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux bsd), )
   ifeq ($(ENABLE_DEBUG_SYMBOLS), true)
     LIBMANAGEMENT_OPTIMIZATION := LOW
   endif
@@ -359,7 +379,7 @@
 BUILD_LIBHPROF_LDFLAGS :=
 
 LIBHPROF_OPTIMIZATION := HIGHEST
-ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux bsd), )
   ifeq ($(ENABLE_DEBUG_SYMBOLS), true)
     LIBHPROF_OPTIMIZATION := LOW
   endif
--- ./jdk/make/lib/SoundLibraries.gmk	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/lib/SoundLibraries.gmk	Mon May 09 17:18:41 2016 -0400
@@ -75,6 +75,13 @@
   LIBJSOUND_CFLAGS += -DX_PLATFORM=X_AIX
 endif # OPENJDK_TARGET_OS aix
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+    EXTRA_SOUND_JNI_LIBS += jsoundalsa
+  endif # OPENJDK_TARGET_OS_VENDOR openbsd
+  LIBJSOUND_CFLAGS += -DX_PLATFORM=X_BSD
+endif # OPENJDK_TARGET_OS bsd
+
 ifeq ($(OPENJDK_TARGET_OS), macosx)
   LIBJSOUND_LANG := C++
   LIBJSOUND_CFLAGS += -DX_PLATFORM=X_MACOSX \
@@ -196,12 +203,14 @@
       CFLAGS := $(CFLAGS_JDKLIB) $(ALSA_CFLAGS) \
           $(LIBJSOUND_CFLAGS) \
           -DUSE_DAUDIO=TRUE \
-          -DUSE_PORTS=TRUE \
-          -DUSE_PLATFORM_MIDI_OUT=TRUE \
+          -DUSE_PORTS=TRUE, \
+      CFLAGS_linux := -DUSE_PLATFORM_MIDI_OUT=TRUE \
           -DUSE_PLATFORM_MIDI_IN=TRUE, \
+      CFLAGS_bsd := -I$(PACKAGE_PATH)/include, \
       MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libjsoundalsa/mapfile-vers, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
           $(call SET_SHARED_LIBRARY_ORIGIN), \
+      LDFLAGS_bsd := -L$(PACKAGE_PATH)/lib, \
       LDFLAGS_SUFFIX := $(ALSA_LIBS) -ljava -ljvm, \
       OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libjsoundalsa, \
       DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))
--- ./jdk/make/mapfiles/launchers/mapfile-ppc64	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/mapfiles/launchers/mapfile-ppc64	Mon May 09 17:18:41 2016 -0400
@@ -33,6 +33,7 @@
 		environ;	# Public symbols and required by Java run time
 		_environ;
 		__environ_lock;
+		__progname;
 
 	local:
 		*;
--- ./jdk/make/mapfiles/launchers/mapfile-x86	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/mapfiles/launchers/mapfile-x86	Mon May 09 17:18:41 2016 -0400
@@ -33,6 +33,7 @@
 		environ;	# Public symbols and required by Java run time
 		_environ;
 		__environ_lock;
+		__progname;
 		___Argv;	# The following are private, but as they are
 		_start;		# exported from ctr1/crtn, the clever hacker
 		_init;		# might know about them.  However note, that
--- ./jdk/make/mapfiles/launchers/mapfile-x86_64	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/mapfiles/launchers/mapfile-x86_64	Mon May 09 17:18:41 2016 -0400
@@ -33,6 +33,7 @@
 		environ;	# Public symbols and required by Java run time
 		_environ;
 		__environ_lock;
+		__progname;
 
 	local:
 		*;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/mapfiles/libattach/mapfile-bsd	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,42 @@
+#
+# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+# Define public interface.
+
+SUNWprivate_1.1 {
+	global:
+	    Java_sun_tools_attach_BsdVirtualMachine_checkPermissions;
+	    Java_sun_tools_attach_BsdVirtualMachine_close;
+	    Java_sun_tools_attach_BsdVirtualMachine_connect;
+	    Java_sun_tools_attach_BsdVirtualMachine_getTempDir;
+	    Java_sun_tools_attach_BsdVirtualMachine_open;
+	    Java_sun_tools_attach_BsdVirtualMachine_sendQuitTo;
+	    Java_sun_tools_attach_BsdVirtualMachine_socket;
+	    Java_sun_tools_attach_BsdVirtualMachine_read;
+	    Java_sun_tools_attach_BsdVirtualMachine_write;
+	    Java_sun_tools_attach_BsdVirtualMachine_createAttachFile;
+	local:
+		*;
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/mapfiles/libnio/mapfile-bsd	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,195 @@
+#
+# Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+SUNWprivate_1.1 {
+	global:
+		Java_java_nio_MappedByteBuffer_force0;
+		Java_java_nio_MappedByteBuffer_isLoaded0;
+		Java_java_nio_MappedByteBuffer_load0;
+		Java_sun_nio_ch_DatagramChannelImpl_disconnect0;
+		Java_sun_nio_ch_DatagramChannelImpl_initIDs;
+		Java_sun_nio_ch_DatagramChannelImpl_receive0;
+		Java_sun_nio_ch_DatagramChannelImpl_send0;
+		Java_sun_nio_ch_DatagramDispatcher_read0;
+		Java_sun_nio_ch_DatagramDispatcher_readv0;
+		Java_sun_nio_ch_DatagramDispatcher_write0;
+		Java_sun_nio_ch_DatagramDispatcher_writev0;
+		Java_sun_nio_ch_FileChannelImpl_close0;
+		Java_sun_nio_ch_FileChannelImpl_initIDs;
+		Java_sun_nio_ch_FileChannelImpl_map0;
+		Java_sun_nio_ch_FileChannelImpl_position0;
+		Java_sun_nio_ch_FileChannelImpl_transferTo0;
+		Java_sun_nio_ch_FileChannelImpl_unmap0;
+		Java_sun_nio_ch_FileDispatcherImpl_close0;
+		Java_sun_nio_ch_FileDispatcherImpl_closeIntFD;
+		Java_sun_nio_ch_FileDispatcherImpl_force0;
+		Java_sun_nio_ch_FileDispatcherImpl_init;
+		Java_sun_nio_ch_FileDispatcherImpl_lock0;
+		Java_sun_nio_ch_FileDispatcherImpl_preClose0;
+		Java_sun_nio_ch_FileDispatcherImpl_pread0;
+		Java_sun_nio_ch_FileDispatcherImpl_pwrite0;
+		Java_sun_nio_ch_FileDispatcherImpl_read0;
+		Java_sun_nio_ch_FileDispatcherImpl_readv0;
+		Java_sun_nio_ch_FileDispatcherImpl_release0;
+		Java_sun_nio_ch_FileDispatcherImpl_size0;
+		Java_sun_nio_ch_FileDispatcherImpl_truncate0;
+		Java_sun_nio_ch_FileDispatcherImpl_write0;
+		Java_sun_nio_ch_FileDispatcherImpl_writev0;
+		Java_sun_nio_ch_FileKey_init;
+		Java_sun_nio_ch_FileKey_initIDs;
+		Java_sun_nio_ch_IOUtil_configureBlocking;
+		Java_sun_nio_ch_IOUtil_drain;
+		Java_sun_nio_ch_IOUtil_fdLimit;
+		Java_sun_nio_ch_IOUtil_fdVal;
+		Java_sun_nio_ch_IOUtil_initIDs;
+		Java_sun_nio_ch_IOUtil_iovMax;
+		Java_sun_nio_ch_IOUtil_makePipe;
+		Java_sun_nio_ch_IOUtil_randomBytes;
+		Java_sun_nio_ch_IOUtil_setfdVal;
+		Java_sun_nio_ch_InheritedChannel_close0;
+		Java_sun_nio_ch_InheritedChannel_dup2;
+		Java_sun_nio_ch_InheritedChannel_dup;
+		Java_sun_nio_ch_InheritedChannel_open0;
+		Java_sun_nio_ch_InheritedChannel_peerAddress0;
+		Java_sun_nio_ch_InheritedChannel_peerPort0;
+		Java_sun_nio_ch_InheritedChannel_soType0;
+		Java_sun_nio_ch_KQueueArrayWrapper_init;
+		Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes;
+		Java_sun_nio_ch_KQueueArrayWrapper_interrupt;
+		Java_sun_nio_ch_KQueueArrayWrapper_kevent0;
+		Java_sun_nio_ch_KQueueArrayWrapper_register0;
+		Java_sun_nio_ch_KQueuePort_close0;
+		Java_sun_nio_ch_KQueuePort_drain1;
+		Java_sun_nio_ch_KQueuePort_interrupt;
+		Java_sun_nio_ch_KQueuePort_socketpair;
+		Java_sun_nio_ch_KQueue_filterOffset;
+		Java_sun_nio_ch_KQueue_flagsOffset;
+		Java_sun_nio_ch_KQueue_identOffset;
+		Java_sun_nio_ch_KQueue_keventPoll;
+		Java_sun_nio_ch_KQueue_keventRegister;
+		Java_sun_nio_ch_KQueue_keventSize;
+		Java_sun_nio_ch_KQueue_kqueue;
+		Java_sun_nio_ch_NativeThread_current;
+		Java_sun_nio_ch_NativeThread_init;
+		Java_sun_nio_ch_NativeThread_signal;
+		Java_sun_nio_ch_Net_bind0;
+		Java_sun_nio_ch_Net_blockOrUnblock4;
+		Java_sun_nio_ch_Net_blockOrUnblock6;
+		Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0;
+		Java_sun_nio_ch_Net_canJoin6WithIPv4Group0;
+		Java_sun_nio_ch_Net_connect0;
+		Java_sun_nio_ch_Net_getIntOption0;
+		Java_sun_nio_ch_Net_getInterface4;
+		Java_sun_nio_ch_Net_getInterface6;
+		Java_sun_nio_ch_Net_initIDs;
+		Java_sun_nio_ch_Net_isExclusiveBindAvailable;
+		Java_sun_nio_ch_Net_isIPv6Available0;
+		Java_sun_nio_ch_Net_joinOrDrop4;
+		Java_sun_nio_ch_Net_joinOrDrop6;
+		Java_sun_nio_ch_Net_listen;
+		Java_sun_nio_ch_Net_localInetAddress;
+		Java_sun_nio_ch_Net_localPort;
+		Java_sun_nio_ch_Net_poll;
+		Java_sun_nio_ch_Net_pollconnValue;
+		Java_sun_nio_ch_Net_pollerrValue;
+		Java_sun_nio_ch_Net_pollhupValue;
+		Java_sun_nio_ch_Net_pollinValue;
+		Java_sun_nio_ch_Net_pollnvalValue;
+		Java_sun_nio_ch_Net_polloutValue;
+		Java_sun_nio_ch_Net_setIntOption0;
+		Java_sun_nio_ch_Net_setInterface4;
+		Java_sun_nio_ch_Net_setInterface6;
+		Java_sun_nio_ch_Net_shutdown;
+		Java_sun_nio_ch_Net_socket0;
+		Java_sun_nio_ch_PollArrayWrapper_interrupt;
+		Java_sun_nio_ch_PollArrayWrapper_poll0;
+		Java_sun_nio_ch_ServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_ServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_SocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_SocketChannelImpl_sendOutOfBandData;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_fs_BsdNativeDispatcher_endfsstat;
+		Java_sun_nio_fs_BsdNativeDispatcher_fsstatEntry;
+		Java_sun_nio_fs_BsdNativeDispatcher_getfsstat;
+		Java_sun_nio_fs_BsdNativeDispatcher_initIDs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
+		Java_sun_nio_fs_MagicFileTypeDetector_initialize0;
+		Java_sun_nio_fs_MagicFileTypeDetector_probe0;
+		Java_sun_nio_fs_UnixCopyFile_transfer;
+		Java_sun_nio_fs_UnixNativeDispatcher_access0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chmod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_close;
+		Java_sun_nio_fs_UnixNativeDispatcher_closedir;
+		Java_sun_nio_fs_UnixNativeDispatcher_dup;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchmod;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchown;
+		Java_sun_nio_fs_UnixNativeDispatcher_fclose;
+		Java_sun_nio_fs_UnixNativeDispatcher_fdopendir;
+		Java_sun_nio_fs_UnixNativeDispatcher_fopen0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fpathconf;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstat;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstatat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_futimes;
+		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrgid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwuid;
+		Java_sun_nio_fs_UnixNativeDispatcher_init;
+		Java_sun_nio_fs_UnixNativeDispatcher_lchown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_link0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lstat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mkdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mknod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_open0;
+		Java_sun_nio_fs_UnixNativeDispatcher_openat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_opendir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_pathconf0;
+		Java_sun_nio_fs_UnixNativeDispatcher_read;
+		Java_sun_nio_fs_UnixNativeDispatcher_readdir;
+		Java_sun_nio_fs_UnixNativeDispatcher_readlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_realpath0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rename0;
+		Java_sun_nio_fs_UnixNativeDispatcher_renameat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rmdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_stat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_statvfs0;
+		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
+		Java_sun_nio_fs_UnixNativeDispatcher_symlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_utimes0;
+		Java_sun_nio_fs_UnixNativeDispatcher_write;
+		handleSocketError;
+
+	local:
+		*;
+};
--- ./jdk/make/mapfiles/libunpack/mapfile-vers-unpack200	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/mapfiles/libunpack/mapfile-vers-unpack200	Mon May 09 17:18:41 2016 -0400
@@ -26,6 +26,9 @@
 # Define library interface.
 
 SUNWprivate_1.1 {
+	global:
+	    environ;
+	    __progname;
 	local:
 	    *;
 };
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/netbeans/common/bsd-sources.ent	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+ Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+   - Neither the name of Oracle nor the names of its
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<source-folder>
+    <label>Sources for BSD Platform</label>
+    <type>java</type>
+    <location>${root}/src/bsd/classes</location>
+    <includes>${includes}</includes>
+    <excludes>${excludes}</excludes>
+    <encoding>US-ASCII</encoding>
+</source-folder>
+<source-folder>
+    <label>Sources for BSD Platform</label>
+    <location>${root}/src/bsd/classes</location>
+</source-folder>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/netbeans/common/bsd-view.ent	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+ Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+   - Neither the name of Oracle nor the names of its
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<source-folder style="tree">
+    <label>Sources for BSD Platform</label>
+    <location>${root}/src/bsd/classes</location>
+    <includes>${includes}</includes>
+    <excludes>${excludes}</excludes>
+</source-folder>
--- ./jdk/make/netbeans/common/java-data-native.ent	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/netbeans/common/java-data-native.ent	Mon May 09 17:18:41 2016 -0400
@@ -34,6 +34,7 @@
 <java-data xmlns="http://www.netbeans.org/ns/freeform-project-java/4">
     <compilation-unit>
         <package-root>${root}/src/share/classes</package-root>
+        <package-root>${root}/src/bsd/classes</package-root>
         <package-root>${root}/src/macosx/classes</package-root>
         <package-root>${root}/src/solaris/classes</package-root>
         <package-root>${root}/src/windows/classes</package-root>
--- ./jdk/make/netbeans/common/make.xml	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/netbeans/common/make.xml	Mon May 09 17:18:41 2016 -0400
@@ -32,16 +32,21 @@
 -->
 
 <project name="make" basedir="..">
-    
-    <target name="-make.init" depends="-init,-pre-init.linux,-pre-init.macosx,-pre-init.solaris,-pre-init.windows,-pre-init.macosx">
+
+    <target name="-make.init" depends="-init,-pre-init.linux,-pre-init.bsd,-pre-init.macosx,-pre-init.solaris,-pre-init.windows">
         <property name="make.options" value=""/> <!-- default, can be overridden per user or per project -->
     </target>
-    
+
     <target name="-pre-init.linux" if="os.linux">
         <property name="platform" value="linux"/>
         <property name="make" value="make"/>
     </target>
 
+    <target name="-pre-init.bsd" if="os.bsd">
+        <property name="platform" value="bsd"/>
+        <property name="make" value="gmake"/>
+    </target>
+
     <target name="-pre-init.macosx" if="os.macosx">
         <property name="platform" value="macosx"/>
         <property name="make" value="make"/>
@@ -56,7 +61,7 @@
         <property name="platform" value="windows"/>
         <property name="make" value="c:/cygwin/bin/make"/>
     </target>
-    
+
     <macrodef name="make-run">
             <attribute name="target"/>
             <attribute name="dir"/>
--- ./jdk/make/netbeans/j2se/nbproject/project.xml	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/netbeans/j2se/nbproject/project.xml	Mon May 09 17:18:41 2016 -0400
@@ -34,6 +34,7 @@
 <!DOCTYPE project [
     <!ENTITY properties SYSTEM "../../common/properties.ent">
     <!ENTITY share-sources SYSTEM "../../common/share-sources.ent">
+    <!ENTITY bsd-sources SYSTEM "../../common/bsd-sources.ent">
     <!ENTITY macosx-sources SYSTEM "../../common/macosx-sources.ent">
     <!ENTITY unix-sources SYSTEM "../../common/unix-sources.ent">
     <!ENTITY windows-sources SYSTEM "../../common/windows-sources.ent">
@@ -41,6 +42,7 @@
     <!ENTITY build-folder SYSTEM "../../common/build-folder.ent">
     <!ENTITY standard-bindings SYSTEM "../../common/standard-bindings.ent">
     <!ENTITY share-view SYSTEM "../../common/share-view.ent">
+    <!ENTITY bsd-view SYSTEM "../../common/bsd-view.ent">
     <!ENTITY macosx-view SYSTEM "../../common/macosx-view.ent">
     <!ENTITY unix-view SYSTEM "../../common/unix-view.ent">
     <!ENTITY windows-view SYSTEM "../../common/windows-view.ent">
@@ -60,6 +62,7 @@
             </properties>
             <folders>
                 &share-sources;
+                &bsd-sources;
                 &macosx-sources;
                 &unix-sources;
                 &windows-sources;
@@ -86,6 +89,7 @@
             <view>
                 <items>
                     &share-view;
+                    &bsd-view;
                     &macosx-view;
                     &unix-view;
                     &windows-view;
--- ./jdk/make/netbeans/world/nbproject/project.xml	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/make/netbeans/world/nbproject/project.xml	Mon May 09 17:18:41 2016 -0400
@@ -34,12 +34,14 @@
 <!DOCTYPE project [
     <!ENTITY properties SYSTEM "../../common/properties.ent">
     <!ENTITY share-sources SYSTEM "../../common/share-sources.ent">
+    <!ENTITY bsd-sources SYSTEM "../../common/bsd-sources.ent">
     <!ENTITY macosx-sources SYSTEM "../../common/macosx-sources.ent">
     <!ENTITY unix-sources SYSTEM "../../common/unix-sources.ent">
     <!ENTITY windows-sources SYSTEM "../../common/windows-sources.ent">
     <!ENTITY build-folder SYSTEM "../../common/build-folder.ent">
     <!ENTITY standard-bindings SYSTEM "../../common/standard-bindings.ent">
     <!ENTITY share-view SYSTEM "../../common/share-view.ent">
+    <!ENTITY bsd-view SYSTEM "../../common/bsd-view.ent">
     <!ENTITY macosx-view SYSTEM "../../common/macosx-view.ent">
     <!ENTITY unix-view SYSTEM "../../common/unix-view.ent">
     <!ENTITY windows-view SYSTEM "../../common/windows-view.ent">
@@ -58,6 +60,7 @@
             </properties>
             <folders>
                 &share-sources;
+                &bsd-sources;
                 &macosx-sources;
                 &unix-sources;
                 &windows-sources;
@@ -69,6 +72,7 @@
             <view>
                 <items>
                     &share-view;
+                    &bsd-view;
                     &macosx-view;
                     &unix-view;
                     &windows-view;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/java/net/DefaultInterface.java	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.net;
+
+/**
+ * Choose a network interface to be the default for
+ * outgoing IPv6 traffic that does not specify a scope_id (and which needs one).
+ * We choose the first interface that is up and is (in order of preference):
+ * 1. neither loopback nor point to point
+ * 2. point to point
+ * 3. loopback
+ * 4. none.
+ * Platforms that do not require a default interface implement a dummy
+ * that returns null.
+ */
+
+import java.util.Enumeration;
+import java.io.IOException;
+
+class DefaultInterface {
+
+    private final static NetworkInterface defaultInterface =
+        chooseDefaultInterface();
+
+    static NetworkInterface getDefault() {
+        return defaultInterface;
+    }
+
+    /**
+     * Choose a default interface. This method returns an interface that is
+     * both "up" and supports multicast. This method choses an interface in
+     * order of preference:
+     * 1. neither loopback nor point to point
+     * 2. point to point
+     * 3. loopback
+     *
+     * @return  the chosen interface or {@code null} if there isn't a suitable
+     *          default
+     */
+    private static NetworkInterface chooseDefaultInterface() {
+        Enumeration<NetworkInterface> nifs;
+
+        try {
+           nifs = NetworkInterface.getNetworkInterfaces();
+        } catch (IOException ignore) {
+            // unable to enumate network interfaces
+            return null;
+        }
+
+        NetworkInterface ppp = null;
+        NetworkInterface loopback = null;
+
+        while (nifs.hasMoreElements()) {
+            NetworkInterface ni = nifs.nextElement();
+            try {
+                if (ni.isUp() && ni.supportsMulticast()) {
+                    boolean isLoopback = ni.isLoopback();
+                    boolean isPPP = ni.isPointToPoint();
+                    if (!isLoopback && !isPPP) {
+                        // found an interface that is not the loopback or a
+                        // point-to-point interface
+                        return ni;
+                    }
+                    if (ppp == null && isPPP)
+                        ppp = ni;
+                    if (loopback == null && isLoopback)
+                        loopback = ni;
+                }
+            } catch (IOException skip) { }
+        }
+
+        return (ppp != null) ? ppp : loopback;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/DefaultSelectorProvider.java	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.nio.ch;
+
+import java.nio.channels.spi.SelectorProvider;
+
+/**
+ * Creates this platform's default SelectorProvider
+ */
+
+public class DefaultSelectorProvider {
+
+    /**
+     * Prevent instantiation.
+     */
+    private DefaultSelectorProvider() { }
+
+    /**
+     * Returns the default SelectorProvider.
+     */
+    public static SelectorProvider create() {
+        return new sun.nio.ch.KQueueSelectorProvider();
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/KQueueArrayWrapper.java	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueArrayWrapper.java
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollArrayWrapper
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+import java.io.IOException;
+import java.io.FileDescriptor;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+/*
+ * struct kevent {           // 32-bit    64-bit
+ *     uintptr_t ident;      //   4         8
+ *     short     filter;     //   2         2
+ *     u_short   flags;      //   2         2
+ *     u_int     fflags;     //   4         4
+ *     intptr_t  data;       //   4         8
+ *     void      *udata;     //   4         8
+ * }                  // Total:  20        32
+ *
+ * The implementation works in 32-bit and 64-bit world. We do this by calling a
+ * native function that actually sets the sizes and offsets of the fields based
+ * on which mode we're in.
+ */
+
+class KQueueArrayWrapper {
+    // kevent filters
+    static short EVFILT_READ;
+    static short EVFILT_WRITE;
+
+    // kevent struct
+    // These fields are now set by initStructSizes in the static initializer.
+    static short SIZEOF_KEVENT;
+    static short FD_OFFSET;
+    static short FILTER_OFFSET;
+
+    // kevent array size
+    static final int NUM_KEVENTS = 128;
+
+    // Are we in a 64-bit VM?
+    static boolean is64bit = false;
+
+    // The kevent array (used for outcoming events only)
+    private AllocatedNativeObject keventArray = null;
+    private long keventArrayAddress;
+
+    // The kqueue fd
+    private int kq = -1;
+
+    // The fd of the interrupt line going out
+    private int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    private int incomingInterruptFD;
+
+    static {
+        IOUtil.load();
+        initStructSizes();
+        String datamodel = java.security.AccessController.doPrivileged(
+            new sun.security.action.GetPropertyAction("sun.arch.data.model")
+        );
+        is64bit = datamodel.equals("64");
+    }
+
+    KQueueArrayWrapper() {
+        int allocationSize = SIZEOF_KEVENT * NUM_KEVENTS;
+        keventArray = new AllocatedNativeObject(allocationSize, true);
+        keventArrayAddress = keventArray.address();
+        kq = init();
+    }
+
+    // Used to update file description registrations
+    private static class Update {
+        SelChImpl channel;
+        int events;
+        Update(SelChImpl channel, int events) {
+            this.channel = channel;
+            this.events = events;
+        }
+    }
+
+    private LinkedList<Update> updateList = new LinkedList<Update>();
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+        register0(kq, fd0, 1, 0);
+    }
+
+    int getReventOps(int index) {
+        int result = 0;
+        int offset = SIZEOF_KEVENT*index + FILTER_OFFSET;
+        short filter = keventArray.getShort(offset);
+
+        // This is all that's necessary based on inspection of usage:
+        //   SinkChannelImpl, SourceChannelImpl, DatagramChannelImpl,
+        //   ServerSocketChannelImpl, SocketChannelImpl
+        if (filter == EVFILT_READ) {
+            result |= Net.POLLIN;
+        } else if (filter == EVFILT_WRITE) {
+            result |= Net.POLLOUT;
+        }
+
+        return result;
+    }
+
+    int getDescriptor(int index) {
+        int offset = SIZEOF_KEVENT*index + FD_OFFSET;
+        /* The ident field is 8 bytes in 64-bit world, however the API wants us
+         * to return an int. Hence read the 8 bytes but return as an int.
+         */
+        if (is64bit) {
+          long fd = keventArray.getLong(offset);
+          assert fd <= Integer.MAX_VALUE;
+          return (int) fd;
+        } else {
+          return keventArray.getInt(offset);
+        }
+    }
+
+    void setInterest(SelChImpl channel, int events) {
+        synchronized (updateList) {
+            // update existing registration
+            updateList.add(new Update(channel, events));
+        }
+    }
+
+    void release(SelChImpl channel) {
+        synchronized (updateList) {
+            // flush any pending updates
+            for (Iterator<Update> it = updateList.iterator(); it.hasNext();) {
+                if (it.next().channel == channel) {
+                    it.remove();
+                }
+            }
+
+            // remove
+            register0(kq, channel.getFDVal(), 0, 0);
+        }
+    }
+
+    void updateRegistrations() {
+        synchronized (updateList) {
+            Update u = null;
+            while ((u = updateList.poll()) != null) {
+                SelChImpl ch = u.channel;
+                if (!ch.isOpen())
+                    continue;
+
+                register0(kq, ch.getFDVal(), u.events & Net.POLLIN, u.events & Net.POLLOUT);
+            }
+        }
+    }
+
+
+    void close() throws IOException {
+        if (keventArray != null) {
+            keventArray.free();
+            keventArray = null;
+        }
+        if (kq >= 0) {
+            FileDispatcherImpl.closeIntFD(kq);
+            kq = -1;
+        }
+    }
+
+    int poll(long timeout) {
+        updateRegistrations();
+        int updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);
+        return updated;
+    }
+
+    void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    private native int init();
+    private static native void initStructSizes();
+
+    private native void register0(int kq, int fd, int read, int write);
+    private native int kevent0(int kq, long keventAddress, int keventCount,
+                               long timeout);
+    private static native void interrupt(int fd);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/KQueueSelectorImpl.java	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueSelectorImpl.java
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollSelectorImpl
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.io.FileDescriptor;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+class KQueueSelectorImpl
+    extends SelectorImpl
+{
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The kqueue manipulator
+    KQueueArrayWrapper kqueueWrapper;
+
+    // Count of registered descriptors (including interrupt)
+    private int totalChannels;
+
+    // Map from a file descriptor to an entry containing the selection key
+    private HashMap<Integer,MapEntry> fdMap;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    // used by updateSelectedKeys to handle cases where the same file
+    // descriptor is polled by more than one filter
+    private long updateCount;
+
+    // Used to map file descriptors to a selection key and "update count"
+    // (see updateSelectedKeys for usage).
+    private static class MapEntry {
+        SelectionKeyImpl ski;
+        long updateCount;
+        MapEntry(SelectionKeyImpl ski) {
+            this.ski = ski;
+        }
+    }
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    KQueueSelectorImpl(SelectorProvider sp) {
+        super(sp);
+        long fds = IOUtil.makePipe(false);
+        fd0 = (int)(fds >>> 32);
+        fd1 = (int)fds;
+        try {
+            kqueueWrapper = new KQueueArrayWrapper();
+            kqueueWrapper.initInterrupt(fd0, fd1);
+            fdMap = new HashMap<>();
+            totalChannels = 1;
+        } catch (Throwable t) {
+            try {
+                FileDispatcherImpl.closeIntFD(fd0);
+            } catch (IOException ioe0) {
+                t.addSuppressed(ioe0);
+            }
+            try {
+                FileDispatcherImpl.closeIntFD(fd1);
+            } catch (IOException ioe1) {
+                t.addSuppressed(ioe1);
+            }
+            throw t;
+        }
+    }
+
+
+    protected int doSelect(long timeout)
+        throws IOException
+    {
+        int entries = 0;
+        if (closed)
+            throw new ClosedSelectorException();
+        processDeregisterQueue();
+        try {
+            begin();
+            entries = kqueueWrapper.poll(timeout);
+        } finally {
+            end();
+        }
+        processDeregisterQueue();
+        return updateSelectedKeys(entries);
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by kqueue.
+     * Add the ready keys to the selected key set.
+     * If the interrupt fd has been selected, drain it and clear the interrupt.
+     */
+    private int updateSelectedKeys(int entries)
+        throws IOException
+    {
+        int numKeysUpdated = 0;
+        boolean interrupted = false;
+
+        // A file descriptor may be registered with kqueue with more than one
+        // filter and so there may be more than one event for a fd. The update
+        // count in the MapEntry tracks when the fd was last updated and this
+        // ensures that the ready ops are updated rather than replaced by a
+        // second or subsequent event.
+        updateCount++;
+
+        for (int i = 0; i < entries; i++) {
+            int nextFD = kqueueWrapper.getDescriptor(i);
+            if (nextFD == fd0) {
+                interrupted = true;
+            } else {
+                MapEntry me = fdMap.get(Integer.valueOf(nextFD));
+
+                // entry is null in the case of an interrupt
+                if (me != null) {
+                    int rOps = kqueueWrapper.getReventOps(i);
+                    SelectionKeyImpl ski = me.ski;
+                    if (selectedKeys.contains(ski)) {
+                        // first time this file descriptor has been encountered on this
+                        // update?
+                        if (me.updateCount != updateCount) {
+                            if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
+                                numKeysUpdated++;
+                                me.updateCount = updateCount;
+                            }
+                        } else {
+                            // ready ops have already been set on this update
+                            ski.channel.translateAndUpdateReadyOps(rOps, ski);
+                        }
+                    } else {
+                        ski.channel.translateAndSetReadyOps(rOps, ski);
+                        if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                            selectedKeys.add(ski);
+                            numKeysUpdated++;
+                            me.updateCount = updateCount;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (interrupted) {
+            // Clear the wakeup pipe
+            synchronized (interruptLock) {
+                IOUtil.drain(fd0);
+                interruptTriggered = false;
+            }
+        }
+        return numKeysUpdated;
+    }
+
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+
+            // prevent further wakeup
+            synchronized (interruptLock) {
+                interruptTriggered = true;
+            }
+
+            FileDispatcherImpl.closeIntFD(fd0);
+            FileDispatcherImpl.closeIntFD(fd1);
+            if (kqueueWrapper != null) {
+                kqueueWrapper.close();
+                kqueueWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+                Iterator<SelectionKey> i = keys.iterator();
+                while (i.hasNext()) {
+                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+                    deregister(ski);
+                    SelectableChannel selch = ski.channel();
+                    if (!selch.isOpen() && !selch.isRegistered())
+                        ((SelChImpl)selch).kill();
+                    i.remove();
+                }
+                totalChannels = 0;
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        if (closed)
+            throw new ClosedSelectorException();
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdMap.put(Integer.valueOf(fd), new MapEntry(ski));
+        totalChannels++;
+        keys.add(ski);
+    }
+
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        int fd = ski.channel.getFDVal();
+        fdMap.remove(Integer.valueOf(fd));
+        kqueueWrapper.release(ski.channel);
+        totalChannels--;
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+        deregister((AbstractSelectionKey)ski);
+        SelectableChannel selch = ski.channel();
+        if (!selch.isOpen() && !selch.isRegistered())
+            ((SelChImpl)selch).kill();
+    }
+
+
+    public void putEventOps(SelectionKeyImpl ski, int ops) {
+        if (closed)
+            throw new ClosedSelectorException();
+        kqueueWrapper.setInterest(ski.channel, ops);
+    }
+
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                kqueueWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+        return this;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/KQueueSelectorProvider.java	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueSelectorProvider.java
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollSelectorProvider
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+public class KQueueSelectorProvider
+extends SelectorProviderImpl
+{
+    public AbstractSelector openSelector() throws IOException {
+        return new KQueueSelectorImpl(this);
+    }
+}
--- ./jdk/src/bsd/doc/man/javah.1	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/bsd/doc/man/javah.1	Mon May 09 17:18:41 2016 -0400
@@ -8,7 +8,7 @@
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
@@ -109,7 +109,7 @@
 
 \&.:\fIyour-path\fR
 
-Example: \f3\&.:/home/avh/classes:/usr/local/java/classes\fR
+Example: \f3\&.:/home/avh/classes:/usr/local/share/java/classes\fR
 
 \fIWindows\fR:
 
--- ./jdk/src/bsd/doc/man/rmic.1	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/bsd/doc/man/rmic.1	Mon May 09 17:18:41 2016 -0400
@@ -8,7 +8,7 @@
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
@@ -92,7 +92,7 @@
 .TP
 -classpath path
 .br
-Specifies the path the \f3rmic\fR command uses to look up classes\&. This option overrides the default or the \f3CLASSPATH\fR environment variable when it is set\&. Directories are separated by colons\&. The general format for path is: \f3\&.:<your_path>\fR, for example: \f3\&.:/usr/local/java/classes\fR\&.
+Specifies the path the \f3rmic\fR command uses to look up classes\&. This option overrides the default or the \f3CLASSPATH\fR environment variable when it is set\&. Directories are separated by colons\&. The general format for path is: \f3\&.:<your_path>\fR, for example: \f3\&.:/usr/local/share/java/classes\fR\&.
 .TP
 -d \fIdirectory\fR
 .br
@@ -206,7 +206,7 @@
 .SH ENVIRONMENT\ VARIABLES    
 .TP     
 CLASSPATH
-Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/java/classes\fR\&.
+Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/share/java/classes\fR\&.
 .SH SEE\ ALSO    
 .TP 0.2i    
 \(bu
--- ./jdk/src/bsd/doc/man/rmid.1	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/bsd/doc/man/rmid.1	Mon May 09 17:18:41 2016 -0400
@@ -8,7 +8,7 @@
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
@@ -300,7 +300,7 @@
 .SH ENVIRONMENT\ VARIABLES    
 .TP     
 CLASSPATH
-Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/java/classes\fR\&.
+Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/share/java/classes\fR\&.
 .SH SEE\ ALSO    
 .TP 0.2i    
 \(bu
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/native/sun/nio/ch/KQueueArrayWrapper.c	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueArrayWrapper.c
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollArrayWrapper
+ */
+
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes(JNIEnv *env, jclass clazz)
+{
+#define CHECK_EXCEPTION() { \
+    if ((*env)->ExceptionCheck(env)) { \
+        goto exceptionOccurred; \
+    } \
+}
+
+#define CHECK_ERROR_AND_EXCEPTION(_field) { \
+    if (_field == NULL) { \
+        goto badField; \
+    } \
+    CHECK_EXCEPTION(); \
+}
+
+
+    jfieldID field;
+
+    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_READ", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, EVFILT_READ);
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_WRITE", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, EVFILT_WRITE);
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "SIZEOF_KEVENT", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, (short) sizeof(struct kevent));
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "FD_OFFSET", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, ident));
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "FILTER_OFFSET", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, filter));
+    CHECK_EXCEPTION();
+    return;
+
+badField:
+    return;
+
+exceptionOccurred:
+    return;
+
+#undef CHECK_EXCEPTION
+#undef CHECK_ERROR_AND_EXCEPTION
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_init(JNIEnv *env, jobject this)
+{
+    int kq = kqueue();
+    if (kq < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue() failed");
+    }
+    return kq;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_register0(JNIEnv *env, jobject this,
+                                             jint kq, jint fd, jint r, jint w)
+{
+    struct kevent changes[2];
+    struct kevent errors[2];
+    struct timespec dontBlock = {0, 0};
+
+    // if (r) then { register for read } else { unregister for read }
+    // if (w) then { register for write } else { unregister for write }
+    // Ignore errors - they're probably complaints about deleting non-
+    //   added filters - but provide an error array anyway because
+    //   kqueue behaves erratically if some of its registrations fail.
+    EV_SET(&changes[0], fd, EVFILT_READ,  r ? EV_ADD : EV_DELETE, 0, 0, 0);
+    EV_SET(&changes[1], fd, EVFILT_WRITE, w ? EV_ADD : EV_DELETE, 0, 0, 0);
+    kevent(kq, changes, 2, errors, 2, &dontBlock);
+}
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq,
+                                           jlong kevAddr, jint kevCount,
+                                           jlong timeout)
+{
+    struct kevent *kevs = (struct kevent *)jlong_to_ptr(kevAddr);
+    struct timespec ts;
+    struct timespec *tsp;
+    int result;
+
+    // Java timeout is in milliseconds. Convert to struct timespec.
+    // Java timeout == -1 : wait forever : timespec timeout of NULL
+    // Java timeout == 0  : return immediately : timespec timeout of zero
+    if (timeout >= 0) {
+        ts.tv_sec = timeout / 1000;
+        ts.tv_nsec = (timeout % 1000) * 1000000; //nanosec = 1 million millisec
+        tsp = &ts;
+    } else {
+        tsp = NULL;
+    }
+
+    result = kevent(kq, NULL, 0, kevs, kevCount, tsp);
+
+    if (result < 0) {
+        if (errno == EINTR) {
+            // ignore EINTR, pretend nothing was selected
+            result = 0;
+        } else {
+            JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue failed");
+        }
+    }
+
+    return result;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_interrupt(JNIEnv *env, jclass cls, jint fd)
+{
+    char c = 1;
+    if (1 != write(fd, &c, 1)) {
+        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: interrupt failed");
+    }
+}
+
--- ./jdk/src/macosx/classes/java/net/DefaultInterface.java	Tue Mar 22 11:33:41 2016 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.net;
-
-/**
- * Choose a network interface to be the default for
- * outgoing IPv6 traffic that does not specify a scope_id (and which needs one).
- * We choose the first interface that is up and is (in order of preference):
- * 1. neither loopback nor point to point
- * 2. point to point
- * 3. loopback
- * 4. none.
- * Platforms that do not require a default interface implement a dummy
- * that returns null.
- */
-
-import java.util.Enumeration;
-import java.io.IOException;
-
-class DefaultInterface {
-
-    private final static NetworkInterface defaultInterface =
-        chooseDefaultInterface();
-
-    static NetworkInterface getDefault() {
-        return defaultInterface;
-    }
-
-    /**
-     * Choose a default interface. This method returns an interface that is
-     * both "up" and supports multicast. This method choses an interface in
-     * order of preference:
-     * 1. neither loopback nor point to point
-     * 2. point to point
-     * 3. loopback
-     *
-     * @return  the chosen interface or {@code null} if there isn't a suitable
-     *          default
-     */
-    private static NetworkInterface chooseDefaultInterface() {
-        Enumeration<NetworkInterface> nifs;
-
-        try {
-           nifs = NetworkInterface.getNetworkInterfaces();
-        } catch (IOException ignore) {
-            // unable to enumate network interfaces
-            return null;
-        }
-
-        NetworkInterface ppp = null;
-        NetworkInterface loopback = null;
-
-        while (nifs.hasMoreElements()) {
-            NetworkInterface ni = nifs.nextElement();
-            try {
-                if (ni.isUp() && ni.supportsMulticast()) {
-                    boolean isLoopback = ni.isLoopback();
-                    boolean isPPP = ni.isPointToPoint();
-                    if (!isLoopback && !isPPP) {
-                        // found an interface that is not the loopback or a
-                        // point-to-point interface
-                        return ni;
-                    }
-                    if (ppp == null && isPPP)
-                        ppp = ni;
-                    if (loopback == null && isLoopback)
-                        loopback = ni;
-                }
-            } catch (IOException skip) { }
-        }
-
-        return (ppp != null) ? ppp : loopback;
-    }
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/DefaultSelectorProvider.java	Tue Mar 22 11:33:41 2016 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.nio.ch;
-
-import java.nio.channels.spi.SelectorProvider;
-
-/**
- * Creates this platform's default SelectorProvider
- */
-
-public class DefaultSelectorProvider {
-
-    /**
-     * Prevent instantiation.
-     */
-    private DefaultSelectorProvider() { }
-
-    /**
-     * Returns the default SelectorProvider.
-     */
-    public static SelectorProvider create() {
-        return new sun.nio.ch.KQueueSelectorProvider();
-    }
-
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/KQueueArrayWrapper.java	Tue Mar 22 11:33:41 2016 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,213 +0,0 @@
-/*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueArrayWrapper.java
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollArrayWrapper
- */
-
-package sun.nio.ch;
-
-import sun.misc.*;
-import java.io.IOException;
-import java.io.FileDescriptor;
-import java.util.Iterator;
-import java.util.LinkedList;
-
-/*
- * struct kevent {           // 32-bit    64-bit
- *     uintptr_t ident;      //   4         8
- *     short     filter;     //   2         2
- *     u_short   flags;      //   2         2
- *     u_int     fflags;     //   4         4
- *     intptr_t  data;       //   4         8
- *     void      *udata;     //   4         8
- * }                  // Total:  20        32
- *
- * The implementation works in 32-bit and 64-bit world. We do this by calling a
- * native function that actually sets the sizes and offsets of the fields based
- * on which mode we're in.
- */
-
-class KQueueArrayWrapper {
-    // kevent filters
-    static short EVFILT_READ;
-    static short EVFILT_WRITE;
-
-    // kevent struct
-    // These fields are now set by initStructSizes in the static initializer.
-    static short SIZEOF_KEVENT;
-    static short FD_OFFSET;
-    static short FILTER_OFFSET;
-
-    // kevent array size
-    static final int NUM_KEVENTS = 128;
-
-    // Are we in a 64-bit VM?
-    static boolean is64bit = false;
-
-    // The kevent array (used for outcoming events only)
-    private AllocatedNativeObject keventArray = null;
-    private long keventArrayAddress;
-
-    // The kqueue fd
-    private int kq = -1;
-
-    // The fd of the interrupt line going out
-    private int outgoingInterruptFD;
-
-    // The fd of the interrupt line coming in
-    private int incomingInterruptFD;
-
-    static {
-        IOUtil.load();
-        initStructSizes();
-        String datamodel = java.security.AccessController.doPrivileged(
-            new sun.security.action.GetPropertyAction("sun.arch.data.model")
-        );
-        is64bit = datamodel.equals("64");
-    }
-
-    KQueueArrayWrapper() {
-        int allocationSize = SIZEOF_KEVENT * NUM_KEVENTS;
-        keventArray = new AllocatedNativeObject(allocationSize, true);
-        keventArrayAddress = keventArray.address();
-        kq = init();
-    }
-
-    // Used to update file description registrations
-    private static class Update {
-        SelChImpl channel;
-        int events;
-        Update(SelChImpl channel, int events) {
-            this.channel = channel;
-            this.events = events;
-        }
-    }
-
-    private LinkedList<Update> updateList = new LinkedList<Update>();
-
-    void initInterrupt(int fd0, int fd1) {
-        outgoingInterruptFD = fd1;
-        incomingInterruptFD = fd0;
-        register0(kq, fd0, 1, 0);
-    }
-
-    int getReventOps(int index) {
-        int result = 0;
-        int offset = SIZEOF_KEVENT*index + FILTER_OFFSET;
-        short filter = keventArray.getShort(offset);
-
-        // This is all that's necessary based on inspection of usage:
-        //   SinkChannelImpl, SourceChannelImpl, DatagramChannelImpl,
-        //   ServerSocketChannelImpl, SocketChannelImpl
-        if (filter == EVFILT_READ) {
-            result |= Net.POLLIN;
-        } else if (filter == EVFILT_WRITE) {
-            result |= Net.POLLOUT;
-        }
-
-        return result;
-    }
-
-    int getDescriptor(int index) {
-        int offset = SIZEOF_KEVENT*index + FD_OFFSET;
-        /* The ident field is 8 bytes in 64-bit world, however the API wants us
-         * to return an int. Hence read the 8 bytes but return as an int.
-         */
-        if (is64bit) {
-          long fd = keventArray.getLong(offset);
-          assert fd <= Integer.MAX_VALUE;
-          return (int) fd;
-        } else {
-          return keventArray.getInt(offset);
-        }
-    }
-
-    void setInterest(SelChImpl channel, int events) {
-        synchronized (updateList) {
-            // update existing registration
-            updateList.add(new Update(channel, events));
-        }
-    }
-
-    void release(SelChImpl channel) {
-        synchronized (updateList) {
-            // flush any pending updates
-            for (Iterator<Update> it = updateList.iterator(); it.hasNext();) {
-                if (it.next().channel == channel) {
-                    it.remove();
-                }
-            }
-
-            // remove
-            register0(kq, channel.getFDVal(), 0, 0);
-        }
-    }
-
-    void updateRegistrations() {
-        synchronized (updateList) {
-            Update u = null;
-            while ((u = updateList.poll()) != null) {
-                SelChImpl ch = u.channel;
-                if (!ch.isOpen())
-                    continue;
-
-                register0(kq, ch.getFDVal(), u.events & Net.POLLIN, u.events & Net.POLLOUT);
-            }
-        }
-    }
-
-
-    void close() throws IOException {
-        if (keventArray != null) {
-            keventArray.free();
-            keventArray = null;
-        }
-        if (kq >= 0) {
-            FileDispatcherImpl.closeIntFD(kq);
-            kq = -1;
-        }
-    }
-
-    int poll(long timeout) {
-        updateRegistrations();
-        int updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);
-        return updated;
-    }
-
-    void interrupt() {
-        interrupt(outgoingInterruptFD);
-    }
-
-    private native int init();
-    private static native void initStructSizes();
-
-    private native void register0(int kq, int fd, int read, int write);
-    private native int kevent0(int kq, long keventAddress, int keventCount,
-                               long timeout);
-    private static native void interrupt(int fd);
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/KQueueSelectorImpl.java	Tue Mar 22 11:33:41 2016 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,263 +0,0 @@
-/*
- * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueSelectorImpl.java
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollSelectorImpl
- */
-
-package sun.nio.ch;
-
-import java.io.IOException;
-import java.io.FileDescriptor;
-import java.nio.channels.*;
-import java.nio.channels.spi.*;
-import java.util.*;
-import sun.misc.*;
-
-class KQueueSelectorImpl
-    extends SelectorImpl
-{
-    // File descriptors used for interrupt
-    protected int fd0;
-    protected int fd1;
-
-    // The kqueue manipulator
-    KQueueArrayWrapper kqueueWrapper;
-
-    // Count of registered descriptors (including interrupt)
-    private int totalChannels;
-
-    // Map from a file descriptor to an entry containing the selection key
-    private HashMap<Integer,MapEntry> fdMap;
-
-    // True if this Selector has been closed
-    private boolean closed = false;
-
-    // Lock for interrupt triggering and clearing
-    private Object interruptLock = new Object();
-    private boolean interruptTriggered = false;
-
-    // used by updateSelectedKeys to handle cases where the same file
-    // descriptor is polled by more than one filter
-    private long updateCount;
-
-    // Used to map file descriptors to a selection key and "update count"
-    // (see updateSelectedKeys for usage).
-    private static class MapEntry {
-        SelectionKeyImpl ski;
-        long updateCount;
-        MapEntry(SelectionKeyImpl ski) {
-            this.ski = ski;
-        }
-    }
-
-    /**
-     * Package private constructor called by factory method in
-     * the abstract superclass Selector.
-     */
-    KQueueSelectorImpl(SelectorProvider sp) {
-        super(sp);
-        long fds = IOUtil.makePipe(false);
-        fd0 = (int)(fds >>> 32);
-        fd1 = (int)fds;
-        try {
-            kqueueWrapper = new KQueueArrayWrapper();
-            kqueueWrapper.initInterrupt(fd0, fd1);
-            fdMap = new HashMap<>();
-            totalChannels = 1;
-        } catch (Throwable t) {
-            try {
-                FileDispatcherImpl.closeIntFD(fd0);
-            } catch (IOException ioe0) {
-                t.addSuppressed(ioe0);
-            }
-            try {
-                FileDispatcherImpl.closeIntFD(fd1);
-            } catch (IOException ioe1) {
-                t.addSuppressed(ioe1);
-            }
-            throw t;
-        }
-    }
-
-
-    protected int doSelect(long timeout)
-        throws IOException
-    {
-        int entries = 0;
-        if (closed)
-            throw new ClosedSelectorException();
-        processDeregisterQueue();
-        try {
-            begin();
-            entries = kqueueWrapper.poll(timeout);
-        } finally {
-            end();
-        }
-        processDeregisterQueue();
-        return updateSelectedKeys(entries);
-    }
-
-    /**
-     * Update the keys whose fd's have been selected by kqueue.
-     * Add the ready keys to the selected key set.
-     * If the interrupt fd has been selected, drain it and clear the interrupt.
-     */
-    private int updateSelectedKeys(int entries)
-        throws IOException
-    {
-        int numKeysUpdated = 0;
-        boolean interrupted = false;
-
-        // A file descriptor may be registered with kqueue with more than one
-        // filter and so there may be more than one event for a fd. The update
-        // count in the MapEntry tracks when the fd was last updated and this
-        // ensures that the ready ops are updated rather than replaced by a
-        // second or subsequent event.
-        updateCount++;
-
-        for (int i = 0; i < entries; i++) {
-            int nextFD = kqueueWrapper.getDescriptor(i);
-            if (nextFD == fd0) {
-                interrupted = true;
-            } else {
-                MapEntry me = fdMap.get(Integer.valueOf(nextFD));
-
-                // entry is null in the case of an interrupt
-                if (me != null) {
-                    int rOps = kqueueWrapper.getReventOps(i);
-                    SelectionKeyImpl ski = me.ski;
-                    if (selectedKeys.contains(ski)) {
-                        // first time this file descriptor has been encountered on this
-                        // update?
-                        if (me.updateCount != updateCount) {
-                            if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
-                                numKeysUpdated++;
-                                me.updateCount = updateCount;
-                            }
-                        } else {
-                            // ready ops have already been set on this update
-                            ski.channel.translateAndUpdateReadyOps(rOps, ski);
-                        }
-                    } else {
-                        ski.channel.translateAndSetReadyOps(rOps, ski);
-                        if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
-                            selectedKeys.add(ski);
-                            numKeysUpdated++;
-                            me.updateCount = updateCount;
-                        }
-                    }
-                }
-            }
-        }
-
-        if (interrupted) {
-            // Clear the wakeup pipe
-            synchronized (interruptLock) {
-                IOUtil.drain(fd0);
-                interruptTriggered = false;
-            }
-        }
-        return numKeysUpdated;
-    }
-
-
-    protected void implClose() throws IOException {
-        if (!closed) {
-            closed = true;
-
-            // prevent further wakeup
-            synchronized (interruptLock) {
-                interruptTriggered = true;
-            }
-
-            FileDispatcherImpl.closeIntFD(fd0);
-            FileDispatcherImpl.closeIntFD(fd1);
-            if (kqueueWrapper != null) {
-                kqueueWrapper.close();
-                kqueueWrapper = null;
-                selectedKeys = null;
-
-                // Deregister channels
-                Iterator<SelectionKey> i = keys.iterator();
-                while (i.hasNext()) {
-                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
-                    deregister(ski);
-                    SelectableChannel selch = ski.channel();
-                    if (!selch.isOpen() && !selch.isRegistered())
-                        ((SelChImpl)selch).kill();
-                    i.remove();
-                }
-                totalChannels = 0;
-            }
-            fd0 = -1;
-            fd1 = -1;
-        }
-    }
-
-
-    protected void implRegister(SelectionKeyImpl ski) {
-        if (closed)
-            throw new ClosedSelectorException();
-        int fd = IOUtil.fdVal(ski.channel.getFD());
-        fdMap.put(Integer.valueOf(fd), new MapEntry(ski));
-        totalChannels++;
-        keys.add(ski);
-    }
-
-
-    protected void implDereg(SelectionKeyImpl ski) throws IOException {
-        int fd = ski.channel.getFDVal();
-        fdMap.remove(Integer.valueOf(fd));
-        kqueueWrapper.release(ski.channel);
-        totalChannels--;
-        keys.remove(ski);
-        selectedKeys.remove(ski);
-        deregister((AbstractSelectionKey)ski);
-        SelectableChannel selch = ski.channel();
-        if (!selch.isOpen() && !selch.isRegistered())
-            ((SelChImpl)selch).kill();
-    }
-
-
-    public void putEventOps(SelectionKeyImpl ski, int ops) {
-        if (closed)
-            throw new ClosedSelectorException();
-        kqueueWrapper.setInterest(ski.channel, ops);
-    }
-
-
-    public Selector wakeup() {
-        synchronized (interruptLock) {
-            if (!interruptTriggered) {
-                kqueueWrapper.interrupt();
-                interruptTriggered = true;
-            }
-        }
-        return this;
-    }
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/KQueueSelectorProvider.java	Tue Mar 22 11:33:41 2016 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueSelectorProvider.java
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollSelectorProvider
- */
-
-package sun.nio.ch;
-
-import java.io.IOException;
-import java.nio.channels.*;
-import java.nio.channels.spi.*;
-
-public class KQueueSelectorProvider
-extends SelectorProviderImpl
-{
-    public AbstractSelector openSelector() throws IOException {
-        return new KQueueSelectorImpl(this);
-    }
-}
--- ./jdk/src/macosx/native/sun/nio/ch/KQueueArrayWrapper.c	Tue Mar 22 11:33:41 2016 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,171 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueArrayWrapper.c
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollArrayWrapper
- */
-
-
-#include "jni.h"
-#include "jni_util.h"
-#include "jvm.h"
-#include "jlong.h"
-
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/time.h>
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes(JNIEnv *env, jclass clazz)
-{
-#define CHECK_EXCEPTION() { \
-    if ((*env)->ExceptionCheck(env)) { \
-        goto exceptionOccurred; \
-    } \
-}
-
-#define CHECK_ERROR_AND_EXCEPTION(_field) { \
-    if (_field == NULL) { \
-        goto badField; \
-    } \
-    CHECK_EXCEPTION(); \
-}
-
-
-    jfieldID field;
-
-    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_READ", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, EVFILT_READ);
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_WRITE", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, EVFILT_WRITE);
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "SIZEOF_KEVENT", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, (short) sizeof(struct kevent));
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "FD_OFFSET", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, ident));
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "FILTER_OFFSET", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, filter));
-    CHECK_EXCEPTION();
-    return;
-
-badField:
-    return;
-
-exceptionOccurred:
-    return;
-
-#undef CHECK_EXCEPTION
-#undef CHECK_ERROR_AND_EXCEPTION
-}
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_init(JNIEnv *env, jobject this)
-{
-    int kq = kqueue();
-    if (kq < 0) {
-        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue() failed");
-    }
-    return kq;
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_register0(JNIEnv *env, jobject this,
-                                             jint kq, jint fd, jint r, jint w)
-{
-    struct kevent changes[2];
-    struct kevent errors[2];
-    struct timespec dontBlock = {0, 0};
-
-    // if (r) then { register for read } else { unregister for read }
-    // if (w) then { register for write } else { unregister for write }
-    // Ignore errors - they're probably complaints about deleting non-
-    //   added filters - but provide an error array anyway because
-    //   kqueue behaves erratically if some of its registrations fail.
-    EV_SET(&changes[0], fd, EVFILT_READ,  r ? EV_ADD : EV_DELETE, 0, 0, 0);
-    EV_SET(&changes[1], fd, EVFILT_WRITE, w ? EV_ADD : EV_DELETE, 0, 0, 0);
-    kevent(kq, changes, 2, errors, 2, &dontBlock);
-}
-
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq,
-                                           jlong kevAddr, jint kevCount,
-                                           jlong timeout)
-{
-    struct kevent *kevs = (struct kevent *)jlong_to_ptr(kevAddr);
-    struct timespec ts;
-    struct timespec *tsp;
-    int result;
-
-    // Java timeout is in milliseconds. Convert to struct timespec.
-    // Java timeout == -1 : wait forever : timespec timeout of NULL
-    // Java timeout == 0  : return immediately : timespec timeout of zero
-    if (timeout >= 0) {
-        ts.tv_sec = timeout / 1000;
-        ts.tv_nsec = (timeout % 1000) * 1000000; //nanosec = 1 million millisec
-        tsp = &ts;
-    } else {
-        tsp = NULL;
-    }
-
-    result = kevent(kq, NULL, 0, kevs, kevCount, tsp);
-
-    if (result < 0) {
-        if (errno == EINTR) {
-            // ignore EINTR, pretend nothing was selected
-            result = 0;
-        } else {
-            JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue failed");
-        }
-    }
-
-    return result;
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_interrupt(JNIEnv *env, jclass cls, jint fd)
-{
-    char c = 1;
-    if (1 != write(fd, &c, 1)) {
-        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: interrupt failed");
-    }
-}
-
--- ./jdk/src/share/bin/jli_util.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/bin/jli_util.h	Mon May 09 17:18:41 2016 -0400
@@ -87,7 +87,7 @@
 #define _LARGFILE64_SOURCE
 #define JLI_Lseek                       lseek64
 #endif
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #define JLI_Lseek                       lseek
 #endif
 #ifdef _AIX
--- ./jdk/src/share/classes/sun/awt/FontConfiguration.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/awt/FontConfiguration.java	Mon May 09 17:18:41 2016 -0400
@@ -1146,7 +1146,7 @@
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!FontUtilities.isLinux) {
+        if (!FontUtilities.isLinux && !FontUtilities.isBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
--- ./jdk/src/share/classes/sun/awt/OSInfo.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/awt/OSInfo.java	Mon May 09 17:18:41 2016 -0400
@@ -39,6 +39,7 @@
         WINDOWS,
         LINUX,
         SOLARIS,
+        BSD,
         MACOSX,
         UNKNOWN
     }
@@ -101,6 +102,10 @@
                 return SOLARIS;
             }
 
+            if (osName.endsWith("BSD")) {
+                return BSD;
+            }
+
             if (osName.contains("OS X")) {
                 return MACOSX;
             }
--- ./jdk/src/share/classes/sun/font/FontUtilities.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/font/FontUtilities.java	Mon May 09 17:18:41 2016 -0400
@@ -48,6 +48,8 @@
 
     public static boolean isLinux;
 
+    public static boolean isBSD;
+
     public static boolean isMacOSX;
 
     public static boolean isSolaris8;
@@ -78,6 +80,8 @@
 
                 isLinux = osName.startsWith("Linux");
 
+                isBSD = osName.endsWith("BSD");
+
                 isMacOSX = osName.contains("OS X"); // TODO: MacOSX
 
                 String t2kStr = System.getProperty("sun.java2d.font.scaler");
--- ./jdk/src/share/classes/sun/font/SunFontManager.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/font/SunFontManager.java	Mon May 09 17:18:41 2016 -0400
@@ -418,7 +418,7 @@
                          * registerFonts method as on-screen these JRE fonts
                          * always go through the T2K rasteriser.
                          */
-                        if (FontUtilities.isLinux) {
+                        if (FontUtilities.isLinux || FontUtilities.isBSD) {
                             /* Linux font configuration uses these fonts */
                             registerFontDir(jreFontDirName);
                         }
--- ./jdk/src/share/classes/sun/nio/cs/ext/ExtendedCharsets.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/nio/cs/ext/ExtendedCharsets.java	Mon May 09 17:18:41 2016 -0400
@@ -1306,7 +1306,7 @@
         String osName = AccessController.doPrivileged(
             new GetPropertyAction("os.name"));
         if ("SunOS".equals(osName) || "Linux".equals(osName) || "AIX".equals(osName)
-               || osName.contains("OS X")) {
+               || osName.endsWith("BSD") || osName.contains("OS X")) {
             charset("x-COMPOUND_TEXT", "COMPOUND_TEXT",
                     new String[] {
                         "COMPOUND_TEXT",        // JDK historical
--- ./jdk/src/share/classes/sun/print/PSPrinterJob.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/print/PSPrinterJob.java	Mon May 09 17:18:41 2016 -0400
@@ -1587,9 +1587,31 @@
         }
 
        String osname = System.getProperty("os.name");
-       if (osname.equals("Linux") || osname.contains("OS X")) {
+       if (osname.equals("Linux") || osname.endsWith("BSD") || osname.contains("OS X")) {
+            String lprPath = "/usr/bin/lpr";
+            if (osname.equals("FreeBSD")) {
+                final PrintService pservice = getPrintService();
+                Boolean isIPPPrinter =
+                    (Boolean)java.security.AccessController.doPrivileged(
+                    new java.security.PrivilegedAction() {
+                        public Object run() {
+                            try {
+                                Class psClass =
+                                    Class.forName("sun.print.IPPPrintService");
+                                if (psClass.isInstance(pservice)) {
+                                    return Boolean.TRUE;
+                                }
+                            } catch (Throwable t) {
+                            }
+                            return Boolean.FALSE;
+                        }
+                    });
+                if (isIPPPrinter) {
+                    lprPath = "/usr/local/bin/lpr";
+                }
+            }
             execCmd = new String[ncomps];
-            execCmd[n++] = "/usr/bin/lpr";
+            execCmd[n++] = lprPath;
             if ((pFlags & PRINTER) != 0) {
                 execCmd[n++] = "-P" + printer;
             }
--- ./jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java	Mon May 09 17:18:41 2016 -0400
@@ -48,6 +48,7 @@
                     public Boolean run() {
                             String osname = System.getProperty("os.name");
                             if (osname.startsWith("SunOS") ||
+                                osname.endsWith("BSD") ||
                                 osname.contains("OS X") ||
                                 osname.startsWith("Linux")) {
                                 return new Boolean(System.getProperty
--- ./jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	Mon May 09 17:18:41 2016 -0400
@@ -90,6 +90,12 @@
                                     "libgssapi_krb5.so",
                                     "libgssapi_krb5.so.2",
                                 };
+                            } else if (osname.endsWith("BSD")) {
+                                gssLibs = new String[]{
+                                    "libgssapi.so",
+                                    "libgssapi_krb5.so",
+                                    "libgssapi_krb5.so.10",
+                                };
                             } else if (osname.contains("OS X")) {
                                 gssLibs = new String[]{
                                     "libgssapi_krb5.dylib",
--- ./jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	Mon May 09 17:18:41 2016 -0400
@@ -31,4 +31,5 @@
 #[windows]sun.tools.attach.WindowsAttachProvider
 #[linux]sun.tools.attach.LinuxAttachProvider
 #[macosx]sun.tools.attach.BsdAttachProvider
+#[bsd]sun.tools.attach.BsdAttachProvider
 #[aix]sun.tools.attach.AixAttachProvider
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/lib/security/java.security-bsd	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,626 @@
+#
+# This is the "master security properties file".
+#
+# An alternate java.security properties file may be specified
+# from the command line via the system property
+#
+#    -Djava.security.properties=<URL>
+#
+# This properties file appends to the master security properties file.
+# If both properties files specify values for the same key, the value
+# from the command-line properties file is selected, as it is the last
+# one loaded.
+#
+# Also, if you specify
+#
+#    -Djava.security.properties==<URL> (2 equals),
+#
+# then that properties file completely overrides the master security
+# properties file.
+#
+# To disable the ability to specify an additional properties file from
+# the command line, set the key security.overridePropertiesFile
+# to false in the master security properties file. It is set to true
+# by default.
+
+# In this file, various security properties are set for use by
+# java.security classes. This is where users can statically register
+# Cryptography Package Providers ("providers" for short). The term
+# "provider" refers to a package or set of packages that supply a
+# concrete implementation of a subset of the cryptography aspects of
+# the Java Security API. A provider may, for example, implement one or
+# more digital signature algorithms or message digest algorithms.
+#
+# Each provider must implement a subclass of the Provider class.
+# To register a provider in this master security properties file,
+# specify the Provider subclass name and priority in the format
+#
+#    security.provider.<n>=<className>
+#
+# This declares a provider, and specifies its preference
+# order n. The preference order is the order in which providers are
+# searched for requested algorithms (when no specific provider is
+# requested). The order is 1-based; 1 is the most preferred, followed
+# by 2, and so on.
+#
+# <className> must specify the subclass of the Provider class whose
+# constructor sets the values of various properties that are required
+# for the Java Security API to look up the algorithms or other
+# facilities implemented by the provider.
+#
+# There must be at least one provider specification in java.security.
+# There is a default provider that comes standard with the JDK. It
+# is called the "SUN" provider, and its Provider subclass
+# named Sun appears in the sun.security.provider package. Thus, the
+# "SUN" provider is registered via the following:
+#
+#    security.provider.1=sun.security.provider.Sun
+#
+# (The number 1 is used for the default provider.)
+#
+# Note: Providers can be dynamically registered instead by calls to
+# either the addProvider or insertProviderAt method in the Security
+# class.
+
+#
+# List of providers and their preference orders (see above):
+#
+security.provider.1=sun.security.provider.Sun
+security.provider.2=sun.security.rsa.SunRsaSign
+security.provider.3=sun.security.ec.SunEC
+security.provider.4=com.sun.net.ssl.internal.ssl.Provider
+security.provider.5=com.sun.crypto.provider.SunJCE
+security.provider.6=sun.security.jgss.SunProvider
+security.provider.7=com.sun.security.sasl.Provider
+security.provider.8=org.jcp.xml.dsig.internal.dom.XMLDSigRI
+security.provider.9=sun.security.smartcardio.SunPCSC
+
+#
+# Sun Provider SecureRandom seed source.
+#
+# Select the primary source of seed data for the "SHA1PRNG" and
+# "NativePRNG" SecureRandom implementations in the "Sun" provider.
+# (Other SecureRandom implementations might also use this property.)
+#
+# On Unix-like systems (for example, Solaris/Linux/MacOS), the
+# "NativePRNG" and "SHA1PRNG" implementations obtains seed data from
+# special device files such as file:/dev/random.
+#
+# On Windows systems, specifying the URLs "file:/dev/random" or
+# "file:/dev/urandom" will enable the native Microsoft CryptoAPI seeding
+# mechanism for SHA1PRNG.
+#
+# By default, an attempt is made to use the entropy gathering device
+# specified by the "securerandom.source" Security property.  If an
+# exception occurs while accessing the specified URL:
+#
+#     SHA1PRNG:
+#         the traditional system/thread activity algorithm will be used.
+#
+#     NativePRNG:
+#         a default value of /dev/random will be used.  If neither
+#         are available, the implementation will be disabled.
+#         "file" is the only currently supported protocol type.
+#
+# The entropy gathering device can also be specified with the System
+# property "java.security.egd". For example:
+#
+#   % java -Djava.security.egd=file:/dev/random MainClass
+#
+# Specifying this System property will override the
+# "securerandom.source" Security property.
+#
+# In addition, if "file:/dev/random" or "file:/dev/urandom" is
+# specified, the "NativePRNG" implementation will be more preferred than
+# SHA1PRNG in the Sun provider.
+#
+securerandom.source=file:/dev/random
+
+#
+# A list of known strong SecureRandom implementations.
+#
+# To help guide applications in selecting a suitable strong
+# java.security.SecureRandom implementation, Java distributions should
+# indicate a list of known strong implementations using the property.
+#
+# This is a comma-separated list of algorithm and/or algorithm:provider
+# entries.
+#
+securerandom.strongAlgorithms=NativePRNGBlocking:SUN
+
+#
+# Class to instantiate as the javax.security.auth.login.Configuration
+# provider.
+#
+login.configuration.provider=sun.security.provider.ConfigFile
+
+#
+# Default login configuration file
+#
+#login.config.url.1=file:${user.home}/.java.login.config
+
+#
+# Class to instantiate as the system Policy. This is the name of the class
+# that will be used as the Policy object.
+#
+policy.provider=sun.security.provider.PolicyFile
+
+# The default is to have a single system-wide policy file,
+# and a policy file in the user's home directory.
+policy.url.1=file:${java.home}/lib/security/java.policy
+policy.url.2=file:${user.home}/.java.policy
+
+# whether or not we expand properties in the policy file
+# if this is set to false, properties (${...}) will not be expanded in policy
+# files.
+policy.expandProperties=true
+
+# whether or not we allow an extra policy to be passed on the command line
+# with -Djava.security.policy=somefile. Comment out this line to disable
+# this feature.
+policy.allowSystemProperty=true
+
+# whether or not we look into the IdentityScope for trusted Identities
+# when encountering a 1.1 signed JAR file. If the identity is found
+# and is trusted, we grant it AllPermission.
+policy.ignoreIdentityScope=false
+
+#
+# Default keystore type.
+#
+keystore.type=jks
+
+#
+# Controls compatibility mode for the JKS keystore type.
+#
+# When set to 'true', the JKS keystore type supports loading
+# keystore files in either JKS or PKCS12 format. When set to 'false'
+# it supports loading only JKS keystore files.
+#
+keystore.type.compat=true
+
+#
+# List of comma-separated packages that start with or equal this string
+# will cause a security exception to be thrown when
+# passed to checkPackageAccess unless the
+# corresponding RuntimePermission ("accessClassInPackage."+package) has
+# been granted.
+package.access=sun.,\
+               com.sun.xml.internal.,\
+               com.sun.imageio.,\
+               com.sun.istack.internal.,\
+               com.sun.jmx.,\
+               com.sun.media.sound.,\
+               com.sun.naming.internal.,\
+               com.sun.proxy.,\
+               com.sun.corba.se.,\
+               com.sun.org.apache.bcel.internal.,\
+               com.sun.org.apache.regexp.internal.,\
+               com.sun.org.apache.xerces.internal.,\
+               com.sun.org.apache.xpath.internal.,\
+               com.sun.org.apache.xalan.internal.extensions.,\
+               com.sun.org.apache.xalan.internal.lib.,\
+               com.sun.org.apache.xalan.internal.res.,\
+               com.sun.org.apache.xalan.internal.templates.,\
+               com.sun.org.apache.xalan.internal.utils.,\
+               com.sun.org.apache.xalan.internal.xslt.,\
+               com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+               com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+               com.sun.org.apache.xalan.internal.xsltc.trax.,\
+               com.sun.org.apache.xalan.internal.xsltc.util.,\
+               com.sun.org.apache.xml.internal.res.,\
+               com.sun.org.apache.xml.internal.security.,\
+               com.sun.org.apache.xml.internal.serializer.utils.,\
+               com.sun.org.apache.xml.internal.utils.,\
+               com.sun.org.glassfish.,\
+               com.oracle.xmlns.internal.,\
+               com.oracle.webservices.internal.,\
+               oracle.jrockit.jfr.,\
+               org.jcp.xml.dsig.internal.,\
+               jdk.internal.,\
+               jdk.nashorn.internal.,\
+               jdk.nashorn.tools.,\
+               com.sun.activation.registries.
+
+#
+# List of comma-separated packages that start with or equal this string
+# will cause a security exception to be thrown when
+# passed to checkPackageDefinition unless the
+# corresponding RuntimePermission ("defineClassInPackage."+package) has
+# been granted.
+#
+# by default, none of the class loaders supplied with the JDK call
+# checkPackageDefinition.
+#
+package.definition=sun.,\
+                   com.sun.xml.internal.,\
+                   com.sun.imageio.,\
+                   com.sun.istack.internal.,\
+                   com.sun.jmx.,\
+                   com.sun.media.sound.,\
+                   com.sun.naming.internal.,\
+                   com.sun.proxy.,\
+                   com.sun.corba.se.,\
+                   com.sun.org.apache.bcel.internal.,\
+                   com.sun.org.apache.regexp.internal.,\
+                   com.sun.org.apache.xerces.internal.,\
+                   com.sun.org.apache.xpath.internal.,\
+                   com.sun.org.apache.xalan.internal.extensions.,\
+                   com.sun.org.apache.xalan.internal.lib.,\
+                   com.sun.org.apache.xalan.internal.res.,\
+                   com.sun.org.apache.xalan.internal.templates.,\
+                   com.sun.org.apache.xalan.internal.utils.,\
+                   com.sun.org.apache.xalan.internal.xslt.,\
+                   com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+                   com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+                   com.sun.org.apache.xalan.internal.xsltc.trax.,\
+                   com.sun.org.apache.xalan.internal.xsltc.util.,\
+                   com.sun.org.apache.xml.internal.res.,\
+                   com.sun.org.apache.xml.internal.security.,\
+                   com.sun.org.apache.xml.internal.serializer.utils.,\
+                   com.sun.org.apache.xml.internal.utils.,\
+                   com.sun.org.glassfish.,\
+                   com.oracle.xmlns.internal.,\
+                   com.oracle.webservices.internal.,\
+                   oracle.jrockit.jfr.,\
+                   org.jcp.xml.dsig.internal.,\
+                   jdk.internal.,\
+                   jdk.nashorn.internal.,\
+                   jdk.nashorn.tools.,\
+                   com.sun.activation.registries.
+
+#
+# Determines whether this properties file can be appended to
+# or overridden on the command line via -Djava.security.properties
+#
+security.overridePropertiesFile=true
+
+#
+# Determines the default key and trust manager factory algorithms for
+# the javax.net.ssl package.
+#
+ssl.KeyManagerFactory.algorithm=SunX509
+ssl.TrustManagerFactory.algorithm=PKIX
+
+#
+# The Java-level namelookup cache policy for successful lookups:
+#
+# any negative value: caching forever
+# any positive value: the number of seconds to cache an address for
+# zero: do not cache
+#
+# default value is forever (FOREVER). For security reasons, this
+# caching is made forever when a security manager is set. When a security
+# manager is not set, the default behavior in this implementation
+# is to cache for 30 seconds.
+#
+# NOTE: setting this to anything other than the default value can have
+#       serious security implications. Do not set it unless
+#       you are sure you are not exposed to DNS spoofing attack.
+#
+#networkaddress.cache.ttl=-1
+
+# The Java-level namelookup cache policy for failed lookups:
+#
+# any negative value: cache forever
+# any positive value: the number of seconds to cache negative lookup results
+# zero: do not cache
+#
+# In some Microsoft Windows networking environments that employ
+# the WINS name service in addition to DNS, name service lookups
+# that fail may take a noticeably long time to return (approx. 5 seconds).
+# For this reason the default caching policy is to maintain these
+# results for 10 seconds.
+#
+#
+networkaddress.cache.negative.ttl=10
+
+#
+# Properties to configure OCSP for certificate revocation checking
+#
+
+# Enable OCSP
+#
+# By default, OCSP is not used for certificate revocation checking.
+# This property enables the use of OCSP when set to the value "true".
+#
+# NOTE: SocketPermission is required to connect to an OCSP responder.
+#
+# Example,
+#   ocsp.enable=true
+
+#
+# Location of the OCSP responder
+#
+# By default, the location of the OCSP responder is determined implicitly
+# from the certificate being validated. This property explicitly specifies
+# the location of the OCSP responder. The property is used when the
+# Authority Information Access extension (defined in RFC 3280) is absent
+# from the certificate or when it requires overriding.
+#
+# Example,
+#   ocsp.responderURL=http://ocsp.example.net:80
+
+#
+# Subject name of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# distinguished name (defined in RFC 2253) which identifies a certificate in
+# the set of certificates supplied during cert path validation. In cases where
+# the subject name alone is not sufficient to uniquely identify the certificate
+# then both the "ocsp.responderCertIssuerName" and
+# "ocsp.responderCertSerialNumber" properties must be used instead. When this
+# property is set then those two properties are ignored.
+#
+# Example,
+#   ocsp.responderCertSubjectName="CN=OCSP Responder, O=XYZ Corp"
+
+#
+# Issuer name of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# distinguished name (defined in RFC 2253) which identifies a certificate in
+# the set of certificates supplied during cert path validation. When this
+# property is set then the "ocsp.responderCertSerialNumber" property must also
+# be set. When the "ocsp.responderCertSubjectName" property is set then this
+# property is ignored.
+#
+# Example,
+#   ocsp.responderCertIssuerName="CN=Enterprise CA, O=XYZ Corp"
+
+#
+# Serial number of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# of hexadecimal digits (colon or space separators may be present) which
+# identifies a certificate in the set of certificates supplied during cert path
+# validation. When this property is set then the "ocsp.responderCertIssuerName"
+# property must also be set. When the "ocsp.responderCertSubjectName" property
+# is set then this property is ignored.
+#
+# Example,
+#   ocsp.responderCertSerialNumber=2A:FF:00
+
+#
+# Policy for failed Kerberos KDC lookups:
+#
+# When a KDC is unavailable (network error, service failure, etc), it is
+# put inside a blacklist and accessed less often for future requests. The
+# value (case-insensitive) for this policy can be:
+#
+# tryLast
+#    KDCs in the blacklist are always tried after those not on the list.
+#
+# tryLess[:max_retries,timeout]
+#    KDCs in the blacklist are still tried by their order in the configuration,
+#    but with smaller max_retries and timeout values. max_retries and timeout
+#    are optional numerical parameters (default 1 and 5000, which means once
+#    and 5 seconds). Please notes that if any of the values defined here is
+#    more than what is defined in krb5.conf, it will be ignored.
+#
+# Whenever a KDC is detected as available, it is removed from the blacklist.
+# The blacklist is reset when krb5.conf is reloaded. You can add
+# refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
+# reloaded whenever a JAAS authentication is attempted.
+#
+# Example,
+#   krb5.kdc.bad.policy = tryLast
+#   krb5.kdc.bad.policy = tryLess:2,2000
+krb5.kdc.bad.policy = tryLast
+
+# Algorithm restrictions for certification path (CertPath) processing
+#
+# In some environments, certain algorithms or key lengths may be undesirable
+# for certification path building and validation.  For example, "MD2" is
+# generally no longer considered to be a secure hash algorithm.  This section
+# describes the mechanism for disabling algorithms based on algorithm name
+# and/or key length.  This includes algorithms used in certificates, as well
+# as revocation information such as CRLs and signed OCSP Responses.
+#
+# The syntax of the disabled algorithm string is described as this Java
+# BNF-style:
+#   DisabledAlgorithms:
+#       " DisabledAlgorithm { , DisabledAlgorithm } "
+#
+#   DisabledAlgorithm:
+#       AlgorithmName [Constraint]
+#
+#   AlgorithmName:
+#       (see below)
+#
+#   Constraint:
+#       KeySizeConstraint
+#
+#   KeySizeConstraint:
+#       keySize Operator DecimalInteger
+#
+#   Operator:
+#       <= | < | == | != | >= | >
+#
+#   DecimalInteger:
+#       DecimalDigits
+#
+#   DecimalDigits:
+#       DecimalDigit {DecimalDigit}
+#
+#   DecimalDigit: one of
+#       1 2 3 4 5 6 7 8 9 0
+#
+# The "AlgorithmName" is the standard algorithm name of the disabled
+# algorithm. See "Java Cryptography Architecture Standard Algorithm Name
+# Documentation" for information about Standard Algorithm Names.  Matching
+# is performed using a case-insensitive sub-element matching rule.  (For
+# example, in "SHA1withECDSA" the sub-elements are "SHA1" for hashing and
+# "ECDSA" for signatures.)  If the assertion "AlgorithmName" is a
+# sub-element of the certificate algorithm name, the algorithm will be
+# rejected during certification path building and validation.  For example,
+# the assertion algorithm name "DSA" will disable all certificate algorithms
+# that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
+# will not disable algorithms related to "ECDSA".
+#
+# A "Constraint" provides further guidance for the algorithm being specified.
+# The "KeySizeConstraint" requires a key of a valid size range if the
+# "AlgorithmName" is of a key algorithm.  The "DecimalInteger" indicates the
+# key size specified in number of bits.  For example, "RSA keySize <= 1024"
+# indicates that any RSA key with key size less than or equal to 1024 bits
+# should be disabled, and "RSA keySize < 1024, RSA keySize > 2048" indicates
+# that any RSA key with key size less than 1024 or greater than 2048 should
+# be disabled. Note that the "KeySizeConstraint" only makes sense to key
+# algorithms.
+#
+# Note: This property is currently used by Oracle's PKIX implementation. It
+# is not guaranteed to be examined and used by other implementations.
+#
+# Example:
+#   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize < 2048
+#
+#
+jdk.certpath.disabledAlgorithms=MD2, RSA keySize < 1024
+
+# Algorithm restrictions for Secure Socket Layer/Transport Layer Security
+# (SSL/TLS) processing
+#
+# In some environments, certain algorithms or key lengths may be undesirable
+# when using SSL/TLS.  This section describes the mechanism for disabling
+# algorithms during SSL/TLS security parameters negotiation, including
+# protocol version negotiation, cipher suites selection, peer authentication
+# and key exchange mechanisms.
+#
+# Disabled algorithms will not be negotiated for SSL/TLS connections, even
+# if they are enabled explicitly in an application.
+#
+# For PKI-based peer authentication and key exchange mechanisms, this list
+# of disabled algorithms will also be checked during certification path
+# building and validation, including algorithms used in certificates, as
+# well as revocation information such as CRLs and signed OCSP Responses.
+# This is in addition to the jdk.certpath.disabledAlgorithms property above.
+#
+# See the specification of "jdk.certpath.disabledAlgorithms" for the
+# syntax of the disabled algorithm string.
+#
+# Note: This property is currently used by Oracle's JSSE implementation.
+# It is not guaranteed to be examined and used by other implementations.
+#
+# Example:
+#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize < 2048
+jdk.tls.disabledAlgorithms=SSLv3, RC4, DH keySize < 768
+
+# Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
+# processing in JSSE implementation.
+#
+# In some environments, a certain algorithm may be undesirable but it
+# cannot be disabled because of its use in legacy applications.  Legacy
+# algorithms may still be supported, but applications should not use them
+# as the security strength of legacy algorithms are usually not strong enough
+# in practice.
+#
+# During SSL/TLS security parameters negotiation, legacy algorithms will
+# not be negotiated unless there are no other candidates.
+#
+# The syntax of the disabled algorithm string is described as this Java
+# BNF-style:
+#   LegacyAlgorithms:
+#       " LegacyAlgorithm { , LegacyAlgorithm } "
+#
+#   LegacyAlgorithm:
+#       AlgorithmName (standard JSSE algorithm name)
+#
+# See the specification of security property "jdk.certpath.disabledAlgorithms"
+# for the syntax and description of the "AlgorithmName" notation.
+#
+# Per SSL/TLS specifications, cipher suites have the form:
+#       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
+# or
+#       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
+#
+# For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
+# key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
+# mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
+# algorithm for HMAC.
+#
+# The LegacyAlgorithm can be one of the following standard algorithm names:
+#     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
+#     2. JSSE key exchange algorithm name, e.g., RSA
+#     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
+#     4. JSSE message digest algorithm name, e.g., SHA
+#
+# See SSL/TLS specifications and "Java Cryptography Architecture Standard
+# Algorithm Name Documentation" for information about the algorithm names.
+#
+# Note: This property is currently used by Oracle's JSSE implementation.
+# It is not guaranteed to be examined and used by other implementations.
+# There is no guarantee the property will continue to exist or be of the
+# same syntax in future releases.
+#
+# Example:
+#   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
+#
+jdk.tls.legacyAlgorithms= \
+        K_NULL, C_NULL, M_NULL, \
+        DHE_DSS_EXPORT, DHE_RSA_EXPORT, DH_anon_EXPORT, DH_DSS_EXPORT, \
+        DH_RSA_EXPORT, RSA_EXPORT, \
+        DH_anon, ECDH_anon, \
+        RC4_128, RC4_40, DES_CBC, DES40_CBC
+
+# The pre-defined default finite field Diffie-Hellman ephemeral (DHE)
+# parameters for Transport Layer Security (SSL/TLS/DTLS) processing.
+#
+# In traditional SSL/TLS/DTLS connections where finite field DHE parameters
+# negotiation mechanism is not used, the server offers the client group
+# parameters, base generator g and prime modulus p, for DHE key exchange.
+# It is recommended to use dynamic group parameters.  This property defines
+# a mechanism that allows you to specify custom group parameters.
+#
+# The syntax of this property string is described as this Java BNF-style:
+#   DefaultDHEParameters:
+#       DefinedDHEParameters { , DefinedDHEParameters }
+#
+#   DefinedDHEParameters:
+#       "{" DHEPrimeModulus , DHEBaseGenerator "}"
+#
+#   DHEPrimeModulus:
+#       HexadecimalDigits
+#
+#   DHEBaseGenerator:
+#       HexadecimalDigits
+#
+#   HexadecimalDigits:
+#       HexadecimalDigit { HexadecimalDigit }
+#
+#   HexadecimalDigit: one of
+#       0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
+#
+# Whitespace characters are ignored.
+#
+# The "DefinedDHEParameters" defines the custom group parameters, prime
+# modulus p and base generator g, for a particular size of prime modulus p.
+# The "DHEPrimeModulus" defines the hexadecimal prime modulus p, and the
+# "DHEBaseGenerator" defines the hexadecimal base generator g of a group
+# parameter.  It is recommended to use safe primes for the custom group
+# parameters.
+#
+# If this property is not defined or the value is empty, the underlying JSSE
+# provider's default group parameter is used for each connection.
+#
+# If the property value does not follow the grammar, or a particular group
+# parameter is not valid, the connection will fall back and use the
+# underlying JSSE provider's default group parameter.
+#
+# Note: This property is currently used by OpenJDK's JSSE implementation. It
+# is not guaranteed to be examined and used by other implementations.
+#
+# Example:
+#   jdk.tls.server.defaultDHEParameters=
+#       { \
+#       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 \
+#       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD \
+#       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245 \
+#       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED \
+#       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381 \
+#       FFFFFFFF FFFFFFFF, 2}
--- ./jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp	Mon May 09 17:18:41 2016 -0400
@@ -62,7 +62,7 @@
 
 #endif // End of ZLIB
 
-#ifdef _BIG_ENDIAN
+#ifdef VM_BIG_ENDIAN
 #define SWAP_BYTES(a) \
     ((((a) << 8) & 0xff00) | 0x00ff) & (((a) >> 8) | 0xff00)
 #else
--- ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	Mon May 09 17:18:41 2016 -0400
@@ -121,7 +121,7 @@
 }
 
 /* conversion from/to 16 bit signed little endian to native endian samples */
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define MAP_LE_SHORT2SAMPLE(sh) ((MAP_Sample) (sh))
 #define MAP_SAMPLE2LE_SHORT(sample) (sample)
 #define MAP_SAMPLE2LE_SHORT_CLIP(sample) MAP_ClipAndConvertToShort(sample)
@@ -132,7 +132,7 @@
 #endif
 
 /* conversion from/to 16 bit signed big endian to native endian samples */
-#ifndef _LITTLE_ENDIAN
+#ifndef VM_LITTLE_ENDIAN
 #define MAP_BE_SHORT2SAMPLE(sh) ((MAP_Sample) (sh))
 #define MAP_SAMPLE2BE_SHORT(sample) (sample)
 #define MAP_SAMPLE2BE_SHORT_CLIP(sample) MAP_ClipAndConvertToShort(sample)
@@ -151,7 +151,7 @@
 #define MAP_SAMPLE2INT8_CLIP(sample) MAP_ClipAndConvertToByte(sample)
 
 /* macros for endian conversion */
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define MAP_NATIVE2LE16(a) (a)
 #define MAP_NATIVE2BE16(a) MAP_SWAP16_impl(a)
 #define MAP_NATIVE2LE32(a) (a)
--- ./jdk/src/share/native/com/sun/media/sound/Utilities.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/Utilities.c	Mon May 09 17:18:41 2016 -0400
@@ -28,7 +28,7 @@
 
 
 int UTIL_IsBigEndianPlatform() {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     return 0;
 #else
     return 1;
--- ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	Mon May 09 17:18:41 2016 -0400
@@ -40,7 +40,7 @@
 #endif
 #endif
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define __HI(x) *(1+(int*)&x)
 #define __LO(x) *(int*)&x
 #define __HIp(x) *(1+(int*)x)
--- ./jdk/src/share/native/sun/awt/image/awt_parseImage.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/image/awt_parseImage.c	Mon May 09 17:18:41 2016 -0400
@@ -624,7 +624,7 @@
     switch(type) {
         case java_awt_image_BufferedImage_TYPE_INT_ARGB:
         case java_awt_image_BufferedImage_TYPE_INT_ARGB_PRE:
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
             colorOrder[0] = 2;
             colorOrder[1] = 1;
             colorOrder[2] = 0;
@@ -637,7 +637,7 @@
 #endif
             break;
         case java_awt_image_BufferedImage_TYPE_INT_BGR:
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
             colorOrder[0] = 0;
             colorOrder[1] = 1;
             colorOrder[2] = 2;
@@ -648,7 +648,7 @@
 #endif
             break;
         case java_awt_image_BufferedImage_TYPE_INT_RGB:
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
             colorOrder[0] = 2;
             colorOrder[1] = 1;
             colorOrder[2] = 0;
--- ./jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	Mon May 09 17:18:41 2016 -0400
@@ -1176,7 +1176,7 @@
 
 #define NLUT 8
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define INDEXES    { 3, 2, 1, 0, 7, 6, 5, 4 }
 #else
 #define INDEXES    { 0, 1, 2, 3, 4, 5, 6, 7 }
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	Mon May 09 17:18:41 2016 -0400
@@ -86,7 +86,7 @@
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if defined(VM_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* defined(VM_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	Mon May 09 17:18:41 2016 -0400
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	Mon May 09 17:18:41 2016 -0400
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	Mon May 09 17:18:41 2016 -0400
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	Mon May 09 17:18:41 2016 -0400
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	Mon May 09 17:18:41 2016 -0400
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	Mon May 09 17:18:41 2016 -0400
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	Mon May 09 17:18:41 2016 -0400
@@ -95,7 +95,7 @@
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	Mon May 09 17:18:41 2016 -0400
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -613,7 +613,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -623,12 +623,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -638,7 +638,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -646,7 +646,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -656,12 +656,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -671,7 +671,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -719,7 +719,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -733,14 +733,14 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -754,7 +754,7 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -764,7 +764,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -778,14 +778,14 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -799,7 +799,7 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -852,7 +852,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -862,12 +862,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -877,12 +877,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -892,12 +892,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -907,7 +907,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -915,7 +915,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -925,12 +925,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -940,12 +940,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -955,12 +955,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -970,7 +970,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	Mon May 09 17:18:41 2016 -0400
@@ -88,7 +88,7 @@
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	Mon May 09 17:18:41 2016 -0400
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	Mon May 09 17:18:41 2016 -0400
@@ -275,11 +275,11 @@
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	Mon May 09 17:18:41 2016 -0400
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	Mon May 09 17:18:41 2016 -0400
@@ -27,9 +27,6 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
-#ifdef MACOSX
-#include <machine/endian.h>
-#endif
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
--- ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	Mon May 09 17:18:41 2016 -0400
@@ -29,7 +29,7 @@
 #ifdef MACOSX
 #include <unistd.h>
 #include <sys/param.h>
-#else
+#elif !defined(_ALLBSD_SOURCE)
 #include <malloc.h>
 #endif
 #include <mlib_types.h>
@@ -97,6 +97,9 @@
   return (void *) malloc(size);
 #elif defined(MACOSX)
   return valloc(size);
+#elif defined(_ALLBSD_SOURCE)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
 #else
   return (void *) memalign(8, size);
 #endif /* _MSC_VER */
--- ./jdk/src/share/native/sun/font/layout/LEStandalone.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/font/layout/LEStandalone.h	Mon May 09 17:18:41 2016 -0400
@@ -136,7 +136,7 @@
 #define U_CAPI extern "C"
 
 #if !defined(U_IS_BIG_ENDIAN)
-    #ifdef _LITTLE_ENDIAN
+    #ifdef VM_LITTLE_ENDIAN
         #define U_IS_BIG_ENDIAN 0
     #endif
 #endif
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/LCMS.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/LCMS.c	Mon May 09 17:18:41 2016 -0400
@@ -182,7 +182,7 @@
         return 0L;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     /* Reversing data packed into int for LE archs */
     if (isInIntPacked) {
         inFormatter ^= DOSWAP_SH(1);
--- ./jdk/src/share/native/sun/management/DiagnosticCommandImpl.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/share/native/sun/management/DiagnosticCommandImpl.c	Mon May 09 17:18:41 2016 -0400
@@ -27,6 +27,7 @@
 #include <jni.h>
 #include "management.h"
 #include "sun_management_DiagnosticCommandImpl.h"
+#include <stdlib.h>
 
 JNIEXPORT void JNICALL Java_sun_management_DiagnosticCommandImpl_setNotificationEnabled
 (JNIEnv *env, jobject dummy, jboolean enabled) {
--- ./jdk/src/solaris/back/util_md.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/back/util_md.h	Mon May 09 17:18:41 2016 -0400
@@ -51,7 +51,7 @@
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if defined(VM_LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
--- ./jdk/src/solaris/bin/ergo_i586.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/bin/ergo_i586.c	Mon May 09 17:18:41 2016 -0400
@@ -106,7 +106,7 @@
 
 #endif /* __solaris__ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -197,7 +197,7 @@
            (result == JNI_TRUE ? "true" : "false"));
   return result;
 }
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 /*
  * Routines shared by solaris-i586 and linux-i586.
--- ./jdk/src/solaris/bin/java_md_solinux.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/bin/java_md_solinux.c	Mon May 09 17:18:41 2016 -0400
@@ -35,6 +35,9 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifdef __FreeBSD__
+#include <sys/sysctl.h>
+#endif
 #include "manifest_info.h"
 #include "version_comp.h"
 
@@ -306,9 +309,9 @@
     if (llp == NULL && dmllp == NULL) {
         return JNI_FALSE;
     }
-#ifdef __linux
+#ifndef __solaris__
     /*
-     * On linux, if a binary is running as sgid or suid, glibc sets
+     * On linux and BSD, if a binary is running as sgid or suid, glibc/libc sets
      * LD_LIBRARY_PATH to the empty string for security purposes. (In contrast,
      * on Solaris the LD_LIBRARY_PATH variable for a privileged binary does not
      * lose its settings; but the dynamic linker does apply more scrutiny to the
@@ -319,12 +322,18 @@
      * libraries will be handled by the RPATH. In reality, this check is
      * redundant, as the previous check for a non-null LD_LIBRARY_PATH will
      * return back to the calling function forthwith, it is left here to safe
-     * guard against any changes, in the glibc's existing security policy.
+     * guard against any changes, in the glibc/libc's existing security policy.
      */
+#ifndef _ALLBSD_SOURCE
     if ((getgid() != getegid()) || (getuid() != geteuid())) {
         return JNI_FALSE;
     }
-#endif /* __linux */
+#else
+    if (issetugid()) {
+        return JNI_FALSE;
+    }
+#endif /* ! _ALLBSD_SOURCE */
+#endif /* ! __solaris__ */
 
     /*
      * Prevent recursions. Since LD_LIBRARY_PATH is the one which will be set by
@@ -929,8 +938,9 @@
  * onwards the filename returned in DL_info structure from dladdr is
  * an absolute pathname so technically realpath isn't required.
  * On Linux we read the executable name from /proc/self/exe.
- * As a fallback, and for platforms other than Solaris and Linux,
- * we use FindExecName to compute the executable name.
+ * On FreeBSD, we get the executable name via sysctl(3).
+ * As a fallback, and for platforms other than Solaris, Linux, and
+ * FreeBSD, we use FindExecName to compute the executable name.
  */
 const char*
 SetExecname(char **argv)
@@ -967,7 +977,17 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__solaris__ && !__linux__ */
+#elif defined(__FreeBSD__)
+    {
+        char buf[PATH_MAX+1];
+        int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+        size_t len = sizeof(buf);
+        if (sysctl(name, 4, buf, &len, NULL, 0) == 0 && len > 0) {
+            buf[len] = '\0';
+            exec_path = JLI_StringDup(buf);
+        }
+    }
+#else /* !__solaris__ && !__linux__ && !__FreeBSD__ */
     {
         /* Not implemented */
     }
@@ -1073,13 +1093,13 @@
 #define MAX_PID_STR_SZ   20
 
 void SetJavaLauncherPlatformProps() {
-   /* Linux only */
-#ifdef __linux__
+   /* Linux and BSD only */
+#ifndef __solaris__
     const char *substr = "-Dsun.java.launcher.pid=";
     char *pid_prop_str = (char *)JLI_MemAlloc(JLI_StrLen(substr) + MAX_PID_STR_SZ + 1);
     sprintf(pid_prop_str, "%s%d", substr, getpid());
     AddOption(pid_prop_str, NULL);
-#endif /* __linux__ */
+#endif /* ! __solaris__ */
 }
 
 int
--- ./jdk/src/solaris/bin/java_md_solinux.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/bin/java_md_solinux.h	Mon May 09 17:18:41 2016 -0400
@@ -26,17 +26,26 @@
 #ifndef JAVA_MD_SOLINUX_H
 #define JAVA_MD_SOLINUX_H
 
-#ifdef HAVE_GETHRTIME
+#if defined(HAVE_GETHRTIME) || defined(__FreeBSD__)
 /*
  * Support for doing cheap, accurate interval timing.
  */
+#ifdef HAVE_GETHRTIME
 #include <sys/time.h>
+#else /* __FreeBSD__ */
+#include <time.h>
+#define gethrtime() __extension__ ({ \
+    struct timespec tp; \
+    clock_gettime(CLOCK_MONOTONIC, &tp); \
+    (uint64_t)tp.tv_sec*1000000 + tp.tv_nsec/1000; \
+})
+#endif /* HAVE_GETHRTIME */
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
-#else  /* ! HAVE_GETHRTIME */
+#else /* ! HAVE_GETHRTIME && ! __FreeBSD__ */
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
-#endif /* HAVE_GETHRTIME */
+#endif /* HAVE_GETHRTIME || __FreeBSD__ */
 
 /* pointer to environment */
 extern char **environ;
@@ -48,6 +57,9 @@
 #ifdef __solaris__
 static const char *system_dir   = "/usr/jdk";
 static const char *user_dir     = "/jdk";
+#elif defined(__FreeBSD__)
+static const char *system_dir  = PACKAGE_PATH "/openjdk8";
+static const char *user_dir    = "/java";
 #else /* !__solaris__, i.e. Linux, AIX,.. */
 static const char *system_dir   = "/usr/java";
 static const char *user_dir     = "/java";
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java	Mon May 09 17:18:41 2016 -0400
@@ -82,6 +82,8 @@
 
         LINUX(LaunchMechanism.VFORK, LaunchMechanism.FORK),
 
+        MACOS(LaunchMechanism.POSIX_SPAWN, LaunchMechanism.FORK),
+
         BSD(LaunchMechanism.POSIX_SPAWN, LaunchMechanism.FORK),
 
         SOLARIS(LaunchMechanism.POSIX_SPAWN, LaunchMechanism.FORK),
@@ -105,9 +107,10 @@
                     // fall through...
                 case LINUX:
                 case AIX:
+                case BSD:
                     return javahome + "/lib/" + osArch + "/jspawnhelper";
 
-                case BSD:
+                case MACOS:
                     return javahome + "/lib/jspawnhelper";
 
                 default:
@@ -157,7 +160,8 @@
             );
 
             if (osName.equals("Linux")) { return LINUX; }
-            if (osName.contains("OS X")) { return BSD; }
+            if (osName.contains("OS X")) { return MACOS; }
+            if (osName.endsWith("BSD")) { return BSD; }
             if (osName.equals("SunOS")) { return SOLARIS; }
             if (osName.equals("AIX")) { return AIX; }
 
@@ -273,6 +277,7 @@
     void initStreams(int[] fds) throws IOException {
         switch (platform) {
             case LINUX:
+            case MACOS:
             case BSD:
                 stdin = (fds[0] == -1) ?
                         ProcessBuilder.NullOutputStream.INSTANCE :
@@ -431,6 +436,7 @@
     private void destroy(boolean force) {
         switch (platform) {
             case LINUX:
+            case MACOS:
             case BSD:
             case AIX:
                 // There is a risk that pid will be recycled, causing us to
--- ./jdk/src/solaris/classes/sun/awt/X11FontManager.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11FontManager.java	Mon May 09 17:18:41 2016 -0400
@@ -234,7 +234,7 @@
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && FontUtilities.isLinux && !isOpenJDK()) {
+            if (fileName == null && (FontUtilities.isLinux || FontUtilities.isBSD) && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -733,7 +733,7 @@
         if (fontConfigDirs == null) {
             return;
         }
-        if (FontUtilities.isLinux) {
+        if (FontUtilities.isLinux || FontUtilities.isBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
@@ -761,7 +761,7 @@
          */
         FontConfiguration mFontConfig = new MFontConfiguration(this);
         if (FontUtilities.isOpenSolaris ||
-            (FontUtilities.isLinux &&
+            ((FontUtilities.isLinux || FontUtilities.isBSD) &&
              (!mFontConfig.foundOsSpecificFile() ||
               !mFontConfig.fontFilesArePresent()) ||
              (FontUtilities.isSolaris && !mFontConfig.fontFilesArePresent()))) {
--- ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.properties	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.properties	Mon May 09 17:18:41 2016 -0400
@@ -26,134 +26,134 @@
 
 # Version
 
-# Uses Fedora Core 6 fonts and file paths.
+# Uses FreeBSD ports Tree fonts and file paths.
 version=1
 
 # Component Font Mappings
 
-dialog.plain.latin-1=DejaVu LGC Sans
+dialog.plain.latin-1=DejaVu Sans
 dialog.plain.japanese-x0208=Sazanami Gothic
-dialog.plain.korean=Baekmuk Gulim
-dialog.plain.chinese-big5=AR PL ShanHeiSun Uni
-dialog.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.plain.korean=NanumGothic
+dialog.plain.chinese-big5=AR PL UMing
+dialog.plain.chinese-gb18030=AR PL UMing
 
-dialog.bold.latin-1=DejaVu LGC Sans Bold
+dialog.bold.latin-1=DejaVu Sans Bold
 dialog.bold.japanese-x0208=Sazanami Gothic
-dialog.bold.korean=Baekmuk Gulim
-dialog.bold.chinese-big5=AR PL ShanHeiSun Uni
-dialog.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.bold.korean=NanumGothic Bold
+dialog.bold.chinese-big5=AR PL UMing
+dialog.bold.chinese-gb18030=AR PL UMing
 
-dialog.italic.latin-1=DejaVu LGC Sans Oblique
+dialog.italic.latin-1=DejaVu Sans Oblique
 dialog.italic.japanese-x0208=Sazanami Gothic
-dialog.italic.korean=Baekmuk Gulim
-dialog.italic.chinese-big5=AR PL ShanHeiSun Uni
-dialog.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.italic.korean=NanumGothic
+dialog.italic.chinese-big5=AR PL UMing
+dialog.italic.chinese-gb18030=AR PL UMing
 
-dialog.bolditalic.latin-1=DejaVu LGC Sans Bold Oblique
+dialog.bolditalic.latin-1=DejaVu Sans Bold Oblique
 dialog.bolditalic.japanese-x0208=Sazanami Gothic
-dialog.bolditalic.korean=Baekmuk Gulim
-dialog.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-dialog.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.bolditalic.korean=NanumGothic Bold
+dialog.bolditalic.chinese-big5=AR PL UMing
+dialog.bolditalic.chinese-gb18030=AR PL UMing
 
 
-sansserif.plain.latin-1=DejaVu LGC Sans
+sansserif.plain.latin-1=DejaVu Sans
 sansserif.plain.japanese-x0208=Sazanami Gothic
-sansserif.plain.korean=Baekmuk Gulim
-sansserif.plain.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.plain.korean=NanumGothic
+sansserif.plain.chinese-big5=AR PL UMing
+sansserif.plain.chinese-gb18030=AR PL UMing
 
-sansserif.bold.latin-1=DejaVu LGC Sans Bold
+sansserif.bold.latin-1=DejaVu Sans Bold
 sansserif.bold.japanese-x0208=Sazanami Gothic
-sansserif.bold.korean=Baekmuk Gulim
-sansserif.bold.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.bold.korean=NanumGothic Bold
+sansserif.bold.chinese-big5=AR PL UMing
+sansserif.bold.chinese-gb18030=AR PL UMing
 
-sansserif.italic.latin-1=DejaVu LGC Sans Oblique
+sansserif.italic.latin-1=DejaVu Sans Oblique
 sansserif.italic.japanese-x0208=Sazanami Gothic
-sansserif.italic.korean=Baekmuk Gulim
-sansserif.italic.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.italic.korean=NanumGothic
+sansserif.italic.chinese-big5=AR PL UMing
+sansserif.italic.chinese-gb18030=AR PL UMing
 
-sansserif.bolditalic.latin-1=DejaVu LGC Sans Bold Oblique
+sansserif.bolditalic.latin-1=DejaVu Sans Bold Oblique
 sansserif.bolditalic.japanese-x0208=Sazanami Gothic
-sansserif.bolditalic.korean=Baekmuk Gulim
-sansserif.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.bolditalic.korean=NanumGothic Bold
+sansserif.bolditalic.chinese-big5=AR PL UMing
+sansserif.bolditalic.chinese-gb18030=AR PL UMing
 
 
-serif.plain.latin-1=DejaVu LGC Serif
+serif.plain.latin-1=DejaVu Serif
 serif.plain.japanese-x0208=Sazanami Mincho
-serif.plain.korean=Baekmuk Batang
-serif.plain.chinese-big5=AR PL ZenKai Uni
-serif.plain.chinese-gb18030=AR PL ZenKai Uni
+serif.plain.korean=NanumMyeongjo
+serif.plain.chinese-big5=AR PL UKai
+serif.plain.chinese-gb18030=AR PL UKai
 
-serif.bold.latin-1=DejaVu LGC Serif Bold
+serif.bold.latin-1=DejaVu Serif Bold
 serif.bold.japanese-x0208=Sazanami Mincho
-serif.bold.korean=Baekmuk Batang
-serif.bold.chinese-big5=AR PL ZenKai Uni
-serif.bold.chinese-gb18030=AR PL ZenKai Uni
+serif.bold.korean=NanumMyeongjo Bold
+serif.bold.chinese-big5=AR PL UKai
+serif.bold.chinese-gb18030=AR PL UKai
 
-serif.italic.latin-1=DejaVu LGC Serif Oblique
+serif.italic.latin-1=DejaVu Serif Italic
 serif.italic.japanese-x0208=Sazanami Mincho
-serif.italic.korean=Baekmuk Batang
-serif.italic.chinese-big5=AR PL ZenKai Uni
-serif.italic.chinese-gb18030=AR PL ZenKai Uni
+serif.italic.korean=NanumMyeongjo
+serif.italic.chinese-big5=AR PL UKai
+serif.italic.chinese-gb18030=AR PL UKai
 
-serif.bolditalic.latin-1=DejaVu LGC Serif Bold Oblique
+serif.bolditalic.latin-1=DejaVu Serif Bold Italic
 serif.bolditalic.japanese-x0208=Sazanami Mincho
-serif.bolditalic.korean=Baekmuk Batang
-serif.bolditalic.chinese-big5=AR PL ZenKai Uni
-serif.bolditalic.chinese-gb18030=AR PL ZenKai Uni
+serif.bolditalic.korean=NanumMyeongjo Bold
+serif.bolditalic.chinese-big5=AR PL UKai
+serif.bolditalic.chinese-gb18030=AR PL UKai
 
 
-monospaced.plain.latin-1=DejaVu LGC Sans Mono
+monospaced.plain.latin-1=DejaVu Sans Mono
 monospaced.plain.japanese-x0208=Sazanami Gothic
-monospaced.plain.korean=Baekmuk Gulim
-monospaced.plain.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.plain.korean=NanumGothic
+monospaced.plain.chinese-big5=AR PL UMing
+monospaced.plain.chinese-gb18030=AR PL UMing
 
-monospaced.bold.latin-1=DejaVu LGC Sans Mono Bold
+monospaced.bold.latin-1=DejaVu Sans Mono Bold
 monospaced.bold.japanese-x0208=Sazanami Gothic
-monospaced.bold.korean=Baekmuk Gulim
-monospaced.bold.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.bold.korean=NanumGothic Bold
+monospaced.bold.chinese-big5=AR PL UMing
+monospaced.bold.chinese-gb18030=AR PL UMing
 
-monospaced.italic.latin-1=DejaVu LGC Sans Mono Oblique
+monospaced.italic.latin-1=DejaVu Sans Mono Oblique
 monospaced.italic.japanese-x0208=Sazanami Gothic
-monospaced.italic.korean=Baekmuk Gulim
-monospaced.italic.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.italic.korean=NanumGothic
+monospaced.italic.chinese-big5=AR PL UMing
+monospaced.italic.chinese-gb18030=AR PL UMing
 
-monospaced.bolditalic.latin-1=DejaVu LGC Sans Mono Bold Oblique
+monospaced.bolditalic.latin-1=DejaVu Sans Mono Bold Oblique
 monospaced.bolditalic.japanese-x0208=Sazanami Gothic
-monospaced.bolditalic.korean=Baekmuk Gulim
-monospaced.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.bolditalic.korean=NanumGothic Bold
+monospaced.bolditalic.chinese-big5=AR PL UMing
+monospaced.bolditalic.chinese-gb18030=AR PL UMing
 
 
-dialoginput.plain.latin-1=DejaVu LGC Sans Mono
+dialoginput.plain.latin-1=DejaVu Sans Mono
 dialoginput.plain.japanese-x0208=Sazanami Gothic
-dialoginput.plain.korean=Baekmuk Gulim
-dialoginput.plain.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.plain.korean=NanumGothic
+dialoginput.plain.chinese-big5=AR PL UMing
+dialoginput.plain.chinese-gb18030=AR PL UMing
 
-dialoginput.bold.latin-1=DejaVu LGC Sans Mono Bold
+dialoginput.bold.latin-1=DejaVu Sans Mono Bold
 dialoginput.bold.japanese-x0208=Sazanami Gothic
-dialoginput.bold.korean=Baekmuk Gulim
-dialoginput.bold.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.bold.korean=NanumGothic Bold
+dialoginput.bold.chinese-big5=AR PL UMing
+dialoginput.bold.chinese-gb18030=AR PL UMing
 
-dialoginput.italic.latin-1=DejaVu LGC Sans Mono Oblique
+dialoginput.italic.latin-1=DejaVu Sans Mono Oblique
 dialoginput.italic.japanese-x0208=Sazanami Gothic
-dialoginput.italic.korean=Baekmuk Gulim
-dialoginput.italic.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.italic.korean=NanumGothic
+dialoginput.italic.chinese-big5=AR PL UMing
+dialoginput.italic.chinese-gb18030=AR PL UMing
 
-dialoginput.bolditalic.latin-1=DejaVu LGC Sans Mono Bold Oblique
+dialoginput.bolditalic.latin-1=DejaVu Sans Mono Bold Oblique
 dialoginput.bolditalic.japanese-x0208=Sazanami Gothic
-dialoginput.bolditalic.korean=Baekmuk Gulim
-dialoginput.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.bolditalic.korean=NanumGothic Bold
+dialoginput.bolditalic.chinese-big5=AR PL UMing
+dialoginput.bolditalic.chinese-gb18030=AR PL UMing
 
 # Search Sequences
 
@@ -166,24 +166,27 @@
 
 # Font File Names
 
-filename.DejaVu_LGC_Sans=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans.ttf
-filename.DejaVu_LGC_Sans_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-Bold.ttf
-filename.DejaVu_LGC_Sans_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-Oblique.ttf
-filename.DejaVu_LGC_Sans_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-BoldOblique.ttf
+## FIXME: Should not hardcode /usr/local
+filename.DejaVu_Sans=/usr/local/lib/X11/fonts/dejavu/DejaVuSans.ttf
+filename.DejaVu_Sans_Bold=/usr/local/lib/X11/fonts/dejavu/DejaVuSans-Bold.ttf
+filename.DejaVu_Sans_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSans-Oblique.ttf
+filename.DejaVu_Sans_Bold_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSans-BoldOblique.ttf
 
-filename.DejaVu_LGC_Sans_Mono=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono.ttf
-filename.DejaVu_LGC_Sans_Mono_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-Bold.ttf
-filename.DejaVu_LGC_Sans_Mono_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-Oblique.ttf
-filename.DejaVu_LGC_Sans_Mono_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-BoldOblique.ttf
+filename.DejaVu_Sans_Mono=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono.ttf
+filename.DejaVu_Sans_Mono_Bold=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono-Bold.ttf
+filename.DejaVu_Sans_Mono_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono-Oblique.ttf
+filename.DejaVu_Sans_Mono_Bold_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono-BoldOblique.ttf
 
-filename.DejaVu_LGC_Serif=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif.ttf
-filename.DejaVu_LGC_Serif_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-Bold.ttf
-filename.DejaVu_LGC_Serif_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-Oblique.ttf
-filename.DejaVu_LGC_Serif_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-BoldOblique.ttf
+filename.DejaVu_Serif=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif.ttf
+filename.DejaVu_Serif_Bold=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif-Bold.ttf
+filename.DejaVu_Serif_Italic=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif-Italic.ttf
+filename.DejaVu_Serif_Bold_Italic=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif-BoldItalic.ttf
 
-filename.Sazanami_Gothic=/usr/share/fonts/japanese/TrueType/sazanami-gothic.ttf
-filename.Sazanami_Mincho=/usr/share/fonts/japanese/TrueType/sazanami-mincho.ttf
-filename.AR_PL_ShanHeiSun_Uni=/usr/share/fonts/chinese/TrueType/uming.ttf
-filename.AR_PL_ZenKai_Uni=/usr/share/fonts/chinese/TrueType/ukai.ttf
-filename.Baekmuk_Gulim=/usr/share/fonts/korean/TrueType/gulim.ttf
-filename.Baekmuk_Batang=/usr/share/fonts/korean/TrueType/batang.ttf
+filename.Sazanami_Gothic=/usr/local/share/font-sazanami/sazanami-gothic.ttf
+filename.Sazanami_Mincho=/usr/local/share/font-sazanami/sazanami-mincho.ttf
+filename.AR_PL_ShanHeiSun_Uni=/usr/local/share/fonts/TrueType/uming.ttc
+filename.AR_PL_ZenKai_Uni=/usr/local/share/fonts/TrueType/ukai.ttc
+filename.NanumGothic=/usr/local/lib/X11/fonts/nanum-ttf/NanumGothic.ttf
+filename.NanumGothic_Bold=/usr/local/lib/X11/fonts/nanum-ttf/NanumGothicBold.ttf
+filename.NanumMyeongjo=/usr/local/lib/X11/fonts/nanum-ttf/NanumMyeongjo.ttf
+filename.NanumMyeongjo_Bold=/usr/local/lib/X11/fonts/nanum-ttf/NanumMyeongjoBold.ttf
--- ./jdk/src/solaris/classes/sun/net/PortConfig.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/net/PortConfig.java	Mon May 09 17:18:41 2016 -0400
@@ -52,7 +52,7 @@
                     } else if (os.startsWith("SunOS")) {
                         defaultLower = 32768;
                         defaultUpper = 65535;
-                    } else if (os.contains("OS X")) {
+                    } else if (os.endsWith("BSD") || os.contains("OS X")) {
                         defaultLower = 49152;
                         defaultUpper = 65535;
                     } else if (os.startsWith("AIX")) {
--- ./jdk/src/solaris/classes/sun/nio/ch/DefaultAsynchronousChannelProvider.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/nio/ch/DefaultAsynchronousChannelProvider.java	Mon May 09 17:18:41 2016 -0400
@@ -66,7 +66,7 @@
             return createProvider("sun.nio.ch.SolarisAsynchronousChannelProvider");
         if (osname.equals("Linux"))
             return createProvider("sun.nio.ch.LinuxAsynchronousChannelProvider");
-        if (osname.contains("OS X"))
+        if (osname.endsWith("BSD") || osname.contains("OS X"))
             return createProvider("sun.nio.ch.BsdAsynchronousChannelProvider");
         if (osname.equals("AIX"))
             return createProvider("sun.nio.ch.AixAsynchronousChannelProvider");
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdFileSystemProvider.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdFileSystemProvider.java	Mon May 09 17:18:41 2016 -0400
@@ -25,10 +25,14 @@
 
 package sun.nio.fs;
 
+import java.nio.file.*;
+import java.nio.file.spi.FileTypeDetector;
 import java.io.IOException;
+import java.security.AccessController;
+import sun.security.action.GetPropertyAction;
 
 /**
- * Bsd implementation of FileSystemProvider
+ * BSD implementation of FileSystemProvider
  */
 
 public class BsdFileSystemProvider extends UnixFileSystemProvider {
@@ -45,4 +49,16 @@
     BsdFileStore getFileStore(UnixPath path) throws IOException {
         return new BsdFileStore(path);
     }
+
+    @Override
+    FileTypeDetector getFileTypeDetector() {
+        Path userMimeTypes = Paths.get(AccessController.doPrivileged(
+            new GetPropertyAction("user.home")), ".mime.types");
+        Path etcMimeTypes = Paths.get("/etc/mime.types");
+
+        return chain(new GnomeFileTypeDetector(),
+                     new MimeTypesFileTypeDetector(userMimeTypes),
+                     new MimeTypesFileTypeDetector(etcMimeTypes),
+                     new MagicFileTypeDetector());
+    }
 }
--- ./jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	Mon May 09 17:18:41 2016 -0400
@@ -61,6 +61,8 @@
             return createProvider("sun.nio.fs.SolarisFileSystemProvider");
         if (osname.equals("Linux"))
             return createProvider("sun.nio.fs.LinuxFileSystemProvider");
+        if (osname.endsWith("BSD"))
+            return createProvider("sun.nio.fs.BsdFileSystemProvider");
         if (osname.contains("OS X"))
             return createProvider("sun.nio.fs.MacOSXFileSystemProvider");
         if (osname.equals("AIX"))
--- ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	Mon May 09 17:18:41 2016 -0400
@@ -161,6 +161,7 @@
 
     static boolean isBSD() {
         return (osname.equals("Linux") ||
+                osname.endsWith("BSD") ||
                 osname.contains("OS X"));
     }
 
@@ -175,12 +176,12 @@
     static int cmdIndex = UNINITIALIZED;
 
     String[] lpcFirstCom = {
-        "/usr/sbin/lpc status | grep : | sed -ne '1,1 s/://p'",
+        "/usr/sbin/lpc status all | grep ':$' | sed -ne '1,1 s/://p'",
         "/usr/sbin/lpc status | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}'"
     };
 
     String[] lpcAllCom = {
-        "/usr/sbin/lpc status all | grep : | sed -e 's/://'",
+        "/usr/sbin/lpc status all | grep ':$' | sed -e 's/://'",
         "/usr/sbin/lpc status all | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}' | sort"
     };
 
--- ./jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java	Mon May 09 17:18:41 2016 -0400
@@ -273,7 +273,7 @@
             try {
                 b = s.getBytes("UTF-8");
             } catch (java.io.UnsupportedEncodingException x) {
-                throw new InternalError();
+                throw new InternalError(x);
             }
             BsdVirtualMachine.write(fd, b, 0, b.length);
         }
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_LinuxOS_ALSA_PCM.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_LinuxOS_ALSA_PCM.c	Mon May 09 17:18:41 2016 -0400
@@ -672,6 +672,7 @@
             return -1;
         }
         return 1;
+#ifdef ESTRPIPE
     } else if (err == -ESTRPIPE) {
         TRACE0("xrun_recovery: suspended.\n");
         ret = snd_pcm_resume(info->handle);
@@ -687,6 +688,7 @@
             return -1;
         }
         return 1;
+#endif
     } else if (err == -EAGAIN) {
         TRACE0("xrun_recovery: EAGAIN try again flag.\n");
         return 0;
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_PCM.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_PCM.c	Mon May 09 17:18:41 2016 -0400
@@ -140,7 +140,7 @@
                                       (float) ((int) sr->samp_rates[s]),
                                       DAUDIO_PCM, /* encoding - let's only do PCM */
                                       (bits[b] > 8)?TRUE:TRUE, /* isSigned */
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
                                       FALSE /* little endian */
 #else
                                       (bits[b] > 8)?TRUE:FALSE  /* big endian */
--- ./jdk/src/solaris/native/common/jni_util_md.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/common/jni_util_md.c	Mon May 09 17:18:41 2016 -0400
@@ -28,6 +28,7 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "dlfcn.h"
+#include <string.h>
 
 jstring nativeNewStringPlatform(JNIEnv *env, const char *str) {
     return NULL;
--- ./jdk/src/solaris/native/java/lang/java_props_md.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/lang/java_props_md.c	Mon May 09 17:18:41 2016 -0400
@@ -151,7 +151,7 @@
     lc = setlocale(cat, NULL);
 #endif
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__FreeBSD__)
     if (lc == NULL) {
         return 0;
     }
@@ -552,23 +552,11 @@
     sprops.sun_jnu_encoding = sprops.encoding;
 #endif
 
-#ifdef _ALLBSD_SOURCE
-#if BYTE_ORDER == _LITTLE_ENDIAN
-     sprops.unicode_encoding = "UnicodeLittle";
- #else
-     sprops.unicode_encoding = "UnicodeBig";
- #endif
-#else /* !_ALLBSD_SOURCE */
-#ifdef __linux__
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     sprops.unicode_encoding = "UnicodeLittle";
 #else
     sprops.unicode_encoding = "UnicodeBig";
 #endif
-#else
-    sprops.unicode_encoding = "UnicodeBig";
-#endif
-#endif /* _ALLBSD_SOURCE */
 
     /* user properties */
     {
--- ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	Mon May 09 17:18:41 2016 -0400
@@ -36,20 +36,13 @@
 #include <stdlib.h>
 #include <ctype.h>
 
-#ifdef _ALLBSD_SOURCE
-#include <unistd.h>
-#include <sys/param.h>
-#endif
-
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
 
 #include "java_net_Inet4AddressImpl.h"
 
-#if defined(__GLIBC__) || (defined(__FreeBSD__) && (__FreeBSD_version >= 601104))
-#define HAS_GLIBC_GETHOSTBY_R   1
-#endif
+extern jobjectArray lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6);
 
 static jclass ni_iacls;
 static jclass ni_ia4cls;
@@ -436,6 +429,17 @@
     }
 #endif
 
+#ifdef _ALLBSD_SOURCE
+    /* If we're looking up the local machine, bypass DNS lookups and get
+     * address from getifaddrs.
+     */
+    ret = lookupIfLocalhost(env, hostname, JNI_FALSE);
+    if (ret != NULL || (*env)->ExceptionCheck(env)) {
+        JNU_ReleaseStringPlatformChars(env, host, hostname);
+        return ret;
+    }
+#endif
+
     error = getaddrinfo(hostname, NULL, &hints, &res);
 
     if (error) {
--- ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	Mon May 09 17:18:41 2016 -0400
@@ -33,7 +33,7 @@
 #include <strings.h>
 #include <stdlib.h>
 #include <ctype.h>
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #include <ifaddrs.h>
 #include <net/if.h>
 #include <unistd.h> /* gethostname */
@@ -155,9 +155,9 @@
     return JNI_TRUE;
 }
 
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 /* also called from Inet4AddressImpl.c */
-__private_extern__ jobjectArray
+jobjectArray
 lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6)
 {
     jobjectArray result = NULL;
@@ -311,6 +311,19 @@
     hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);
     CHECK_NULL_RETURN(hostname, NULL);
 
+#ifdef _ALLBSD_SOURCE
+    /*
+     * If we're looking up the local machine, attempt to get the address
+     * from getifaddrs. This ensures we get an IPv6 address for the local
+     * machine.
+     */
+    ret = lookupIfLocalhost(env, hostname, JNI_TRUE);
+    if (ret != NULL || (*env)->ExceptionCheck(env)) {
+        JNU_ReleaseStringPlatformChars(env, host, hostname);
+        return ret;
+    }
+#endif
+
 #ifdef AF_INET6
     /* Try once, with our static buffer. */
     memset(&hints, 0, sizeof(hints));
--- ./jdk/src/solaris/native/java/net/NetworkInterface.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/NetworkInterface.c	Mon May 09 17:18:41 2016 -0400
@@ -67,14 +67,19 @@
 #include <sys/param.h>
 #include <sys/ioctl.h>
 #include <sys/sockio.h>
-#if defined(__APPLE__)
+#if defined(__APPLE__) || defined(__FreeBSD__)
 #include <net/ethernet.h>
 #include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#include <netinet6/in6_var.h>
+#elif defined(__NetBSD__)
+#include <net/if_ether.h>
+#endif
 #include <net/if_dl.h>
 #include <netinet/in_var.h>
 #include <ifaddrs.h>
 #endif
-#endif
 
 #include "jvm.h"
 #include "jni_util.h"
--- ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	Mon May 09 17:18:41 2016 -0400
@@ -2210,7 +2210,7 @@
                 }
             }
 #endif
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
             if (family == AF_INET6 && index == 0) {
                 index = getDefaultScopeID(env);
             }
--- ./jdk/src/solaris/native/java/net/bsd_close.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/bsd_close.c	Mon May 09 17:18:41 2016 -0400
@@ -316,11 +316,8 @@
 }
 
 int NET_Accept(int s, struct sockaddr *addr, int *addrlen) {
-    socklen_t len = *addrlen;
-    int error = accept(s, addr, &len);
-    if (error != -1)
-        *addrlen = (int)len;
-    BLOCKING_IO_RETURN_INT( s, error );
+    /* See NET_RecvFrom() */
+    BLOCKING_IO_RETURN_INT( s, accept(s, addr, (socklen_t *)addrlen) );
 }
 
 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
--- ./jdk/src/solaris/native/java/net/net_util_md.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/net_util_md.c	Mon May 09 17:18:41 2016 -0400
@@ -45,6 +45,10 @@
 #endif
 #endif
 
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -87,7 +91,7 @@
 
 void setDefaultScopeID(JNIEnv *env, struct sockaddr *him)
 {
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
     static jclass ni_class = NULL;
     static jfieldID ni_defaultIndexID;
     if (ni_class == NULL) {
--- ./jdk/src/solaris/native/java/net/net_util_md.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/net/net_util_md.h	Mon May 09 17:18:41 2016 -0400
@@ -47,7 +47,7 @@
    close subroutine does not return until the select call returns.
    ...
 */
-#if defined(__linux__) || defined(MACOSX) || defined (_AIX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE) || defined (_AIX)
 extern int NET_Timeout(int s, long timeout);
 extern int NET_Read(int s, void* buf, size_t len);
 extern int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
--- ./jdk/src/solaris/native/java/util/TimeZone_md.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/java/util/TimeZone_md.c	Mon May 09 17:18:41 2016 -0400
@@ -56,7 +56,11 @@
 #endif
 
 #if defined(__linux__) || defined(_ALLBSD_SOURCE)
+#ifdef __FreeBSD__
+static const char *ETC_TIMEZONE_FILE = "/var/db/zoneinfo";
+#else
 static const char *ETC_TIMEZONE_FILE = "/etc/timezone";
+#endif
 static const char *ZONEINFO_DIR = "/usr/share/zoneinfo";
 static const char *DEFAULT_ZONEINFO_FILE = "/etc/localtime";
 #else
@@ -69,7 +73,7 @@
 static const char *ETC_ENVIRONMENT_FILE = "/etc/environment";
 #endif
 
-#if defined(__linux__) || defined(MACOSX) || defined(__solaris__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(__solaris__)
 
 /*
  * Returns a pointer to the zone ID portion of the given zoneinfo file
@@ -215,7 +219,7 @@
     return tz;
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 /*
  * Performs Linux specific mapping and returns a zone ID
@@ -231,7 +235,7 @@
     char *buf;
     size_t size;
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /*
      * Try reading the /etc/timezone file for Debian distros. There's
      * no spec of the file format available. This parsing assumes that
@@ -255,7 +259,7 @@
             return tz;
         }
     }
-#endif /* defined(__linux__) */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     /*
      * Next, try /etc/localtime to find the zone ID.
@@ -815,7 +819,7 @@
  * Returns a GMT-offset-based zone ID. (e.g., "GMT-08:00")
  */
 
-#if defined(MACOSX)
+#if defined(_ALLBSD_SOURCE)
 
 char *
 getGMTOffsetID()
@@ -877,4 +881,4 @@
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
 }
-#endif /* MACOSX */
+#endif /* _ALLBSD_SOURCE */
--- ./jdk/src/solaris/native/sun/awt/awt_Font.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Font.c	Mon May 09 17:18:41 2016 -0400
@@ -255,7 +255,7 @@
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
--- ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Mon May 09 17:18:41 2016 -0400
@@ -121,7 +121,7 @@
  */
 
 #define MAXFRAMEBUFFERS 16
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -427,20 +427,15 @@
     if (XQueryExtension(awt_display, "RENDER",
                         &major_opcode, &first_event, &first_error))
     {
-        xrenderLibHandle = dlopen("libXrender.so.1", RTLD_LAZY | RTLD_GLOBAL);
-
-#ifdef MACOSX
-#define XRENDER_LIB "/usr/X11/lib/libXrender.dylib"
-#else
-#define XRENDER_LIB "libXrender.so"
-#endif
+        xrenderLibHandle = dlopen(VERSIONED_JNI_LIB_NAME("Xrender", "1"),
+                                  RTLD_LAZY | RTLD_GLOBAL);
 
         if (xrenderLibHandle == NULL) {
-            xrenderLibHandle = dlopen(XRENDER_LIB,
+            xrenderLibHandle = dlopen(JNI_LIB_NAME("Xrender"),
                                       RTLD_LAZY | RTLD_GLOBAL);
         }
 
-#ifndef __linux__ /* SOLARIS */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* SOLARIS */
         if (xrenderLibHandle == NULL) {
             xrenderLibHandle = dlopen("/usr/sfw/lib/libXrender.so.1",
                                       RTLD_LAZY | RTLD_GLOBAL);
@@ -584,7 +579,7 @@
 }
 
 #ifndef HEADLESS
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
     void* libHandle = NULL;
@@ -635,7 +630,7 @@
     }
 }
 #endif
-#if !defined(__linux__) && !defined(MACOSX) /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
     void* libHandle = NULL;
@@ -695,11 +690,11 @@
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1597,7 +1592,7 @@
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1610,7 +1605,7 @@
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ || MACOSX */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
--- ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	Mon May 09 17:18:41 2016 -0400
@@ -52,7 +52,7 @@
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -66,7 +66,7 @@
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -84,14 +84,14 @@
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -124,7 +124,7 @@
     XIMCallback *callbacks;     /* callback parameters */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #endif
     char        *lookup_buf;    /* buffer used for XmbLookupString */
@@ -370,7 +370,7 @@
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -473,7 +473,7 @@
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -481,7 +481,7 @@
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -573,7 +573,7 @@
     return result;
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
                                 Window parent) {
     StatusWindow *statusWindow;
@@ -886,7 +886,7 @@
         }
     }
 }
-#endif  /* __linux__ || MACOSX */
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -929,7 +929,7 @@
         return FALSE ;
     }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -942,9 +942,9 @@
             break;
         }
     }
-#else /*! __linux__ && !MACOSX */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
     on_the_spot_styles |= XIMStatusNothing;
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -998,7 +998,7 @@
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1020,7 +1020,7 @@
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ && !MACOSX */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
             pX11IMData->ic_active = XCreateIC(X11im,
                                               XNClientWindow, w,
                                               XNFocusWindow, w,
@@ -1028,7 +1028,7 @@
                                               XNPreeditAttributes, preedit,
                                               NULL);
         XFree((void *)preedit);
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
     } else {
         pX11IMData->ic_active = XCreateIC(X11im,
                                           XNClientWindow, w,
@@ -1188,7 +1188,7 @@
 
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1256,7 +1256,7 @@
  finally:
     AWT_UNLOCK();
 }
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1353,14 +1353,14 @@
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIDProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1395,9 +1395,9 @@
 
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1447,14 +1447,14 @@
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  w;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1471,7 +1471,7 @@
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1639,7 +1639,7 @@
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
--- ./jdk/src/solaris/native/sun/awt/awt_Robot.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Robot.c	Mon May 09 17:18:41 2016 -0400
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
--- ./jdk/src/solaris/native/sun/awt/extutil.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/awt/extutil.h	Mon May 09 17:18:41 2016 -0400
@@ -58,7 +58,7 @@
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
--- ./jdk/src/solaris/native/sun/awt/fontpath.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/awt/fontpath.c	Mon May 09 17:18:41 2016 -0400
@@ -23,9 +23,9 @@
  * questions.
  */
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 #include <stdio.h>
 #include <stdlib.h>
 #include <strings.h>
@@ -113,7 +113,6 @@
     OPENWINHOMELIB "locale/ar/X11/fonts/Type1",
     NULL, /* terminates the list */
 };
-
 #elif defined( __linux__)
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
@@ -140,6 +139,20 @@
     "/usr/lpp/X11/lib/X11/fonts/TrueType", /* from X11.fnt.ucs.ttf */
     NULL, /* terminates the list */
 };
+#elif defined(_ALLBSD_SOURCE)
+static char *fullBSDFontPath[] = {
+    PACKAGE_PATH "/lib/X11/fonts/TrueType",
+    PACKAGE_PATH "/lib/X11/fonts/truetype",
+    PACKAGE_PATH "/lib/X11/fonts/TTF",
+    PACKAGE_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    PACKAGE_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #endif
 
 static char **getFontConfigLocations();
@@ -381,7 +394,7 @@
 
 #endif /* !HEADLESS */
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -512,6 +525,8 @@
     knowndirs = fullSolarisFontPath;
 #elif defined(_AIX)
     knowndirs = fullAixFontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #endif
     /* REMIND: this code requires to be executed when the GraphicsEnvironment
      * is already initialised. That is always true, but if it were not so,
@@ -520,8 +535,8 @@
      */
 #ifndef HEADLESS
     if (isX11) { // The following only works in an x11 environment.
-#if defined(__linux__)
-    /* There's no headless build on linux ... */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    /* There's no headless build on linux and BSD ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
       /* Using the X11 font path to locate font files is now a fallback
@@ -536,7 +551,7 @@
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
     }
@@ -1231,7 +1246,7 @@
              */
             if (fontformat != NULL
                 && (strcmp((char*)fontformat, "TrueType") != 0)
-#if defined(__linux__) || defined(_AIX)
+#if defined(__linux__) || defined(_AIX) || defined(_ALLBSD_SOURCE)
                 && (strcmp((char*)fontformat, "Type 1") != 0)
 #endif
              ) {
--- ./jdk/src/solaris/native/sun/java2d/j2d_md.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/java2d/j2d_md.h	Mon May 09 17:18:41 2016 -0400
@@ -28,11 +28,11 @@
 #include <sys/types.h>
 
 /*
- * Linux and MACOSX's version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's version of <sys/types.h> does not define intptr_t
  */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 typedef unsigned char   jubyte;
 typedef unsigned short  jushort;
--- ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	Mon May 09 17:18:41 2016 -0400
@@ -63,9 +63,6 @@
  *    MLIB_EDGE_SRC_PADDED
  */
 
-#ifdef MACOSX
-#include <machine/endian.h>
-#endif
 #include <mlib_image.h>
 #include <mlib_ImageZoom.h>
 
@@ -102,7 +99,7 @@
 
 /***************************************************************/
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -111,7 +108,7 @@
   0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
 };
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
@@ -120,7 +117,7 @@
   0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 
@@ -344,11 +341,11 @@
 #ifdef _NO_LONGLONG
 
 typedef struct {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   mlib_u32 uint1, uint0;
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
   mlib_u32 uint0, uint1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 } two_uint;
 
 /***************************************************************/
@@ -511,11 +508,11 @@
         DTYPE mask;
         MASK(mask);
         off *= 8;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         LSHIFT(dd_old, da[0], 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
         RSHIFT(dd_old, da[0], 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
@@ -540,30 +537,30 @@
 
           res = (res & 0xff) | (res >> 8);
           dd = gray_mask[res];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 /* *da++ = (dd_old >> (64 - off)) | (dd << off);*/
           RSHIFT(dd_old, dd_old, 64 - off);
           LSHIFT(dtmp, dd, off);
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 /* *da++ = (dd_old << (64 - off)) | (dd >> off);*/
           LSHIFT(dd_old, dd_old, 64 - off);
           RSHIFT(dtmp, dd, off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           LOGIC(*da++, dd_old, dtmp, |);
           dd_old = dd;
         }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 /* da[0] = (dd_old >> (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) << off));*/
         LSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         RSHIFT(dtmp1, dd_old, 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 /* da[0] = (dd_old << (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) >> off));*/
         RSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         LSHIFT(dtmp1, dd_old, 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         LOGIC(da[0], dtmp, dtmp1, |);
       }
       else {                                               /* aligned */
--- ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	Mon May 09 17:18:41 2016 -0400
@@ -804,7 +804,7 @@
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/native/sun/management/BsdOperatingSystem.c	Mon May 09 17:18:41 2016 -0400
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <jni.h>
+#include "jvm.h"
+#include "sun_management_OperatingSystemImpl.h"
+
+JNIEXPORT jdouble JNICALL
+Java_sun_management_OperatingSystemImpl_getSystemCpuLoad
+(JNIEnv *env, jobject dummy)
+{
+    return (jdouble) -1;
+}
+
+JNIEXPORT jdouble JNICALL
+Java_sun_management_OperatingSystemImpl_getProcessCpuLoad
+(JNIEnv *env, jobject dummy)
+{
+    return (jdouble) -1;
+}
--- ./jdk/src/solaris/native/sun/management/OperatingSystemImpl.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/management/OperatingSystemImpl.c	Mon May 09 17:18:41 2016 -0400
@@ -56,6 +56,9 @@
 #include <limits.h>
 #include <stdlib.h>
 #include <unistd.h>
+#ifdef __FreeBSD__
+#include <vm/vm_param.h>
+#endif
 
 #if defined(_AIX)
 #include <libperfstat.h>
@@ -168,6 +171,25 @@
         throw_internal_error(env, "sysctlbyname failed");
     }
     return available ? (jlong)vmusage.xsu_avail : (jlong)vmusage.xsu_total;
+#elif defined(__FreeBSD__)
+    struct xswdev xsw;
+    size_t mibsize, size;
+    jlong npages;
+    int mib[16], n;
+
+    mibsize = sizeof(mib) / sizeof(mib[0]);
+    if (sysctlnametomib("vm.swap_info", mib, &mibsize) == -1)
+       return (0);
+    for (n = 0, npages = 0; ; n++) {
+       mib[mibsize] = n;
+       size = sizeof(xsw);
+       if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+           break;
+       npages += xsw.xsw_nblks;
+       if (available)
+           npages -= xsw.xsw_used;
+    }
+    return (npages * page_size);
 #else /* _ALLBSD_SOURCE */
     /*
      * XXXBSD: there's no way available to get swap info in
@@ -243,11 +265,30 @@
         throw_internal_error(env, "task_info failed");
     }
     return t_info.virtual_size;
+#elif defined(__FreeBSD__)
+    FILE *fp;
+    unsigned long end, start;
+    jlong total = 0;
+
+    if ((fp = fopen("/proc/curproc/map", "r")) == NULL) {
+        throw_internal_error(env, "Unable to open /proc/curproc/map");
+        return -1;
+    }
+
+    for (;;) {
+       // Ignore everything except start and end entries
+       if (fscanf(fp, "0x%lx 0x%lx %*[^\n]\n", &start, &end) != 2 || start > end)
+           break;
+       total += end - start;
+    }
+
+    fclose(fp);
+    return total;
 #else /* _ALLBSD_SOURCE */
     /*
-     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     * XXXBSD: there's no way available to do it in BSD, AFAIK.
      */
-    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    // throw_internal_error(env, "Unimplemented in BSD");
     return (64 * MB);
 #endif
 }
@@ -324,11 +365,27 @@
         return -1;
     }
     return (jlong)vm_stats.free_count * page_size;
+#elif defined(__FreeBSD__)
+    static const char *vm_stats[] = {
+       "vm.stats.vm.v_free_count",
+       "vm.stats.vm.v_cache_count",
+       /* "vm.stats.vm.v_inactive_count", */
+       NULL
+    };
+    size_t size;
+    jlong free_pages;
+    u_int i, npages;
+    for (i = 0, free_pages = 0, size = sizeof(npages); vm_stats[i] != NULL; i++) {
+       if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1)
+           return 0;
+       free_pages += npages;
+    }
+    return (free_pages * page_size);
 #elif defined(_ALLBSD_SOURCE)
     /*
-     * XXBSDL no way to do it in FreeBSD
+     * XXBSDL no way to do it in BSD
      */
-    // throw_internal_error(env, "unimplemented in FreeBSD")
+    // throw_internal_error(env, "unimplemented in BSD")
     return (128 * MB);
 #elif defined(_AIX)
     perfstat_memory_total_t memory_info;
@@ -346,13 +403,19 @@
 Java_sun_management_OperatingSystemImpl_getTotalPhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(_SC_PHYS_PAGES)
     jlong result = 0;
     int mib[2];
     size_t rlen;
 
     mib[0] = CTL_HW;
+#if defined (HW_MEMSIZE) // Apple
     mib[1] = HW_MEMSIZE;
+#elif defined(HW_PHYSMEM) // Most of BSD
+    mib[1] = HW_PHYSMEM;
+#else
+  #error No ways to get physmem
+#endif
     rlen = sizeof(result);
     if (sysctl(mib, 2, &result, &rlen, NULL, 0) != 0) {
         throw_internal_error(env, "sysctl failed");
@@ -372,6 +435,11 @@
 }
 
 
+#ifdef _ALLBSD_SOURCE
+#define FD_DIR "/dev/fd"
+#else
+#define FD_DIR "/proc/self/fd"
+#endif
 
 JNIEXPORT jlong JNICALL
 Java_sun_management_OperatingSystemImpl_getOpenFileDescriptorCount
@@ -421,12 +489,6 @@
     free(fds);
 
     return nfiles;
-#elif defined(_ALLBSD_SOURCE)
-    /*
-     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
-     */
-    // throw_internal_error(env, "Unimplemented in FreeBSD");
-    return (100);
 #else /* solaris/linux */
     DIR *dirp;
     struct dirent dbuf;
@@ -444,7 +506,7 @@
 
     dirp = opendir(FD_DIR);
     if (dirp == NULL) {
-        throw_internal_error(env, "Unable to open directory /proc/self/fd");
+        throw_internal_error(env, "Unable to open directory " FD_DIR);
         return -1;
     }
 
--- ./jdk/src/solaris/native/sun/net/portconfig.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/net/portconfig.c	Mon May 09 17:18:41 2016 -0400
@@ -67,6 +67,24 @@
         range->lower = net_getParam("/dev/tcp", "tcp_smallest_anon_port");
         return 0;
     }
+#elif defined(__OpenBSD__)
+    {
+        int mib[3];
+        mib[0] = CTL_NET;
+        mib[1] = PF_INET;
+
+        mib[2] = IPCTL_IPPORT_HIFIRSTAUTO;
+        size_t rlen = sizeof(range->lower);
+        if (sysctl(mib, 3, &range->lower, &rlen, NULL, 0) == -1)
+            return -1;
+
+        mib[2] = IPCTL_IPPORT_HILASTAUTO;
+        rlen = sizeof(range->higher);
+        if (sysctl(mib, 3, &range->higher, &rlen, NULL, 0) == -1)
+            return -1;
+
+        return 0;
+    }
 #elif defined(_ALLBSD_SOURCE)
     {
         int ret;
--- ./jdk/src/solaris/native/sun/nio/ch/sctp/Sctp.h	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/sctp/Sctp.h	Mon May 09 17:18:41 2016 -0400
@@ -67,7 +67,7 @@
 
 
 
-#else /* __linux__ */
+#elif defined(__linux__)
 #include <stdint.h>
 #include <linux/types.h>
 #include <sys/socket.h>
@@ -319,9 +319,20 @@
 typedef int sctp_bindx_func(int sd, struct sockaddr *addrs, int addrcnt, int flags);
 typedef int sctp_peeloff_func(int sock, sctp_assoc_t id);
 
+#elif defined(__FreeBSD__)
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/sctp.h>
+#include <netinet/sctp_peeloff.h>
+#include <netinet/sctp_uio.h>
+#include "jni.h"
 
 #endif /* __linux__ */
 
+#ifndef __FreeBSD__
+
 sctp_getladdrs_func* nio_sctp_getladdrs;
 sctp_freeladdrs_func* nio_sctp_freeladdrs;
 sctp_getpaddrs_func* nio_sctp_getpaddrs;
@@ -329,6 +340,17 @@
 sctp_bindx_func* nio_sctp_bindx;
 sctp_peeloff_func* nio_sctp_peeloff;
 
+#else
+
+#define nio_sctp_getladdrs     sctp_getladdrs
+#define nio_sctp_freeladdrs    sctp_freeladdrs
+#define nio_sctp_getpaddrs     sctp_getpaddrs
+#define nio_sctp_freepaddrs    sctp_freepaddrs
+#define nio_sctp_bindx         sctp_bindx
+#define nio_sctp_peeloff       sctp_peeloff
+
+#endif
+
 jboolean loadSocketExtensionFuncs(JNIEnv* env);
 
 #endif /* !SUN_NIO_CH_SCTP_H */
--- ./jdk/src/solaris/native/sun/nio/ch/sctp/SctpNet.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/sctp/SctpNet.c	Mon May 09 17:18:41 2016 -0400
@@ -58,6 +58,7 @@
  */
 jboolean loadSocketExtensionFuncs
   (JNIEnv* env) {
+#ifndef __FreeBSD__
     if (dlopen(nativeSctpLib, RTLD_GLOBAL | RTLD_LAZY) == NULL) {
         JNU_ThrowByName(env, "java/lang/UnsupportedOperationException",
               dlerror());
@@ -105,6 +106,7 @@
               dlerror());
         return JNI_FALSE;
     }
+#endif
 
     funcsLoaded = JNI_TRUE;
     return JNI_TRUE;
--- ./jdk/src/solaris/native/sun/nio/fs/MagicFileTypeDetector.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/MagicFileTypeDetector.c	Mon May 09 17:18:41 2016 -0400
@@ -31,6 +31,12 @@
 #include <dlfcn.h>
 #include <string.h>
 
+#ifdef __FreeBSD__
+#define MAGIC_MAJOR_VERSION "4"
+#else
+#define MAGIC_MAJOR_VERSION "1"
+#endif
+
 #define MAGIC_MIME_TYPE 0x000010 /* Return the MIME type */
 
 typedef struct magic_set magic_t;
@@ -54,7 +60,7 @@
 {
     magic_handle = dlopen("libmagic.so", RTLD_LAZY);
     if (magic_handle == NULL) {
-        magic_handle = dlopen("libmagic.so.1", RTLD_LAZY);
+        magic_handle = dlopen("libmagic.so." MAGIC_MAJOR_VERSION, RTLD_LAZY);
         if (magic_handle == NULL) {
             return JNI_FALSE;
         }
--- ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	Mon May 09 17:18:41 2016 -0400
@@ -54,7 +54,7 @@
     }
 
     // look up existing handle only, do not load
-#if defined(AIX)
+#if defined(AIX) || !defined(RTLD_NOLOAD)
     void *hModule = dlopen(libName, RTLD_LAZY);
 #else
     void *hModule = dlopen(libName, RTLD_NOLOAD);
--- ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	Mon May 09 17:18:41 2016 -0400
@@ -37,7 +37,9 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#ifndef __FreeBSD__
 #include <sys/syslimits.h>
+#endif
 #include <sys/un.h>
 #include <fcntl.h>
 
--- ./jdk/src/solaris/native/sun/xawt/XWindow.c	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/solaris/native/sun/xawt/XWindow.c	Mon May 09 17:18:41 2016 -0400
@@ -886,7 +886,7 @@
 {
     KeySym originalKeysym = *keysym;
 
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
--- ./jdk/src/windows/native/com/sun/media/sound/PLATFORM_API_WinOS_DirectSound.cpp	Tue Mar 22 11:33:41 2016 -0700
+++ ./jdk/src/windows/native/com/sun/media/sound/PLATFORM_API_WinOS_DirectSound.cpp	Mon May 09 17:18:41 2016 -0400
@@ -308,7 +308,7 @@
                                       DAUDIO_PCM,
                                       (bitsArray[bitIndex]==8)?FALSE:TRUE,  /* signed */
                                       (bitsArray[bitIndex]==8)?FALSE:
-#ifndef _LITTLE_ENDIAN
+#ifndef VM_LITTLE_ENDIAN
                                       TRUE /* big endian */
 #else
                                       FALSE /* little endian */
@@ -860,7 +860,7 @@
         return NULL;
     }
     if (sampleSizeInBits > 8 &&
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         isBigEndian
 #else
         !isBigEndian
