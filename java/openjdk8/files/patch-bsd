--- ./common/autoconf/build-performance.m4	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/build-performance.m4	Mon Sep 03 11:10:31 2018 -0700
@@ -41,6 +41,10 @@
     # Looks like a MacOSX system
     NUM_CORES=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Cores' | awk  '{print [$]5}'`
     FOUND_CORES=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    NUM_CORES=`/sbin/sysctl -n hw.ncpu`
+    FOUND_CORES=yes
   elif test "x$OPENJDK_BUILD_OS" = xaix ; then
     NUM_CORES=`/usr/sbin/prtconf | grep "^Number Of Processors" | awk '{ print [$]4 }'`
     FOUND_CORES=yes
@@ -79,6 +83,15 @@
     MEMORY_SIZE=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Memory' | awk  '{print [$]2}'`
     MEMORY_SIZE=`expr $MEMORY_SIZE \* 1024`
     FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o OpenBSD)" = xOpenBSD; then
+    # Looks like an OpenBSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem | awk '{print int($NF / 1048576); }'`
+    FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem`
+    MEMORY_SIZE=`expr $MEMORY_SIZE / 1024 / 1024`
+    FOUND_MEM=yes
   elif test "x$OPENJDK_BUILD_OS" = xwindows; then
     # Windows, but without cygwin
     MEMORY_SIZE=`wmic computersystem get totalphysicalmemory -value | grep = | cut -d "=" -f 2-`
@@ -199,8 +212,8 @@
     # Only use ccache if it is 3.1.4 or later, which supports
     # precompiled headers.
     AC_MSG_CHECKING([if ccache supports precompiled headers])
-    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | grep -E 3.1.@<:@456789@:>@) 2> /dev/null`
-    if test "x$HAS_GOOD_CCACHE" = x; then
+    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | awk '{ split(@S|@3, a, "."); if (a@<:@1@:>@ >= 3 && (a@<:@2@:>@ > 1 || (a@<:@2@:>@ == 1 && a@<:@3@:>@ >= 4))) print "yes"; else print "no"; }') 2> /dev/null`
+    if test "x$HAS_GOOD_CCACHE" = xyes; then
       AC_MSG_RESULT([no, disabling ccache])
       CCACHE=
     else
--- ./common/autoconf/generated-configure.sh	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/generated-configure.sh	Mon Sep 03 11:10:31 2018 -0700
@@ -646,6 +646,8 @@
 LIBM
 LIBZIP_CAN_USE_MMAP
 USE_EXTERNAL_LIBZ
+GIFLIB_LDFLAGS
+GIFLIB_CFLAGS
 USE_EXTERNAL_LIBGIF
 USE_EXTERNAL_LIBJPEG
 ALSA_LIBS
@@ -824,6 +826,7 @@
 JDK_MAJOR_VERSION
 USER_RELEASE_SUFFIX
 COMPRESS_JARS
+BSD_STATIC_LIBJLI
 UNLIMITED_CRYPTO
 CACERTS_FILE
 TEST_IN_BUILD
@@ -900,6 +903,7 @@
 OPENJDK_TARGET_CPU_ARCH
 OPENJDK_TARGET_CPU
 OPENJDK_TARGET_OS_API
+OPENJDK_TARGET_OS_VENDOR
 OPENJDK_TARGET_OS
 OPENJDK_BUILD_CPU_ENDIAN
 OPENJDK_BUILD_CPU_BITS
@@ -1032,6 +1036,7 @@
 enable_hotspot_test_in_build
 with_cacerts_file
 enable_unlimited_crypto
+enable_static_libjli
 with_milestone
 with_update_version
 with_user_release_suffix
@@ -1058,6 +1063,7 @@
 with_extra_cflags
 with_extra_cxxflags
 with_extra_ldflags
+with_package_path
 enable_debug_symbols
 enable_zip_debug_info
 enable_macosx_runtime_support
@@ -1734,6 +1740,7 @@
                           run the Queens test after Hotspot build [disabled]
   --enable-unlimited-crypto
                           Enable unlimited crypto policy [disabled]
+  --enable-static-libjli  Enable staticly linking libjli on bsd [disabled]
   --disable-debug-symbols disable generation of debug symbols [enabled]
   --disable-zip-debug-info
                           disable zipping of debug-info files [enabled]
@@ -1830,6 +1837,8 @@
   --with-extra-cflags     extra flags to be used when compiling jdk c-files
   --with-extra-cxxflags   extra flags to be used when compiling jdk c++-files
   --with-extra-ldflags    extra flags to be used when linking jdk
+  --with-package-path     package path to be used for location of third party
+                          packages
   --with-x                use the X Window System
   --with-cups             specify prefix directory for the cups package
                           (expecting the headers under PATH/include)
@@ -3744,7 +3753,7 @@
 
 
 #
-# Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -6840,11 +6849,27 @@
       as_fn_error $? "unsupported operating system $build_os" "$LINENO" 5
       ;;
   esac
+  # The BSD's have slight differences so determine which one we are building on.
+  # For the rest set VAR_OS_VENDOR to VAR_OS
+  case "$build_os" in
+    *openbsd*)
+      VAR_OS_VENDOR=openbsd
+      ;;
+    *netbsd*)
+      VAR_OS_VENDOR=netbsd
+      ;;
+    *freebsd*)
+      VAR_OS_VENDOR=freebsd
+      ;;
+    *)
+      VAR_OS_VENDOR="$VAR_OS"
+      ;;
+  esac
 
 
   # First argument is the cpu name from the trip/quad
   case "$build_cpu" in
-    x86_64)
+    amd64|x86_64)
       VAR_CPU=x86_64
       VAR_CPU_ARCH=x86
       VAR_CPU_BITS=64
@@ -6977,11 +7002,27 @@
       as_fn_error $? "unsupported operating system $host_os" "$LINENO" 5
       ;;
   esac
+  # The BSD's have slight differences so determine which one we are building on.
+  # For the rest set VAR_OS_VENDOR to VAR_OS
+  case "$host_os" in
+    *openbsd*)
+      VAR_OS_VENDOR=openbsd
+      ;;
+    *netbsd*)
+      VAR_OS_VENDOR=netbsd
+      ;;
+    *freebsd*)
+      VAR_OS_VENDOR=freebsd
+      ;;
+    *)
+      VAR_OS_VENDOR="$VAR_OS"
+      ;;
+  esac
 
 
   # First argument is the cpu name from the trip/quad
   case "$host_cpu" in
-    x86_64)
+    amd64|x86_64)
       VAR_CPU=x86_64
       VAR_CPU_ARCH=x86
       VAR_CPU_BITS=64
@@ -7054,6 +7095,7 @@
 
   # ... and setup our own variables. (Do this explicitely to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
+  OPENJDK_TARGET_OS_VENDOR="$VAR_OS_VENDOR"
   OPENJDK_TARGET_OS_API="$VAR_OS_API"
   OPENJDK_TARGET_OS_ENV="$VAR_OS_ENV"
   OPENJDK_TARGET_CPU="$VAR_CPU"
@@ -7067,6 +7109,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking openjdk-target os-cpu" >&5
 $as_echo_n "checking openjdk-target os-cpu... " >&6; }
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU" >&5
@@ -7195,8 +7238,8 @@
 
   # Setup OPENJDK_TARGET_CPU_OSARCH, which is used to set the os.arch Java system property
   OPENJDK_TARGET_CPU_OSARCH="$OPENJDK_TARGET_CPU"
-  if test "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
-    # On linux only, we replace x86 with i386.
+  if test "x$OPENJDK_TARGET_OS" = xbsd -o "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
+    # On Linux and BSD, we replace x86 with i386.
     OPENJDK_TARGET_CPU_OSARCH="i386"
   elif test "x$OPENJDK_TARGET_OS" != xmacosx && test "x$OPENJDK_TARGET_CPU" = xx86_64; then
     # On all platforms except macosx, we replace x86_64 with amd64.
@@ -8017,7 +8060,7 @@
     INCLUDE_SA=false
   fi
   if test "x$VAR_CPU" = xppc64 ; then
-    INCLUDE_SA=false
+    INCLUDE_SA=true
   fi
   if test "x$OPENJDK_TARGET_CPU" = xaarch64; then
     INCLUDE_SA=false
@@ -11206,6 +11249,24 @@
 
   ###############################################################################
   #
+  # Enable or disable static linking of libjli on bsd only
+  #
+  # Check whether --enable-static-libjli was given.
+if test "${enable_static_libjli+set}" = set; then :
+  enableval=$enable_static_libjli;
+else
+  enable_static_libjli=no
+fi
+
+  if test "x$OPENJDK_TARGET_OS" = "xbsd" && test "x$enable_static_libjli" = "xyes"; then
+    BSD_STATIC_LIBJLI=bsd
+  else
+    BSD_STATIC_LIBJLI=
+  fi
+
+
+  ###############################################################################
+  #
   # Enable or disable the elliptic curve crypto implementation
   #
 
@@ -19429,6 +19490,8 @@
   elif test "x$OPENJDK_TARGET_OS" = "xaix"; then
     # Do not probe for cc on AIX.
     COMPILER_CHECK_LIST="xlc_r"
+  elif test "`uname -s`" = "FreeBSD"; then
+    COMPILER_CHECK_LIST="cc gcc"
   else
     COMPILER_CHECK_LIST="gcc cc"
   fi
@@ -20389,7 +20452,7 @@
   else
     COMPILER_VERSION_TEST=`$COMPILER --version 2>&1 | $HEAD -n 1`
     # Check that this is likely to be GCC.
-    $COMPILER --version 2>&1 | $GREP "Free Software Foundation" > /dev/null
+    $COMPILER --version 2>&1 | $GREP -E "(Free Software Foundation|clang)" > /dev/null
     if test $? -ne 0; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&5
 $as_echo "$as_me: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&6;}
@@ -21991,7 +22054,7 @@
   else
     COMPILER_VERSION_TEST=`$COMPILER --version 2>&1 | $HEAD -n 1`
     # Check that this is likely to be GCC.
-    $COMPILER --version 2>&1 | $GREP "Free Software Foundation" > /dev/null
+    $COMPILER --version 2>&1 | $GREP -E "(Free Software Foundation|clang)" > /dev/null
     if test $? -ne 0; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&5
 $as_echo "$as_me: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler." >&6;}
@@ -28026,7 +28089,7 @@
 
   # objcopy is used for moving debug symbols to separate files when
   # full debug symbols are enabled.
-  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux; then
+  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux || test "x$OPENJDK_TARGET_OS" = xbsd ; then
     if test -n "$ac_tool_prefix"; then
   for ac_prog in gobjcopy objcopy
   do
@@ -29383,8 +29446,10 @@
       SET_SHARED_LIBRARY_NAME='-Xlinker -install_name -Xlinker @rpath/$1'
       SET_SHARED_LIBRARY_MAPFILE=''
       SET_SHARED_LIBRARY_ORIGIN='-Xlinker -rpath -Xlinker @loader_path/.'
+      POST_STRIP_CMD="$STRIP -S"
+    fi
+    if test "x$OPENJDK_TARGET_OS" = xbsd || test "x$OPENJDK_TARGET_OS" = xmacosx; then
       SET_EXECUTABLE_ORIGIN="$SET_SHARED_LIBRARY_ORIGIN"
-      POST_STRIP_CMD="$STRIP -S"
     fi
   else
     if test "x$OPENJDK_TARGET_OS" = xsolaris; then
@@ -29731,7 +29796,7 @@
   #
   case $COMPILER_NAME in
     gcc )
-      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS $COMMON_CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses \
+      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS $COMMON_CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses -Wno-sign-compare \
       -pipe \
       -D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE"
       CXXSTD_CXXFLAG="-std=gnu++98"
@@ -30073,22 +30138,36 @@
   COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK $ADD_LP64"
 
   # The package path is used only on macosx?
-  PACKAGE_PATH=/opt/local
+
+# Check whether --with-package-path was given.
+if test "${with_package_path+set}" = set; then :
+  withval=$with_package_path;
+fi
+
+  PACKAGE_PATH="$with_package_path"
+  if test "x$PACKAGE_PATH" = x; then
+    if test "`uname -s`" = "Darwin"; then
+      PACKAGE_PATH=/opt/local
+    fi
+
+    if test "`uname -s`" = "FreeBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+
+    if test "`uname -s`" = "NetBSD"; then
+      PACKAGE_PATH=/usr/pkg
+    fi
+
+    if test "`uname -s`" = "OpenBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+  fi
 
 
   if test "x$OPENJDK_TARGET_CPU_ENDIAN" = xlittle; then
-    # The macro _LITTLE_ENDIAN needs to be defined the same to avoid the
-    #   Sun C compiler warning message: warning: macro redefined: _LITTLE_ENDIAN
-    #   (The Solaris X86 system defines this in file /usr/include/sys/isa_defs.h).
-    #   Note: -Dmacro         is the same as    #define macro 1
-    #         -Dmacro=        is the same as    #define macro
-    if test "x$OPENJDK_TARGET_OS" = xsolaris; then
-      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -D_LITTLE_ENDIAN="
-    else
-      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -D_LITTLE_ENDIAN"
-    fi
-  else
-    COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -D_BIG_ENDIAN"
+    COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DVM_LITTLE_ENDIAN"
+  else
+    COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DVM_BIG_ENDIAN"
   fi
   if test "x$OPENJDK_TARGET_OS" = xlinux; then
     COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DLINUX"
@@ -30118,6 +30197,38 @@
   fi
   if test "x$OPENJDK_TARGET_OS" = xbsd; then
     COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DBSD -D_ALLBSD_SOURCE"
+    if test "`uname -s`" = "OpenBSD"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if ld requires -z wxneeded" >&5
+$as_echo_n "checking if ld requires -z wxneeded... " >&6; }
+        if test "$cross_compiling" = yes; then :
+
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/mman.h>
+int main() { return mmap(0, 4096, PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, -1, 0) != MAP_FAILED; }
+_ACEOF
+if ac_fn_cxx_try_run "$LINENO"; then :
+
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+              LDFLAGS_JDK="$LDFLAGS_JDK -Wl,-z,wxneeded"
+
+else
+
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    fi
   fi
   if test "x$DEBUG_LEVEL" = xrelease; then
     COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DNDEBUG"
@@ -30187,6 +30298,15 @@
           # Should this be supplied to the OSS linker as well?
           LDFLAGS_JDK="${LDFLAGS_JDK} -Xlinker -O1"
         fi
+      elif test "x$OPENJDK_TARGET_OS" = xbsd; then
+        # And since we now know that the linker is gnu, then add:
+        #   -z noexecstack, to mark stack regions as non-executable
+        LDFLAGS_JDK="${LDFLAGS_JDK} -Xlinker -z -Xlinker noexecstack"
+        if test "x$DEBUG_LEVEL" = "xrelease"; then
+          # When building release libraries, tell the linker optimize them.
+          # Should this be supplied to the OSS linker as well?
+          LDFLAGS_JDK="${LDFLAGS_JDK} -Xlinker -O1"
+        fi
       fi
     fi
     LDFLAGS_JDKLIB="${LDFLAGS_JDK} $SHARED_LIBRARY_FLAGS \
@@ -30641,11 +30761,18 @@
   fi
 
   if test "x$OPENJDK_TARGET_OS" = xbsd; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking what is not needed on bsd?" >&5
-$as_echo_n "checking what is not needed on bsd?... " >&6; }
-    ALSA_NOT_NEEDED=yes
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: alsa" >&5
-$as_echo "alsa" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking what is not needed on BSD?" >&5
+$as_echo_n "checking what is not needed on BSD?... " >&6; }
+    if test "x$OPENJDK_TARGET_OS_VENDOR" = xopenbsd; then
+      ALSA_NOT_NEEDED=yes
+      PULSE_NOT_NEEDED=yes
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: alsa pulse" >&5
+$as_echo "alsa pulse" >&6; }
+    else
+      PULSE_NOT_NEEDED=yes
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: pulse" >&5
+$as_echo "pulse" >&6; }
+    fi
   fi
 
   if test "x$OPENJDK" = "xfalse"; then
@@ -30681,14 +30808,18 @@
   # --x-libraries for the sysroot, if that seems to be correct.
   if test "x$SYS_ROOT" != "x/"; then
     if test "x$x_includes" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
+      if test -f "$SYS_ROOT/usr/X11R7/include/X11/Xlib.h"; then
+        x_includes="$SYS_ROOT/usr/X11R7/include"
+      elif test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/X11R6/include"
       elif test -f "$SYS_ROOT/usr/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/include"
       fi
     fi
     if test "x$x_libraries" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
+      if test -f "$SYS_ROOT/usr/X11R7/lib/libX11.so"; then
+        x_libraries="$SYS_ROOT/usr/X11R7/lib"
+      elif test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
         x_libraries="$SYS_ROOT/usr/X11R6/lib"
       elif test "$SYS_ROOT/usr/lib64/libX11.so" && test "x$OPENJDK_TARGET_CPU_BITS" = x64; then
         x_libraries="$SYS_ROOT/usr/lib64"
@@ -31735,6 +31866,10 @@
         # A CSW package seems to be installed!
         CUPS_FOUND=yes
         CUPS_CFLAGS="-I/opt/csw/include"
+      elif test -s ${PACKAGE_PATH}/include/cups/cups.h; then
+        # Standard package location for BSD
+        CUPS_FOUND=yes
+        CUPS_CFLAGS="-I${PACKAGE_PATH}/include"
       fi
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CUPS_FOUND" >&5
 $as_echo "$CUPS_FOUND" >&6; }
@@ -34900,7 +35035,7 @@
 
   ###############################################################################
   #
-  # Check for alsa headers and libraries. Used on Linux/GNU systems.
+  # Check for alsa headers and libraries. Used on Linux/GNU and BSD systems.
   #
 
 # Check whether --with-alsa was given.
@@ -35308,15 +35443,66 @@
 
   if test "x${with_giflib}" = "xbundled"; then
     USE_EXTERNAL_LIBGIF=false
+    GIFLIB_CFLAGS=
+    GIFLIB_LDFLAGS=
   elif test "x${with_giflib}" = "xsystem"; then
+    GIFLIB_H_FOUND=no
     ac_fn_cxx_check_header_mongrel "$LINENO" "gif_lib.h" "ac_cv_header_gif_lib_h" "$ac_includes_default"
 if test "x$ac_cv_header_gif_lib_h" = xyes; then :
 
-else
-   as_fn_error $? "--with-giflib=system specified, but gif_lib.h not found!" "$LINENO" 5
-fi
-
-
+           GIFLIB_H_FOUND=yes
+           GIFLIB_CFLAGS=
+
+
+fi
+
+
+    if test "x$GIFLIB_H_FOUND" = xno; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for giflib headers" >&5
+$as_echo_n "checking for giflib headers... " >&6; }
+      if test -s ${PACKAGE_PATH}/include/gif_lib.h; then
+        # Standard package location for BSD
+        GIFLIB_H_FOUND=yes
+        GIFLIB_CFLAGS="-I${PACKAGE_PATH}/include"
+      fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GIFLIB_H_FOUND" >&5
+$as_echo "$GIFLIB_H_FOUND" >&6; }
+    fi
+    if test "x$GIFLIB_H_FOUND" = xno; then
+
+  # Print a helpful message on how to acquire the necessary build dependency.
+  # giflib is the help tag: freetype, cups, pulse, alsa etc
+  MISSING_DEPENDENCY=giflib
+
+  if test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.cygwin"; then
+    cygwin_help $MISSING_DEPENDENCY
+  elif test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.msys"; then
+    msys_help $MISSING_DEPENDENCY
+  else
+    PKGHANDLER_COMMAND=
+
+    case $PKGHANDLER in
+      apt-get)
+        apt_help     $MISSING_DEPENDENCY ;;
+      yum)
+        yum_help     $MISSING_DEPENDENCY ;;
+      port)
+        port_help    $MISSING_DEPENDENCY ;;
+      pkgutil)
+        pkgutil_help $MISSING_DEPENDENCY ;;
+      pkgadd)
+        pkgadd_help  $MISSING_DEPENDENCY ;;
+    esac
+
+    if test "x$PKGHANDLER_COMMAND" != x; then
+      HELP_MSG="You might be able to fix this by running '$PKGHANDLER_COMMAND'."
+    fi
+  fi
+
+      as_fn_error $? "Could not find giflib headers! $HELP_MSG " "$LINENO" 5
+    fi
+
+    GIFLIB_LIB_FOUND=no
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for DGifGetCode in -lgif" >&5
 $as_echo_n "checking for DGifGetCode in -lgif... " >&6; }
 if ${ac_cv_lib_gif_DGifGetCode+:} false; then :
@@ -35354,16 +35540,96 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gif_DGifGetCode" >&5
 $as_echo "$ac_cv_lib_gif_DGifGetCode" >&6; }
 if test "x$ac_cv_lib_gif_DGifGetCode" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGIF 1
-_ACEOF
-
-  LIBS="-lgif $LIBS"
-
-else
-   as_fn_error $? "--with-giflib=system specified, but no giflib found!" "$LINENO" 5
-fi
-
+
+           GIFLIB_LIB_FOUND=yes
+           GIFLIB_LDFLAGS=
+
+
+fi
+
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+      save_LDFLAGS="$LDFLAGS"
+      LDFLAGS="$LDFLAGS -L${PACKAGE_PATH}/lib"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for DGifOpen in -lgif" >&5
+$as_echo_n "checking for DGifOpen in -lgif... " >&6; }
+if ${ac_cv_lib_gif_DGifOpen+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgif  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char DGifOpen ();
+int
+main ()
+{
+return DGifOpen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_gif_DGifOpen=yes
+else
+  ac_cv_lib_gif_DGifOpen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gif_DGifOpen" >&5
+$as_echo "$ac_cv_lib_gif_DGifOpen" >&6; }
+if test "x$ac_cv_lib_gif_DGifOpen" = xyes; then :
+
+             GIFLIB_LIB_FOUND=yes
+             GIFLIB_LDFLAGS="-L${PACKAGE_PATH}/lib"
+
+
+fi
+
+      LDFLAGS="$save_LDFLAGS"
+    fi
+
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+
+  # Print a helpful message on how to acquire the necessary build dependency.
+  # giflib is the help tag: freetype, cups, pulse, alsa etc
+  MISSING_DEPENDENCY=giflib
+
+  if test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.cygwin"; then
+    cygwin_help $MISSING_DEPENDENCY
+  elif test "x$OPENJDK_BUILD_OS_ENV" = "xwindows.msys"; then
+    msys_help $MISSING_DEPENDENCY
+  else
+    PKGHANDLER_COMMAND=
+
+    case $PKGHANDLER in
+      apt-get)
+        apt_help     $MISSING_DEPENDENCY ;;
+      yum)
+        yum_help     $MISSING_DEPENDENCY ;;
+      port)
+        port_help    $MISSING_DEPENDENCY ;;
+      pkgutil)
+        pkgutil_help $MISSING_DEPENDENCY ;;
+      pkgadd)
+        pkgadd_help  $MISSING_DEPENDENCY ;;
+    esac
+
+    if test "x$PKGHANDLER_COMMAND" != x; then
+      HELP_MSG="You might be able to fix this by running '$PKGHANDLER_COMMAND'."
+    fi
+  fi
+
+      as_fn_error $? "Could not find giflib library! $HELP_MSG " "$LINENO" 5
+    fi
 
     USE_EXTERNAL_LIBGIF=true
   else
@@ -35371,6 +35637,8 @@
   fi
 
 
+
+
   ###############################################################################
   #
   # Check for the zlib library
@@ -35938,6 +36206,11 @@
     LIBCXX="-lstdc++"
   fi
 
+  # TODO better (platform agnostic) test
+  if test "x$OPENJDK_TARGET_OS" = xbsd && test "x$LIBCXX" = x && test "x$GCC" = xyes; then
+    LIBCXX="-lstdc++"
+  fi
+
 
 
 
@@ -36011,6 +36284,10 @@
     # Looks like a MacOSX system
     NUM_CORES=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Cores' | awk  '{print $5}'`
     FOUND_CORES=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    NUM_CORES=`/sbin/sysctl -n hw.ncpu`
+    FOUND_CORES=yes
   elif test "x$OPENJDK_BUILD_OS" = xaix ; then
     NUM_CORES=`/usr/sbin/prtconf | grep "^Number Of Processors" | awk '{ print $4 }'`
     FOUND_CORES=yes
@@ -36066,6 +36343,15 @@
     MEMORY_SIZE=`/usr/sbin/system_profiler -detailLevel full SPHardwareDataType | grep 'Memory' | awk  '{print $2}'`
     MEMORY_SIZE=`expr $MEMORY_SIZE \* 1024`
     FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o OpenBSD)" = xOpenBSD; then
+    # Looks like an OpenBSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem | awk '{print int($NF / 1048576); }'`
+    FOUND_MEM=yes
+  elif test "x$OPENJDK_BUILD_OS" = xbsd && test "x$(uname -s | grep -o BSD)" = xBSD; then
+    # Looks like a BSD system
+    MEMORY_SIZE=`/sbin/sysctl -n hw.physmem`
+    MEMORY_SIZE=`expr $MEMORY_SIZE / 1024 / 1024`
+    FOUND_MEM=yes
   elif test "x$OPENJDK_BUILD_OS" = xwindows; then
     # Windows, but without cygwin
     MEMORY_SIZE=`wmic computersystem get totalphysicalmemory -value | grep = | cut -d "=" -f 2-`
@@ -36473,8 +36759,8 @@
     # precompiled headers.
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking if ccache supports precompiled headers" >&5
 $as_echo_n "checking if ccache supports precompiled headers... " >&6; }
-    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | grep -E 3.1.[456789]) 2> /dev/null`
-    if test "x$HAS_GOOD_CCACHE" = x; then
+    HAS_GOOD_CCACHE=`($CCACHE --version | head -n 1 | awk '{ split($3, a, "."); if (a[1] >= 3 && (a[2] > 1 || (a[2] == 1 && a[3] >= 4))) print "yes"; else print "no"; }') 2> /dev/null`
+    if test "x$HAS_GOOD_CCACHE" = xyes; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, disabling ccache" >&5
 $as_echo "no, disabling ccache" >&6; }
       CCACHE=
--- ./common/autoconf/jdk-options.m4	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/jdk-options.m4	Mon Sep 03 11:10:31 2018 -0700
@@ -159,7 +159,7 @@
     INCLUDE_SA=false
   fi
   if test "x$VAR_CPU" = xppc64 ; then
-    INCLUDE_SA=false
+    INCLUDE_SA=true
   fi
   if test "x$OPENJDK_TARGET_CPU" = xaarch64; then
     INCLUDE_SA=false
@@ -410,6 +410,20 @@
 
   ###############################################################################
   #
+  # Enable or disable static linking of libjli on bsd only
+  #
+  AC_ARG_ENABLE(static-libjli, [AS_HELP_STRING([--enable-static-libjli],
+      [Enable staticly linking libjli on bsd @<:@disabled@:>@])],,
+      [enable_static_libjli=no])
+  if test "x$OPENJDK_TARGET_OS" = "xbsd" && test "x$enable_static_libjli" = "xyes"; then
+    BSD_STATIC_LIBJLI=bsd
+  else
+    BSD_STATIC_LIBJLI=
+  fi
+  AC_SUBST(BSD_STATIC_LIBJLI)
+
+  ###############################################################################
+  #
   # Enable or disable the elliptic curve crypto implementation
   #
   AC_DEFUN_ONCE([JDKOPT_DETECT_INTREE_EC],
--- ./common/autoconf/libraries.m4	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/libraries.m4	Mon Sep 03 11:10:31 2018 -0700
@@ -69,9 +69,15 @@
   fi
 
   if test "x$OPENJDK_TARGET_OS" = xbsd; then
-    AC_MSG_CHECKING([what is not needed on bsd?])
-    ALSA_NOT_NEEDED=yes
-    AC_MSG_RESULT([alsa])
+    AC_MSG_CHECKING([what is not needed on BSD?])
+    if test "x$OPENJDK_TARGET_OS_VENDOR" = xopenbsd; then
+      ALSA_NOT_NEEDED=yes
+      PULSE_NOT_NEEDED=yes
+      AC_MSG_RESULT([alsa pulse])
+    else
+      PULSE_NOT_NEEDED=yes
+      AC_MSG_RESULT([pulse])
+    fi
   fi
 
   if test "x$OPENJDK" = "xfalse"; then
@@ -99,14 +105,18 @@
   # --x-libraries for the sysroot, if that seems to be correct.
   if test "x$SYS_ROOT" != "x/"; then
     if test "x$x_includes" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
+      if test -f "$SYS_ROOT/usr/X11R7/include/X11/Xlib.h"; then
+        x_includes="$SYS_ROOT/usr/X11R7/include"
+      elif test -f "$SYS_ROOT/usr/X11R6/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/X11R6/include"
       elif test -f "$SYS_ROOT/usr/include/X11/Xlib.h"; then
         x_includes="$SYS_ROOT/usr/include"
       fi
     fi
     if test "x$x_libraries" = xNONE; then
-      if test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
+      if test -f "$SYS_ROOT/usr/X11R7/lib/libX11.so"; then
+        x_libraries="$SYS_ROOT/usr/X11R7/lib"
+      elif test -f "$SYS_ROOT/usr/X11R6/lib/libX11.so"; then
         x_libraries="$SYS_ROOT/usr/X11R6/lib"
       elif test "$SYS_ROOT/usr/lib64/libX11.so" && test "x$OPENJDK_TARGET_CPU_BITS" = x64; then
         x_libraries="$SYS_ROOT/usr/lib64"
@@ -232,6 +242,10 @@
         # A CSW package seems to be installed!
         CUPS_FOUND=yes
         CUPS_CFLAGS="-I/opt/csw/include"
+      elif test -s ${PACKAGE_PATH}/include/cups/cups.h; then
+        # Standard package location for BSD
+        CUPS_FOUND=yes
+        CUPS_CFLAGS="-I${PACKAGE_PATH}/include"
       fi
       AC_MSG_RESULT([$CUPS_FOUND])
     fi
@@ -525,7 +539,7 @@
 
   ###############################################################################
   #
-  # Check for alsa headers and libraries. Used on Linux/GNU systems.
+  # Check for alsa headers and libraries. Used on Linux/GNU and BSD systems.
   #
   AC_ARG_WITH(alsa, [AS_HELP_STRING([--with-alsa],
       [specify prefix directory for the alsa package
@@ -627,17 +641,61 @@
 
   if test "x${with_giflib}" = "xbundled"; then
     USE_EXTERNAL_LIBGIF=false
+    GIFLIB_CFLAGS=
+    GIFLIB_LDFLAGS=
   elif test "x${with_giflib}" = "xsystem"; then
-    AC_CHECK_HEADER(gif_lib.h, [],
-        [ AC_MSG_ERROR([--with-giflib=system specified, but gif_lib.h not found!])])
-    AC_CHECK_LIB(gif, DGifGetCode, [],
-        [ AC_MSG_ERROR([--with-giflib=system specified, but no giflib found!])])
+    GIFLIB_H_FOUND=no
+    AC_CHECK_HEADER(gif_lib.h,
+        [
+           GIFLIB_H_FOUND=yes
+           GIFLIB_CFLAGS=
+        ]
+    )
+    if test "x$GIFLIB_H_FOUND" = xno; then
+      AC_MSG_CHECKING([for giflib headers])
+      if test -s ${PACKAGE_PATH}/include/gif_lib.h; then
+        # Standard package location for BSD
+        GIFLIB_H_FOUND=yes
+        GIFLIB_CFLAGS="-I${PACKAGE_PATH}/include"
+      fi
+      AC_MSG_RESULT([$GIFLIB_H_FOUND])
+    fi
+    if test "x$GIFLIB_H_FOUND" = xno; then
+      HELP_MSG_MISSING_DEPENDENCY([giflib])
+      AC_MSG_ERROR([Could not find giflib headers! $HELP_MSG ])
+    fi
+
+    GIFLIB_LIB_FOUND=no
+    AC_CHECK_LIB(gif, DGifGetCode,
+        [
+           GIFLIB_LIB_FOUND=yes
+           GIFLIB_LDFLAGS=
+        ]
+    )
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+      save_LDFLAGS="$LDFLAGS"
+      LDFLAGS="$LDFLAGS -L${PACKAGE_PATH}/lib"
+      AC_CHECK_LIB(gif, DGifOpen,
+          [
+             GIFLIB_LIB_FOUND=yes
+             GIFLIB_LDFLAGS="-L${PACKAGE_PATH}/lib"
+          ]
+      )
+      LDFLAGS="$save_LDFLAGS"
+    fi
+
+    if test "x$GIFLIB_LIB_FOUND" = xno; then
+      HELP_MSG_MISSING_DEPENDENCY([giflib])
+      AC_MSG_ERROR([Could not find giflib library! $HELP_MSG ])
+    fi
 
     USE_EXTERNAL_LIBGIF=true
   else
     AC_MSG_ERROR([Invalid value of --with-giflib: ${with_giflib}, use 'system' or 'bundled'])
   fi
   AC_SUBST(USE_EXTERNAL_LIBGIF)
+  AC_SUBST(GIFLIB_CFLAGS)
+  AC_SUBST(GIFLIB_LDFLAGS)
 
   ###############################################################################
   #
@@ -872,5 +930,10 @@
     LIBCXX="-lstdc++"
   fi
 
+  # TODO better (platform agnostic) test
+  if test "x$OPENJDK_TARGET_OS" = xbsd && test "x$LIBCXX" = x && test "x$GCC" = xyes; then
+    LIBCXX="-lstdc++"
+  fi
+
   AC_SUBST(LIBCXX)
 ])
--- ./common/autoconf/platform.m4	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/platform.m4	Mon Sep 03 11:10:31 2018 -0700
@@ -30,7 +30,7 @@
 [
   # First argument is the cpu name from the trip/quad
   case "$1" in
-    x86_64)
+    amd64|x86_64)
       VAR_CPU=x86_64
       VAR_CPU_ARCH=x86
       VAR_CPU_BITS=64
@@ -147,6 +147,22 @@
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+  # The BSD's have slight differences so determine which one we are building on.
+  # For the rest set VAR_OS_VENDOR to VAR_OS
+  case "$1" in
+    *openbsd*)
+      VAR_OS_VENDOR=openbsd
+      ;;
+    *netbsd*)
+      VAR_OS_VENDOR=netbsd
+      ;;
+    *freebsd*)
+      VAR_OS_VENDOR=freebsd
+      ;;
+    *)
+      VAR_OS_VENDOR="$VAR_OS"
+      ;;
+  esac
 ])
 
 # Expects $host_os $host_cpu $build_os and $build_cpu
@@ -192,6 +208,7 @@
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
   # ... and setup our own variables. (Do this explicitely to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
+  OPENJDK_TARGET_OS_VENDOR="$VAR_OS_VENDOR"
   OPENJDK_TARGET_OS_API="$VAR_OS_API"
   OPENJDK_TARGET_OS_ENV="$VAR_OS_ENV"
   OPENJDK_TARGET_CPU="$VAR_CPU"
@@ -199,6 +216,7 @@
   OPENJDK_TARGET_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_TARGET_CPU_ENDIAN="$VAR_CPU_ENDIAN"
   AC_SUBST(OPENJDK_TARGET_OS)
+  AC_SUBST(OPENJDK_TARGET_OS_VENDOR)
   AC_SUBST(OPENJDK_TARGET_OS_API)
   AC_SUBST(OPENJDK_TARGET_CPU)
   AC_SUBST(OPENJDK_TARGET_CPU_ARCH)
@@ -308,8 +326,8 @@
 
   # Setup OPENJDK_TARGET_CPU_OSARCH, which is used to set the os.arch Java system property
   OPENJDK_TARGET_CPU_OSARCH="$OPENJDK_TARGET_CPU"
-  if test "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
-    # On linux only, we replace x86 with i386.
+  if test "x$OPENJDK_TARGET_OS" = xbsd -o "x$OPENJDK_TARGET_OS" = xlinux && test "x$OPENJDK_TARGET_CPU" = xx86; then
+    # On Linux and BSD, we replace x86 with i386.
     OPENJDK_TARGET_CPU_OSARCH="i386"
   elif test "x$OPENJDK_TARGET_OS" != xmacosx && test "x$OPENJDK_TARGET_CPU" = xx86_64; then
     # On all platforms except macosx, we replace x86_64 with amd64.
--- ./common/autoconf/spec.gmk.in	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/spec.gmk.in	Mon Sep 03 11:10:31 2018 -0700
@@ -76,6 +76,7 @@
 OPENJDK_TARGET_OS:=@OPENJDK_TARGET_OS@
 OPENJDK_TARGET_OS_API:=@OPENJDK_TARGET_OS_API@
 OPENJDK_TARGET_OS_ENV:=@OPENJDK_TARGET_OS_ENV@
+OPENJDK_TARGET_OS_VENDOR:=@OPENJDK_TARGET_OS_VENDOR@
 
 OPENJDK_TARGET_CPU:=@OPENJDK_TARGET_CPU@
 OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET_CPU_ARCH@
@@ -276,7 +277,7 @@
 ALSA_LIBS:=@ALSA_LIBS@
 ALSA_CFLAGS:=@ALSA_CFLAGS@
 
-PACKAGE_PATH=@PACKAGE_PATH@
+PACKAGE_PATH:=@PACKAGE_PATH@
 
 # Source file for cacerts
 CACERTS_FILE=@CACERTS_FILE@
@@ -284,6 +285,9 @@
 # Enable unlimited crypto policy
 UNLIMITED_CRYPTO=@UNLIMITED_CRYPTO@
 
+# Build static libjli on bsd
+BSD_STATIC_LIBJLI=@BSD_STATIC_LIBJLI@
+
 # Necessary additional compiler flags to compile X11
 X_CFLAGS:=@X_CFLAGS@
 X_LIBS:=@X_LIBS@
@@ -568,6 +572,8 @@
 ENABLE_INTREE_EC=@ENABLE_INTREE_EC@
 USE_EXTERNAL_LIBJPEG:=@USE_EXTERNAL_LIBJPEG@
 USE_EXTERNAL_LIBGIF:=@USE_EXTERNAL_LIBGIF@
+GIFLIB_CFLAGS:=@GIFLIB_CFLAGS@
+GIFLIB_LDFLAGS:=@GIFLIB_LDFLAGS@
 USE_EXTERNAL_LIBZ:=@USE_EXTERNAL_LIBZ@
 LIBZIP_CAN_USE_MMAP:=@LIBZIP_CAN_USE_MMAP@
 MSVCR_DLL:=@MSVCR_DLL@
--- ./common/autoconf/toolchain.m4	Sat Jun 23 21:01:22 2018 -0700
+++ ./common/autoconf/toolchain.m4	Mon Sep 03 11:10:31 2018 -0700
@@ -122,7 +122,7 @@
   else
     COMPILER_VERSION_TEST=`$COMPILER --version 2>&1 | $HEAD -n 1`
     # Check that this is likely to be GCC.
-    $COMPILER --version 2>&1 | $GREP "Free Software Foundation" > /dev/null
+    $COMPILER --version 2>&1 | $GREP -E "(Free Software Foundation|clang)" > /dev/null
     if test $? -ne 0; then
       AC_MSG_NOTICE([The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required GCC compiler.])
       AC_MSG_NOTICE([The result from running with --version was: "$COMPILER_VERSION_TEST"])
@@ -401,6 +401,8 @@
   elif test "x$OPENJDK_TARGET_OS" = "xaix"; then
     # Do not probe for cc on AIX.
     COMPILER_CHECK_LIST="xlc_r"
+  elif test "`uname -s`" = "FreeBSD"; then
+    COMPILER_CHECK_LIST="cc gcc"
   else
     COMPILER_CHECK_LIST="gcc cc"
   fi
@@ -629,7 +631,7 @@
 
   # objcopy is used for moving debug symbols to separate files when
   # full debug symbols are enabled.
-  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux; then
+  if test "x$OPENJDK_TARGET_OS" = xsolaris || test "x$OPENJDK_TARGET_OS" = xlinux || test "x$OPENJDK_TARGET_OS" = xbsd ; then
     AC_CHECK_TOOLS(OBJCOPY, [gobjcopy objcopy])
     # Only call fixup if objcopy was found.
     if test -n "$OBJCOPY"; then
@@ -692,8 +694,10 @@
       SET_SHARED_LIBRARY_NAME='-Xlinker -install_name -Xlinker @rpath/[$]1'
       SET_SHARED_LIBRARY_MAPFILE=''
       SET_SHARED_LIBRARY_ORIGIN='-Xlinker -rpath -Xlinker @loader_path/.'
+      POST_STRIP_CMD="$STRIP -S"
+    fi
+    if test "x$OPENJDK_TARGET_OS" = xbsd || test "x$OPENJDK_TARGET_OS" = xmacosx; then
       SET_EXECUTABLE_ORIGIN="$SET_SHARED_LIBRARY_ORIGIN"
-      POST_STRIP_CMD="$STRIP -S"
     fi
   else
     if test "x$OPENJDK_TARGET_OS" = xsolaris; then
@@ -1018,7 +1022,7 @@
   #
   case $COMPILER_NAME in
     gcc )
-      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS $COMMON_CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses \
+      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS $COMMON_CCXXFLAGS_JDK -W -Wall -Wno-unused -Wno-parentheses -Wno-sign-compare \
       -pipe \
       -D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE"
       CXXSTD_CXXFLAG="-std=gnu++98"
@@ -1106,22 +1110,33 @@
   COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK $ADD_LP64"
 
   # The package path is used only on macosx?
-  PACKAGE_PATH=/opt/local
+  AC_ARG_WITH(package-path, [AS_HELP_STRING([--with-package-path],
+      [package path to be used for location of third party packages])])
+  PACKAGE_PATH="$with_package_path"
+  if test "x$PACKAGE_PATH" = x; then
+    if test "`uname -s`" = "Darwin"; then
+      PACKAGE_PATH=/opt/local
+    fi
+
+    if test "`uname -s`" = "FreeBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+
+    if test "`uname -s`" = "NetBSD"; then
+      PACKAGE_PATH=/usr/pkg
+    fi
+
+    if test "`uname -s`" = "OpenBSD"; then
+      PACKAGE_PATH=/usr/local
+    fi
+  fi
+
   AC_SUBST(PACKAGE_PATH)
 
   if test "x$OPENJDK_TARGET_CPU_ENDIAN" = xlittle; then
-    # The macro _LITTLE_ENDIAN needs to be defined the same to avoid the
-    #   Sun C compiler warning message: warning: macro redefined: _LITTLE_ENDIAN
-    #   (The Solaris X86 system defines this in file /usr/include/sys/isa_defs.h).
-    #   Note: -Dmacro         is the same as    #define macro 1
-    #         -Dmacro=        is the same as    #define macro
-    if test "x$OPENJDK_TARGET_OS" = xsolaris; then
-      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -D_LITTLE_ENDIAN="
-    else
-      COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -D_LITTLE_ENDIAN"
-    fi
+    COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DVM_LITTLE_ENDIAN"
   else
-    COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -D_BIG_ENDIAN"
+    COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DVM_BIG_ENDIAN"
   fi
   if test "x$OPENJDK_TARGET_OS" = xlinux; then
     COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DLINUX"
@@ -1151,6 +1166,22 @@
   fi
   if test "x$OPENJDK_TARGET_OS" = xbsd; then
     COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DBSD -D_ALLBSD_SOURCE"
+    if test "`uname -s`" = "OpenBSD"; then
+        AC_MSG_CHECKING([if ld requires -z wxneeded])
+        AC_RUN_IFELSE([AC_LANG_SOURCE([[#include <sys/mman.h>
+int main() { return mmap(0, 4096, PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, -1, 0) != MAP_FAILED; }]])],
+            [
+              AC_MSG_RESULT([yes])
+              LDFLAGS_JDK="$LDFLAGS_JDK -Wl,-z,wxneeded"
+            ],
+            [
+              AC_MSG_RESULT([no])
+            ],
+            [
+              AC_MSG_RESULT([no])
+            ]
+        )
+    fi
   fi
   if test "x$DEBUG_LEVEL" = xrelease; then
     COMMON_CCXXFLAGS_JDK="$COMMON_CCXXFLAGS_JDK -DNDEBUG"
@@ -1220,6 +1251,15 @@
           # Should this be supplied to the OSS linker as well?
           LDFLAGS_JDK="${LDFLAGS_JDK} -Xlinker -O1"
         fi
+      elif test "x$OPENJDK_TARGET_OS" = xbsd; then
+        # And since we now know that the linker is gnu, then add:
+        #   -z noexecstack, to mark stack regions as non-executable
+        LDFLAGS_JDK="${LDFLAGS_JDK} -Xlinker -z -Xlinker noexecstack"
+        if test "x$DEBUG_LEVEL" = "xrelease"; then
+          # When building release libraries, tell the linker optimize them.
+          # Should this be supplied to the OSS linker as well?
+          LDFLAGS_JDK="${LDFLAGS_JDK} -Xlinker -O1"
+        fi
       fi
     fi
     LDFLAGS_JDKLIB="${LDFLAGS_JDK} $SHARED_LIBRARY_FLAGS \
--- ./configure	Sat Jun 23 21:01:22 2018 -0700
+++ ./configure	Mon Sep 03 11:10:31 2018 -0700
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 #
 # Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
--- ./make/Javadoc.gmk	Sat Jun 23 21:01:22 2018 -0700
+++ ./make/Javadoc.gmk	Mon Sep 03 11:10:31 2018 -0700
@@ -46,8 +46,18 @@
 
 BUILD_NUMBER=$(JDK_BUILD_NUMBER)
 
+ifeq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+  ifeq ($(OPENJDK_TARGET_CPU_BITS), 32)
+    JAVADOC_CMD_MEM = "-Xmx768m"
+  else
+    JAVADOC_CMD_MEM = "-Xmx1024m"
+  endif
+else
+  JAVADOC_CMD_MEM = "-Xmx1024m"
+endif
+
 JAVADOC_CMD = $(JAVA) \
-    -Xmx1024m \
+    $(JAVADOC_CMD_MEM) \
     -Djava.awt.headless=true \
     $(NEW_JAVADOC) \
     -bootclasspath $(JDK_OUTPUTDIR)/classes
--- ./make/Main.gmk	Sat Jun 23 21:01:22 2018 -0700
+++ ./make/Main.gmk	Mon Sep 03 11:10:31 2018 -0700
@@ -58,7 +58,11 @@
 
 # Setup number of jobs to use. -jN is unfortunately not available for us to parse from the command line,
 # hence this workaround.
+ifdef JOBS
+ifneq ($(JOBS),0)
 MAKE_ARGS:=$(MAKE_ARGS) -j$(JOBS)
+endif
+endif
 
 ### Main targets
 
--- ./make/common/MakeBase.gmk	Sat Jun 23 21:01:22 2018 -0700
+++ ./make/common/MakeBase.gmk	Mon Sep 03 11:10:31 2018 -0700
@@ -338,7 +338,7 @@
     # (and causing a crash on Cygwin).
     # Default shell seems to always be /bin/sh. Must override with bash to get this to work on Solaris.
     # Only use time if it's GNU time which supports format and output file.
-    WRAPPER_SHELL:=/bin/bash $$(SRC_ROOT)/common/bin/shell-tracer.sh $$(if $$(findstring yes,$$(IS_GNU_TIME)),$$(TIME),-) $$(OUTPUT_ROOT)/build-trace-time.log /bin/bash
+    WRAPPER_SHELL:=bash $$(SRC_ROOT)/common/bin/shell-tracer.sh $$(if $$(findstring yes,$$(IS_GNU_TIME)),$$(TIME),-) $$(OUTPUT_ROOT)/build-trace-time.log bash
     SHELL=$$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$<, (from $$<))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(WRAPPER_SHELL)
   endif
   # Never remove warning messages; this is just for completeness
@@ -365,8 +365,8 @@
 
 # This is to be called by all SetupFoo macros
 define LogSetupMacroEntry
-  $(if $(27),$(error Internal makefile error: Too many arguments to LogSetupMacroEntry, please update MakeBase.gmk))
-  $(if $(findstring $(LOG_LEVEL),debug trace), $(info $1 $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26,$(if $($i),$(NEWLINE) $(strip [$i] $($i))))))
+  $(if $(30),$(error Internal makefile error: Too many arguments to LogSetupMacroEntry, please update MakeBase.gmk))
+  $(if $(findstring $(LOG_LEVEL),debug trace), $(info $1 $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29,$(if $($i),$(NEWLINE) $(strip [$i] $($i))))))
 endef
 
 # Make directory without forking mkdir if not needed
--- ./make/common/NativeCompilation.gmk	Sat Jun 23 21:01:22 2018 -0700
+++ ./make/common/NativeCompilation.gmk	Mon Sep 03 11:10:31 2018 -0700
@@ -151,9 +151,9 @@
   #   CC the compiler to use, default is $(CC)
   #   LDEXE the linker to use for linking executables, default is $(LDEXE)
   #   OPTIMIZATION sets optimization level to NONE, LOW, HIGH, HIGHEST
-  $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26, $(if $($i),$1_$(strip $($i)))$(NEWLINE))
-  $(call LogSetupMacroEntry,SetupNativeCompilation($1),$2,$3,$4,$5,$6,$7,$8,$9,$(10),$(11),$(12),$(13),$(14),$(15),$(16),$(17),$(18),$(19),$(20),$(21),$(22),$(23),$(24),$(25),$(26))
-  $(if $(27),$(error Internal makefile error: Too many arguments to SetupNativeCompilation, please update NativeCompilation.gmk))
+  $(foreach i,2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29, $(if $($i),$1_$(strip $($i)))$(NEWLINE))
+  $(call LogSetupMacroEntry,SetupNativeCompilation($1),$2,$3,$4,$5,$6,$7,$8,$9,$(10),$(11),$(12),$(13),$(14),$(15),$(16),$(17),$(18),$(19),$(20),$(21),$(22),$(23),$(24),$(25),$(26),$(27),$(28),$(29))
+  $(if $(30),$(error Internal makefile error: Too many arguments to SetupNativeCompilation, please update NativeCompilation.gmk))
 
   ifneq (,$$($1_BIN))
     $$(error BIN has been replaced with OBJECT_DIR)
--- ./hotspot/agent/make/Makefile	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/make/Makefile	Mon Sep 03 11:13:04 2018 -0700
@@ -50,6 +50,7 @@
 sun.jvm.hotspot.debugger.amd64 \
 sun.jvm.hotspot.debugger.bsd \
 sun.jvm.hotspot.debugger.bsd.amd64 \
+sun.jvm.hotspot.debugger.bsd.ppc64 \
 sun.jvm.hotspot.debugger.bsd.x86 \
 sun.jvm.hotspot.debugger.cdbg \
 sun.jvm.hotspot.debugger.cdbg.basic \
@@ -61,12 +62,15 @@
 sun.jvm.hotspot.debugger.linux.x86 \
 sun.jvm.hotspot.debugger.posix \
 sun.jvm.hotspot.debugger.posix.elf \
+sun.jvm.hotspot.debugger.ppc64 \
 sun.jvm.hotspot.debugger.proc \
 sun.jvm.hotspot.debugger.proc.amd64 \
+sun.jvm.hotspot.debugger.proc.ppc64 \
 sun.jvm.hotspot.debugger.proc.sparc \
 sun.jvm.hotspot.debugger.proc.x86 \
 sun.jvm.hotspot.debugger.remote \
 sun.jvm.hotspot.debugger.remote.amd64 \
+sun.jvm.hotspot.debugger.remote.ppc64 \
 sun.jvm.hotspot.debugger.remote.sparc \
 sun.jvm.hotspot.debugger.remote.x86 \
 sun.jvm.hotspot.debugger.sparc \
@@ -90,12 +94,14 @@
 sun.jvm.hotspot.runtime.amd64 \
 sun.jvm.hotspot.runtime.bsd \
 sun.jvm.hotspot.runtime.bsd_amd64 \
+sun.jvm.hotspot.runtime.bsd_ppc64 \
 sun.jvm.hotspot.runtime.bsd_x86 \
 sun.jvm.hotspot.runtime.linux \
 sun.jvm.hotspot.runtime.linux_amd64 \
 sun.jvm.hotspot.runtime.linux_sparc \
 sun.jvm.hotspot.runtime.linux_x86 \
 sun.jvm.hotspot.runtime.posix \
+sun.jvm.hotspot.runtime.ppc64 \
 sun.jvm.hotspot.runtime.solaris_amd64 \
 sun.jvm.hotspot.runtime.solaris_sparc \
 sun.jvm.hotspot.runtime.solaris_x86 \
@@ -135,6 +141,7 @@
 sun/jvm/hotspot/debugger/amd64/*.java \
 sun/jvm/hotspot/debugger/bsd/*.java \
 sun/jvm/hotspot/debugger/bsd/amd64/*.java \
+sun/jvm/hotspot/debugger/bsd/ppc64/*.java \
 sun/jvm/hotspot/debugger/bsd/x86/*.java \
 sun/jvm/hotspot/debugger/cdbg/*.java \
 sun/jvm/hotspot/debugger/cdbg/basic/*.java \
@@ -145,12 +152,15 @@
 sun/jvm/hotspot/debugger/linux/x86/*.java \
 sun/jvm/hotspot/debugger/posix/*.java \
 sun/jvm/hotspot/debugger/posix/elf/*.java \
+sun/jvm/hotspot/debugger/ppc64/*.java \
 sun/jvm/hotspot/debugger/proc/*.java \
 sun/jvm/hotspot/debugger/proc/amd64/*.java \
+sun/jvm/hotspot/debugger/proc/ppc64/*.java \
 sun/jvm/hotspot/debugger/proc/sparc/*.java \
 sun/jvm/hotspot/debugger/proc/x86/*.java \
 sun/jvm/hotspot/debugger/remote/*.java \
 sun/jvm/hotspot/debugger/remote/amd64/*.java \
+sun/jvm/hotspot/debugger/remote/ppc64/*.java \
 sun/jvm/hotspot/debugger/remote/sparc/*.java \
 sun/jvm/hotspot/debugger/remote/x86/*.java \
 sun/jvm/hotspot/debugger/sparc/*.java \
@@ -171,12 +181,14 @@
 sun/jvm/hotspot/runtime/amd64/*.java \
 sun/jvm/hotspot/runtime/bsd/*.java \
 sun/jvm/hotspot/runtime/bsd_amd64/*.java \
+sun/jvm/hotspot/runtime/bsd_ppc64/*.java \
 sun/jvm/hotspot/runtime/bsd_x86/*.java \
 sun/jvm/hotspot/runtime/linux/*.java \
 sun/jvm/hotspot/runtime/linux_amd64/*.java \
 sun/jvm/hotspot/runtime/linux_sparc/*.java \
 sun/jvm/hotspot/runtime/linux_x86/*.java \
 sun/jvm/hotspot/runtime/posix/*.java \
+sun/jvm/hotspot/runtime/ppc64/*.java \
 sun/jvm/hotspot/runtime/solaris_amd64/*.java \
 sun/jvm/hotspot/runtime/solaris_sparc/*.java \
 sun/jvm/hotspot/runtime/solaris_x86/*.java \
--- ./hotspot/agent/src/os/bsd/BsdDebuggerLocal.c	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/os/bsd/BsdDebuggerLocal.c	Mon Sep 03 11:13:04 2018 -0700
@@ -42,6 +42,10 @@
 #include "sun_jvm_hotspot_debugger_sparc_SPARCThreadContext.h"
 #endif
 
+#ifdef ppc64
+#include "sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext.h"
+#endif
+
 static jfieldID p_ps_prochandle_ID = 0;
 static jfieldID threadList_ID = 0;
 static jfieldID loadObjectList_ID = 0;
@@ -307,6 +311,9 @@
 #if defined(sparc) || defined(sparcv9)
 #define NPRGREG sun_jvm_hotspot_debugger_sparc_SPARCThreadContext_NPRGREG
 #endif
+#ifdef ppc64
+#define NPRGREG sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext_NPRGREG
+#endif
 
   array = (*env)->NewLongArray(env, NPRGREG);
   CHECK_EXCEPTION_(0);
@@ -407,6 +414,46 @@
   regs[REG_INDEX(R_O7)]  = gregs.u_regs[14];
 #endif /* sparc */
 
+#if defined(ppc64) || defined(ppc64le)
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext_##reg
+
+  regs[REG_INDEX(LR)] = gregs.lr;
+  regs[REG_INDEX(PC)] = gregs.pc;
+  regs[REG_INDEX(R0)]  = gregs.fixreg[0];
+  regs[REG_INDEX(R1)]  = gregs.fixreg[1];
+  regs[REG_INDEX(R2)]  = gregs.fixreg[2];
+  regs[REG_INDEX(R3)]  = gregs.fixreg[3];
+  regs[REG_INDEX(R4)]  = gregs.fixreg[4];
+  regs[REG_INDEX(R5)]  = gregs.fixreg[5];
+  regs[REG_INDEX(R6)]  = gregs.fixreg[6];
+  regs[REG_INDEX(R7)]  = gregs.fixreg[7];
+  regs[REG_INDEX(R8)]  = gregs.fixreg[8];
+  regs[REG_INDEX(R9)]  = gregs.fixreg[9];
+  regs[REG_INDEX(R10)] = gregs.fixreg[10];
+  regs[REG_INDEX(R11)] = gregs.fixreg[11];
+  regs[REG_INDEX(R12)] = gregs.fixreg[12];
+  regs[REG_INDEX(R13)] = gregs.fixreg[13];
+  regs[REG_INDEX(R14)] = gregs.fixreg[14];
+  regs[REG_INDEX(R15)] = gregs.fixreg[15];
+  regs[REG_INDEX(R16)] = gregs.fixreg[16];
+  regs[REG_INDEX(R17)] = gregs.fixreg[17];
+  regs[REG_INDEX(R18)] = gregs.fixreg[18];
+  regs[REG_INDEX(R19)] = gregs.fixreg[19];
+  regs[REG_INDEX(R20)] = gregs.fixreg[20];
+  regs[REG_INDEX(R21)] = gregs.fixreg[21];
+  regs[REG_INDEX(R22)] = gregs.fixreg[22];
+  regs[REG_INDEX(R23)] = gregs.fixreg[23];
+  regs[REG_INDEX(R24)] = gregs.fixreg[24];
+  regs[REG_INDEX(R25)] = gregs.fixreg[25];
+  regs[REG_INDEX(R26)] = gregs.fixreg[26];
+  regs[REG_INDEX(R27)] = gregs.fixreg[27];
+  regs[REG_INDEX(R28)] = gregs.fixreg[28];
+  regs[REG_INDEX(R29)] = gregs.fixreg[29];
+  regs[REG_INDEX(R30)] = gregs.fixreg[30];
+  regs[REG_INDEX(R31)] = gregs.fixreg[31];
+
+#endif
+ 
 
   (*env)->ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);
   return array;
--- ./hotspot/agent/src/os/bsd/Makefile	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/os/bsd/Makefile	Mon Sep 03 11:13:04 2018 -0700
@@ -85,6 +85,9 @@
   LFLAGS_LIBSA = -Xlinker --version-script=mapfile
 endif
 
+LDFLAGS_NO_EXEC_STACK="-Wl,-z,noexecstack"
+LFLAGS_LIBSA += $(LDFLAGS_NO_EXEC_STACK)
+
 $(LIBSA): $(OBJSPLUS) mapfile 
 	if [ ! -d $(ARCH) ] ; then mkdir $(ARCH) ; fi
 	$(GCC) -shared $(LFLAGS_LIBSA) -o $(LIBSA) $(FOUNDATIONFLAGS) $(OBJSPLUS) $(LIBS) $(SALIBS)
--- ./hotspot/agent/src/os/bsd/elfmacros.h	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/os/bsd/elfmacros.h	Mon Sep 03 11:13:04 2018 -0700
@@ -34,6 +34,7 @@
 #define ELF_SYM         Elf64_Sym
 #define ELF_DYN         Elf64_Dyn
 #define ELF_ADDR        Elf64_Addr
+#define ELF_AUXV        Elf64_Auxinfo
 
 #ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE     ELF64_ST_TYPE
@@ -47,6 +48,7 @@
 #define ELF_SYM         Elf32_Sym
 #define ELF_DYN         Elf32_Dyn
 #define ELF_ADDR        Elf32_Addr
+#define ELF_AUXV        Elf32_Auxinfo
 
 #ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE     ELF32_ST_TYPE
--- ./hotspot/agent/src/os/bsd/ps_core.c	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/os/bsd/ps_core.c	Mon Sep 03 11:13:04 2018 -0700
@@ -1091,6 +1091,18 @@
         if (core_handle_prstatus(ph, descdata, notep->n_descsz) != true) {
           return false;
         }
+      } else if (notep->n_type == NT_PROCSTAT_AUXV) {
+        // Get first segment from entry point
+        ELF_AUXV *auxv = (ELF_AUXV *)descdata;
+        while (auxv->a_type != AT_NULL) {
+          if (auxv->a_type == AT_ENTRY) {
+            // Set entry point address to address of dynamic section.
+            // We will adjust it in read_exec_segments().
+            ph->core->dynamic_addr = auxv->a_un.a_val;
+            break;
+          }
+          auxv++;
+        }
       }
       p = descdata + ROUNDUP(notep->n_descsz, 4);
    }
@@ -1272,7 +1284,13 @@
 
          // from PT_DYNAMIC we want to read address of first link_map addr
          case PT_DYNAMIC: {
-            ph->core->dynamic_addr = exec_php->p_vaddr;
+            if (exec_ehdr->e_type == ET_EXEC) {
+                ph->core->dynamic_addr = exec_php->p_vaddr;
+            } else { // ET_DYN
+                // dynamic_addr has entry point of executable.
+                // Thus we should substract it.
+                ph->core->dynamic_addr += exec_php->p_vaddr - exec_ehdr->e_entry;
+            }
             print_debug("address of _DYNAMIC is 0x%lx\n", ph->core->dynamic_addr);
             break;
          }
@@ -1472,8 +1490,9 @@
     goto err;
   }
 
-  if (read_elf_header(ph->core->exec_fd, &exec_ehdr) != true || exec_ehdr.e_type != ET_EXEC) {
-    print_debug("executable file is not a valid ELF ET_EXEC file\n");
+  if (read_elf_header(ph->core->exec_fd, &exec_ehdr) != true ||
+      ((exec_ehdr.e_type != ET_EXEC) && (exec_ehdr.e_type != ET_DYN))) {
+    print_debug("executable file is not a valid ELF file\n");
     goto err;
   }
 
--- ./hotspot/agent/src/os/bsd/symtab.c	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/os/bsd/symtab.c	Mon Sep 03 11:13:04 2018 -0700
@@ -211,6 +211,10 @@
 
   // Reading of elf header
   struct elf_section *scn_cache = NULL;
+#if defined(ppc64)
+  struct elf_section *opd_sect = NULL;
+  ELF_SHDR *opd = NULL;
+#endif
   int cnt = 0;
   ELF_SHDR* shbuf = NULL;
   ELF_SHDR* cursct = NULL;
@@ -258,6 +262,14 @@
     cursct++;
   }
 
+#if defined(ppc64)
+  opd_sect = find_section_by_name(".opd", fd, &ehdr, scn_cache);
+  if (opd_sect != NULL && opd_sect->c_data != NULL && opd_sect->c_shdr != NULL) {
+    // plausibility check
+    opd = opd_sect->c_shdr;
+  }
+#endif
+
   if (!symtab_found && dynsym_found)
      symsection = SHT_DYNSYM;
 
@@ -322,6 +334,13 @@
         symtab->symbols[j].name   = sym_name;
         symtab->symbols[j].offset = syms->st_value - baseaddr;
         symtab->symbols[j].size   = syms->st_size;
+#if defined(ppc64)
+        if (opd != NULL && *sym_name != '.' &&
+            (opd->sh_addr <= syms->st_value && syms->st_value <= opd->sh_addr + opd->sh_size))
+          symtab->symbols[j].offset =
+            ((ELF_ADDR*)opd_sect->c_data)[(syms->st_value - opd->sh_addr) / sizeof(ELF_ADDR*)] - baseaddr;
+        else
+#endif
 
         key.data = sym_name;
         key.size = strlen(sym_name) + 1;
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java	Mon Sep 03 11:13:04 2018 -0700
@@ -33,6 +33,7 @@
 import sun.jvm.hotspot.debugger.JVMDebugger;
 import sun.jvm.hotspot.debugger.MachineDescription;
 import sun.jvm.hotspot.debugger.MachineDescriptionAMD64;
+import sun.jvm.hotspot.debugger.MachineDescriptionPPC64;
 import sun.jvm.hotspot.debugger.MachineDescriptionIA64;
 import sun.jvm.hotspot.debugger.MachineDescriptionIntelX86;
 import sun.jvm.hotspot.debugger.MachineDescriptionSPARC32Bit;
@@ -588,6 +589,8 @@
             machDesc = new MachineDescriptionIA64();
         } else if (cpu.equals("amd64")) {
             machDesc = new MachineDescriptionAMD64();
+        } else if (cpu.equals("ppc64")) {
+            machDesc = new MachineDescriptionPPC64();
         } else if (cpu.equals("sparc")) {
             if (LinuxDebuggerLocal.getAddressSize()==8) {
                     machDesc = new MachineDescriptionSPARC64Bit();
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/MachineDescriptionPPC64.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger;
+
+public class MachineDescriptionPPC64 extends MachineDescriptionTwosComplement implements MachineDescription {
+  public long getAddressSize() {
+    return 8;
+  }
+
+  public boolean isLP64() {
+    return true;
+  }
+
+  public boolean isBigEndian() {
+    String endian = System.getProperty("sun.cpu.endian");
+    if (endian.equals("big"))
+      return true;
+    else
+      return false;
+  }
+}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java	Mon Sep 03 11:13:04 2018 -0700
@@ -30,8 +30,10 @@
 import sun.jvm.hotspot.debugger.cdbg.*;
 import sun.jvm.hotspot.debugger.x86.*;
 import sun.jvm.hotspot.debugger.amd64.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
+import sun.jvm.hotspot.debugger.bsd.ppc64.*;
 import sun.jvm.hotspot.utilities.*;
 
 class BsdCDebugger implements CDebugger {
@@ -97,6 +99,13 @@
        Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);
        if (pc == null) return null;
        return new BsdAMD64CFrame(dbg, rbp, pc);
+    }  else if (cpu.equals("ppc64")) {
+        PPC64ThreadContext context = (PPC64ThreadContext) thread.getContext();
+        Address sp = context.getRegisterAsAddress(PPC64ThreadContext.SP);
+        if (sp == null) return null;
+        Address pc  = context.getRegisterAsAddress(PPC64ThreadContext.PC);
+        if (pc == null) return null;
+        return new BsdPPC64CFrame(dbg, sp, pc, BsdDebuggerLocal.getAddressSize());
     } else {
        throw new DebuggerException(cpu + " is not yet supported");
     }
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java	Mon Sep 03 11:13:04 2018 -0700
@@ -27,6 +27,7 @@
 import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
+import sun.jvm.hotspot.debugger.bsd.ppc64.*;
 
 class BsdThreadContextFactory {
    static ThreadContext createThreadContext(BsdDebugger dbg) {
@@ -35,6 +36,8 @@
          return new BsdX86ThreadContext(dbg);
       } else if (cpu.equals("amd64") || cpu.equals("x86_64")) {
          return new BsdAMD64ThreadContext(dbg);
+      }  else if (cpu.equals("ppc64")) {
+          return new BsdPPC64ThreadContext(dbg);
       } else {
          throw new RuntimeException("cpu " + cpu + " is not yet supported");
       }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/ppc64/BsdPPC64CFrame.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.bsd.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.debugger.bsd.*;
+import sun.jvm.hotspot.debugger.cdbg.*;
+import sun.jvm.hotspot.debugger.cdbg.basic.*;
+
+final public class BsdPPC64CFrame extends BasicCFrame {
+  // package/class internals only
+
+  public BsdPPC64CFrame(BsdDebugger dbg, Address sp, Address pc, int address_size) {
+    super(dbg.getCDebugger());
+    this.sp = sp;
+    this.pc = pc;
+    this.dbg = dbg;
+    this.address_size=address_size;
+  }
+
+  // override base class impl to avoid ELF parsing
+  public ClosestSymbol closestSymbolToPC() {
+    // try native lookup in debugger.
+    return dbg.lookup(dbg.getAddressValue(pc()));
+  }
+
+  public Address pc() {
+    return     pc;
+  }
+
+  public Address localVariableBase() {
+    return sp;
+  }
+
+  public CFrame sender(ThreadProxy thread) {
+    if (sp == null) {
+      return null;
+    }
+
+    Address nextSP = sp.getAddressAt(0);
+    if (nextSP == null) {
+      return null;
+    }
+    Address nextPC  = sp.getAddressAt(2 * address_size);
+    if (nextPC == null) {
+      return null;
+    }
+    return new BsdPPC64CFrame(dbg, nextSP, nextPC, address_size);
+  }
+
+  public static int PPC64_STACK_BIAS = 0;
+  private static int address_size;
+  private Address pc;
+  private Address sp;
+  private BsdDebugger dbg;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/ppc64/BsdPPC64ThreadContext.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.bsd.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.debugger.bsd.*;
+
+public class BsdPPC64ThreadContext extends PPC64ThreadContext {
+  private BsdDebugger debugger;
+
+  public BsdPPC64ThreadContext(BsdDebugger debugger) {
+    super();
+    this.debugger = debugger;
+  }
+
+  public void setRegisterAsAddress(int index, Address value) {
+    setRegister(index, debugger.getAddressValue(value));
+  }
+
+  public Address getRegisterAsAddress(int index) {
+    return debugger.newAddress(getRegister(index));
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/ppc64/PPC64ThreadContext.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.cdbg.*;
+
+/** Specifies the thread context on ppc64 platforms; only a sub-portion
+ * of the context is guaranteed to be present on all operating
+ * systems. */
+
+public abstract class PPC64ThreadContext implements ThreadContext {
+
+  // NOTE: The indices for the various registers must be maintained as
+  // listed across various operating systems. However, only a small
+  // subset of the registers' values are guaranteed to be present (and
+  // must be present for the SA's stack walking to work).
+
+  public static final int R31 = 0;
+  public static final int R30 = 1;
+  public static final int R29 = 2;
+  public static final int R28 = 3;
+  public static final int R27 = 4;
+  public static final int R26 = 5;
+  public static final int R25  = 6;
+  public static final int R24  = 7;
+  public static final int R23 = 8;
+  public static final int R22 = 9;
+  public static final int R21 = 10;
+  public static final int R20 = 11;
+  public static final int R19 = 12;
+  public static final int R18 = 13;
+  public static final int R17 = 14;
+  public static final int R16 = 15;
+  public static final int R15 = 16;
+  public static final int R14 = 17;
+  public static final int R13 = 18;
+  public static final int R12 = 19;
+  public static final int R11 = 20;
+  public static final int R10 = 21;
+  public static final int R9 = 22;
+  public static final int R8 = 23;
+  public static final int R7 = 24;
+  public static final int R6 = 25;
+  public static final int R5 = 26;
+  public static final int R4 = 27;
+  public static final int R3 = 28;
+  public static final int R2 = 29;
+  public static final int R1 = 30;
+  public static final int R0 = 31;
+  public static final int NIP = 32;
+  public static final int LR = 33;
+
+  public static final int NPRGREG = 34;
+
+  private static final String[] regNames = {
+    "r31", "r30", "r29", "r28", "r27", "r26", "r25", "r24",
+    "r23", "r22", "r21", "r20", "r19", "r18", "r17", "r16",
+    "r15", "r14", "r13", "r12", "r11", "r10", "r9",  "r8",
+    "r7",  "r6",  "r5",  "r4",  "r3",   "r2", "r1",  "r0",
+    "nip", "link"
+  };
+
+  public static final int PC = NIP;
+  public static final int SP = R1;
+
+  private long[] data;
+
+  public PPC64ThreadContext() {
+    data = new long[NPRGREG];
+  }
+
+  public int getNumRegisters() {
+    return NPRGREG;
+  }
+
+  public String getRegisterName(int index) {
+    return regNames[index];
+  }
+
+  public void setRegister(int index, long value) {
+    data[index] = value;
+  }
+
+  public long getRegister(int index) {
+    return data[index];
+  }
+
+  public CFrame getTopFrame(Debugger dbg) {
+    return null;
+  }
+
+  /** This can't be implemented in this class since we would have to
+   * tie the implementation to, for example, the debugging system */
+  public abstract void setRegisterAsAddress(int index, Address value);
+
+  /** This can't be implemented in this class since we would have to
+   * tie the implementation to, for example, the debugging system */
+  public abstract Address getRegisterAsAddress(int index);
+
+}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/proc/ProcDebuggerLocal.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/proc/ProcDebuggerLocal.java	Mon Sep 03 11:13:04 2018 -0700
@@ -32,7 +32,9 @@
 import sun.jvm.hotspot.debugger.cdbg.*;
 import sun.jvm.hotspot.debugger.proc.amd64.*;
 import sun.jvm.hotspot.debugger.proc.sparc.*;
+import sun.jvm.hotspot.debugger.proc.ppc64.*;
 import sun.jvm.hotspot.debugger.proc.x86.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
 import sun.jvm.hotspot.debugger.amd64.*;
 import sun.jvm.hotspot.debugger.sparc.*;
 import sun.jvm.hotspot.debugger.x86.*;
@@ -86,6 +88,10 @@
             threadFactory = new ProcAMD64ThreadFactory(this);
             pcRegIndex = AMD64ThreadContext.RIP;
             fpRegIndex = AMD64ThreadContext.RBP;
+        } else if (cpu.equals("ppc64")) {
+            threadFactory = new ProcPPC64ThreadFactory(this);
+            pcRegIndex = PPC64ThreadContext.PC;
+            fpRegIndex = PPC64ThreadContext.SP;
         } else {
           try {
             Class tfc = Class.forName("sun.jvm.hotspot.debugger.proc." +
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/proc/ppc64/ProcPPC64Thread.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.proc.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.debugger.proc.*;
+import sun.jvm.hotspot.utilities.*;
+
+public class ProcPPC64Thread implements ThreadProxy {
+  private ProcDebugger debugger;
+  private int         id;
+
+  public ProcPPC64Thread(ProcDebugger debugger, Address addr) {
+    this.debugger = debugger;
+
+    // FIXME: the size here should be configurable. However, making it
+    // so would produce a dependency on the "types" package from the
+    // debugger package, which is not desired.
+    this.id       = (int) addr.getCIntegerAt(0, 4, true);
+  }
+
+  public ProcPPC64Thread(ProcDebugger debugger, long id) {
+    this.debugger = debugger;
+    this.id = (int) id;
+  }
+
+  public ThreadContext getContext() throws IllegalThreadStateException {
+    ProcPPC64ThreadContext context = new ProcPPC64ThreadContext(debugger);
+    long[] regs = debugger.getThreadIntegerRegisterSet(id);
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(regs.length <= PPC64ThreadContext.NPRGREG, "size of register set is greater than " + PPC64ThreadContext.NPRGREG);
+    }
+    for (int i = 0; i < regs.length; i++) {
+      context.setRegister(i, regs[i]);
+    }
+    return context;
+  }
+
+  public boolean canSetContext() throws DebuggerException {
+    return false;
+  }
+
+  public void setContext(ThreadContext context)
+    throws IllegalThreadStateException, DebuggerException {
+    throw new DebuggerException("Unimplemented");
+  }
+
+  public String toString() {
+    return "t@" + id;
+  }
+
+  public boolean equals(Object obj) {
+    if ((obj == null) || !(obj instanceof ProcPPC64Thread)) {
+      return false;
+    }
+
+    return (((ProcPPC64Thread) obj).id == id);
+  }
+
+  public int hashCode() {
+    return id;
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/proc/ppc64/ProcPPC64ThreadContext.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.proc.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.debugger.proc.*;
+
+public class ProcPPC64ThreadContext extends PPC64ThreadContext {
+  private ProcDebugger debugger;
+
+  public ProcPPC64ThreadContext(ProcDebugger debugger) {
+    super();
+    this.debugger = debugger;
+  }
+
+  public void setRegisterAsAddress(int index, Address value) {
+    setRegister(index, debugger.getAddressValue(value));
+  }
+
+  public Address getRegisterAsAddress(int index) {
+    return debugger.newAddress(getRegister(index));
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/proc/ppc64/ProcPPC64ThreadFactory.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.proc.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.proc.*;
+
+public class ProcPPC64ThreadFactory implements ProcThreadFactory {
+  private ProcDebugger debugger;
+
+  public ProcPPC64ThreadFactory(ProcDebugger debugger) {
+    this.debugger = debugger;
+  }
+
+  public ThreadProxy createThreadWrapper(Address threadIdentifierAddr) {
+    return new ProcPPC64Thread(debugger, threadIdentifierAddr);
+  }
+
+  public ThreadProxy createThreadWrapper(long id) {
+    return new ProcPPC64Thread(debugger, id);
+  }
+}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/remote/RemoteDebuggerClient.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/remote/RemoteDebuggerClient.java	Mon Sep 03 11:13:04 2018 -0700
@@ -33,6 +33,7 @@
 import sun.jvm.hotspot.debugger.remote.sparc.*;
 import sun.jvm.hotspot.debugger.remote.x86.*;
 import sun.jvm.hotspot.debugger.remote.amd64.*;
+import sun.jvm.hotspot.debugger.remote.ppc64.*;
 
 /** An implementation of Debugger which wraps a
     RemoteDebugger, providing remote debugging via RMI.
@@ -70,6 +71,11 @@
         cachePageSize = 4096;
         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
         unalignedAccessesOkay = true;
+      } else if (cpu.equals("ppc64")) {
+        threadFactory = new RemotePPC64ThreadFactory(this);
+        cachePageSize = 4096;
+        cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
+        unalignedAccessesOkay = true;
       } else {
         try {
           Class tf = Class.forName("sun.jvm.hotspot.debugger.remote." +
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/remote/ppc64/RemotePPC64Thread.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.remote.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.debugger.remote.*;
+import sun.jvm.hotspot.utilities.*;
+
+public class RemotePPC64Thread extends RemoteThread  {
+  public RemotePPC64Thread(RemoteDebuggerClient debugger, Address addr) {
+    super(debugger, addr);
+  }
+
+  public RemotePPC64Thread(RemoteDebuggerClient debugger, long id) {
+    super(debugger, id);
+  }
+
+  public ThreadContext getContext() throws IllegalThreadStateException {
+    RemotePPC64ThreadContext context = new RemotePPC64ThreadContext(debugger);
+    long[] regs = (addr != null)? debugger.getThreadIntegerRegisterSet(addr) :
+      debugger.getThreadIntegerRegisterSet(id);
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(regs.length == PPC64ThreadContext.NPRGREG, "size of register set must match");
+    }
+    for (int i = 0; i < regs.length; i++) {
+      context.setRegister(i, regs[i]);
+    }
+    return context;
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/remote/ppc64/RemotePPC64ThreadContext.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.remote.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.debugger.remote.*;
+
+public class RemotePPC64ThreadContext extends PPC64ThreadContext {
+  private RemoteDebuggerClient debugger;
+
+  public RemotePPC64ThreadContext(RemoteDebuggerClient debugger) {
+    super();
+    this.debugger = debugger;
+  }
+
+  /** This can't be implemented in this class since we would have to
+      tie the implementation to, for example, the debugging system */
+  public void setRegisterAsAddress(int index, Address value) {
+    setRegister(index, debugger.getAddressValue(value));
+  }
+
+  /** This can't be implemented in this class since we would have to
+      tie the implementation to, for example, the debugging system */
+  public Address getRegisterAsAddress(int index) {
+    return debugger.newAddress(getRegister(index));
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/remote/ppc64/RemotePPC64ThreadFactory.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.remote.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.remote.*;
+
+public class RemotePPC64ThreadFactory implements RemoteThreadFactory {
+  private RemoteDebuggerClient debugger;
+
+  public RemotePPC64ThreadFactory(RemoteDebuggerClient debugger) {
+    this.debugger = debugger;
+  }
+
+  public ThreadProxy createThreadWrapper(Address threadIdentifierAddr) {
+    return new RemotePPC64Thread(debugger, threadIdentifierAddr);
+  }
+
+  public ThreadProxy createThreadWrapper(long id) {
+    return new RemotePPC64Thread(debugger, id);
+  }
+}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/Threads.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/Threads.java	Mon Sep 03 11:13:04 2018 -0700
@@ -37,6 +37,7 @@
 import sun.jvm.hotspot.runtime.linux_sparc.LinuxSPARCJavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_ppc64.BsdPPC64JavaThreadPDAccess;
 import sun.jvm.hotspot.utilities.*;
 
 public class Threads {
@@ -103,6 +104,8 @@
                 access = new BsdX86JavaThreadPDAccess();
             } else if (cpu.equals("amd64") || cpu.equals("x86_64")) {
                 access = new BsdAMD64JavaThreadPDAccess();
+            } else if (cpu.equals("ppc64")) {
+                access = new BsdPPC64JavaThreadPDAccess();
             }
         } else if (os.equals("darwin")) {
             if (cpu.equals("amd64") || cpu.equals("x86_64")) {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_ppc64/BsdPPC64JavaThreadPDAccess.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.bsd_ppc64;
+
+import java.io.*;
+import java.util.*;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.runtime.*;
+import sun.jvm.hotspot.runtime.ppc64.*;
+import sun.jvm.hotspot.types.*;
+import sun.jvm.hotspot.utilities.*;
+
+public class BsdPPC64JavaThreadPDAccess implements JavaThreadPDAccess {
+  private static AddressField  osThreadField;
+
+  // Field from OSThread
+  private static CIntegerField osThreadThreadIDField;
+
+  // This is currently unneeded but is being kept in case we change
+  // the currentFrameGuess algorithm
+  private static final long GUESS_SCAN_RANGE = 128 * 1024;
+
+  static {
+    VM.registerVMInitializedObserver(new Observer() {
+        public void update(Observable o, Object data) {
+          initialize(VM.getVM().getTypeDataBase());
+        }
+      });
+  }
+
+  private static synchronized void initialize(TypeDataBase db) {
+    Type type = db.lookupType("JavaThread");
+    osThreadField           = type.getAddressField("_osthread");
+
+    Type osThreadType = db.lookupType("OSThread");
+    osThreadThreadIDField   = osThreadType.getCIntegerField("_thread_id");
+  }
+
+  public    Address getLastJavaFP(Address addr) {
+    return null;
+  }
+
+  public    Address getLastJavaPC(Address addr) {
+    return null;
+  }
+
+  public    Address getBaseOfStackPointer(Address addr) {
+    return null;
+  }
+
+  public    Frame getLastFramePD(JavaThread thread, Address addr) {
+    Address fp = thread.getLastJavaFP();
+    if (fp == null) {
+      return null; // no information
+    }
+    return new PPC64Frame(thread.getLastJavaSP(), fp);
+  }
+
+  public    RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
+    return new PPC64RegisterMap(thread, updateMap);
+  }
+
+  public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
+    ThreadProxy t = getThreadProxy(addr);
+    PPC64ThreadContext context = (PPC64ThreadContext) t.getContext();
+    PPC64CurrentFrameGuess guesser = new PPC64CurrentFrameGuess(context, thread);
+    if (!guesser.run(GUESS_SCAN_RANGE)) {
+      return null;
+    }
+    if (guesser.getPC() == null) {
+      return new PPC64Frame(guesser.getSP(), guesser.getFP());
+    } else {
+      return new PPC64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());
+    }
+  }
+
+  public    void printThreadIDOn(Address addr, PrintStream tty) {
+    tty.print(getThreadProxy(addr));
+  }
+
+  public    void printInfoOn(Address threadAddr, PrintStream tty) {
+    tty.print("Thread id: ");
+    printThreadIDOn(threadAddr, tty);
+//    tty.println("\nPostJavaState: " + getPostJavaState(threadAddr));
+  }
+
+  public    Address getLastSP(Address addr) {
+    ThreadProxy t = getThreadProxy(addr);
+    PPC64ThreadContext context = (PPC64ThreadContext) t.getContext();
+    return context.getRegisterAsAddress(PPC64ThreadContext.SP);
+  }
+
+  public Address getLastFP(Address addr) {
+    return getLastSP(addr).getAddressAt(0);
+  }
+
+  public    ThreadProxy getThreadProxy(Address addr) {
+    // Addr is the address of the JavaThread.
+    // Fetch the OSThread (for now and for simplicity, not making a
+    // separate "OSThread" class in this package)
+    Address osThreadAddr = osThreadField.getValue(addr);
+    // Get the address of the _thread_id from the OSThread
+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());
+
+    JVMDebugger debugger = VM.getVM().getDebugger();
+    return debugger.getThreadForIdentifierAddress(threadIdAddr);
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/ppc64/PPC64CurrentFrameGuess.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.ppc64.*;
+import sun.jvm.hotspot.code.*;
+import sun.jvm.hotspot.interpreter.*;
+import sun.jvm.hotspot.runtime.*;
+import sun.jvm.hotspot.runtime.ppc64.*;
+
+/** <P> Should be able to be used on all ppc64 platforms we support
+    (Linux/ppc64) to implement JavaThread's "currentFrameGuess()"
+    functionality. Input is a PPC64ThreadContext; output is SP, FP,
+    and PC for an PPC64Frame. Instantiation of the PPC64Frame is left
+    to the caller, since we may need to subclass PPC64Frame to support
+    signal handler frames on Unix platforms. </P>
+ */
+
+public class PPC64CurrentFrameGuess {
+  private PPC64ThreadContext context;
+  private JavaThread       thread;
+  private Address          spFound;
+  private Address          fpFound;
+  private Address          pcFound;
+
+  private static final boolean DEBUG = System.getProperty("sun.jvm.hotspot.runtime.ppc64.PPC64Frame.DEBUG")
+                                       != null;
+
+  public PPC64CurrentFrameGuess(PPC64ThreadContext context,
+                              JavaThread thread) {
+    this.context = context;
+    this.thread  = thread;
+  }
+
+  /** Returns false if not able to find a frame within a reasonable range. */
+  public boolean run(long regionInBytesToSearch) {
+    Address sp  = context.getRegisterAsAddress(PPC64ThreadContext.SP);
+    Address pc  = context.getRegisterAsAddress(PPC64ThreadContext.PC);
+    if (sp == null) {
+      // Bail out if no last java frame either
+      if (thread.getLastJavaSP() != null) {
+        Address javaSP = thread.getLastJavaSP();
+        Address javaFP = javaSP.getAddressAt(0);
+        setValues(javaSP, javaFP, null);
+        return true;
+      }
+      return false;
+    }
+    /* There is no frame pointer per se for the ppc64 architecture.  To mirror
+     * the behavior of the VM frame manager, we set fp to be the caller's (i.e., "sender's")
+     * stack pointer, which is the back chain value contained in our sp.
+     */
+    Address fp = sp.getAddressAt(0);
+    setValues(null, null, null); // Assume we're not going to find anything
+
+    VM vm = VM.getVM();
+    if (vm.isJavaPCDbg(pc)) {
+      if (vm.isClientCompiler()) {
+        // Topmost frame is a Java frame.
+        if (DEBUG) {
+          System.out.println("CurrentFrameGuess: choosing compiler frame: sp = " +
+                             sp + ", fp = " + fp + ", pc = " + pc);
+        }
+        setValues(sp, fp, pc);
+        return true;
+      } else {
+        if (vm.getInterpreter().contains(pc)) {
+          if (DEBUG) {
+            System.out.println("CurrentFrameGuess: choosing interpreter frame: sp = " +
+                               sp + ", fp = " + fp + ", pc = " + pc);
+          }
+          setValues(sp, fp, pc);
+          return true;
+        }
+
+        // This algorithm takes the current PC as a given and tries to
+        // find the correct corresponding SP by walking up the stack
+        // and repeatedly performing stackwalks (very inefficient).
+        for (long offset = 0;
+             offset < regionInBytesToSearch;
+             offset += vm.getAddressSize()) {
+          try {
+            Address curSP = sp.addOffsetTo(offset);
+            fp = curSP.getAddressAt(0);
+            Frame frame = new PPC64Frame(curSP, fp, pc);
+            RegisterMap map = thread.newRegisterMap(false);
+            while (frame != null) {
+              if (frame.isEntryFrame() && frame.entryFrameIsFirst()) {
+                // We were able to traverse all the way to the
+                // bottommost Java frame.
+                // This sp looks good. Keep it.
+                if (DEBUG) {
+                  System.out.println("CurrentFrameGuess: Choosing sp = " + curSP + ", pc = " + pc);
+                }
+                setValues(curSP, fp, pc);
+                return true;
+              }
+              frame = frame.sender(map);
+            }
+          } catch (Exception e) {
+            if (DEBUG) {
+              System.out.println("CurrentFrameGuess: Exception " + e + " at offset " + offset);
+            }
+            // Bad SP. Try another.
+          }
+        }
+
+        // Were not able to find a plausible SP to go with this PC.
+        // Bail out.
+        return false;
+
+      }
+    } else {
+      // If the current program counter was not known to us as a Java
+      // PC, we currently assume that we are in the run-time system
+      // and attempt to look to thread-local storage for saved java SP.
+      // Note that if this is null (because we were, in fact,
+      // in Java code, i.e., vtable stubs or similar, and the SA
+      // didn't have enough insight into the target VM to understand
+      // that) then we are going to lose the entire stack trace for
+      // the thread, which is sub-optimal. FIXME.
+
+      if (thread.getLastJavaSP() == null) {
+        if (DEBUG)
+          System.out.println("CurrentFrameGuess: last java sp is null");
+        return false; // No known Java frames on stack
+      }
+
+      Address javaSP = thread.getLastJavaSP();
+      Address javaFP = javaSP.getAddressAt(0);
+      Address javaPC = thread.getLastJavaPC();
+      if (DEBUG) {
+        System.out.println("CurrentFrameGuess: choosing last Java frame: sp = " +
+                           javaSP + ", fp = " + javaFP + ", pc = " + javaPC);
+      }
+      setValues(javaSP, javaFP, javaPC);
+      return true;
+    }
+  }
+
+  public Address getSP() { return spFound; }
+  public Address getFP() { return fpFound; }
+  /** May be null if getting values from thread-local storage; take
+      care to call the correct PPC64Frame constructor to recover this if
+      necessary */
+  public Address getPC() { return pcFound; }
+
+  private void setValues(Address sp, Address fp, Address pc) {
+    spFound = sp;
+    fpFound = fp;
+    pcFound = pc;
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/ppc64/PPC64Frame.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,508 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.ppc64;
+
+import java.util.*;
+import sun.jvm.hotspot.code.*;
+import sun.jvm.hotspot.compiler.*;
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.oops.*;
+import sun.jvm.hotspot.runtime.*;
+import sun.jvm.hotspot.types.*;
+import sun.jvm.hotspot.utilities.*;
+
+/** Specialization of and implementation of abstract methods of the
+    Frame class for the ppc64 family of CPUs. */
+
+public class PPC64Frame extends Frame {
+  private static final boolean DEBUG;
+  static {
+    DEBUG = System.getProperty("sun.jvm.hotspot.runtime.ppc64.PPC64Frame.DEBUG") != null;
+  }
+
+  // All frames
+  private static final int SENDER_SP_OFFSET           =  0;
+
+  // Interpreter frames
+  private static final int INTERPRETER_FRAME_MIRROR_OFFSET    =  -3; // for native calls only
+  private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -4;
+  private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_MDX_OFFSET = INTERPRETER_FRAME_LAST_SP_OFFSET -1;
+  private static final  int INTERPRETER_FRAME_ESP_OFFSET = INTERPRETER_FRAME_MDX_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_BCX_OFFSET = INTERPRETER_FRAME_ESP_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_CACHE_OFFSET =INTERPRETER_FRAME_BCX_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_MONITORS_OFFSET = INTERPRETER_FRAME_CACHE_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_LOCALS_OFFSET = INTERPRETER_FRAME_MONITORS_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_METHOD_OFFSET = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
+  private static final int INTERPRETER_FRAME_INITIAL_SP_OFFSET = INTERPRETER_FRAME_BCX_OFFSET - 1; // FIXME: probably wrong, but unused anyway
+  private static final int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
+  private static final int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
+
+  // Entry frames
+  private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET;
+
+  // Native frames
+  private static       int NATIVE_FRAME_INITIAL_PARAM_OFFSET;
+
+
+  static {
+    VM.registerVMInitializedObserver(new Observer() {
+      public void update(Observable o, Object data) {
+        initialize(VM.getVM().getTypeDataBase());
+      }
+    });
+  }
+
+  private static synchronized void initialize(TypeDataBase db) {
+    int abi_minframe_size = db.lookupIntConstant("frame::abi_minframe_size").intValue();
+    int entry_frame_locals_size = db.lookupIntConstant("frame::entry_frame_locals_size").intValue();
+    int wordLength = (int)VM.getVM().getAddressSize();
+    NATIVE_FRAME_INITIAL_PARAM_OFFSET = -abi_minframe_size/wordLength;
+    ENTRY_FRAME_CALL_WRAPPER_OFFSET = -entry_frame_locals_size/wordLength;
+  }
+
+
+  // an additional field beyond sp and pc:
+  Address raw_fp; // frame pointer
+  private Address raw_unextendedSP;
+
+  private PPC64Frame() {
+  }
+
+  private void adjustForDeopt() {
+    if ( pc != null) {
+      // Look for a deopt pc and if it is deopted convert to original pc
+      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);
+      if (cb != null && cb.isJavaMethod()) {
+        NMethod nm = (NMethod) cb;
+        if (pc.equals(nm.deoptHandlerBegin())) {
+          if (Assert.ASSERTS_ENABLED) {
+            Assert.that(this.getUnextendedSP() != null, "null SP in Java frame");
+          }
+          // adjust pc if frame is deoptimized.
+          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());
+          deoptimized = true;
+        }
+      }
+    }
+  }
+
+  public PPC64Frame(Address raw_sp, Address raw_fp, Address pc) {
+    this.raw_sp = raw_sp;
+    this.raw_unextendedSP = raw_sp;
+    if (raw_fp == null)
+      this.raw_fp = raw_sp.getAddressAt(0);
+    else
+      this.raw_fp = raw_fp;
+    if (pc == null)
+      this.pc = raw_sp.getAddressAt(2 * VM.getVM().getAddressSize());
+    else
+      this.pc = pc;
+    adjustUnextendedSP();
+
+    // Frame must be fully constructed before this call
+    adjustForDeopt();
+
+    if (DEBUG) {
+      System.out.println("PPC64Frame(sp, fp, pc): " + this);
+      dumpStack();
+    }
+  }
+
+  public PPC64Frame(Address raw_sp, Address raw_fp) {
+    this.raw_sp = raw_sp;
+    this.raw_unextendedSP = raw_sp;
+    if (raw_fp == null)
+      this.raw_fp = raw_sp.getAddressAt(0);
+    else
+      this.raw_fp = raw_fp;
+    this.pc = raw_sp.getAddressAt(2 * VM.getVM().getAddressSize());
+    adjustUnextendedSP();
+
+    // Frame must be fully constructed before this call
+    adjustForDeopt();
+
+    if (DEBUG) {
+      System.out.println("PPC64Frame(sp, fp): " + this);
+      dumpStack();
+    }
+  }
+
+  public PPC64Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {
+    this.raw_sp = raw_sp;
+    this.raw_unextendedSP = raw_unextendedSp;
+    if (raw_fp == null)
+      this.raw_fp = raw_sp.getAddressAt(0);
+    else
+      this.raw_fp = raw_fp;
+    if (pc == null)
+      this.pc = raw_sp.getAddressAt(2 * VM.getVM().getAddressSize());
+    else
+      this.pc = pc;
+    adjustUnextendedSP();
+
+    // Frame must be fully constructed before this call
+    adjustForDeopt();
+
+    if (DEBUG) {
+      System.out.println("PPC64Frame(sp, unextendedSP, fp, pc): " + this);
+      dumpStack();
+    }
+
+  }
+
+  public Object clone() {
+    PPC64Frame frame = new PPC64Frame();
+    frame.raw_sp = raw_sp;
+    frame.raw_unextendedSP = raw_unextendedSP;
+    frame.raw_fp = raw_fp;
+    frame.pc = pc;
+    frame.deoptimized = deoptimized;
+    return frame;
+  }
+
+  public boolean equals(Object arg) {
+    if (arg == null) {
+      return false;
+    }
+
+    if (!(arg instanceof PPC64Frame)) {
+      return false;
+    }
+
+    PPC64Frame other = (PPC64Frame) arg;
+
+    return (AddressOps.equal(getSP(), other.getSP()) &&
+        AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &&
+        AddressOps.equal(getFP(), other.getFP()) &&
+        AddressOps.equal(getPC(), other.getPC()));
+  }
+
+  public int hashCode() {
+    if (raw_sp == null) {
+      return 0;
+    }
+
+    return raw_sp.hashCode();
+  }
+
+  public String toString() {
+    return "sp: " + (getSP() == null? "null" : getSP().toString()) +
+        ", unextendedSP: " + (getUnextendedSP() == null? "null" : getUnextendedSP().toString()) +
+        ", fp: " + (getFP() == null? "null" : getFP().toString()) +
+        ", pc: " + (pc == null? "null" : pc.toString());
+  }
+
+  // accessors for the instance variables
+  public Address getFP() { return raw_fp; }
+  public Address getSP() { return raw_sp; }
+  public Address getID() { return raw_sp; }
+
+  // FIXME: not implemented yet (should be done for Solaris/PPC64)
+  public boolean isSignalHandlerFrameDbg() { return false; }
+  public int     getSignalNumberDbg()      { return 0;     }
+  public String  getSignalNameDbg()        { return null;  }
+
+  public boolean isInterpretedFrameValid() {
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(isInterpretedFrame(), "Not an interpreted frame");
+    }
+
+    // These are reasonable sanity checks
+    if (getFP() == null || getFP().andWithMask(0x3) != null) {
+      return false;
+    }
+
+    if (getSP() == null || getSP().andWithMask(0x3) != null) {
+      return false;
+    }
+
+    // These are hacks to keep us out of trouble.
+    // The problem with these is that they mask other problems
+    if (getFP().lessThanOrEqual(getSP())) {
+      // this attempts to deal with unsigned comparison above
+      return false;
+    }
+
+    if (getFP().minus(getSP()) > 4096 * VM.getVM().getAddressSize()) {
+      // stack frames shouldn't be large.
+      return false;
+    }
+
+    return true;
+  }
+
+  // FIXME: not applicable in current system
+  //  void    patch_pc(Thread* thread, address pc);
+
+  public Frame sender(RegisterMap regMap, CodeBlob cb) {
+    PPC64RegisterMap map = (PPC64RegisterMap) regMap;
+
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(map != null, "map must be set");
+    }
+
+    // Default is we done have to follow them. The sender_for_xxx will
+    // update it accordingly
+    map.setIncludeArgumentOops(false);
+
+    if (isEntryFrame())       return senderForEntryFrame(map);
+    if (isInterpretedFrame()) return senderForInterpreterFrame(map);
+
+    if(cb == null) {
+      cb = VM.getVM().getCodeCache().findBlob(getPC());
+    } else {
+      if (Assert.ASSERTS_ENABLED) {
+        Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), "Must be the same");
+      }
+    }
+
+    if (cb != null) {
+      return senderForCompiledFrame(map, cb);
+    }
+
+    // Must be native-compiled frame, i.e. the marshaling code for native
+    // methods that exists in the core system.
+    return new PPC64Frame(getSenderSP(), getLink(), getSenderPC());
+  }
+
+  private Frame senderForEntryFrame(PPC64RegisterMap map) {
+    if (DEBUG) {
+      System.out.println("senderForEntryFrame");
+    }
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(map != null, "map must be set");
+    }
+    // Java frame called from C; skip all C frames and return top C
+    // frame of that chunk as the sender
+    PPC64JavaCallWrapper jcw = (PPC64JavaCallWrapper) getEntryFrameCallWrapper();
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(!entryFrameIsFirst(), "next Java fp must be non zero");
+      Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), "must be above this frame on stack");
+    }
+    PPC64Frame fr;
+    if (jcw.getLastJavaPC() != null) {
+      fr = new PPC64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());
+    } else {
+      fr = new PPC64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());
+    }
+    map.clear();
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(map.getIncludeArgumentOops(), "should be set by clear");
+    }
+    return fr;
+  }
+
+  //------------------------------------------------------------------------------
+  // frame::adjust_unextended_sp
+  private void adjustUnextendedSP() {
+    raw_unextendedSP = getFP();
+  }
+  private Frame senderForInterpreterFrame(PPC64RegisterMap map) {
+    if (DEBUG) {
+      System.out.println("senderForInterpreterFrame");
+    }
+    Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
+    Address sp = getSenderSP();
+
+    return new PPC64Frame(sp, unextendedSP, getLink(), getSenderPC());
+  }
+
+
+  private Frame senderForCompiledFrame(PPC64RegisterMap map, CodeBlob cb) {
+    if (DEBUG) {
+      System.out.println("senderForCompiledFrame");
+    }
+
+    //
+    // NOTE: some of this code is (unfortunately) duplicated in PPC64CurrentFrameGuess
+    //
+
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(map != null, "map must be set");
+    }
+
+    // frame owned by optimizing compiler
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(cb.getFrameSize() >= 0, "must have non-zero frame size");
+    }
+    Address senderSP = getSenderSP();
+
+    Address senderPC = getSenderPC();
+
+    if (map.getUpdateMap()) {
+      // Tell GC to use argument oopmaps for some runtime stubs that need it.
+      // For C1, the runtime stub might not have oop maps, so set this flag
+      // outside of update_register_map.
+      map.setIncludeArgumentOops(cb.callerMustGCArguments());
+
+      if (cb.getOopMaps() != null) {
+        OopMapSet.updateRegisterMap(this, cb, map, true);
+      }
+    }
+
+    return new PPC64Frame(senderSP, getLink(), senderPC);
+  }
+
+  protected boolean hasSenderPD() {
+    // FIXME
+    return true;
+  }
+
+  public long frameSize() {
+    return (getSenderSP().minus(getSP()) / VM.getVM().getAddressSize());
+  }
+
+  public Address getLink() {
+    return getSenderSP().getAddressAt(0);
+  }
+
+  public Address getUnextendedSP() { return raw_unextendedSP; }
+
+  // Return address:
+  public Address getSenderPC()     { return getSenderSP().getAddressAt(2 * VM.getVM().getAddressSize()); }
+
+  // return address of param, zero origin index.
+  // MPJ note:   Appears to be unused.
+  public Address getNativeParamAddr(int idx) {
+    return null;
+    // return addressOfStackSlot(NATIVE_FRAME_INITIAL_PARAM_OFFSET + idx);
+  }
+
+  public Address getSenderSP()     { return getFP(); }
+  public Address addressOfInterpreterFrameLocals() {
+    return addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET);
+  }
+
+  private Address addressOfInterpreterFrameBCX() {
+    return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);
+  }
+
+  public int getInterpreterFrameBCI() {
+    // FIXME: this is not atomic with respect to GC and is unsuitable
+    // for use in a non-debugging, or reflective, system. Need to
+    // figure out how to express this.
+    Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);
+    Address methodHandle = addressOfInterpreterFrameMethod().getAddressAt(0);
+    Method method = (Method)Metadata.instantiateWrapperFor(methodHandle);
+    return bcpToBci(bcp, method);
+  }
+
+  public Address addressOfInterpreterFrameMDX() {
+    return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);
+  }
+
+  // FIXME
+  //inline int frame::interpreter_frame_monitor_size() {
+  //  return BasicObjectLock::size();
+  //}
+
+  // expression stack
+  // (the max_stack arguments are used by the GC; see class FrameClosure)
+
+  public Address addressOfInterpreterFrameExpressionStack() {
+    Address monitorEnd = interpreterFrameMonitorEnd().address();
+    return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());
+  }
+
+  public int getInterpreterFrameExpressionStackDirection() { return -1; }
+
+  // top of expression stack
+  public Address addressOfInterpreterFrameTOS() {
+    return getSP();
+  }
+
+  /** Expression stack from top down */
+  public Address addressOfInterpreterFrameTOSAt(int slot) {
+    return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
+  }
+
+  public Address getInterpreterFrameSenderSP() {
+    if (Assert.ASSERTS_ENABLED) {
+      Assert.that(isInterpretedFrame(), "interpreted frame expected");
+    }
+    return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
+  }
+
+  // Monitors
+  public BasicObjectLock interpreterFrameMonitorBegin() {
+    return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
+  }
+
+  public BasicObjectLock interpreterFrameMonitorEnd() {
+    Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getAddressAt(0);
+    if (Assert.ASSERTS_ENABLED) {
+      // make sure the pointer points inside the frame
+      Assert.that(AddressOps.gt(getFP(), result), "result must <  than frame pointer");
+      Assert.that(AddressOps.lte(getSP(), result), "result must >= than stack pointer");
+    }
+    return new BasicObjectLock(result);
+  }
+
+  public int interpreterFrameMonitorSize() {
+    return BasicObjectLock.size();
+  }
+
+  // Method
+  public Address addressOfInterpreterFrameMethod() {
+    return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
+  }
+
+  // Constant pool cache
+  public Address addressOfInterpreterFrameCPCache() {
+    return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
+  }
+
+  // Entry frames
+  public JavaCallWrapper getEntryFrameCallWrapper() {
+    return new PPC64JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));
+  }
+
+  protected Address addressOfSavedOopResult() {
+    // offset is 2 for compiler2 and 3 for compiler1
+    return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *
+        VM.getVM().getAddressSize());
+  }
+
+  protected Address addressOfSavedReceiver() {
+    return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
+  }
+
+  private void dumpStack() {
+    if (getFP() != null) {
+      for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());
+          AddressOps.lte(addr, getFP().addOffsetTo(5 * VM.getVM().getAddressSize()));
+          addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
+        System.out.println(addr + ": " + addr.getAddressAt(0));
+      }
+    } else {
+      for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());
+          AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));
+          addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
+        System.out.println(addr + ": " + addr.getAddressAt(0));
+      }
+    }
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/ppc64/PPC64JavaCallWrapper.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.ppc64;
+
+import java.util.*;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.types.*;
+import sun.jvm.hotspot.runtime.*;
+
+public class PPC64JavaCallWrapper extends JavaCallWrapper {
+
+  public PPC64JavaCallWrapper(Address addr) {
+    super(addr);
+  }
+
+  public Address getLastJavaFP() {
+    return null;
+  }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/ppc64/PPC64RegisterMap.java	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 20014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.ppc64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.runtime.*;
+
+public class PPC64RegisterMap extends RegisterMap {
+
+  /** This is the only public constructor */
+  public PPC64RegisterMap(JavaThread thread, boolean updateMap) {
+    super(thread, updateMap);
+  }
+
+  protected PPC64RegisterMap(RegisterMap map) {
+    super(map);
+  }
+
+  public Object clone() {
+    PPC64RegisterMap retval = new PPC64RegisterMap(this);
+    return retval;
+  }
+
+  // no PD state to clear or copy:
+  protected void clearPD() {}
+  protected void initializePD() {}
+  protected void initializeFromPD(RegisterMap map) {}
+  protected Address getLocationPD(VMReg reg) { return null; }
+}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java	Mon Sep 03 11:13:04 2018 -0700
@@ -61,7 +61,7 @@
       return "x86";
     } else if (cpu.equals("sparc") || cpu.equals("sparcv9")) {
       return "sparc";
-    } else if (cpu.equals("ia64") || cpu.equals("amd64") || cpu.equals("x86_64")) {
+    } else if (cpu.equals("ia64") || cpu.equals("amd64") || cpu.equals("x86_64") || cpu.equals("ppc64")) {
       return cpu;
     } else {
       try {
--- ./hotspot/make/bsd/Makefile	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/Makefile	Mon Sep 03 11:13:04 2018 -0700
@@ -66,6 +66,10 @@
     FORCE_TIERED=1
   endif
 endif
+# C1 is not ported on ppc64, so we cannot build a tiered VM:
+ifneq (,$(findstring $(ARCH), ppc ppc64))
+  FORCE_TIERED=0
+endif
 
 ifdef LP64
   ifeq ("$(filter $(LP64_ARCH),$(BUILDARCH))","")
--- ./hotspot/make/bsd/makefiles/build_vm_def.sh	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/build_vm_def.sh	Mon Sep 03 11:13:04 2018 -0700
@@ -1,12 +1,28 @@
 #!/bin/sh
 
 # If we're cross compiling use that path for nm
-if [ "$CROSS_COMPILE_ARCH" != "" ]; then 
-NM=$ALT_COMPILER_PATH/nm
+if [ "$CROSS_COMPILE_ARCH" != "" ]; then
+    NM=$ALT_COMPILER_PATH/nm
 else
-NM=nm
+    NM=nm
 fi
 
-$NM -Uj $* | awk '
-   { if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 }
-   '
+case "$(uname -s)" in
+Darwin )
+    $NM -Uj $@ | awk '{
+        if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3
+    }' ;;
+OpenBSD )
+    $NM $@ | awk '{
+        if ($2 == "U") next
+        if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 ";"
+        if ($3 ~ /^UseSharedSpaces$/) print "\t" $3 ";"
+        if ($3 ~ /^_ZN9Arguments17SharedArchivePathE$/) print "\t" $3 ";"
+    }' | sort -u ;;
+* )
+    $NM --defined-only $@ | awk '{
+        if ($3 ~ /^_ZTV/ || $3 ~ /^gHotSpotVM/) print "\t" $3 ";"
+        if ($3 ~ /^UseSharedSpaces$/) print "\t" $3 ";"
+        if ($3 ~ /^_ZN9Arguments17SharedArchivePathE$/) print "\t" $3 ";"
+    }' | sort -u ;;
+esac
--- ./hotspot/make/bsd/makefiles/debug.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/debug.make	Mon Sep 03 11:13:04 2018 -0700
@@ -35,7 +35,10 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug
+ifeq ($(OS_VENDOR), Darwin)
+MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug$(MAPSUFX)
 
 VERSION = debug
 SYSDEFS += -DASSERT
--- ./hotspot/make/bsd/makefiles/defs.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/defs.make	Mon Sep 03 11:13:04 2018 -0700
@@ -29,7 +29,15 @@
 SLASH_JAVA ?= /java
 
 # Need PLATFORM (os-arch combo names) for jdk and hotspot, plus libarch name
-ARCH:=$(shell uname -m)
+# ARCH can be set explicitly in spec.gmk
+ifndef ARCH
+  ARCH := $(shell uname -m)
+  # Fold little endian PowerPC64 into big-endian (if ARCH is set in
+  # hotspot-spec.gmk, this will be done by the configure script).
+  ifeq ($(ARCH),ppc64le)
+    ARCH := ppc64
+  endif
+endif
 PATH_SEP = :
 ifeq ($(LP64), 1)
   ARCH_DATA_MODEL ?= 64
@@ -117,11 +125,19 @@
 endif
 
 # PPC
-ifeq ($(ARCH), ppc)
-  ARCH_DATA_MODEL  = 32
-  PLATFORM         = bsd-ppc
-  VM_PLATFORM      = bsd_ppc
-  HS_ARCH          = ppc
+# Notice: after 8046471 ARCH will be 'ppc' for top-level ppc64 builds but
+# 'ppc64' for HotSpot-only ppc64 builds. Need to detect both variants here!
+ifneq (,$(findstring $(ARCH), ppc ppc64))
+  ifeq ($(ARCH_DATA_MODEL), 64)
+    MAKE_ARGS        += LP64=1
+    PLATFORM         = bsd-ppc64
+    VM_PLATFORM      = bsd_ppc64
+  else
+    ARCH_DATA_MODEL  = 32
+    PLATFORM         = bsd-ppc
+    VM_PLATFORM      = bsd_ppc
+  endif
+  HS_ARCH = ppc
 endif
 
 # On 32 bit bsd we build server and client, on 64 bit just server.
@@ -321,10 +337,22 @@
 ifeq ($(JVM_VARIANT_MINIMAL1),true)
   EXPORT_LIST += $(EXPORT_MINIMAL_DIR)/Xusage.txt
   EXPORT_LIST += $(EXPORT_MINIMAL_DIR)/libjvm.$(LIBRARY_SUFFIX)
+
+  ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+    ifeq ($(ZIP_DEBUGINFO_FILES),1)
+        EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.diz
+    else
+      ifeq ($(OS_VENDOR), Darwin)
+          EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX).dSYM
+      else
+          EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.debuginfo
+      endif
+    endif
+  endif
 endif
 
 # Serviceability Binaries
-# No SA Support for PPC, IA64, ARM or zero
+# No SA Support for IA64, ARM or zero
 ADD_SA_BINARIES/x86   = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
                         $(EXPORT_LIB_DIR)/sa-jdi.jar
 
@@ -340,6 +368,23 @@
   endif
 endif
 
+ADD_SA_BINARIES/ppc   = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
+                        $(EXPORT_LIB_DIR)/sa-jdi.jar
+ADD_SA_BINARIES/universal = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
+                            $(EXPORT_LIB_DIR)/sa-jdi.jar
+
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  ifeq ($(ZIP_DEBUGINFO_FILES),1)
+      ADD_SA_BINARIES/ppc += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.diz
+  else
+    ifeq ($(OS_VENDOR), Darwin)
+        ADD_SA_BINARIES/ppc += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX).dSYM
+    else
+        ADD_SA_BINARIES/ppc += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.debuginfo
+    endif
+  endif
+endif
+
 ADD_SA_BINARIES/sparc = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
                         $(EXPORT_LIB_DIR)/sa-jdi.jar
 ADD_SA_BINARIES/universal = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
@@ -357,7 +402,6 @@
   endif
 endif
 
-ADD_SA_BINARIES/ppc   =
 ADD_SA_BINARIES/ia64  =
 ADD_SA_BINARIES/arm   =
 ADD_SA_BINARIES/zero  =
--- ./hotspot/make/bsd/makefiles/fastdebug.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/fastdebug.make	Mon Sep 03 11:13:04 2018 -0700
@@ -56,7 +56,10 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug
+ifeq ($(OS_VENDOR), Darwin)
+MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug$(MAPSUFX)
 
 VERSION = fastdebug
 SYSDEFS += -DASSERT -DCHECK_UNHANDLED_OOPS
--- ./hotspot/make/bsd/makefiles/gcc.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/gcc.make	Mon Sep 03 11:13:04 2018 -0700
@@ -168,6 +168,9 @@
   CFLAGS += -DDONT_USE_PRECOMPILED_HEADER
 endif
 
+# Allow for where third party packages are located
+CFLAGS+= -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+
 #------------------------------------------------------------------------
 # Compiler flags
 
@@ -201,12 +204,15 @@
 endif
 
 ifeq ($(USE_CLANG), true)
-  # Before Clang 3.1, we had to pass the stack alignment specification directly to llvm with the help of '-mllvm'
-  # Starting with version 3.1, Clang understands the '-mstack-alignment' (and rejects '-mllvm -stack-alignment')
-  ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 3 \) \| \( \( $(CC_VER_MAJOR) = 3 \) \& \( $(CC_VER_MINOR) \>= 1 \) \))" "0"
-    STACK_ALIGNMENT_OPT = -mno-omit-leaf-frame-pointer -mstack-alignment=16
-  else
-    STACK_ALIGNMENT_OPT = -mno-omit-leaf-frame-pointer -mllvm -stack-alignment=16
+  STACK_ALIGNMENT_OPT = -mno-omit-leaf-frame-pointer
+  ifeq ($(OS_VENDOR), Darwin)
+    # Before Clang 3.1, we had to pass the stack alignment specification directly to llvm with the help of '-mllvm'
+    # Starting with version 3.1, Clang understands the '-mstack-alignment' (and rejects '-mllvm -stack-alignment')
+    ifneq "$(shell expr \( $(CC_VER_MAJOR) \> 3 \) \| \( \( $(CC_VER_MAJOR) = 3 \) \& \( $(CC_VER_MINOR) \>= 1 \) \))" "0"
+      STACK_ALIGNMENT_OPT += -mstack-alignment=16
+    else
+      STACK_ALIGNMENT_OPT += -mllvm -stack-alignment=16
+    endif
   endif
 endif
 
@@ -258,6 +264,10 @@
 #  WARNINGS_ARE_ERRORS += -Wno-tautological-constant-out-of-range-compare
   WARNINGS_ARE_ERRORS += -Wno-delete-non-virtual-dtor -Wno-deprecated -Wno-format -Wno-dynamic-class-memaccess
   WARNINGS_ARE_ERRORS += -Wno-empty-body
+  ifneq "$(shell expr \( $(CC_VER_MAJOR) \>= 6 \))" "0"
+    WARNINGS_ARE_ERRORS += -Wno-undefined-bool-conversion -Wno-expansion-to-defined
+    WARNINGS_ARE_ERRORS += -Wno-undefined-var-template
+  endif
 endif
 
 WARNING_FLAGS = -Wpointer-arith -Wsign-compare -Wundef
@@ -265,7 +275,7 @@
 ifeq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 3 \) \))" "0"
   # Since GCC 4.3, -Wconversion has changed its meanings to warn these implicit
   # conversions which might affect the values. Only enable it in earlier versions.
-  WARNING_FLAGS = -Wunused-function
+#  WARNING_FLAGS = -Wunused-function
   ifeq ($(USE_CLANG),)
     WARNING_FLAGS += -Wconversion
   endif
@@ -318,6 +328,9 @@
     OPT_CFLAGS/loopTransform.o += $(OPT_CFLAGS/NOOPT)
     OPT_CFLAGS/unsafe.o += -O1
   endif
+  ifeq ($(shell expr $(CC_VER_MAJOR) = 6 \& $(CC_VER_MINOR) = 0), 1)
+    OPT_CFLAGS/unsafe.o += -O1
+  endif
 else
   # 6835796. Problem in GCC 4.3.0 with mulnode.o optimized compilation.
   ifeq ($(shell expr $(CC_VER_MAJOR) = 4 \& $(CC_VER_MINOR) = 3), 1)
@@ -379,6 +392,8 @@
 # Use $(MAPFLAG:FILENAME=real_file_name) to specify a map file.
 MAPFLAG = -Xlinker --version-script=FILENAME
 
+LDFLAGS_NO_EXEC_STACK="-Wl,-z,noexecstack"
+
 #
 # Shared Library
 #
@@ -421,53 +436,44 @@
   CFLAGS += -flimit-debug-info
 endif
 
+# Use the stabs format for debugging information (this is the default
+# on gcc-2.91). It's good enough, has all the information about line
+# numbers and local variables, and libjvm.so is only about 16M.
+# Change this back to "-g" if you want the most expressive format.
+# (warning: that could easily inflate libjvm.so to 150M!)
+# Note: The Itanium gcc compiler crashes when using -gstabs.
+# Don't use stabs on gcc>=4.8 because it is incompatible with
+# pre-compiled-headers
+ifeq ($(USE_CLANG), true)
+  # Clang doesn't understand -gstabs
+  STABS_CFLAGS += -g
+else
+  ifeq "$(shell expr \( $(CC_VER_MAJOR) \> 4 \) \| \( \( $(CC_VER_MAJOR) = 4 \) \& \( $(CC_VER_MINOR) \>= 8 \) \))" "1"
+    # GCC >= 4.8
+    STABS_CFLAGS += -g
+  else
+    STABS_CFLAGS/ia64  = -g
+    STABS_CFLAGS/arm   = -g
+    STABS_CFLAGS/ppc   = -g
+    STABS_CFLAGS/amd64 = -g
+    ifeq ($(STABS_CFLAGS/$(BUILDARCH)),)
+      STABS_CFLAGS += -gstabs
+    else
+      STABS_CFLAGS += $(STABS_CFLAGS/$(BUILDARCH))
+    endif
+  endif
+endif
+
 # DEBUG_BINARIES uses full -g debug information for all configs
 ifeq ($(DEBUG_BINARIES), true)
   CFLAGS += -g
 else
-  # Use the stabs format for debugging information (this is the default
-  # on gcc-2.91). It's good enough, has all the information about line
-  # numbers and local variables, and libjvm.so is only about 16M.
-  # Change this back to "-g" if you want the most expressive format.
-  # (warning: that could easily inflate libjvm.so to 150M!)
-  # Note: The Itanium gcc compiler crashes when using -gstabs.
-  DEBUG_CFLAGS/ia64  = -g
-  DEBUG_CFLAGS/amd64 = -g
-  DEBUG_CFLAGS/arm   = -g
-  DEBUG_CFLAGS/ppc   = -g
-  DEBUG_CFLAGS += $(DEBUG_CFLAGS/$(BUILDARCH))
-  ifeq ($(DEBUG_CFLAGS/$(BUILDARCH)),)
-  DEBUG_CFLAGS += -gstabs
-  endif
+  DEBUG_CFLAGS += ${STABS_CFLAGS}
   
   ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
-    FASTDEBUG_CFLAGS/ia64  = -g
-    FASTDEBUG_CFLAGS/amd64 = -g
-    FASTDEBUG_CFLAGS/arm   = -g
-    FASTDEBUG_CFLAGS/ppc   = -g
-    FASTDEBUG_CFLAGS += $(FASTDEBUG_CFLAGS/$(BUILDARCH))
-    ifeq ($(FASTDEBUG_CFLAGS/$(BUILDARCH)),)
-      ifeq ($(USE_CLANG), true)
-        # Clang doesn't understand -gstabs
-        FASTDEBUG_CFLAGS += -g
-      else
-        FASTDEBUG_CFLAGS += -gstabs
-      endif
-    endif
+    FASTDEBUG_CFLAGS += ${STABS_CFLAGS}
   
-    OPT_CFLAGS/ia64  = -g
-    OPT_CFLAGS/amd64 = -g
-    OPT_CFLAGS/arm   = -g
-    OPT_CFLAGS/ppc   = -g
-    OPT_CFLAGS += $(OPT_CFLAGS/$(BUILDARCH))
-    ifeq ($(OPT_CFLAGS/$(BUILDARCH)),)
-      ifeq ($(USE_CLANG), true)
-        # Clang doesn't understand -gstabs
-        OPT_CFLAGS += -g
-      else
-        OPT_CFLAGS += -gstabs
-      endif
-    endif
+    OPT_CFLAGS += ${STABS_CFLAGS}
   endif
 endif
 
--- ./hotspot/make/bsd/makefiles/jsig.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/jsig.make	Mon Sep 03 11:13:04 2018 -0700
@@ -52,7 +52,7 @@
 # cause problems with interposing. See CR: 6466665
 # LFLAGS_JSIG += $(MAPFLAG:FILENAME=$(LIBJSIG_MAPFILE))
 
-LFLAGS_JSIG += -D_GNU_SOURCE -pthread $(LDFLAGS_HASH_STYLE)
+LFLAGS_JSIG += -D_GNU_SOURCE -pthread $(LDFLAGS_HASH_STYLE) $(LDFLAGS_NO_EXEC_STACK)
 
 # DEBUG_BINARIES overrides everything, use full -g debug information
 ifeq ($(DEBUG_BINARIES), true)
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/launcher.make	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,117 @@
+#
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+
+# Rules to build gamma launcher, used by vm.make
+
+
+LAUNCHER_SCRIPT = hotspot
+LAUNCHER   = gamma
+
+LAUNCHERDIR   := $(GAMMADIR)/src/os/posix/launcher
+LAUNCHERDIR_SHARE := $(GAMMADIR)/src/share/tools/launcher
+LAUNCHERFLAGS := $(ARCHFLAG) \
+                -I$(LAUNCHERDIR) -I$(GAMMADIR)/src/share/vm/prims \
+                -I$(LAUNCHERDIR_SHARE) \
+                -DFULL_VERSION=\"$(HOTSPOT_RELEASE_VERSION)\" \
+                -DJDK_MAJOR_VERSION=\"$(JDK_MAJOR_VERSION)\" \
+                -DJDK_MINOR_VERSION=\"$(JDK_MINOR_VERSION)\" \
+                -DARCH=\"$(LIBARCH)\" \
+                -DGAMMA \
+                -DLAUNCHER_TYPE=\"gamma\" \
+                -DLINK_INTO_$(LINK_INTO) \
+                $(TARGET_DEFINES)
+# Give the launcher task_for_pid() privileges so that it can be used to run JStack, JInfo, et al.
+ifeq ($(OS_VENDOR), Darwin)
+LFLAGS_LAUNCHER += -sectcreate __TEXT __info_plist $(GAMMADIR)/src/os/bsd/launcher/Info-privileged.plist
+endif
+
+ifeq ($(LINK_INTO),AOUT)
+  LAUNCHER.o                 = launcher.o $(JVM_OBJ_FILES)
+  LAUNCHER_MAPFILE           = mapfile_reorder
+  LFLAGS_LAUNCHER$(LDNOMAP) += $(MAPFLAG:FILENAME=$(LAUNCHER_MAPFILE))
+  LFLAGS_LAUNCHER           += $(SONAMEFLAG:SONAME=$(LIBJVM)) $(STATIC_LIBGCC)
+  LIBS_LAUNCHER             += $(STATIC_STDCXX) $(LIBS)
+else
+  LAUNCHER.o                 = launcher.o
+  LFLAGS_LAUNCHER           += -L`pwd`
+
+  # The gamma launcher runs the JDK from $JAVA_HOME, overriding the JVM with a
+  # freshly built JVM at ./libjvm.{so|dylib}.  This is accomplished by setting
+  # the library searchpath using ({DY}LD_LIBRARY_PATH) to find the local JVM
+  # first.  Gamma dlopen()s libjava from $JAVA_HOME/jre/lib{/$arch}, which is
+  # statically linked with CoreFoundation framework libs. Unfortunately, gamma's
+  # unique searchpath results in some unresolved symbols in the framework
+  # libraries, because JDK libraries are inadvertently discovered first on the
+  # searchpath, e.g. libjpeg.  On Mac OS X, filenames are case *insensitive*.
+  # So, the actual filename collision is libjpeg.dylib and libJPEG.dylib.
+  # To resolve this, gamma needs to also statically link with the CoreFoundation
+  # framework libraries.
+
+  ifeq ($(OS_VENDOR),Darwin)
+    LFLAGS_LAUNCHER         += -framework CoreFoundation
+  endif
+
+  LIBS_LAUNCHER             += -l$(JVM) $(LIBS)
+endif
+
+LINK_LAUNCHER = $(LINK.CC)
+
+LINK_LAUNCHER/PRE_HOOK  = $(LINK_LIB.CXX/PRE_HOOK)
+LINK_LAUNCHER/POST_HOOK = $(LINK_LIB.CXX/POST_HOOK)
+
+LAUNCHER_OUT = launcher
+
+SUFFIXES += .d
+
+SOURCES := $(shell find $(LAUNCHERDIR) -name "*.c")
+SOURCES_SHARE := $(shell find $(LAUNCHERDIR_SHARE) -name "*.c")
+
+OBJS := $(patsubst $(LAUNCHERDIR)/%.c,$(LAUNCHER_OUT)/%.o,$(SOURCES)) $(patsubst $(LAUNCHERDIR_SHARE)/%.c,$(LAUNCHER_OUT)/%.o,$(SOURCES_SHARE))
+
+DEPFILES := $(patsubst %.o,%.d,$(OBJS))
+-include $(DEPFILES)
+
+$(LAUNCHER_OUT)/%.o: $(LAUNCHERDIR_SHARE)/%.c
+	$(QUIETLY) [ -d $(LAUNCHER_OUT) ] || { mkdir -p $(LAUNCHER_OUT); }
+	$(QUIETLY) $(CC) -g -o $@ -c $< -MMD $(LAUNCHERFLAGS) $(CXXFLAGS)
+
+$(LAUNCHER_OUT)/%.o: $(LAUNCHERDIR)/%.c
+	$(QUIETLY) [ -d $(LAUNCHER_OUT) ] || { mkdir -p $(LAUNCHER_OUT); }
+	$(QUIETLY) $(CC) -g -o $@ -c $< -MMD $(LAUNCHERFLAGS) $(CXXFLAGS)
+
+$(LAUNCHER): $(OBJS) $(LIBJVM) $(LAUNCHER_MAPFILE)
+	$(QUIETLY) echo Linking launcher...
+	$(QUIETLY) $(LINK_LAUNCHER/PRE_HOOK)
+	$(QUIETLY) $(LINK_LAUNCHER) $(LFLAGS_LAUNCHER) -o $@ $(sort $(OBJS)) $(LIBS_LAUNCHER)
+	$(QUIETLY) $(LINK_LAUNCHER/POST_HOOK)
+	# Sign the launcher with the development certificate (if present) so that it can be used
+	# to run JStack, JInfo, et al.
+	$(QUIETLY) -codesign -s openjdk_codesign $@
+
+$(LAUNCHER): $(LAUNCHER_SCRIPT)
+
+$(LAUNCHER_SCRIPT): $(LAUNCHERDIR)/launcher.script
+	$(QUIETLY) sed -e 's/@@LIBARCH@@/$(LIBARCH)/g' $< > $@
+	$(QUIETLY) chmod +x $@
+
--- ./hotspot/make/bsd/makefiles/mapfile-vers-debug	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-debug	Mon Sep 03 11:13:04 2018 -0700
@@ -21,246 +21,254 @@
 # questions.
 #
 #
-# Only used for OSX/Darwin builds
 
 # Define public interface.
+
+SUNWprivate_1.1 {
+        global:
                 # _JNI
-                _JNI_CreateJavaVM
-                _JNI_GetCreatedJavaVMs
-                _JNI_GetDefaultJavaVMInitArgs
+                JNI_CreateJavaVM;
+                JNI_GetCreatedJavaVMs;
+                JNI_GetDefaultJavaVMInitArgs;
 
-                # _JVM
-                _JVM_Accept
-                _JVM_ActiveProcessorCount
-                _JVM_AllocateNewArray
-                _JVM_AllocateNewObject
-                _JVM_ArrayCopy
-                _JVM_AssertionStatusDirectives
-                _JVM_Available
-                _JVM_Bind
-                _JVM_ClassDepth
-                _JVM_ClassLoaderDepth
-                _JVM_Clone
-                _JVM_Close
-                _JVM_CX8Field
-                _JVM_CompileClass
-                _JVM_CompileClasses
-                _JVM_CompilerCommand
-                _JVM_Connect
-                _JVM_ConstantPoolGetClassAt
-                _JVM_ConstantPoolGetClassAtIfLoaded
-                _JVM_ConstantPoolGetDoubleAt
-                _JVM_ConstantPoolGetFieldAt
-                _JVM_ConstantPoolGetFieldAtIfLoaded
-                _JVM_ConstantPoolGetFloatAt
-                _JVM_ConstantPoolGetIntAt
-                _JVM_ConstantPoolGetLongAt
-                _JVM_ConstantPoolGetMethodAt
-                _JVM_ConstantPoolGetMethodAtIfLoaded
-                _JVM_ConstantPoolGetMemberRefInfoAt
-                _JVM_ConstantPoolGetSize
-                _JVM_ConstantPoolGetStringAt
-                _JVM_ConstantPoolGetUTF8At
-                _JVM_CountStackFrames
-                _JVM_CurrentClassLoader
-                _JVM_CurrentLoadedClass
-                _JVM_CurrentThread
-                _JVM_CurrentTimeMillis
-                _JVM_DefineClass
-                _JVM_DefineClassWithSource
-                _JVM_DefineClassWithSourceCond
-                _JVM_DesiredAssertionStatus
-                _JVM_DisableCompiler
-                _JVM_DoPrivileged
-                _JVM_DTraceGetVersion
-                _JVM_DTraceActivate
-                _JVM_DTraceIsProbeEnabled
-                _JVM_DTraceIsSupported
-                _JVM_DTraceDispose
-                _JVM_DumpAllStacks
-                _JVM_DumpThreads
-                _JVM_EnableCompiler
-                _JVM_Exit
-                _JVM_FillInStackTrace
-                _JVM_FindClassFromCaller
-                _JVM_FindClassFromClass
-                _JVM_FindClassFromClassLoader
-                _JVM_FindClassFromBootLoader
-                _JVM_FindLibraryEntry
-                _JVM_FindLoadedClass
-                _JVM_FindPrimitiveClass
-                _JVM_FindSignal
-                _JVM_FreeMemory
-                _JVM_GC
-                _JVM_GetAllThreads
-                _JVM_GetArrayElement
-                _JVM_GetArrayLength
-                _JVM_GetCPClassNameUTF
-                _JVM_GetCPFieldClassNameUTF
-                _JVM_GetCPFieldModifiers
-                _JVM_GetCPFieldNameUTF
-                _JVM_GetCPFieldSignatureUTF
-                _JVM_GetCPMethodClassNameUTF
-                _JVM_GetCPMethodModifiers
-                _JVM_GetCPMethodNameUTF
-                _JVM_GetCPMethodSignatureUTF
-                _JVM_GetCallerClass
-                _JVM_GetClassAccessFlags
-                _JVM_GetClassAnnotations
-                _JVM_GetClassCPEntriesCount
-                _JVM_GetClassCPTypes
-                _JVM_GetClassConstantPool
-                _JVM_GetClassContext
-                _JVM_GetClassDeclaredConstructors
-                _JVM_GetClassDeclaredFields
-                _JVM_GetClassDeclaredMethods
-                _JVM_GetClassFieldsCount
-                _JVM_GetClassInterfaces
-                _JVM_GetClassLoader
-                _JVM_GetClassMethodsCount
-                _JVM_GetClassModifiers
-                _JVM_GetClassName
-                _JVM_GetClassNameUTF
-                _JVM_GetClassSignature
-                _JVM_GetClassSigners
-                _JVM_GetClassTypeAnnotations
-                _JVM_GetComponentType
-                _JVM_GetDeclaredClasses
-                _JVM_GetDeclaringClass
-                _JVM_GetEnclosingMethodInfo
-                _JVM_GetFieldAnnotations
-                _JVM_GetFieldIxModifiers
-                _JVM_GetFieldTypeAnnotations
-                _JVM_GetHostName
-                _JVM_GetInheritedAccessControlContext
-                _JVM_GetInterfaceVersion
-                _JVM_GetLastErrorString
-                _JVM_GetManagement
-                _JVM_GetMethodAnnotations
-                _JVM_GetMethodDefaultAnnotationValue
-                _JVM_GetMethodIxArgsSize
-                _JVM_GetMethodIxByteCode
-                _JVM_GetMethodIxByteCodeLength
-                _JVM_GetMethodIxExceptionIndexes
-                _JVM_GetMethodIxExceptionTableEntry
-                _JVM_GetMethodIxExceptionTableLength
-                _JVM_GetMethodIxExceptionsCount
-                _JVM_GetMethodIxLocalsCount
-                _JVM_GetMethodIxMaxStack
-                _JVM_GetMethodIxModifiers
-                _JVM_GetMethodIxNameUTF
-                _JVM_GetMethodIxSignatureUTF
-                _JVM_GetMethodParameterAnnotations
-                _JVM_GetMethodParameters
-                _JVM_GetMethodTypeAnnotations
-                _JVM_GetPrimitiveArrayElement
-                _JVM_GetProtectionDomain
-                _JVM_GetSockName
-                _JVM_GetSockOpt
-                _JVM_GetStackAccessControlContext
-                _JVM_GetStackTraceDepth
-                _JVM_GetStackTraceElement
-                _JVM_GetSystemPackage
-                _JVM_GetSystemPackages
-                _JVM_GetTemporaryDirectory
-                _JVM_GetThreadStateNames
-                _JVM_GetThreadStateValues
-                _JVM_GetVersionInfo
-                _JVM_Halt
-                _JVM_HoldsLock
-                _JVM_IHashCode
-                _JVM_InitAgentProperties
-                _JVM_InitProperties
-                _JVM_InitializeCompiler
-                _JVM_InitializeSocketLibrary
-                _JVM_InternString
-                _JVM_Interrupt
-                _JVM_InvokeMethod
-                _JVM_IsArrayClass
-                _JVM_IsConstructorIx
-                _JVM_IsInterface
-                _JVM_IsInterrupted
-                _JVM_IsNaN
-                _JVM_IsPrimitiveClass
-                _JVM_IsSameClassPackage
-                _JVM_IsSilentCompiler
-                _JVM_IsSupportedJNIVersion
-                _JVM_IsThreadAlive
-                _JVM_IsVMGeneratedMethodIx
-                _JVM_KnownToNotExist
-                _JVM_GetResourceLookupCacheURLs
-                _JVM_GetResourceLookupCache
-                _JVM_LatestUserDefinedLoader
-                _JVM_Listen
-                _JVM_LoadClass0
-                _JVM_LoadLibrary
-                _JVM_Lseek
-                _JVM_MaxObjectInspectionAge
-                _JVM_MaxMemory
-                _JVM_MonitorNotify
-                _JVM_MonitorNotifyAll
-                _JVM_MonitorWait
-                _JVM_NanoTime
-                _JVM_NativePath
-                _JVM_NewArray
-                _JVM_NewInstanceFromConstructor
-                _JVM_NewMultiArray
-                _JVM_OnExit
-                _JVM_Open
-                _JVM_RaiseSignal
-                _JVM_RawMonitorCreate
-                _JVM_RawMonitorDestroy
-                _JVM_RawMonitorEnter
-                _JVM_RawMonitorExit
-                _JVM_Read
-                _JVM_Recv
-                _JVM_RecvFrom
-                _JVM_RegisterSignal
-                _JVM_ReleaseUTF
-                _JVM_ResolveClass
-                _JVM_ResumeThread
-                _JVM_Send
-                _JVM_SendTo
-                _JVM_SetArrayElement
-                _JVM_SetClassSigners
-                _JVM_SetLength
-                _JVM_SetNativeThreadName
-                _JVM_SetPrimitiveArrayElement
-                _JVM_SetSockOpt
-                _JVM_SetThreadPriority
-                _JVM_Sleep
-                _JVM_Socket
-                _JVM_SocketAvailable
-                _JVM_SocketClose
-                _JVM_SocketShutdown
-                _JVM_StartThread
-                _JVM_StopThread
-                _JVM_SuspendThread
-                _JVM_SupportsCX8
-                _JVM_Sync
-                _JVM_Timeout
-                _JVM_TotalMemory
-                _JVM_TraceInstructions
-                _JVM_TraceMethodCalls
-                _JVM_UnloadLibrary
-                _JVM_Write
-                _JVM_Yield
-                _JVM_handle_bsd_signal
+                # JVM
+                JVM_Accept;
+                JVM_ActiveProcessorCount;
+                JVM_AllocateNewArray;
+                JVM_AllocateNewObject;
+                JVM_ArrayCopy;
+                JVM_AssertionStatusDirectives;
+                JVM_Available;
+                JVM_Bind;
+                JVM_ClassDepth;
+                JVM_ClassLoaderDepth;
+                JVM_Clone;
+                JVM_Close;
+                JVM_CX8Field;
+                JVM_CompileClass;
+                JVM_CompileClasses;
+                JVM_CompilerCommand;
+                JVM_Connect;
+                JVM_ConstantPoolGetClassAt;
+                JVM_ConstantPoolGetClassAtIfLoaded;
+                JVM_ConstantPoolGetDoubleAt;
+                JVM_ConstantPoolGetFieldAt;
+                JVM_ConstantPoolGetFieldAtIfLoaded;
+                JVM_ConstantPoolGetFloatAt;
+                JVM_ConstantPoolGetIntAt;
+                JVM_ConstantPoolGetLongAt;
+                JVM_ConstantPoolGetMethodAt;
+                JVM_ConstantPoolGetMethodAtIfLoaded;
+                JVM_ConstantPoolGetMemberRefInfoAt;
+                JVM_ConstantPoolGetSize;
+                JVM_ConstantPoolGetStringAt;
+                JVM_ConstantPoolGetUTF8At;
+                JVM_CountStackFrames;
+                JVM_CurrentClassLoader;
+                JVM_CurrentLoadedClass;
+                JVM_CurrentThread;
+                JVM_CurrentTimeMillis;
+                JVM_DefineClass;
+                JVM_DefineClassWithSource;
+                JVM_DefineClassWithSourceCond;
+                JVM_DesiredAssertionStatus;
+                JVM_DisableCompiler;
+                JVM_DoPrivileged;
+                JVM_DTraceGetVersion;
+                JVM_DTraceActivate;
+                JVM_DTraceIsProbeEnabled;
+                JVM_DTraceIsSupported;
+                JVM_DTraceDispose;
+                JVM_DumpAllStacks;
+                JVM_DumpThreads;
+                JVM_EnableCompiler;
+                JVM_Exit;
+                JVM_FillInStackTrace;
+                JVM_FindClassFromCaller;
+                JVM_FindClassFromClass;
+                JVM_FindClassFromClassLoader;
+                JVM_FindClassFromBootLoader;
+                JVM_FindLibraryEntry;
+                JVM_FindLoadedClass;
+                JVM_FindPrimitiveClass;
+                JVM_FindSignal;
+                JVM_FreeMemory;
+                JVM_GC;
+                JVM_GetAllThreads;
+                JVM_GetArrayElement;
+                JVM_GetArrayLength;
+                JVM_GetCPClassNameUTF;
+                JVM_GetCPFieldClassNameUTF;
+                JVM_GetCPFieldModifiers;
+                JVM_GetCPFieldNameUTF;
+                JVM_GetCPFieldSignatureUTF;
+                JVM_GetCPMethodClassNameUTF;
+                JVM_GetCPMethodModifiers;
+                JVM_GetCPMethodNameUTF;
+                JVM_GetCPMethodSignatureUTF;
+                JVM_GetCallerClass;
+                JVM_GetClassAccessFlags;
+                JVM_GetClassAnnotations;
+                JVM_GetClassCPEntriesCount;
+                JVM_GetClassCPTypes;
+                JVM_GetClassConstantPool;
+                JVM_GetClassContext;
+                JVM_GetClassDeclaredConstructors;
+                JVM_GetClassDeclaredFields;
+                JVM_GetClassDeclaredMethods;
+                JVM_GetClassFieldsCount;
+                JVM_GetClassInterfaces;
+                JVM_GetClassLoader;
+                JVM_GetClassMethodsCount;
+                JVM_GetClassModifiers;
+                JVM_GetClassName;
+                JVM_GetClassNameUTF;
+                JVM_GetClassSignature;
+                JVM_GetClassSigners;
+                JVM_GetClassTypeAnnotations;
+                JVM_GetComponentType;
+                JVM_GetDeclaredClasses;
+                JVM_GetDeclaringClass;
+                JVM_GetEnclosingMethodInfo;
+                JVM_GetFieldAnnotations;
+                JVM_GetFieldIxModifiers;
+                JVM_GetFieldTypeAnnotations;
+                JVM_GetHostName;
+                JVM_GetInheritedAccessControlContext;
+                JVM_GetInterfaceVersion;
+                JVM_GetLastErrorString;
+                JVM_GetManagement;
+                JVM_GetMethodAnnotations;
+                JVM_GetMethodDefaultAnnotationValue;
+                JVM_GetMethodIxArgsSize;
+                JVM_GetMethodIxByteCode;
+                JVM_GetMethodIxByteCodeLength;
+                JVM_GetMethodIxExceptionIndexes;
+                JVM_GetMethodIxExceptionTableEntry;
+                JVM_GetMethodIxExceptionTableLength;
+                JVM_GetMethodIxExceptionsCount;
+                JVM_GetMethodIxLocalsCount;
+                JVM_GetMethodIxMaxStack;
+                JVM_GetMethodIxModifiers;
+                JVM_GetMethodIxNameUTF;
+                JVM_GetMethodIxSignatureUTF;
+                JVM_GetMethodParameterAnnotations;
+                JVM_GetMethodParameters;
+                JVM_GetMethodTypeAnnotations;
+                JVM_GetPrimitiveArrayElement;
+                JVM_GetProtectionDomain;
+                JVM_GetSockName;
+                JVM_GetSockOpt;
+                JVM_GetStackAccessControlContext;
+                JVM_GetStackTraceDepth;
+                JVM_GetStackTraceElement;
+                JVM_GetSystemPackage;
+                JVM_GetSystemPackages;
+                JVM_GetTemporaryDirectory;
+                JVM_GetThreadStateNames;
+                JVM_GetThreadStateValues;
+                JVM_GetVersionInfo;
+                JVM_Halt;
+                JVM_HoldsLock;
+                JVM_IHashCode;
+                JVM_InitAgentProperties;
+                JVM_InitProperties;
+                JVM_InitializeCompiler;
+                JVM_InitializeSocketLibrary;
+                JVM_InternString;
+                JVM_Interrupt;
+                JVM_InvokeMethod;
+                JVM_IsArrayClass;
+                JVM_IsConstructorIx;
+                JVM_IsInterface;
+                JVM_IsInterrupted;
+                JVM_IsNaN;
+                JVM_IsPrimitiveClass;
+                JVM_IsSameClassPackage;
+                JVM_IsSilentCompiler;
+                JVM_IsSupportedJNIVersion;
+                JVM_IsThreadAlive;
+                JVM_IsVMGeneratedMethodIx;
+                JVM_KnownToNotExist;
+                JVM_GetResourceLookupCacheURLs;
+                JVM_GetResourceLookupCache;
+                JVM_LatestUserDefinedLoader;
+                JVM_Listen;
+                JVM_LoadClass0;
+                JVM_LoadLibrary;
+                JVM_Lseek;
+                JVM_MaxObjectInspectionAge;
+                JVM_MaxMemory;
+                JVM_MonitorNotify;
+                JVM_MonitorNotifyAll;
+                JVM_MonitorWait;
+                JVM_NanoTime;
+                JVM_NativePath;
+                JVM_NewArray;
+                JVM_NewInstanceFromConstructor;
+                JVM_NewMultiArray;
+                JVM_OnExit;
+                JVM_Open;
+                JVM_RaiseSignal;
+                JVM_RawMonitorCreate;
+                JVM_RawMonitorDestroy;
+                JVM_RawMonitorEnter;
+                JVM_RawMonitorExit;
+                JVM_Read;
+                JVM_Recv;
+                JVM_RecvFrom;
+                JVM_RegisterSignal;
+                JVM_ReleaseUTF;
+                JVM_ResolveClass;
+                JVM_ResumeThread;
+                JVM_Send;
+                JVM_SendTo;
+                JVM_SetArrayElement;
+                JVM_SetClassSigners;
+                JVM_SetLength;
+                JVM_SetNativeThreadName;
+                JVM_SetPrimitiveArrayElement;
+                JVM_SetSockOpt;
+                JVM_SetThreadPriority;
+                JVM_Sleep;
+                JVM_Socket;
+                JVM_SocketAvailable;
+                JVM_SocketClose;
+                JVM_SocketShutdown;
+                JVM_StartThread;
+                JVM_StopThread;
+                JVM_SuspendThread;
+                JVM_SupportsCX8;
+                JVM_Sync;
+                JVM_Timeout;
+                JVM_TotalMemory;
+                JVM_TraceInstructions;
+                JVM_TraceMethodCalls;
+                JVM_UnloadLibrary;
+                JVM_Write;
+                JVM_Yield;
+                JVM_handle_bsd_signal;
 
-                # debug _JVM
-                _JVM_AccessVMBooleanFlag
-                _JVM_AccessVMIntFlag
-                _JVM_VMBreakPoint
+                # debug JVM
+                JVM_AccessVMBooleanFlag;
+                JVM_AccessVMIntFlag;
+                JVM_VMBreakPoint;
 
                 # miscellaneous functions
-                _jio_fprintf
-                _jio_printf
-                _jio_snprintf
-                _jio_vfprintf
-                _jio_vsnprintf
+                jio_fprintf;
+                jio_printf;
+                jio_snprintf;
+                jio_vfprintf;
+                jio_vsnprintf;
+		fork1;
+                numa_warn;
+                numa_error;
 
                 # This is for Forte Analyzer profiling support.
-                _AsyncGetCallTrace
+                AsyncGetCallTrace;
 
                 # INSERT VTABLE SYMBOLS HERE
 
+        local:
+                *;
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-debug.macosx	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,266 @@
+#
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+# Only used for OSX/Darwin builds
+
+# Define public interface.
+                # _JNI
+                _JNI_CreateJavaVM
+                _JNI_GetCreatedJavaVMs
+                _JNI_GetDefaultJavaVMInitArgs
+
+                # _JVM
+                _JVM_Accept
+                _JVM_ActiveProcessorCount
+                _JVM_AllocateNewArray
+                _JVM_AllocateNewObject
+                _JVM_ArrayCopy
+                _JVM_AssertionStatusDirectives
+                _JVM_Available
+                _JVM_Bind
+                _JVM_ClassDepth
+                _JVM_ClassLoaderDepth
+                _JVM_Clone
+                _JVM_Close
+                _JVM_CX8Field
+                _JVM_CompileClass
+                _JVM_CompileClasses
+                _JVM_CompilerCommand
+                _JVM_Connect
+                _JVM_ConstantPoolGetClassAt
+                _JVM_ConstantPoolGetClassAtIfLoaded
+                _JVM_ConstantPoolGetDoubleAt
+                _JVM_ConstantPoolGetFieldAt
+                _JVM_ConstantPoolGetFieldAtIfLoaded
+                _JVM_ConstantPoolGetFloatAt
+                _JVM_ConstantPoolGetIntAt
+                _JVM_ConstantPoolGetLongAt
+                _JVM_ConstantPoolGetMethodAt
+                _JVM_ConstantPoolGetMethodAtIfLoaded
+                _JVM_ConstantPoolGetMemberRefInfoAt
+                _JVM_ConstantPoolGetSize
+                _JVM_ConstantPoolGetStringAt
+                _JVM_ConstantPoolGetUTF8At
+                _JVM_CountStackFrames
+                _JVM_CurrentClassLoader
+                _JVM_CurrentLoadedClass
+                _JVM_CurrentThread
+                _JVM_CurrentTimeMillis
+                _JVM_DefineClass
+                _JVM_DefineClassWithSource
+                _JVM_DefineClassWithSourceCond
+                _JVM_DesiredAssertionStatus
+                _JVM_DisableCompiler
+                _JVM_DoPrivileged
+                _JVM_DTraceGetVersion
+                _JVM_DTraceActivate
+                _JVM_DTraceIsProbeEnabled
+                _JVM_DTraceIsSupported
+                _JVM_DTraceDispose
+                _JVM_DumpAllStacks
+                _JVM_DumpThreads
+                _JVM_EnableCompiler
+                _JVM_Exit
+                _JVM_FillInStackTrace
+                _JVM_FindClassFromCaller
+                _JVM_FindClassFromClass
+                _JVM_FindClassFromClassLoader
+                _JVM_FindClassFromBootLoader
+                _JVM_FindLibraryEntry
+                _JVM_FindLoadedClass
+                _JVM_FindPrimitiveClass
+                _JVM_FindSignal
+                _JVM_FreeMemory
+                _JVM_GC
+                _JVM_GetAllThreads
+                _JVM_GetArrayElement
+                _JVM_GetArrayLength
+                _JVM_GetCPClassNameUTF
+                _JVM_GetCPFieldClassNameUTF
+                _JVM_GetCPFieldModifiers
+                _JVM_GetCPFieldNameUTF
+                _JVM_GetCPFieldSignatureUTF
+                _JVM_GetCPMethodClassNameUTF
+                _JVM_GetCPMethodModifiers
+                _JVM_GetCPMethodNameUTF
+                _JVM_GetCPMethodSignatureUTF
+                _JVM_GetCallerClass
+                _JVM_GetClassAccessFlags
+                _JVM_GetClassAnnotations
+                _JVM_GetClassCPEntriesCount
+                _JVM_GetClassCPTypes
+                _JVM_GetClassConstantPool
+                _JVM_GetClassContext
+                _JVM_GetClassDeclaredConstructors
+                _JVM_GetClassDeclaredFields
+                _JVM_GetClassDeclaredMethods
+                _JVM_GetClassFieldsCount
+                _JVM_GetClassInterfaces
+                _JVM_GetClassLoader
+                _JVM_GetClassMethodsCount
+                _JVM_GetClassModifiers
+                _JVM_GetClassName
+                _JVM_GetClassNameUTF
+                _JVM_GetClassSignature
+                _JVM_GetClassSigners
+                _JVM_GetClassTypeAnnotations
+                _JVM_GetComponentType
+                _JVM_GetDeclaredClasses
+                _JVM_GetDeclaringClass
+                _JVM_GetEnclosingMethodInfo
+                _JVM_GetFieldAnnotations
+                _JVM_GetFieldIxModifiers
+                _JVM_GetFieldTypeAnnotations
+                _JVM_GetHostName
+                _JVM_GetInheritedAccessControlContext
+                _JVM_GetInterfaceVersion
+                _JVM_GetLastErrorString
+                _JVM_GetManagement
+                _JVM_GetMethodAnnotations
+                _JVM_GetMethodDefaultAnnotationValue
+                _JVM_GetMethodIxArgsSize
+                _JVM_GetMethodIxByteCode
+                _JVM_GetMethodIxByteCodeLength
+                _JVM_GetMethodIxExceptionIndexes
+                _JVM_GetMethodIxExceptionTableEntry
+                _JVM_GetMethodIxExceptionTableLength
+                _JVM_GetMethodIxExceptionsCount
+                _JVM_GetMethodIxLocalsCount
+                _JVM_GetMethodIxMaxStack
+                _JVM_GetMethodIxModifiers
+                _JVM_GetMethodIxNameUTF
+                _JVM_GetMethodIxSignatureUTF
+                _JVM_GetMethodParameterAnnotations
+                _JVM_GetMethodParameters
+                _JVM_GetMethodTypeAnnotations
+                _JVM_GetPrimitiveArrayElement
+                _JVM_GetProtectionDomain
+                _JVM_GetSockName
+                _JVM_GetSockOpt
+                _JVM_GetStackAccessControlContext
+                _JVM_GetStackTraceDepth
+                _JVM_GetStackTraceElement
+                _JVM_GetSystemPackage
+                _JVM_GetSystemPackages
+                _JVM_GetTemporaryDirectory
+                _JVM_GetThreadStateNames
+                _JVM_GetThreadStateValues
+                _JVM_GetVersionInfo
+                _JVM_Halt
+                _JVM_HoldsLock
+                _JVM_IHashCode
+                _JVM_InitAgentProperties
+                _JVM_InitProperties
+                _JVM_InitializeCompiler
+                _JVM_InitializeSocketLibrary
+                _JVM_InternString
+                _JVM_Interrupt
+                _JVM_InvokeMethod
+                _JVM_IsArrayClass
+                _JVM_IsConstructorIx
+                _JVM_IsInterface
+                _JVM_IsInterrupted
+                _JVM_IsNaN
+                _JVM_IsPrimitiveClass
+                _JVM_IsSameClassPackage
+                _JVM_IsSilentCompiler
+                _JVM_IsSupportedJNIVersion
+                _JVM_IsThreadAlive
+                _JVM_IsVMGeneratedMethodIx
+                _JVM_KnownToNotExist
+                _JVM_GetResourceLookupCacheURLs
+                _JVM_GetResourceLookupCache
+                _JVM_LatestUserDefinedLoader
+                _JVM_Listen
+                _JVM_LoadClass0
+                _JVM_LoadLibrary
+                _JVM_Lseek
+                _JVM_MaxObjectInspectionAge
+                _JVM_MaxMemory
+                _JVM_MonitorNotify
+                _JVM_MonitorNotifyAll
+                _JVM_MonitorWait
+                _JVM_NanoTime
+                _JVM_NativePath
+                _JVM_NewArray
+                _JVM_NewInstanceFromConstructor
+                _JVM_NewMultiArray
+                _JVM_OnExit
+                _JVM_Open
+                _JVM_RaiseSignal
+                _JVM_RawMonitorCreate
+                _JVM_RawMonitorDestroy
+                _JVM_RawMonitorEnter
+                _JVM_RawMonitorExit
+                _JVM_Read
+                _JVM_Recv
+                _JVM_RecvFrom
+                _JVM_RegisterSignal
+                _JVM_ReleaseUTF
+                _JVM_ResolveClass
+                _JVM_ResumeThread
+                _JVM_Send
+                _JVM_SendTo
+                _JVM_SetArrayElement
+                _JVM_SetClassSigners
+                _JVM_SetLength
+                _JVM_SetNativeThreadName
+                _JVM_SetPrimitiveArrayElement
+                _JVM_SetSockOpt
+                _JVM_SetThreadPriority
+                _JVM_Sleep
+                _JVM_Socket
+                _JVM_SocketAvailable
+                _JVM_SocketClose
+                _JVM_SocketShutdown
+                _JVM_StartThread
+                _JVM_StopThread
+                _JVM_SuspendThread
+                _JVM_SupportsCX8
+                _JVM_Sync
+                _JVM_Timeout
+                _JVM_TotalMemory
+                _JVM_TraceInstructions
+                _JVM_TraceMethodCalls
+                _JVM_UnloadLibrary
+                _JVM_Write
+                _JVM_Yield
+                _JVM_handle_bsd_signal
+
+                # debug _JVM
+                _JVM_AccessVMBooleanFlag
+                _JVM_AccessVMIntFlag
+                _JVM_VMBreakPoint
+
+                # miscellaneous functions
+                _jio_fprintf
+                _jio_printf
+                _jio_snprintf
+                _jio_vfprintf
+                _jio_vsnprintf
+
+                # This is for Forte Analyzer profiling support.
+                _AsyncGetCallTrace
+
+                # INSERT VTABLE SYMBOLS HERE
+
--- ./hotspot/make/bsd/makefiles/mapfile-vers-product	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-product	Mon Sep 03 11:13:04 2018 -0700
@@ -21,241 +21,249 @@
 # questions.
 #
 #
-# Only used for OSX/Darwin builds
 
 # Define public interface.
+
+SUNWprivate_1.1 {
+        global:
                 # _JNI
-                _JNI_CreateJavaVM
-                _JNI_GetCreatedJavaVMs
-                _JNI_GetDefaultJavaVMInitArgs
+                JNI_CreateJavaVM;
+                JNI_GetCreatedJavaVMs;
+                JNI_GetDefaultJavaVMInitArgs;
 
-                # _JVM
-                _JVM_Accept
-                _JVM_ActiveProcessorCount
-                _JVM_AllocateNewArray
-                _JVM_AllocateNewObject
-                _JVM_ArrayCopy
-                _JVM_AssertionStatusDirectives
-                _JVM_Available
-                _JVM_Bind
-                _JVM_ClassDepth
-                _JVM_ClassLoaderDepth
-                _JVM_Clone
-                _JVM_Close
-                _JVM_CX8Field
-                _JVM_CompileClass
-                _JVM_CompileClasses
-                _JVM_CompilerCommand
-                _JVM_Connect
-                _JVM_ConstantPoolGetClassAt
-                _JVM_ConstantPoolGetClassAtIfLoaded
-                _JVM_ConstantPoolGetDoubleAt
-                _JVM_ConstantPoolGetFieldAt
-                _JVM_ConstantPoolGetFieldAtIfLoaded
-                _JVM_ConstantPoolGetFloatAt
-                _JVM_ConstantPoolGetIntAt
-                _JVM_ConstantPoolGetLongAt
-                _JVM_ConstantPoolGetMethodAt
-                _JVM_ConstantPoolGetMethodAtIfLoaded
-                _JVM_ConstantPoolGetMemberRefInfoAt
-                _JVM_ConstantPoolGetSize
-                _JVM_ConstantPoolGetStringAt
-                _JVM_ConstantPoolGetUTF8At
-                _JVM_CountStackFrames
-                _JVM_CurrentClassLoader
-                _JVM_CurrentLoadedClass
-                _JVM_CurrentThread
-                _JVM_CurrentTimeMillis
-                _JVM_DefineClass
-                _JVM_DefineClassWithSource
-                _JVM_DefineClassWithSourceCond
-                _JVM_DesiredAssertionStatus
-                _JVM_DisableCompiler
-                _JVM_DoPrivileged
-                _JVM_DTraceGetVersion
-                _JVM_DTraceActivate
-                _JVM_DTraceIsProbeEnabled
-                _JVM_DTraceIsSupported
-                _JVM_DTraceDispose
-                _JVM_DumpAllStacks
-                _JVM_DumpThreads
-                _JVM_EnableCompiler
-                _JVM_Exit
-                _JVM_FillInStackTrace
-                _JVM_FindClassFromCaller
-                _JVM_FindClassFromClass
-                _JVM_FindClassFromClassLoader
-                _JVM_FindClassFromBootLoader
-                _JVM_FindLibraryEntry
-                _JVM_FindLoadedClass
-                _JVM_FindPrimitiveClass
-                _JVM_FindSignal
-                _JVM_FreeMemory
-                _JVM_GC
-                _JVM_GetAllThreads
-                _JVM_GetArrayElement
-                _JVM_GetArrayLength
-                _JVM_GetCPClassNameUTF
-                _JVM_GetCPFieldClassNameUTF
-                _JVM_GetCPFieldModifiers
-                _JVM_GetCPFieldNameUTF
-                _JVM_GetCPFieldSignatureUTF
-                _JVM_GetCPMethodClassNameUTF
-                _JVM_GetCPMethodModifiers
-                _JVM_GetCPMethodNameUTF
-                _JVM_GetCPMethodSignatureUTF
-                _JVM_GetCallerClass
-                _JVM_GetClassAccessFlags
-                _JVM_GetClassAnnotations
-                _JVM_GetClassCPEntriesCount
-                _JVM_GetClassCPTypes
-                _JVM_GetClassConstantPool
-                _JVM_GetClassContext
-                _JVM_GetClassDeclaredConstructors
-                _JVM_GetClassDeclaredFields
-                _JVM_GetClassDeclaredMethods
-                _JVM_GetClassFieldsCount
-                _JVM_GetClassInterfaces
-                _JVM_GetClassLoader
-                _JVM_GetClassMethodsCount
-                _JVM_GetClassModifiers
-                _JVM_GetClassName
-                _JVM_GetClassNameUTF
-                _JVM_GetClassSignature
-                _JVM_GetClassSigners
-                _JVM_GetClassTypeAnnotations
-                _JVM_GetComponentType
-                _JVM_GetDeclaredClasses
-                _JVM_GetDeclaringClass
-                _JVM_GetEnclosingMethodInfo
-                _JVM_GetFieldAnnotations
-                _JVM_GetFieldIxModifiers
-                _JVM_GetFieldTypeAnnotations
-                _JVM_GetHostName
-                _JVM_GetInheritedAccessControlContext
-                _JVM_GetInterfaceVersion
-                _JVM_GetLastErrorString
-                _JVM_GetManagement
-                _JVM_GetMethodAnnotations
-                _JVM_GetMethodDefaultAnnotationValue
-                _JVM_GetMethodIxArgsSize
-                _JVM_GetMethodIxByteCode
-                _JVM_GetMethodIxByteCodeLength
-                _JVM_GetMethodIxExceptionIndexes
-                _JVM_GetMethodIxExceptionTableEntry
-                _JVM_GetMethodIxExceptionTableLength
-                _JVM_GetMethodIxExceptionsCount
-                _JVM_GetMethodIxLocalsCount
-                _JVM_GetMethodIxMaxStack
-                _JVM_GetMethodIxModifiers
-                _JVM_GetMethodIxNameUTF
-                _JVM_GetMethodIxSignatureUTF
-                _JVM_GetMethodParameterAnnotations
-                _JVM_GetMethodParameters
-                _JVM_GetMethodTypeAnnotations
-                _JVM_GetPrimitiveArrayElement
-                _JVM_GetProtectionDomain
-                _JVM_GetSockName
-                _JVM_GetSockOpt
-                _JVM_GetStackAccessControlContext
-                _JVM_GetStackTraceDepth
-                _JVM_GetStackTraceElement
-                _JVM_GetSystemPackage
-                _JVM_GetSystemPackages
-                _JVM_GetTemporaryDirectory
-                _JVM_GetThreadStateNames
-                _JVM_GetThreadStateValues
-                _JVM_GetVersionInfo
-                _JVM_Halt
-                _JVM_HoldsLock
-                _JVM_IHashCode
-                _JVM_InitAgentProperties
-                _JVM_InitProperties
-                _JVM_InitializeCompiler
-                _JVM_InitializeSocketLibrary
-                _JVM_InternString
-                _JVM_Interrupt
-                _JVM_InvokeMethod
-                _JVM_IsArrayClass
-                _JVM_IsConstructorIx
-                _JVM_IsInterface
-                _JVM_IsInterrupted
-                _JVM_IsNaN
-                _JVM_IsPrimitiveClass
-                _JVM_IsSameClassPackage
-                _JVM_IsSilentCompiler
-                _JVM_IsSupportedJNIVersion
-                _JVM_IsThreadAlive
-                _JVM_IsVMGeneratedMethodIx
-                _JVM_KnownToNotExist
-                _JVM_GetResourceLookupCacheURLs
-                _JVM_GetResourceLookupCache
-                _JVM_LatestUserDefinedLoader
-                _JVM_Listen
-                _JVM_LoadClass0
-                _JVM_LoadLibrary
-                _JVM_Lseek
-                _JVM_MaxObjectInspectionAge
-                _JVM_MaxMemory
-                _JVM_MonitorNotify
-                _JVM_MonitorNotifyAll
-                _JVM_MonitorWait
-                _JVM_NanoTime
-                _JVM_NativePath
-                _JVM_NewArray
-                _JVM_NewInstanceFromConstructor
-                _JVM_NewMultiArray
-                _JVM_OnExit
-                _JVM_Open
-                _JVM_RaiseSignal
-                _JVM_RawMonitorCreate
-                _JVM_RawMonitorDestroy
-                _JVM_RawMonitorEnter
-                _JVM_RawMonitorExit
-                _JVM_Read
-                _JVM_Recv
-                _JVM_RecvFrom
-                _JVM_RegisterSignal
-                _JVM_ReleaseUTF
-                _JVM_ResolveClass
-                _JVM_ResumeThread
-                _JVM_Send
-                _JVM_SendTo
-                _JVM_SetArrayElement
-                _JVM_SetClassSigners
-                _JVM_SetLength
-                _JVM_SetNativeThreadName
-                _JVM_SetPrimitiveArrayElement
-                _JVM_SetSockOpt
-                _JVM_SetThreadPriority
-                _JVM_Sleep
-                _JVM_Socket
-                _JVM_SocketAvailable
-                _JVM_SocketClose
-                _JVM_SocketShutdown
-                _JVM_StartThread
-                _JVM_StopThread
-                _JVM_SuspendThread
-                _JVM_SupportsCX8
-                _JVM_Sync
-                _JVM_Timeout
-                _JVM_TotalMemory
-                _JVM_TraceInstructions
-                _JVM_TraceMethodCalls
-                _JVM_UnloadLibrary
-                _JVM_Write
-                _JVM_Yield
-                _JVM_handle_bsd_signal
+                # JVM
+                JVM_Accept;
+                JVM_ActiveProcessorCount;
+                JVM_AllocateNewArray;
+                JVM_AllocateNewObject;
+                JVM_ArrayCopy;
+                JVM_AssertionStatusDirectives;
+                JVM_Available;
+                JVM_Bind;
+                JVM_ClassDepth;
+                JVM_ClassLoaderDepth;
+                JVM_Clone;
+                JVM_Close;
+                JVM_CX8Field;
+                JVM_CompileClass;
+                JVM_CompileClasses;
+                JVM_CompilerCommand;
+                JVM_Connect;
+                JVM_ConstantPoolGetClassAt;
+                JVM_ConstantPoolGetClassAtIfLoaded;
+                JVM_ConstantPoolGetDoubleAt;
+                JVM_ConstantPoolGetFieldAt;
+                JVM_ConstantPoolGetFieldAtIfLoaded;
+                JVM_ConstantPoolGetFloatAt;
+                JVM_ConstantPoolGetIntAt;
+                JVM_ConstantPoolGetLongAt;
+                JVM_ConstantPoolGetMethodAt;
+                JVM_ConstantPoolGetMethodAtIfLoaded;
+                JVM_ConstantPoolGetMemberRefInfoAt;
+                JVM_ConstantPoolGetSize;
+                JVM_ConstantPoolGetStringAt;
+                JVM_ConstantPoolGetUTF8At;
+                JVM_CountStackFrames;
+                JVM_CurrentClassLoader;
+                JVM_CurrentLoadedClass;
+                JVM_CurrentThread;
+                JVM_CurrentTimeMillis;
+                JVM_DefineClass;
+                JVM_DefineClassWithSource;
+                JVM_DefineClassWithSourceCond;
+                JVM_DesiredAssertionStatus;
+                JVM_DisableCompiler;
+                JVM_DoPrivileged;
+                JVM_DTraceGetVersion;
+                JVM_DTraceActivate;
+                JVM_DTraceIsProbeEnabled;
+                JVM_DTraceIsSupported;
+                JVM_DTraceDispose;
+                JVM_DumpAllStacks;
+                JVM_DumpThreads;
+                JVM_EnableCompiler;
+                JVM_Exit;
+                JVM_FillInStackTrace;
+                JVM_FindClassFromCaller;
+                JVM_FindClassFromClass;
+                JVM_FindClassFromClassLoader;
+                JVM_FindClassFromBootLoader;
+                JVM_FindLibraryEntry;
+                JVM_FindLoadedClass;
+                JVM_FindPrimitiveClass;
+                JVM_FindSignal;
+                JVM_FreeMemory;
+                JVM_GC;
+                JVM_GetAllThreads;
+                JVM_GetArrayElement;
+                JVM_GetArrayLength;
+                JVM_GetCPClassNameUTF;
+                JVM_GetCPFieldClassNameUTF;
+                JVM_GetCPFieldModifiers;
+                JVM_GetCPFieldNameUTF;
+                JVM_GetCPFieldSignatureUTF;
+                JVM_GetCPMethodClassNameUTF;
+                JVM_GetCPMethodModifiers;
+                JVM_GetCPMethodNameUTF;
+                JVM_GetCPMethodSignatureUTF;
+                JVM_GetCallerClass;
+                JVM_GetClassAccessFlags;
+                JVM_GetClassAnnotations;
+                JVM_GetClassCPEntriesCount;
+                JVM_GetClassCPTypes;
+                JVM_GetClassConstantPool;
+                JVM_GetClassContext;
+                JVM_GetClassDeclaredConstructors;
+                JVM_GetClassDeclaredFields;
+                JVM_GetClassDeclaredMethods;
+                JVM_GetClassFieldsCount;
+                JVM_GetClassInterfaces;
+                JVM_GetClassLoader;
+                JVM_GetClassMethodsCount;
+                JVM_GetClassModifiers;
+                JVM_GetClassName;
+                JVM_GetClassNameUTF;
+                JVM_GetClassSignature;
+                JVM_GetClassSigners;
+                JVM_GetClassTypeAnnotations;
+                JVM_GetComponentType;
+                JVM_GetDeclaredClasses;
+                JVM_GetDeclaringClass;
+                JVM_GetEnclosingMethodInfo;
+                JVM_GetFieldAnnotations;
+                JVM_GetFieldIxModifiers;
+                JVM_GetFieldTypeAnnotations;
+                JVM_GetHostName;
+                JVM_GetInheritedAccessControlContext;
+                JVM_GetInterfaceVersion;
+                JVM_GetLastErrorString;
+                JVM_GetManagement;
+                JVM_GetMethodAnnotations;
+                JVM_GetMethodDefaultAnnotationValue;
+                JVM_GetMethodIxArgsSize;
+                JVM_GetMethodIxByteCode;
+                JVM_GetMethodIxByteCodeLength;
+                JVM_GetMethodIxExceptionIndexes;
+                JVM_GetMethodIxExceptionTableEntry;
+                JVM_GetMethodIxExceptionTableLength;
+                JVM_GetMethodIxExceptionsCount;
+                JVM_GetMethodIxLocalsCount;
+                JVM_GetMethodIxMaxStack;
+                JVM_GetMethodIxModifiers;
+                JVM_GetMethodIxNameUTF;
+                JVM_GetMethodIxSignatureUTF;
+                JVM_GetMethodParameterAnnotations;
+                JVM_GetMethodParameters;
+                JVM_GetMethodTypeAnnotations;
+                JVM_GetPrimitiveArrayElement;
+                JVM_GetProtectionDomain;
+                JVM_GetSockName;
+                JVM_GetSockOpt;
+                JVM_GetStackAccessControlContext;
+                JVM_GetStackTraceDepth;
+                JVM_GetStackTraceElement;
+                JVM_GetSystemPackage;
+                JVM_GetSystemPackages;
+                JVM_GetTemporaryDirectory;
+                JVM_GetThreadStateNames;
+                JVM_GetThreadStateValues;
+                JVM_GetVersionInfo;
+                JVM_Halt;
+                JVM_HoldsLock;
+                JVM_IHashCode;
+                JVM_InitAgentProperties;
+                JVM_InitProperties;
+                JVM_InitializeCompiler;
+                JVM_InitializeSocketLibrary;
+                JVM_InternString;
+                JVM_Interrupt;
+                JVM_InvokeMethod;
+                JVM_IsArrayClass;
+                JVM_IsConstructorIx;
+                JVM_IsInterface;
+                JVM_IsInterrupted;
+                JVM_IsNaN;
+                JVM_IsPrimitiveClass;
+                JVM_IsSameClassPackage;
+                JVM_IsSilentCompiler;
+                JVM_IsSupportedJNIVersion;
+                JVM_IsThreadAlive;
+                JVM_IsVMGeneratedMethodIx;
+                JVM_KnownToNotExist;
+                JVM_GetResourceLookupCacheURLs;
+                JVM_GetResourceLookupCache;
+                JVM_LatestUserDefinedLoader;
+                JVM_Listen;
+                JVM_LoadClass0;
+                JVM_LoadLibrary;
+                JVM_Lseek;
+                JVM_MaxObjectInspectionAge;
+                JVM_MaxMemory;
+                JVM_MonitorNotify;
+                JVM_MonitorNotifyAll;
+                JVM_MonitorWait;
+                JVM_NanoTime;
+                JVM_NativePath;
+                JVM_NewArray;
+                JVM_NewInstanceFromConstructor;
+                JVM_NewMultiArray;
+                JVM_OnExit;
+                JVM_Open;
+                JVM_RaiseSignal;
+                JVM_RawMonitorCreate;
+                JVM_RawMonitorDestroy;
+                JVM_RawMonitorEnter;
+                JVM_RawMonitorExit;
+                JVM_Read;
+                JVM_Recv;
+                JVM_RecvFrom;
+                JVM_RegisterSignal;
+                JVM_ReleaseUTF;
+                JVM_ResolveClass;
+                JVM_ResumeThread;
+                JVM_Send;
+                JVM_SendTo;
+                JVM_SetArrayElement;
+                JVM_SetClassSigners;
+                JVM_SetLength;
+                JVM_SetNativeThreadName;
+                JVM_SetPrimitiveArrayElement;
+                JVM_SetSockOpt;
+                JVM_SetThreadPriority;
+                JVM_Sleep;
+                JVM_Socket;
+                JVM_SocketAvailable;
+                JVM_SocketClose;
+                JVM_SocketShutdown;
+                JVM_StartThread;
+                JVM_StopThread;
+                JVM_SuspendThread;
+                JVM_SupportsCX8;
+                JVM_Sync;
+                JVM_Timeout;
+                JVM_TotalMemory;
+                JVM_TraceInstructions;
+                JVM_TraceMethodCalls;
+                JVM_UnloadLibrary;
+                JVM_Write;
+                JVM_Yield;
+                JVM_handle_bsd_signal;
 
                 # miscellaneous functions
-                _jio_fprintf
-                _jio_printf
-                _jio_snprintf
-                _jio_vfprintf
-                _jio_vsnprintf
+                jio_fprintf;
+                jio_printf;
+                jio_snprintf;
+                jio_vfprintf;
+                jio_vsnprintf;
+		fork1;
+                numa_warn;
+                numa_error;
 
                 # This is for Forte Analyzer profiling support.
-                _AsyncGetCallTrace
+                AsyncGetCallTrace;
 
                 # INSERT VTABLE SYMBOLS HERE
 
+        local:
+                *;
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-product.macosx	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,261 @@
+#
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+# Only used for OSX/Darwin builds
+
+# Define public interface.
+                # _JNI
+                _JNI_CreateJavaVM
+                _JNI_GetCreatedJavaVMs
+                _JNI_GetDefaultJavaVMInitArgs
+
+                # _JVM
+                _JVM_Accept
+                _JVM_ActiveProcessorCount
+                _JVM_AllocateNewArray
+                _JVM_AllocateNewObject
+                _JVM_ArrayCopy
+                _JVM_AssertionStatusDirectives
+                _JVM_Available
+                _JVM_Bind
+                _JVM_ClassDepth
+                _JVM_ClassLoaderDepth
+                _JVM_Clone
+                _JVM_Close
+                _JVM_CX8Field
+                _JVM_CompileClass
+                _JVM_CompileClasses
+                _JVM_CompilerCommand
+                _JVM_Connect
+                _JVM_ConstantPoolGetClassAt
+                _JVM_ConstantPoolGetClassAtIfLoaded
+                _JVM_ConstantPoolGetDoubleAt
+                _JVM_ConstantPoolGetFieldAt
+                _JVM_ConstantPoolGetFieldAtIfLoaded
+                _JVM_ConstantPoolGetFloatAt
+                _JVM_ConstantPoolGetIntAt
+                _JVM_ConstantPoolGetLongAt
+                _JVM_ConstantPoolGetMethodAt
+                _JVM_ConstantPoolGetMethodAtIfLoaded
+                _JVM_ConstantPoolGetMemberRefInfoAt
+                _JVM_ConstantPoolGetSize
+                _JVM_ConstantPoolGetStringAt
+                _JVM_ConstantPoolGetUTF8At
+                _JVM_CountStackFrames
+                _JVM_CurrentClassLoader
+                _JVM_CurrentLoadedClass
+                _JVM_CurrentThread
+                _JVM_CurrentTimeMillis
+                _JVM_DefineClass
+                _JVM_DefineClassWithSource
+                _JVM_DefineClassWithSourceCond
+                _JVM_DesiredAssertionStatus
+                _JVM_DisableCompiler
+                _JVM_DoPrivileged
+                _JVM_DTraceGetVersion
+                _JVM_DTraceActivate
+                _JVM_DTraceIsProbeEnabled
+                _JVM_DTraceIsSupported
+                _JVM_DTraceDispose
+                _JVM_DumpAllStacks
+                _JVM_DumpThreads
+                _JVM_EnableCompiler
+                _JVM_Exit
+                _JVM_FillInStackTrace
+                _JVM_FindClassFromCaller
+                _JVM_FindClassFromClass
+                _JVM_FindClassFromClassLoader
+                _JVM_FindClassFromBootLoader
+                _JVM_FindLibraryEntry
+                _JVM_FindLoadedClass
+                _JVM_FindPrimitiveClass
+                _JVM_FindSignal
+                _JVM_FreeMemory
+                _JVM_GC
+                _JVM_GetAllThreads
+                _JVM_GetArrayElement
+                _JVM_GetArrayLength
+                _JVM_GetCPClassNameUTF
+                _JVM_GetCPFieldClassNameUTF
+                _JVM_GetCPFieldModifiers
+                _JVM_GetCPFieldNameUTF
+                _JVM_GetCPFieldSignatureUTF
+                _JVM_GetCPMethodClassNameUTF
+                _JVM_GetCPMethodModifiers
+                _JVM_GetCPMethodNameUTF
+                _JVM_GetCPMethodSignatureUTF
+                _JVM_GetCallerClass
+                _JVM_GetClassAccessFlags
+                _JVM_GetClassAnnotations
+                _JVM_GetClassCPEntriesCount
+                _JVM_GetClassCPTypes
+                _JVM_GetClassConstantPool
+                _JVM_GetClassContext
+                _JVM_GetClassDeclaredConstructors
+                _JVM_GetClassDeclaredFields
+                _JVM_GetClassDeclaredMethods
+                _JVM_GetClassFieldsCount
+                _JVM_GetClassInterfaces
+                _JVM_GetClassLoader
+                _JVM_GetClassMethodsCount
+                _JVM_GetClassModifiers
+                _JVM_GetClassName
+                _JVM_GetClassNameUTF
+                _JVM_GetClassSignature
+                _JVM_GetClassSigners
+                _JVM_GetClassTypeAnnotations
+                _JVM_GetComponentType
+                _JVM_GetDeclaredClasses
+                _JVM_GetDeclaringClass
+                _JVM_GetEnclosingMethodInfo
+                _JVM_GetFieldAnnotations
+                _JVM_GetFieldIxModifiers
+                _JVM_GetFieldTypeAnnotations
+                _JVM_GetHostName
+                _JVM_GetInheritedAccessControlContext
+                _JVM_GetInterfaceVersion
+                _JVM_GetLastErrorString
+                _JVM_GetManagement
+                _JVM_GetMethodAnnotations
+                _JVM_GetMethodDefaultAnnotationValue
+                _JVM_GetMethodIxArgsSize
+                _JVM_GetMethodIxByteCode
+                _JVM_GetMethodIxByteCodeLength
+                _JVM_GetMethodIxExceptionIndexes
+                _JVM_GetMethodIxExceptionTableEntry
+                _JVM_GetMethodIxExceptionTableLength
+                _JVM_GetMethodIxExceptionsCount
+                _JVM_GetMethodIxLocalsCount
+                _JVM_GetMethodIxMaxStack
+                _JVM_GetMethodIxModifiers
+                _JVM_GetMethodIxNameUTF
+                _JVM_GetMethodIxSignatureUTF
+                _JVM_GetMethodParameterAnnotations
+                _JVM_GetMethodParameters
+                _JVM_GetMethodTypeAnnotations
+                _JVM_GetPrimitiveArrayElement
+                _JVM_GetProtectionDomain
+                _JVM_GetSockName
+                _JVM_GetSockOpt
+                _JVM_GetStackAccessControlContext
+                _JVM_GetStackTraceDepth
+                _JVM_GetStackTraceElement
+                _JVM_GetSystemPackage
+                _JVM_GetSystemPackages
+                _JVM_GetTemporaryDirectory
+                _JVM_GetThreadStateNames
+                _JVM_GetThreadStateValues
+                _JVM_GetVersionInfo
+                _JVM_Halt
+                _JVM_HoldsLock
+                _JVM_IHashCode
+                _JVM_InitAgentProperties
+                _JVM_InitProperties
+                _JVM_InitializeCompiler
+                _JVM_InitializeSocketLibrary
+                _JVM_InternString
+                _JVM_Interrupt
+                _JVM_InvokeMethod
+                _JVM_IsArrayClass
+                _JVM_IsConstructorIx
+                _JVM_IsInterface
+                _JVM_IsInterrupted
+                _JVM_IsNaN
+                _JVM_IsPrimitiveClass
+                _JVM_IsSameClassPackage
+                _JVM_IsSilentCompiler
+                _JVM_IsSupportedJNIVersion
+                _JVM_IsThreadAlive
+                _JVM_IsVMGeneratedMethodIx
+                _JVM_KnownToNotExist
+                _JVM_GetResourceLookupCacheURLs
+                _JVM_GetResourceLookupCache
+                _JVM_LatestUserDefinedLoader
+                _JVM_Listen
+                _JVM_LoadClass0
+                _JVM_LoadLibrary
+                _JVM_Lseek
+                _JVM_MaxObjectInspectionAge
+                _JVM_MaxMemory
+                _JVM_MonitorNotify
+                _JVM_MonitorNotifyAll
+                _JVM_MonitorWait
+                _JVM_NanoTime
+                _JVM_NativePath
+                _JVM_NewArray
+                _JVM_NewInstanceFromConstructor
+                _JVM_NewMultiArray
+                _JVM_OnExit
+                _JVM_Open
+                _JVM_RaiseSignal
+                _JVM_RawMonitorCreate
+                _JVM_RawMonitorDestroy
+                _JVM_RawMonitorEnter
+                _JVM_RawMonitorExit
+                _JVM_Read
+                _JVM_Recv
+                _JVM_RecvFrom
+                _JVM_RegisterSignal
+                _JVM_ReleaseUTF
+                _JVM_ResolveClass
+                _JVM_ResumeThread
+                _JVM_Send
+                _JVM_SendTo
+                _JVM_SetArrayElement
+                _JVM_SetClassSigners
+                _JVM_SetLength
+                _JVM_SetNativeThreadName
+                _JVM_SetPrimitiveArrayElement
+                _JVM_SetSockOpt
+                _JVM_SetThreadPriority
+                _JVM_Sleep
+                _JVM_Socket
+                _JVM_SocketAvailable
+                _JVM_SocketClose
+                _JVM_SocketShutdown
+                _JVM_StartThread
+                _JVM_StopThread
+                _JVM_SuspendThread
+                _JVM_SupportsCX8
+                _JVM_Sync
+                _JVM_Timeout
+                _JVM_TotalMemory
+                _JVM_TraceInstructions
+                _JVM_TraceMethodCalls
+                _JVM_UnloadLibrary
+                _JVM_Write
+                _JVM_Yield
+                _JVM_handle_bsd_signal
+
+                # miscellaneous functions
+                _jio_fprintf
+                _jio_printf
+                _jio_snprintf
+                _jio_vfprintf
+                _jio_vsnprintf
+
+                # This is for Forte Analyzer profiling support.
+                _AsyncGetCallTrace
+
+                # INSERT VTABLE SYMBOLS HERE
+
--- ./hotspot/make/bsd/makefiles/optimized.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/optimized.make	Mon Sep 03 11:13:04 2018 -0700
@@ -38,6 +38,9 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug
+ifeq ($(OS_VENDOR), Darwin)
+MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-debug$(MAPSUFX)
 
 VERSION = optimized
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/makefiles/ppc64.make	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,51 @@
+#
+# Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2012, 2013 SAP AG. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+#
+
+# make c code know it is on a 64 bit platform.
+CFLAGS += -D_LP64=1
+
+ifeq ($(origin OPENJDK_TARGET_CPU_ENDIAN),undefined)
+  # This can happen during hotspot standalone build. Set endianness from
+  # uname. We assume build and target machines are the same.
+  OPENJDK_TARGET_CPU_ENDIAN:=$(if $(filter ppc64le,$(shell uname -m)),little,big)
+endif
+
+ifeq ($(filter $(OPENJDK_TARGET_CPU_ENDIAN),big little),)
+  $(error OPENJDK_TARGET_CPU_ENDIAN value should be 'big' or 'little')
+endif
+
+ifeq ($(OPENJDK_TARGET_CPU_ENDIAN),big)
+  # fixes `relocation truncated to fit' error for gcc 4.1.
+  CFLAGS += -mminimal-toc
+
+  # finds use ppc64 instructions, but schedule for power5
+  CFLAGS += -mcpu=powerpc64 -mtune=power5 -minsert-sched-nops=regroup_exact -mno-multiple -mno-string
+else
+  # Little endian machine uses ELFv2 ABI.
+  CFLAGS += -DVM_LITTLE_ENDIAN -DABI_ELFv2
+
+  # Use Power8, this is the first CPU to support PPC64 LE with ELFv2 ABI.
+  CFLAGS += -mcpu=power7 -mtune=power8 -minsert-sched-nops=regroup_exact -mno-multiple -mno-string
+endif
--- ./hotspot/make/bsd/makefiles/product.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/product.make	Mon Sep 03 11:13:04 2018 -0700
@@ -38,7 +38,10 @@
 # to inhibit the effect of the previous line on CFLAGS.
 
 # Linker mapfile
-MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-product
+ifeq ($(OS_VENDOR), Darwin)
+  MAPSUFX = .macosx
+endif
+MAPFILE = $(GAMMADIR)/make/bsd/makefiles/mapfile-vers-product$(MAPSUFX)
 
 SYSDEFS += -DPRODUCT
 VERSION = optimized
--- ./hotspot/make/bsd/makefiles/rules.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/rules.make	Mon Sep 03 11:13:04 2018 -0700
@@ -34,7 +34,7 @@
 CC_COMPILE       = $(CC) $(CXXFLAGS) $(CFLAGS)
 CXX_COMPILE      = $(CXX) $(CXXFLAGS) $(CFLAGS)
 
-AS.S            = $(AS) $(ASFLAGS)
+AS.S            = $(AS) -x assembler-with-cpp $(ASFLAGS)
 
 COMPILE.CC       = $(CC_COMPILE) -c
 GENASM.CC        = $(CC_COMPILE) -S
--- ./hotspot/make/bsd/makefiles/sa.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/sa.make	Mon Sep 03 11:13:04 2018 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -19,7 +19,7 @@
 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 # or visit www.oracle.com if you need additional information or have any
 # questions.
-#  
+#
 #
 
 # This makefile (sa.make) is included from the sa.make in the
@@ -30,34 +30,21 @@
 
 include $(GAMMADIR)/make/bsd/makefiles/rules.make
 
+include $(GAMMADIR)/make/defs.make
+include $(GAMMADIR)/make/altsrc.make
+
 AGENT_DIR = $(GAMMADIR)/agent
 
 include $(GAMMADIR)/make/sa.files
 
 -include $(HS_ALT_MAKE)/bsd/makefiles/sa.make
 
+
 TOPDIR    = $(shell echo `pwd`)
 GENERATED = $(TOPDIR)/../generated
 
-# SA-JDI depends on the standard JDI classes.
-# Default SA_CLASSPATH location:
-DEF_SA_CLASSPATH=$(BOOT_JAVA_HOME)/lib/tools.jar
-ifeq ($(ALT_SA_CLASSPATH),)
-  # no alternate specified; see if default exists
-  SA_CLASSPATH=$(shell test -f $(DEF_SA_CLASSPATH) && echo $(DEF_SA_CLASSPATH))
-  ifeq ($(SA_CLASSPATH),)
-    # the default doesn't exist
-    ifeq ($(OS_VENDOR), Darwin)
-      # A JDK from Apple doesn't have tools.jar; the JDI classes are
-      # are in the regular classes.jar file.
-      APPLE_JAR=$(BOOT_JAVA_HOME)/bundle/Classes/classes.jar
-      SA_CLASSPATH=$(shell test -f $(APPLE_JAR) && echo $(APPLE_JAR))
-    endif
-  endif
-else
-  _JUNK_ := $(shell echo >&2 "INFO: ALT_SA_CLASSPATH=$(ALT_SA_CLASSPATH)")
-  SA_CLASSPATH=$(shell test -f $(ALT_SA_CLASSPATH) && echo $(ALT_SA_CLASSPATH))
-endif
+# tools.jar is needed by the JDI - SA binding
+SA_CLASSPATH = $(BOOT_JAVA_HOME)/lib/tools.jar
 
 # TODO: if it's a modules image, check if SA module is installed.
 MODULELIB_PATH= $(BOOT_JAVA_HOME)/lib/modules
@@ -71,24 +58,22 @@
 SA_PROPERTIES = $(SA_CLASSDIR)/sa.properties
 
 # if $(AGENT_DIR) does not exist, we don't build SA
-# also, we don't build SA on Itanium, PowerPC, ARM or zero.
+# also, we don't build SA on Itanium or zero.
 
-all: 
+all:
 	if [ -d $(AGENT_DIR) -a "$(SRCARCH)" != "ia64" \
-             -a "$(SRCARCH)" != "arm" \
-             -a "$(SRCARCH)" != "ppc" \
              -a "$(SRCARCH)" != "zero" ] ; then \
 	   $(MAKE) -f sa.make $(GENERATED)/sa-jdi.jar; \
 	fi
 
-$(GENERATED)/sa-jdi.jar: $(AGENT_FILES)
-	$(QUIETLY) echo "Making $@"
+$(GENERATED)/sa-jdi.jar:: $(AGENT_FILES)
+	$(QUIETLY) echo $(LOG_INFO) "Making $@"
 	$(QUIETLY) if [ "$(BOOT_JAVA_HOME)" = "" ]; then \
 	  echo "ALT_BOOTDIR, BOOTDIR or JAVA_HOME needs to be defined to build SA"; \
 	  exit 1; \
 	fi
-	$(QUIETLY) if [ ! -f "$(SA_CLASSPATH)" -a ! -d $(MODULELIB_PATH) ] ; then \
-	  echo "Cannot find JDI classes. Use 1.6.0 or later version of JDK."; \
+	$(QUIETLY) if [ ! -f $(SA_CLASSPATH) -a ! -d $(MODULELIB_PATH) ] ; then \
+	  echo "Missing $(SA_CLASSPATH) file. Use 1.6.0 or later version of JDK";\
 	  echo ""; \
 	  exit 1; \
 	fi
@@ -114,19 +99,22 @@
 	$(QUIETLY) $(REMOTE) $(COMPILE.RMIC)  -classpath $(SA_CLASSDIR) -d $(SA_CLASSDIR) sun.jvm.hotspot.debugger.remote.RemoteDebuggerServer
 	$(QUIETLY) echo "$(SA_BUILD_VERSION_PROP)" > $(SA_PROPERTIES)
 	$(QUIETLY) rm -f $(SA_CLASSDIR)/sun/jvm/hotspot/utilities/soql/sa.js
-	$(QUIETLY) cp $(AGENT_SRC_DIR)/sun/jvm/hotspot/utilities/soql/sa.js $(SA_CLASSDIR)/sun/jvm/hotspot/utilities/soql
+	$(QUIETLY) $(CP) $(AGENT_SRC_DIR)/sun/jvm/hotspot/utilities/soql/sa.js $(SA_CLASSDIR)/sun/jvm/hotspot/utilities/soql
 	$(QUIETLY) mkdir -p $(SA_CLASSDIR)/sun/jvm/hotspot/ui/resources
 	$(QUIETLY) rm -f $(SA_CLASSDIR)/sun/jvm/hotspot/ui/resources/*
-	$(QUIETLY) cp $(AGENT_SRC_DIR)/sun/jvm/hotspot/ui/resources/*.png $(SA_CLASSDIR)/sun/jvm/hotspot/ui/resources/
-	$(QUIETLY) cp -r $(AGENT_SRC_DIR)/images/* $(SA_CLASSDIR)/
+	$(QUIETLY) $(CP) $(AGENT_SRC_DIR)/sun/jvm/hotspot/ui/resources/*.png $(SA_CLASSDIR)/sun/jvm/hotspot/ui/resources/
+	$(QUIETLY) $(CP) -r $(AGENT_SRC_DIR)/images/* $(SA_CLASSDIR)/
 	$(QUIETLY) $(REMOTE) $(RUN.JAR) cf $@ -C $(SA_CLASSDIR)/ .
 	$(QUIETLY) $(REMOTE) $(RUN.JAR) uf $@ -C $(AGENT_SRC_DIR) META-INF/services/com.sun.jdi.connect.Connector
 	$(QUIETLY) $(REMOTE) $(RUN.JAVAH) -classpath $(SA_CLASSDIR) -d $(GENERATED) -jni sun.jvm.hotspot.debugger.x86.X86ThreadContext
 	$(QUIETLY) $(REMOTE) $(RUN.JAVAH) -classpath $(SA_CLASSDIR) -d $(GENERATED) -jni sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext
 	$(QUIETLY) $(REMOTE) $(RUN.JAVAH) -classpath $(SA_CLASSDIR) -d $(GENERATED) -jni sun.jvm.hotspot.debugger.sparc.SPARCThreadContext
+	$(QUIETLY) $(REMOTE) $(RUN.JAVAH) -classpath $(SA_CLASSDIR) -d $(GENERATED) -jni sun.jvm.hotspot.debugger.ppc64.PPC64ThreadContext
 	$(QUIETLY) $(REMOTE) $(RUN.JAVAH) -classpath $(SA_CLASSDIR) -d $(GENERATED) -jni sun.jvm.hotspot.asm.Disassembler
 
 clean:
 	rm -rf $(SA_CLASSDIR)
 	rm -rf $(GENERATED)/sa-jdi.jar
 	rm -rf $(AGENT_FILES_LIST)
+
+-include $(HS_ALT_MAKE)/bsd/makefiles/sa-rules.make
--- ./hotspot/make/bsd/makefiles/saproc.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/saproc.make	Mon Sep 03 11:13:04 2018 -0700
@@ -99,10 +99,10 @@
 endif
 
 # if $(AGENT_DIR) does not exist, we don't build SA
-# also, we don't build SA on Itanium, PPC, ARM or zero.
+# also, we don't build SA on Itanium, ARM or zero.
 
 ifneq ($(wildcard $(AGENT_DIR)),)
-ifneq ($(filter-out ia64 arm ppc zero,$(SRCARCH)),)
+ifneq ($(filter-out ia64 arm zero,$(SRCARCH)),)
   BUILDLIBSAPROC = $(LIBSAPROC)
 endif
 endif
@@ -162,16 +162,17 @@
 endif
 
 install_saproc: $(BUILDLIBSAPROC)
-	@echo "Copying $(LIBSAPROC) to $(DEST_SAPROC)"
+	$(QUIETLY) if [ -e $(LIBSAPROC) ] ; then             \
+	  echo "Copying $(LIBSAPROC) to $(DEST_SAPROC)";     \
 ifeq ($(OS_VENDOR), Darwin)
-	$(QUIETLY) test -d $(LIBSAPROC_DEBUGINFO) && \
-	    cp -f -r $(LIBSAPROC_DEBUGINFO) $(DEST_SAPROC_DEBUGINFO)
+	$test -d $(LIBSAPROC_DEBUGINFO) && 			\
+	    cp -f -r $(LIBSAPROC_DEBUGINFO) $(DEST_SAPROC_DEBUGINFO); \
 else
-	$(QUIETLY) test -f $(LIBSAPROC_DEBUGINFO) && \
-	    cp -f $(LIBSAPROC_DEBUGINFO) $(DEST_SAPROC_DEBUGINFO)
+	 test -f $(LIBSAPROC_DEBUGINFO) && 		\
+	    cp -f $(LIBSAPROC_DEBUGINFO) $(DEST_SAPROC_DEBUGINFO);   \
 endif
-	$(QUIETLY) test -f $(LIBSAPROC_DIZ) && \
-	    cp -f $(LIBSAPROC_DIZ) $(DEST_SAPROC_DIZ)
-	$(QUIETLY) cp -f $(LIBSAPROC) $(DEST_SAPROC) && echo "Done"
+	 test -f $(LIBSAPROC_DIZ) && 				\
+	    cp -f $(LIBSAPROC_DIZ) $(DEST_SAPROC_DIZ); \
+	 cp -f $(LIBSAPROC) $(DEST_SAPROC) && echo "Done"
 
 .PHONY: install_saproc
--- ./hotspot/make/bsd/makefiles/vm.make	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/bsd/makefiles/vm.make	Mon Sep 03 11:13:04 2018 -0700
@@ -107,7 +107,7 @@
 # File specific flags
 CXXFLAGS += $(CXXFLAGS/BYFILE)
 
-ifdef DEFAULT_LIBPATH
+ifneq ($(DEFAULT_LIBPATH),)
 CXXFLAGS += -DDEFAULT_LIBPATH="\"$(DEFAULT_LIBPATH)\""
 endif
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/make/bsd/platform_ppc64	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,17 @@
+os_family = bsd
+
+arch = ppc
+
+arch_model = ppc_64
+
+os_arch = bsd_ppc
+
+os_arch_model = bsd_ppc_64
+
+lib_arch = ppc64
+
+compiler = gcc
+
+gnu_dis_arch = ppc64
+
+sysdefs = -DBSD -D_ALLBSD_SOURCE -D_GNU_SOURCE -DPPC64
--- ./hotspot/make/sa.files	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/make/sa.files	Mon Sep 03 11:13:04 2018 -0700
@@ -45,6 +45,7 @@
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/amd64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/ppc64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/basic/*.java \
@@ -55,12 +56,15 @@
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/linux/sparc/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/posix/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/posix/elf/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/ppc64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/proc/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/proc/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/proc/ppc64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/proc/sparc/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/proc/x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/remote/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/remote/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/remote/ppc64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/remote/sparc/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/remote/x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/sparc/*.java \
@@ -85,6 +89,7 @@
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/amd64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_ppc64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/linux/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/linux_amd64/*.java \
@@ -96,6 +101,7 @@
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/solaris_x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/sparc/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/x86/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/ppc64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/tools/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/tools/jcore/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/tools/soql/*.java \
--- ./hotspot/src/cpu/ppc/vm/bytes_ppc.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/ppc/vm/bytes_ppc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -277,5 +277,9 @@
 #if defined(TARGET_OS_ARCH_linux_ppc)
 #include "bytes_linux_ppc.inline.hpp"
 #endif
+#if defined(TARGET_OS_ARCH_bsd_ppc)
+#include "bytes_bsd_ppc.inline.hpp"
+#endif
+
 
 #endif // CPU_PPC_VM_BYTES_PPC_HPP
--- ./hotspot/src/cpu/ppc/vm/interpreter_ppc.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/ppc/vm/interpreter_ppc.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -307,6 +307,8 @@
   // Although AIX runs on big endian CPU, float is in most significant
   // word of an argument slot.
   __ stfs(floatSlot, 0, arg_c);
+#elif defined(BSD)
+  __ stfs(floatSlot, 4, arg_c);
 #else
 #error "unknown OS"
 #endif
--- ./hotspot/src/cpu/ppc/vm/sharedRuntime_ppc.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/ppc/vm/sharedRuntime_ppc.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -780,6 +780,8 @@
       // Although AIX runs on big endian CPU, float is in the most
       // significant word of an argument slot.
 #define FLOAT_WORD_OFFSET_IN_SLOT 0
+#elif defined(BSD)
+#define FLOAT_WORD_OFFSET_IN_SLOT 1
 #else
 #error "unknown OS"
 #endif
--- ./hotspot/src/cpu/x86/vm/jni_x86.h	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/x86/vm/jni_x86.h	Mon Sep 03 11:13:04 2018 -0700
@@ -34,7 +34,7 @@
 #ifndef __has_attribute
   #define __has_attribute(x) 0
 #endif
-#if (defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2))) || __has_attribute(visibility)
+#if (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2)))) || __has_attribute(visibility)
   #define JNIEXPORT     __attribute__((visibility("default")))
   #define JNIIMPORT     __attribute__((visibility("default")))
 #else
--- ./hotspot/src/cpu/x86/vm/sharedRuntime_x86_32.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/x86/vm/sharedRuntime_x86_32.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -2266,7 +2266,7 @@
   if (!is_critical_native) {
     // reset handle block
     __ movptr(rcx, Address(thread, JavaThread::active_handles_offset()));
-    __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);
+    __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
 
     // Any exception pending?
     __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
--- ./hotspot/src/cpu/x86/vm/sharedRuntime_x86_64.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/x86/vm/sharedRuntime_x86_64.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -23,9 +23,12 @@
  */
 
 #include "precompiled.hpp"
-#ifndef _WINDOWS
+#if !defined(_WINDOWS) && !defined(_ALLBSD_SOURCE)
 #include "alloca.h"
 #endif
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#endif
 #include "asm/macroAssembler.hpp"
 #include "asm/macroAssembler.inline.hpp"
 #include "code/debugInfoRec.hpp"
--- ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_32.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_32.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -1293,7 +1293,7 @@
 
   // reset handle block
   __ movptr(t, Address(thread, JavaThread::active_handles_offset()));
-  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);
+  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
 
   // If result was an oop then unbox and save it in the frame
   { Label L;
--- ./hotspot/src/cpu/x86/vm/x86_32.ad	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/cpu/x86/vm/x86_32.ad	Mon Sep 03 11:13:04 2018 -0700
@@ -1250,6 +1250,7 @@
 
 
   Unimplemented();
+  return 0;
 }
 
 #ifndef PRODUCT
--- ./hotspot/src/os/aix/vm/os_aix.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/aix/vm/os_aix.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -5236,6 +5236,10 @@
     return 0;
   }
 
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
+
   return strlen(buffer);
 }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os/bsd/vm/decoder_bsd.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef __APPLE__
+#include "prims/jvm.h"
+#include "utilities/decoder_elf.hpp"
+
+#include <cxxabi.h>
+
+bool ElfDecoder::demangle(const char* symbol, char *buf, int buflen) {
+  int   status;
+  char* result;
+  size_t size = (size_t)buflen;
+
+#ifdef PPC64
+  // On PPC64 ElfDecoder::decode() may return a dot (.) prefixed name
+  // (see elfFuncDescTable.hpp for details)
+  if (symbol && *symbol == '.') symbol += 1;
+#endif
+
+  // Don't pass buf to __cxa_demangle. In case of the 'buf' is too small,
+  // __cxa_demangle will call system "realloc" for additional memory, which
+  // may use different malloc/realloc mechanism that allocates 'buf'.
+  if ((result = abi::__cxa_demangle(symbol, NULL, NULL, &status)) != NULL) {
+    jio_snprintf(buf, buflen, "%s", result);
+      // call c library's free
+      ::free(result);
+      return true;
+  }
+  return false;
+}
+#endif
--- ./hotspot/src/os/bsd/vm/jsig.c	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/jsig.c	Mon Sep 03 11:13:04 2018 -0700
@@ -165,9 +165,8 @@
 }
 
 sa_handler_t sigset(int sig, sa_handler_t disp) {
-  printf("sigset() is not supported by BSD");
-  exit(0);
- }
+  return set_signal(sig, disp, true);
+}
 
 static int call_os_sigaction(int sig, const struct sigaction  *act,
                              struct sigaction *oact) {
--- ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -50,6 +50,7 @@
     case INTERRUPT_SIGNAL:
     case SIGFPE:
     case SIGILL:
+    case SIGBUS:
     case SIGSEGV:
 
     /* The following signal is used by the VM to dump thread stacks unless
@@ -110,71 +111,29 @@
 JVM_END
 
 /*
-  All the defined signal names for Bsd.
+  All the defined signal names for BSD are defined by sys_signame[].
 
   NOTE that not all of these names are accepted by our Java implementation
 
   Via an existing claim by the VM, sigaction restrictions, or
   the "rules of Unix" some of these names will be rejected at runtime.
   For example the VM sets up to handle USR1, sigaction returns EINVAL for
-  STOP, and Bsd simply doesn't allow catching of KILL.
+  STOP, and BSD simply doesn't allow catching of KILL.
 
   Here are the names currently accepted by a user of sun.misc.Signal with
   1.4.1 (ignoring potential interaction with use of chaining, etc):
 
-    HUP, INT, TRAP, ABRT, IOT, BUS, USR2, PIPE, ALRM, TERM, STKFLT,
-    CLD, CHLD, CONT, TSTP, TTIN, TTOU, URG, XCPU, XFSZ, VTALRM, PROF,
-    WINCH, POLL, IO, PWR, SYS
-
+      HUP, INT, TRAP, ABRT, EMT, SYS, PIPE, ALRM, TERM, URG, TSTP, CONT,
+      CHLD, TTIN, TTOU, IO, XCPU, XFSZ, VTALRM, PROF, WINCH, INFO, USR2
 */
 
-struct siglabel {
-  const char *name;
-  int   number;
-};
-
-struct siglabel siglabels[] = {
-  /* derived from /usr/include/bits/signum.h on RH7.2 */
-   "HUP",       SIGHUP,         /* Hangup (POSIX).  */
-  "INT",        SIGINT,         /* Interrupt (ANSI).  */
-  "QUIT",       SIGQUIT,        /* Quit (POSIX).  */
-  "ILL",        SIGILL,         /* Illegal instruction (ANSI).  */
-  "TRAP",       SIGTRAP,        /* Trace trap (POSIX).  */
-  "ABRT",       SIGABRT,        /* Abort (ANSI).  */
-  "EMT",        SIGEMT,         /* EMT trap  */
-  "FPE",        SIGFPE,         /* Floating-point exception (ANSI).  */
-  "KILL",       SIGKILL,        /* Kill, unblockable (POSIX).  */
-  "BUS",        SIGBUS,         /* BUS error (4.2 BSD).  */
-  "SEGV",       SIGSEGV,        /* Segmentation violation (ANSI).  */
-  "SYS",        SIGSYS,         /* Bad system call. Only on some Bsden! */
-  "PIPE",       SIGPIPE,        /* Broken pipe (POSIX).  */
-  "ALRM",       SIGALRM,        /* Alarm clock (POSIX).  */
-  "TERM",       SIGTERM,        /* Termination (ANSI).  */
-  "URG",        SIGURG,         /* Urgent condition on socket (4.2 BSD).  */
-  "STOP",       SIGSTOP,        /* Stop, unblockable (POSIX).  */
-  "TSTP",       SIGTSTP,        /* Keyboard stop (POSIX).  */
-  "CONT",       SIGCONT,        /* Continue (POSIX).  */
-  "CHLD",       SIGCHLD,        /* Child status has changed (POSIX).  */
-  "TTIN",       SIGTTIN,        /* Background read from tty (POSIX).  */
-  "TTOU",       SIGTTOU,        /* Background write to tty (POSIX).  */
-  "IO",         SIGIO,          /* I/O now possible (4.2 BSD).  */
-  "XCPU",       SIGXCPU,        /* CPU limit exceeded (4.2 BSD).  */
-  "XFSZ",       SIGXFSZ,        /* File size limit exceeded (4.2 BSD).  */
-  "VTALRM",     SIGVTALRM,      /* Virtual alarm clock (4.2 BSD).  */
-  "PROF",       SIGPROF,        /* Profiling alarm clock (4.2 BSD).  */
-  "WINCH",      SIGWINCH,       /* Window size change (4.3 BSD, Sun).  */
-  "INFO",       SIGINFO,        /* Information request.  */
-  "USR1",       SIGUSR1,        /* User-defined signal 1 (POSIX).  */
-  "USR2",       SIGUSR2         /* User-defined signal 2 (POSIX).  */
-  };
-
 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
 
   /* find and return the named signal's number */
 
-  for(uint i=0; i<ARRAY_SIZE(siglabels); i++)
-    if(!strcmp(name, siglabels[i].name))
-      return siglabels[i].number;
+  for (int i = 1; i < NSIG; i++)
+    if (strcasecmp(name, sys_signame[i]) == 0)
+      return i;
 
   return -1;
 
@@ -182,11 +141,14 @@
 
 // used by os::exception_name()
 extern bool signal_name(int signo, char* buf, size_t len) {
-  for(uint i = 0; i < ARRAY_SIZE(siglabels); i++) {
-    if (signo == siglabels[i].number) {
-      jio_snprintf(buf, len, "SIG%s", siglabels[i].name);
-      return true;
-    }
-  }
-  return false;
+  if (signo <= 0 || signo >= NSIG)
+    return false;
+  char signame[8];
+  const char *s = sys_signame[signo];
+  uint i;
+  for (i = 0; i < sizeof(signame) - 1 && s[i] != '\0'; i++)
+    signame[i] = toupper(s[i]);
+  signame[i] = '\0';
+  jio_snprintf(buf, len, "SIG%s", signame);
+  return true;
 }
--- ./hotspot/src/os/bsd/vm/jvm_bsd.h	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.h	Mon Sep 03 11:13:04 2018 -0700
@@ -112,20 +112,6 @@
 #define SHUTDOWN2_SIGNAL SIGINT
 #define SHUTDOWN3_SIGNAL SIGTERM
 
-#ifndef SIGRTMIN
-#ifdef __OpenBSD__
-#define SIGRTMIN        1
-#else
-#define SIGRTMIN        33
-#endif
-#endif
-#ifndef SIGRTMAX
-#ifdef __OpenBSD__
-#define SIGRTMAX        31
-#else
-#define SIGRTMAX        63
-#endif
-#endif
 #endif /* JVM_MD_H */
 
 #endif // OS_BSD_VM_JVM_BSD_H
--- ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -30,7 +30,7 @@
 
 void OSThread::pd_initialize() {
   assert(this != NULL, "check");
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
   _thread_id        = 0;
 #else
   _thread_id        = NULL;
--- ./hotspot/src/os/bsd/vm/os_bsd.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -97,16 +97,31 @@
 # include <sys/shm.h>
 #ifndef __APPLE__
 # include <link.h>
+# include <stdlib.h>
 #endif
 # include <stdint.h>
 # include <inttypes.h>
 # include <sys/ioctl.h>
 # include <sys/syscall.h>
 
+#ifdef __FreeBSD__
+# if __FreeBSD_version > 900030
+#  include <pthread_np.h>
+# else
+#  include <sys/thr.h>
+# endif
+# include <sys/cpuset.h>
+# include <vm/vm_param.h>
+#endif
+
 #if defined(__FreeBSD__) || defined(__NetBSD__)
 # include <elf.h>
 #endif
 
+#ifdef __NetBSD__
+#include <lwp.h>
+#endif
+
 #ifdef __APPLE__
 # include <mach/mach.h> // semaphore_* API
 # include <mach-o/dyld.h>
@@ -136,9 +151,11 @@
 volatile uint64_t         os::Bsd::_max_abstime   = 0;
 #else
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+int (*os::Bsd::_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 #endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
+pthread_condattr_t os::Bsd::_condattr[1];
 
 static jlong initial_time_count=0;
 
@@ -169,6 +186,27 @@
 
 // available here means free
 julong os::Bsd::available_memory() {
+#ifdef __FreeBSD__
+  static const char *vm_stats[] = {
+    "vm.stats.vm.v_free_count",
+    "vm.stats.vm.v_cache_count",
+    "vm.stats.vm.v_inactive_count"
+  };
+  size_t size;
+  julong free_pages;
+  u_int i, npages;
+
+  for (i = 0, free_pages = 0; i < sizeof(vm_stats) / sizeof(vm_stats[0]); i++) {
+    size = sizeof(npages);
+    if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1) {
+      free_pages = 0;
+      break;
+    }
+    free_pages += npages;
+  }
+  if (free_pages > 0)
+    return free_pages * os::vm_page_size();
+#endif
   uint64_t available = physical_memory() >> 2;
 #ifdef __APPLE__
   mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;
@@ -208,7 +246,7 @@
   static bool init = false;
   static bool privileges = false;
   if (!init) {
-    privileges = (getuid() != geteuid()) || (getgid() != getegid());
+    privileges = issetugid();
     init = true;
   }
   return privileges;
@@ -229,6 +267,8 @@
 static char cpu_arch[] = "arm";
 #elif defined(PPC32)
 static char cpu_arch[] = "ppc";
+#elif defined(PPC64)
+static char cpu_arch[] = "ppc64";
 #elif defined(SPARC)
 #  ifdef _LP64
 static char cpu_arch[] = "sparcv9";
@@ -272,6 +312,8 @@
 
 #if defined (HW_MEMSIZE) // Apple
   mib[1] = HW_MEMSIZE;
+#elif defined(HW_PHYSMEM64) // OpenBSD & NetBSD
+  mib[1] = HW_PHYSMEM64;
 #elif defined(HW_PHYSMEM) // Most of BSD
   mib[1] = HW_PHYSMEM;
 #elif defined(HW_REALMEM) // Old FreeBSD
@@ -411,12 +453,21 @@
     const char *v = ::getenv("LD_LIBRARY_PATH");
     const char *v_colon = ":";
     if (v == NULL) { v = ""; v_colon = ""; }
+#ifdef __APPLE__
     // That's +1 for the colon and +1 for the trailing '\0'.
     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,
                                                      strlen(v) + 1 +
                                                      sizeof(SYS_EXT_DIR) + sizeof("/lib/") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,
                                                      mtInternal);
     sprintf(ld_library_path, "%s%s" SYS_EXT_DIR "/lib/%s:" DEFAULT_LIBPATH, v, v_colon, cpu_arch);
+#else
+    // That's +1 for the colon and +1 for the trailing '\0'.
+    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,
+                                                     strlen(v) + 1 +
+                                                     sizeof(PACKAGE_PATH) + sizeof("/lib") + 1,
+                                                     mtInternal);
+    sprintf(ld_library_path, "%s%s" PACKAGE_PATH "/lib", v, v_colon);
+#endif
     Arguments::set_library_path(ld_library_path);
     FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);
   }
@@ -591,6 +642,9 @@
   sigaddset(&unblocked_sigs, SIGSEGV);
   sigaddset(&unblocked_sigs, SIGBUS);
   sigaddset(&unblocked_sigs, SIGFPE);
+#if defined(PPC64)
+  sigaddset(&unblocked_sigs, SIGTRAP);
+#endif
   sigaddset(&unblocked_sigs, SR_signum);
 
   if (!ReduceSignalUsage) {
@@ -983,6 +1037,13 @@
 bool os::vtime_enabled()  { return false; }
 
 double os::elapsedVTime() {
+#ifdef RUSAGE_THREAD
+  struct rusage usage;
+  int retval = getrusage(RUSAGE_THREAD, &usage);
+  if (retval == 0) {
+    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
+  }
+#endif
   // better than nothing, but not much
   return elapsedTime();
 }
@@ -1008,11 +1069,15 @@
 void os::Bsd::clock_init() {
   struct timespec res;
   struct timespec tp;
+  _getcpuclockid = (int (*)(pthread_t, clockid_t *))dlsym(RTLD_DEFAULT, "pthread_getcpuclockid");
   if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
       ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
     // yes, monotonic clock is supported
     _clock_gettime = ::clock_gettime;
+    return;
   }
+  warning("No monotonic clock was available - timed services may " \
+          "be adversely affected if the time-of-day clock changes");
 }
 #endif
 
@@ -1048,7 +1113,7 @@
 jlong os::javaTimeNanos() {
   if (Bsd::supports_monotonic_clock()) {
     struct timespec tp;
-    int status = Bsd::_clock_gettime(CLOCK_MONOTONIC, &tp);
+    int status = ::clock_gettime(CLOCK_MONOTONIC, &tp);
     assert(status == 0, "gettime error");
     jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);
     return result;
@@ -1190,35 +1255,38 @@
 pid_t os::Bsd::gettid() {
   int retval = -1;
 
-#ifdef __APPLE__ //XNU kernel
+#if defined(__APPLE__) //XNU kernel
   // despite the fact mach port is actually not a thread id use it
   // instead of syscall(SYS_thread_selfid) as it certainly fits to u4
   retval = ::pthread_mach_thread_np(::pthread_self());
   guarantee(retval != 0, "just checking");
   return retval;
 
+#elif defined(__FreeBSD__)
+#if __FreeBSD_version > 900030
+  return ::pthread_getthreadid_np();
 #else
-  #ifdef __FreeBSD__
-  retval = syscall(SYS_thr_self);
-  #else
-    #ifdef __OpenBSD__
+  long tid;
+  thr_self(&tid);
+  return (pid_t)tid;
+#endif
+#elif defined(__OpenBSD__)
   retval = syscall(SYS_getthrid);
-    #else
-      #ifdef __NetBSD__
-  retval = (pid_t) syscall(SYS__lwp_self);
-      #endif
-    #endif
-  #endif
+#elif defined(__NetBSD__)
+  retval = (pid_t) _lwp_self();
 #endif
 
   if (retval == -1) {
     return getpid();
   }
+  return retval;
 }
 
 intx os::current_thread_id() {
-#ifdef __APPLE__
+#if defined(__APPLE__)
   return (intx)::pthread_mach_thread_np(::pthread_self());
+#elif defined(__FreeBSD__)
+  return os::Bsd::gettid();
 #else
   return (intx)::pthread_self();
 #endif
@@ -1691,14 +1759,14 @@
 }
 
 void os::print_os_info_brief(outputStream* st) {
-  st->print("Bsd");
+  st->print_cr("BSD");
 
   os::Posix::print_uname_info(st);
 }
 
 void os::print_os_info(outputStream* st) {
   st->print("OS:");
-  st->print("Bsd");
+  st->print_cr("BSD");
 
   os::Posix::print_uname_info(st);
 
@@ -1711,6 +1779,29 @@
   // Nothing to do for now.
 }
 
+#ifdef __FreeBSD__
+static void get_swap_info(int *total_pages, int *used_pages) {
+  struct xswdev xsw;
+  size_t mibsize, size;
+  int mib[16];
+  int n, total = 0, used = 0;
+
+  mibsize = sizeof(mib) / sizeof(mib[0]);
+  if (sysctlnametomib("vm.swap_info", mib, &mibsize) != -1) {
+    for (n = 0; ; n++) {
+      mib[mibsize] = n;
+      size = sizeof(xsw);
+      if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+        break;
+      total += xsw.xsw_nblks;
+      used += xsw.xsw_used;
+    }
+  }
+  *total_pages = total;
+  *used_pages = used;
+}
+#endif
+
 void os::print_memory_info(outputStream* st) {
 
   st->print("Memory:");
@@ -1720,11 +1811,14 @@
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
-  st->cr();
-
-  // meminfo
-  st->print("\n/proc/meminfo:\n");
-  _print_ascii_file("/proc/meminfo", st);
+#ifdef __FreeBSD__
+  int total, used;
+  get_swap_info(&total, &used);
+  st->print(", swap " UINT64_FORMAT "k",
+            (total * os::vm_page_size()) >> 10);
+  st->print("(" UINT64_FORMAT "k free)",
+            ((total - used) * os::vm_page_size()) >> 10);
+#endif
   st->cr();
 }
 
@@ -1763,6 +1857,9 @@
   print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);
   print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);
   print_signal_handler(st, BREAK_SIGNAL, buf, buflen);
+#if defined(PPC64)
+  print_signal_handler(st, SIGTRAP, buf, buflen);
+#endif
 }
 
 static char saved_jvm_path[MAXPATHLEN] = {0};
@@ -1960,7 +2057,7 @@
     os_semaphore_t _semaphore;
 };
 
-Semaphore::Semaphore() : _semaphore(0) {
+Semaphore::Semaphore() {
   SEM_INIT(_semaphore, 0);
 }
 
@@ -2148,7 +2245,7 @@
       if (::write(fd, "", 1) == 1) {
         mmap(base, size,
              PROT_READ|PROT_WRITE|PROT_EXEC,
-             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
+             MAP_PRIVATE|MAP_FIXED, fd, 0);
       }
     }
     ::close(fd);
@@ -2258,7 +2355,7 @@
   return ::mprotect(addr, size, PROT_NONE) == 0;
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
-                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
+                MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
 #endif
 }
@@ -2285,7 +2382,7 @@
   char * addr;
   int flags;
 
-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+  flags = MAP_PRIVATE | MAP_ANONYMOUS;
   if (fixed) {
     assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, "unaligned address");
     flags |= MAP_FIXED;
@@ -2774,6 +2871,7 @@
   return OS_OK;
 #elif defined(__FreeBSD__)
   int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+  return (ret == 0) ? OS_OK : OS_ERR;
 #elif defined(__APPLE__) || defined(__NetBSD__)
   struct sched_param sp;
   int policy;
@@ -3320,6 +3418,9 @@
     set_signal_handler(SIGBUS, true);
     set_signal_handler(SIGILL, true);
     set_signal_handler(SIGFPE, true);
+#if defined(PPC64)
+    set_signal_handler(SIGTRAP, true);
+#endif
     set_signal_handler(SIGXFSZ, true);
 
 #if defined(__APPLE__)
@@ -3368,18 +3469,6 @@
   }
 }
 
-
-/////
-// glibc on Bsd platform uses non-documented flag
-// to indicate, that some special sort of signal
-// trampoline is used.
-// We will never set this flag, and we should
-// ignore this flag in our diagnostic
-#ifdef SIGNIFICANT_SIGNAL_MASK
-#undef SIGNIFICANT_SIGNAL_MASK
-#endif
-#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
-
 static const char* get_signal_handler_name(address handler,
                                            char* buf, int buflen) {
   int offset;
@@ -3403,9 +3492,6 @@
 
   sigaction(sig, NULL, &sa);
 
-  // See comment for SIGNIFICANT_SIGNAL_MASK define
-  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;
-
   st->print("%s: ", os::exception_name(sig, buf, buflen));
 
   address handler = (sa.sa_flags & SA_SIGINFO)
@@ -3427,7 +3513,7 @@
   // May be, handler was resetted by VMError?
   if(rh != NULL) {
     handler = rh;
-    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;
+    sa.sa_flags = VMError::get_resetted_sigflags(sig);
   }
 
   st->print(", sa_flags=");
@@ -3469,6 +3555,9 @@
   DO_SIGNAL_CHECK(SIGBUS);
   DO_SIGNAL_CHECK(SIGPIPE);
   DO_SIGNAL_CHECK(SIGXFSZ);
+#if defined(PPC64)
+  DO_SIGNAL_CHECK(SIGTRAP);
+#endif
 
 
   // ReduceSignalUsage allows the user to override these handlers
@@ -3503,8 +3592,6 @@
   os_sigaction(sig, (struct sigaction*)NULL, &act);
 
 
-  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;
-
   address thisHandler = (act.sa_flags & SA_SIGINFO)
     ? CAST_FROM_FN_PTR(address, act.sa_sigaction)
     : CAST_FROM_FN_PTR(address, act.sa_handler) ;
@@ -3569,6 +3656,14 @@
 
 extern bool signal_name(int signo, char* buf, size_t len);
 
+#ifndef SIGRTMAX
+#ifdef __OpenBSD__
+#define SIGRTMAX        31
+#else
+#define SIGRTMAX        63
+#endif
+#endif
+
 const char* os::exception_name(int exception_code, char* buf, size_t size) {
   if (0 < exception_code && exception_code <= SIGRTMAX) {
     // signal
@@ -3617,6 +3712,25 @@
   Bsd::clock_init();
   initial_time_count = javaTimeNanos();
 
+  // pthread_condattr initialization for monotonic clock
+  int status;
+  pthread_condattr_t* _condattr = os::Bsd::condAttr();
+  if ((status = pthread_condattr_init(_condattr)) != 0) {
+    fatal(err_msg("pthread_condattr_init: %s", strerror(status)));
+  }
+  // Only set the clock if CLOCK_MONOTONIC is available
+  if (Bsd::supports_monotonic_clock()) {
+    if ((status = pthread_condattr_setclock(_condattr, CLOCK_MONOTONIC)) != 0) {
+      if (status == EINVAL) {
+        warning("Unable to use monotonic clock with relative timed-waits" \
+                " - changes to the time-of-day clock may have adverse affects");
+      } else {
+        fatal(err_msg("pthread_condattr_setclock: %s", strerror(status)));
+      }
+    }
+  }
+  // else it defaults to CLOCK_REALTIME
+
 #ifdef __APPLE__
   // XXXDARWIN
   // Work around the unaligned VM callbacks in hotspot's
@@ -3765,6 +3879,19 @@
 };
 
 int os::active_processor_count() {
+#ifdef __FreeBSD__
+  int online_cpus = 0;
+  cpuset_t mask;
+  if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(mask),
+      &mask) == 0)
+    for (u_int i = 0; i < sizeof(mask) / sizeof(long); i++)
+      online_cpus += __builtin_popcountl(((long *)&mask)[i]);
+  if (online_cpus > 0 && online_cpus <= _processor_count)
+    return online_cpus;
+  online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
+  if (online_cpus >= 1)
+    return online_cpus;
+#endif
   return _processor_count;
 }
 
@@ -3976,7 +4103,10 @@
   }
   int fd;
   int o_delete = (oflag & O_DELETE);
-  oflag = oflag & ~O_DELETE;
+  oflag &= ~O_DELETE;
+#ifdef O_CLOEXEC
+  oflag |= O_CLOEXEC;
+#endif
 
   fd = ::open(path, oflag, mode);
   if (fd == -1) return -1;
@@ -4021,7 +4151,7 @@
      * 4843136: (process) pipe file descriptor from Runtime.exec not being closed
      * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9
      */
-#ifdef FD_CLOEXEC
+#if !defined(O_CLOEXEC) && defined(FD_CLOEXEC)
     {
         int flags = ::fcntl(fd, F_GETFD);
         if (flags != -1)
@@ -4161,8 +4291,9 @@
 #ifdef __APPLE__
   return os::thread_cpu_time(Thread::current(), true /* user + sys */);
 #else
-  Unimplemented();
-  return 0;
+  if (Bsd::_getcpuclockid != NULL)
+    return os::thread_cpu_time(Thread::current(), true /* user + sys */);
+  return -1;
 #endif
 }
 
@@ -4170,8 +4301,9 @@
 #ifdef __APPLE__
   return os::thread_cpu_time(thread, true /* user + sys */);
 #else
-  Unimplemented();
-  return 0;
+  if (Bsd::_getcpuclockid != NULL)
+    return os::thread_cpu_time(thread, true /* user + sys */);
+  return -1;
 #endif
 }
 
@@ -4179,8 +4311,9 @@
 #ifdef __APPLE__
   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
 #else
-  Unimplemented();
-  return 0;
+  if (Bsd::_getcpuclockid != NULL)
+    return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
+  return -1;
 #endif
 }
 
@@ -4205,8 +4338,41 @@
     return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
   }
 #else
-  Unimplemented();
-  return 0;
+  if (user_sys_cpu_time && Bsd::_getcpuclockid != NULL) {
+    struct timespec tp;
+    clockid_t clockid;
+    int ret;
+
+    /*
+     * XXX This is essentially a copy of the Linux implementation,
+     *     but with fewer indirections.
+     */
+    ret = Bsd::_getcpuclockid(thread->osthread()->pthread_id(), &clockid);
+    if (ret != 0)
+      return -1;
+    /* NB: _clock_gettime only needs to be valid for CLOCK_MONOTONIC. */
+    ret = ::clock_gettime(clockid, &tp);
+    if (ret != 0)
+      return -1;
+    return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;
+  }
+#ifdef RUSAGE_THREAD
+  if (thread == Thread::current()) {
+    struct rusage usage;
+    jlong nanos;
+
+    if (getrusage(RUSAGE_THREAD, &usage) != 0)
+      return -1;
+    nanos = (jlong)usage.ru_utime.tv_sec * NANOSECS_PER_SEC;
+    nanos += (jlong)usage.ru_utime.tv_usec * 1000;
+    if (user_sys_cpu_time) {
+      nanos += (jlong)usage.ru_stime.tv_sec * NANOSECS_PER_SEC;
+      nanos += (jlong)usage.ru_stime.tv_usec * 1000;
+    }
+    return nanos;
+  }
+#endif
+  return -1;
 #endif
 }
 
@@ -4229,7 +4395,7 @@
 #ifdef __APPLE__
   return true;
 #else
-  return false;
+  return (Bsd::_getcpuclockid != NULL);
 #endif
 }
 
@@ -4327,21 +4493,36 @@
 
 static struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
-  struct timeval now;
-  int status = gettimeofday(&now, NULL);
-  assert(status == 0, "gettimeofday");
+
   jlong seconds = millis / 1000;
   millis %= 1000;
   if (seconds > 50000000) { // see man cond_timedwait(3T)
     seconds = 50000000;
   }
-  abstime->tv_sec = now.tv_sec  + seconds;
-  long       usec = now.tv_usec + millis * 1000;
-  if (usec >= 1000000) {
-    abstime->tv_sec += 1;
-    usec -= 1000000;
+
+  if (os::Bsd::supports_monotonic_clock()) {
+    struct timespec now;
+    int status = ::clock_gettime(CLOCK_MONOTONIC, &now);
+    assert_status(status == 0, status, "clock_gettime");
+    abstime->tv_sec = now.tv_sec  + seconds;
+    long nanos = now.tv_nsec + millis * NANOSECS_PER_MILLISEC;
+    if (nanos >= NANOSECS_PER_SEC) {
+      abstime->tv_sec += 1;
+      nanos -= NANOSECS_PER_SEC;
+    }
+    abstime->tv_nsec = nanos;
+  } else {
+    struct timeval now;
+    int status = gettimeofday(&now, NULL);
+    assert(status == 0, "gettimeofday");
+    abstime->tv_sec = now.tv_sec  + seconds;
+    long usec = now.tv_usec + millis * 1000;
+    if (usec >= 1000000) {
+      abstime->tv_sec += 1;
+      usec -= 1000000;
+    }
+    abstime->tv_nsec = usec * 1000;
   }
-  abstime->tv_nsec = usec * 1000;
   return abstime;
 }
 
@@ -4433,7 +4614,7 @@
     status = os::Bsd::safe_cond_timedwait(_cond, _mutex, &abst);
     if (status != 0 && WorkAroundNPTLTimedWaitHang) {
       pthread_cond_destroy (_cond);
-      pthread_cond_init (_cond, NULL) ;
+      pthread_cond_init (_cond, os::Bsd::condAttr()) ;
     }
     assert_status(status == 0 || status == EINTR ||
                   status == ETIMEDOUT,
@@ -4534,32 +4715,50 @@
 
 static void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
-
-  struct timeval now;
-  int status = gettimeofday(&now, NULL);
-  assert(status == 0, "gettimeofday");
-
-  time_t max_secs = now.tv_sec + MAX_SECS;
-
-  if (isAbsolute) {
-    jlong secs = time / 1000;
-    if (secs > max_secs) {
-      absTime->tv_sec = max_secs;
+  time_t max_secs = 0;
+
+  if (!os::Bsd::supports_monotonic_clock() || isAbsolute) {
+    struct timeval now;
+    int status = gettimeofday(&now, NULL);
+    assert(status == 0, "gettimeofday");
+
+    max_secs = now.tv_sec + MAX_SECS;
+
+    if (isAbsolute) {
+      jlong secs = time / 1000;
+      if (secs > max_secs) {
+        absTime->tv_sec = max_secs;
+      } else {
+        absTime->tv_sec = secs;
+      }
+      absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;
+    } else {
+      jlong secs = time / NANOSECS_PER_SEC;
+      if (secs >= MAX_SECS) {
+        absTime->tv_sec = max_secs;
+        absTime->tv_nsec = 0;
+      } else {
+        absTime->tv_sec = now.tv_sec + secs;
+        absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;
+        if (absTime->tv_nsec >= NANOSECS_PER_SEC) {
+          absTime->tv_nsec -= NANOSECS_PER_SEC;
+          ++absTime->tv_sec; // note: this must be <= max_secs
+        }
+      }
     }
-    else {
-      absTime->tv_sec = secs;
-    }
-    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;
-  }
-  else {
+  } else {
+    // must be relative using monotonic clock
+    struct timespec now;
+    int status = ::clock_gettime(CLOCK_MONOTONIC, &now);
+    assert_status(status == 0, status, "clock_gettime");
+    max_secs = now.tv_sec + MAX_SECS;
     jlong secs = time / NANOSECS_PER_SEC;
     if (secs >= MAX_SECS) {
       absTime->tv_sec = max_secs;
       absTime->tv_nsec = 0;
-    }
-    else {
+    } else {
       absTime->tv_sec = now.tv_sec + secs;
-      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;
+      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_nsec;
       if (absTime->tv_nsec >= NANOSECS_PER_SEC) {
         absTime->tv_nsec -= NANOSECS_PER_SEC;
         ++absTime->tv_sec; // note: this must be <= max_secs
@@ -4639,15 +4838,19 @@
   jt->set_suspend_equivalent();
   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
 
+  assert(_cur_index == -1, "invariant");
   if (time == 0) {
-    status = pthread_cond_wait (_cond, _mutex) ;
+    _cur_index = REL_INDEX; // arbitrary choice when not timed
+    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;
   } else {
-    status = os::Bsd::safe_cond_timedwait (_cond, _mutex, &absTime) ;
+    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;
+    status = os::Bsd::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;
     if (status != 0 && WorkAroundNPTLTimedWaitHang) {
-      pthread_cond_destroy (_cond) ;
-      pthread_cond_init    (_cond, NULL);
+      pthread_cond_destroy (&_cond[_cur_index]) ;
+      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Bsd::condAttr());
     }
   }
+  _cur_index = -1;
   assert_status(status == 0 || status == EINTR ||
                 status == ETIMEDOUT,
                 status, "cond_timedwait");
@@ -4676,17 +4879,26 @@
   s = _counter;
   _counter = 1;
   if (s < 1) {
-     if (WorkAroundNPTLTimedWaitHang) {
-        status = pthread_cond_signal (_cond) ;
-        assert (status == 0, "invariant") ;
+    // thread might be parked
+    if (_cur_index != -1) {
+      // thread is definitely parked
+      if (WorkAroundNPTLTimedWaitHang) {
+        status = pthread_cond_signal (&_cond[_cur_index]);
+        assert (status == 0, "invariant");
         status = pthread_mutex_unlock(_mutex);
-        assert (status == 0, "invariant") ;
-     } else {
+        assert (status == 0, "invariant");
+      } else {
+        // must capture correct index before unlocking
+        int index = _cur_index;
         status = pthread_mutex_unlock(_mutex);
-        assert (status == 0, "invariant") ;
-        status = pthread_cond_signal (_cond) ;
-        assert (status == 0, "invariant") ;
-     }
+        assert (status == 0, "invariant");
+        status = pthread_cond_signal (&_cond[index]);
+        assert (status == 0, "invariant");
+      }
+    } else {
+      pthread_mutex_unlock(_mutex);
+      assert (status == 0, "invariant") ;
+    }
   } else {
     pthread_mutex_unlock(_mutex);
     assert (status == 0, "invariant") ;
@@ -4817,13 +5029,29 @@
 
 // Get the default path to the core file
 // Returns the length of the string
-int os::get_core_path(char* buffer, size_t bufferSize) {
-  int n = jio_snprintf(buffer, bufferSize, "/cores");
-
-  // Truncate if theoretical string was longer than bufferSize
-  n = MIN2(n, (int)bufferSize);
-
-  return n;
+int os::get_core_path(char *buffer, size_t bufferSize) {
+#ifdef __APPLE__
+  jio_snprintf(buffer, bufferSize, "/cores/core.%d", current_process_id());
+#else
+  const char *p = get_current_directory(buffer, bufferSize);
+
+  if (p == NULL) {
+    assert(p != NULL, "failed to get current directory");
+    return 0;
+  }
+
+  const char *q = getprogname();
+
+  if (q == NULL) {
+    assert(q != NULL, "failed to get progname");
+    return 0;
+  }
+
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/%s.core", q);
+#endif
+  return strlen(buffer);
 }
 
 #ifndef PRODUCT
--- ./hotspot/src/os/bsd/vm/os_bsd.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -58,12 +58,16 @@
   // For signal flags diagnostics
   static int sigflags[MAXSIGNUM];
 
+  static address   _initial_thread_stack_bottom;
+  static uintptr_t _initial_thread_stack_size;
+
 #ifdef __APPLE__
   // mach_absolute_time
   static mach_timebase_info_data_t _timebase_info;
   static volatile uint64_t         _max_abstime;
 #else
   static int (*_clock_gettime)(clockid_t, struct timespec *);
+  static int (*_getcpuclockid)(pthread_t, clockid_t *);
 #endif
 
   static GrowableArray<int>* _cpu_to_node;
@@ -95,6 +99,9 @@
   static bool is_initial_thread(void);
   static pid_t gettid();
 
+  static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
+  static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
+
   static int page_size(void)                                        { return _page_size; }
   static void set_page_size(int val)                                { _page_size = val; }
 
@@ -148,6 +155,13 @@
 #endif
   }
 
+  // pthread_cond clock suppport
+  private:
+  static pthread_condattr_t _condattr[1];
+
+  public:
+  static pthread_condattr_t* condAttr() { return _condattr; }
+
   // Stack repair handling
 
   // none present
@@ -213,7 +227,7 @@
   public:
     PlatformEvent() {
       int status;
-      status = pthread_cond_init (_cond, NULL);
+      status = pthread_cond_init (_cond, os::Bsd::condAttr());
       assert_status(status == 0, status, "cond_init");
       status = pthread_mutex_init (_mutex, NULL);
       assert_status(status == 0, status, "mutex_init");
@@ -228,14 +242,19 @@
     void park () ;
     void unpark () ;
     int  TryPark () ;
-    int  park (jlong millis) ;
+    int  park (jlong millis) ; // relative timed-wait only
     void SetAssociation (Thread * a) { _Assoc = a ; }
 };
 
 class PlatformParker : public CHeapObj<mtInternal> {
   protected:
+    enum {
+        REL_INDEX = 0,
+        ABS_INDEX = 1
+    };
+    int _cur_index;  // which cond is in use: -1, 0, 1
     pthread_mutex_t _mutex [1] ;
-    pthread_cond_t  _cond  [1] ;
+    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.
 
   public:       // TODO-FIXME: make dtor private
     ~PlatformParker() { guarantee (0, "invariant") ; }
@@ -243,10 +262,13 @@
   public:
     PlatformParker() {
       int status;
-      status = pthread_cond_init (_cond, NULL);
-      assert_status(status == 0, status, "cond_init");
+      status = pthread_cond_init (&_cond[REL_INDEX], os::Bsd::condAttr());
+      assert_status(status == 0, status, "cond_init rel");
+      status = pthread_cond_init (&_cond[ABS_INDEX], NULL);
+      assert_status(status == 0, status, "cond_init abs");
       status = pthread_mutex_init (_mutex, NULL);
       assert_status(status == 0, status, "mutex_init");
+      _cur_index = -1; // mark as unused
     }
 };
 
--- ./hotspot/src/os/bsd/vm/vmError_bsd.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/bsd/vm/vmError_bsd.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -33,30 +33,50 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <signal.h>
+#ifdef __FreeBSD__
+#include <limits.h>
+#include <sys/sysctl.h>
+#endif
+
+#define GDB_CMD "gdb"
+
+static void set_debugger(char *buf, int buflen) {
+  int pid = os::current_process_id();
+#ifdef __FreeBSD__
+  char cmd[PATH_MAX+1];
+  int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, pid };
+  size_t len = sizeof(cmd);
+  if (sysctl(name, 4, cmd, &len, NULL, 0) == 0 && len > 0) {
+    cmd[len] = '\0';
+    jio_snprintf(buf, buflen, "%s %s %d", GDB_CMD, cmd, pid);
+  } else
+#endif
+  jio_snprintf(buf, buflen, "%s /proc/%d/file %d", GDB_CMD, pid, pid);
+}
 
 void VMError::show_message_box(char *buf, int buflen) {
   bool yes;
   do {
-    error_string(buf, buflen);
-    int len = (int)strlen(buf);
+    intx tid = os::current_thread_id();
+    set_debugger(buf, buflen);
+    int len = (int)strlen(buf) + 1;
+    char *msg = &buf[len];
+    error_string(msg, buflen - len);
+    len += (int)strlen(msg);
     char *p = &buf[len];
 
     jio_snprintf(p, buflen - len,
                "\n\n"
                "Do you want to debug the problem?\n\n"
-               "To debug, run 'gdb /proc/%d/exe %d'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
-               "Enter 'yes' to launch gdb automatically (PATH must include gdb)\n"
+               "To debug, run '%s'; then switch to thread " INTX_FORMAT " (" INTPTR_FORMAT ")\n"
+               "Enter 'yes' to launch " GDB_CMD " automatically (PATH must include " GDB_CMD ")\n"
                "Otherwise, press RETURN to abort...",
-               os::current_process_id(), os::current_process_id(),
-               os::current_thread_id(), os::current_thread_id());
+               buf, tid, tid);
 
-    yes = os::message_box("Unexpected Error", buf);
+    yes = os::message_box("Unexpected Error", msg);
 
     if (yes) {
       // yes, user asked VM to launch debugger
-      jio_snprintf(buf, buflen, "gdb /proc/%d/exe %d",
-                   os::current_process_id(), os::current_process_id());
-
       os::fork_and_exec(buf);
       yes = false;
     }
--- ./hotspot/src/os/linux/vm/os_linux.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/linux/vm/os_linux.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -6285,6 +6285,10 @@
     return 0;
   }
 
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
+
   return strlen(buffer);
 }
 
--- ./hotspot/src/os/posix/vm/os_posix.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/posix/vm/os_posix.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -53,12 +53,11 @@
   n = get_core_path(buffer, bufferSize);
 
   if (getrlimit(RLIMIT_CORE, &rlim) != 0) {
-    jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d (may not exist)", current_process_id());
+    jio_snprintf(buffer + n, bufferSize - n, " (may not exist)");
     success = true;
   } else {
     switch(rlim.rlim_cur) {
       case RLIM_INFINITY:
-        jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
         success = true;
         break;
       case 0:
@@ -66,7 +65,7 @@
         success = false;
         break;
       default:
-        jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d (max size %lu kB). To ensure a full core dump, try \"ulimit -c unlimited\" before starting Java again", current_process_id(), (unsigned long)(rlim.rlim_cur >> 10));
+        jio_snprintf(buffer + n, bufferSize - n, " (max size %lu kB). To ensure a full core dump, try \"ulimit -c unlimited\" before starting Java again", (unsigned long)(rlim.rlim_cur >> 10));
         success = true;
         break;
     }
@@ -201,8 +200,13 @@
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifdef __OpenBSD__
+  st->print(", DATA ");
+  getrlimit(RLIMIT_DATA, &rlim);
+#else
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
+#endif
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%uk", rlim.rlim_cur >> 10);
   st->cr();
@@ -222,7 +226,11 @@
 
 bool os::has_allocatable_memory_limit(julong* limit) {
   struct rlimit rlim;
+#ifdef __OpenBSD__
+  int getrlimit_res = getrlimit(RLIMIT_DATA, &rlim);
+#else
   int getrlimit_res = getrlimit(RLIMIT_AS, &rlim);
+#endif
   // if there was an error when calling getrlimit, assume that there is no limitation
   // on virtual memory.
   bool result;
@@ -721,8 +729,12 @@
     { SI_USER,      "SI_USER",     "Signal sent by kill()." },
     { SI_QUEUE,     "SI_QUEUE",    "Signal sent by the sigqueue()." },
     { SI_TIMER,     "SI_TIMER",    "Signal generated by expiration of a timer set by timer_settime()." },
+#ifdef SI_ASYNCIO
     { SI_ASYNCIO,   "SI_ASYNCIO",  "Signal generated by completion of an asynchronous I/O request." },
+#endif
+#ifdef SI_MESGQ
     { SI_MESGQ,     "SI_MESGQ",    "Signal generated by arrival of a message on an empty message queue." },
+#endif
     // Linux specific
 #ifdef SI_TKILL
     { SI_TKILL,     "SI_TKILL",    "Signal sent by tkill (pthread_kill)" },
--- ./hotspot/src/os/solaris/vm/os_solaris.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os/solaris/vm/os_solaris.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -6375,6 +6375,10 @@
     return 0;
   }
 
+  const int n = strlen(buffer);
+
+  jio_snprintf(buffer + n, bufferSize - n, "/core or core.%d", current_process_id());
+
   return strlen(buffer);
 }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/atomic_bsd_ppc.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,400 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
+
+#include "runtime/atomic.hpp"
+#include "runtime/os.hpp"
+#include "vm_version_ppc.hpp"
+
+#ifndef PPC64
+#error "Atomic currently only implemented for PPC64"
+#endif
+
+// Implementation of class atomic
+
+inline void Atomic::store    (jbyte    store_value, jbyte*    dest) { *dest = store_value; }
+inline void Atomic::store    (jshort   store_value, jshort*   dest) { *dest = store_value; }
+inline void Atomic::store    (jint     store_value, jint*     dest) { *dest = store_value; }
+inline void Atomic::store    (jlong    store_value, jlong*    dest) { *dest = store_value; }
+inline void Atomic::store_ptr(intptr_t store_value, intptr_t* dest) { *dest = store_value; }
+inline void Atomic::store_ptr(void*    store_value, void*     dest) { *(void**)dest = store_value; }
+
+inline void Atomic::store    (jbyte    store_value, volatile jbyte*    dest) { *dest = store_value; }
+inline void Atomic::store    (jshort   store_value, volatile jshort*   dest) { *dest = store_value; }
+inline void Atomic::store    (jint     store_value, volatile jint*     dest) { *dest = store_value; }
+inline void Atomic::store    (jlong    store_value, volatile jlong*    dest) { *dest = store_value; }
+inline void Atomic::store_ptr(intptr_t store_value, volatile intptr_t* dest) { *dest = store_value; }
+inline void Atomic::store_ptr(void*    store_value, volatile void*     dest) { *(void* volatile *)dest = store_value; }
+
+inline jlong Atomic::load(volatile jlong* src) { return *src; }
+
+//
+// machine barrier instructions:
+//
+// - sync            two-way memory barrier, aka fence
+// - lwsync          orders  Store|Store,
+//                            Load|Store,
+//                            Load|Load,
+//                   but not Store|Load
+// - eieio           orders memory accesses for device memory (only)
+// - isync           invalidates speculatively executed instructions
+//                   From the POWER ISA 2.06 documentation:
+//                    "[...] an isync instruction prevents the execution of
+//                   instructions following the isync until instructions
+//                   preceding the isync have completed, [...]"
+//                   From IBM's AIX assembler reference:
+//                    "The isync [...] instructions causes the processor to
+//                   refetch any instructions that might have been fetched
+//                   prior to the isync instruction. The instruction isync
+//                   causes the processor to wait for all previous instructions
+//                   to complete. Then any instructions already fetched are
+//                   discarded and instruction processing continues in the
+//                   environment established by the previous instructions."
+//
+// semantic barrier instructions:
+// (as defined in orderAccess.hpp)
+//
+// - release         orders Store|Store,       (maps to lwsync)
+//                           Load|Store
+// - acquire         orders  Load|Store,       (maps to lwsync)
+//                           Load|Load
+// - fence           orders Store|Store,       (maps to sync)
+//                           Load|Store,
+//                           Load|Load,
+//                          Store|Load
+//
+
+#define strasm_sync                       "\n  sync    \n"
+#define strasm_lwsync                     "\n  lwsync  \n"
+#define strasm_isync                      "\n  isync   \n"
+#define strasm_release                    strasm_lwsync
+#define strasm_acquire                    strasm_lwsync
+#define strasm_fence                      strasm_sync
+#define strasm_nobarrier                  ""
+#define strasm_nobarrier_clobber_memory   ""
+
+inline jint     Atomic::add    (jint     add_value, volatile jint*     dest) {
+
+  unsigned int result;
+
+  __asm__ __volatile__ (
+    strasm_lwsync
+    "1: lwarx   %0,  0, %2    \n"
+    "   add     %0, %0, %1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_isync
+    : /*%0*/"=&r" (result)
+    : /*%1*/"r" (add_value), /*%2*/"r" (dest)
+    : "cc", "memory" );
+
+  return (jint) result;
+}
+
+
+inline intptr_t Atomic::add_ptr(intptr_t add_value, volatile intptr_t* dest) {
+
+  long result;
+
+  __asm__ __volatile__ (
+    strasm_lwsync
+    "1: ldarx   %0,  0, %2    \n"
+    "   add     %0, %0, %1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_isync
+    : /*%0*/"=&r" (result)
+    : /*%1*/"r" (add_value), /*%2*/"r" (dest)
+    : "cc", "memory" );
+
+  return (intptr_t) result;
+}
+
+inline void*    Atomic::add_ptr(intptr_t add_value, volatile void*     dest) {
+  return (void*)add_ptr(add_value, (volatile intptr_t*)dest);
+}
+
+
+inline void Atomic::inc    (volatile jint*     dest) {
+
+  unsigned int temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: lwarx   %0,  0, %2    \n"
+    "   addic   %0, %0,  1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::inc_ptr(volatile intptr_t* dest) {
+
+  long temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: ldarx   %0,  0, %2    \n"
+    "   addic   %0, %0,  1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::inc_ptr(volatile void*     dest) {
+  inc_ptr((volatile intptr_t*)dest);
+}
+
+
+inline void Atomic::dec    (volatile jint*     dest) {
+
+  unsigned int temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: lwarx   %0,  0, %2    \n"
+    "   addic   %0, %0, -1    \n"
+    "   stwcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::dec_ptr(volatile intptr_t* dest) {
+
+  long temp;
+
+  __asm__ __volatile__ (
+    strasm_nobarrier
+    "1: ldarx   %0,  0, %2    \n"
+    "   addic   %0, %0, -1    \n"
+    "   stdcx.  %0,  0, %2    \n"
+    "   bne-    1b            \n"
+    strasm_nobarrier
+    : /*%0*/"=&r" (temp), "=m" (*dest)
+    : /*%2*/"r" (dest), "m" (*dest)
+    : "cc" strasm_nobarrier_clobber_memory);
+
+}
+
+inline void Atomic::dec_ptr(volatile void*     dest) {
+  dec_ptr((volatile intptr_t*)dest);
+}
+
+inline jint Atomic::xchg(jint exchange_value, volatile jint* dest) {
+
+  // Note that xchg_ptr doesn't necessarily do an acquire
+  // (see synchronizer.cpp).
+
+  unsigned int old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* lwsync */
+    strasm_lwsync
+    /* atomic loop */
+    "1:                                                 \n"
+    "   lwarx   %[old_value], %[dest], %[zero]          \n"
+    "   stwcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* isync */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jint) old_value;
+}
+
+inline intptr_t Atomic::xchg_ptr(intptr_t exchange_value, volatile intptr_t* dest) {
+
+  // Note that xchg_ptr doesn't necessarily do an acquire
+  // (see synchronizer.cpp).
+
+  long old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* lwsync */
+    strasm_lwsync
+    /* atomic loop */
+    "1:                                                 \n"
+    "   ldarx   %[old_value], %[dest], %[zero]          \n"
+    "   stdcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* isync */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (intptr_t) old_value;
+}
+
+inline void* Atomic::xchg_ptr(void* exchange_value, volatile void* dest) {
+  return (void*)xchg_ptr((intptr_t)exchange_value, (volatile intptr_t*)dest);
+}
+
+inline jint Atomic::cmpxchg(jint exchange_value, volatile jint* dest, jint compare_value) {
+
+  // Note that cmpxchg guarantees a two-way memory barrier across
+  // the cmpxchg, so it's really a a 'fence_cmpxchg_acquire'
+  // (see atomic.hpp).
+
+  unsigned int old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* fence */
+    strasm_sync
+    /* simple guard */
+    "   lwz     %[old_value], 0(%[dest])                \n"
+    "   cmpw    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    /* atomic loop */
+    "1:                                                 \n"
+    "   lwarx   %[old_value], %[dest], %[zero]          \n"
+    "   cmpw    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    "   stwcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* acquire */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [compare_value]   "r"     (compare_value),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jint) old_value;
+}
+
+inline jlong Atomic::cmpxchg(jlong exchange_value, volatile jlong* dest, jlong compare_value) {
+
+  // Note that cmpxchg guarantees a two-way memory barrier across
+  // the cmpxchg, so it's really a a 'fence_cmpxchg_acquire'
+  // (see atomic.hpp).
+
+  long old_value;
+  const uint64_t zero = 0;
+
+  __asm__ __volatile__ (
+    /* fence */
+    strasm_sync
+    /* simple guard */
+    "   ld      %[old_value], 0(%[dest])                \n"
+    "   cmpd    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    /* atomic loop */
+    "1:                                                 \n"
+    "   ldarx   %[old_value], %[dest], %[zero]          \n"
+    "   cmpd    %[compare_value], %[old_value]          \n"
+    "   bne-    2f                                      \n"
+    "   stdcx.  %[exchange_value], %[dest], %[zero]     \n"
+    "   bne-    1b                                      \n"
+    /* acquire */
+    strasm_sync
+    /* exit */
+    "2:                                                 \n"
+    /* out */
+    : [old_value]       "=&r"   (old_value),
+                        "=m"    (*dest)
+    /* in */
+    : [dest]            "b"     (dest),
+      [zero]            "r"     (zero),
+      [compare_value]   "r"     (compare_value),
+      [exchange_value]  "r"     (exchange_value),
+                        "m"     (*dest)
+    /* clobber */
+    : "cc",
+      "memory"
+    );
+
+  return (jlong) old_value;
+}
+
+inline intptr_t Atomic::cmpxchg_ptr(intptr_t exchange_value, volatile intptr_t* dest, intptr_t compare_value) {
+  return (intptr_t)cmpxchg((jlong)exchange_value, (volatile jlong*)dest, (jlong)compare_value);
+}
+
+inline void* Atomic::cmpxchg_ptr(void* exchange_value, volatile void* dest, void* compare_value) {
+  return (void*)cmpxchg((jlong)exchange_value, (volatile jlong*)dest, (jlong)compare_value);
+}
+
+#undef strasm_sync
+#undef strasm_lwsync
+#undef strasm_isync
+#undef strasm_release
+#undef strasm_acquire
+#undef strasm_fence
+#undef strasm_nobarrier
+#undef strasm_nobarrier_clobber_memory
+
+#endif // OS_CPU_BSD_PPC_VM_ATOMIC_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/bytes_bsd_ppc.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2014 Google Inc.  All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
+
+#if defined(VM_LITTLE_ENDIAN)
+#include <byteswap.h>
+
+// Efficient swapping of data bytes from Java byte
+// ordering to native byte ordering and vice versa.
+inline u2 Bytes::swap_u2(u2 x) { return bswap_16(x); }
+inline u4 Bytes::swap_u4(u4 x) { return bswap_32(x); }
+inline u8 Bytes::swap_u8(u8 x) { return bswap_64(x); }
+#endif // VM_LITTLE_ENDIAN
+
+#endif // OS_CPU_BSD_PPC_VM_BYTES_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/globals_bsd_ppc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
+
+// Sets the default values for platform dependent flags used by the runtime system.
+// (see globals.hpp)
+
+define_pd_global(bool, DontYieldALot,            false);
+define_pd_global(intx, ThreadStackSize,          2048); // 0 => use system default
+define_pd_global(intx, VMThreadStackSize,        2048);
+
+// if we set CompilerThreadStackSize to a value different than 0, it will
+// be used in os::create_thread(). Otherwise, due the strange logic in os::create_thread(),
+// the stack size for compiler threads will default to VMThreadStackSize, although it
+// is defined to 4M in os::Bsd::default_stack_size()!
+define_pd_global(intx, CompilerThreadStackSize,  4096);
+
+// Allow extra space in DEBUG builds for asserts.
+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+
+define_pd_global(intx, StackYellowPages,         6);
+define_pd_global(intx, StackRedPages,            1);
+define_pd_global(intx, StackShadowPages,         6 DEBUG_ONLY(+2));
+
+// Only used on 64 bit platforms
+define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+// Only used on 64 bit Windows platforms
+define_pd_global(bool, UseVectoredExceptions,    false);
+
+#endif // OS_CPU_BSD_PPC_VM_GLOBALS_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/orderAccess_bsd_ppc.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
+
+#include "runtime/orderAccess.hpp"
+#include "vm_version_ppc.hpp"
+
+#ifndef PPC64
+#error "OrderAccess currently only implemented for PPC64"
+#endif
+
+// Implementation of class OrderAccess.
+
+//
+// Machine barrier instructions:
+//
+// - sync            Two-way memory barrier, aka fence.
+// - lwsync          orders  Store|Store,
+//                            Load|Store,
+//                            Load|Load,
+//                   but not Store|Load
+// - eieio           orders  Store|Store
+// - isync           Invalidates speculatively executed instructions,
+//                   but isync may complete before storage accesses
+//                   associated with instructions preceding isync have
+//                   been performed.
+//
+// Semantic barrier instructions:
+// (as defined in orderAccess.hpp)
+//
+// - release         orders Store|Store,       (maps to lwsync)
+//                           Load|Store
+// - acquire         orders  Load|Store,       (maps to lwsync)
+//                           Load|Load
+// - fence           orders Store|Store,       (maps to sync)
+//                           Load|Store,
+//                           Load|Load,
+//                          Store|Load
+//
+
+#define inlasm_sync()     __asm__ __volatile__ ("sync"   : : : "memory");
+#define inlasm_lwsync()   __asm__ __volatile__ ("lwsync" : : : "memory");
+#define inlasm_eieio()    __asm__ __volatile__ ("eieio"  : : : "memory");
+#define inlasm_isync()    __asm__ __volatile__ ("isync"  : : : "memory");
+#define inlasm_release()  inlasm_lwsync();
+#define inlasm_acquire()  inlasm_lwsync();
+// Use twi-isync for load_acquire (faster than lwsync).
+#define inlasm_acquire_reg(X) __asm__ __volatile__ ("twi 0,%0,0\n isync\n" : : "r" (X) : "memory");
+#define inlasm_fence()    inlasm_sync();
+
+inline void     OrderAccess::loadload()   { inlasm_lwsync();  }
+inline void     OrderAccess::storestore() { inlasm_lwsync();  }
+inline void     OrderAccess::loadstore()  { inlasm_lwsync();  }
+inline void     OrderAccess::storeload()  { inlasm_fence();   }
+
+inline void     OrderAccess::acquire()    { inlasm_acquire(); }
+inline void     OrderAccess::release()    { inlasm_release(); }
+inline void     OrderAccess::fence()      { inlasm_fence();   }
+
+inline jbyte    OrderAccess::load_acquire(volatile jbyte*   p) { register jbyte t = *p;   inlasm_acquire_reg(t); return t; }
+inline jshort   OrderAccess::load_acquire(volatile jshort*  p) { register jshort t = *p;  inlasm_acquire_reg(t); return t; }
+inline jint     OrderAccess::load_acquire(volatile jint*    p) { register jint t = *p;    inlasm_acquire_reg(t); return t; }
+inline jlong    OrderAccess::load_acquire(volatile jlong*   p) { register jlong t = *p;   inlasm_acquire_reg(t); return t; }
+inline jubyte   OrderAccess::load_acquire(volatile jubyte*  p) { register jubyte t = *p;  inlasm_acquire_reg(t); return t; }
+inline jushort  OrderAccess::load_acquire(volatile jushort* p) { register jushort t = *p; inlasm_acquire_reg(t); return t; }
+inline juint    OrderAccess::load_acquire(volatile juint*   p) { register juint t = *p;   inlasm_acquire_reg(t); return t; }
+inline julong   OrderAccess::load_acquire(volatile julong*  p) { return (julong)load_acquire((volatile jlong*)p); }
+inline jfloat   OrderAccess::load_acquire(volatile jfloat*  p) { register jfloat t = *p;  inlasm_acquire(); return t; }
+inline jdouble  OrderAccess::load_acquire(volatile jdouble* p) { register jdouble t = *p; inlasm_acquire(); return t; }
+
+inline intptr_t OrderAccess::load_ptr_acquire(volatile intptr_t*   p) { return (intptr_t)load_acquire((volatile jlong*)p); }
+inline void*    OrderAccess::load_ptr_acquire(volatile void*       p) { return (void*)   load_acquire((volatile jlong*)p); }
+inline void*    OrderAccess::load_ptr_acquire(const volatile void* p) { return (void*)   load_acquire((volatile jlong*)p); }
+
+inline void     OrderAccess::release_store(volatile jbyte*   p, jbyte   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jshort*  p, jshort  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jint*    p, jint    v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jlong*   p, jlong   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jubyte*  p, jubyte  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jushort* p, jushort v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile juint*   p, juint   v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile julong*  p, julong  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jfloat*  p, jfloat  v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store(volatile jdouble* p, jdouble v) { inlasm_release(); *p = v; }
+
+inline void     OrderAccess::release_store_ptr(volatile intptr_t* p, intptr_t v) { inlasm_release(); *p = v; }
+inline void     OrderAccess::release_store_ptr(volatile void*     p, void*    v) { inlasm_release(); *(void* volatile *)p = v; }
+
+inline void     OrderAccess::store_fence(jbyte*   p, jbyte   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jshort*  p, jshort  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jint*    p, jint    v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jlong*   p, jlong   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jubyte*  p, jubyte  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jushort* p, jushort v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(juint*   p, juint   v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(julong*  p, julong  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jfloat*  p, jfloat  v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_fence(jdouble* p, jdouble v) { *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::store_ptr_fence(intptr_t* p, intptr_t v) { *p = v; inlasm_fence(); }
+inline void     OrderAccess::store_ptr_fence(void**    p, void*    v) { *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::release_store_fence(volatile jbyte*   p, jbyte   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jshort*  p, jshort  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jint*    p, jint    v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jlong*   p, jlong   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jubyte*  p, jubyte  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jushort* p, jushort v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile juint*   p, juint   v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile julong*  p, julong  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jfloat*  p, jfloat  v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_fence(volatile jdouble* p, jdouble v) { inlasm_release(); *p = v; inlasm_fence(); }
+
+inline void     OrderAccess::release_store_ptr_fence(volatile intptr_t* p, intptr_t v) { inlasm_release(); *p = v; inlasm_fence(); }
+inline void     OrderAccess::release_store_ptr_fence(volatile void*     p, void*    v) { inlasm_release(); *(void* volatile *)p = v; inlasm_fence(); }
+
+#undef inlasm_sync
+#undef inlasm_lwsync
+#undef inlasm_eieio
+#undef inlasm_isync
+#undef inlasm_release
+#undef inlasm_acquire
+#undef inlasm_fence
+
+#endif // OS_CPU_BSD_PPC_VM_ORDERACCESS_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/os_bsd_ppc.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,666 @@
+/*
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// no precompiled headers
+#include "assembler_ppc.inline.hpp"
+#include "classfile/classLoader.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/vmSymbols.hpp"
+#include "code/icBuffer.hpp"
+#include "code/vtableStubs.hpp"
+#include "interpreter/interpreter.hpp"
+#include "jvm_bsd.h"
+#include "memory/allocation.inline.hpp"
+#include "mutex_bsd.inline.hpp"
+#include "nativeInst_ppc.hpp"
+#include "os_share_bsd.hpp"
+#include "prims/jniFastGetField.hpp"
+#include "prims/jvm.h"
+#include "prims/jvm_misc.hpp"
+#include "runtime/arguments.hpp"
+#include "runtime/extendedPC.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/interfaceSupport.hpp"
+#include "runtime/java.hpp"
+#include "runtime/javaCalls.hpp"
+#include "runtime/mutexLocker.hpp"
+#include "runtime/osThread.hpp"
+#include "runtime/sharedRuntime.hpp"
+#include "runtime/stubRoutines.hpp"
+#include "runtime/thread.inline.hpp"
+#include "runtime/timer.hpp"
+#include "utilities/events.hpp"
+#include "utilities/vmError.hpp"
+#ifdef COMPILER1
+#include "c1/c1_Runtime1.hpp"
+#endif
+#ifdef COMPILER2
+#include "opto/runtime.hpp"
+#endif
+
+// put OS-includes here
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <pthread.h>
+# include <signal.h>
+# include <errno.h>
+# include <dlfcn.h>
+# include <stdlib.h>
+# include <stdio.h>
+# include <unistd.h>
+# include <sys/resource.h>
+# include <pthread_np.h>
+# include <sys/stat.h>
+# include <sys/time.h>
+# include <sys/utsname.h>
+# include <sys/socket.h>
+# include <sys/wait.h>
+# include <pwd.h>
+# include <poll.h>
+# include <ucontext.h>
+
+
+address os::current_stack_pointer() {
+  intptr_t* csp;
+
+  // inline assembly `mr regno(csp), R1_SP':
+  __asm__ __volatile__ ("mr %0, 1":"=r"(csp):);
+
+  return (address) csp;
+}
+
+char* os::non_memory_address_word() {
+  // Must never look like an address returned by reserve_memory,
+  // even in its subfields (as defined by the CPU immediate fields,
+  // if the CPU splits constants across multiple instructions).
+
+  return (char*) -1;
+}
+
+void os::initialize_thread(Thread *thread) { }
+
+address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
+  guarantee(uc->uc_mcontext.mc_gpr != NULL, "only use ucontext_get_pc in sigaction context");
+  return (address)uc->uc_mcontext.mc_srr0;
+}
+
+intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
+  return (intptr_t*)uc->uc_mcontext.mc_gpr[1/*REG_SP*/];
+}
+
+intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
+  return NULL;
+}
+
+ExtendedPC os::fetch_frame_from_context(void* ucVoid,
+                    intptr_t** ret_sp, intptr_t** ret_fp) {
+
+  ExtendedPC  epc;
+  ucontext_t* uc = (ucontext_t*)ucVoid;
+
+  if (uc != NULL) {
+    epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));
+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
+  } else {
+    // construct empty ExtendedPC for return value checking
+    epc = ExtendedPC(NULL);
+    if (ret_sp) *ret_sp = (intptr_t *)NULL;
+    if (ret_fp) *ret_fp = (intptr_t *)NULL;
+  }
+
+  return epc;
+}
+
+frame os::fetch_frame_from_context(void* ucVoid) {
+  intptr_t* sp;
+  intptr_t* fp;
+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);
+  return frame(sp, epc.pc());
+}
+
+frame os::get_sender_for_C_frame(frame* fr) {
+  if (*fr->sp() == 0) {
+    // fr is the last C frame
+    return frame(NULL, NULL);
+  }
+  return frame(fr->sender_sp(), fr->sender_pc());
+}
+
+
+frame os::current_frame() {
+  intptr_t* csp = (intptr_t*) *((intptr_t*) os::current_stack_pointer());
+  // hack.
+  frame topframe(csp, (address)0x8);
+  // return sender of current topframe which hopefully has pc != NULL.
+  return os::get_sender_for_C_frame(&topframe);
+}
+
+// Utility functions
+
+extern "C" JNIEXPORT int
+JVM_handle_bsd_signal(int sig, siginfo_t* info, void* ucVoid, int abort_if_unrecognized) {
+
+  ucontext_t* uc = (ucontext_t*) ucVoid;
+
+  Thread* t = ThreadLocalStorage::get_thread_slow();   // slow & steady
+
+  SignalHandlerMark shm(t);
+
+  // Note: it's not uncommon that JNI code uses signal/sigset to install
+  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
+  // or have a SIGILL handler when detecting CPU type). When that happens,
+  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
+  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
+  // that do not require siginfo/ucontext first.
+
+  if (sig == SIGPIPE) {
+    if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+      return 1;
+    } else {
+      if (PrintMiscellaneous && (WizardMode || Verbose)) {
+        warning("Ignoring SIGPIPE - see bug 4229104");
+      }
+      return 1;
+    }
+  }
+
+  JavaThread* thread = NULL;
+  VMThread* vmthread = NULL;
+  if (os::Bsd::signal_handlers_are_installed) {
+    if (t != NULL) {
+      if(t->is_Java_thread()) {
+        thread = (JavaThread*)t;
+      }
+      else if(t->is_VM_thread()) {
+        vmthread = (VMThread *)t;
+      }
+    }
+  }
+
+  // Decide if this trap can be handled by a stub.
+  address stub = NULL;
+
+  // retrieve program counter
+  address const pc = uc ? os::Bsd::ucontext_get_pc(uc) : NULL;
+
+  // retrieve crash address
+  address const addr = info ? (const address) info->si_addr : NULL;
+
+  // SafeFetch 32 handling:
+  // - make it work if _thread is null
+  // - make it use the standard os::...::ucontext_get/set_pc APIs
+  if (uc) {
+    address const pc = os::Bsd::ucontext_get_pc(uc);
+    if (pc && StubRoutines::is_safefetch_fault(pc)) {
+      uc->uc_mcontext.mc_srr0 = (unsigned long)StubRoutines::continuation_for_safefetch_fault(pc);
+      return true;
+    }
+  }
+
+  // Handle SIGDANGER right away. AIX would raise SIGDANGER whenever available swap
+  // space falls below 30%. This is only a chance for the process to gracefully abort.
+  // We can't hope to proceed after SIGDANGER since SIGKILL tailgates.
+  // if (sig == SIGDANGER) {
+  //  goto report_and_die;
+  // }
+
+  if (info == NULL || uc == NULL || thread == NULL && vmthread == NULL) {
+    goto run_chained_handler;
+  }
+
+  // If we are a java thread...
+  if (thread != NULL) {
+
+    // Handle ALL stack overflow variations here
+    if (sig == SIGSEGV && (addr < thread->stack_base() &&
+                           addr >= thread->stack_base() - thread->stack_size())) {
+      // stack overflow
+      //
+      // If we are in a yellow zone and we are inside java, we disable the yellow zone and
+      // throw a stack overflow exception.
+      // If we are in native code or VM C code, we report-and-die. The original coding tried
+      // to continue with yellow zone disabled, but that doesn't buy us much and prevents
+      // hs_err_pid files.
+      if (thread->in_stack_yellow_zone(addr)) {
+        thread->disable_stack_yellow_zone();
+        if (thread->thread_state() == _thread_in_Java) {
+          // Throw a stack overflow exception.
+          // Guard pages will be reenabled while unwinding the stack.
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
+          goto run_stub;
+        } else {
+          // Thread was in the vm or native code. Return and try to finish.
+          return 1;
+        }
+      } else if (thread->in_stack_red_zone(addr)) {
+        // Fatal red zone violation. Disable the guard pages and fall through
+        // to handle_unexpected_exception way down below.
+        thread->disable_stack_red_zone();
+        tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+        goto report_and_die;
+      } else {
+        // This means a segv happened inside our stack, but not in
+        // the guarded zone. I'd like to know when this happens,
+        tty->print_raw_cr("SIGSEGV happened inside stack but outside yellow and red zone.");
+        goto report_and_die;
+      }
+
+    } // end handle SIGSEGV inside stack boundaries
+
+    if (thread->thread_state() == _thread_in_Java) {
+      // Java thread running in Java code
+
+      // The following signals are used for communicating VM events:
+      //
+      // SIGILL: the compiler generates illegal opcodes
+      //   at places where it wishes to interrupt the VM:
+      //   Safepoints, Unreachable Code, Entry points of Zombie methods,
+      //    This results in a SIGILL with (*pc) == inserted illegal instruction.
+      //
+      //   (so, SIGILLs with a pc inside the zero page are real errors)
+      //
+      // SIGTRAP:
+      //   The ppc trap instruction raises a SIGTRAP and is very efficient if it
+      //   does not trap. It is used for conditional branches that are expected
+      //   to be never taken. These are:
+      //     - zombie methods
+      //     - IC (inline cache) misses.
+      //     - null checks leading to UncommonTraps.
+      //     - range checks leading to Uncommon Traps.
+      //   On Bsd, these are especially null checks, as the ImplicitNullCheck
+      //   optimization works only in rare cases, as the page at address 0 is only
+      //   write protected.      //
+      //   Note: !UseSIGTRAP is used to prevent SIGTRAPS altogether, to facilitate debugging.
+      //
+      // SIGSEGV:
+      //   used for safe point polling:
+      //     To notify all threads that they have to reach a safe point, safe point polling is used:
+      //     All threads poll a certain mapped memory page. Normally, this page has read access.
+      //     If the VM wants to inform the threads about impending safe points, it puts this
+      //     page to read only ("poisens" the page), and the threads then reach a safe point.
+      //   used for null checks:
+      //     If the compiler finds a store it uses it for a null check. Unfortunately this
+      //     happens rarely.  In heap based and disjoint base compressd oop modes also loads
+      //     are used for null checks.
+
+      // A VM-related SIGILL may only occur if we are not in the zero page.
+      // On AIX, we get a SIGILL if we jump to 0x0 or to somewhere else
+      // in the zero page, because it is filled with 0x0. We ignore
+      // explicit SIGILLs in the zero page.
+      if (sig == SIGILL && (pc < (address) 0x200)) {
+        if (TraceTraps) {
+          tty->print_raw_cr("SIGILL happened inside zero page.");
+        }
+        goto report_and_die;
+      }
+
+      // Handle signal from NativeJump::patch_verified_entry().
+      if (( TrapBasedNotEntrantChecks && sig == SIGTRAP && nativeInstruction_at(pc)->is_sigtrap_zombie_not_entrant()) ||
+          (!TrapBasedNotEntrantChecks && sig == SIGILL  && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant())) {
+        if (TraceTraps) {
+          tty->print_cr("trap: zombie_not_entrant (%s)", (sig == SIGTRAP) ? "SIGTRAP" : "SIGILL");
+        }
+        stub = SharedRuntime::get_handle_wrong_method_stub();
+        goto run_stub;
+      }
+
+      else if (sig == SIGSEGV && os::is_poll_address(addr)) {
+        if (TraceTraps) {
+          tty->print_cr("trap: safepoint_poll at " INTPTR_FORMAT " (SIGSEGV)", pc);
+        }
+        stub = SharedRuntime::get_poll_stub(pc);
+        goto run_stub;
+      }
+
+      // SIGTRAP-based ic miss check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedICMissChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_ic_miss_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: ic_miss_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::get_ic_miss_stub();
+        goto run_stub;
+      }
+
+      // SIGTRAP-based implicit null check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedNullChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_null_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: null_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+        goto run_stub;
+      }
+
+      // SIGSEGV-based implicit null check in compiled code.
+      else if (sig == SIGSEGV && ImplicitNullChecks &&
+               CodeCache::contains((void*) pc) &&
+               !MacroAssembler::needs_explicit_null_check((intptr_t) info->si_addr)) {
+        if (TraceTraps) {
+          tty->print_cr("trap: null_check at " INTPTR_FORMAT " (SIGSEGV)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+      }
+
+#ifdef COMPILER2
+      // SIGTRAP-based implicit range check in compiled code.
+      else if (sig == SIGTRAP && TrapBasedRangeChecks &&
+               nativeInstruction_at(pc)->is_sigtrap_range_check()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: range_check at " INTPTR_FORMAT " (SIGTRAP)", pc);
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+        goto run_stub;
+      }
+#endif
+
+      else if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
+        if (TraceTraps) {
+          tty->print_raw_cr("Fix SIGFPE handler, trying divide by zero handler.");
+        }
+        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
+        goto run_stub;
+      }
+
+      else if (sig == SIGBUS) {
+        // BugId 4454115: A read from a MappedByteBuffer can fault here if the
+        // underlying file has been truncated. Do not crash the VM in such a case.
+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
+        nmethod* nm = cb->is_nmethod() ? (nmethod*)cb : NULL;
+        if (nm != NULL && nm->has_unsafe_access()) {
+          // We don't really need a stub here! Just set the pending exeption and
+          // continue at the next instruction after the faulting read. Returning
+          // garbage from this read is ok.
+          thread->set_pending_unsafe_access_error();
+          uc->uc_mcontext.mc_srr0 = ((unsigned long)pc) + 4;
+          return 1;
+        }
+      }
+    }
+
+    else { // thread->thread_state() != _thread_in_Java
+      // Detect CPU features. This is only done at the very start of the VM. Later, the
+      // VM_Version::is_determine_features_test_running() flag should be false.
+
+      if (sig == SIGILL && VM_Version::is_determine_features_test_running()) {
+        // SIGILL must be caused by VM_Version::determine_features().
+        *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
+                        // flushing of icache is not necessary.
+        stub = pc + 4;  // continue with next instruction.
+        goto run_stub;
+      }
+      else if (thread->thread_state() == _thread_in_vm &&
+               sig == SIGBUS && thread->doing_unsafe_access()) {
+        // We don't really need a stub here! Just set the pending exeption and
+        // continue at the next instruction after the faulting read. Returning
+        // garbage from this read is ok.
+        thread->set_pending_unsafe_access_error();
+        uc->uc_mcontext.mc_srr0 = ((unsigned long)pc) + 4;
+        return 1;
+      }
+    }
+
+    // Check to see if we caught the safepoint code in the
+    // process of write protecting the memory serialization page.
+    // It write enables the page immediately after protecting it
+    // so we can just return to retry the write.
+    if ((sig == SIGSEGV) &&
+        os::is_memory_serialize_page(thread, addr)) {
+      // Synchronization problem in the pseudo memory barrier code (bug id 6546278)
+      // Block current thread until the memory serialize page permission restored.
+      os::block_on_serialize_page_trap();
+      return true;
+    }
+  }
+
+run_stub:
+
+  // One of the above code blocks ininitalized the stub, so we want to
+  // delegate control to that stub.
+  if (stub != NULL) {
+    // Save all thread context in case we need to restore it.
+    if (thread != NULL) thread->set_saved_exception_pc(pc);
+    uc->uc_mcontext.mc_srr0 = (unsigned long)stub;
+    return 1;
+  }
+
+run_chained_handler:
+
+  // signal-chaining
+  if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+    return 1;
+  }
+  if (!abort_if_unrecognized) {
+    // caller wants another chance, so give it to him
+    return 0;
+  }
+
+report_and_die:
+
+  // Use sigthreadmask instead of sigprocmask on AIX and unmask current signal.
+  sigset_t newset;
+  sigemptyset(&newset);
+  sigaddset(&newset, sig);
+  sigprocmask(SIG_UNBLOCK, &newset, NULL);
+
+  VMError err(t, sig, pc, info, ucVoid);
+  err.report_and_die();
+
+  ShouldNotReachHere();
+  return 0;
+}
+
+void os::Bsd::init_thread_fpu_state(void) {
+  // Disable FP exceptions.
+  __asm__ __volatile__ ("mtfsfi 6,0");
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// thread stack
+
+size_t os::Bsd::min_stack_allowed = 128*K;
+
+bool os::Bsd::supports_variable_stack_size() { return true; }
+
+// return default stack size for thr_type
+size_t os::Bsd::default_stack_size(os::ThreadType thr_type) {
+  // default stack size (compiler thread needs larger stack)
+  // Notice that the setting for compiler threads here have no impact
+  // because of the strange 'fallback logic' in os::create_thread().
+  // Better set CompilerThreadStackSize in globals_<os_cpu>.hpp if you want to
+  // specify a different stack size for compiler threads!
+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1024 * K);
+  return s;
+}
+
+size_t os::Bsd::default_guard_size(os::ThreadType thr_type) {
+  return 2 * page_size();
+}
+
+// Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\  JavaThread created by VM does not have glibc
+//    |    glibc guard page    | - guard, attached Java thread usually has
+//    |                        |/  1 page glibc guard.
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |  HotSpot Guard Pages   | - red and yellow pages
+//    |                        |/
+//    +------------------------+ JavaThread::stack_yellow_zone_base()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// Non-Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\
+//    |  glibc guard page      | - usually 1 page
+//    |                        |/
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
+//    pthread_attr_getstack()
+
+static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  // workaround for OS X 10.9.0 (Mavericks)
+  // pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages
+  if (pthread_main_np() == 1) {
+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {
+      char kern_osrelease[256];
+      size_t kern_osrelease_size = sizeof(kern_osrelease);
+      int ret = sysctlbyname("kern.osrelease", kern_osrelease, &kern_osrelease_size, NULL, 0);
+      if (ret == 0) {
+        // get the major number, atoi will ignore the minor amd micro portions of the version string
+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {
+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());
+        }
+      }
+    }
+  }
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_stackseg_np failed with err = %d", rslt));
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#else
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_init failed with err = %d", rslt));
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_get_np failed with err = %d", rslt));
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#endif
+  assert(os::current_stack_pointer() >= *bottom &&
+         os::current_stack_pointer() < *bottom + *size, "just checking");
+}
+
+address os::current_stack_base() {
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return (bottom + size);
+}
+
+size_t os::current_stack_size() {
+  // stack size includes normal stack and HotSpot guard pages
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// helper functions for fatal error handler
+
+void os::print_context(outputStream *st, void *context) {
+  if (context == NULL) return;
+
+  ucontext_t* uc = (ucontext_t*)context;
+
+  st->print_cr("Registers:");
+  st->print("pc =" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_srr0);
+  st->print("lr =" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_lr);
+  st->print("ctr=" INTPTR_FORMAT "  ", uc->uc_mcontext.mc_ctr);
+  st->cr();
+  for (int i = 0; i < 32; i++) {
+    st->print("r%-2d=" INTPTR_FORMAT "  ", i, uc->uc_mcontext.mc_gpr[i]);
+    if (i % 3 == 2) st->cr();
+  }
+  st->cr();
+  st->cr();
+
+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);
+  st->print_cr("Top of Stack: (sp=" PTR_FORMAT ")", p2i(sp));
+  print_hex_dump(st, (address)sp, (address)(sp + 128), sizeof(intptr_t));
+  st->cr();
+
+  // Note: it may be unsafe to inspect memory near pc. For example, pc may
+  // point to garbage if entry point in an nmethod is corrupted. Leave
+  // this at the end, and hope for the best.
+  address pc = os::Bsd::ucontext_get_pc(uc);
+  st->print_cr("Instructions: (pc=" PTR_FORMAT ")", p2i(pc));
+  print_hex_dump(st, pc - 64, pc + 64, /*instrsize=*/4);
+  st->cr();
+}
+
+void os::print_register_info(outputStream *st, void *context) {
+  if (context == NULL) return;
+
+  ucontext_t *uc = (ucontext_t*)context;
+
+  st->print_cr("Register to memory mapping:");
+  st->cr();
+
+  // this is only for the "general purpose" registers
+  for (int i = 0; i < 32; i++) {
+    st->print("r%-2d=", i);
+    print_location(st, uc->uc_mcontext.mc_gpr[i]);
+  }
+  st->cr();
+}
+
+extern "C" {
+  int SpinPause() {
+    return 0;
+  }
+}
+
+#ifndef PRODUCT
+void os::verify_stack_alignment() {
+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, "incorrect stack alignment");
+}
+#endif
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/os_bsd_ppc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
+
+  static void setup_fpu() {}
+
+  // Used to register dynamic code cache area with the OS
+  // Note: Currently only used in 64 bit Windows implementations
+  static bool register_code_area(char *low, char *high) { return true; }
+
+#endif // OS_CPU_BSD_PPC_VM_OS_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/prefetch_bsd_ppc.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+#define OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
+
+#include "runtime/prefetch.hpp"
+
+
+inline void Prefetch::read(void *loc, intx interval) {
+  __asm__ __volatile__ (
+    "   dcbt   0, %0       \n"
+    :
+    : /*%0*/"r" ( ((address)loc) +((long)interval) )
+    //:
+    );
+}
+
+inline void Prefetch::write(void *loc, intx interval) {
+  __asm__ __volatile__ (
+    "   dcbtst 0, %0       \n"
+    :
+    : /*%0*/"r" ( ((address)loc) +((long)interval) )
+    //:
+    );
+}
+
+#endif // OS_CPU_BSD_PPC_VM_PREFETCH_BSD_PPC_INLINE_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/threadLS_bsd_ppc.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/threadLocalStorage.hpp"
+
+void ThreadLocalStorage::generate_code_for_get_thread() {
+    // nothing we can do here for user-level thread
+}
+
+void ThreadLocalStorage::pd_init() {
+  // Nothing to do
+}
+
+void ThreadLocalStorage::pd_set_thread(Thread* thread) {
+  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/threadLS_bsd_ppc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
+
+  // Processor dependent parts of ThreadLocalStorage
+
+public:
+  static Thread* thread() {
+    return (Thread *) os::thread_local_storage_at(thread_index());
+  }
+
+#endif // OS_CPU_BSD_PPC_VM_THREADLS_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/thread_bsd_ppc.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2014 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/frame.hpp"
+#include "runtime/thread.hpp"
+
+// Forte Analyzer AsyncGetCallTrace profiling support is not implemented on Bsd/PPC.
+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava) {
+  Unimplemented();
+  return false;
+}
+
+void JavaThread::cache_global_variables() { }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/thread_bsd_ppc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
+
+ private:
+
+  void pd_initialize() {
+    _anchor.clear();
+    _last_interpreter_fp = NULL;
+  }
+
+  // The `last' frame is the youngest Java frame on the thread's stack.
+  frame pd_last_frame() {
+    assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
+
+    intptr_t* sp = last_Java_sp();
+    address pc = _anchor.last_Java_pc();
+
+    // Last_Java_pc ist not set, if we come here from compiled code.
+    if (pc == NULL) {
+      pc = (address) *(sp + 2);
+    }
+
+    return frame(sp, pc);
+  }
+
+ public:
+
+  void set_base_of_stack_pointer(intptr_t* base_sp) {}
+  intptr_t* base_of_stack_pointer() { return NULL; }
+  void record_base_of_stack_pointer() {}
+
+  // These routines are only used on cpu architectures that
+  // have separate register stacks (Itanium).
+  static bool register_stack_overflow() { return false; }
+  static void enable_register_stack_guard() {}
+  static void disable_register_stack_guard() {}
+
+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava);
+
+ protected:
+
+  // -Xprof support
+  //
+  // In order to find the last Java fp from an async profile
+  // tick, we store the current interpreter fp in the thread.
+  // This value is only valid while we are in the C++ interpreter
+  // and profiling.
+  intptr_t *_last_interpreter_fp;
+
+ public:
+
+  static ByteSize last_interpreter_fp_offset() {
+    return byte_offset_of(JavaThread, _last_interpreter_fp);
+  }
+
+  intptr_t* last_interpreter_fp() { return _last_interpreter_fp; }
+
+#endif // OS_CPU_BSD_PPC_VM_THREAD_BSD_PPC_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/os_cpu/bsd_ppc/vm/vmStructs_bsd_ppc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2012, 2013 SAP AG. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+#define OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
+
+// These are the OS and CPU-specific fields, types and integer
+// constants required by the Serviceability Agent. This file is
+// referenced by vmStructs.cpp.
+
+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \
+                                                                                                                                     \
+  /******************************/                                                                                                   \
+  /* Threads (NOTE: incomplete) */                                                                                                   \
+  /******************************/                                                                                                   \
+  nonstatic_field(OSThread,                      _thread_id,                                      pid_t)                             \
+  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)
+
+
+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \
+                                                                          \
+  /**********************/                                                \
+  /* Posix Thread IDs   */                                                \
+  /**********************/                                                \
+                                                                          \
+  declare_integer_type(pid_t)                                             \
+  declare_unsigned_integer_type(pthread_t)
+
+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#endif // OS_CPU_BSD_PPC_VM_VMSTRUCTS_BSD_PPC_HPP
--- ./hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -594,7 +594,11 @@
           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
       }
     } else if (thread->thread_state() == _thread_in_vm &&
+#ifdef __FreeBSD__
+               (sig == SIGBUS || sig == SIGSEGV) && 
+#else
                sig == SIGBUS && /* info->si_code == BUS_OBJERR && */
+#endif
                thread->doing_unsafe_access()) {
         stub = StubRoutines::handler_for_unsafe_access();
     }
--- ./hotspot/src/share/vm/opto/lcm.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/opto/lcm.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -49,7 +49,7 @@
 // Check whether val is not-null-decoded compressed oop,
 // i.e. will grab into the base of the heap if it represents NULL.
 static bool accesses_heap_base_zone(Node *val) {
-  if (Universe::narrow_oop_base() > 0) { // Implies UseCompressedOops.
+  if (Universe::narrow_oop_base() != NULL) { // Implies UseCompressedOops.
     if (val && val->is_Mach()) {
       if (val->as_Mach()->ideal_Opcode() == Op_DecodeN) {
         // This assumes all Decodes with TypePtr::NotNull are matched to nodes that
--- ./hotspot/src/share/vm/opto/loopPredicate.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/opto/loopPredicate.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -869,7 +869,7 @@
       Node*          idx    = cmp->in(1);
       assert(!invar.is_invariant(idx), "index is variant");
       Node* rng = cmp->in(2);
-      assert(rng->Opcode() == Op_LoadRange || _igvn.type(rng)->is_int() >= 0, "must be");
+      assert(rng->Opcode() == Op_LoadRange || _igvn.type(rng)->is_int()->_lo >= 0, "must be");
       assert(invar.is_invariant(rng), "range must be invariant");
       int scale    = 1;
       Node* offset = zero;
--- ./hotspot/src/share/vm/opto/node.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/opto/node.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -286,6 +286,10 @@
 #ifdef _MSC_VER // the IDX_INIT hack falls foul of warning C4355
 #pragma warning( disable:4355 ) // 'this' : used in base member initializer list
 #endif
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#endif
 
 // Out-of-line code from node constructors.
 // Executed only when extra debug info. is being passed around.
@@ -493,6 +497,10 @@
   _in[6] = n6; if (n6 != NULL) n6->add_out((Node *)this);
 }
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 
 //------------------------------clone------------------------------------------
 // Clone a Node.
--- ./hotspot/src/share/vm/prims/whitebox.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/prims/whitebox.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -158,7 +158,7 @@
 }
 WB_END
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include "utilities/elfFile.hpp"
 #endif
 
@@ -1016,7 +1016,7 @@
 // Checks that the library libfile has the noexecstack bit set.
 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
   jboolean ret = false;
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   // Can't be in VM when we call JNI.
   ThreadToNativeFromVM ttnfv(thread);
   const char* lf = env->GetStringUTFChars(libfile, NULL);
--- ./hotspot/src/share/vm/runtime/atomic.inline.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/atomic.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -63,6 +63,9 @@
 #endif
 
 // BSD
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "atomic_bsd_ppc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "atomic_bsd_x86.inline.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/globals.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/globals.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -94,6 +94,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "globals_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "globals_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "globals_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/orderAccess.inline.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/orderAccess.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -64,6 +64,9 @@
 #endif
 
 // BSD
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "orderAccess_bsd_ppc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "orderAccess_bsd_x86.inline.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/os.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/os.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -426,15 +426,6 @@
     if (_native_java_library == NULL) {
       vm_exit_during_initialization("Unable to load native library", ebuf);
     }
-
-#if defined(__OpenBSD__)
-    // Work-around OpenBSD's lack of $ORIGIN support by pre-loading libnet.so
-    // ignore errors
-    if (dll_build_name(buffer, sizeof(buffer), Arguments::get_dll_dir(),
-                       "net")) {
-      dll_load(buffer, ebuf, sizeof(ebuf));
-    }
-#endif
   }
   static jboolean onLoaded = JNI_FALSE;
   if (onLoaded) {
--- ./hotspot/src/share/vm/runtime/os.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/os.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -843,6 +843,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "os_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "os_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "os_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/prefetch.inline.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/prefetch.inline.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -63,6 +63,9 @@
 #endif
 
 // BSD
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "prefetch_bsd_ppc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "prefetch_bsd_x86.inline.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/thread.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/thread.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -1730,6 +1730,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "thread_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "thread_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "thread_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/threadLocalStorage.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/threadLocalStorage.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -75,6 +75,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "threadLS_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "threadLS_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "threadLS_bsd_x86.hpp"
 #endif
--- ./hotspot/src/share/vm/runtime/virtualspace.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/virtualspace.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -342,7 +342,7 @@
                 (UseCompressedOops && (Universe::narrow_oop_base() != NULL) &&
                  Universe::narrow_oop_use_implicit_null_checks()) ?
                   lcm(os::vm_page_size(), alignment) : 0) {
-  if (base() > 0) {
+  if (base() != NULL) {
     MemTracker::record_virtual_memory_type((address)base(), mtJavaHeap);
   }
 
--- ./hotspot/src/share/vm/runtime/vmStructs.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/runtime/vmStructs.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -146,6 +146,9 @@
 #ifdef TARGET_OS_ARCH_aix_ppc
 # include "vmStructs_aix_ppc.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "vmStructs_bsd_ppc.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_x86
 # include "vmStructs_bsd_x86.hpp"
 #endif
@@ -2556,6 +2559,8 @@
   /**********************/                                                \
   /* frame              */                                                \
   /**********************/                                                \
+  NOT_ZERO(PPC64_ONLY(declare_constant(frame::abi_minframe_size)))        \
+  NOT_ZERO(PPC64_ONLY(declare_constant(frame::entry_frame_locals_size)))  \
                                                                           \
   NOT_ZERO(X86_ONLY(declare_constant(frame::entry_frame_call_wrapper_offset)))      \
   declare_constant(frame::pc_return_offset)                               \
--- ./hotspot/src/share/vm/services/mallocSiteTable.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/services/mallocSiteTable.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -42,7 +42,7 @@
 
  public:
   MallocSite() :
-    AllocationSite<MemoryCounter>(NativeCallStack::EMPTY_STACK), _flags(mtNone) {}
+    AllocationSite<MemoryCounter>(NativeCallStack::EMPTY_STACK()), _flags(mtNone) {}
 
   MallocSite(const NativeCallStack& stack, MEMFLAGS flags) :
     AllocationSite<MemoryCounter>(stack), _flags(flags) {}
--- ./hotspot/src/share/vm/services/memTracker.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/services/memTracker.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -67,10 +67,6 @@
     os::unsetenv(buf);
   }
 
-  // Construct NativeCallStack::EMPTY_STACK. It may get constructed twice,
-  // but it is benign, the results are the same.
-  ::new ((void*)&NativeCallStack::EMPTY_STACK) NativeCallStack(0, false);
-
   if (!MallocTracker::initialize(level) ||
       !VirtualMemoryTracker::initialize(level)) {
     level = NMT_off;
--- ./hotspot/src/share/vm/services/memTracker.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/services/memTracker.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -31,8 +31,8 @@
 
 #if !INCLUDE_NMT
 
-#define CURRENT_PC   NativeCallStack::EMPTY_STACK
-#define CALLER_PC    NativeCallStack::EMPTY_STACK
+#define CURRENT_PC   NativeCallStack::EMPTY_STACK()
+#define CALLER_PC    NativeCallStack::EMPTY_STACK()
 
 class Tracker : public StackObj {
  public:
@@ -83,9 +83,9 @@
 extern volatile bool NMT_stack_walkable;
 
 #define CURRENT_PC ((MemTracker::tracking_level() == NMT_detail && NMT_stack_walkable) ? \
-                    NativeCallStack(0, true) : NativeCallStack::EMPTY_STACK)
+                    NativeCallStack(0, true) : NativeCallStack::EMPTY_STACK())
 #define CALLER_PC  ((MemTracker::tracking_level() == NMT_detail && NMT_stack_walkable) ?  \
-                    NativeCallStack(1, true) : NativeCallStack::EMPTY_STACK)
+                    NativeCallStack(1, true) : NativeCallStack::EMPTY_STACK())
 
 class MemBaseline;
 class Mutex;
--- ./hotspot/src/share/vm/services/virtualMemoryTracker.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/services/virtualMemoryTracker.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -167,7 +167,7 @@
           // higher part
           address high_base = addr + sz;
           size_t  high_size = top - high_base;
-          CommittedMemoryRegion high_rgn(high_base, high_size, NativeCallStack::EMPTY_STACK);
+          CommittedMemoryRegion high_rgn(high_base, high_size, NativeCallStack::EMPTY_STACK());
           return add_committed_region(high_rgn);
         } else {
           return false;
--- ./hotspot/src/share/vm/services/virtualMemoryTracker.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/services/virtualMemoryTracker.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -305,7 +305,7 @@
 
 
   ReservedMemoryRegion(address base, size_t size) :
-    VirtualMemoryRegion(base, size), _stack(NativeCallStack::EMPTY_STACK), _flag(mtNone),
+    VirtualMemoryRegion(base, size), _stack(NativeCallStack::EMPTY_STACK()), _flag(mtNone),
     _all_committed(false) { }
 
   // Copy constructor
--- ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -30,6 +30,11 @@
 // This file holds compiler-dependent includes,
 // globally used constants & types, class (forward)
 // declarations and a few frequently used utility functions.
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif // __STDC_LIMIT_MACROS
+#endif
 
 #include <ctype.h>
 #include <string.h>
@@ -69,9 +74,6 @@
 # endif
 
 #if defined(LINUX) || defined(_ALLBSD_SOURCE)
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS
-#endif // __STDC_LIMIT_MACROS
 #include <inttypes.h>
 #include <signal.h>
 #ifndef __OpenBSD__
@@ -242,7 +244,7 @@
 #endif
 
 // GCC 4.3 does not allow 0.0/0.0 to produce a NAN value
-#if (__GNUC__ == 4) && (__GNUC_MINOR__ > 2)
+#if defined(__clang__) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 2))
 #define CAN_USE_NAN_DEFINE 1
 #endif
 
--- ./hotspot/src/share/vm/utilities/nativeCallStack.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/utilities/nativeCallStack.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -27,7 +27,10 @@
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/nativeCallStack.hpp"
 
-const NativeCallStack NativeCallStack::EMPTY_STACK(0, false);
+const NativeCallStack& NativeCallStack::EMPTY_STACK() {
+  static const NativeCallStack empty(0, false);
+  return empty;
+}
 
 NativeCallStack::NativeCallStack(int toSkip, bool fillStack) :
   _hash_value(0) {
--- ./hotspot/src/share/vm/utilities/nativeCallStack.hpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/utilities/nativeCallStack.hpp	Mon Sep 03 11:13:04 2018 -0700
@@ -53,7 +53,7 @@
  */
 class NativeCallStack : public StackObj {
  public:
-  static const NativeCallStack EMPTY_STACK;
+  static const NativeCallStack& EMPTY_STACK();
 
  private:
   address   _stack[NMT_TrackingStackDepth];
--- ./hotspot/src/share/vm/utilities/vmError.cpp	Sat Jun 23 21:01:40 2018 -0700
+++ ./hotspot/src/share/vm/utilities/vmError.cpp	Mon Sep 03 11:13:04 2018 -0700
@@ -22,7 +22,6 @@
  *
  */
 
-#include <fcntl.h>
 #include "precompiled.hpp"
 #include "compiler/compileBroker.hpp"
 #include "gc_interface/collectedHeap.hpp"
--- ./jdk/make/CompileDemos.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/CompileDemos.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -323,7 +323,7 @@
 $(eval $(call SetupJVMTIDemo,hprof, java_crw_demo, \
     -I$(JDK_TOPDIR)/src/share/npt -I$(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/npt \
     $(BUILD_LIBHPROF_AIX_EXTRA_CFLAGS), C, \
-    -ldl, ws2_32.lib winmm.lib, -lsocket -lnsl, -lpthread, $(BUILD_LIBHPROF_AIX_EXTRA_SRC)))
+    $(LIBDL), ws2_32.lib winmm.lib, -lsocket -lnsl, -lpthread, $(BUILD_LIBHPROF_AIX_EXTRA_SRC)))
 
 $(eval $(call SetupJVMTIDemo,minst, agent_util java_crw_demo))
 $(eval $(call SetupJVMTIDemo,mtrace, agent_util java_crw_demo))
--- ./jdk/make/CompileJavaClasses.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/CompileJavaClasses.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -128,23 +128,32 @@
       sun/nio/fs/LinuxFileStore.java \
       sun/nio/fs/LinuxFileSystem.java \
       sun/nio/fs/LinuxFileSystemProvider.java \
-      sun/nio/fs/MagicFileTypeDetector.java \
       sun/nio/fs/LinuxNativeDispatcher.java \
       sun/nio/fs/LinuxUserDefinedFileAttributeView.java \
       sun/nio/fs/LinuxWatchService.java
 endif
 
+ifeq (, $(filter $(OPENJDK_TARGET_OS), linux bsd))
+  EXFILES += sun/nio/fs/MagicFileTypeDetector.java
+endif
+
 ifneq ($(OPENJDK_TARGET_OS), macosx)
+  EXFILES += sun/nio/fs/MacOSXFileSystemProvider.java \
+      sun/nio/fs/MacOSXFileSystem.java \
+      sun/nio/fs/MacOSXNativeDispatcher.java
+endif
+
+ifeq (, $(filter $(OPENJDK_TARGET_OS), bsd macosx))
   EXFILES += sun/nio/ch/BsdAsynchronousChannelProvider.java \
       sun/nio/ch/KQueue.java \
+      sun/nio/ch/KQueueArrayWrapper.java \
       sun/nio/ch/KQueuePort.java \
+      sun/nio/ch/KQueueSelectorImpl.java \
+      sun/nio/ch/KQueueSelectorProvider.java \
       sun/nio/fs/BsdFileStore.java \
       sun/nio/fs/BsdFileSystem.java \
       sun/nio/fs/BsdFileSystemProvider.java \
       sun/nio/fs/BsdNativeDispatcher.java \
-      sun/nio/fs/MacOSXFileSystemProvider.java \
-      sun/nio/fs/MacOSXFileSystem.java \
-      sun/nio/fs/MacOSXNativeDispatcher.java \
       sun/tools/attach/BsdAttachProvider.java \
       sun/tools/attach/BsdVirtualMachine.java
 endif
@@ -231,9 +240,9 @@
 # Exclude another implicitly not included file.
 EXFILES += sun/util/locale/AsciiUtil.java
 
-ifeq (, $(filter $(OPENJDK_TARGET_OS), solaris macosx aix))
+ifeq (, $(filter $(OPENJDK_TARGET_OS), solaris bsd macosx aix))
   #
-  # only solaris, macosx and aix
+  # only solaris, BSD, macosx and aix
   #
   EXFILES += sun/nio/fs/PollingWatchService.java
 endif
@@ -268,21 +277,26 @@
       $(wildcard $(JDK_TOPDIR)/src/closed/$(OPENJDK_TARGET_OS_API_DIR)/classes)
 endif
 
-MACOSX_SRC_DIRS :=
-ifeq ($(OPENJDK_TARGET_OS), macosx)
-  MACOSX_SRC_DIRS += $(JDK_TOPDIR)/src/macosx/classes
+BSD_SRC_DIRS :=
+ifneq (, $(filter $(OPENJDK_TARGET_OS), bsd macosx))
+  BSD_SRC_DIRS += $(JDK_TOPDIR)/src/bsd/classes
 
-  # this files are duplicated in MACOSX_SRC_DIRS
-  EXFILES += $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java \
-      $(JDK_TOPDIR)/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java \
-      $(JDK_TOPDIR)/src/solaris/classes/java/net/DefaultInterface.java \
+  # these files are duplicated in BSD_SRC_DIRS
+  EXFILES += $(JDK_TOPDIR)/src/solaris/classes/java/net/DefaultInterface.java \
+      $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
+endif
+
+ifeq ($(OPENJDK_TARGET_OS), macosx)
+  BSD_SRC_DIRS += $(JDK_TOPDIR)/src/macosx/classes
+
+  # these files are duplicated in BSD_SRC_DIRS
+  EXFILES += $(JDK_TOPDIR)/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java \
       $(JDK_TOPDIR)/src/solaris/classes/java/lang/ClassLoaderHelper.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/util/locale/provider/HostLocaleProviderAdapterImpl.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/fs/GnomeFileTypeDetector.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/sctp/SctpChannelImpl.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/sctp/SctpMultiChannelImpl.java \
       $(JDK_TOPDIR)/src/solaris/classes/sun/nio/ch/sctp/SctpServerChannelImpl.java
-
 endif
 
 # The security classes should not end up in the classes directory as that will prevent them
@@ -332,6 +346,7 @@
     SRC:=$(JDK_TOPDIR)/src/share/classes \
         $(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/classes \
         $(MACOSX_SRC_DIRS) \
+        $(BSD_SRC_DIRS) \
         $(AIX_SRC_DIRS) \
         $(JDK_OUTPUTDIR)/gensrc \
         $(JDK_OUTPUTDIR)/gensrc_no_srczip \
@@ -351,7 +366,7 @@
     SETUP := GENERATE_JDKBYTECODE, \
     SRC := $(JDK_TOPDIR)/src/share/classes \
         $(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/classes \
-        $(MACOSX_SRC_DIRS) \
+        $(BSD_SRC_DIRS) \
         $(CLOSED_SRC_DIRS), \
     INCLUDES := $(SECURITY_PKGS), \
     EXCLUDES := $(EXCLUDES), \
--- ./jdk/make/CompileLaunchers.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/CompileLaunchers.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -49,7 +49,7 @@
   ORIGIN_ROOT := /..
 endif
 
-ifeq ($(OPENJDK_TARGET_OS), macosx)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx), )
   ORIGIN_ARG := $(call SET_EXECUTABLE_ORIGIN)
 else
   ORIGIN_ARG := $(call SET_EXECUTABLE_ORIGIN,$(ORIGIN_ROOT)/lib$(OPENJDK_TARGET_CPU_LIBDIR)/jli)
@@ -60,7 +60,7 @@
 # System.loadLibrary("jawt") first. This was the behaviour described in the
 # devloper documentation of JAWT and what worked with OpenJDK6.
 #
-ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris bsd), )
   ORIGIN_ARG += $(call SET_EXECUTABLE_ORIGIN,$(ORIGIN_ROOT)/lib$(OPENJDK_TARGET_CPU_LIBDIR))
 endif
 
@@ -89,6 +89,18 @@
 
   $1_LDFLAGS := $3
   $1_LDFLAGS_SUFFIX :=
+  ifeq ($(OPENJDK_TARGET_OS), bsd)
+    ifeq ($(BSD_STATIC_LIBJLI), bsd)
+      $1_LDFLAGS += -Wl,--whole-archive $(JDK_OUTPUTDIR)/objs/libjli_static.a \
+          -Wl,--no-whole-archive
+      $1_LDFLAGS_SUFFIX += -pthread
+    else
+      $1_LDFLAGS += \
+          $(call SET_SHARED_LIBRARY_NAME,$(LIBRARY_PREFIX)$(SHARED_LIBRARY_SUFFIX))
+      $1_LDFLAGS_SUFFIX += -L$(JDK_OUTPUTDIR)/lib$(OPENJDK_TARGET_CPU_LIBDIR)/jli -ljli -pthread
+    endif
+  endif
+
   ifeq ($(OPENJDK_TARGET_OS), macosx)
     $1_PLIST_FILE := Info-cmdline.plist
     ifneq ($(11), )
@@ -162,9 +174,11 @@
           -DLIBARCHNAME='"$(OPENJDK_TARGET_CPU_LEGACY)"' \
           -DLAUNCHER_NAME='"$(LAUNCHER_NAME)"' \
           -DPROGNAME='"$1"' $(DPACKAGEPATH) \
+          -DPACKAGE_PATH='"$(PACKAGE_PATH)"' \
           $2, \
       CFLAGS_linux := -fPIC, \
       CFLAGS_solaris := -KPIC -DHAVE_GETHRTIME, \
+      CFLAGS_bsd := -fPIC, \
       LDFLAGS := $(LDFLAGS_JDKEXE) \
           $(ORIGIN_ARG) \
           $$($1_LDFLAGS), \
@@ -195,7 +209,7 @@
 
   BUILD_LAUNCHERS += $$(BUILD_LAUNCHER_$1)
 
-  ifneq (,$(filter $(OPENJDK_TARGET_OS), macosx aix))
+  ifneq (,$(filter $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx aix))
     $$(BUILD_LAUNCHER_$1): $(JDK_OUTPUTDIR)/objs/libjli_static.a
   endif
 
@@ -476,6 +490,7 @@
     CFLAGS_release := -DPRODUCT, \
     CFLAGS_linux := -fPIC, \
     CFLAGS_solaris := -KPIC, \
+    CFLAGS_bsd := -fPIC, \
     CFLAGS_macosx := -fPIC, \
     MAPFILE := $(UNPACK_MAPFILE),\
     LDFLAGS := $(UNPACKEXE_ZIPOBJS), \
@@ -538,7 +553,7 @@
   endif
 endif
 
-ifeq ($(OPENJDK_TARGET_OS), linux)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux bsd), )
   BUILD_JEXEC := 1
 endif # OPENJDK_TARGET_OS
 
@@ -574,6 +589,7 @@
           $(BUILD_JEXEC_INC), \
       CFLAGS_linux := -fPIC, \
       CFLAGS_solaris := -KPIC, \
+      CFLAGS_bsd := -fPIC, \
       LDFLAGS := $(LDFLAGS_JDKEXE) \
           $(call SET_SHARED_LIBRARY_NAME,$(LIBRARY_PREFIX)$(SHARED_LIBRARY_SUFFIX)), \
       OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/jexec_obj, \
@@ -590,10 +606,7 @@
 # The java-rmi.cgi script in bin/ only gets delivered in certain situations
 #
 JAVA_RMI_CGI := $(JDK_OUTPUTDIR)/bin$(OUTPUT_SUBDIR)/java-rmi.cgi
-ifeq ($(OPENJDK_TARGET_OS), linux)
-  BUILD_LAUNCHERS += $(JAVA_RMI_CGI)
-endif
-ifeq ($(OPENJDK_TARGET_OS), solaris)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris bsd), )
   BUILD_LAUNCHERS += $(JAVA_RMI_CGI)
 endif
 
@@ -621,7 +634,7 @@
 LINK_JSPAWNHELPER_OBJECTS := $(JDK_OUTPUTDIR)/objs/libjava/childproc.o
 LINK_JSPAWNHELPER_FLAGS :=
 
-ifneq ($(findstring $(OPENJDK_TARGET_OS), macosx solaris aix), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), bsd macosx solaris aix), )
   BUILD_JSPAWNHELPER := 1
 endif
 
--- ./jdk/make/CopyFiles.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/CopyFiles.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -29,6 +29,8 @@
 
 ifeq ($(OPENJDK_TARGET_OS), windows)
   OPENJDK_TARGET_OS_INCLUDE = $(INCLUDEDIR)/win32
+else ifeq ($(OPENJDK_TARGET_OS), bsd)
+  OPENJDK_TARGET_OS_INCLUDE = $(INCLUDEDIR)/$(shell uname -s | ${TR} "[:upper:]" "[:lower:]")
 else ifeq ($(OPENJDK_TARGET_OS), macosx)
   OPENJDK_TARGET_OS_INCLUDE = $(INCLUDEDIR)/darwin
 endif
@@ -323,23 +325,23 @@
 	$(RM) $(@)
         # Now check for other permutations
         ifeq ($(JVM_VARIANT_SERVER), true)
-	  $(PRINTF) "-server KNOWN\n">>$(@)
-	  $(PRINTF) "-client ALIASED_TO -server\n">>$(@)
+	  $(PRINTF) -- "-server KNOWN\n">>$(@)
+	  $(PRINTF) -- "-client ALIASED_TO -server\n">>$(@)
           ifeq ($(JVM_VARIANT_MINIMAL1), true)
-	    $(PRINTF) "-minimal KNOWN\n">>$(@)
+	    $(PRINTF) -- "-minimal KNOWN\n">>$(@)
           endif
         else
           ifeq ($(JVM_VARIANT_CLIENT), true)
-	    $(PRINTF) "-client KNOWN\n">>$(@)
-	    $(PRINTF) "-server ALIASED_TO -client\n">>$(@)
+	    $(PRINTF) -- "-client KNOWN\n">>$(@)
+	    $(PRINTF) -- "-server ALIASED_TO -client\n">>$(@)
             ifeq ($(JVM_VARIANT_MINIMAL1), true)
-	      $(PRINTF) "-minimal KNOWN\n">>$(@)
+	      $(PRINTF) -- "-minimal KNOWN\n">>$(@)
             endif
           else
             ifeq ($(JVM_VARIANT_MINIMAL1), true)
-	      $(PRINTF) "-minimal KNOWN\n">>$(@)
-	      $(PRINTF) "-server ALIASED_TO -minimal\n">>$(@)
-	      $(PRINTF) "-client ALIASED_TO -minimal\n">>$(@)
+	      $(PRINTF) -- "-minimal KNOWN\n">>$(@)
+	      $(PRINTF) -- "-server ALIASED_TO -minimal\n">>$(@)
+	      $(PRINTF) -- "-client ALIASED_TO -minimal\n">>$(@)
             endif
           endif
         endif
--- ./jdk/make/Images.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/Images.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -236,11 +236,11 @@
 endif
 
 JDK_LIB_FILES := $(NOT_JRE_LIB_FILES)
-ifeq ($(OPENJDK_TARGET_OS), linux)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux bsd),)
   JDK_LIB_FILES += jexec
 endif
 
-ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris),) # If Linux or Solaris
+ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris bsd),) # If Linux, Solaris, or BSD
     JDK_LIB_FILES += $(LIBRARY_PREFIX)jli$(SHARED_LIBRARY_SUFFIX) \
 		     $(LIBRARY_PREFIX)jawt$(SHARED_LIBRARY_SUFFIX)
 endif
@@ -391,7 +391,7 @@
     MAN_SRC_DIR = $(MAN_SRC_BASEDIR)/solaris/doc
     MAN1_SUBDIR = sun/man/man1
   endif
-  ifeq ($(OPENJDK_TARGET_OS), macosx)
+  ifneq ($(findstring $(OPENJDK_TARGET_OS), bsd macosx),)
     MAN_SRC_DIR = $(MAN_SRC_BASEDIR)/bsd/doc
     MAN1_SUBDIR = man
   endif
@@ -447,7 +447,7 @@
 	$(install-file)
   endif
 
-  ifeq ($(OPENJDK_TARGET_OS), linux)
+  ifneq ($(findstring $(OPENJDK_TARGET_OS), linux bsd macosx),)
     $(JRE_IMAGE_DIR)/man/ja:
 	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
 	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
@@ -455,19 +455,7 @@
     $(JDK_IMAGE_DIR)/man/ja:
 	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
 	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
-  endif
 
-  ifeq ($(OPENJDK_TARGET_OS), macosx)
-    $(JRE_IMAGE_DIR)/man/ja:
-	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
-	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
-
-    $(JDK_IMAGE_DIR)/man/ja:
-	$(ECHO) $(LOG_INFO) Creating $(patsubst $(OUTPUT_ROOT)/%,%,$@)
-	$(CD) $(@D) && $(RM) ja && $(LN) -s ja_JP.UTF-8 ja
-  endif
-
-  ifeq ($(OPENJDK_TARGET_OS), linux)
     JRE_MAN_PAGE_LIST = $(addprefix $(JRE_IMAGE_DIR)/man/man1/, $(JRE_MAN_PAGES)) \
         $(addprefix $(JRE_IMAGE_DIR)/man/ja_JP.UTF-8/man1/, $(JRE_MAN_PAGES)) \
         $(JRE_IMAGE_DIR)/man/ja
@@ -489,16 +477,6 @@
         $(addprefix $(JDK_IMAGE_DIR)/man/ja_JP.PCK/man1/, $(JDK_MAN_PAGES))
   endif
 
-  ifeq ($(OPENJDK_TARGET_OS), macosx)
-    JRE_MAN_PAGE_LIST = $(addprefix $(JRE_IMAGE_DIR)/man/man1/, $(JRE_MAN_PAGES)) \
-        $(addprefix $(JRE_IMAGE_DIR)/man/ja_JP.UTF-8/man1/, $(JRE_MAN_PAGES)) \
-        $(JRE_IMAGE_DIR)/man/ja
-
-    JDK_MAN_PAGE_LIST = $(addprefix $(JDK_IMAGE_DIR)/man/man1/, $(JDK_MAN_PAGES)) \
-        $(addprefix $(JDK_IMAGE_DIR)/man/ja_JP.UTF-8/man1/, $(JDK_MAN_PAGES)) \
-        $(JDK_IMAGE_DIR)/man/ja
-  endif
-
 endif # Windows
 
 ################################################################################
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/data/classlist/classlist.bsd	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,2559 @@
+java/lang/Object
+java/lang/String
+java/io/Serializable
+java/lang/Comparable
+java/lang/CharSequence
+java/lang/Class
+java/lang/reflect/GenericDeclaration
+java/lang/reflect/AnnotatedElement
+java/lang/reflect/Type
+java/lang/Cloneable
+java/lang/ClassLoader
+java/lang/System
+java/lang/Throwable
+java/lang/Error
+java/lang/ThreadDeath
+java/lang/Exception
+java/lang/RuntimeException
+java/lang/SecurityManager
+java/security/ProtectionDomain
+java/security/AccessControlContext
+java/security/SecureClassLoader
+java/lang/ClassNotFoundException
+java/lang/ReflectiveOperationException
+java/lang/NoClassDefFoundError
+java/lang/LinkageError
+java/lang/ClassCastException
+java/lang/ArrayStoreException
+java/lang/VirtualMachineError
+java/lang/OutOfMemoryError
+java/lang/StackOverflowError
+java/lang/IllegalMonitorStateException
+java/lang/ref/Reference
+java/lang/ref/SoftReference
+java/lang/ref/WeakReference
+java/lang/ref/FinalReference
+java/lang/ref/PhantomReference
+sun/misc/Cleaner
+java/lang/ref/Finalizer
+java/lang/Thread
+java/lang/Runnable
+java/lang/ThreadGroup
+java/lang/Thread$UncaughtExceptionHandler
+java/util/Properties
+java/util/Hashtable
+java/util/Map
+java/util/Dictionary
+java/lang/reflect/AccessibleObject
+java/lang/reflect/Field
+java/lang/reflect/Member
+java/lang/reflect/Parameter
+java/lang/reflect/Method
+java/lang/reflect/Executable
+java/lang/reflect/Constructor
+sun/reflect/MagicAccessorImpl
+sun/reflect/MethodAccessorImpl
+sun/reflect/MethodAccessor
+sun/reflect/ConstructorAccessorImpl
+sun/reflect/ConstructorAccessor
+sun/reflect/DelegatingClassLoader
+sun/reflect/ConstantPool
+sun/reflect/UnsafeStaticFieldAccessorImpl
+sun/reflect/UnsafeFieldAccessorImpl
+sun/reflect/FieldAccessorImpl
+sun/reflect/FieldAccessor
+sun/reflect/CallerSensitive
+java/lang/annotation/Annotation
+java/lang/invoke/DirectMethodHandle
+java/lang/invoke/MethodHandle
+java/lang/invoke/MemberName
+java/lang/invoke/MethodHandleNatives
+java/lang/invoke/LambdaForm
+java/lang/invoke/MethodType
+java/lang/BootstrapMethodError
+java/lang/invoke/CallSite
+java/lang/invoke/ConstantCallSite
+java/lang/invoke/MutableCallSite
+java/lang/invoke/VolatileCallSite
+java/lang/StringBuffer
+java/lang/AbstractStringBuilder
+java/lang/Appendable
+java/lang/StringBuilder
+sun/misc/Unsafe
+java/io/ByteArrayInputStream
+java/io/InputStream
+java/io/Closeable
+java/lang/AutoCloseable
+java/io/File
+java/net/URLClassLoader
+java/net/URL
+java/util/jar/Manifest
+sun/misc/Launcher
+sun/misc/Launcher$AppClassLoader
+sun/misc/Launcher$ExtClassLoader
+java/security/CodeSource
+java/lang/StackTraceElement
+java/nio/Buffer
+java/lang/Boolean
+java/lang/Character
+java/lang/Float
+java/lang/Number
+java/lang/Double
+java/lang/Byte
+java/lang/Short
+java/lang/Integer
+java/lang/Long
+java/lang/NullPointerException
+java/lang/ArithmeticException
+java/io/ObjectStreamField
+java/lang/String$CaseInsensitiveComparator
+java/util/Comparator
+java/lang/RuntimePermission
+java/security/BasicPermission
+java/security/Permission
+java/security/Guard
+java/security/AccessController
+java/lang/reflect/ReflectPermission
+sun/reflect/ReflectionFactory$GetReflectionFactoryAction
+java/security/PrivilegedAction
+java/security/cert/Certificate
+java/util/Vector
+java/util/List
+java/util/Collection
+java/lang/Iterable
+java/util/RandomAccess
+java/util/AbstractList
+java/util/AbstractCollection
+java/util/Stack
+sun/reflect/ReflectionFactory
+java/lang/ref/Reference$Lock
+java/lang/ref/Reference$ReferenceHandler
+java/lang/ref/ReferenceQueue
+java/lang/ref/ReferenceQueue$Null
+java/lang/ref/ReferenceQueue$Lock
+java/lang/ref/Finalizer$FinalizerThread
+sun/misc/VM
+java/util/Hashtable$Entry
+java/util/Map$Entry
+java/lang/Math
+java/nio/charset/Charset
+sun/nio/cs/StandardCharsets
+sun/nio/cs/FastCharsetProvider
+java/nio/charset/spi/CharsetProvider
+sun/nio/cs/StandardCharsets$Aliases
+sun/util/PreHashedMap
+java/util/AbstractMap
+sun/nio/cs/StandardCharsets$Classes
+sun/nio/cs/StandardCharsets$Cache
+java/lang/ThreadLocal
+java/util/concurrent/atomic/AtomicInteger
+java/lang/NoSuchMethodError
+java/lang/IncompatibleClassChangeError
+java/util/ArrayList
+java/util/Collections
+java/util/Collections$EmptySet
+java/util/AbstractSet
+java/util/Set
+java/util/Collections$EmptyList
+java/util/Collections$EmptyMap
+java/util/Collections$UnmodifiableRandomAccessList
+java/util/Collections$UnmodifiableList
+java/util/Collections$UnmodifiableCollection
+sun/reflect/Reflection
+java/util/HashMap
+java/util/HashMap$Node
+java/lang/Class$3
+java/lang/Class$ReflectionData
+java/lang/Class$Atomic
+sun/reflect/generics/repository/ClassRepository
+sun/reflect/generics/repository/GenericDeclRepository
+sun/reflect/generics/repository/AbstractRepository
+java/lang/Class$AnnotationData
+sun/reflect/annotation/AnnotationType
+java/lang/ClassValue$ClassValueMap
+java/util/WeakHashMap
+java/lang/reflect/Modifier
+java/lang/reflect/ReflectAccess
+sun/reflect/LangReflectAccess
+java/util/Arrays
+sun/nio/cs/UTF_8
+sun/nio/cs/Unicode
+sun/nio/cs/HistoricallyNamedCharset
+java/lang/Class$1
+sun/reflect/ReflectionFactory$1
+sun/reflect/NativeConstructorAccessorImpl
+sun/reflect/DelegatingConstructorAccessorImpl
+java/lang/StringCoding
+java/lang/ThreadLocal$ThreadLocalMap
+java/lang/ThreadLocal$ThreadLocalMap$Entry
+java/lang/StringCoding$StringDecoder
+sun/nio/cs/UTF_8$Decoder
+sun/nio/cs/ArrayDecoder
+java/nio/charset/CharsetDecoder
+java/nio/charset/CodingErrorAction
+java/util/Hashtable$EntrySet
+java/util/Collections$SynchronizedSet
+java/util/Collections$SynchronizedCollection
+java/util/Objects
+java/util/Hashtable$Enumerator
+java/util/Enumeration
+java/util/Iterator
+java/lang/Runtime
+sun/misc/Version
+java/io/FileInputStream
+java/io/FileDescriptor
+java/io/FileDescriptor$1
+sun/misc/JavaIOFileDescriptorAccess
+sun/misc/SharedSecrets
+java/io/FileOutputStream
+java/io/OutputStream
+java/io/Flushable
+java/io/BufferedInputStream
+java/io/FilterInputStream
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl$1
+java/security/PrivilegedExceptionAction
+sun/reflect/misc/ReflectUtil
+java/io/PrintStream
+java/io/FilterOutputStream
+java/io/BufferedOutputStream
+java/io/OutputStreamWriter
+java/io/Writer
+sun/nio/cs/StreamEncoder
+sun/security/action/GetPropertyAction
+sun/nio/cs/UTF_8$Encoder
+sun/nio/cs/ArrayEncoder
+java/nio/charset/CharsetEncoder
+java/nio/ByteBuffer
+java/nio/HeapByteBuffer
+java/nio/Bits
+java/nio/ByteOrder
+java/nio/Bits$1
+sun/misc/JavaNioAccess
+java/io/BufferedWriter
+java/io/DefaultFileSystem
+java/io/UnixFileSystem
+java/io/FileSystem
+java/io/ExpiringCache
+java/io/ExpiringCache$1
+java/util/LinkedHashMap
+java/io/File$PathStatus
+java/lang/Enum
+java/nio/file/Path
+java/nio/file/Watchable
+java/lang/StringCoding$StringEncoder
+java/lang/ClassLoader$3
+java/io/ExpiringCache$Entry
+java/util/LinkedHashMap$Entry
+java/lang/ClassLoader$NativeLibrary
+java/lang/Terminator
+java/lang/Terminator$1
+sun/misc/SignalHandler
+sun/misc/Signal
+sun/misc/NativeSignalHandler
+java/lang/Integer$IntegerCache
+sun/misc/OSEnvironment
+java/lang/System$2
+sun/misc/JavaLangAccess
+java/lang/IllegalArgumentException
+java/lang/Compiler
+java/lang/Compiler$1
+sun/misc/Launcher$Factory
+java/net/URLStreamHandlerFactory
+sun/security/util/Debug
+java/lang/ClassLoader$ParallelLoaders
+java/util/WeakHashMap$Entry
+java/util/Collections$SetFromMap
+java/util/WeakHashMap$KeySet
+java/net/URLClassLoader$7
+sun/misc/JavaNetAccess
+java/util/StringTokenizer
+sun/misc/Launcher$ExtClassLoader$1
+sun/misc/MetaIndex
+java/io/BufferedReader
+java/io/Reader
+java/lang/Readable
+java/io/FileReader
+java/io/InputStreamReader
+sun/nio/cs/StreamDecoder
+java/nio/CharBuffer
+java/nio/HeapCharBuffer
+java/nio/charset/CoderResult
+java/nio/charset/CoderResult$1
+java/nio/charset/CoderResult$Cache
+java/nio/charset/CoderResult$2
+java/lang/reflect/Array
+java/io/FileInputStream$1
+sun/net/www/ParseUtil
+java/util/BitSet
+java/util/Locale
+java/util/Locale$Cache
+sun/util/locale/LocaleObjectCache
+java/util/concurrent/ConcurrentHashMap
+java/util/concurrent/ConcurrentMap
+java/util/concurrent/ConcurrentHashMap$Segment
+java/util/concurrent/locks/ReentrantLock
+java/util/concurrent/locks/Lock
+java/util/concurrent/ConcurrentHashMap$Node
+java/util/concurrent/ConcurrentHashMap$CounterCell
+java/util/concurrent/ConcurrentHashMap$KeySetView
+java/util/concurrent/ConcurrentHashMap$CollectionView
+java/util/concurrent/ConcurrentHashMap$ValuesView
+java/util/concurrent/ConcurrentHashMap$EntrySetView
+sun/util/locale/BaseLocale
+sun/util/locale/BaseLocale$Cache
+sun/util/locale/BaseLocale$Key
+sun/util/locale/LocaleObjectCache$CacheEntry
+java/util/Locale$LocaleKey
+sun/util/locale/LocaleUtils
+java/lang/CharacterData
+java/lang/CharacterDataLatin1
+java/net/Parts
+sun/net/www/protocol/file/Handler
+java/net/URLStreamHandler
+java/util/HashMap$TreeNode
+java/security/ProtectionDomain$JavaSecurityAccessImpl
+sun/misc/JavaSecurityAccess
+java/security/ProtectionDomain$2
+sun/misc/JavaSecurityProtectionDomainAccess
+java/security/ProtectionDomain$Key
+java/security/Principal
+java/util/HashSet
+sun/misc/URLClassPath
+sun/net/www/protocol/jar/Handler
+sun/misc/Launcher$AppClassLoader$1
+java/lang/SystemClassLoaderAction
+java/lang/invoke/MethodHandleImpl
+java/lang/invoke/MethodHandleImpl$1
+java/lang/invoke/MethodHandleImpl$2
+java/util/function/Function
+java/lang/invoke/MethodHandleImpl$3
+java/lang/invoke/MethodHandleImpl$4
+java/lang/ClassValue
+java/lang/ClassValue$Entry
+java/lang/ClassValue$Identity
+java/lang/ClassValue$Version
+java/lang/invoke/MemberName$Factory
+java/lang/invoke/MethodHandleStatics
+java/lang/invoke/MethodHandleStatics$1
+sun/misc/PostVMInitHook
+sun/usagetracker/UsageTrackerClient
+java/util/concurrent/atomic/AtomicBoolean
+sun/usagetracker/UsageTrackerClient$1
+sun/usagetracker/UsageTrackerClient$4
+sun/usagetracker/UsageTrackerClient$3
+java/io/FileOutputStream$1
+sun/launcher/LauncherHelper
+java/net/URLClassLoader$1
+sun/net/util/URLUtil
+sun/misc/URLClassPath$3
+sun/misc/URLClassPath$JarLoader
+sun/misc/URLClassPath$Loader
+java/util/zip/ZipFile
+java/util/zip/ZipConstants
+java/util/zip/ZipFile$1
+sun/misc/JavaUtilZipFileAccess
+sun/misc/URLClassPath$JarLoader$1
+sun/misc/FileURLMapper
+java/util/jar/JarFile
+java/util/jar/JavaUtilJarAccessImpl
+sun/misc/JavaUtilJarAccess
+java/nio/charset/StandardCharsets
+sun/nio/cs/US_ASCII
+sun/nio/cs/ISO_8859_1
+sun/nio/cs/UTF_16BE
+sun/nio/cs/UTF_16LE
+sun/nio/cs/UTF_16
+java/util/ArrayDeque
+java/util/Deque
+java/util/Queue
+java/util/zip/ZipCoder
+sun/misc/PerfCounter
+sun/misc/Perf$GetPerfAction
+sun/misc/Perf
+sun/misc/PerfCounter$CoreCounters
+sun/nio/ch/DirectBuffer
+java/nio/DirectByteBuffer
+java/nio/MappedByteBuffer
+java/nio/DirectLongBufferU
+java/nio/LongBuffer
+sun/misc/JarIndex
+sun/misc/ExtensionDependency
+java/util/zip/ZipEntry
+java/util/jar/JarFile$JarFileEntry
+java/util/jar/JarEntry
+java/util/zip/ZipFile$ZipFileInputStream
+java/util/zip/Inflater
+java/util/zip/ZStreamRef
+java/util/zip/ZipFile$ZipFileInflaterInputStream
+java/util/zip/InflaterInputStream
+sun/misc/IOUtils
+sun/misc/URLClassPath$JarLoader$2
+sun/misc/Resource
+sun/nio/ByteBuffered
+java/security/Permissions
+java/security/PermissionCollection
+sun/net/www/protocol/file/FileURLConnection
+sun/net/www/URLConnection
+java/net/URLConnection
+sun/net/www/MessageHeader
+java/io/FilePermission
+java/io/FilePermission$1
+java/io/FilePermissionCollection
+java/security/AllPermission
+java/security/UnresolvedPermission
+java/security/BasicPermissionCollection
+javax/swing/JLabel
+javax/swing/SwingConstants
+javax/accessibility/Accessible
+javax/swing/JComponent
+javax/swing/TransferHandler$HasGetTransferHandler
+java/awt/Container
+java/awt/Component
+java/awt/image/ImageObserver
+java/awt/MenuContainer
+sun/launcher/LauncherHelper$FXHelper
+java/lang/Class$MethodArray
+java/lang/InterruptedException
+javax/swing/JFrame
+javax/swing/WindowConstants
+javax/swing/RootPaneContainer
+java/awt/Frame
+java/awt/Window
+java/util/concurrent/ConcurrentHashMap$ForwardingNode
+java/awt/Graphics
+java/lang/Void
+sun/util/logging/PlatformLogger
+sun/util/logging/PlatformLogger$Level
+sun/util/logging/PlatformLogger$1
+sun/util/logging/PlatformLogger$DefaultLoggerProxy
+sun/util/logging/PlatformLogger$LoggerProxy
+sun/util/logging/PlatformLogger$JavaLoggerProxy
+sun/util/logging/LoggingSupport
+sun/util/logging/LoggingSupport$1
+java/util/logging/LoggingProxyImpl
+sun/util/logging/LoggingProxy
+sun/reflect/UnsafeFieldAccessorFactory
+sun/reflect/UnsafeQualifiedStaticObjectFieldAccessorImpl
+sun/reflect/UnsafeQualifiedStaticFieldAccessorImpl
+java/util/HashMap$EntrySet
+java/util/HashMap$EntryIterator
+java/util/HashMap$HashIterator
+sun/util/logging/LoggingSupport$2
+java/util/Date
+sun/util/calendar/CalendarSystem
+sun/util/calendar/Gregorian
+sun/util/calendar/BaseCalendar
+sun/util/calendar/AbstractCalendar
+java/awt/Component$AWTTreeLock
+java/awt/Toolkit
+java/awt/Toolkit$4
+sun/awt/AWTAccessor$ToolkitAccessor
+sun/awt/AWTAccessor
+java/awt/Toolkit$5
+sun/util/CoreResourceBundleControl
+java/util/ResourceBundle$Control
+java/util/Arrays$ArrayList
+java/util/ResourceBundle$Control$CandidateListCache
+java/util/ResourceBundle
+java/util/ResourceBundle$1
+java/util/spi/ResourceBundleControlProvider
+java/util/ServiceLoader
+java/util/ServiceLoader$LazyIterator
+java/util/ServiceLoader$1
+java/util/LinkedHashMap$LinkedEntrySet
+java/util/LinkedHashMap$LinkedEntryIterator
+java/util/LinkedHashMap$LinkedHashIterator
+sun/misc/Launcher$BootClassPathHolder
+sun/misc/Launcher$BootClassPathHolder$1
+sun/misc/URLClassPath$2
+java/lang/ClassLoader$2
+sun/misc/URLClassPath$1
+java/net/URLClassLoader$3
+sun/misc/CompoundEnumeration
+java/io/FileNotFoundException
+java/io/IOException
+java/security/PrivilegedActionException
+java/net/URLClassLoader$3$1
+java/util/ResourceBundle$RBClassLoader
+java/util/ResourceBundle$RBClassLoader$1
+java/util/ResourceBundle$CacheKey
+java/util/ResourceBundle$LoaderReference
+java/util/ResourceBundle$CacheKeyReference
+java/util/ResourceBundle$SingleFormatControl
+java/util/LinkedList
+java/util/AbstractSequentialList
+java/util/LinkedList$Node
+sun/awt/resources/awt
+java/util/ListResourceBundle
+java/awt/Toolkit$3
+java/awt/GraphicsEnvironment
+java/lang/invoke/LambdaMetafactory
+java/lang/invoke/MethodHandles$Lookup
+java/lang/invoke/MethodType$ConcurrentWeakInternSet
+java/lang/invoke/MethodTypeForm
+java/lang/invoke/Invokers
+java/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry
+java/lang/invoke/MethodHandles
+sun/invoke/util/Wrapper
+sun/invoke/util/Wrapper$Format
+java/lang/Byte$ByteCache
+java/lang/Short$ShortCache
+java/lang/Character$CharacterCache
+java/lang/Long$LongCache
+sun/invoke/util/VerifyAccess
+sun/invoke/util/ValueConversions
+java/lang/NoSuchMethodException
+java/lang/invoke/LambdaForm$BasicType
+java/lang/invoke/LambdaForm$Name
+java/lang/invoke/LambdaForm$NamedFunction
+java/lang/invoke/SimpleMethodHandle
+java/lang/invoke/BoundMethodHandle
+java/lang/invoke/BoundMethodHandle$SpeciesData
+java/lang/invoke/BoundMethodHandle$Factory
+java/lang/invoke/BoundMethodHandle$Species_L
+java/util/HashMap$Values
+java/util/HashMap$ValueIterator
+sun/invoke/util/BytecodeDescriptor
+java/lang/invoke/DirectMethodHandle$Lazy
+java/lang/InstantiationException
+java/util/Collections$UnmodifiableCollection$1
+java/util/AbstractList$Itr
+java/lang/invoke/InvokerBytecodeGenerator
+jdk/internal/org/objectweb/asm/ClassWriter
+jdk/internal/org/objectweb/asm/ClassVisitor
+jdk/internal/org/objectweb/asm/ByteVector
+jdk/internal/org/objectweb/asm/Item
+jdk/internal/org/objectweb/asm/MethodWriter
+jdk/internal/org/objectweb/asm/MethodVisitor
+jdk/internal/org/objectweb/asm/Type
+jdk/internal/org/objectweb/asm/Label
+jdk/internal/org/objectweb/asm/Frame
+jdk/internal/org/objectweb/asm/AnnotationWriter
+jdk/internal/org/objectweb/asm/AnnotationVisitor
+java/lang/invoke/MethodHandleImpl$Intrinsic
+java/lang/invoke/InvokerBytecodeGenerator$2
+sun/invoke/util/VerifyType
+sun/invoke/empty/Empty
+java/lang/NoSuchFieldException
+java/lang/invoke/InvokerBytecodeGenerator$CpPatch
+java/lang/invoke/DirectMethodHandle$Accessor
+java/util/ArrayList$Itr
+java/util/RandomAccessSubList
+java/util/SubList
+java/util/SubList$1
+java/util/ListIterator
+java/util/AbstractList$ListItr
+java/lang/invoke/MethodHandleImpl$AsVarargsCollector
+java/lang/invoke/DelegatingMethodHandle
+java/lang/invoke/WrongMethodTypeException
+java/lang/invoke/MethodHandleImpl$Lazy
+java/lang/invoke/MethodHandleImpl$IntrinsicMethodHandle
+java/lang/NoSuchFieldError
+java/lang/IllegalAccessException
+java/lang/invoke/LambdaFormEditor
+java/lang/invoke/LambdaFormEditor$Transform$Kind
+java/lang/invoke/LambdaFormEditor$Transform
+java/lang/invoke/LambdaFormBuffer
+jdk/internal/org/objectweb/asm/FieldWriter
+jdk/internal/org/objectweb/asm/FieldVisitor
+java/lang/invoke/InnerClassLambdaMetafactory
+java/lang/invoke/AbstractValidatingLambdaMetafactory
+java/util/PropertyPermission
+java/security/AccessController$1
+sun/security/util/SecurityConstants
+java/net/NetPermission
+java/security/SecurityPermission
+java/net/SocketPermission
+sun/security/action/GetBooleanAction
+java/security/AllPermissionCollection
+java/lang/invoke/InfoFromMemberName
+java/lang/invoke/MethodHandleInfo
+java/lang/invoke/InnerClassLambdaMetafactory$ForwardingMethodGenerator
+java/lang/invoke/TypeConvertingMethodAdapter
+java/lang/invoke/InnerClassLambdaMetafactory$1
+java/lang/ProcessEnvironment
+java/lang/ProcessEnvironment$Variable
+java/lang/ProcessEnvironment$ExternalData
+java/lang/ProcessEnvironment$Value
+java/lang/ProcessEnvironment$StringEnvironment
+java/util/Collections$UnmodifiableMap
+java/awt/Toolkit$1
+java/awt/event/KeyEvent
+java/awt/event/InputEvent
+java/awt/event/ComponentEvent
+java/awt/AWTEvent
+java/util/EventObject
+java/awt/AWTEvent$1
+sun/awt/AWTAccessor$AWTEventAccessor
+java/awt/event/NativeLibLoader
+java/awt/event/NativeLibLoader$1
+java/awt/event/InputEvent$1
+sun/awt/AWTAccessor$InputEventAccessor
+java/awt/event/KeyEvent$1
+sun/awt/AWTAccessor$KeyEventAccessor
+java/awt/Component$1
+sun/awt/AWTAccessor$ComponentAccessor
+java/awt/Component$DummyRequestFocusController
+sun/awt/RequestFocusController
+java/awt/LayoutManager
+java/awt/LightweightDispatcher
+java/awt/event/AWTEventListener
+java/util/EventListener
+java/awt/Dimension
+java/awt/geom/Dimension2D
+java/awt/Container$1
+sun/awt/AWTAccessor$ContainerAccessor
+javax/swing/JComponent$1
+java/awt/ComponentOrientation
+java/awt/Component$3
+sun/awt/AppContext
+java/util/IdentityHashMap
+java/util/Collections$SynchronizedMap
+sun/awt/AppContext$GetAppContextLock
+sun/awt/AppContext$6
+sun/misc/JavaAWTAccess
+sun/awt/AppContext$3
+sun/awt/AppContext$2
+sun/awt/SunToolkit
+sun/awt/WindowClosingSupport
+sun/awt/WindowClosingListener
+sun/awt/ComponentFactory
+sun/awt/InputMethodSupport
+sun/awt/KeyboardFocusManagerPeerProvider
+java/util/concurrent/locks/ReentrantLock$NonfairSync
+java/util/concurrent/locks/ReentrantLock$Sync
+java/util/concurrent/locks/AbstractQueuedSynchronizer
+java/util/concurrent/locks/AbstractOwnableSynchronizer
+java/util/concurrent/locks/AbstractQueuedSynchronizer$Node
+java/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject
+java/util/concurrent/locks/Condition
+sun/misc/SoftCache
+sun/awt/AppContext$State
+sun/awt/AppContext$1
+java/awt/EventQueue
+java/awt/EventQueue$1
+java/awt/EventQueue$2
+sun/awt/AWTAccessor$EventQueueAccessor
+java/awt/Queue
+sun/awt/MostRecentKeyValue
+sun/awt/PostEventQueue
+javax/swing/event/EventListenerList
+javax/swing/SwingUtilities
+javax/swing/RepaintManager
+javax/swing/RepaintManager$DisplayChangedHandler
+sun/awt/DisplayChangedListener
+javax/swing/RepaintManager$1
+sun/swing/SwingAccessor$RepaintManagerAccessor
+sun/swing/SwingAccessor
+sun/awt/X11GraphicsEnvironment
+sun/java2d/SunGraphicsEnvironment
+sun/awt/X11GraphicsEnvironment$1
+sun/awt/X11/XErrorHandlerUtil
+sun/awt/X11/XlibWrapper
+sun/java2d/UnixSurfaceManagerFactory
+sun/java2d/SurfaceManagerFactory
+sun/awt/SunDisplayChanger
+sun/java2d/SunGraphicsEnvironment$1
+sun/misc/FloatingDecimal
+sun/misc/FloatingDecimal$ExceptionalBinaryToASCIIBuffer
+sun/misc/FloatingDecimal$BinaryToASCIIConverter
+sun/misc/FloatingDecimal$BinaryToASCIIBuffer
+sun/misc/FloatingDecimal$1
+sun/misc/FloatingDecimal$PreparedASCIIToBinaryBuffer
+sun/misc/FloatingDecimal$ASCIIToBinaryConverter
+java/lang/NumberFormatException
+java/lang/StringIndexOutOfBoundsException
+java/lang/IndexOutOfBoundsException
+java/awt/Font
+java/awt/Font$FontAccessImpl
+sun/font/FontAccess
+java/awt/geom/AffineTransform
+sun/font/AttributeValues
+sun/font/EAttribute
+java/text/AttributedCharacterIterator$Attribute
+java/lang/Class$4
+sun/reflect/NativeMethodAccessorImpl
+sun/reflect/DelegatingMethodAccessorImpl
+java/awt/font/TextAttribute
+java/awt/Toolkit$2
+sun/awt/X11/XToolkit
+sun/awt/UNIXToolkit
+java/util/TreeMap
+java/util/NavigableMap
+java/util/SortedMap
+java/awt/GraphicsDevice
+sun/awt/X11GraphicsDevice
+sun/awt/X11GraphicsConfig
+sun/awt/image/SurfaceManager$ProxiedGraphicsConfig
+java/awt/GraphicsConfiguration
+java/awt/ImageCapabilities
+sun/java2d/x11/X11SurfaceData
+sun/java2d/x11/XSurfaceData
+sun/java2d/SurfaceData
+java/awt/Transparency
+sun/java2d/DisposerTarget
+sun/java2d/StateTrackable
+sun/java2d/Surface
+sun/java2d/InvalidPipeException
+java/lang/IllegalStateException
+sun/java2d/NullSurfaceData
+sun/java2d/StateTrackable$State
+sun/java2d/loops/SurfaceType
+sun/awt/image/PixelConverter
+sun/awt/image/PixelConverter$Xrgb
+sun/awt/image/PixelConverter$Argb
+sun/awt/image/PixelConverter$ArgbPre
+sun/awt/image/PixelConverter$Xbgr
+sun/awt/image/PixelConverter$Rgba
+sun/awt/image/PixelConverter$RgbaPre
+sun/awt/image/PixelConverter$Ushort565Rgb
+sun/awt/image/PixelConverter$Ushort555Rgb
+sun/awt/image/PixelConverter$Ushort555Rgbx
+sun/awt/image/PixelConverter$Ushort4444Argb
+sun/awt/image/PixelConverter$ByteGray
+sun/awt/image/PixelConverter$UshortGray
+sun/awt/image/PixelConverter$Rgbx
+sun/awt/image/PixelConverter$Bgrx
+sun/awt/image/PixelConverter$ArgbBm
+java/awt/image/ColorModel
+java/awt/image/ColorModel$1
+java/awt/image/DirectColorModel
+java/awt/image/PackedColorModel
+java/awt/color/ColorSpace
+java/awt/color/ICC_Profile
+sun/java2d/cmm/ProfileDeferralInfo
+sun/java2d/cmm/ProfileDeferralMgr
+java/awt/color/ICC_ProfileRGB
+java/awt/color/ICC_Profile$1
+sun/java2d/cmm/ProfileActivator
+java/awt/color/ICC_ColorSpace
+sun/java2d/StateTrackableDelegate
+sun/java2d/StateTrackableDelegate$2
+sun/java2d/pipe/NullPipe
+sun/java2d/pipe/PixelDrawPipe
+sun/java2d/pipe/PixelFillPipe
+sun/java2d/pipe/ShapeDrawPipe
+sun/java2d/pipe/TextPipe
+sun/java2d/pipe/DrawImagePipe
+java/awt/image/IndexColorModel
+sun/java2d/pipe/LoopPipe
+sun/java2d/pipe/ParallelogramPipe
+sun/java2d/pipe/LoopBasedPipe
+sun/java2d/pipe/RenderingEngine
+sun/java2d/pipe/RenderingEngine$1
+sun/dc/DuctusRenderingEngine
+sun/java2d/pipe/OutlineTextRenderer
+sun/java2d/pipe/SolidTextRenderer
+sun/java2d/pipe/GlyphListLoopPipe
+sun/java2d/pipe/GlyphListPipe
+sun/java2d/pipe/AATextRenderer
+sun/java2d/pipe/LCDTextRenderer
+sun/java2d/pipe/AlphaColorPipe
+sun/java2d/pipe/CompositePipe
+sun/java2d/SurfaceData$PixelToShapeLoopConverter
+sun/java2d/pipe/PixelToShapeConverter
+sun/java2d/SurfaceData$PixelToPgramLoopConverter
+sun/java2d/pipe/PixelToParallelogramConverter
+sun/java2d/pipe/TextRenderer
+sun/java2d/pipe/SpanClipRenderer
+sun/java2d/pipe/Region
+sun/java2d/pipe/RegionIterator
+sun/java2d/pipe/Region$ImmutableRegion
+sun/java2d/pipe/AAShapePipe
+sun/java2d/pipe/AlphaPaintPipe
+sun/java2d/pipe/SpanShapeRenderer$Composite
+sun/java2d/pipe/SpanShapeRenderer
+sun/java2d/pipe/GeneralCompositePipe
+sun/java2d/pipe/DrawImage
+sun/java2d/loops/RenderCache
+sun/java2d/loops/RenderCache$Entry
+sun/java2d/loops/XORComposite
+java/awt/Composite
+sun/font/X11TextRenderer
+sun/java2d/loops/GraphicsPrimitive
+sun/java2d/x11/X11PMBlitLoops
+sun/java2d/loops/Blit
+sun/java2d/loops/GraphicsPrimitiveMgr
+sun/java2d/loops/CompositeType
+sun/java2d/SunGraphics2D
+sun/awt/ConstrainableGraphics
+sun/java2d/DestSurfaceProvider
+java/awt/Graphics2D
+java/awt/Color
+java/awt/Paint
+java/awt/AlphaComposite
+java/awt/geom/Path2D
+java/awt/Shape
+java/awt/geom/Path2D$Float
+sun/awt/SunHints
+sun/java2d/loops/BlitBg
+sun/java2d/loops/ScaledBlit
+sun/java2d/loops/FillRect
+sun/java2d/loops/FillSpans
+sun/java2d/loops/FillParallelogram
+sun/java2d/loops/DrawParallelogram
+sun/java2d/loops/DrawLine
+sun/java2d/loops/DrawRect
+sun/java2d/loops/DrawPolygons
+sun/java2d/loops/DrawPath
+sun/java2d/loops/FillPath
+sun/java2d/loops/MaskBlit
+sun/java2d/loops/MaskFill
+sun/java2d/loops/DrawGlyphList
+sun/java2d/loops/DrawGlyphListAA
+sun/java2d/loops/DrawGlyphListLCD
+sun/java2d/loops/TransformHelper
+java/awt/BasicStroke
+java/awt/Stroke
+sun/misc/PerformanceLogger
+sun/misc/PerformanceLogger$TimeData
+sun/java2d/pipe/ValidatePipe
+sun/awt/SunHints$Key
+java/awt/RenderingHints$Key
+sun/awt/SunHints$Value
+sun/awt/SunHints$LCDContrastKey
+sun/java2d/loops/CustomComponent
+sun/java2d/loops/GraphicsPrimitiveProxy
+sun/java2d/loops/GeneralRenderer
+sun/java2d/loops/GraphicsPrimitiveMgr$1
+sun/java2d/loops/GraphicsPrimitiveMgr$2
+sun/java2d/x11/X11PMBlitLoops$DelegateBlitLoop
+sun/java2d/x11/X11PMBlitBgLoops
+sun/java2d/x11/X11SurfaceData$LazyPipe
+sun/awt/X11GraphicsConfig$X11GCDisposerRecord
+sun/java2d/DisposerRecord
+sun/java2d/Disposer
+sun/java2d/Disposer$1
+sun/misc/ThreadGroupUtils
+sun/awt/X11/XModifierKeymap
+sun/awt/X11/XWrapperBase
+sun/awt/X11/Native
+sun/awt/X11/Native$1
+sun/awt/X11/XToolkit$3
+sun/awt/X11/XToolkit$4
+sun/awt/X11/XEventDispatcher
+java/awt/Toolkit$DesktopPropertyChangeSupport
+java/beans/PropertyChangeSupport
+java/beans/PropertyChangeSupport$PropertyChangeListenerMap
+java/beans/ChangeListenerMap
+java/beans/PropertyChangeListener
+sun/awt/SunToolkit$ModalityListenerList
+sun/awt/ModalityListener
+sun/font/FontConfigManager
+sun/font/FontConfigManager$FontConfigInfo
+sun/awt/X11/AwtScreenData
+sun/awt/X11/XToolkit$1
+java/lang/invoke/DirectMethodHandle$Special
+sun/awt/X11/XToolkit$2
+java/lang/ApplicationShutdownHooks
+java/lang/ApplicationShutdownHooks$1
+java/lang/Shutdown
+java/lang/Shutdown$Lock
+sun/awt/X11/XWM
+sun/awt/X11/XAtom
+java/awt/Insets
+sun/awt/X11/XWM$1
+sun/awt/X11/XErrorHandler$XBaseErrorHandler
+sun/awt/X11/XErrorHandler
+sun/awt/X11/XSetWindowAttributes
+sun/awt/X11/XNETProtocol
+sun/awt/X11/XStateProtocol
+sun/awt/X11/XLayerProtocol
+sun/awt/X11/XProtocol
+sun/awt/X11/WindowPropertyGetter
+sun/awt/X11/UnsafeXDisposerRecord
+sun/awt/X11/XPropertyCache
+sun/awt/X11/XWINProtocol
+sun/awt/X11/XAtomList
+java/awt/Rectangle
+java/awt/geom/Rectangle2D
+sun/awt/X11/XEvent
+java/awt/geom/RectangularShape
+javax/swing/RepaintManager$ProcessingRunnable
+com/sun/java/swing/SwingUtilities3
+javax/swing/UIManager
+javax/swing/UIManager$LookAndFeelInfo
+sun/awt/OSInfo
+sun/awt/OSInfo$WindowsVersion
+sun/awt/OSInfo$1
+sun/awt/OSInfo$OSType
+sun/swing/SwingUtilities2
+java/awt/font/FontRenderContext
+java/awt/RenderingHints
+sun/swing/StringUIClientPropertyKey
+sun/swing/UIClientPropertyKey
+sun/swing/SwingUtilities2$LSBCacheEntry
+javax/swing/UIManager$LAFState
+javax/swing/UIDefaults
+javax/swing/MultiUIDefaults
+javax/swing/UIManager$1
+javax/swing/plaf/metal/MetalLookAndFeel
+javax/swing/plaf/basic/BasicLookAndFeel
+javax/swing/LookAndFeel
+sun/swing/DefaultLookup
+javax/swing/plaf/metal/OceanTheme
+javax/swing/plaf/metal/DefaultMetalTheme
+javax/swing/plaf/metal/MetalTheme
+javax/swing/plaf/ColorUIResource
+javax/swing/plaf/UIResource
+sun/swing/PrintColorUIResource
+javax/swing/plaf/metal/DefaultMetalTheme$FontDelegate
+javax/swing/plaf/FontUIResource
+sun/swing/SwingLazyValue
+javax/swing/UIDefaults$LazyValue
+javax/swing/UIDefaults$ActiveValue
+javax/swing/plaf/InsetsUIResource
+javax/swing/plaf/BorderUIResource$EmptyBorderUIResource
+javax/swing/border/EmptyBorder
+javax/swing/border/AbstractBorder
+javax/swing/border/Border
+sun/swing/SwingUtilities2$2
+javax/swing/plaf/basic/BasicLookAndFeel$2
+javax/swing/plaf/DimensionUIResource
+javax/swing/UIDefaults$LazyInputMap
+javax/swing/plaf/metal/MetalLookAndFeel$FontActiveValue
+sun/swing/SwingUtilities2$AATextInfo
+sun/awt/HeadlessToolkit
+sun/awt/X11/XAWTXSettings
+sun/awt/X11/XMSelectionListener
+sun/awt/XSettings
+sun/awt/X11/XMSelection
+sun/awt/X11/XMSelection$1
+sun/awt/X11/XMSelection$3
+sun/awt/X11/XErrorHandler$IgnoreBadWindowHandler
+sun/awt/XSettings$Update
+java/beans/PropertyChangeEvent
+java/awt/Toolkit$DesktopPropertyChangeSupport$1
+java/util/IdentityHashMap$Values
+java/util/IdentityHashMap$ValueIterator
+java/util/IdentityHashMap$IdentityHashMapIterator
+java/util/HashMap$KeySet
+java/util/HashMap$KeyIterator
+javax/swing/plaf/metal/MetalLookAndFeel$AATextListener
+java/beans/PropertyChangeListenerProxy
+java/util/EventListenerProxy
+javax/swing/plaf/metal/OceanTheme$1
+javax/swing/plaf/metal/OceanTheme$2
+javax/swing/plaf/metal/OceanTheme$3
+javax/swing/plaf/metal/OceanTheme$4
+javax/swing/plaf/metal/OceanTheme$5
+javax/swing/plaf/metal/OceanTheme$6
+javax/swing/SwingPaintEventDispatcher
+sun/awt/PaintEventDispatcher
+java/awt/KeyboardFocusManager
+java/awt/KeyEventDispatcher
+java/awt/KeyEventPostProcessor
+java/awt/KeyboardFocusManager$1
+sun/awt/AWTAccessor$KeyboardFocusManagerAccessor
+java/awt/AWTKeyStroke
+java/awt/AWTKeyStroke$1
+java/awt/DefaultKeyboardFocusManager
+java/awt/DefaultKeyboardFocusManager$1
+sun/awt/AWTAccessor$DefaultKeyboardFocusManagerAccessor
+java/awt/DefaultFocusTraversalPolicy
+java/awt/ContainerOrderFocusTraversalPolicy
+java/awt/FocusTraversalPolicy
+java/util/Collections$UnmodifiableSet
+sun/awt/X11/XKeyboardFocusManagerPeer
+sun/awt/KeyboardFocusManagerPeerImpl
+java/awt/peer/KeyboardFocusManagerPeer
+javax/swing/UIManager$2
+javax/swing/JRootPane
+javax/swing/UIDefaults$TextAndMnemonicHashMap
+com/sun/swing/internal/plaf/metal/resources/metal
+sun/util/ResourceBundleEnumeration
+com/sun/swing/internal/plaf/basic/resources/basic
+javax/swing/plaf/metal/MetalLabelUI
+javax/swing/plaf/basic/BasicLabelUI
+javax/swing/plaf/LabelUI
+javax/swing/plaf/ComponentUI
+sun/reflect/misc/MethodUtil
+sun/reflect/misc/MethodUtil$1
+sun/net/www/protocol/jar/JarURLConnection
+java/net/JarURLConnection
+sun/net/www/protocol/jar/JarFileFactory
+sun/net/www/protocol/jar/URLJarFile$URLJarFileCloseController
+java/net/HttpURLConnection
+sun/net/www/protocol/jar/URLJarFile
+sun/net/www/protocol/jar/URLJarFile$URLJarFileEntry
+sun/net/www/protocol/jar/JarURLConnection$JarURLInputStream
+java/lang/UnsupportedOperationException
+java/lang/reflect/InvocationTargetException
+javax/swing/plaf/metal/DefaultMetalTheme$FontDelegate$1
+javax/swing/plaf/basic/BasicHTML
+sun/awt/util/IdentityArrayList
+java/awt/Window$1
+sun/awt/AWTAccessor$WindowAccessor
+java/awt/Frame$1
+sun/awt/AWTAccessor$FrameAccessor
+java/awt/Window$Type
+java/awt/Cursor
+java/awt/Cursor$1
+sun/awt/AWTAccessor$CursorAccessor
+java/awt/BorderLayout
+java/awt/LayoutManager2
+sun/awt/X11/XlibUtil
+java/util/concurrent/locks/LockSupport
+sun/nio/ch/Interruptible
+java/awt/Dialog$ModalExclusionType
+java/awt/Window$WindowDisposerRecord
+javax/swing/JPanel
+java/awt/FlowLayout
+javax/swing/plaf/basic/BasicPanelUI
+javax/swing/plaf/PanelUI
+java/awt/Component$BaselineResizeBehavior
+sun/swing/SwingLazyValue$1
+javax/swing/JLayeredPane
+javax/swing/JRootPane$1
+javax/swing/ArrayTable
+javax/swing/JRootPane$RootLayout
+javax/swing/BufferStrategyPaintManager
+javax/swing/RepaintManager$PaintManager
+javax/swing/FocusManager
+javax/swing/LayoutFocusTraversalPolicy
+javax/swing/SortingFocusTraversalPolicy
+javax/swing/InternalFrameFocusTraversalPolicy
+javax/swing/SwingContainerOrderFocusTraversalPolicy
+javax/swing/SortingFocusTraversalPolicy$1
+java/util/Spliterator$OfLong
+java/util/Spliterator$OfPrimitive
+java/util/Spliterator
+java/util/Spliterator$OfInt
+java/util/Spliterator$OfDouble
+java/util/stream/IntStream
+java/util/stream/BaseStream
+java/util/stream/Stream
+java/util/stream/DoubleStream
+java/util/stream/LongStream
+java/util/function/DoubleBinaryOperator
+java/util/function/IntBinaryOperator
+java/util/function/LongBinaryOperator
+java/util/function/BinaryOperator
+java/util/function/BiFunction
+java/util/function/IntToDoubleFunction
+java/util/function/IntFunction
+java/util/function/IntToLongFunction
+java/util/function/IntUnaryOperator
+javax/swing/SwingDefaultFocusTraversalPolicy
+javax/swing/LayoutComparator
+javax/swing/plaf/metal/MetalRootPaneUI
+javax/swing/plaf/basic/BasicRootPaneUI
+javax/swing/plaf/RootPaneUI
+javax/swing/plaf/basic/BasicRootPaneUI$RootPaneInputMap
+javax/swing/plaf/ComponentInputMapUIResource
+javax/swing/ComponentInputMap
+javax/swing/InputMap
+javax/swing/plaf/InputMapUIResource
+javax/swing/KeyStroke
+java/awt/VKCollection
+sun/reflect/UnsafeQualifiedStaticIntegerFieldAccessorImpl
+javax/swing/plaf/basic/LazyActionMap
+javax/swing/plaf/ActionMapUIResource
+javax/swing/ActionMap
+sun/awt/X11/XFramePeer
+java/awt/peer/FramePeer
+java/awt/peer/WindowPeer
+java/awt/peer/ContainerPeer
+java/awt/peer/ComponentPeer
+sun/awt/X11/XDecoratedPeer
+sun/awt/X11/XWindowPeer
+sun/awt/X11/XPanelPeer
+java/awt/peer/PanelPeer
+sun/awt/X11/XCanvasPeer
+java/awt/peer/CanvasPeer
+sun/awt/X11/XComponentPeer
+java/awt/dnd/peer/DropTargetPeer
+sun/java2d/BackBufferCapsProvider
+sun/awt/X11/XWindow
+sun/awt/X11ComponentPeer
+sun/awt/X11/XBaseWindow
+sun/awt/X11/XCreateWindowParams
+sun/awt/X11/XBaseWindow$InitialiseState
+sun/awt/X11/XBaseWindow$StateLock
+sun/awt/X11/AwtGraphicsConfigData
+sun/awt/X11/XVisualInfo
+java/awt/SystemColor
+sun/awt/AWTAccessor$SystemColorAccessor
+sun/awt/X11/MotifColorUtilities
+sun/awt/X11/XRepaintArea
+sun/awt/RepaintArea
+sun/awt/X11/XWindowAttributesData
+sun/awt/X11/WindowDimensions
+java/awt/Point
+java/awt/geom/Point2D
+java/util/TreeMap$Entry
+sun/awt/X11/XSizeHints
+sun/awt/X11/XRootWindow
+sun/awt/X11/XRootWindow$LazyHolder
+sun/nio/cs/ISO_8859_1$Encoder
+sun/nio/cs/Surrogate$Parser
+sun/nio/cs/Surrogate
+sun/java2d/x11/X11SurfaceData$X11WindowSurfaceData
+sun/awt/X11/XDropTargetEventProcessor
+sun/java2d/loops/RenderLoops
+sun/awt/X11/XDragSourceContextPeer
+sun/java2d/loops/GraphicsPrimitiveMgr$PrimitiveSpec
+sun/awt/X11/XDragSourceProtocolListener
+java/util/Arrays$LegacyMergeSort
+sun/awt/dnd/SunDragSourceContextPeer
+java/awt/dnd/peer/DragSourceContextPeer
+java/util/TimSort
+sun/awt/X11/XAnyEvent
+sun/awt/X11/XAwtState
+sun/awt/X11/XBaseWindow$1
+sun/awt/X11/XPropertyEvent
+sun/java2d/DefaultDisposerRecord
+sun/java2d/SurfaceDataProxy
+sun/awt/image/SurfaceManager$FlushableCacheData
+sun/java2d/SurfaceDataProxy$1
+sun/java2d/StateTracker
+sun/java2d/StateTracker$1
+sun/java2d/StateTracker$2
+sun/java2d/x11/X11Renderer
+sun/awt/X11/XGlobalCursorManager
+sun/awt/GlobalCursorManager
+sun/awt/IconInfo
+sun/awt/AWTIcon32_java_icon16_png
+sun/awt/AWTIcon32_java_icon24_png
+sun/awt/AWTIcon32_java_icon32_png
+sun/awt/AWTIcon32_java_icon48_png
+sun/awt/X11/XClientMessageEvent
+sun/awt/X11/XContentWindow
+sun/awt/X11/XFocusProxyWindow
+sun/awt/X11/XWMHints
+java/util/LinkedList$ListItr
+sun/awt/AWTAutoShutdown
+java/awt/peer/LightweightPeer
+sun/awt/NullComponentPeer
+java/awt/SplashScreen
+java/awt/Dialog
+java/awt/Dialog$ModalityType
+sun/awt/X11/PropMwmHints
+sun/awt/X11/XWindowPeer$4
+sun/awt/GlobalCursorManager$NativeUpdater
+java/awt/event/WindowEvent
+java/awt/EventQueue$5
+java/awt/EventDispatchThread
+sun/awt/PeerEvent
+java/awt/EventDispatchThread$1
+java/awt/Conditional
+java/awt/event/InvocationEvent
+java/awt/ActiveEvent
+java/awt/EventDispatchThread$HierarchyEventFilter
+java/awt/EventFilter
+java/awt/event/PaintEvent
+sun/awt/X11/XReparentEvent
+java/awt/event/MouseEvent
+java/awt/ModalEventFilter
+sun/awt/EventQueueItem
+sun/awt/EventQueueDelegate
+java/awt/EventFilter$FilterAction
+java/awt/EventQueue$3
+java/awt/EventQueue$4
+sun/awt/dnd/SunDropTargetEvent
+sun/awt/X11/XConfigureEvent
+java/awt/event/InputMethodEvent
+java/awt/event/ActionEvent
+java/awt/event/FocusEvent
+java/util/Vector$Itr
+java/awt/event/InvocationEvent$1
+sun/awt/X11/XWindowPeer$2
+sun/awt/AWTAccessor$InvocationEventAccessor
+java/applet/Applet
+java/awt/Panel
+sun/awt/X11/XVisibilityEvent
+sun/awt/X11/XExposeEvent
+sun/awt/event/IgnorePaintEvent
+sun/awt/X11/XTranslateCoordinates
+sun/awt/X11/XFocusChangeEvent
+java/awt/SequencedEvent
+java/awt/SequencedEvent$1
+sun/awt/AWTAccessor$SequencedEventAccessor
+sun/awt/X11/XComponentPeer$1
+java/awt/MenuComponent
+java/awt/TrayIcon
+java/util/IdentityHashMap$KeySet
+java/util/IdentityHashMap$KeyIterator
+javax/swing/RepaintManager$4
+java/awt/GraphicsCallback$PaintCallback
+java/awt/GraphicsCallback
+sun/awt/SunGraphicsCallback
+javax/swing/BufferStrategyPaintManager$BufferInfo
+java/awt/event/WindowListener
+java/awt/event/ComponentAdapter
+java/awt/event/ComponentListener
+java/awt/AWTEventMulticaster
+java/awt/event/ContainerListener
+java/awt/event/FocusListener
+java/awt/event/KeyListener
+java/awt/event/MouseListener
+java/awt/event/MouseMotionListener
+java/awt/event/WindowFocusListener
+java/awt/event/WindowStateListener
+java/awt/event/ActionListener
+java/awt/event/ItemListener
+java/awt/event/AdjustmentListener
+java/awt/event/TextListener
+java/awt/event/InputMethodListener
+java/awt/event/HierarchyListener
+java/awt/event/HierarchyBoundsListener
+java/awt/event/MouseWheelListener
+java/awt/BufferCapabilities
+java/awt/Component$BltSubRegionBufferStrategy
+sun/awt/SubRegionShowable
+java/awt/Component$BltBufferStrategy
+java/awt/image/BufferStrategy
+java/awt/image/VolatileImage
+java/awt/Image
+sun/awt/image/SunVolatileImage
+java/awt/Image$1
+sun/awt/image/SurfaceManager$ImageAccessor
+sun/awt/image/SurfaceManager
+sun/awt/image/BufferedImageGraphicsConfig
+sun/print/PrinterGraphicsConfig
+sun/java2d/opengl/GLXGraphicsConfig
+sun/java2d/opengl/OGLGraphicsConfig
+sun/java2d/pipe/hw/AccelGraphicsConfig
+sun/java2d/pipe/hw/BufferedContextProvider
+sun/java2d/xr/XRGraphicsConfig
+sun/java2d/x11/X11VolatileSurfaceManager
+sun/awt/image/VolatileSurfaceManager
+sun/java2d/x11/X11SurfaceData$X11PixmapSurfaceData
+sun/font/FontDesignMetrics
+java/awt/FontMetrics
+sun/font/SunFontManager
+sun/java2d/FontSupport
+sun/font/FontManagerForSGE
+sun/font/FontManager
+sun/font/SunFontManager$TTFilter
+java/io/FilenameFilter
+sun/font/SunFontManager$T1Filter
+sun/font/SunFontManager$1
+sun/font/FontManagerNativeLibrary
+sun/font/FontManagerNativeLibrary$1
+sun/font/FontUtilities
+sun/font/FontUtilities$1
+sun/font/TrueTypeFont
+sun/font/FileFont
+sun/font/PhysicalFont
+sun/font/Font2D
+sun/font/Type1Font
+java/awt/geom/Point2D$Float
+sun/font/StrikeMetrics
+java/awt/geom/Rectangle2D$Float
+java/awt/geom/GeneralPath
+sun/font/CharToGlyphMapper
+sun/font/PhysicalStrike
+sun/font/FontStrike
+sun/font/StrikeCache
+sun/font/StrikeCache$1
+sun/font/GlyphList
+sun/font/FontManagerFactory
+sun/font/FontManagerFactory$1
+sun/awt/X11FontManager
+sun/font/CompositeFont
+sun/font/SunFontManager$2
+java/io/StreamTokenizer
+sun/font/SunFontManager$FontRegistrationInfo
+sun/awt/motif/MFontConfiguration
+sun/awt/FontConfiguration
+sun/awt/FontDescriptor
+java/util/Properties$LineReader
+sun/font/FcFontConfiguration
+java/net/InetAddress
+java/net/InetAddress$1
+java/net/InetAddress$InetAddressHolder
+java/net/InetAddress$Cache
+java/net/InetAddress$Cache$Type
+java/net/InetAddressImplFactory
+java/net/Inet4AddressImpl
+java/net/InetAddressImpl
+java/net/InetAddress$2
+sun/net/spi/nameservice/NameService
+java/net/Inet4Address
+java/net/Inet6Address
+java/net/Inet6Address$Inet6AddressHolder
+sun/net/InetAddressCachePolicy
+sun/net/InetAddressCachePolicy$1
+java/security/Security
+java/security/Security$1
+sun/net/InetAddressCachePolicy$2
+java/util/LinkedHashMap$LinkedKeySet
+java/util/LinkedHashMap$LinkedKeyIterator
+java/net/InetAddress$CacheEntry
+sun/font/FontConfigManager$FcCompFont
+sun/font/FontConfigManager$FontConfigFont
+sun/font/CompositeFontDescriptor
+sun/font/Font2DHandle
+sun/font/FontFamily
+sun/font/SunFontManager$3
+sun/font/FontDesignMetrics$MetricsKey
+sun/font/FontStrikeDesc
+sun/font/CompositeStrike
+sun/font/FontStrikeDisposer
+sun/java2d/Disposer$PollDisposable
+sun/font/StrikeCache$SoftDisposerRef
+sun/font/StrikeCache$DisposableStrike
+sun/font/TrueTypeFont$TTDisposerRecord
+sun/font/TrueTypeFont$1
+java/io/RandomAccessFile
+java/io/DataOutput
+java/io/DataInput
+sun/nio/ch/FileChannelImpl
+java/nio/channels/FileChannel
+java/nio/channels/SeekableByteChannel
+java/nio/channels/ByteChannel
+java/nio/channels/ReadableByteChannel
+java/nio/channels/Channel
+java/nio/channels/WritableByteChannel
+java/nio/channels/GatheringByteChannel
+java/nio/channels/ScatteringByteChannel
+java/nio/channels/spi/AbstractInterruptibleChannel
+java/nio/channels/InterruptibleChannel
+java/nio/file/attribute/FileAttribute
+sun/nio/ch/IOUtil
+sun/nio/ch/IOUtil$1
+sun/nio/ch/NativeThreadSet
+sun/nio/ch/FileDispatcherImpl
+sun/nio/ch/FileDispatcher
+sun/nio/ch/NativeDispatcher
+java/nio/channels/spi/AbstractInterruptibleChannel$1
+sun/nio/ch/NativeThread
+sun/nio/ch/IOStatus
+sun/nio/ch/Util
+sun/nio/ch/Util$1
+sun/nio/ch/Util$BufferCache
+java/nio/DirectByteBuffer$Deallocator
+java/nio/ByteBufferAsIntBufferB
+java/nio/IntBuffer
+sun/font/TrueTypeFont$DirectoryEntry
+java/nio/ByteBufferAsShortBufferB
+java/nio/ShortBuffer
+sun/nio/cs/UTF_16$Decoder
+sun/nio/cs/UnicodeDecoder
+sun/font/FileFontStrike
+sun/font/FontScaler
+sun/font/T2KFontScaler
+sun/font/T2KFontScaler$1
+sun/font/TrueTypeGlyphMapper
+sun/font/CMap
+sun/font/CMap$NullCMapClass
+sun/font/CMap$CMapFormat12
+sun/font/FontDesignMetrics$KeyReference
+sun/font/CompositeGlyphMapper
+java/awt/print/PrinterGraphics
+java/awt/PrintGraphics
+sun/java2d/loops/FontInfo
+sun/awt/X11/XSystemTrayPeer
+java/awt/peer/SystemTrayPeer
+java/util/jar/Attributes
+java/util/jar/Manifest$FastInputStream
+java/util/jar/Attributes$Name
+sun/misc/ASCIICaseInsensitiveComparator
+java/util/jar/JarVerifier
+java/security/CodeSigner
+java/util/jar/JarVerifier$3
+java/io/ByteArrayOutputStream
+java/lang/Package
+sun/security/util/SignatureFileVerifier
+sun/security/util/ManifestEntryVerifier
+java/util/MissingResourceException
+javax/swing/JDialog
+javax/swing/text/JTextComponent
+javax/swing/Scrollable
+javax/swing/JTextArea
+javax/swing/JScrollPane
+javax/swing/ScrollPaneConstants
+javax/swing/AbstractButton
+java/awt/ItemSelectable
+javax/swing/JButton
+java/io/StringWriter
+java/lang/SecurityException
+javax/swing/JWindow
+java/io/UnsupportedEncodingException
+sun/misc/URLClassPath$FileLoader
+java/lang/CloneNotSupportedException
+java/lang/InternalError
+java/net/UnknownHostException
+java/net/Socket
+java/net/SocketAddress
+java/nio/channels/SocketChannel
+java/nio/channels/NetworkChannel
+java/nio/channels/spi/AbstractSelectableChannel
+java/nio/channels/SelectableChannel
+java/net/SocketException
+java/net/SocketImplFactory
+java/net/InetSocketAddress
+java/net/InetSocketAddress$InetSocketAddressHolder
+java/net/Proxy
+java/net/SocketImpl
+java/net/SocketOptions
+java/net/SocksSocketImpl
+java/net/SocksConsts
+java/net/PlainSocketImpl
+java/net/AbstractPlainSocketImpl
+java/net/AbstractPlainSocketImpl$1
+sun/net/util/IPAddressUtil
+java/net/SocksSocketImpl$3
+java/net/ProxySelector
+sun/net/spi/DefaultProxySelector
+sun/net/spi/DefaultProxySelector$1
+sun/net/NetProperties
+sun/net/NetProperties$1
+java/net/URI
+java/net/URI$Parser
+sun/net/spi/DefaultProxySelector$NonProxyInfo
+sun/net/spi/DefaultProxySelector$3
+java/net/Proxy$Type
+sun/net/NetHooks
+sun/net/sdp/SdpProvider
+sun/net/NetHooks$Provider
+java/net/ConnectException
+java/net/MalformedURLException
+java/lang/UnsatisfiedLinkError
+javax/swing/UnsupportedLookAndFeelException
+sun/misc/FloatingDecimal$ASCIIToBinaryBuffer
+sun/misc/FDBigInteger
+java/util/ResourceBundle$Control$1
+java/net/URLClassLoader$2
+java/util/PropertyResourceBundle
+java/util/ResourceBundle$BundleReference
+java/util/logging/Level
+java/util/logging/Level$KnownLevel
+java/util/logging/Logger
+java/util/logging/Handler
+java/util/logging/Logger$LoggerBundle
+java/util/concurrent/CopyOnWriteArrayList
+java/util/logging/LogManager
+java/util/logging/LogManager$1
+java/util/logging/LogManager$SystemLoggerContext
+java/util/logging/LogManager$LoggerContext
+java/util/logging/LogManager$LogNode
+java/util/logging/LoggingPermission
+java/util/logging/LogManager$Cleaner
+java/util/logging/LogManager$2
+java/util/logging/LogManager$3
+java/util/logging/LogManager$LoggerWeakRef
+java/util/logging/LogManager$LoggerContext$1
+java/util/logging/LogManager$RootLogger
+java/util/logging/LogManager$5
+java/util/logging/Logger$1
+sun/util/logging/resources/logging
+javax/swing/Box
+javax/swing/Box$Filler
+javax/swing/Icon
+javax/swing/BoxLayout
+javax/swing/plaf/basic/BasicPopupMenuUI
+javax/swing/plaf/PopupMenuUI
+javax/swing/ImageIcon
+javax/swing/ImageIcon$1
+javax/swing/ImageIcon$2
+javax/swing/ImageIcon$2$1
+java/awt/dnd/DropTarget
+java/awt/dnd/DropTargetListener
+javax/accessibility/AccessibleContext
+sun/reflect/UnsafeObjectFieldAccessorImpl
+java/awt/MediaTracker
+sun/misc/SoftCache$ValueCell
+sun/awt/image/URLImageSource
+sun/awt/image/InputStreamImageSource
+java/awt/image/ImageProducer
+sun/awt/image/ImageFetchable
+sun/awt/image/ToolkitImage
+sun/awt/image/NativeLibLoader
+sun/awt/image/NativeLibLoader$1
+javax/swing/ImageIcon$3
+java/awt/ImageMediaEntry
+java/awt/MediaEntry
+sun/awt/image/MultiResolutionToolkitImage
+sun/awt/image/MultiResolutionImage
+sun/awt/image/ImageRepresentation
+java/awt/image/ImageConsumer
+sun/awt/image/ImageWatched
+sun/awt/image/ImageWatched$Link
+sun/awt/image/ImageWatched$WeakLink
+sun/awt/image/ImageConsumerQueue
+sun/awt/image/ImageFetcher
+sun/awt/image/FetcherInfo
+sun/awt/image/ImageFetcher$1
+sun/net/ProgressMonitor
+sun/net/DefaultProgressMeteringPolicy
+sun/net/ProgressMeteringPolicy
+sun/net/www/MimeTable
+java/net/FileNameMap
+sun/net/www/MimeTable$1
+sun/net/www/MimeTable$DefaultInstanceHolder
+sun/net/www/MimeTable$DefaultInstanceHolder$1
+sun/net/www/MimeEntry
+java/net/URLConnection$1
+java/text/SimpleDateFormat
+java/text/DateFormat
+java/text/Format
+java/text/DateFormat$Field
+java/text/Format$Field
+java/util/TimeZone
+sun/util/calendar/ZoneInfo
+sun/util/calendar/ZoneInfoFile
+sun/util/calendar/ZoneInfoFile$1
+java/io/DataInputStream
+sun/util/calendar/ZoneInfoFile$ZoneOffsetTransitionRule
+sun/util/calendar/ZoneInfoFile$Checksum
+java/util/zip/CRC32
+java/util/zip/Checksum
+java/util/TimeZone$1
+java/util/Calendar
+sun/util/spi/CalendarProvider
+java/util/spi/LocaleServiceProvider
+sun/util/locale/provider/LocaleProviderAdapter
+sun/util/locale/provider/JRELocaleProviderAdapter
+sun/util/locale/provider/ResourceBundleBasedAdapter
+sun/util/locale/provider/SPILocaleProviderAdapter
+sun/util/locale/provider/AuxLocaleProviderAdapter
+sun/util/locale/provider/AuxLocaleProviderAdapter$NullProvider
+sun/util/locale/provider/LocaleProviderAdapter$Type
+sun/util/locale/provider/LocaleProviderAdapter$1
+sun/util/locale/provider/CalendarProviderImpl
+sun/util/locale/provider/AvailableLanguageTags
+sun/util/locale/provider/LocaleDataMetaInfo
+sun/util/locale/provider/JRELocaleProviderAdapter$1
+java/util/Calendar$Builder
+java/util/GregorianCalendar
+sun/util/locale/provider/CalendarDataUtility
+java/util/spi/CalendarDataProvider
+sun/util/locale/provider/LocaleServiceProviderPool
+java/text/spi/BreakIteratorProvider
+java/text/spi/CollatorProvider
+java/text/spi/DateFormatProvider
+java/text/spi/DateFormatSymbolsProvider
+java/text/spi/DecimalFormatSymbolsProvider
+java/text/spi/NumberFormatProvider
+java/util/spi/CurrencyNameProvider
+java/util/spi/LocaleNameProvider
+java/util/spi/TimeZoneNameProvider
+sun/util/locale/provider/CalendarDataProviderImpl
+sun/util/locale/provider/SPILocaleProviderAdapter$1
+sun/util/locale/provider/CalendarDataUtility$CalendarWeekParameterGetter
+sun/util/locale/provider/LocaleServiceProviderPool$LocalizedObjectGetter
+sun/util/locale/provider/LocaleResources
+sun/util/resources/LocaleData
+sun/util/resources/LocaleData$1
+sun/util/resources/LocaleData$LocaleDataResourceBundleControl
+sun/util/locale/LanguageTag
+java/util/Collections$EmptyIterator
+sun/util/resources/CalendarData
+sun/util/resources/LocaleNamesBundle
+sun/util/resources/OpenListResourceBundle
+sun/util/resources/en/CalendarData_en
+sun/util/locale/provider/LocaleResources$ResourceReference
+sun/util/calendar/Gregorian$Date
+sun/util/calendar/BaseCalendar$Date
+sun/util/calendar/CalendarDate
+sun/util/calendar/CalendarUtils
+java/text/DateFormatSymbols
+sun/util/locale/provider/DateFormatSymbolsProviderImpl
+sun/text/resources/FormatData
+sun/util/resources/ParallelListResourceBundle
+java/util/concurrent/atomic/AtomicMarkableReference
+java/util/concurrent/atomic/AtomicMarkableReference$Pair
+sun/text/resources/en/FormatData_en
+sun/text/resources/en/FormatData_en_US
+sun/util/resources/ParallelListResourceBundle$KeySet
+java/text/NumberFormat
+sun/util/locale/provider/NumberFormatProviderImpl
+java/text/DecimalFormatSymbols
+sun/util/locale/provider/DecimalFormatSymbolsProviderImpl
+java/util/Currency
+java/util/Currency$1
+sun/util/locale/provider/CurrencyNameProviderImpl
+java/util/Currency$CurrencyNameGetter
+sun/util/resources/CurrencyNames
+sun/util/resources/en/CurrencyNames_en_US
+java/text/DecimalFormat
+java/text/FieldPosition
+java/text/DigitList
+java/math/RoundingMode
+java/text/DontCareFieldPosition
+java/text/DontCareFieldPosition$1
+java/text/Format$FieldDelegate
+sun/awt/image/GifImageDecoder
+sun/awt/image/ImageDecoder
+sun/awt/image/GifFrame
+java/awt/image/Raster
+java/awt/image/DataBufferByte
+java/awt/image/DataBuffer
+java/awt/image/DataBuffer$1
+sun/awt/image/SunWritableRaster$DataStealer
+sun/awt/image/SunWritableRaster
+java/awt/image/WritableRaster
+java/awt/image/PixelInterleavedSampleModel
+java/awt/image/ComponentSampleModel
+java/awt/image/SampleModel
+sun/awt/image/ByteInterleavedRaster
+sun/awt/image/ByteComponentRaster
+java/awt/image/BufferedImage
+java/awt/image/WritableRenderedImage
+java/awt/image/RenderedImage
+java/awt/image/BufferedImage$1
+sun/awt/image/IntegerComponentRaster
+sun/awt/image/BytePackedRaster
+javax/swing/plaf/BorderUIResource
+javax/swing/BorderFactory
+javax/swing/border/BevelBorder
+javax/swing/border/EtchedBorder
+javax/swing/plaf/metal/MetalIconFactory
+javax/swing/plaf/metal/MetalIconFactory$TreeFolderIcon
+javax/swing/plaf/metal/MetalIconFactory$FolderIcon16
+java/util/zip/ZipInputStream
+java/io/PushbackInputStream
+java/util/zip/ZipUtils
+java/io/RandomAccessFile$1
+java/lang/Thread$State
+javax/swing/SwingUtilities$SharedOwnerFrame
+sun/awt/X11/XWindowAttributes
+javax/swing/border/LineBorder
+javax/swing/SizeRequirements
+java/util/ArrayList$ListItr
+javax/swing/CellRendererPane
+javax/swing/RepaintManager$3
+javax/swing/JRadioButton
+javax/swing/JToggleButton
+java/lang/ClassFormatError
+java/io/ObjectInputStream
+java/io/ObjectInput
+java/io/ObjectStreamConstants
+sun/awt/image/BufImgSurfaceManager
+sun/awt/image/BufImgSurfaceData
+sun/awt/image/BufImgSurfaceData$ICMColorData
+sun/java2d/x11/X11SurfaceDataProxy
+sun/java2d/x11/X11SurfaceDataProxy$Bitmask
+sun/java2d/StateTrackableDelegate$1
+javax/swing/JTabbedPane
+java/awt/geom/RectIterator
+java/awt/geom/PathIterator
+javax/swing/event/ChangeListener
+java/awt/Polygon
+javax/swing/event/MenuListener
+javax/swing/DefaultSingleSelectionModel
+javax/swing/SingleSelectionModel
+javax/swing/JTabbedPane$ModelListener
+javax/swing/plaf/metal/MetalTabbedPaneUI
+javax/swing/plaf/basic/BasicTabbedPaneUI
+javax/swing/plaf/TabbedPaneUI
+javax/swing/plaf/metal/MetalTabbedPaneUI$TabbedPaneLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$TabbedPaneLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$TabbedPaneScrollLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$Handler
+sun/reflect/MethodAccessorGenerator
+sun/reflect/AccessorGenerator
+sun/reflect/ClassFileConstants
+sun/reflect/ByteVectorFactory
+sun/reflect/ByteVectorImpl
+sun/reflect/ByteVector
+sun/reflect/ClassFileAssembler
+sun/reflect/UTF8
+sun/reflect/Label
+sun/reflect/Label$PatchInfo
+sun/reflect/MethodAccessorGenerator$1
+sun/reflect/ClassDefiner
+sun/reflect/ClassDefiner$1
+sun/reflect/BootstrapConstructorAccessorImpl
+javax/swing/JTextField
+javax/swing/JViewport
+java/awt/CardLayout
+javax/swing/text/Document
+javax/swing/text/JTextComponent$1
+sun/swing/SwingAccessor$JTextComponentAccessor
+javax/swing/text/JTextComponent$4
+com/sun/beans/util/Cache
+com/sun/beans/util/Cache$Kind
+com/sun/beans/util/Cache$Kind$1
+com/sun/beans/util/Cache$Kind$2
+com/sun/beans/util/Cache$Kind$3
+com/sun/beans/util/Cache$CacheEntry
+javax/swing/Action
+javax/swing/JTextField$NotifyAction
+javax/swing/text/TextAction
+javax/swing/AbstractAction
+java/lang/ArrayIndexOutOfBoundsException
+javax/swing/DropMode
+javax/swing/text/JTextComponent$MutableCaretEvent
+javax/swing/event/CaretEvent
+javax/swing/plaf/metal/MetalTextFieldUI
+javax/swing/plaf/basic/BasicTextFieldUI
+javax/swing/plaf/basic/BasicTextUI
+javax/swing/text/ViewFactory
+javax/swing/plaf/TextUI
+javax/swing/plaf/basic/BasicTextUI$BasicCursor
+javax/swing/text/DefaultEditorKit
+javax/swing/text/EditorKit
+javax/swing/text/DefaultEditorKit$InsertContentAction
+javax/swing/text/DefaultEditorKit$DeletePrevCharAction
+javax/swing/text/DefaultEditorKit$DeleteNextCharAction
+javax/swing/text/DefaultEditorKit$ReadOnlyAction
+javax/swing/text/DefaultEditorKit$DeleteWordAction
+javax/swing/text/DefaultEditorKit$WritableAction
+javax/swing/text/DefaultEditorKit$CutAction
+javax/swing/text/DefaultEditorKit$CopyAction
+javax/swing/text/DefaultEditorKit$PasteAction
+javax/swing/text/DefaultEditorKit$VerticalPageAction
+javax/swing/text/DefaultEditorKit$PageAction
+javax/swing/text/DefaultEditorKit$InsertBreakAction
+javax/swing/text/DefaultEditorKit$BeepAction
+javax/swing/text/DefaultEditorKit$NextVisualPositionAction
+javax/swing/text/DefaultEditorKit$BeginWordAction
+javax/swing/text/DefaultEditorKit$EndWordAction
+javax/swing/text/DefaultEditorKit$PreviousWordAction
+javax/swing/text/DefaultEditorKit$NextWordAction
+javax/swing/text/DefaultEditorKit$BeginLineAction
+javax/swing/text/DefaultEditorKit$EndLineAction
+javax/swing/text/DefaultEditorKit$BeginParagraphAction
+javax/swing/text/DefaultEditorKit$EndParagraphAction
+javax/swing/text/DefaultEditorKit$BeginAction
+javax/swing/text/DefaultEditorKit$EndAction
+javax/swing/text/DefaultEditorKit$DefaultKeyTypedAction
+javax/swing/text/DefaultEditorKit$InsertTabAction
+javax/swing/text/DefaultEditorKit$SelectWordAction
+javax/swing/text/DefaultEditorKit$SelectLineAction
+javax/swing/text/DefaultEditorKit$SelectParagraphAction
+javax/swing/text/DefaultEditorKit$SelectAllAction
+javax/swing/text/DefaultEditorKit$UnselectAction
+javax/swing/text/DefaultEditorKit$ToggleComponentOrientationAction
+javax/swing/text/DefaultEditorKit$DumpModelAction
+javax/swing/plaf/basic/BasicTextUI$TextTransferHandler
+javax/swing/TransferHandler
+javax/swing/TransferHandler$TransferAction
+sun/swing/UIAction
+javax/swing/text/Position$Bias
+javax/swing/plaf/basic/BasicTextUI$RootView
+javax/swing/text/View
+javax/swing/plaf/basic/BasicTextUI$UpdateHandler
+javax/swing/event/DocumentListener
+javax/swing/plaf/basic/BasicTextUI$DragListener
+javax/swing/plaf/basic/DragRecognitionSupport$BeforeDrag
+javax/swing/event/MouseInputAdapter
+javax/swing/event/MouseInputListener
+java/awt/event/MouseAdapter
+javax/swing/plaf/metal/MetalBorders
+javax/swing/plaf/BorderUIResource$CompoundBorderUIResource
+javax/swing/border/CompoundBorder
+javax/swing/plaf/metal/MetalBorders$TextFieldBorder
+javax/swing/plaf/metal/MetalBorders$Flush3DBorder
+javax/swing/plaf/basic/BasicBorders$MarginBorder
+javax/swing/plaf/basic/BasicTextUI$BasicCaret
+javax/swing/text/DefaultCaret
+javax/swing/text/Caret
+javax/swing/text/DefaultCaret$Handler
+java/awt/datatransfer/ClipboardOwner
+javax/swing/Timer
+javax/swing/Timer$DoPostEvent
+javax/swing/plaf/basic/BasicTextUI$BasicHighlighter
+javax/swing/text/DefaultHighlighter
+javax/swing/text/LayeredHighlighter
+javax/swing/text/Highlighter
+javax/swing/text/Highlighter$Highlight
+javax/swing/text/DefaultHighlighter$DefaultHighlightPainter
+javax/swing/text/LayeredHighlighter$LayerPainter
+javax/swing/text/Highlighter$HighlightPainter
+javax/swing/text/DefaultHighlighter$SafeDamager
+javax/swing/ClientPropertyKey
+javax/swing/ClientPropertyKey$1
+sun/awt/AWTAccessor$ClientPropertyKeyAccessor
+javax/swing/TransferHandler$SwingDropTarget
+java/awt/dnd/DropTargetContext
+java/awt/datatransfer/SystemFlavorMap
+java/awt/datatransfer/FlavorMap
+java/awt/datatransfer/FlavorTable
+java/awt/datatransfer/SystemFlavorMap$SoftCache
+javax/swing/TransferHandler$DropHandler
+javax/swing/TransferHandler$TransferSupport
+javax/swing/text/PlainDocument
+javax/swing/text/AbstractDocument
+javax/swing/text/GapContent
+javax/swing/text/AbstractDocument$Content
+javax/swing/text/GapVector
+javax/swing/text/GapContent$MarkVector
+javax/swing/text/GapContent$MarkData
+javax/swing/text/StyleContext
+javax/swing/text/AbstractDocument$AttributeContext
+javax/swing/text/StyleConstants
+javax/swing/text/StyleConstants$CharacterConstants
+javax/swing/text/AttributeSet$CharacterAttribute
+javax/swing/text/StyleConstants$FontConstants
+javax/swing/text/AttributeSet$FontAttribute
+javax/swing/text/StyleConstants$ColorConstants
+javax/swing/text/AttributeSet$ColorAttribute
+javax/swing/text/StyleConstants$ParagraphConstants
+javax/swing/text/AttributeSet$ParagraphAttribute
+javax/swing/text/StyleContext$FontKey
+javax/swing/text/SimpleAttributeSet
+javax/swing/text/MutableAttributeSet
+javax/swing/text/AttributeSet
+javax/swing/text/SimpleAttributeSet$EmptyAttributeSet
+javax/swing/text/StyleContext$NamedStyle
+javax/swing/text/Style
+java/util/Collections$EmptyEnumeration
+javax/swing/text/StyleContext$SmallAttributeSet
+java/util/Collections$3
+javax/swing/text/AbstractDocument$BidiRootElement
+javax/swing/text/AbstractDocument$BranchElement
+javax/swing/text/AbstractDocument$AbstractElement
+javax/swing/text/Element
+javax/swing/tree/TreeNode
+javax/swing/text/AbstractDocument$1
+javax/swing/text/AbstractDocument$BidiElement
+javax/swing/text/AbstractDocument$LeafElement
+javax/swing/text/GapContent$StickyPosition
+javax/swing/text/Position
+javax/swing/text/StyleContext$KeyEnumeration
+javax/swing/text/FieldView
+javax/swing/text/PlainView
+javax/swing/text/TabExpander
+javax/swing/text/JTextComponent$DefaultKeymap
+javax/swing/text/Keymap
+javax/swing/text/JTextComponent$KeymapWrapper
+javax/swing/text/JTextComponent$KeymapActionMap
+javax/swing/plaf/basic/BasicTextUI$FocusAction
+javax/swing/plaf/basic/BasicTextUI$TextActionWrapper
+javax/swing/plaf/synth/SynthUI
+javax/swing/plaf/synth/SynthConstants
+javax/swing/JEditorPane
+javax/swing/DefaultBoundedRangeModel
+javax/swing/BoundedRangeModel
+javax/swing/JTextField$ScrollRepainter
+javax/swing/DefaultButtonModel
+javax/swing/ButtonModel
+javax/swing/AbstractButton$Handler
+javax/swing/plaf/basic/BasicButtonUI
+javax/swing/plaf/ButtonUI
+javax/swing/plaf/metal/MetalBorders$ButtonBorder
+javax/swing/plaf/basic/BasicButtonListener
+javax/swing/event/AncestorListener
+java/beans/VetoableChangeListener
+javax/swing/plaf/metal/MetalComboBoxButton
+javax/swing/plaf/basic/BasicArrowButton
+javax/swing/plaf/metal/MetalScrollButton
+sun/swing/ImageIconUIResource
+javax/swing/GrayFilter
+java/awt/image/RGBImageFilter
+java/awt/image/ImageFilter
+java/awt/image/FilteredImageSource
+javax/swing/plaf/basic/BasicGraphicsUtils
+javax/swing/ButtonGroup
+org/w3c/dom/Node
+org/xml/sax/SAXException
+javax/xml/parsers/ParserConfigurationException
+org/xml/sax/EntityResolver
+java/security/NoSuchAlgorithmException
+java/security/GeneralSecurityException
+java/util/zip/GZIPInputStream
+java/util/zip/DeflaterOutputStream
+java/io/StringReader
+org/xml/sax/InputSource
+javax/xml/parsers/DocumentBuilderFactory
+javax/xml/parsers/FactoryFinder
+javax/xml/parsers/SecuritySupport
+javax/xml/parsers/SecuritySupport$2
+javax/xml/parsers/SecuritySupport$5
+javax/xml/parsers/FactoryFinder$1
+javax/xml/parsers/DocumentBuilder
+org/xml/sax/ErrorHandler
+org/w3c/dom/Document
+org/xml/sax/helpers/DefaultHandler
+org/xml/sax/DTDHandler
+org/xml/sax/ContentHandler
+org/xml/sax/SAXNotRecognizedException
+org/xml/sax/SAXNotSupportedException
+org/xml/sax/Locator
+org/xml/sax/SAXParseException
+org/w3c/dom/NodeList
+org/w3c/dom/events/EventTarget
+org/w3c/dom/traversal/DocumentTraversal
+org/w3c/dom/events/DocumentEvent
+org/w3c/dom/ranges/DocumentRange
+org/w3c/dom/Element
+org/w3c/dom/CharacterData
+org/w3c/dom/CDATASection
+org/w3c/dom/Text
+org/w3c/dom/Entity
+org/xml/sax/AttributeList
+org/w3c/dom/DOMException
+org/w3c/dom/DocumentType
+org/w3c/dom/Attr
+org/w3c/dom/EntityReference
+org/w3c/dom/DocumentFragment
+org/w3c/dom/ProcessingInstruction
+org/w3c/dom/Notation
+org/w3c/dom/Comment
+org/w3c/dom/events/EventException
+org/w3c/dom/events/Event
+org/w3c/dom/events/MutationEvent
+org/w3c/dom/traversal/TreeWalker
+org/w3c/dom/ranges/Range
+org/w3c/dom/traversal/NodeIterator
+org/w3c/dom/NamedNodeMap
+java/awt/GridLayout
+javax/swing/JToggleButton$ToggleButtonModel
+javax/swing/plaf/metal/MetalRadioButtonUI
+javax/swing/plaf/basic/BasicRadioButtonUI
+javax/swing/plaf/basic/BasicToggleButtonUI
+javax/swing/plaf/basic/BasicBorders
+javax/swing/plaf/basic/BasicBorders$RadioButtonBorder
+javax/swing/plaf/basic/BasicBorders$ButtonBorder
+javax/swing/plaf/metal/MetalIconFactory$RadioButtonIcon
+javax/swing/plaf/basic/BasicRadioButtonUI$KeyHandler
+javax/swing/plaf/basic/BasicRadioButtonUI$SelectPreviousBtn
+javax/swing/plaf/basic/BasicRadioButtonUI$SelectNextBtn
+javax/swing/event/ChangeEvent
+java/awt/event/ItemEvent
+javax/swing/ToolTipManager
+javax/swing/ToolTipManager$insideTimerAction
+javax/swing/ToolTipManager$outsideTimerAction
+javax/swing/ToolTipManager$stillInsideTimerAction
+javax/swing/ToolTipManager$MoveBeforeEnterListener
+java/awt/event/MouseMotionAdapter
+javax/swing/ToolTipManager$AccessibilityKeyListener
+java/awt/event/KeyAdapter
+java/awt/CardLayout$Card
+javax/swing/JComboBox
+javax/swing/event/ListDataListener
+javax/swing/JCheckBox
+javax/swing/JPopupMenu
+javax/swing/MenuElement
+javax/swing/DefaultComboBoxModel
+javax/swing/MutableComboBoxModel
+javax/swing/ComboBoxModel
+javax/swing/ListModel
+javax/swing/AbstractListModel
+javax/swing/JComboBox$1
+javax/swing/AncestorNotifier
+javax/swing/plaf/metal/MetalComboBoxUI
+javax/swing/plaf/basic/BasicComboBoxUI
+javax/swing/plaf/ComboBoxUI
+javax/swing/plaf/metal/MetalComboBoxUI$MetalComboBoxLayoutManager
+javax/swing/plaf/basic/BasicComboBoxUI$ComboBoxLayoutManager
+javax/swing/plaf/basic/BasicComboPopup
+javax/swing/plaf/basic/ComboPopup
+javax/swing/plaf/basic/BasicComboPopup$EmptyListModelClass
+javax/swing/plaf/basic/BasicLookAndFeel$AWTEventHelper
+java/awt/event/AWTEventListenerProxy
+java/awt/Toolkit$SelectiveAWTEventListener
+java/awt/Toolkit$ToolkitEventMulticaster
+javax/swing/plaf/basic/BasicLookAndFeel$1
+javax/swing/plaf/basic/DefaultMenuLayout
+javax/swing/plaf/metal/MetalBorders$PopupMenuBorder
+javax/swing/plaf/basic/BasicPopupMenuUI$BasicPopupMenuListener
+javax/swing/event/PopupMenuListener
+javax/swing/plaf/basic/BasicPopupMenuUI$BasicMenuKeyListener
+javax/swing/event/MenuKeyListener
+javax/swing/plaf/basic/BasicPopupMenuUI$MouseGrabber
+javax/swing/MenuSelectionManager
+javax/swing/plaf/basic/BasicPopupMenuUI$MenuKeyboardHelper
+javax/swing/plaf/basic/BasicPopupMenuUI$MenuKeyboardHelper$1
+java/awt/event/FocusAdapter
+javax/swing/plaf/basic/BasicComboPopup$1
+javax/swing/JList
+javax/swing/DefaultListSelectionModel
+javax/swing/ListSelectionModel
+javax/swing/plaf/basic/BasicListUI
+javax/swing/plaf/ListUI
+javax/swing/plaf/basic/BasicListUI$ListTransferHandler
+javax/swing/DefaultListCellRenderer$UIResource
+javax/swing/DefaultListCellRenderer
+javax/swing/ListCellRenderer
+javax/swing/plaf/basic/BasicListUI$Handler
+javax/swing/event/ListSelectionListener
+javax/swing/JMenu
+javax/swing/JMenuItem
+javax/swing/event/ListSelectionEvent
+javax/swing/plaf/basic/BasicComboPopup$Handler
+javax/swing/ScrollPaneLayout$UIResource
+javax/swing/ScrollPaneLayout
+javax/swing/ViewportLayout
+javax/swing/plaf/basic/BasicViewportUI
+javax/swing/plaf/ViewportUI
+javax/swing/JScrollPane$ScrollBar
+javax/swing/JScrollBar
+java/awt/Adjustable
+javax/swing/JScrollBar$ModelListener
+javax/swing/plaf/metal/MetalScrollBarUI
+javax/swing/plaf/basic/BasicScrollBarUI
+javax/swing/plaf/ScrollBarUI
+javax/swing/plaf/metal/MetalBumps
+javax/swing/plaf/basic/BasicScrollBarUI$TrackListener
+javax/swing/plaf/basic/BasicScrollBarUI$ArrowButtonListener
+javax/swing/plaf/basic/BasicScrollBarUI$ModelListener
+javax/swing/plaf/metal/MetalScrollBarUI$ScrollBarListener
+javax/swing/plaf/basic/BasicScrollBarUI$PropertyChangeHandler
+javax/swing/plaf/basic/BasicScrollBarUI$Handler
+javax/swing/plaf/basic/BasicScrollBarUI$ScrollListener
+javax/swing/JViewport$ViewListener
+javax/swing/plaf/metal/MetalScrollPaneUI
+javax/swing/plaf/basic/BasicScrollPaneUI
+javax/swing/plaf/ScrollPaneUI
+javax/swing/plaf/metal/MetalBorders$ScrollPaneBorder
+javax/swing/plaf/basic/BasicScrollPaneUI$Handler
+javax/swing/plaf/metal/MetalScrollPaneUI$1
+javax/swing/plaf/basic/BasicComboBoxRenderer$UIResource
+javax/swing/plaf/basic/BasicComboBoxRenderer
+javax/swing/plaf/metal/MetalComboBoxEditor$UIResource
+javax/swing/plaf/metal/MetalComboBoxEditor
+javax/swing/plaf/basic/BasicComboBoxEditor
+javax/swing/ComboBoxEditor
+javax/swing/plaf/basic/BasicComboBoxEditor$BorderlessTextField
+javax/swing/plaf/basic/BasicComboBoxEditor$UIResource
+javax/swing/text/Segment
+java/text/CharacterIterator
+javax/swing/plaf/metal/MetalComboBoxEditor$1
+javax/swing/plaf/metal/MetalComboBoxEditor$EditorBorder
+javax/swing/JToolBar
+javax/swing/plaf/metal/MetalComboBoxUI$MetalPropertyChangeListener
+javax/swing/plaf/basic/BasicComboBoxUI$PropertyChangeHandler
+javax/swing/plaf/basic/BasicComboBoxUI$Handler
+javax/swing/plaf/metal/MetalComboBoxIcon
+javax/swing/plaf/metal/MetalComboBoxButton$1
+javax/swing/plaf/basic/BasicComboBoxUI$DefaultKeySelectionManager
+javax/swing/JComboBox$KeySelectionManager
+javax/swing/plaf/metal/MetalCheckBoxUI
+javax/swing/plaf/metal/MetalIconFactory$CheckBoxIcon
+java/lang/ExceptionInInitializerError
+com/sun/java/swing/plaf/windows/WindowsTabbedPaneUI
+javax/swing/JProgressBar
+javax/swing/JProgressBar$ModelListener
+javax/swing/plaf/metal/MetalProgressBarUI
+javax/swing/plaf/basic/BasicProgressBarUI
+javax/swing/plaf/ProgressBarUI
+javax/swing/plaf/BorderUIResource$LineBorderUIResource
+javax/swing/plaf/basic/BasicProgressBarUI$Handler
+javax/swing/JTable
+javax/swing/event/TableModelListener
+javax/swing/event/TableColumnModelListener
+javax/swing/event/CellEditorListener
+javax/swing/event/RowSorterListener
+javax/swing/tree/TreeModel
+javax/swing/table/JTableHeader
+javax/swing/table/AbstractTableModel
+javax/swing/table/TableModel
+javax/swing/table/TableCellRenderer
+javax/swing/event/TreeExpansionListener
+javax/swing/table/DefaultTableCellRenderer
+javax/swing/JCheckBoxMenuItem
+javax/swing/JTree
+javax/swing/tree/TreeSelectionModel
+javax/swing/tree/DefaultTreeCellRenderer
+javax/swing/tree/TreeCellRenderer
+javax/swing/table/TableCellEditor
+javax/swing/CellEditor
+javax/swing/JToolTip
+javax/swing/table/TableColumn
+javax/swing/table/DefaultTableColumnModel
+javax/swing/table/TableColumnModel
+javax/swing/table/DefaultTableModel
+javax/swing/event/TableModelEvent
+sun/swing/table/DefaultTableCellHeaderRenderer
+sun/swing/table/DefaultTableCellHeaderRenderer$EmptyIcon
+javax/swing/plaf/basic/BasicTableHeaderUI
+javax/swing/plaf/TableHeaderUI
+javax/swing/plaf/basic/BasicTableHeaderUI$1
+javax/swing/plaf/basic/BasicTableHeaderUI$MouseInputHandler
+javax/swing/DefaultCellEditor
+javax/swing/tree/TreeCellEditor
+javax/swing/AbstractCellEditor
+javax/swing/plaf/basic/BasicTableUI
+javax/swing/plaf/TableUI
+javax/swing/plaf/basic/BasicTableUI$TableTransferHandler
+javax/swing/plaf/basic/BasicTableUI$Handler
+javax/swing/tree/DefaultTreeSelectionModel
+javax/swing/tree/TreePath
+javax/swing/plaf/metal/MetalTreeUI
+javax/swing/plaf/basic/BasicTreeUI
+javax/swing/plaf/TreeUI
+javax/swing/plaf/basic/BasicTreeUI$Actions
+javax/swing/plaf/basic/BasicTreeUI$TreeTransferHandler
+javax/swing/plaf/metal/MetalTreeUI$LineListener
+javax/swing/plaf/basic/BasicTreeUI$Handler
+javax/swing/event/TreeModelListener
+javax/swing/event/TreeSelectionListener
+javax/swing/event/SwingPropertyChangeSupport
+javax/swing/tree/VariableHeightLayoutCache
+javax/swing/tree/AbstractLayoutCache
+javax/swing/tree/RowMapper
+javax/swing/plaf/basic/BasicTreeUI$NodeDimensionsHandler
+javax/swing/tree/AbstractLayoutCache$NodeDimensions
+javax/swing/JTree$TreeModelHandler
+javax/swing/tree/VariableHeightLayoutCache$TreeStateNode
+javax/swing/tree/DefaultMutableTreeNode
+javax/swing/tree/MutableTreeNode
+javax/swing/tree/DefaultMutableTreeNode$PreorderEnumeration
+java/util/Vector$1
+javax/swing/event/TableColumnModelEvent
+javax/swing/JPopupMenu$Separator
+javax/swing/JSeparator
+java/text/ParseException
+java/text/NumberFormat$Field
+javax/swing/text/GapContent$InsertUndo
+javax/swing/undo/AbstractUndoableEdit
+javax/swing/undo/UndoableEdit
+javax/swing/text/AbstractDocument$DefaultDocumentEvent
+javax/swing/event/DocumentEvent
+javax/swing/undo/CompoundEdit
+javax/swing/event/DocumentEvent$EventType
+javax/swing/text/Utilities
+javax/swing/text/SegmentCache
+javax/swing/text/SegmentCache$CachedSegment
+javax/swing/event/DocumentEvent$ElementChange
+javax/swing/event/UndoableEditEvent
+javax/swing/event/UndoableEditListener
+java/awt/Canvas
+java/util/Locale$Category
+java/util/Locale$1
+javax/swing/filechooser/FileFilter
+java/io/FileWriter
+javax/swing/tree/DefaultTreeModel
+javax/swing/tree/DefaultTreeCellEditor
+javax/swing/tree/DefaultTreeCellEditor$1
+javax/swing/tree/DefaultTreeCellEditor$DefaultTextField
+javax/swing/DefaultCellEditor$1
+javax/swing/DefaultCellEditor$EditorDelegate
+javax/swing/tree/DefaultTreeCellEditor$EditorContainer
+javax/swing/JTree$TreeSelectionRedirector
+javax/swing/JMenuItem$MenuItemFocusListener
+javax/swing/plaf/basic/BasicMenuItemUI
+javax/swing/plaf/MenuItemUI
+javax/swing/plaf/metal/MetalBorders$MenuItemBorder
+javax/swing/plaf/metal/MetalIconFactory$MenuItemArrowIcon
+sun/swing/MenuItemLayoutHelper
+javax/swing/plaf/basic/BasicMenuItemUI$Handler
+javax/swing/event/MenuDragMouseListener
+javax/swing/event/TreeModelEvent
+javax/swing/JSplitPane
+javax/swing/plaf/metal/MetalSplitPaneUI
+javax/swing/plaf/basic/BasicSplitPaneUI
+javax/swing/plaf/SplitPaneUI
+javax/swing/plaf/basic/BasicSplitPaneDivider
+javax/swing/plaf/basic/BasicBorders$SplitPaneBorder
+javax/swing/plaf/metal/MetalSplitPaneDivider
+javax/swing/plaf/basic/BasicSplitPaneDivider$DividerLayout
+javax/swing/plaf/basic/BasicSplitPaneDivider$MouseHandler
+javax/swing/plaf/basic/BasicBorders$SplitPaneDividerBorder
+javax/swing/plaf/basic/BasicSplitPaneUI$BasicHorizontalLayoutManager
+javax/swing/plaf/basic/BasicSplitPaneUI$1
+javax/swing/plaf/basic/BasicSplitPaneUI$Handler
+javax/swing/plaf/metal/MetalSplitPaneDivider$1
+javax/swing/plaf/basic/BasicSplitPaneDivider$OneTouchActionHandler
+javax/swing/plaf/metal/MetalSplitPaneDivider$2
+javax/swing/border/TitledBorder
+javax/swing/plaf/basic/BasicTextAreaUI
+javax/swing/text/AbstractDocument$ElementEdit
+java/util/Random
+java/util/concurrent/atomic/AtomicLong
+java/io/InterruptedIOException
+java/net/NoRouteToHostException
+java/net/BindException
+javax/swing/tree/PathPlaceHolder
+javax/swing/event/TreeSelectionEvent
+javax/swing/JList$3
+javax/swing/JList$ListSelectionHandler
+javax/swing/JSlider
+javax/swing/JSlider$ModelListener
+javax/swing/plaf/metal/MetalSliderUI
+javax/swing/plaf/basic/BasicSliderUI
+javax/swing/plaf/SliderUI
+javax/swing/plaf/basic/BasicSliderUI$Actions
+javax/swing/plaf/metal/MetalIconFactory$HorizontalSliderThumbIcon
+javax/swing/plaf/metal/MetalIconFactory$VerticalSliderThumbIcon
+javax/swing/plaf/basic/BasicSliderUI$TrackListener
+javax/swing/plaf/basic/BasicSliderUI$Handler
+javax/swing/plaf/basic/BasicSliderUI$ScrollListener
+javax/swing/plaf/metal/MetalSliderUI$MetalPropertyListener
+javax/swing/plaf/basic/BasicSliderUI$PropertyChangeHandler
+java/util/concurrent/ConcurrentHashMap$KeyIterator
+java/util/concurrent/ConcurrentHashMap$BaseIterator
+java/util/concurrent/ConcurrentHashMap$Traverser
+sun/font/Type1Font$1
+java/nio/channels/FileChannel$MapMode
+sun/nio/ch/FileChannelImpl$Unmapper
+sun/nio/ch/Util$4
+java/nio/DirectByteBufferR
+sun/nio/cs/US_ASCII$Decoder
+sun/font/SunFontManager$10
+java/util/concurrent/ConcurrentHashMap$ValueIterator
+javax/swing/DefaultListModel
+javax/swing/event/ListDataEvent
+javax/sound/sampled/DataLine
+javax/sound/sampled/Line
+javax/sound/sampled/LineUnavailableException
+javax/sound/sampled/UnsupportedAudioFileException
+javax/sound/sampled/Line$Info
+javax/sound/sampled/DataLine$Info
+javax/sound/sampled/Control$Type
+javax/sound/sampled/FloatControl$Type
+javax/swing/JMenuBar
+javax/swing/plaf/basic/BasicMenuBarUI
+javax/swing/plaf/MenuBarUI
+javax/swing/plaf/metal/MetalBorders$MenuBarBorder
+javax/swing/plaf/basic/BasicMenuBarUI$Handler
+javax/swing/KeyboardManager
+javax/swing/JRadioButtonMenuItem
+javax/swing/JMenu$MenuChangeListener
+javax/swing/plaf/basic/BasicMenuUI
+javax/swing/plaf/metal/MetalIconFactory$MenuArrowIcon
+javax/swing/plaf/basic/BasicMenuUI$Handler
+javax/swing/JMenuItem$AccessibleJMenuItem
+javax/swing/AbstractButton$AccessibleAbstractButton
+javax/accessibility/AccessibleAction
+javax/accessibility/AccessibleValue
+javax/accessibility/AccessibleText
+javax/accessibility/AccessibleExtendedComponent
+javax/accessibility/AccessibleComponent
+javax/swing/JComponent$AccessibleJComponent
+java/awt/Container$AccessibleAWTContainer
+java/awt/Component$AccessibleAWTComponent
+javax/accessibility/AccessibleContext$1
+sun/awt/AWTAccessor$AccessibleContextAccessor
+javax/accessibility/AccessibleRelationSet
+javax/swing/JMenu$WinListener
+java/awt/event/WindowAdapter
+javax/swing/plaf/metal/MetalPopupMenuSeparatorUI
+javax/swing/plaf/metal/MetalSeparatorUI
+javax/swing/plaf/basic/BasicSeparatorUI
+javax/swing/plaf/SeparatorUI
+javax/accessibility/AccessibleState
+javax/accessibility/AccessibleBundle
+javax/swing/plaf/basic/BasicCheckBoxMenuItemUI
+javax/swing/plaf/metal/MetalIconFactory$CheckBoxMenuItemIcon
+javax/swing/JCheckBoxMenuItem$AccessibleJCheckBoxMenuItem
+javax/swing/plaf/basic/BasicRadioButtonMenuItemUI
+javax/swing/plaf/metal/MetalIconFactory$RadioButtonMenuItemIcon
+java/awt/event/ContainerEvent
+sun/awt/image/ImageDecoder$1
+java/awt/im/InputContext
+sun/awt/im/InputMethodContext
+java/awt/im/spi/InputMethodContext
+java/awt/im/InputMethodRequests
+sun/awt/im/InputContext
+sun/awt/im/InputMethodManager
+sun/awt/im/ExecutableInputMethodManager
+sun/awt/X11/XInputMethodDescriptor
+sun/awt/X11InputMethodDescriptor
+java/awt/im/spi/InputMethodDescriptor
+sun/awt/im/InputMethodLocator
+sun/awt/im/ExecutableInputMethodManager$3
+javax/swing/JTabbedPane$Page
+java/net/DatagramSocket
+java/net/MulticastSocket
+java/net/DatagramPacket
+java/net/DatagramPacket$1
+java/net/DefaultDatagramSocketImplFactory
+java/net/PlainDatagramSocketImpl
+java/net/AbstractPlainDatagramSocketImpl
+java/net/DatagramSocketImpl
+java/net/AbstractPlainDatagramSocketImpl$1
+java/net/NetworkInterface
+java/net/NetworkInterface$1
+java/net/InterfaceAddress
+java/net/DefaultInterface
+java/net/DatagramSocket$1
+java/net/SocketOption
+sun/net/ResourceManager
+java/text/Collator
+sun/util/locale/provider/CollatorProviderImpl
+java/util/Collections$UnmodifiableList$1
+sun/text/resources/CollationData
+java/text/RuleBasedCollator
+java/text/RBCollationTables
+java/net/ServerSocket
+java/text/RBTableBuilder
+java/text/RBCollationTables$BuildAPI
+sun/text/IntHashtable
+sun/text/UCompactIntArray
+sun/text/normalizer/NormalizerImpl
+sun/text/normalizer/ICUData
+sun/text/normalizer/NormalizerDataReader
+sun/text/normalizer/ICUBinary$Authenticate
+sun/text/normalizer/ICUBinary
+sun/text/normalizer/NormalizerImpl$FCDTrieImpl
+sun/text/normalizer/Trie$DataManipulate
+sun/text/normalizer/NormalizerImpl$NormTrieImpl
+sun/text/normalizer/NormalizerImpl$AuxTrieImpl
+sun/text/normalizer/IntTrie
+sun/text/normalizer/Trie
+sun/text/normalizer/CharTrie
+sun/text/normalizer/CharTrie$FriendAgent
+sun/text/normalizer/UnicodeSet
+sun/text/normalizer/UnicodeMatcher
+sun/text/normalizer/NormalizerImpl$DecomposeArgs
+java/text/MergeCollation
+java/text/PatternEntry$Parser
+java/text/PatternEntry
+java/text/EntryPair
+sun/text/ComposedCharIter
+sun/text/normalizer/UTF16
+sun/net/www/protocol/http/Handler
+java/security/SignatureException
+java/security/InvalidKeyException
+java/security/KeyException
+java/security/Signature
+java/security/SignatureSpi
+java/io/ObjectInputStream$BlockDataInputStream
+java/io/ObjectInputStream$PeekInputStream
+java/io/ObjectInputStream$HandleTable
+java/io/ObjectInputStream$HandleTable$HandleList
+java/io/ObjectInputStream$ValidationList
+java/io/Bits
+java/io/ObjectStreamClass
+java/io/ObjectOutputStream
+java/io/ObjectOutput
+sun/security/provider/DSAPublicKey
+java/security/interfaces/DSAPublicKey
+java/security/interfaces/DSAKey
+java/security/PublicKey
+java/security/Key
+sun/security/x509/X509Key
+java/io/ObjectStreamClass$Caches
+java/io/ObjectStreamClass$WeakClassKey
+java/io/ObjectStreamClass$EntryFuture
+java/lang/reflect/Proxy
+java/lang/reflect/InvocationHandler
+java/lang/reflect/WeakCache
+java/lang/reflect/Proxy$KeyFactory
+java/lang/reflect/Proxy$ProxyClassFactory
+java/io/Externalizable
+java/io/ObjectStreamClass$2
+java/util/ComparableTimSort
+sun/security/x509/AlgorithmId
+sun/security/util/DerEncoder
+sun/reflect/SerializationConstructorAccessorImpl
+sun/security/util/BitArray
+sun/reflect/UnsafeQualifiedStaticLongFieldAccessorImpl
+java/io/ObjectStreamClass$FieldReflectorKey
+java/io/ObjectStreamClass$FieldReflector
+java/io/ObjectStreamClass$1
+java/io/DataOutputStream
+java/io/ObjectStreamClass$MemberSignature
+java/io/ObjectStreamClass$3
+sun/security/util/DerOutputStream
+java/io/ObjectStreamClass$4
+java/io/ObjectStreamClass$5
+sun/security/util/DerValue
+java/security/MessageDigest
+java/security/MessageDigestSpi
+sun/security/jca/GetInstance
+sun/security/jca/Providers
+java/lang/InheritableThreadLocal
+sun/security/jca/ProviderList
+sun/security/jca/ProviderConfig
+java/math/BigInteger
+java/security/Provider
+sun/security/jca/ProviderList$3
+sun/security/jca/ProviderList$1
+java/security/Provider$ServiceKey
+java/security/Provider$EngineDescription
+java/security/interfaces/DSAParams
+sun/security/jca/ProviderList$2
+sun/security/jca/ProviderConfig$2
+java/io/ObjectStreamClass$ClassDataSlot
+sun/security/provider/Sun
+java/io/SerialCallbackContext
+sun/security/provider/SunEntries
+sun/security/provider/SunEntries$1
+sun/security/provider/NativePRNG
+java/security/SecureRandomSpi
+sun/security/provider/NativePRNG$Variant
+sun/security/util/DerInputStream
+sun/security/provider/NativePRNG$1
+sun/security/provider/NativePRNG$2
+sun/security/provider/NativePRNG$RandomIO
+sun/security/util/DerInputBuffer
+sun/security/provider/NativePRNG$Blocking
+sun/security/provider/NativePRNG$NonBlocking
+sun/security/util/ObjectIdentifier
+java/security/Provider$Service
+java/security/Provider$UString
+sun/security/provider/SHA
+sun/security/provider/DigestBase
+sun/security/jca/GetInstance$Instance
+java/security/MessageDigest$Delegate
+sun/security/provider/ByteArrayAccess
+java/io/ObjectOutputStream$BlockDataOutputStream
+java/security/AlgorithmParameters
+java/io/ObjectOutputStream$HandleTable
+java/io/ObjectOutputStream$ReplaceTable
+java/security/AlgorithmParametersSpi
+sun/security/provider/DSAParameters
+sun/security/util/ByteArrayLexOrder
+sun/security/util/ByteArrayTagOrder
+sun/security/util/DerIndefLenConverter
+java/io/ObjectStreamClass$ExceptionInfo
+java/io/ObjectInputStream$GetFieldImpl
+java/io/ObjectInputStream$GetField
+java/math/BigInteger$UnsafeHolder
+sun/security/jca/ServiceId
+sun/security/jca/ProviderList$ServiceList
+sun/security/jca/ProviderList$ServiceList$1
+java/security/Signature$Delegate
+java/util/ArrayList$SubList
+java/util/ArrayList$SubList$1
+java/security/interfaces/DSAPrivateKey
+java/security/PrivateKey
+javax/security/auth/Destroyable
+sun/security/provider/DSA$SHA1withDSA
+sun/security/provider/DSA$LegacyDSA
+sun/security/provider/DSA
+java/security/spec/DSAParameterSpec
+java/security/spec/AlgorithmParameterSpec
+java/math/MutableBigInteger
+java/math/SignedMutableBigInteger
+javax/swing/TimerQueue
+java/util/concurrent/DelayQueue
+java/util/concurrent/BlockingQueue
+java/util/AbstractQueue
+java/util/PriorityQueue
+javax/swing/TimerQueue$1
+javax/swing/TimerQueue$DelayedTimer
+java/util/concurrent/Delayed
+java/util/concurrent/TimeUnit
+java/util/concurrent/TimeUnit$1
+java/util/concurrent/TimeUnit$2
+java/util/concurrent/TimeUnit$3
+java/util/concurrent/TimeUnit$4
+java/util/concurrent/TimeUnit$5
+java/util/concurrent/TimeUnit$6
+java/util/concurrent/TimeUnit$7
+java/awt/Window$1DisposeAction
+java/awt/EventQueue$1AWTInvocationLock
+sun/awt/X11/XUnmapEvent
+java/awt/LightweightDispatcher$2
+java/awt/Component$FlipBufferStrategy
+java/awt/SentEvent
+sun/java2d/cmm/CMSManager
+java/awt/image/DataBufferInt
+java/awt/image/SinglePixelPackedSampleModel
+sun/awt/image/IntegerInterleavedRaster
+sun/awt/X11/XDropTargetRegistry
+sun/awt/X11/XEmbeddedFramePeer
+sun/awt/X11/XDragAndDropProtocols
+sun/awt/X11/XDropTargetContextPeer
+sun/awt/dnd/SunDropTargetContextPeer
+java/awt/dnd/peer/DropTargetContextPeer
+java/awt/datatransfer/Transferable
+sun/awt/X11/XDropTargetContextPeer$XDropTargetProtocolListenerImpl
+sun/awt/X11/XDropTargetProtocolListener
+sun/awt/X11/XDnDDragSourceProtocol
+sun/awt/X11/XDragSourceProtocol
+sun/awt/X11/MotifDnDDragSourceProtocol
+sun/awt/X11/XDnDDropTargetProtocol
+sun/awt/X11/XDropTargetProtocol
+sun/awt/X11/MotifDnDDropTargetProtocol
+sun/awt/X11/XErrorHandler$VerifyChangePropertyHandler
+sun/awt/X11/XDnDConstants
+sun/awt/X11/XSelection
+sun/awt/X11/XSelection$IncrementalTransferHandler
+sun/awt/X11/XSelection$SelectionEventHandler
+sun/awt/X11/MotifDnDConstants
+javax/swing/JLayer
+javax/swing/JInternalFrame
+javax/swing/KeyboardManager$ComponentKeyStrokePair
+sun/awt/EmbeddedFrame
+sun/swing/MenuItemLayoutHelper$RectSize
+javax/swing/JTable$2
+javax/swing/JTable$Resizable3
+javax/swing/JTable$Resizable2
+javax/swing/JTable$5
+javax/swing/event/AncestorEvent
+java/awt/Label
+sun/awt/X11/XLabelPeer
+java/awt/peer/LabelPeer
+sun/awt/TimedWindowEvent
+java/awt/DefaultKeyboardFocusManager$DefaultKeyboardFocusManagerSentEvent
+sun/awt/CausedFocusEvent$Cause
+java/awt/KeyboardFocusManager$HeavyweightFocusRequest
+java/awt/DefaultKeyboardFocusManager$TypeAheadMarker
+java/awt/KeyboardFocusManager$LightweightFocusRequest
+sun/awt/CausedFocusEvent
+java/awt/KeyboardFocusManager$3
+sun/awt/X11/XInputMethod
+sun/awt/X11InputMethod
+sun/awt/im/InputMethodAdapter
+java/awt/im/spi/InputMethod
+java/awt/Event
+java/net/Authenticator
+java/lang/Throwable$WrappedPrintStream
+java/lang/Throwable$PrintStreamOrWriter
+sun/awt/image/PNGImageDecoder
+sun/awt/image/PNGFilterInputStream
+sun/util/locale/provider/TimeZoneNameUtility
+sun/util/locale/provider/TimeZoneNameProviderImpl
+sun/util/locale/provider/TimeZoneNameUtility$TimeZoneNameGetter
+sun/util/resources/TimeZoneNames
+sun/util/resources/TimeZoneNamesBundle
+sun/util/resources/en/TimeZoneNames_en
+sun/awt/image/OffScreenImage
+java/lang/ProcessBuilder
+java/lang/ProcessImpl
+java/lang/UNIXProcess
+java/lang/Process
+java/lang/UNIXProcess$Platform
+java/lang/UNIXProcess$LaunchMechanism
+java/util/EnumSet
+java/util/RegularEnumSet
+sun/java2d/x11/X11SurfaceDataProxy$Opaque
+java/lang/UNIXProcess$1
+java/util/concurrent/Executor
+java/util/concurrent/ThreadFactory
+java/util/concurrent/Executors
+java/util/concurrent/ThreadPoolExecutor
+java/util/concurrent/AbstractExecutorService
+java/util/concurrent/ExecutorService
+java/util/concurrent/ThreadPoolExecutor$AbortPolicy
+java/util/concurrent/RejectedExecutionHandler
+java/util/concurrent/SynchronousQueue
+java/util/concurrent/SynchronousQueue$TransferStack
+java/util/concurrent/SynchronousQueue$Transferer
+java/util/concurrent/SynchronousQueue$TransferStack$SNode
+java/lang/UNIXProcess$ProcessPipeOutputStream
+java/lang/UNIXProcess$ProcessPipeInputStream
+java/util/concurrent/ThreadPoolExecutor$Worker
+java/lang/ProcessBuilder$NullOutputStream
+java/io/FilterReader
+sun/awt/X11/XClipboard
+sun/awt/X11/OwnershipListener
+sun/awt/datatransfer/SunClipboard
+java/awt/datatransfer/Clipboard
+java/io/EOFException
+java/util/jar/JarFile$JarEntryIterator
+java/util/zip/ZipFile$ZipEntryIterator
+java/lang/IllegalAccessError
+java/text/MessageFormat
+java/text/MessageFormat$Field
+java/util/Hashtable$ValueCollection
+javax/swing/event/CaretListener
+javax/swing/plaf/metal/MetalButtonUI
+javax/swing/plaf/metal/MetalToggleButtonUI
+javax/swing/plaf/metal/MetalBorders$ToggleButtonBorder
+javax/swing/event/MenuEvent
+javax/swing/border/MatteBorder
+sun/font/StandardGlyphVector
+java/awt/font/GlyphVector
+sun/font/StandardGlyphVector$GlyphStrike
+sun/font/CoreMetrics
+sun/font/FontLineMetrics
+java/awt/font/LineMetrics
+javax/swing/JToolBar$DefaultToolBarLayout
+javax/swing/plaf/metal/MetalToolBarUI
+javax/swing/plaf/basic/BasicToolBarUI
+javax/swing/plaf/ToolBarUI
+javax/swing/plaf/metal/MetalBorders$ToolBarBorder
+javax/swing/plaf/metal/MetalBorders$RolloverButtonBorder
+javax/swing/plaf/metal/MetalBorders$RolloverMarginBorder
+javax/swing/plaf/basic/BasicBorders$RolloverMarginBorder
+javax/swing/plaf/metal/MetalToolBarUI$MetalDockingListener
+javax/swing/plaf/basic/BasicToolBarUI$DockingListener
+javax/swing/plaf/basic/BasicToolBarUI$Handler
+javax/swing/JToolBar$Separator
+javax/swing/plaf/basic/BasicToolBarSeparatorUI
+java/awt/event/AdjustmentEvent
+java/awt/MenuBar
+sun/awt/X11/XErrorEvent
+# eea35d9d56e0006e
--- ./jdk/make/gendata/GendataFontConfig.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/gendata/GendataFontConfig.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -73,6 +73,13 @@
   GENDATA_FONT_CONFIG_SRC_PREFIX := aix.
 endif
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  GENDATA_FONT_CONFIG_SRC_DIR := \
+      $(JDK_TOPDIR)/src/solaris/classes/sun/awt/fontconfigs
+  GENDATA_FONT_CONFIG_SRC_FILES := fontconfig.properties
+  GENDATA_FONT_CONFIG_SRC_PREFIX := bsd.
+endif
+
 ###
 
 $(GENDATA_FONT_CONFIG_DST)/%.src: \
--- ./jdk/make/lib/Awt2dLibraries.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/lib/Awt2dLibraries.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -309,7 +309,7 @@
     debug_trace.c \
     debug_util.c
 
-ifneq (, $(filter $(OPENJDK_TARGET_OS), solaris linux aix))
+ifneq (, $(filter $(OPENJDK_TARGET_OS), bsd solaris linux aix))
   LIBAWT_FILES += awt_LoadLibrary.c initIDs.c img_colors.c
 endif
 
@@ -481,6 +481,7 @@
     LDFLAGS_SUFFIX_linux := -ljvm $(LIBM) $(LIBDL) -ljava, \
     LDFLAGS_SUFFIX_solaris := -ljvm $(LIBM) $(LIBDL) -ljava -lc, \
     LDFLAGS_SUFFIX_aix :=-ljvm $(LIBM) $(LIBDL) -ljava -lm,\
+    LDFLAGS_SUFFIX_bsd := -ljvm $(LIBM) -ljava, \
     LDFLAGS_SUFFIX_macosx := -lmlib_image -ljvm $(LIBM) \
         -framework Cocoa \
         -framework OpenGL \
@@ -557,6 +558,16 @@
       endif
     endif
 
+    ifeq ($(OPENJDK_TARGET_OS), bsd)
+      ifndef OPENJDK
+        include $(JDK_TOPDIR)/make/closed/xawt.gmk
+      endif
+
+      ifeq ($(DISABLE_XRENDER), true)
+        LIBAWT_XAWT_CFLAGS += -DDISABLE_XRENDER_BY_DEFAULT=true
+      endif
+    endif
+
     ifeq ($(MILESTONE), internal)
       LIBAWT_XAWT_CFLAGS += -DINTERNAL_BUILD
     endif
@@ -625,6 +636,11 @@
       LIBAWT_XAWT_LDFLAGS += -lpthread
     endif
 
+    ifeq ($(OPENJDK_TARGET_OS), bsd)
+      # To match old build, add this to LDFLAGS instead of suffix.
+      LIBAWT_XAWT_LDFLAGS += -pthread
+    endif
+
     $(eval $(call SetupNativeCompilation,BUILD_LIBAWT_XAWT, \
         LIBRARY := awt_xawt, \
         OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -646,6 +662,7 @@
             -R/usr/dt/lib$(OPENJDK_TARGET_CPU_ISADIR) \
             $(call SET_SHARED_LIBRARY_ORIGIN) \
             $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
+        LDFLAGS_bsd := $(call SET_SHARED_LIBRARY_ORIGIN), \
         LDFLAGS_SUFFIX := $(LIBAWT_XAWT_LDFLAGS_SUFFIX), \
         VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
         RC_FLAGS := $(RC_FLAGS) \
@@ -689,6 +706,7 @@
     LDFLAGS_SUFFIX_macosx := $(LIBM) -lawt -ljava -ljvm, \
     LDFLAGS_SUFFIX_linux := -lm -lawt -ljava -ljvm, \
     LDFLAGS_SUFFIX_aix := -lm -lawt -ljava -ljvm,\
+    LDFLAGS_SUFFIX_bsd := -lm -lawt -ljava -ljvm, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
         -D "JDK_FNAME=lcms.dll" \
@@ -847,6 +865,7 @@
         LDFLAGS_SUFFIX_linux := -ljvm -lawt -lm $(LIBDL) -ljava, \
         LDFLAGS_SUFFIX_aix := -ljvm -lawt -ljava,\
         LDFLAGS_SUFFIX_solaris := $(LIBDL) -ljvm -lawt -lm -ljava $(LIBCXX) -lc, \
+	LDFLAGS_SUFFIX_bsd := -ljvm -lawt -lm -ljava, \
         OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libawt_headless, \
         DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))
 
@@ -924,6 +943,7 @@
     LDFLAGS_SUFFIX_linux := -lawt $(LIBM) $(LIBCXX) -ljava -ljvm -lc, \
     LDFLAGS_SUFFIX_solaris := -lawt -lawt_headless -lc $(LIBM) $(LIBCXX) -ljava -ljvm, \
     LDFLAGS_SUFFIX_aix := -lawt -lawt_headless $(LIBM) $(LIBCXX) -ljava -ljvm,\
+    LDFLAGS_SUFFIX_bsd := -lawt $(LIBM) $(LIBCXX) -ljava -ljvm -lc, \
     LDFLAGS_SUFFIX_macosx := -lawt $(LIBM) $(LIBCXX) -undefined dynamic_lookup \
         -ljava -ljvm, \
     LDFLAGS_SUFFIX_windows := $(WIN_JAVA_LIB) advapi32.lib user32.lib gdi32.lib \
@@ -1067,6 +1087,7 @@
       OPTIMIZATION := LOW, \
       CFLAGS := $(CFLAGS_JDKLIB), \
       CFLAGS_linux := $(HEADLESS_CFLAG), \
+      CFLAGS_bsd := $(HEADLESS_CFLAG), \
       CFLAGS_macosx := -I$(JDK_TOPDIR)/src/solaris/native/sun/awt, \
       MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libjawt/mapfile-vers, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
@@ -1075,6 +1096,7 @@
       LDFLAGS_SUFFIX_linux := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX), \
       LDFLAGS_SUFFIX_aix := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX),\
       LDFLAGS_SUFFIX_solaris := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX) -lXrender, \
+      LDFLAGS_SUFFIX_bsd := $(JAWT_LIBS) $(LDFLAGS_JDKLIB_SUFFIX), \
       LDFLAGS_SUFFIX_macosx := -Xlinker -rpath -Xlinker @loader_path $(JAWT_LIBS) \
           -framework Cocoa $(LDFLAGS_JDKLIB_SUFFIX), \
       OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libjawt, \
@@ -1193,7 +1215,7 @@
     $(JDK_TOPDIR)/src/share/native/sun/awt/splashscreen
 
   ifeq ($(USE_EXTERNAL_LIBGIF), true)
-    GIFLIB_LDFLAGS := -lgif
+    GIFLIB_LDFLAGS += -lgif
   else
     LIBSPLASHSCREEN_DIRS += $(JDK_TOPDIR)/src/share/native/sun/awt/giflib
     GIFLIB_CFLAGS := -I$(JDK_TOPDIR)/src/share/native/sun/awt/giflib
@@ -1226,6 +1248,11 @@
     LIBSPLASHSCREEN_CFLAGS += -DWITH_WIN32
   else ifeq ($(OPENJDK_TARGET_OS), solaris)
     LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+  else ifeq ($(OPENJDK_TARGET_OS), bsd)
+    LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 $(X_CFLAGS) -I$(PACKAGE_PATH)/include
+    ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+      LIBSPLASHSCREEN_CFLAGS += -DLIBICONV_PLUG
+    endif
   else
     LIBSPLASHSCREEN_CFLAGS += -DWITH_X11 $(X_CFLAGS)
   endif
@@ -1248,6 +1275,8 @@
   else ifeq ($(OPENJDK_TARGET_OS), solaris)
     # Solaris still uses OPENWIN_LIB ..
     LIBSPLASHSCREEN_LDFLAGS_SUFFIX += -L$(OPENWIN_LIB)$(OPENJDK_TARGET_CPU_ISADIR) -lX11 -lXext $(LIBM) -lpthread
+  else ifeq ($(OPENJDK_TARGET_OS), bsd)
+    LIBSPLASHSCREEN_LDFLAGS_SUFFIX += $(X_LIBS) -lX11 -lXext $(LIBM) -L$(PACKAGE_PATH)/lib -liconv -pthread
   else	# .. all other Unixes can use X_LIBS
     LIBSPLASHSCREEN_LDFLAGS_SUFFIX += $(X_LIBS) -lX11 -lXext $(LIBM) -lpthread
   endif
--- ./jdk/make/lib/CoreLibraries.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/lib/CoreLibraries.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -100,7 +100,7 @@
 endif
 
 LIBVERIFY_OPTIMIZATION := HIGH
-ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux bsd), )
   ifeq ($(ENABLE_DEBUG_SYMBOLS), true)
     LIBVERIFY_OPTIMIZATION := LOW
   endif
@@ -222,6 +222,7 @@
     LDFLAGS_SUFFIX_solaris := -lsocket -lnsl -lscf $(LIBDL) $(BUILD_LIBFDLIBM) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBDL) $(BUILD_LIBFDLIBM), \
     LDFLAGS_SUFFIX_aix := $(LIBDL) $(BUILD_LIBFDLIBM) -lm,\
+    LDFLAGS_SUFFIX_bsd := $(BUILD_LIBFDLIBM), \
     LDFLAGS_SUFFIX_macosx := -L$(JDK_OUTPUTDIR)/objs/ -lfdlibm \
         -framework CoreFoundation \
         -framework Foundation \
@@ -292,6 +293,7 @@
     LDFLAGS_SUFFIX_linux := -ljvm -ljava $(LIBZ), \
     LDFLAGS_SUFFIX_solaris := -ljvm -ljava $(LIBZ) -lc, \
     LDFLAGS_SUFFIX_aix := -ljvm -ljava $(LIBZ),\
+    LDFLAGS_SUFFIX_bsd := -ljvm -ljava $(LIBZ), \
     LDFLAGS_SUFFIX_macosx := $(LIBZ) -ljava -ljvm, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
@@ -402,7 +404,7 @@
 # Append defines depending on target platform
 LIBJLI_CFLAGS += $(OPENJDK_TARGET_CPU_JLI_CFLAGS)
 
-ifeq ($(OPENJDK_TARGET_OS), macosx)
+ifneq ($(findstring $(OPENJDK_TARGET_OS), bsd macosx), )
   LIBJLI_CFLAGS += -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
 endif
 
@@ -437,11 +439,13 @@
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_linux := $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
     LDFLAGS_solaris := $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
+    LDFLAGS_bsd := $(call SET_SHARED_LIBRARY_ORIGIN,/..), \
     LDFLAGS_macosx := -framework Cocoa -framework Security -framework ApplicationServices, \
     LDFLAGS_SUFFIX_solaris := $(LIBZ) $(LIBDL) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBZ) $(LIBDL) -lc -lpthread, \
     LDFLAGS_SUFFIX_aix := $(LIBZ) $(LIBDL),\
     LDFLAGS_SUFFIX_macosx := $(LIBZ), \
+    LDFLAGS_SUFFIX_bsd := $(LIBZ) -pthread, \
     LDFLAGS_SUFFIX_windows := \
         -export:JLI_Launch \
         -export:JLI_ManifestIterate \
@@ -485,9 +489,9 @@
 
   BUILD_LIBRARIES += $(BUILD_LIBJLI_STATIC)
 
-else ifeq ($(OPENJDK_TARGET_OS), macosx)
+else ifneq ($(findstring $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx), )
   #
-  # On macosx they do partial (incremental) linking of libjli_static.a
+  # On BSD they do partial (incremental) linking of libjli_static.a
   # code it here...rather than add support to NativeCompilation
   # as this is first time I see it
   $(eval $(call SetupNativeCompilation,BUILD_LIBJLI_STATIC, \
@@ -526,6 +530,13 @@
 
 ##########################################################################################
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  BSD_ICONV_CFLAGS:= -I$(PACKAGE_PATH)/include
+  ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+    BSD_ICONV_CFLAGS += -DLIBICONV_PLUG
+  endif
+endif
+
 $(eval $(call SetupNativeCompilation,BUILD_LIBNPT, \
     LIBRARY := npt, \
     OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -535,9 +546,11 @@
     CFLAGS := $(CFLAGS_JDKLIB) \
         -I$(JDK_TOPDIR)/src/share/npt \
         -I$(JDK_TOPDIR)/src/$(OPENJDK_TARGET_OS_API_DIR)/npt, \
+    CFLAGS_bsd := $(BSD_ICONV_CFLAGS), \
     MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libnpt/mapfile-vers, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
+    LDFLAGS_bsd := -L$(PACKAGE_PATH)/lib -liconv, \
     LDFLAGS_macosx := -liconv, \
     LDFLAGS_SUFFIX_windows := -export:nptInitialize -export:nptTerminate, \
     LDFLAGS_SUFFIX_solaris := -lc, \
--- ./jdk/make/lib/NetworkingLibraries.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/lib/NetworkingLibraries.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -42,7 +42,7 @@
   LIBNET_EXCLUDE_FILES += linux_close.c
 endif
 
-ifneq ($(OPENJDK_TARGET_OS), macosx)
+ifeq (,$(findstring $(OPENJDK_TARGET_OS), bsd macosx))
   LIBNET_EXCLUDE_FILES += bsd_close.c
 endif
 
@@ -58,6 +58,10 @@
       NTLMAuthSequence.c NetworkInterface_winXP.c
 endif
 
+ifneq ($(DONT_ENABLE_IPV6),)
+  LIBNET_CFLAGS += -DDONT_ENABLE_IPV6
+endif
+
 $(eval $(call SetupNativeCompilation,BUILD_LIBNET, \
     LIBRARY := net, \
     OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -74,6 +78,7 @@
     LDFLAGS_SUFFIX_solaris := -ljvm -ljava -lnsl -lsocket $(LIBDL) -lc, \
     LDFLAGS_SUFFIX_linux := $(LIBDL) -ljvm -lpthread -ljava, \
     LDFLAGS_SUFFIX_aix := $(LIBDL) -ljvm -ljava,\
+    LDFLAGS_SUFFIX_bsd := -ljvm -pthread -ljava, \
     LDFLAGS_SUFFIX_windows := ws2_32.lib jvm.lib secur32.lib iphlpapi.lib \
         delayimp.lib $(WIN_JAVA_LIB) advapi32.lib \
         -DELAYLOAD:secur32.dll -DELAYLOAD:iphlpapi.dll, \
--- ./jdk/make/lib/NioLibraries.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/lib/NioLibraries.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -77,9 +77,28 @@
       UnixNativeDispatcher.c
 endif
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  BUILD_LIBNIO_MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libnio/mapfile-$(OPENJDK_TARGET_OS)
+  BUILD_LIBNIO_SRC += $(JDK_TOPDIR)/src/bsd/native/sun/nio/ch
+  BUILD_LIBNIO_FILES += \
+      BsdNativeDispatcher.c \
+      GnomeFileTypeDetector.c \
+      InheritedChannel.c \
+      KQueue.c \
+      KQueueArrayWrapper.c \
+      KQueuePort.c \
+      MagicFileTypeDetector.c \
+      NativeThread.c \
+      PollArrayWrapper.c \
+      UnixAsynchronousServerSocketChannelImpl.c \
+      UnixAsynchronousSocketChannelImpl.c \
+      UnixCopyFile.c \
+      UnixNativeDispatcher.c
+endif
+
 ifeq ($(OPENJDK_TARGET_OS), macosx)
   BUILD_LIBNIO_MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libnio/mapfile-$(OPENJDK_TARGET_OS)
-  BUILD_LIBNIO_SRC += $(JDK_TOPDIR)/src/macosx/native/sun/nio/ch
+  BUILD_LIBNIO_SRC += $(JDK_TOPDIR)/src/bsd/native/sun/nio/ch
   BUILD_LIBNIO_FILES += \
       InheritedChannel.c \
       NativeThread.c \
@@ -149,6 +168,7 @@
     LDFLAGS_SUFFIX_windows := jvm.lib ws2_32.lib $(WIN_JAVA_LIB) \
         $(JDK_OUTPUTDIR)/objs/libnet/net.lib \
         advapi32.lib, \
+    LDFLAGS_SUFFIX_bsd := -ljava -lnet -pthread, \
     LDFLAGS_SUFFIX_macosx := -ljava -lnet -pthread -framework CoreFoundation, \
     LDFLAGS_SUFFIX :=, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
@@ -168,6 +188,7 @@
 ifeq ($(OPENJDK_TARGET_OS_API), posix)
 
   ifeq (, $(filter $(OPENJDK_TARGET_OS), macosx aix))
+  ifeq (, $(filter $(OPENJDK_TARGET_OS_VENDOR), netbsd openbsd))
 
     # Suppress unused parameters required by exported JNI functions.
     SCTP_WERROR := -Werror -Wno-error=unused-parameter
@@ -194,6 +215,7 @@
         LDFLAGS_SUFFIX_linux := -lpthread $(LIBDL) -ljava -ljvm, \
         LDFLAGS_SUFFIX_posix := -lnio -lnet, \
         LDFLAGS_SUFFIX_solaris := -lsocket -ljava -ljvm -lc, \
+        LDFLAGS_SUFFIX_bsd := -pthread -ljava -ljvm, \
         LDFLAGS_SUFFIX_macosx := -ljava -ljvm, \
         OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libsctp, \
         DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))
@@ -202,4 +224,5 @@
 
     $(BUILD_LIBSCTP): $(BUILD_LIBNIO)
   endif
+  endif
 endif
--- ./jdk/make/lib/ServiceabilityLibraries.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/lib/ServiceabilityLibraries.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -34,7 +34,7 @@
 ifneq ($(OPENJDK_TARGET_OS), linux)
   LIBATTACH_EXCLUDE_FILES += LinuxVirtualMachine.c
 endif
-ifneq ($(OPENJDK_TARGET_OS), macosx)
+ifeq (,$(findstring $(OPENJDK_TARGET_OS), bsd macosx))
   LIBATTACH_EXCLUDE_FILES += BsdVirtualMachine.c
 endif
 ifneq ($(OPENJDK_TARGET_OS),aix)
@@ -94,6 +94,7 @@
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_SUFFIX_linux := -lpthread, \
     LDFLAGS_SUFFIX_solaris := -lnsl -lsocket -lc, \
+    LDFLAGS_SUFFIX_bsd := -pthread, \
     LDFLAGS_SUFFIX_windows := $(LDFLAGS_JDKLIB_SUFFIX) -export:jdwpTransport_OnLoad ws2_32.lib, \
     VERSIONINFO_RESOURCE := $(JDK_TOPDIR)/src/windows/resource/version.rc, \
     RC_FLAGS := $(RC_FLAGS) \
@@ -245,6 +246,21 @@
   LIBINSTRUMENT_CFLAGS += -Dstrcasecmp=stricmp
 endif
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  LIBINSTRUMENT_LDFLAGS_SUFFIX += -L$(PACKAGE_PATH)/lib -liconv $(LIBZ)
+  ifeq ($(BSD_STATIC_LIBJLI), bsd)
+    LIBINSTRUMENT_LDFLAGS += -Xlinker --whole-archive $(JDK_OUTPUTDIR)/objs/libjli_static.a \
+        -Xlinker --no-whole-archive
+  else
+    LIBINSTRUMENT_LDFLAGS += $(call SET_SHARED_LIBRARY_ORIGIN,/jli)
+    LIBINSTRUMENT_LDFLAGS_SUFFIX += -L$(INSTALL_LIBRARIES_HERE)/jli -ljli
+  endif
+  BSD_ICONV_CFLAGS:= -I$(PACKAGE_PATH)/include
+  ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+    BSD_ICONV_CFLAGS += -DLIBICONV_PLUG
+  endif
+endif
+
 $(eval $(call SetupNativeCompilation,BUILD_LIBINSTRUMENT, \
     LIBRARY := instrument, \
     OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \
@@ -255,6 +271,7 @@
     CFLAGS := $(LIBINSTRUMENT_CFLAGS), \
     CFLAGS_debug := -DJPLIS_LOGGING, \
     CFLAGS_release := -DNO_JPLIS_LOGGING, \
+    CFLAGS_bsd := $(BSD_ICONV_CFLAGS), \
     MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libinstrument/mapfile-vers, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN) \
@@ -276,7 +293,7 @@
     OBJECT_DIR := $(LIBINSTRUMENT_DIR), \
     DEBUG_SYMBOLS := true))
 
-ifneq (, $(findstring $(OPENJDK_TARGET_OS), macosx windows aix))
+ifneq (, $(findstring $(OPENJDK_TARGET_OS), $(BSD_STATIC_LIBJLI) macosx windows aix))
   $(BUILD_LIBINSTRUMENT): $(JDK_OUTPUTDIR)/objs/$(LIBRARY_PREFIX)jli_static$(STATIC_LIBRARY_SUFFIX)
 else
   $(BUILD_LIBINSTRUMENT): $(INSTALL_LIBRARIES_HERE)/jli/$(LIBRARY_PREFIX)jli$(SHARED_LIBRARY_SUFFIX)
@@ -306,12 +323,16 @@
   BUILD_LIBMANAGEMENT_EXCLUDES += LinuxOperatingSystem.c
 endif
 
+ifneq ($(OPENJDK_TARGET_OS), bsd)
+  BUILD_LIBMANAGEMENT_EXCLUDES += BsdOperatingSystem.c
+endif
+
 ifneq ($(OPENJDK_TARGET_OS), macosx)
   BUILD_LIBMANAGEMENT_EXCLUDES += MacosxOperatingSystem.c
 endif
 
 LIBMANAGEMENT_OPTIMIZATION := HIGH
-ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux bsd), )
   ifeq ($(ENABLE_DEBUG_SYMBOLS), true)
     LIBMANAGEMENT_OPTIMIZATION := LOW
   endif
@@ -363,7 +384,7 @@
 BUILD_LIBHPROF_LDFLAGS :=
 
 LIBHPROF_OPTIMIZATION := HIGHEST
-ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux), )
+ifneq ($(findstring $(OPENJDK_TARGET_OS), solaris linux bsd), )
   ifeq ($(ENABLE_DEBUG_SYMBOLS), true)
     LIBHPROF_OPTIMIZATION := LOW
   endif
--- ./jdk/make/lib/SoundLibraries.gmk	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/lib/SoundLibraries.gmk	Sun Sep 02 07:33:40 2018 -0700
@@ -75,6 +75,13 @@
   LIBJSOUND_CFLAGS += -DX_PLATFORM=X_AIX
 endif # OPENJDK_TARGET_OS aix
 
+ifeq ($(OPENJDK_TARGET_OS), bsd)
+  ifneq ($(OPENJDK_TARGET_OS_VENDOR), openbsd)
+    EXTRA_SOUND_JNI_LIBS += jsoundalsa
+  endif # OPENJDK_TARGET_OS_VENDOR openbsd
+  LIBJSOUND_CFLAGS += -DX_PLATFORM=X_BSD
+endif # OPENJDK_TARGET_OS bsd
+
 ifeq ($(OPENJDK_TARGET_OS), macosx)
   LIBJSOUND_LANG := C++
   LIBJSOUND_CFLAGS += -DX_PLATFORM=X_MACOSX \
@@ -196,12 +203,14 @@
       CFLAGS := $(CFLAGS_JDKLIB) $(ALSA_CFLAGS) \
           $(LIBJSOUND_CFLAGS) \
           -DUSE_DAUDIO=TRUE \
-          -DUSE_PORTS=TRUE \
-          -DUSE_PLATFORM_MIDI_OUT=TRUE \
+          -DUSE_PORTS=TRUE, \
+      CFLAGS_linux := -DUSE_PLATFORM_MIDI_OUT=TRUE \
           -DUSE_PLATFORM_MIDI_IN=TRUE, \
+      CFLAGS_bsd := -I$(PACKAGE_PATH)/include, \
       MAPFILE := $(JDK_TOPDIR)/make/mapfiles/libjsoundalsa/mapfile-vers, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
           $(call SET_SHARED_LIBRARY_ORIGIN), \
+      LDFLAGS_bsd := -L$(PACKAGE_PATH)/lib, \
       LDFLAGS_SUFFIX := $(ALSA_LIBS) -ljava -ljvm, \
       OBJECT_DIR := $(JDK_OUTPUTDIR)/objs/libjsoundalsa, \
       DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))
--- ./jdk/make/mapfiles/launchers/mapfile-ppc64	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/mapfiles/launchers/mapfile-ppc64	Sun Sep 02 07:33:40 2018 -0700
@@ -33,6 +33,7 @@
 		environ;	# Public symbols and required by Java run time
 		_environ;
 		__environ_lock;
+		__progname;
 
 	local:
 		*;
--- ./jdk/make/mapfiles/launchers/mapfile-x86	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/mapfiles/launchers/mapfile-x86	Sun Sep 02 07:33:40 2018 -0700
@@ -33,6 +33,7 @@
 		environ;	# Public symbols and required by Java run time
 		_environ;
 		__environ_lock;
+		__progname;
 		___Argv;	# The following are private, but as they are
 		_start;		# exported from ctr1/crtn, the clever hacker
 		_init;		# might know about them.  However note, that
--- ./jdk/make/mapfiles/launchers/mapfile-x86_64	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/mapfiles/launchers/mapfile-x86_64	Sun Sep 02 07:33:40 2018 -0700
@@ -33,6 +33,7 @@
 		environ;	# Public symbols and required by Java run time
 		_environ;
 		__environ_lock;
+		__progname;
 
 	local:
 		*;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/mapfiles/libattach/mapfile-bsd	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,42 @@
+#
+# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+# Define public interface.
+
+SUNWprivate_1.1 {
+	global:
+	    Java_sun_tools_attach_BsdVirtualMachine_checkPermissions;
+	    Java_sun_tools_attach_BsdVirtualMachine_close;
+	    Java_sun_tools_attach_BsdVirtualMachine_connect;
+	    Java_sun_tools_attach_BsdVirtualMachine_getTempDir;
+	    Java_sun_tools_attach_BsdVirtualMachine_open;
+	    Java_sun_tools_attach_BsdVirtualMachine_sendQuitTo;
+	    Java_sun_tools_attach_BsdVirtualMachine_socket;
+	    Java_sun_tools_attach_BsdVirtualMachine_read;
+	    Java_sun_tools_attach_BsdVirtualMachine_write;
+	    Java_sun_tools_attach_BsdVirtualMachine_createAttachFile;
+	local:
+		*;
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/mapfiles/libnio/mapfile-bsd	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,195 @@
+#
+# Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+SUNWprivate_1.1 {
+	global:
+		Java_java_nio_MappedByteBuffer_force0;
+		Java_java_nio_MappedByteBuffer_isLoaded0;
+		Java_java_nio_MappedByteBuffer_load0;
+		Java_sun_nio_ch_DatagramChannelImpl_disconnect0;
+		Java_sun_nio_ch_DatagramChannelImpl_initIDs;
+		Java_sun_nio_ch_DatagramChannelImpl_receive0;
+		Java_sun_nio_ch_DatagramChannelImpl_send0;
+		Java_sun_nio_ch_DatagramDispatcher_read0;
+		Java_sun_nio_ch_DatagramDispatcher_readv0;
+		Java_sun_nio_ch_DatagramDispatcher_write0;
+		Java_sun_nio_ch_DatagramDispatcher_writev0;
+		Java_sun_nio_ch_FileChannelImpl_close0;
+		Java_sun_nio_ch_FileChannelImpl_initIDs;
+		Java_sun_nio_ch_FileChannelImpl_map0;
+		Java_sun_nio_ch_FileChannelImpl_position0;
+		Java_sun_nio_ch_FileChannelImpl_transferTo0;
+		Java_sun_nio_ch_FileChannelImpl_unmap0;
+		Java_sun_nio_ch_FileDispatcherImpl_close0;
+		Java_sun_nio_ch_FileDispatcherImpl_closeIntFD;
+		Java_sun_nio_ch_FileDispatcherImpl_force0;
+		Java_sun_nio_ch_FileDispatcherImpl_init;
+		Java_sun_nio_ch_FileDispatcherImpl_lock0;
+		Java_sun_nio_ch_FileDispatcherImpl_preClose0;
+		Java_sun_nio_ch_FileDispatcherImpl_pread0;
+		Java_sun_nio_ch_FileDispatcherImpl_pwrite0;
+		Java_sun_nio_ch_FileDispatcherImpl_read0;
+		Java_sun_nio_ch_FileDispatcherImpl_readv0;
+		Java_sun_nio_ch_FileDispatcherImpl_release0;
+		Java_sun_nio_ch_FileDispatcherImpl_size0;
+		Java_sun_nio_ch_FileDispatcherImpl_truncate0;
+		Java_sun_nio_ch_FileDispatcherImpl_write0;
+		Java_sun_nio_ch_FileDispatcherImpl_writev0;
+		Java_sun_nio_ch_FileKey_init;
+		Java_sun_nio_ch_FileKey_initIDs;
+		Java_sun_nio_ch_IOUtil_configureBlocking;
+		Java_sun_nio_ch_IOUtil_drain;
+		Java_sun_nio_ch_IOUtil_fdLimit;
+		Java_sun_nio_ch_IOUtil_fdVal;
+		Java_sun_nio_ch_IOUtil_initIDs;
+		Java_sun_nio_ch_IOUtil_iovMax;
+		Java_sun_nio_ch_IOUtil_makePipe;
+		Java_sun_nio_ch_IOUtil_randomBytes;
+		Java_sun_nio_ch_IOUtil_setfdVal;
+		Java_sun_nio_ch_InheritedChannel_close0;
+		Java_sun_nio_ch_InheritedChannel_dup2;
+		Java_sun_nio_ch_InheritedChannel_dup;
+		Java_sun_nio_ch_InheritedChannel_open0;
+		Java_sun_nio_ch_InheritedChannel_peerAddress0;
+		Java_sun_nio_ch_InheritedChannel_peerPort0;
+		Java_sun_nio_ch_InheritedChannel_soType0;
+		Java_sun_nio_ch_KQueueArrayWrapper_init;
+		Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes;
+		Java_sun_nio_ch_KQueueArrayWrapper_interrupt;
+		Java_sun_nio_ch_KQueueArrayWrapper_kevent0;
+		Java_sun_nio_ch_KQueueArrayWrapper_register0;
+		Java_sun_nio_ch_KQueuePort_close0;
+		Java_sun_nio_ch_KQueuePort_drain1;
+		Java_sun_nio_ch_KQueuePort_interrupt;
+		Java_sun_nio_ch_KQueuePort_socketpair;
+		Java_sun_nio_ch_KQueue_filterOffset;
+		Java_sun_nio_ch_KQueue_flagsOffset;
+		Java_sun_nio_ch_KQueue_identOffset;
+		Java_sun_nio_ch_KQueue_keventPoll;
+		Java_sun_nio_ch_KQueue_keventRegister;
+		Java_sun_nio_ch_KQueue_keventSize;
+		Java_sun_nio_ch_KQueue_kqueue;
+		Java_sun_nio_ch_NativeThread_current;
+		Java_sun_nio_ch_NativeThread_init;
+		Java_sun_nio_ch_NativeThread_signal;
+		Java_sun_nio_ch_Net_bind0;
+		Java_sun_nio_ch_Net_blockOrUnblock4;
+		Java_sun_nio_ch_Net_blockOrUnblock6;
+		Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0;
+		Java_sun_nio_ch_Net_canJoin6WithIPv4Group0;
+		Java_sun_nio_ch_Net_connect0;
+		Java_sun_nio_ch_Net_getIntOption0;
+		Java_sun_nio_ch_Net_getInterface4;
+		Java_sun_nio_ch_Net_getInterface6;
+		Java_sun_nio_ch_Net_initIDs;
+		Java_sun_nio_ch_Net_isExclusiveBindAvailable;
+		Java_sun_nio_ch_Net_isIPv6Available0;
+		Java_sun_nio_ch_Net_joinOrDrop4;
+		Java_sun_nio_ch_Net_joinOrDrop6;
+		Java_sun_nio_ch_Net_listen;
+		Java_sun_nio_ch_Net_localInetAddress;
+		Java_sun_nio_ch_Net_localPort;
+		Java_sun_nio_ch_Net_poll;
+		Java_sun_nio_ch_Net_pollconnValue;
+		Java_sun_nio_ch_Net_pollerrValue;
+		Java_sun_nio_ch_Net_pollhupValue;
+		Java_sun_nio_ch_Net_pollinValue;
+		Java_sun_nio_ch_Net_pollnvalValue;
+		Java_sun_nio_ch_Net_polloutValue;
+		Java_sun_nio_ch_Net_setIntOption0;
+		Java_sun_nio_ch_Net_setInterface4;
+		Java_sun_nio_ch_Net_setInterface6;
+		Java_sun_nio_ch_Net_shutdown;
+		Java_sun_nio_ch_Net_socket0;
+		Java_sun_nio_ch_PollArrayWrapper_interrupt;
+		Java_sun_nio_ch_PollArrayWrapper_poll0;
+		Java_sun_nio_ch_ServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_ServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_SocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_SocketChannelImpl_sendOutOfBandData;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_fs_BsdNativeDispatcher_endfsstat;
+		Java_sun_nio_fs_BsdNativeDispatcher_fsstatEntry;
+		Java_sun_nio_fs_BsdNativeDispatcher_getfsstat;
+		Java_sun_nio_fs_BsdNativeDispatcher_initIDs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
+		Java_sun_nio_fs_MagicFileTypeDetector_initialize0;
+		Java_sun_nio_fs_MagicFileTypeDetector_probe0;
+		Java_sun_nio_fs_UnixCopyFile_transfer;
+		Java_sun_nio_fs_UnixNativeDispatcher_access0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chmod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_close;
+		Java_sun_nio_fs_UnixNativeDispatcher_closedir;
+		Java_sun_nio_fs_UnixNativeDispatcher_dup;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchmod;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchown;
+		Java_sun_nio_fs_UnixNativeDispatcher_fclose;
+		Java_sun_nio_fs_UnixNativeDispatcher_fdopendir;
+		Java_sun_nio_fs_UnixNativeDispatcher_fopen0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fpathconf;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstat;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstatat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_futimes;
+		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrgid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwuid;
+		Java_sun_nio_fs_UnixNativeDispatcher_init;
+		Java_sun_nio_fs_UnixNativeDispatcher_lchown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_link0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lstat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mkdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mknod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_open0;
+		Java_sun_nio_fs_UnixNativeDispatcher_openat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_opendir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_pathconf0;
+		Java_sun_nio_fs_UnixNativeDispatcher_read;
+		Java_sun_nio_fs_UnixNativeDispatcher_readdir;
+		Java_sun_nio_fs_UnixNativeDispatcher_readlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_realpath0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rename0;
+		Java_sun_nio_fs_UnixNativeDispatcher_renameat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rmdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_stat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_statvfs0;
+		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
+		Java_sun_nio_fs_UnixNativeDispatcher_symlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_utimes0;
+		Java_sun_nio_fs_UnixNativeDispatcher_write;
+		handleSocketError;
+
+	local:
+		*;
+};
--- ./jdk/make/mapfiles/libunpack/mapfile-vers-unpack200	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/mapfiles/libunpack/mapfile-vers-unpack200	Sun Sep 02 07:33:40 2018 -0700
@@ -26,6 +26,9 @@
 # Define library interface.
 
 SUNWprivate_1.1 {
+	global:
+	    environ;
+	    __progname;
 	local:
 	    *;
 };
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/netbeans/common/bsd-sources.ent	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+ Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+   - Neither the name of Oracle nor the names of its
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<source-folder>
+    <label>Sources for BSD Platform</label>
+    <type>java</type>
+    <location>${root}/src/bsd/classes</location>
+    <includes>${includes}</includes>
+    <excludes>${excludes}</excludes>
+    <encoding>US-ASCII</encoding>
+</source-folder>
+<source-folder>
+    <label>Sources for BSD Platform</label>
+    <location>${root}/src/bsd/classes</location>
+</source-folder>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/make/netbeans/common/bsd-view.ent	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+ Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+   - Neither the name of Oracle nor the names of its
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+
+<source-folder style="tree">
+    <label>Sources for BSD Platform</label>
+    <location>${root}/src/bsd/classes</location>
+    <includes>${includes}</includes>
+    <excludes>${excludes}</excludes>
+</source-folder>
--- ./jdk/make/netbeans/common/java-data-native.ent	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/netbeans/common/java-data-native.ent	Sun Sep 02 07:33:40 2018 -0700
@@ -34,6 +34,7 @@
 <java-data xmlns="http://www.netbeans.org/ns/freeform-project-java/4">
     <compilation-unit>
         <package-root>${root}/src/share/classes</package-root>
+        <package-root>${root}/src/bsd/classes</package-root>
         <package-root>${root}/src/macosx/classes</package-root>
         <package-root>${root}/src/solaris/classes</package-root>
         <package-root>${root}/src/windows/classes</package-root>
--- ./jdk/make/netbeans/common/make.xml	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/netbeans/common/make.xml	Sun Sep 02 07:33:40 2018 -0700
@@ -32,16 +32,21 @@
 -->
 
 <project name="make" basedir="..">
-    
-    <target name="-make.init" depends="-init,-pre-init.linux,-pre-init.macosx,-pre-init.solaris,-pre-init.windows,-pre-init.macosx">
+
+    <target name="-make.init" depends="-init,-pre-init.linux,-pre-init.bsd,-pre-init.macosx,-pre-init.solaris,-pre-init.windows">
         <property name="make.options" value=""/> <!-- default, can be overridden per user or per project -->
     </target>
-    
+
     <target name="-pre-init.linux" if="os.linux">
         <property name="platform" value="linux"/>
         <property name="make" value="make"/>
     </target>
 
+    <target name="-pre-init.bsd" if="os.bsd">
+        <property name="platform" value="bsd"/>
+        <property name="make" value="gmake"/>
+    </target>
+
     <target name="-pre-init.macosx" if="os.macosx">
         <property name="platform" value="macosx"/>
         <property name="make" value="make"/>
@@ -56,7 +61,7 @@
         <property name="platform" value="windows"/>
         <property name="make" value="c:/cygwin/bin/make"/>
     </target>
-    
+
     <macrodef name="make-run">
             <attribute name="target"/>
             <attribute name="dir"/>
--- ./jdk/make/netbeans/j2se/nbproject/project.xml	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/netbeans/j2se/nbproject/project.xml	Sun Sep 02 07:33:40 2018 -0700
@@ -34,6 +34,7 @@
 <!DOCTYPE project [
     <!ENTITY properties SYSTEM "../../common/properties.ent">
     <!ENTITY share-sources SYSTEM "../../common/share-sources.ent">
+    <!ENTITY bsd-sources SYSTEM "../../common/bsd-sources.ent">
     <!ENTITY macosx-sources SYSTEM "../../common/macosx-sources.ent">
     <!ENTITY unix-sources SYSTEM "../../common/unix-sources.ent">
     <!ENTITY windows-sources SYSTEM "../../common/windows-sources.ent">
@@ -41,6 +42,7 @@
     <!ENTITY build-folder SYSTEM "../../common/build-folder.ent">
     <!ENTITY standard-bindings SYSTEM "../../common/standard-bindings.ent">
     <!ENTITY share-view SYSTEM "../../common/share-view.ent">
+    <!ENTITY bsd-view SYSTEM "../../common/bsd-view.ent">
     <!ENTITY macosx-view SYSTEM "../../common/macosx-view.ent">
     <!ENTITY unix-view SYSTEM "../../common/unix-view.ent">
     <!ENTITY windows-view SYSTEM "../../common/windows-view.ent">
@@ -60,6 +62,7 @@
             </properties>
             <folders>
                 &share-sources;
+                &bsd-sources;
                 &macosx-sources;
                 &unix-sources;
                 &windows-sources;
@@ -86,6 +89,7 @@
             <view>
                 <items>
                     &share-view;
+                    &bsd-view;
                     &macosx-view;
                     &unix-view;
                     &windows-view;
--- ./jdk/make/netbeans/world/nbproject/project.xml	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/make/netbeans/world/nbproject/project.xml	Sun Sep 02 07:33:40 2018 -0700
@@ -34,12 +34,14 @@
 <!DOCTYPE project [
     <!ENTITY properties SYSTEM "../../common/properties.ent">
     <!ENTITY share-sources SYSTEM "../../common/share-sources.ent">
+    <!ENTITY bsd-sources SYSTEM "../../common/bsd-sources.ent">
     <!ENTITY macosx-sources SYSTEM "../../common/macosx-sources.ent">
     <!ENTITY unix-sources SYSTEM "../../common/unix-sources.ent">
     <!ENTITY windows-sources SYSTEM "../../common/windows-sources.ent">
     <!ENTITY build-folder SYSTEM "../../common/build-folder.ent">
     <!ENTITY standard-bindings SYSTEM "../../common/standard-bindings.ent">
     <!ENTITY share-view SYSTEM "../../common/share-view.ent">
+    <!ENTITY bsd-view SYSTEM "../../common/bsd-view.ent">
     <!ENTITY macosx-view SYSTEM "../../common/macosx-view.ent">
     <!ENTITY unix-view SYSTEM "../../common/unix-view.ent">
     <!ENTITY windows-view SYSTEM "../../common/windows-view.ent">
@@ -58,6 +60,7 @@
             </properties>
             <folders>
                 &share-sources;
+                &bsd-sources;
                 &macosx-sources;
                 &unix-sources;
                 &windows-sources;
@@ -69,6 +72,7 @@
             <view>
                 <items>
                     &share-view;
+                    &bsd-view;
                     &macosx-view;
                     &unix-view;
                     &windows-view;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/java/net/DefaultInterface.java	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.net;
+
+/**
+ * Choose a network interface to be the default for
+ * outgoing IPv6 traffic that does not specify a scope_id (and which needs one).
+ * We choose the first interface that is up and is (in order of preference):
+ * 1. neither loopback nor point to point
+ * 2. point to point
+ * 3. loopback
+ * 4. none.
+ * Platforms that do not require a default interface implement a dummy
+ * that returns null.
+ */
+
+import java.util.Enumeration;
+import java.io.IOException;
+
+class DefaultInterface {
+
+    private final static NetworkInterface defaultInterface =
+        chooseDefaultInterface();
+
+    static NetworkInterface getDefault() {
+        return defaultInterface;
+    }
+
+    /**
+     * Choose a default interface. This method returns an interface that is
+     * both "up" and supports multicast. This method choses an interface in
+     * order of preference:
+     * 1. neither loopback nor point to point
+     * 2. point to point
+     * 3. loopback
+     *
+     * @return  the chosen interface or {@code null} if there isn't a suitable
+     *          default
+     */
+    private static NetworkInterface chooseDefaultInterface() {
+        Enumeration<NetworkInterface> nifs;
+
+        try {
+           nifs = NetworkInterface.getNetworkInterfaces();
+        } catch (IOException ignore) {
+            // unable to enumate network interfaces
+            return null;
+        }
+
+        NetworkInterface ppp = null;
+        NetworkInterface loopback = null;
+
+        while (nifs.hasMoreElements()) {
+            NetworkInterface ni = nifs.nextElement();
+            try {
+                if (ni.isUp() && ni.supportsMulticast()) {
+                    boolean isLoopback = ni.isLoopback();
+                    boolean isPPP = ni.isPointToPoint();
+                    if (!isLoopback && !isPPP) {
+                        // found an interface that is not the loopback or a
+                        // point-to-point interface
+                        return ni;
+                    }
+                    if (ppp == null && isPPP)
+                        ppp = ni;
+                    if (loopback == null && isLoopback)
+                        loopback = ni;
+                }
+            } catch (IOException skip) { }
+        }
+
+        return (ppp != null) ? ppp : loopback;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/DefaultSelectorProvider.java	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.nio.ch;
+
+import java.nio.channels.spi.SelectorProvider;
+
+/**
+ * Creates this platform's default SelectorProvider
+ */
+
+public class DefaultSelectorProvider {
+
+    /**
+     * Prevent instantiation.
+     */
+    private DefaultSelectorProvider() { }
+
+    /**
+     * Returns the default SelectorProvider.
+     */
+    public static SelectorProvider create() {
+        return new sun.nio.ch.KQueueSelectorProvider();
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/KQueueArrayWrapper.java	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueArrayWrapper.java
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollArrayWrapper
+ */
+
+package sun.nio.ch;
+
+import sun.misc.*;
+import java.io.IOException;
+import java.io.FileDescriptor;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+/*
+ * struct kevent {           // 32-bit    64-bit
+ *     uintptr_t ident;      //   4         8
+ *     short     filter;     //   2         2
+ *     u_short   flags;      //   2         2
+ *     u_int     fflags;     //   4         4
+ *     intptr_t  data;       //   4         8
+ *     void      *udata;     //   4         8
+ * }                  // Total:  20        32
+ *
+ * The implementation works in 32-bit and 64-bit world. We do this by calling a
+ * native function that actually sets the sizes and offsets of the fields based
+ * on which mode we're in.
+ */
+
+class KQueueArrayWrapper {
+    // kevent filters
+    static short EVFILT_READ;
+    static short EVFILT_WRITE;
+
+    // kevent struct
+    // These fields are now set by initStructSizes in the static initializer.
+    static short SIZEOF_KEVENT;
+    static short FD_OFFSET;
+    static short FILTER_OFFSET;
+
+    // kevent array size
+    static final int NUM_KEVENTS = 128;
+
+    // Are we in a 64-bit VM?
+    static boolean is64bit = false;
+
+    // The kevent array (used for outcoming events only)
+    private AllocatedNativeObject keventArray = null;
+    private long keventArrayAddress;
+
+    // The kqueue fd
+    private int kq = -1;
+
+    // The fd of the interrupt line going out
+    private int outgoingInterruptFD;
+
+    // The fd of the interrupt line coming in
+    private int incomingInterruptFD;
+
+    static {
+        IOUtil.load();
+        initStructSizes();
+        String datamodel = java.security.AccessController.doPrivileged(
+            new sun.security.action.GetPropertyAction("sun.arch.data.model")
+        );
+        is64bit = datamodel.equals("64");
+    }
+
+    KQueueArrayWrapper() {
+        int allocationSize = SIZEOF_KEVENT * NUM_KEVENTS;
+        keventArray = new AllocatedNativeObject(allocationSize, true);
+        keventArrayAddress = keventArray.address();
+        kq = init();
+    }
+
+    // Used to update file description registrations
+    private static class Update {
+        SelChImpl channel;
+        int events;
+        Update(SelChImpl channel, int events) {
+            this.channel = channel;
+            this.events = events;
+        }
+    }
+
+    private LinkedList<Update> updateList = new LinkedList<Update>();
+
+    void initInterrupt(int fd0, int fd1) {
+        outgoingInterruptFD = fd1;
+        incomingInterruptFD = fd0;
+        register0(kq, fd0, 1, 0);
+    }
+
+    int getReventOps(int index) {
+        int result = 0;
+        int offset = SIZEOF_KEVENT*index + FILTER_OFFSET;
+        short filter = keventArray.getShort(offset);
+
+        // This is all that's necessary based on inspection of usage:
+        //   SinkChannelImpl, SourceChannelImpl, DatagramChannelImpl,
+        //   ServerSocketChannelImpl, SocketChannelImpl
+        if (filter == EVFILT_READ) {
+            result |= Net.POLLIN;
+        } else if (filter == EVFILT_WRITE) {
+            result |= Net.POLLOUT;
+        }
+
+        return result;
+    }
+
+    int getDescriptor(int index) {
+        int offset = SIZEOF_KEVENT*index + FD_OFFSET;
+        /* The ident field is 8 bytes in 64-bit world, however the API wants us
+         * to return an int. Hence read the 8 bytes but return as an int.
+         */
+        if (is64bit) {
+          long fd = keventArray.getLong(offset);
+          assert fd <= Integer.MAX_VALUE;
+          return (int) fd;
+        } else {
+          return keventArray.getInt(offset);
+        }
+    }
+
+    void setInterest(SelChImpl channel, int events) {
+        synchronized (updateList) {
+            // update existing registration
+            updateList.add(new Update(channel, events));
+        }
+    }
+
+    void release(SelChImpl channel) {
+        synchronized (updateList) {
+            // flush any pending updates
+            for (Iterator<Update> it = updateList.iterator(); it.hasNext();) {
+                if (it.next().channel == channel) {
+                    it.remove();
+                }
+            }
+
+            // remove
+            register0(kq, channel.getFDVal(), 0, 0);
+        }
+    }
+
+    void updateRegistrations() {
+        synchronized (updateList) {
+            Update u = null;
+            while ((u = updateList.poll()) != null) {
+                SelChImpl ch = u.channel;
+                if (!ch.isOpen())
+                    continue;
+
+                register0(kq, ch.getFDVal(), u.events & Net.POLLIN, u.events & Net.POLLOUT);
+            }
+        }
+    }
+
+
+    void close() throws IOException {
+        if (keventArray != null) {
+            keventArray.free();
+            keventArray = null;
+        }
+        if (kq >= 0) {
+            FileDispatcherImpl.closeIntFD(kq);
+            kq = -1;
+        }
+    }
+
+    int poll(long timeout) {
+        updateRegistrations();
+        int updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);
+        return updated;
+    }
+
+    void interrupt() {
+        interrupt(outgoingInterruptFD);
+    }
+
+    private native int init();
+    private static native void initStructSizes();
+
+    private native void register0(int kq, int fd, int read, int write);
+    private native int kevent0(int kq, long keventAddress, int keventCount,
+                               long timeout);
+    private static native void interrupt(int fd);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/KQueueSelectorImpl.java	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueSelectorImpl.java
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollSelectorImpl
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.io.FileDescriptor;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.*;
+import sun.misc.*;
+
+class KQueueSelectorImpl
+    extends SelectorImpl
+{
+    // File descriptors used for interrupt
+    protected int fd0;
+    protected int fd1;
+
+    // The kqueue manipulator
+    KQueueArrayWrapper kqueueWrapper;
+
+    // Count of registered descriptors (including interrupt)
+    private int totalChannels;
+
+    // Map from a file descriptor to an entry containing the selection key
+    private HashMap<Integer,MapEntry> fdMap;
+
+    // True if this Selector has been closed
+    private boolean closed = false;
+
+    // Lock for interrupt triggering and clearing
+    private Object interruptLock = new Object();
+    private boolean interruptTriggered = false;
+
+    // used by updateSelectedKeys to handle cases where the same file
+    // descriptor is polled by more than one filter
+    private long updateCount;
+
+    // Used to map file descriptors to a selection key and "update count"
+    // (see updateSelectedKeys for usage).
+    private static class MapEntry {
+        SelectionKeyImpl ski;
+        long updateCount;
+        MapEntry(SelectionKeyImpl ski) {
+            this.ski = ski;
+        }
+    }
+
+    /**
+     * Package private constructor called by factory method in
+     * the abstract superclass Selector.
+     */
+    KQueueSelectorImpl(SelectorProvider sp) {
+        super(sp);
+        long fds = IOUtil.makePipe(false);
+        fd0 = (int)(fds >>> 32);
+        fd1 = (int)fds;
+        try {
+            kqueueWrapper = new KQueueArrayWrapper();
+            kqueueWrapper.initInterrupt(fd0, fd1);
+            fdMap = new HashMap<>();
+            totalChannels = 1;
+        } catch (Throwable t) {
+            try {
+                FileDispatcherImpl.closeIntFD(fd0);
+            } catch (IOException ioe0) {
+                t.addSuppressed(ioe0);
+            }
+            try {
+                FileDispatcherImpl.closeIntFD(fd1);
+            } catch (IOException ioe1) {
+                t.addSuppressed(ioe1);
+            }
+            throw t;
+        }
+    }
+
+
+    protected int doSelect(long timeout)
+        throws IOException
+    {
+        int entries = 0;
+        if (closed)
+            throw new ClosedSelectorException();
+        processDeregisterQueue();
+        try {
+            begin();
+            entries = kqueueWrapper.poll(timeout);
+        } finally {
+            end();
+        }
+        processDeregisterQueue();
+        return updateSelectedKeys(entries);
+    }
+
+    /**
+     * Update the keys whose fd's have been selected by kqueue.
+     * Add the ready keys to the selected key set.
+     * If the interrupt fd has been selected, drain it and clear the interrupt.
+     */
+    private int updateSelectedKeys(int entries)
+        throws IOException
+    {
+        int numKeysUpdated = 0;
+        boolean interrupted = false;
+
+        // A file descriptor may be registered with kqueue with more than one
+        // filter and so there may be more than one event for a fd. The update
+        // count in the MapEntry tracks when the fd was last updated and this
+        // ensures that the ready ops are updated rather than replaced by a
+        // second or subsequent event.
+        updateCount++;
+
+        for (int i = 0; i < entries; i++) {
+            int nextFD = kqueueWrapper.getDescriptor(i);
+            if (nextFD == fd0) {
+                interrupted = true;
+            } else {
+                MapEntry me = fdMap.get(Integer.valueOf(nextFD));
+
+                // entry is null in the case of an interrupt
+                if (me != null) {
+                    int rOps = kqueueWrapper.getReventOps(i);
+                    SelectionKeyImpl ski = me.ski;
+                    if (selectedKeys.contains(ski)) {
+                        // first time this file descriptor has been encountered on this
+                        // update?
+                        if (me.updateCount != updateCount) {
+                            if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
+                                numKeysUpdated++;
+                                me.updateCount = updateCount;
+                            }
+                        } else {
+                            // ready ops have already been set on this update
+                            ski.channel.translateAndUpdateReadyOps(rOps, ski);
+                        }
+                    } else {
+                        ski.channel.translateAndSetReadyOps(rOps, ski);
+                        if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
+                            selectedKeys.add(ski);
+                            numKeysUpdated++;
+                            me.updateCount = updateCount;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (interrupted) {
+            // Clear the wakeup pipe
+            synchronized (interruptLock) {
+                IOUtil.drain(fd0);
+                interruptTriggered = false;
+            }
+        }
+        return numKeysUpdated;
+    }
+
+
+    protected void implClose() throws IOException {
+        if (!closed) {
+            closed = true;
+
+            // prevent further wakeup
+            synchronized (interruptLock) {
+                interruptTriggered = true;
+            }
+
+            FileDispatcherImpl.closeIntFD(fd0);
+            FileDispatcherImpl.closeIntFD(fd1);
+            if (kqueueWrapper != null) {
+                kqueueWrapper.close();
+                kqueueWrapper = null;
+                selectedKeys = null;
+
+                // Deregister channels
+                Iterator<SelectionKey> i = keys.iterator();
+                while (i.hasNext()) {
+                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
+                    deregister(ski);
+                    SelectableChannel selch = ski.channel();
+                    if (!selch.isOpen() && !selch.isRegistered())
+                        ((SelChImpl)selch).kill();
+                    i.remove();
+                }
+                totalChannels = 0;
+            }
+            fd0 = -1;
+            fd1 = -1;
+        }
+    }
+
+
+    protected void implRegister(SelectionKeyImpl ski) {
+        if (closed)
+            throw new ClosedSelectorException();
+        int fd = IOUtil.fdVal(ski.channel.getFD());
+        fdMap.put(Integer.valueOf(fd), new MapEntry(ski));
+        totalChannels++;
+        keys.add(ski);
+    }
+
+
+    protected void implDereg(SelectionKeyImpl ski) throws IOException {
+        int fd = ski.channel.getFDVal();
+        fdMap.remove(Integer.valueOf(fd));
+        kqueueWrapper.release(ski.channel);
+        totalChannels--;
+        keys.remove(ski);
+        selectedKeys.remove(ski);
+        deregister((AbstractSelectionKey)ski);
+        SelectableChannel selch = ski.channel();
+        if (!selch.isOpen() && !selch.isRegistered())
+            ((SelChImpl)selch).kill();
+    }
+
+
+    public void putEventOps(SelectionKeyImpl ski, int ops) {
+        if (closed)
+            throw new ClosedSelectorException();
+        kqueueWrapper.setInterest(ski.channel, ops);
+    }
+
+
+    public Selector wakeup() {
+        synchronized (interruptLock) {
+            if (!interruptTriggered) {
+                kqueueWrapper.interrupt();
+                interruptTriggered = true;
+            }
+        }
+        return this;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/classes/sun/nio/ch/KQueueSelectorProvider.java	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueSelectorProvider.java
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollSelectorProvider
+ */
+
+package sun.nio.ch;
+
+import java.io.IOException;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+
+public class KQueueSelectorProvider
+extends SelectorProviderImpl
+{
+    public AbstractSelector openSelector() throws IOException {
+        return new KQueueSelectorImpl(this);
+    }
+}
--- ./jdk/src/bsd/doc/man/javah.1	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/bsd/doc/man/javah.1	Sun Sep 02 07:33:40 2018 -0700
@@ -8,7 +8,7 @@
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
@@ -109,7 +109,7 @@
 
 \&.:\fIyour-path\fR
 
-Example: \f3\&.:/home/avh/classes:/usr/local/java/classes\fR
+Example: \f3\&.:/home/avh/classes:/usr/local/share/java/classes\fR
 
 \fIWindows\fR:
 
--- ./jdk/src/bsd/doc/man/rmic.1	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/bsd/doc/man/rmic.1	Sun Sep 02 07:33:40 2018 -0700
@@ -8,7 +8,7 @@
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
@@ -92,7 +92,7 @@
 .TP
 -classpath path
 .br
-Specifies the path the \f3rmic\fR command uses to look up classes\&. This option overrides the default or the \f3CLASSPATH\fR environment variable when it is set\&. Directories are separated by colons\&. The general format for path is: \f3\&.:<your_path>\fR, for example: \f3\&.:/usr/local/java/classes\fR\&.
+Specifies the path the \f3rmic\fR command uses to look up classes\&. This option overrides the default or the \f3CLASSPATH\fR environment variable when it is set\&. Directories are separated by colons\&. The general format for path is: \f3\&.:<your_path>\fR, for example: \f3\&.:/usr/local/share/java/classes\fR\&.
 .TP
 -d \fIdirectory\fR
 .br
@@ -206,7 +206,7 @@
 .SH ENVIRONMENT\ VARIABLES    
 .TP     
 CLASSPATH
-Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/java/classes\fR\&.
+Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/share/java/classes\fR\&.
 .SH SEE\ ALSO    
 .TP 0.2i    
 \(bu
--- ./jdk/src/bsd/doc/man/rmid.1	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/bsd/doc/man/rmid.1	Sun Sep 02 07:33:40 2018 -0700
@@ -8,7 +8,7 @@
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
@@ -300,7 +300,7 @@
 .SH ENVIRONMENT\ VARIABLES    
 .TP     
 CLASSPATH
-Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/java/classes\fR\&.
+Used to provide the system a path to user-defined classes\&. Directories are separated by colons, for example: \f3\&.:/usr/local/share/java/classes\fR\&.
 .SH SEE\ ALSO    
 .TP 0.2i    
 \(bu
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/bsd/native/sun/nio/ch/KQueueArrayWrapper.c	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * KQueueArrayWrapper.c
+ * Implementation of Selector using FreeBSD / Mac OS X kqueues
+ * Derived from Sun's DevPollArrayWrapper
+ */
+
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes(JNIEnv *env, jclass clazz)
+{
+#define CHECK_EXCEPTION() { \
+    if ((*env)->ExceptionCheck(env)) { \
+        goto exceptionOccurred; \
+    } \
+}
+
+#define CHECK_ERROR_AND_EXCEPTION(_field) { \
+    if (_field == NULL) { \
+        goto badField; \
+    } \
+    CHECK_EXCEPTION(); \
+}
+
+
+    jfieldID field;
+
+    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_READ", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, EVFILT_READ);
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_WRITE", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, EVFILT_WRITE);
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "SIZEOF_KEVENT", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, (short) sizeof(struct kevent));
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "FD_OFFSET", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, ident));
+    CHECK_EXCEPTION();
+
+    field = (*env)->GetStaticFieldID(env, clazz, "FILTER_OFFSET", "S");
+    CHECK_ERROR_AND_EXCEPTION(field);
+    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, filter));
+    CHECK_EXCEPTION();
+    return;
+
+badField:
+    return;
+
+exceptionOccurred:
+    return;
+
+#undef CHECK_EXCEPTION
+#undef CHECK_ERROR_AND_EXCEPTION
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_init(JNIEnv *env, jobject this)
+{
+    int kq = kqueue();
+    if (kq < 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue() failed");
+    }
+    return kq;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_register0(JNIEnv *env, jobject this,
+                                             jint kq, jint fd, jint r, jint w)
+{
+    struct kevent changes[2];
+    struct kevent errors[2];
+    struct timespec dontBlock = {0, 0};
+
+    // if (r) then { register for read } else { unregister for read }
+    // if (w) then { register for write } else { unregister for write }
+    // Ignore errors - they're probably complaints about deleting non-
+    //   added filters - but provide an error array anyway because
+    //   kqueue behaves erratically if some of its registrations fail.
+    EV_SET(&changes[0], fd, EVFILT_READ,  r ? EV_ADD : EV_DELETE, 0, 0, 0);
+    EV_SET(&changes[1], fd, EVFILT_WRITE, w ? EV_ADD : EV_DELETE, 0, 0, 0);
+    kevent(kq, changes, 2, errors, 2, &dontBlock);
+}
+
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq,
+                                           jlong kevAddr, jint kevCount,
+                                           jlong timeout)
+{
+    struct kevent *kevs = (struct kevent *)jlong_to_ptr(kevAddr);
+    struct timespec ts;
+    struct timespec *tsp;
+    int result;
+
+    // Java timeout is in milliseconds. Convert to struct timespec.
+    // Java timeout == -1 : wait forever : timespec timeout of NULL
+    // Java timeout == 0  : return immediately : timespec timeout of zero
+    if (timeout >= 0) {
+        ts.tv_sec = timeout / 1000;
+        ts.tv_nsec = (timeout % 1000) * 1000000; //nanosec = 1 million millisec
+        tsp = &ts;
+    } else {
+        tsp = NULL;
+    }
+
+    result = kevent(kq, NULL, 0, kevs, kevCount, tsp);
+
+    if (result < 0) {
+        if (errno == EINTR) {
+            // ignore EINTR, pretend nothing was selected
+            result = 0;
+        } else {
+            JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue failed");
+        }
+    }
+
+    return result;
+}
+
+
+JNIEXPORT void JNICALL
+Java_sun_nio_ch_KQueueArrayWrapper_interrupt(JNIEnv *env, jclass cls, jint fd)
+{
+    char c = 1;
+    if (1 != write(fd, &c, 1)) {
+        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: interrupt failed");
+    }
+}
+
--- ./jdk/src/macosx/classes/java/net/DefaultInterface.java	Sat Jun 23 21:02:10 2018 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.net;
-
-/**
- * Choose a network interface to be the default for
- * outgoing IPv6 traffic that does not specify a scope_id (and which needs one).
- * We choose the first interface that is up and is (in order of preference):
- * 1. neither loopback nor point to point
- * 2. point to point
- * 3. loopback
- * 4. none.
- * Platforms that do not require a default interface implement a dummy
- * that returns null.
- */
-
-import java.util.Enumeration;
-import java.io.IOException;
-
-class DefaultInterface {
-
-    private final static NetworkInterface defaultInterface =
-        chooseDefaultInterface();
-
-    static NetworkInterface getDefault() {
-        return defaultInterface;
-    }
-
-    /**
-     * Choose a default interface. This method returns an interface that is
-     * both "up" and supports multicast. This method choses an interface in
-     * order of preference:
-     * 1. neither loopback nor point to point
-     * 2. point to point
-     * 3. loopback
-     *
-     * @return  the chosen interface or {@code null} if there isn't a suitable
-     *          default
-     */
-    private static NetworkInterface chooseDefaultInterface() {
-        Enumeration<NetworkInterface> nifs;
-
-        try {
-           nifs = NetworkInterface.getNetworkInterfaces();
-        } catch (IOException ignore) {
-            // unable to enumate network interfaces
-            return null;
-        }
-
-        NetworkInterface ppp = null;
-        NetworkInterface loopback = null;
-
-        while (nifs.hasMoreElements()) {
-            NetworkInterface ni = nifs.nextElement();
-            try {
-                if (ni.isUp() && ni.supportsMulticast()) {
-                    boolean isLoopback = ni.isLoopback();
-                    boolean isPPP = ni.isPointToPoint();
-                    if (!isLoopback && !isPPP) {
-                        // found an interface that is not the loopback or a
-                        // point-to-point interface
-                        return ni;
-                    }
-                    if (ppp == null && isPPP)
-                        ppp = ni;
-                    if (loopback == null && isLoopback)
-                        loopback = ni;
-                }
-            } catch (IOException skip) { }
-        }
-
-        return (ppp != null) ? ppp : loopback;
-    }
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/DefaultSelectorProvider.java	Sat Jun 23 21:02:10 2018 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.nio.ch;
-
-import java.nio.channels.spi.SelectorProvider;
-
-/**
- * Creates this platform's default SelectorProvider
- */
-
-public class DefaultSelectorProvider {
-
-    /**
-     * Prevent instantiation.
-     */
-    private DefaultSelectorProvider() { }
-
-    /**
-     * Returns the default SelectorProvider.
-     */
-    public static SelectorProvider create() {
-        return new sun.nio.ch.KQueueSelectorProvider();
-    }
-
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/KQueueArrayWrapper.java	Sat Jun 23 21:02:10 2018 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,213 +0,0 @@
-/*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueArrayWrapper.java
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollArrayWrapper
- */
-
-package sun.nio.ch;
-
-import sun.misc.*;
-import java.io.IOException;
-import java.io.FileDescriptor;
-import java.util.Iterator;
-import java.util.LinkedList;
-
-/*
- * struct kevent {           // 32-bit    64-bit
- *     uintptr_t ident;      //   4         8
- *     short     filter;     //   2         2
- *     u_short   flags;      //   2         2
- *     u_int     fflags;     //   4         4
- *     intptr_t  data;       //   4         8
- *     void      *udata;     //   4         8
- * }                  // Total:  20        32
- *
- * The implementation works in 32-bit and 64-bit world. We do this by calling a
- * native function that actually sets the sizes and offsets of the fields based
- * on which mode we're in.
- */
-
-class KQueueArrayWrapper {
-    // kevent filters
-    static short EVFILT_READ;
-    static short EVFILT_WRITE;
-
-    // kevent struct
-    // These fields are now set by initStructSizes in the static initializer.
-    static short SIZEOF_KEVENT;
-    static short FD_OFFSET;
-    static short FILTER_OFFSET;
-
-    // kevent array size
-    static final int NUM_KEVENTS = 128;
-
-    // Are we in a 64-bit VM?
-    static boolean is64bit = false;
-
-    // The kevent array (used for outcoming events only)
-    private AllocatedNativeObject keventArray = null;
-    private long keventArrayAddress;
-
-    // The kqueue fd
-    private int kq = -1;
-
-    // The fd of the interrupt line going out
-    private int outgoingInterruptFD;
-
-    // The fd of the interrupt line coming in
-    private int incomingInterruptFD;
-
-    static {
-        IOUtil.load();
-        initStructSizes();
-        String datamodel = java.security.AccessController.doPrivileged(
-            new sun.security.action.GetPropertyAction("sun.arch.data.model")
-        );
-        is64bit = datamodel.equals("64");
-    }
-
-    KQueueArrayWrapper() {
-        int allocationSize = SIZEOF_KEVENT * NUM_KEVENTS;
-        keventArray = new AllocatedNativeObject(allocationSize, true);
-        keventArrayAddress = keventArray.address();
-        kq = init();
-    }
-
-    // Used to update file description registrations
-    private static class Update {
-        SelChImpl channel;
-        int events;
-        Update(SelChImpl channel, int events) {
-            this.channel = channel;
-            this.events = events;
-        }
-    }
-
-    private LinkedList<Update> updateList = new LinkedList<Update>();
-
-    void initInterrupt(int fd0, int fd1) {
-        outgoingInterruptFD = fd1;
-        incomingInterruptFD = fd0;
-        register0(kq, fd0, 1, 0);
-    }
-
-    int getReventOps(int index) {
-        int result = 0;
-        int offset = SIZEOF_KEVENT*index + FILTER_OFFSET;
-        short filter = keventArray.getShort(offset);
-
-        // This is all that's necessary based on inspection of usage:
-        //   SinkChannelImpl, SourceChannelImpl, DatagramChannelImpl,
-        //   ServerSocketChannelImpl, SocketChannelImpl
-        if (filter == EVFILT_READ) {
-            result |= Net.POLLIN;
-        } else if (filter == EVFILT_WRITE) {
-            result |= Net.POLLOUT;
-        }
-
-        return result;
-    }
-
-    int getDescriptor(int index) {
-        int offset = SIZEOF_KEVENT*index + FD_OFFSET;
-        /* The ident field is 8 bytes in 64-bit world, however the API wants us
-         * to return an int. Hence read the 8 bytes but return as an int.
-         */
-        if (is64bit) {
-          long fd = keventArray.getLong(offset);
-          assert fd <= Integer.MAX_VALUE;
-          return (int) fd;
-        } else {
-          return keventArray.getInt(offset);
-        }
-    }
-
-    void setInterest(SelChImpl channel, int events) {
-        synchronized (updateList) {
-            // update existing registration
-            updateList.add(new Update(channel, events));
-        }
-    }
-
-    void release(SelChImpl channel) {
-        synchronized (updateList) {
-            // flush any pending updates
-            for (Iterator<Update> it = updateList.iterator(); it.hasNext();) {
-                if (it.next().channel == channel) {
-                    it.remove();
-                }
-            }
-
-            // remove
-            register0(kq, channel.getFDVal(), 0, 0);
-        }
-    }
-
-    void updateRegistrations() {
-        synchronized (updateList) {
-            Update u = null;
-            while ((u = updateList.poll()) != null) {
-                SelChImpl ch = u.channel;
-                if (!ch.isOpen())
-                    continue;
-
-                register0(kq, ch.getFDVal(), u.events & Net.POLLIN, u.events & Net.POLLOUT);
-            }
-        }
-    }
-
-
-    void close() throws IOException {
-        if (keventArray != null) {
-            keventArray.free();
-            keventArray = null;
-        }
-        if (kq >= 0) {
-            FileDispatcherImpl.closeIntFD(kq);
-            kq = -1;
-        }
-    }
-
-    int poll(long timeout) {
-        updateRegistrations();
-        int updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);
-        return updated;
-    }
-
-    void interrupt() {
-        interrupt(outgoingInterruptFD);
-    }
-
-    private native int init();
-    private static native void initStructSizes();
-
-    private native void register0(int kq, int fd, int read, int write);
-    private native int kevent0(int kq, long keventAddress, int keventCount,
-                               long timeout);
-    private static native void interrupt(int fd);
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/KQueueSelectorImpl.java	Sat Jun 23 21:02:10 2018 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,263 +0,0 @@
-/*
- * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueSelectorImpl.java
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollSelectorImpl
- */
-
-package sun.nio.ch;
-
-import java.io.IOException;
-import java.io.FileDescriptor;
-import java.nio.channels.*;
-import java.nio.channels.spi.*;
-import java.util.*;
-import sun.misc.*;
-
-class KQueueSelectorImpl
-    extends SelectorImpl
-{
-    // File descriptors used for interrupt
-    protected int fd0;
-    protected int fd1;
-
-    // The kqueue manipulator
-    KQueueArrayWrapper kqueueWrapper;
-
-    // Count of registered descriptors (including interrupt)
-    private int totalChannels;
-
-    // Map from a file descriptor to an entry containing the selection key
-    private HashMap<Integer,MapEntry> fdMap;
-
-    // True if this Selector has been closed
-    private boolean closed = false;
-
-    // Lock for interrupt triggering and clearing
-    private Object interruptLock = new Object();
-    private boolean interruptTriggered = false;
-
-    // used by updateSelectedKeys to handle cases where the same file
-    // descriptor is polled by more than one filter
-    private long updateCount;
-
-    // Used to map file descriptors to a selection key and "update count"
-    // (see updateSelectedKeys for usage).
-    private static class MapEntry {
-        SelectionKeyImpl ski;
-        long updateCount;
-        MapEntry(SelectionKeyImpl ski) {
-            this.ski = ski;
-        }
-    }
-
-    /**
-     * Package private constructor called by factory method in
-     * the abstract superclass Selector.
-     */
-    KQueueSelectorImpl(SelectorProvider sp) {
-        super(sp);
-        long fds = IOUtil.makePipe(false);
-        fd0 = (int)(fds >>> 32);
-        fd1 = (int)fds;
-        try {
-            kqueueWrapper = new KQueueArrayWrapper();
-            kqueueWrapper.initInterrupt(fd0, fd1);
-            fdMap = new HashMap<>();
-            totalChannels = 1;
-        } catch (Throwable t) {
-            try {
-                FileDispatcherImpl.closeIntFD(fd0);
-            } catch (IOException ioe0) {
-                t.addSuppressed(ioe0);
-            }
-            try {
-                FileDispatcherImpl.closeIntFD(fd1);
-            } catch (IOException ioe1) {
-                t.addSuppressed(ioe1);
-            }
-            throw t;
-        }
-    }
-
-
-    protected int doSelect(long timeout)
-        throws IOException
-    {
-        int entries = 0;
-        if (closed)
-            throw new ClosedSelectorException();
-        processDeregisterQueue();
-        try {
-            begin();
-            entries = kqueueWrapper.poll(timeout);
-        } finally {
-            end();
-        }
-        processDeregisterQueue();
-        return updateSelectedKeys(entries);
-    }
-
-    /**
-     * Update the keys whose fd's have been selected by kqueue.
-     * Add the ready keys to the selected key set.
-     * If the interrupt fd has been selected, drain it and clear the interrupt.
-     */
-    private int updateSelectedKeys(int entries)
-        throws IOException
-    {
-        int numKeysUpdated = 0;
-        boolean interrupted = false;
-
-        // A file descriptor may be registered with kqueue with more than one
-        // filter and so there may be more than one event for a fd. The update
-        // count in the MapEntry tracks when the fd was last updated and this
-        // ensures that the ready ops are updated rather than replaced by a
-        // second or subsequent event.
-        updateCount++;
-
-        for (int i = 0; i < entries; i++) {
-            int nextFD = kqueueWrapper.getDescriptor(i);
-            if (nextFD == fd0) {
-                interrupted = true;
-            } else {
-                MapEntry me = fdMap.get(Integer.valueOf(nextFD));
-
-                // entry is null in the case of an interrupt
-                if (me != null) {
-                    int rOps = kqueueWrapper.getReventOps(i);
-                    SelectionKeyImpl ski = me.ski;
-                    if (selectedKeys.contains(ski)) {
-                        // first time this file descriptor has been encountered on this
-                        // update?
-                        if (me.updateCount != updateCount) {
-                            if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
-                                numKeysUpdated++;
-                                me.updateCount = updateCount;
-                            }
-                        } else {
-                            // ready ops have already been set on this update
-                            ski.channel.translateAndUpdateReadyOps(rOps, ski);
-                        }
-                    } else {
-                        ski.channel.translateAndSetReadyOps(rOps, ski);
-                        if ((ski.nioReadyOps() & ski.nioInterestOps()) != 0) {
-                            selectedKeys.add(ski);
-                            numKeysUpdated++;
-                            me.updateCount = updateCount;
-                        }
-                    }
-                }
-            }
-        }
-
-        if (interrupted) {
-            // Clear the wakeup pipe
-            synchronized (interruptLock) {
-                IOUtil.drain(fd0);
-                interruptTriggered = false;
-            }
-        }
-        return numKeysUpdated;
-    }
-
-
-    protected void implClose() throws IOException {
-        if (!closed) {
-            closed = true;
-
-            // prevent further wakeup
-            synchronized (interruptLock) {
-                interruptTriggered = true;
-            }
-
-            FileDispatcherImpl.closeIntFD(fd0);
-            FileDispatcherImpl.closeIntFD(fd1);
-            if (kqueueWrapper != null) {
-                kqueueWrapper.close();
-                kqueueWrapper = null;
-                selectedKeys = null;
-
-                // Deregister channels
-                Iterator<SelectionKey> i = keys.iterator();
-                while (i.hasNext()) {
-                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();
-                    deregister(ski);
-                    SelectableChannel selch = ski.channel();
-                    if (!selch.isOpen() && !selch.isRegistered())
-                        ((SelChImpl)selch).kill();
-                    i.remove();
-                }
-                totalChannels = 0;
-            }
-            fd0 = -1;
-            fd1 = -1;
-        }
-    }
-
-
-    protected void implRegister(SelectionKeyImpl ski) {
-        if (closed)
-            throw new ClosedSelectorException();
-        int fd = IOUtil.fdVal(ski.channel.getFD());
-        fdMap.put(Integer.valueOf(fd), new MapEntry(ski));
-        totalChannels++;
-        keys.add(ski);
-    }
-
-
-    protected void implDereg(SelectionKeyImpl ski) throws IOException {
-        int fd = ski.channel.getFDVal();
-        fdMap.remove(Integer.valueOf(fd));
-        kqueueWrapper.release(ski.channel);
-        totalChannels--;
-        keys.remove(ski);
-        selectedKeys.remove(ski);
-        deregister((AbstractSelectionKey)ski);
-        SelectableChannel selch = ski.channel();
-        if (!selch.isOpen() && !selch.isRegistered())
-            ((SelChImpl)selch).kill();
-    }
-
-
-    public void putEventOps(SelectionKeyImpl ski, int ops) {
-        if (closed)
-            throw new ClosedSelectorException();
-        kqueueWrapper.setInterest(ski.channel, ops);
-    }
-
-
-    public Selector wakeup() {
-        synchronized (interruptLock) {
-            if (!interruptTriggered) {
-                kqueueWrapper.interrupt();
-                interruptTriggered = true;
-            }
-        }
-        return this;
-    }
-}
--- ./jdk/src/macosx/classes/sun/nio/ch/KQueueSelectorProvider.java	Sat Jun 23 21:02:10 2018 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueSelectorProvider.java
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollSelectorProvider
- */
-
-package sun.nio.ch;
-
-import java.io.IOException;
-import java.nio.channels.*;
-import java.nio.channels.spi.*;
-
-public class KQueueSelectorProvider
-extends SelectorProviderImpl
-{
-    public AbstractSelector openSelector() throws IOException {
-        return new KQueueSelectorImpl(this);
-    }
-}
--- ./jdk/src/macosx/native/sun/nio/ch/KQueueArrayWrapper.c	Sat Jun 23 21:02:10 2018 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,171 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * KQueueArrayWrapper.c
- * Implementation of Selector using FreeBSD / Mac OS X kqueues
- * Derived from Sun's DevPollArrayWrapper
- */
-
-
-#include "jni.h"
-#include "jni_util.h"
-#include "jvm.h"
-#include "jlong.h"
-
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/time.h>
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes(JNIEnv *env, jclass clazz)
-{
-#define CHECK_EXCEPTION() { \
-    if ((*env)->ExceptionCheck(env)) { \
-        goto exceptionOccurred; \
-    } \
-}
-
-#define CHECK_ERROR_AND_EXCEPTION(_field) { \
-    if (_field == NULL) { \
-        goto badField; \
-    } \
-    CHECK_EXCEPTION(); \
-}
-
-
-    jfieldID field;
-
-    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_READ", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, EVFILT_READ);
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "EVFILT_WRITE", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, EVFILT_WRITE);
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "SIZEOF_KEVENT", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, (short) sizeof(struct kevent));
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "FD_OFFSET", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, ident));
-    CHECK_EXCEPTION();
-
-    field = (*env)->GetStaticFieldID(env, clazz, "FILTER_OFFSET", "S");
-    CHECK_ERROR_AND_EXCEPTION(field);
-    (*env)->SetStaticShortField(env, clazz, field, (short) offsetof(struct kevent, filter));
-    CHECK_EXCEPTION();
-    return;
-
-badField:
-    return;
-
-exceptionOccurred:
-    return;
-
-#undef CHECK_EXCEPTION
-#undef CHECK_ERROR_AND_EXCEPTION
-}
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_init(JNIEnv *env, jobject this)
-{
-    int kq = kqueue();
-    if (kq < 0) {
-        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue() failed");
-    }
-    return kq;
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_register0(JNIEnv *env, jobject this,
-                                             jint kq, jint fd, jint r, jint w)
-{
-    struct kevent changes[2];
-    struct kevent errors[2];
-    struct timespec dontBlock = {0, 0};
-
-    // if (r) then { register for read } else { unregister for read }
-    // if (w) then { register for write } else { unregister for write }
-    // Ignore errors - they're probably complaints about deleting non-
-    //   added filters - but provide an error array anyway because
-    //   kqueue behaves erratically if some of its registrations fail.
-    EV_SET(&changes[0], fd, EVFILT_READ,  r ? EV_ADD : EV_DELETE, 0, 0, 0);
-    EV_SET(&changes[1], fd, EVFILT_WRITE, w ? EV_ADD : EV_DELETE, 0, 0, 0);
-    kevent(kq, changes, 2, errors, 2, &dontBlock);
-}
-
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq,
-                                           jlong kevAddr, jint kevCount,
-                                           jlong timeout)
-{
-    struct kevent *kevs = (struct kevent *)jlong_to_ptr(kevAddr);
-    struct timespec ts;
-    struct timespec *tsp;
-    int result;
-
-    // Java timeout is in milliseconds. Convert to struct timespec.
-    // Java timeout == -1 : wait forever : timespec timeout of NULL
-    // Java timeout == 0  : return immediately : timespec timeout of zero
-    if (timeout >= 0) {
-        ts.tv_sec = timeout / 1000;
-        ts.tv_nsec = (timeout % 1000) * 1000000; //nanosec = 1 million millisec
-        tsp = &ts;
-    } else {
-        tsp = NULL;
-    }
-
-    result = kevent(kq, NULL, 0, kevs, kevCount, tsp);
-
-    if (result < 0) {
-        if (errno == EINTR) {
-            // ignore EINTR, pretend nothing was selected
-            result = 0;
-        } else {
-            JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue failed");
-        }
-    }
-
-    return result;
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_KQueueArrayWrapper_interrupt(JNIEnv *env, jclass cls, jint fd)
-{
-    char c = 1;
-    if (1 != write(fd, &c, 1)) {
-        JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: interrupt failed");
-    }
-}
-
--- ./jdk/src/share/bin/jli_util.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/bin/jli_util.h	Sun Sep 02 07:33:40 2018 -0700
@@ -87,7 +87,7 @@
 #define _LARGFILE64_SOURCE
 #define JLI_Lseek                       lseek64
 #endif
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #define JLI_Lseek                       lseek
 #endif
 #ifdef _AIX
--- ./jdk/src/share/classes/sun/awt/FontConfiguration.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/awt/FontConfiguration.java	Sun Sep 02 07:33:40 2018 -0700
@@ -1146,7 +1146,7 @@
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!FontUtilities.isLinux) {
+        if (!FontUtilities.isLinux && !FontUtilities.isBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
--- ./jdk/src/share/classes/sun/awt/OSInfo.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/awt/OSInfo.java	Sun Sep 02 07:33:40 2018 -0700
@@ -39,6 +39,7 @@
         WINDOWS,
         LINUX,
         SOLARIS,
+        BSD,
         MACOSX,
         UNKNOWN
     }
@@ -101,6 +102,10 @@
                 return SOLARIS;
             }
 
+            if (osName.endsWith("BSD")) {
+                return BSD;
+            }
+
             if (osName.contains("OS X")) {
                 return MACOSX;
             }
--- ./jdk/src/share/classes/sun/font/FontUtilities.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/font/FontUtilities.java	Sun Sep 02 07:33:40 2018 -0700
@@ -48,6 +48,8 @@
 
     public static boolean isLinux;
 
+    public static boolean isBSD;
+
     public static boolean isMacOSX;
 
     public static boolean isSolaris8;
@@ -78,6 +80,8 @@
 
                 isLinux = osName.startsWith("Linux");
 
+                isBSD = osName.endsWith("BSD");
+
                 isMacOSX = osName.contains("OS X"); // TODO: MacOSX
 
                 String t2kStr = System.getProperty("sun.java2d.font.scaler");
--- ./jdk/src/share/classes/sun/font/SunFontManager.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/font/SunFontManager.java	Sun Sep 02 07:33:40 2018 -0700
@@ -418,7 +418,7 @@
                          * registerFonts method as on-screen these JRE fonts
                          * always go through the T2K rasteriser.
                          */
-                        if (FontUtilities.isLinux) {
+                        if (FontUtilities.isLinux || FontUtilities.isBSD) {
                             /* Linux font configuration uses these fonts */
                             registerFontDir(jreFontDirName);
                         }
--- ./jdk/src/share/classes/sun/nio/cs/ext/ExtendedCharsets.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/nio/cs/ext/ExtendedCharsets.java	Sun Sep 02 07:33:40 2018 -0700
@@ -1306,7 +1306,7 @@
         String osName = AccessController.doPrivileged(
             new GetPropertyAction("os.name"));
         if ("SunOS".equals(osName) || "Linux".equals(osName) || "AIX".equals(osName)
-               || osName.contains("OS X")) {
+               || osName.endsWith("BSD") || osName.contains("OS X")) {
             charset("x-COMPOUND_TEXT", "COMPOUND_TEXT",
                     new String[] {
                         "COMPOUND_TEXT",        // JDK historical
--- ./jdk/src/share/classes/sun/print/PSPrinterJob.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/print/PSPrinterJob.java	Sun Sep 02 07:33:40 2018 -0700
@@ -1587,9 +1587,31 @@
         }
 
        String osname = System.getProperty("os.name");
-       if (osname.equals("Linux") || osname.contains("OS X")) {
+       if (osname.equals("Linux") || osname.endsWith("BSD") || osname.contains("OS X")) {
+            String lprPath = "/usr/bin/lpr";
+            if (osname.equals("FreeBSD")) {
+                final PrintService pservice = getPrintService();
+                Boolean isIPPPrinter =
+                    (Boolean)java.security.AccessController.doPrivileged(
+                    new java.security.PrivilegedAction() {
+                        public Object run() {
+                            try {
+                                Class psClass =
+                                    Class.forName("sun.print.IPPPrintService");
+                                if (psClass.isInstance(pservice)) {
+                                    return Boolean.TRUE;
+                                }
+                            } catch (Throwable t) {
+                            }
+                            return Boolean.FALSE;
+                        }
+                    });
+                if (isIPPPrinter) {
+                    lprPath = "/usr/local/bin/lpr";
+                }
+            }
             execCmd = new String[ncomps];
-            execCmd[n++] = "/usr/bin/lpr";
+            execCmd[n++] = lprPath;
             if ((pFlags & PRINTER) != 0) {
                 execCmd[n++] = "-P" + printer;
             }
--- ./jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/security/jgss/GSSManagerImpl.java	Sun Sep 02 07:33:40 2018 -0700
@@ -48,6 +48,7 @@
                     public Boolean run() {
                             String osname = System.getProperty("os.name");
                             if (osname.startsWith("SunOS") ||
+                                osname.endsWith("BSD") ||
                                 osname.contains("OS X") ||
                                 osname.startsWith("Linux")) {
                                 return new Boolean(System.getProperty
--- ./jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	Sun Sep 02 07:33:40 2018 -0700
@@ -90,6 +90,12 @@
                                     "libgssapi_krb5.so",
                                     "libgssapi_krb5.so.2",
                                 };
+                            } else if (osname.endsWith("BSD")) {
+                                gssLibs = new String[]{
+                                    "libgssapi.so",
+                                    "libgssapi_krb5.so",
+                                    "libgssapi_krb5.so.10",
+                                };
                             } else if (osname.contains("OS X")) {
                                 gssLibs = new String[]{
                                     "libgssapi_krb5.dylib",
--- ./jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	Sun Sep 02 07:33:40 2018 -0700
@@ -31,4 +31,5 @@
 #[windows]sun.tools.attach.WindowsAttachProvider
 #[linux]sun.tools.attach.LinuxAttachProvider
 #[macosx]sun.tools.attach.BsdAttachProvider
+#[bsd]sun.tools.attach.BsdAttachProvider
 #[aix]sun.tools.attach.AixAttachProvider
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/lib/security/java.security-bsd	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,983 @@
+#
+# This is the "master security properties file".
+#
+# An alternate java.security properties file may be specified
+# from the command line via the system property
+#
+#    -Djava.security.properties=<URL>
+#
+# This properties file appends to the master security properties file.
+# If both properties files specify values for the same key, the value
+# from the command-line properties file is selected, as it is the last
+# one loaded.
+#
+# Also, if you specify
+#
+#    -Djava.security.properties==<URL> (2 equals),
+#
+# then that properties file completely overrides the master security
+# properties file.
+#
+# To disable the ability to specify an additional properties file from
+# the command line, set the key security.overridePropertiesFile
+# to false in the master security properties file. It is set to true
+# by default.
+
+# In this file, various security properties are set for use by
+# java.security classes. This is where users can statically register
+# Cryptography Package Providers ("providers" for short). The term
+# "provider" refers to a package or set of packages that supply a
+# concrete implementation of a subset of the cryptography aspects of
+# the Java Security API. A provider may, for example, implement one or
+# more digital signature algorithms or message digest algorithms.
+#
+# Each provider must implement a subclass of the Provider class.
+# To register a provider in this master security properties file,
+# specify the Provider subclass name and priority in the format
+#
+#    security.provider.<n>=<className>
+#
+# This declares a provider, and specifies its preference
+# order n. The preference order is the order in which providers are
+# searched for requested algorithms (when no specific provider is
+# requested). The order is 1-based; 1 is the most preferred, followed
+# by 2, and so on.
+#
+# <className> must specify the subclass of the Provider class whose
+# constructor sets the values of various properties that are required
+# for the Java Security API to look up the algorithms or other
+# facilities implemented by the provider.
+#
+# There must be at least one provider specification in java.security.
+# There is a default provider that comes standard with the JDK. It
+# is called the "SUN" provider, and its Provider subclass
+# named Sun appears in the sun.security.provider package. Thus, the
+# "SUN" provider is registered via the following:
+#
+#    security.provider.1=sun.security.provider.Sun
+#
+# (The number 1 is used for the default provider.)
+#
+# Note: Providers can be dynamically registered instead by calls to
+# either the addProvider or insertProviderAt method in the Security
+# class.
+
+#
+# List of providers and their preference orders (see above):
+#
+security.provider.1=sun.security.provider.Sun
+security.provider.2=sun.security.rsa.SunRsaSign
+security.provider.3=sun.security.ec.SunEC
+security.provider.4=com.sun.net.ssl.internal.ssl.Provider
+security.provider.5=com.sun.crypto.provider.SunJCE
+security.provider.6=sun.security.jgss.SunProvider
+security.provider.7=com.sun.security.sasl.Provider
+security.provider.8=org.jcp.xml.dsig.internal.dom.XMLDSigRI
+security.provider.9=sun.security.smartcardio.SunPCSC
+
+#
+# Sun Provider SecureRandom seed source.
+#
+# Select the primary source of seed data for the "SHA1PRNG" and
+# "NativePRNG" SecureRandom implementations in the "Sun" provider.
+# (Other SecureRandom implementations might also use this property.)
+#
+# On Unix-like systems (for example, Solaris/Linux/MacOS), the
+# "NativePRNG" and "SHA1PRNG" implementations obtains seed data from
+# special device files such as file:/dev/random.
+#
+# On Windows systems, specifying the URLs "file:/dev/random" or
+# "file:/dev/urandom" will enable the native Microsoft CryptoAPI seeding
+# mechanism for SHA1PRNG.
+#
+# By default, an attempt is made to use the entropy gathering device
+# specified by the "securerandom.source" Security property.  If an
+# exception occurs while accessing the specified URL:
+#
+#     SHA1PRNG:
+#         the traditional system/thread activity algorithm will be used.
+#
+#     NativePRNG:
+#         a default value of /dev/random will be used.  If neither
+#         are available, the implementation will be disabled.
+#         "file" is the only currently supported protocol type.
+#
+# The entropy gathering device can also be specified with the System
+# property "java.security.egd". For example:
+#
+#   % java -Djava.security.egd=file:/dev/random MainClass
+#
+# Specifying this System property will override the
+# "securerandom.source" Security property.
+#
+# In addition, if "file:/dev/random" or "file:/dev/urandom" is
+# specified, the "NativePRNG" implementation will be more preferred than
+# SHA1PRNG in the Sun provider.
+#
+securerandom.source=file:/dev/random
+
+#
+# A list of known strong SecureRandom implementations.
+#
+# To help guide applications in selecting a suitable strong
+# java.security.SecureRandom implementation, Java distributions should
+# indicate a list of known strong implementations using the property.
+#
+# This is a comma-separated list of algorithm and/or algorithm:provider
+# entries.
+#
+securerandom.strongAlgorithms=NativePRNGBlocking:SUN
+
+#
+# Class to instantiate as the javax.security.auth.login.Configuration
+# provider.
+#
+login.configuration.provider=sun.security.provider.ConfigFile
+
+#
+# Default login configuration file
+#
+#login.config.url.1=file:${user.home}/.java.login.config
+
+#
+# Class to instantiate as the system Policy. This is the name of the class
+# that will be used as the Policy object.
+#
+policy.provider=sun.security.provider.PolicyFile
+
+# The default is to have a single system-wide policy file,
+# and a policy file in the user's home directory.
+policy.url.1=file:${java.home}/lib/security/java.policy
+policy.url.2=file:${user.home}/.java.policy
+
+# whether or not we expand properties in the policy file
+# if this is set to false, properties (${...}) will not be expanded in policy
+# files.
+policy.expandProperties=true
+
+# whether or not we allow an extra policy to be passed on the command line
+# with -Djava.security.policy=somefile. Comment out this line to disable
+# this feature.
+policy.allowSystemProperty=true
+
+# whether or not we look into the IdentityScope for trusted Identities
+# when encountering a 1.1 signed JAR file. If the identity is found
+# and is trusted, we grant it AllPermission.
+policy.ignoreIdentityScope=false
+
+#
+# Default keystore type.
+#
+keystore.type=jks
+
+#
+# Controls compatibility mode for the JKS keystore type.
+#
+# When set to 'true', the JKS keystore type supports loading
+# keystore files in either JKS or PKCS12 format. When set to 'false'
+# it supports loading only JKS keystore files.
+#
+keystore.type.compat=true
+
+#
+# List of comma-separated packages that start with or equal this string
+# will cause a security exception to be thrown when
+# passed to checkPackageAccess unless the
+# corresponding RuntimePermission ("accessClassInPackage."+package) has
+# been granted.
+package.access=sun.,\
+               com.sun.xml.internal.,\
+               com.sun.imageio.,\
+               com.sun.istack.internal.,\
+               com.sun.jmx.,\
+               com.sun.media.sound.,\
+               com.sun.naming.internal.,\
+               com.sun.proxy.,\
+               com.sun.corba.se.,\
+               com.sun.org.apache.bcel.internal.,\
+               com.sun.org.apache.regexp.internal.,\
+               com.sun.org.apache.xerces.internal.,\
+               com.sun.org.apache.xpath.internal.,\
+               com.sun.org.apache.xalan.internal.extensions.,\
+               com.sun.org.apache.xalan.internal.lib.,\
+               com.sun.org.apache.xalan.internal.res.,\
+               com.sun.org.apache.xalan.internal.templates.,\
+               com.sun.org.apache.xalan.internal.utils.,\
+               com.sun.org.apache.xalan.internal.xslt.,\
+               com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+               com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+               com.sun.org.apache.xalan.internal.xsltc.trax.,\
+               com.sun.org.apache.xalan.internal.xsltc.util.,\
+               com.sun.org.apache.xml.internal.res.,\
+               com.sun.org.apache.xml.internal.resolver.helpers.,\
+               com.sun.org.apache.xml.internal.resolver.readers.,\
+               com.sun.org.apache.xml.internal.security.,\
+               com.sun.org.apache.xml.internal.serializer.utils.,\
+               com.sun.org.apache.xml.internal.utils.,\
+               com.sun.org.glassfish.,\
+               com.oracle.xmlns.internal.,\
+               com.oracle.webservices.internal.,\
+               oracle.jrockit.jfr.,\
+               org.jcp.xml.dsig.internal.,\
+               jdk.internal.,\
+               jdk.nashorn.internal.,\
+               jdk.nashorn.tools.,\
+               jdk.xml.internal.,\
+               com.sun.activation.registries.
+
+#
+# List of comma-separated packages that start with or equal this string
+# will cause a security exception to be thrown when
+# passed to checkPackageDefinition unless the
+# corresponding RuntimePermission ("defineClassInPackage."+package) has
+# been granted.
+#
+# by default, none of the class loaders supplied with the JDK call
+# checkPackageDefinition.
+#
+package.definition=sun.,\
+                   com.sun.xml.internal.,\
+                   com.sun.imageio.,\
+                   com.sun.istack.internal.,\
+                   com.sun.jmx.,\
+                   com.sun.media.sound.,\
+                   com.sun.naming.internal.,\
+                   com.sun.proxy.,\
+                   com.sun.corba.se.,\
+                   com.sun.org.apache.bcel.internal.,\
+                   com.sun.org.apache.regexp.internal.,\
+                   com.sun.org.apache.xerces.internal.,\
+                   com.sun.org.apache.xpath.internal.,\
+                   com.sun.org.apache.xalan.internal.extensions.,\
+                   com.sun.org.apache.xalan.internal.lib.,\
+                   com.sun.org.apache.xalan.internal.res.,\
+                   com.sun.org.apache.xalan.internal.templates.,\
+                   com.sun.org.apache.xalan.internal.utils.,\
+                   com.sun.org.apache.xalan.internal.xslt.,\
+                   com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+                   com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+                   com.sun.org.apache.xalan.internal.xsltc.trax.,\
+                   com.sun.org.apache.xalan.internal.xsltc.util.,\
+                   com.sun.org.apache.xml.internal.res.,\
+                   com.sun.org.apache.xml.internal.resolver.helpers.,\
+                   com.sun.org.apache.xml.internal.resolver.readers.,\
+                   com.sun.org.apache.xml.internal.security.,\
+                   com.sun.org.apache.xml.internal.serializer.utils.,\
+                   com.sun.org.apache.xml.internal.utils.,\
+                   com.sun.org.glassfish.,\
+                   com.oracle.xmlns.internal.,\
+                   com.oracle.webservices.internal.,\
+                   oracle.jrockit.jfr.,\
+                   org.jcp.xml.dsig.internal.,\
+                   jdk.internal.,\
+                   jdk.nashorn.internal.,\
+                   jdk.nashorn.tools.,\
+                   jdk.xml.internal.,\
+                   com.sun.activation.registries.
+
+#
+# Determines whether this properties file can be appended to
+# or overridden on the command line via -Djava.security.properties
+#
+security.overridePropertiesFile=true
+
+#
+# Determines the default key and trust manager factory algorithms for
+# the javax.net.ssl package.
+#
+ssl.KeyManagerFactory.algorithm=SunX509
+ssl.TrustManagerFactory.algorithm=PKIX
+
+#
+# The Java-level namelookup cache policy for successful lookups:
+#
+# any negative value: caching forever
+# any positive value: the number of seconds to cache an address for
+# zero: do not cache
+#
+# default value is forever (FOREVER). For security reasons, this
+# caching is made forever when a security manager is set. When a security
+# manager is not set, the default behavior in this implementation
+# is to cache for 30 seconds.
+#
+# NOTE: setting this to anything other than the default value can have
+#       serious security implications. Do not set it unless
+#       you are sure you are not exposed to DNS spoofing attack.
+#
+#networkaddress.cache.ttl=-1
+
+# The Java-level namelookup cache policy for failed lookups:
+#
+# any negative value: cache forever
+# any positive value: the number of seconds to cache negative lookup results
+# zero: do not cache
+#
+# In some Microsoft Windows networking environments that employ
+# the WINS name service in addition to DNS, name service lookups
+# that fail may take a noticeably long time to return (approx. 5 seconds).
+# For this reason the default caching policy is to maintain these
+# results for 10 seconds.
+#
+#
+networkaddress.cache.negative.ttl=10
+
+#
+# Properties to configure OCSP for certificate revocation checking
+#
+
+# Enable OCSP
+#
+# By default, OCSP is not used for certificate revocation checking.
+# This property enables the use of OCSP when set to the value "true".
+#
+# NOTE: SocketPermission is required to connect to an OCSP responder.
+#
+# Example,
+#   ocsp.enable=true
+
+#
+# Location of the OCSP responder
+#
+# By default, the location of the OCSP responder is determined implicitly
+# from the certificate being validated. This property explicitly specifies
+# the location of the OCSP responder. The property is used when the
+# Authority Information Access extension (defined in RFC 3280) is absent
+# from the certificate or when it requires overriding.
+#
+# Example,
+#   ocsp.responderURL=http://ocsp.example.net:80
+
+#
+# Subject name of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# distinguished name (defined in RFC 2253) which identifies a certificate in
+# the set of certificates supplied during cert path validation. In cases where
+# the subject name alone is not sufficient to uniquely identify the certificate
+# then both the "ocsp.responderCertIssuerName" and
+# "ocsp.responderCertSerialNumber" properties must be used instead. When this
+# property is set then those two properties are ignored.
+#
+# Example,
+#   ocsp.responderCertSubjectName="CN=OCSP Responder, O=XYZ Corp"
+
+#
+# Issuer name of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# distinguished name (defined in RFC 2253) which identifies a certificate in
+# the set of certificates supplied during cert path validation. When this
+# property is set then the "ocsp.responderCertSerialNumber" property must also
+# be set. When the "ocsp.responderCertSubjectName" property is set then this
+# property is ignored.
+#
+# Example,
+#   ocsp.responderCertIssuerName="CN=Enterprise CA, O=XYZ Corp"
+
+#
+# Serial number of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# of hexadecimal digits (colon or space separators may be present) which
+# identifies a certificate in the set of certificates supplied during cert path
+# validation. When this property is set then the "ocsp.responderCertIssuerName"
+# property must also be set. When the "ocsp.responderCertSubjectName" property
+# is set then this property is ignored.
+#
+# Example,
+#   ocsp.responderCertSerialNumber=2A:FF:00
+
+#
+# Policy for failed Kerberos KDC lookups:
+#
+# When a KDC is unavailable (network error, service failure, etc), it is
+# put inside a blacklist and accessed less often for future requests. The
+# value (case-insensitive) for this policy can be:
+#
+# tryLast
+#    KDCs in the blacklist are always tried after those not on the list.
+#
+# tryLess[:max_retries,timeout]
+#    KDCs in the blacklist are still tried by their order in the configuration,
+#    but with smaller max_retries and timeout values. max_retries and timeout
+#    are optional numerical parameters (default 1 and 5000, which means once
+#    and 5 seconds). Please notes that if any of the values defined here is
+#    more than what is defined in krb5.conf, it will be ignored.
+#
+# Whenever a KDC is detected as available, it is removed from the blacklist.
+# The blacklist is reset when krb5.conf is reloaded. You can add
+# refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
+# reloaded whenever a JAAS authentication is attempted.
+#
+# Example,
+#   krb5.kdc.bad.policy = tryLast
+#   krb5.kdc.bad.policy = tryLess:2,2000
+krb5.kdc.bad.policy = tryLast
+
+# Algorithm restrictions for certification path (CertPath) processing
+#
+# In some environments, certain algorithms or key lengths may be undesirable
+# for certification path building and validation.  For example, "MD2" is
+# generally no longer considered to be a secure hash algorithm.  This section
+# describes the mechanism for disabling algorithms based on algorithm name
+# and/or key length.  This includes algorithms used in certificates, as well
+# as revocation information such as CRLs and signed OCSP Responses.
+# The syntax of the disabled algorithm string is described as follows:
+#   DisabledAlgorithms:
+#       " DisabledAlgorithm { , DisabledAlgorithm } "
+#
+#   DisabledAlgorithm:
+#       AlgorithmName [Constraint] { '&' Constraint }
+#
+#   AlgorithmName:
+#       (see below)
+#
+#   Constraint:
+#       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
+#       UsageConstraint
+#
+#   KeySizeConstraint:
+#       keySize Operator KeyLength
+#
+#   Operator:
+#       <= | < | == | != | >= | >
+#
+#   KeyLength:
+#       Integer value of the algorithm's key length in bits
+#
+#   CAConstraint:
+#       jdkCA
+#
+#   DenyAfterConstraint:
+#       denyAfter YYYY-MM-DD
+#
+#   UsageConstraint:
+#       usage [TLSServer] [TLSClient] [SignedJAR]
+#
+# The "AlgorithmName" is the standard algorithm name of the disabled
+# algorithm. See "Java Cryptography Architecture Standard Algorithm Name
+# Documentation" for information about Standard Algorithm Names.  Matching
+# is performed using a case-insensitive sub-element matching rule.  (For
+# example, in "SHA1withECDSA" the sub-elements are "SHA1" for hashing and
+# "ECDSA" for signatures.)  If the assertion "AlgorithmName" is a
+# sub-element of the certificate algorithm name, the algorithm will be
+# rejected during certification path building and validation.  For example,
+# the assertion algorithm name "DSA" will disable all certificate algorithms
+# that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
+# will not disable algorithms related to "ECDSA".
+#
+# A "Constraint" defines restrictions on the keys and/or certificates for
+# a specified AlgorithmName:
+#
+#   KeySizeConstraint:
+#     keySize Operator KeyLength
+#       The constraint requires a key of a valid size range if the
+#       "AlgorithmName" is of a key algorithm.  The "KeyLength" indicates
+#       the key size specified in number of bits.  For example,
+#       "RSA keySize <= 1024" indicates that any RSA key with key size less
+#       than or equal to 1024 bits should be disabled, and
+#       "RSA keySize < 1024, RSA keySize > 2048" indicates that any RSA key
+#       with key size less than 1024 or greater than 2048 should be disabled.
+#       This constraint is only used on algorithms that have a key size.
+#
+#   CAConstraint:
+#     jdkCA
+#       This constraint prohibits the specified algorithm only if the
+#       algorithm is used in a certificate chain that terminates at a marked
+#       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
+#       constraint is not set, then all chains using the specified algorithm
+#       are restricted.  jdkCA may only be used once in a DisabledAlgorithm
+#       expression.
+#       Example:  To apply this constraint to SHA-1 certificates, include
+#       the following:  "SHA1 jdkCA"
+#
+#   DenyAfterConstraint:
+#     denyAfter YYYY-MM-DD
+#       This constraint prohibits a certificate with the specified algorithm
+#       from being used after the date regardless of the certificate's
+#       validity.  JAR files that are signed and timestamped before the
+#       constraint date with certificates containing the disabled algorithm
+#       will not be restricted.  The date is processed in the UTC timezone.
+#       This constraint can only be used once in a DisabledAlgorithm
+#       expression.
+#       Example:  To deny usage of RSA 2048 bit certificates after Feb 3 2020,
+#       use the following:  "RSA keySize == 2048 & denyAfter 2020-02-03"
+#
+#   UsageConstraint:
+#     usage [TLSServer] [TLSClient] [SignedJAR]
+#       This constraint prohibits the specified algorithm for
+#       a specified usage.  This should be used when disabling an algorithm
+#       for all usages is not practical. 'TLSServer' restricts the algorithm
+#       in TLS server certificate chains when server authentication is
+#       performed. 'TLSClient' restricts the algorithm in TLS client
+#       certificate chains when client authentication is performed.
+#       'SignedJAR' constrains use of certificates in signed jar files.
+#       The usage type follows the keyword and more than one usage type can
+#       be specified with a whitespace delimiter.
+#       Example:  "SHA1 usage TLSServer TLSClient"
+#
+# When an algorithm must satisfy more than one constraint, it must be
+# delimited by an ampersand '&'.  For example, to restrict certificates in a
+# chain that terminate at a distribution provided trust anchor and contain
+# RSA keys that are less than or equal to 1024 bits, add the following
+# constraint:  "RSA keySize <= 1024 & jdkCA".
+#
+# All DisabledAlgorithms expressions are processed in the order defined in the
+# property.  This requires lower keysize constraints to be specified
+# before larger keysize constraints of the same algorithm.  For example:
+# "RSA keySize < 1024 & jdkCA, RSA keySize < 2048".
+#
+# Note: The algorithm restrictions do not apply to trust anchors or
+# self-signed certificates.
+#
+# Note: This property is currently used by Oracle's PKIX implementation. It
+# is not guaranteed to be examined and used by other implementations.
+#
+# Example:
+#   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize < 2048
+#
+#
+jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA & usage TLSServer, \
+    RSA keySize < 1024, DSA keySize < 1024, EC keySize < 224
+
+#
+# Algorithm restrictions for signed JAR files
+#
+# In some environments, certain algorithms or key lengths may be undesirable
+# for signed JAR validation.  For example, "MD2" is generally no longer
+# considered to be a secure hash algorithm.  This section describes the
+# mechanism for disabling algorithms based on algorithm name and/or key length.
+# JARs signed with any of the disabled algorithms or key sizes will be treated
+# as unsigned.
+#
+# The syntax of the disabled algorithm string is described as follows:
+#   DisabledAlgorithms:
+#       " DisabledAlgorithm { , DisabledAlgorithm } "
+#
+#   DisabledAlgorithm:
+#       AlgorithmName [Constraint] { '&' Constraint }
+#
+#   AlgorithmName:
+#       (see below)
+#
+#   Constraint:
+#       KeySizeConstraint | DenyAfterConstraint
+#
+#   KeySizeConstraint:
+#       keySize Operator KeyLength
+#
+#   DenyAfterConstraint:
+#       denyAfter YYYY-MM-DD
+#
+#   Operator:
+#       <= | < | == | != | >= | >
+#
+#   KeyLength:
+#       Integer value of the algorithm's key length in bits
+#
+# Note: This property is currently used by the JDK Reference
+# implementation. It is not guaranteed to be examined and used by other
+# implementations.
+#
+# See "jdk.certpath.disabledAlgorithms" for syntax descriptions.
+#
+jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize < 1024, DSA keySize < 1024
+
+#
+# Algorithm restrictions for Secure Socket Layer/Transport Layer Security
+# (SSL/TLS) processing
+#
+# In some environments, certain algorithms or key lengths may be undesirable
+# when using SSL/TLS.  This section describes the mechanism for disabling
+# algorithms during SSL/TLS security parameters negotiation, including
+# protocol version negotiation, cipher suites selection, peer authentication
+# and key exchange mechanisms.
+#
+# Disabled algorithms will not be negotiated for SSL/TLS connections, even
+# if they are enabled explicitly in an application.
+#
+# For PKI-based peer authentication and key exchange mechanisms, this list
+# of disabled algorithms will also be checked during certification path
+# building and validation, including algorithms used in certificates, as
+# well as revocation information such as CRLs and signed OCSP Responses.
+# This is in addition to the jdk.certpath.disabledAlgorithms property above.
+#
+# See the specification of "jdk.certpath.disabledAlgorithms" for the
+# syntax of the disabled algorithm string.
+#
+# Note: The algorithm restrictions do not apply to trust anchors or
+# self-signed certificates.
+#
+# Note: This property is currently used by the JDK Reference implementation.
+# It is not guaranteed to be examined and used by other implementations.
+#
+# Example:
+#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize < 2048
+jdk.tls.disabledAlgorithms=SSLv3, RC4, MD5withRSA, DH keySize < 1024, \
+    EC keySize < 224, DES40_CBC, RC4_40, 3DES_EDE_CBC
+
+# Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
+# processing in JSSE implementation.
+#
+# In some environments, a certain algorithm may be undesirable but it
+# cannot be disabled because of its use in legacy applications.  Legacy
+# algorithms may still be supported, but applications should not use them
+# as the security strength of legacy algorithms are usually not strong enough
+# in practice.
+#
+# During SSL/TLS security parameters negotiation, legacy algorithms will
+# not be negotiated unless there are no other candidates.
+#
+# The syntax of the legacy algorithms string is described as this Java
+# BNF-style:
+#   LegacyAlgorithms:
+#       " LegacyAlgorithm { , LegacyAlgorithm } "
+#
+#   LegacyAlgorithm:
+#       AlgorithmName (standard JSSE algorithm name)
+#
+# See the specification of security property "jdk.certpath.disabledAlgorithms"
+# for the syntax and description of the "AlgorithmName" notation.
+#
+# Per SSL/TLS specifications, cipher suites have the form:
+#       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
+# or
+#       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
+#
+# For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
+# key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
+# mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
+# algorithm for HMAC.
+#
+# The LegacyAlgorithm can be one of the following standard algorithm names:
+#     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
+#     2. JSSE key exchange algorithm name, e.g., RSA
+#     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
+#     4. JSSE message digest algorithm name, e.g., SHA
+#
+# See SSL/TLS specifications and "Java Cryptography Architecture Standard
+# Algorithm Name Documentation" for information about the algorithm names.
+#
+# Note: This property is currently used by the JDK Reference implementation.
+# It is not guaranteed to be examined and used by other implementations.
+# There is no guarantee the property will continue to exist or be of the
+# same syntax in future releases.
+#
+# Example:
+#   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
+#
+jdk.tls.legacyAlgorithms= \
+        K_NULL, C_NULL, M_NULL, \
+        DH_anon, ECDH_anon, \
+        RC4_128, RC4_40, DES_CBC, DES40_CBC, \
+        3DES_EDE_CBC
+
+# The pre-defined default finite field Diffie-Hellman ephemeral (DHE)
+# parameters for Transport Layer Security (SSL/TLS/DTLS) processing.
+#
+# In traditional SSL/TLS/DTLS connections where finite field DHE parameters
+# negotiation mechanism is not used, the server offers the client group
+# parameters, base generator g and prime modulus p, for DHE key exchange.
+# It is recommended to use dynamic group parameters.  This property defines
+# a mechanism that allows you to specify custom group parameters.
+#
+# The syntax of this property string is described as this Java BNF-style:
+#   DefaultDHEParameters:
+#       DefinedDHEParameters { , DefinedDHEParameters }
+#
+#   DefinedDHEParameters:
+#       "{" DHEPrimeModulus , DHEBaseGenerator "}"
+#
+#   DHEPrimeModulus:
+#       HexadecimalDigits
+#
+#   DHEBaseGenerator:
+#       HexadecimalDigits
+#
+#   HexadecimalDigits:
+#       HexadecimalDigit { HexadecimalDigit }
+#
+#   HexadecimalDigit: one of
+#       0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
+#
+# Whitespace characters are ignored.
+#
+# The "DefinedDHEParameters" defines the custom group parameters, prime
+# modulus p and base generator g, for a particular size of prime modulus p.
+# The "DHEPrimeModulus" defines the hexadecimal prime modulus p, and the
+# "DHEBaseGenerator" defines the hexadecimal base generator g of a group
+# parameter.  It is recommended to use safe primes for the custom group
+# parameters.
+#
+# If this property is not defined or the value is empty, the underlying JSSE
+# provider's default group parameter is used for each connection.
+#
+# If the property value does not follow the grammar, or a particular group
+# parameter is not valid, the connection will fall back and use the
+# underlying JSSE provider's default group parameter.
+#
+# Note: This property is currently used by OpenJDK's JSSE implementation. It
+# is not guaranteed to be examined and used by other implementations.
+#
+# Example:
+#   jdk.tls.server.defaultDHEParameters=
+#       { \
+#       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 \
+#       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD \
+#       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245 \
+#       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED \
+#       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381 \
+#       FFFFFFFF FFFFFFFF, 2}
+
+# Cryptographic Jurisdiction Policy defaults
+#
+# Import and export control rules on cryptographic software vary from
+# country to country.  By default, the JDK provides two different sets of
+# cryptographic policy files:
+#
+#     unlimited:  These policy files contain no restrictions on cryptographic
+#                 strengths or algorithms.
+#
+#     limited:    These policy files contain more restricted cryptographic
+#                 strengths, and are still available if your country or
+#                 usage requires the traditional restrictive policy.
+#
+# The JDK JCE framework uses the unlimited policy files by default.
+# However the user may explicitly choose a set either by defining the
+# "crypto.policy" Security property or by installing valid JCE policy
+# jar files into the traditional JDK installation location.  To better
+# support older JDK Update releases, the "crypto.policy" property is not
+# defined by default.  See below for more information.
+#
+# The following logic determines which policy files are used:
+#
+#         <java-home> refers to the directory where the JRE was
+#         installed and may be determined using the "java.home"
+#         System property.
+#
+# 1.  If the Security property "crypto.policy" has been defined,
+#     then the following mechanism is used:
+#
+#     The policy files are stored as jar files in subdirectories of
+# <java-home>/lib/security/policy.  Each directory contains a complete
+# set of policy files.
+#
+#     The "crypto.policy" Security property controls the directory
+#     selection, and thus the effective cryptographic policy.
+#
+# The default set of directories is:
+#
+#     limited | unlimited
+#
+# 2.  If the "crypto.policy" property is not set and the traditional
+#     US_export_policy.jar and local_policy.jar files
+#     (e.g. limited/unlimited) are found in the legacy
+#     <java-home>/lib/security directory, then the rules embedded within
+#     those jar files will be used. This helps preserve compatibility
+# for users upgrading from an older installation.
+#
+# 3.  If the jar files are not present in the legacy location
+#     and the "crypto.policy" Security property is not defined,
+#     then the JDK will use the unlimited settings (equivalent to
+#     crypto.policy=unlimited)
+#
+# Please see the JCA documentation for additional information on these
+# files and formats.
+#
+# YOU ARE ADVISED TO CONSULT YOUR EXPORT/IMPORT CONTROL COUNSEL OR ATTORNEY
+# TO DETERMINE THE EXACT REQUIREMENTS.
+#
+# Please note that the JCE for Java SE, including the JCE framework,
+# cryptographic policy files, and standard JCE providers provided with
+# the Java SE, have been reviewed and approved for export as mass market
+# encryption item by the US Bureau of Industry and Security.
+#
+# Note: This property is currently used by the JDK Reference implementation.
+# It is not guaranteed to be examined and used by other implementations.
+#
+#crypto.policy=unlimited
+
+#
+# The policy for the XML Signature secure validation mode. The mode is
+# enabled by setting the property "org.jcp.xml.dsig.secureValidation" to
+# true with the javax.xml.crypto.XMLCryptoContext.setProperty() method,
+# or by running the code with a SecurityManager.
+#
+#   Policy:
+#       Constraint {"," Constraint }
+#   Constraint:
+#       AlgConstraint | MaxTransformsConstraint | MaxReferencesConstraint |
+#       ReferenceUriSchemeConstraint | KeySizeConstraint | OtherConstraint
+#   AlgConstraint
+#       "disallowAlg" Uri
+#   MaxTransformsConstraint:
+#       "maxTransforms" Integer
+#   MaxReferencesConstraint:
+#       "maxReferences" Integer
+#   ReferenceUriSchemeConstraint:
+#       "disallowReferenceUriSchemes" String { String }
+#   KeySizeConstraint:
+#       "minKeySize" KeyAlg Integer
+#   OtherConstraint:
+#       "noDuplicateIds" | "noRetrievalMethodLoops"
+#
+# For AlgConstraint, Uri is the algorithm URI String that is not allowed.
+# See the XML Signature Recommendation for more information on algorithm
+# URI Identifiers. For KeySizeConstraint, KeyAlg is the standard algorithm
+# name of the key type (ex: "RSA"). If the MaxTransformsConstraint,
+# MaxReferencesConstraint or KeySizeConstraint (for the same key type) is
+# specified more than once, only the last entry is enforced.
+#
+# Note: This property is currently used by the JDK Reference implementation. It
+# is not guaranteed to be examined and used by other implementations.
+#
+jdk.xml.dsig.secureValidationPolicy=\
+    disallowAlg http://www.w3.org/TR/1999/REC-xslt-19991116,\
+    disallowAlg http://www.w3.org/2001/04/xmldsig-more#rsa-md5,\
+    disallowAlg http://www.w3.org/2001/04/xmldsig-more#hmac-md5,\
+    disallowAlg http://www.w3.org/2001/04/xmldsig-more#md5,\
+    maxTransforms 5,\
+    maxReferences 30,\
+    disallowReferenceUriSchemes file http https,\
+    minKeySize RSA 1024,\
+    minKeySize DSA 1024,\
+    minKeySize EC 224,\
+    noDuplicateIds,\
+    noRetrievalMethodLoops
+
+#
+# Serialization process-wide filter
+#
+# A filter, if configured, is used by java.io.ObjectInputStream during
+# deserialization to check the contents of the stream.
+# A filter is configured as a sequence of patterns, each pattern is either
+# matched against the name of a class in the stream or defines a limit.
+# Patterns are separated by ";" (semicolon).
+# Whitespace is significant and is considered part of the pattern.
+#
+# If the system property jdk.serialFilter is also specified, it supersedes
+# the security property value defined here.
+#
+# If a pattern includes a "=", it sets a limit.
+# If a limit appears more than once the last value is used.
+# Limits are checked before classes regardless of the order in the sequence of patterns.
+# If any of the limits are exceeded, the filter status is REJECTED.
+#
+#   maxdepth=value - the maximum depth of a graph
+#   maxrefs=value  - the maximum number of internal references
+#   maxbytes=value - the maximum number of bytes in the input stream
+#   maxarray=value - the maximum array length allowed
+#
+# Other patterns, from left to right, match the class or package name as
+# returned from Class.getName.
+# If the class is an array type, the class or package to be matched is the element type.
+# Arrays of any number of dimensions are treated the same as the element type.
+# For example, a pattern of "!example.Foo", rejects creation of any instance or
+# array of example.Foo.
+#
+# If the pattern starts with "!", the status is REJECTED if the remaining pattern
+#   is matched; otherwise the status is ALLOWED if the pattern matches.
+# If the pattern ends with ".**" it matches any class in the package and all subpackages.
+# If the pattern ends with ".*" it matches any class in the package.
+# If the pattern ends with "*", it matches any class with the pattern as a prefix.
+# If the pattern is equal to the class name, it matches.
+# Otherwise, the status is UNDECIDED.
+#
+# Primitive types are not configurable with this filter.
+#
+#jdk.serialFilter=pattern;pattern
+
+#
+# RMI Registry Serial Filter
+#
+# The filter pattern uses the same format as jdk.serialFilter.
+# This filter can override the builtin filter if additional types need to be
+# allowed or rejected from the RMI Registry or to decrease limits but not
+# to increase limits.
+# If the limits (maxdepth, maxrefs, or maxbytes) are exceeded, the object is rejected.
+#
+# The maxdepth of any array passed to the RMI Registry is set to
+# 10000.  The maximum depth of the graph is set to 20.
+# These limits can be reduced via the maxarray, maxdepth limits.
+#
+#sun.rmi.registry.registryFilter=pattern;pattern
+
+#
+# Array construction of any component type, including subarrays and arrays of
+# primitives, are allowed unless the length is greater than the maxarray limit.
+# The filter is applied to each array element.
+#
+# The built-in filter allows subclasses of allowed classes and
+# can approximately be represented as the pattern:
+#
+#sun.rmi.registry.registryFilter=\
+#    maxarray=1000000;\
+#    maxdepth=20;\
+#    java.lang.String;\
+#    java.lang.Number;\
+#    java.lang.reflect.Proxy;\
+#    java.rmi.Remote;\
+#    sun.rmi.server.UnicastRef;\
+#    sun.rmi.server.RMIClientSocketFactory;\
+#    sun.rmi.server.RMIServerSocketFactory;\
+#    java.rmi.activation.ActivationID;\
+#    java.rmi.server.UID
+#
+# RMI Distributed Garbage Collector (DGC) Serial Filter
+#
+# The filter pattern uses the same format as jdk.serialFilter.
+# This filter can override the builtin filter if additional types need to be
+# allowed or rejected from the RMI DGC.
+#
+# The builtin DGC filter can approximately be represented as the filter pattern:
+#
+#sun.rmi.transport.dgcFilter=\
+#    java.rmi.server.ObjID;\
+#    java.rmi.server.UID;\
+#    java.rmi.dgc.VMID;\
+#    java.rmi.dgc.Lease;\
+#    maxdepth=5;maxarray=10000
+
+# CORBA ORBIorTypeCheckRegistryFilter
+# Type check enhancement for ORB::string_to_object processing
+#
+# An IOR type check filter, if configured, is used by an ORB during
+# an ORB::string_to_object invocation to check the veracity of the type encoded
+# in the ior string.
+#
+# The filter pattern consists of a semi-colon separated list of class names.
+# The configured list contains the binary class names of the IDL interface types
+# corresponding to the IDL stub class to be instantiated.
+# As such, a filter specifies a list of IDL stub classes that will be
+# allowed by an ORB when an ORB::string_to_object is invoked.
+# It is used to specify a white list configuration of acceptable
+# IDL stub types which may be contained in a stringified IOR
+# parameter passed as input to an ORB::string_to_object method.
+#
+# Note: This property is currently used by the JDK Reference implementation.
+# It is not guaranteed to be examined and used by other implementations.
+#
+#com.sun.CORBA.ORBIorTypeCheckRegistryFilter=binary_class_name;binary_class_name
+
+#
+# JCEKS Encrypted Key Serial Filter
+#
+# This filter, if configured, is used by the JCEKS KeyStore during the
+# deserialization of the encrypted Key object stored inside a key entry.
+# If not configured or the filter result is UNDECIDED (i.e. none of the patterns
+# matches), the filter configured by jdk.serialFilter will be consulted.
+#
+# If the system property jceks.key.serialFilter is also specified, it supersedes
+# the security property value defined here.
+#
+# The filter pattern uses the same format as jdk.serialFilter. The default
+# pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
+# and javax.crypto.spec.SecretKeySpec and rejects all the others.
+jceks.key.serialFilter = java.lang.Enum;java.security.KeyRep;\
+  java.security.KeyRep$Type;javax.crypto.spec.SecretKeySpec;!*
--- ./jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp	Sun Sep 02 07:33:40 2018 -0700
@@ -62,7 +62,7 @@
 
 #endif // End of ZLIB
 
-#ifdef _BIG_ENDIAN
+#ifdef VM_BIG_ENDIAN
 #define SWAP_BYTES(a) \
     ((((a) << 8) & 0xff00) | 0x00ff) & (((a) >> 8) | 0xff00)
 #else
--- ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	Sun Sep 02 07:33:40 2018 -0700
@@ -121,7 +121,7 @@
 }
 
 /* conversion from/to 16 bit signed little endian to native endian samples */
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define MAP_LE_SHORT2SAMPLE(sh) ((MAP_Sample) (sh))
 #define MAP_SAMPLE2LE_SHORT(sample) (sample)
 #define MAP_SAMPLE2LE_SHORT_CLIP(sample) MAP_ClipAndConvertToShort(sample)
@@ -132,7 +132,7 @@
 #endif
 
 /* conversion from/to 16 bit signed big endian to native endian samples */
-#ifndef _LITTLE_ENDIAN
+#ifndef VM_LITTLE_ENDIAN
 #define MAP_BE_SHORT2SAMPLE(sh) ((MAP_Sample) (sh))
 #define MAP_SAMPLE2BE_SHORT(sample) (sample)
 #define MAP_SAMPLE2BE_SHORT_CLIP(sample) MAP_ClipAndConvertToShort(sample)
@@ -151,7 +151,7 @@
 #define MAP_SAMPLE2INT8_CLIP(sample) MAP_ClipAndConvertToByte(sample)
 
 /* macros for endian conversion */
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define MAP_NATIVE2LE16(a) (a)
 #define MAP_NATIVE2BE16(a) MAP_SWAP16_impl(a)
 #define MAP_NATIVE2LE32(a) (a)
--- ./jdk/src/share/native/com/sun/media/sound/Utilities.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/Utilities.c	Sun Sep 02 07:33:40 2018 -0700
@@ -28,7 +28,7 @@
 
 
 int UTIL_IsBigEndianPlatform() {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     return 0;
 #else
     return 1;
--- ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	Sun Sep 02 07:33:40 2018 -0700
@@ -40,7 +40,7 @@
 #endif
 #endif
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define __HI(x) *(1+(int*)&x)
 #define __LO(x) *(int*)&x
 #define __HIp(x) *(1+(int*)x)
--- ./jdk/src/share/native/sun/awt/image/awt_parseImage.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/image/awt_parseImage.c	Sun Sep 02 07:33:40 2018 -0700
@@ -624,7 +624,7 @@
     switch(type) {
         case java_awt_image_BufferedImage_TYPE_INT_ARGB:
         case java_awt_image_BufferedImage_TYPE_INT_ARGB_PRE:
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
             colorOrder[0] = 2;
             colorOrder[1] = 1;
             colorOrder[2] = 0;
@@ -637,7 +637,7 @@
 #endif
             break;
         case java_awt_image_BufferedImage_TYPE_INT_BGR:
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
             colorOrder[0] = 0;
             colorOrder[1] = 1;
             colorOrder[2] = 2;
@@ -648,7 +648,7 @@
 #endif
             break;
         case java_awt_image_BufferedImage_TYPE_INT_RGB:
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
             colorOrder[0] = 2;
             colorOrder[1] = 1;
             colorOrder[2] = 0;
--- ./jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	Sun Sep 02 07:33:40 2018 -0700
@@ -1198,7 +1198,7 @@
 
 #define NLUT 8
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 #define INDEXES    { 3, 2, 1, 0, 7, 6, 5, 4 }
 #else
 #define INDEXES    { 0, 1, 2, 3, 4, 5, 6, 7 }
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	Sun Sep 02 07:33:40 2018 -0700
@@ -86,7 +86,7 @@
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if defined(VM_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* defined(VM_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	Sun Sep 02 07:33:40 2018 -0700
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	Sun Sep 02 07:33:40 2018 -0700
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	Sun Sep 02 07:33:40 2018 -0700
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	Sun Sep 02 07:33:40 2018 -0700
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	Sun Sep 02 07:33:40 2018 -0700
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	Sun Sep 02 07:33:40 2018 -0700
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	Sun Sep 02 07:33:40 2018 -0700
@@ -95,7 +95,7 @@
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	Sun Sep 02 07:33:40 2018 -0700
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -613,7 +613,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -623,12 +623,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -638,7 +638,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -646,7 +646,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -656,12 +656,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -671,7 +671,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -719,7 +719,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -733,14 +733,14 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -754,7 +754,7 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -764,7 +764,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -778,14 +778,14 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -799,7 +799,7 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -852,7 +852,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -862,12 +862,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -877,12 +877,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -892,12 +892,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -907,7 +907,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -915,7 +915,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -925,12 +925,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -940,12 +940,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -955,12 +955,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -970,7 +970,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	Sun Sep 02 07:33:40 2018 -0700
@@ -88,7 +88,7 @@
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	Sun Sep 02 07:33:40 2018 -0700
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	Sun Sep 02 07:33:40 2018 -0700
@@ -275,11 +275,11 @@
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	Sun Sep 02 07:33:40 2018 -0700
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	Sun Sep 02 07:33:40 2018 -0700
@@ -27,9 +27,6 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
-#ifdef MACOSX
-#include <machine/endian.h>
-#endif
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
--- ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	Sun Sep 02 07:33:40 2018 -0700
@@ -29,7 +29,7 @@
 #ifdef MACOSX
 #include <unistd.h>
 #include <sys/param.h>
-#else
+#elif !defined(_ALLBSD_SOURCE)
 #include <malloc.h>
 #endif
 #include <mlib_types.h>
@@ -97,6 +97,9 @@
   return (void *) malloc(size);
 #elif defined(MACOSX)
   return valloc(size);
+#elif defined(_ALLBSD_SOURCE)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
 #else
   return (void *) memalign(8, size);
 #endif /* _MSC_VER */
--- ./jdk/src/share/native/sun/font/layout/LEStandalone.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/font/layout/LEStandalone.h	Sun Sep 02 07:33:40 2018 -0700
@@ -136,7 +136,7 @@
 #define U_CAPI extern "C"
 
 #if !defined(U_IS_BIG_ENDIAN)
-    #ifdef _LITTLE_ENDIAN
+    #ifdef VM_LITTLE_ENDIAN
         #define U_IS_BIG_ENDIAN 0
     #endif
 #endif
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/LCMS.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/LCMS.c	Sun Sep 02 07:33:40 2018 -0700
@@ -182,7 +182,7 @@
         return 0L;
     }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     /* Reversing data packed into int for LE archs */
     if (isInIntPacked) {
         inFormatter ^= DOSWAP_SH(1);
--- ./jdk/src/share/native/sun/management/DiagnosticCommandImpl.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/share/native/sun/management/DiagnosticCommandImpl.c	Sun Sep 02 07:33:40 2018 -0700
@@ -27,6 +27,7 @@
 #include <jni.h>
 #include "management.h"
 #include "sun_management_DiagnosticCommandImpl.h"
+#include <stdlib.h>
 
 JNIEXPORT void JNICALL Java_sun_management_DiagnosticCommandImpl_setNotificationEnabled
 (JNIEnv *env, jobject dummy, jboolean enabled) {
--- ./jdk/src/solaris/back/util_md.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/back/util_md.h	Sun Sep 02 07:33:40 2018 -0700
@@ -51,7 +51,7 @@
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if defined(VM_LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
--- ./jdk/src/solaris/bin/ergo_i586.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/bin/ergo_i586.c	Sun Sep 02 07:33:40 2018 -0700
@@ -106,7 +106,7 @@
 
 #endif /* __solaris__ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -197,7 +197,7 @@
            (result == JNI_TRUE ? "true" : "false"));
   return result;
 }
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 /*
  * Routines shared by solaris-i586 and linux-i586.
--- ./jdk/src/solaris/bin/java_md_solinux.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/bin/java_md_solinux.c	Sun Sep 02 07:33:40 2018 -0700
@@ -35,6 +35,9 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifdef __FreeBSD__
+#include <sys/sysctl.h>
+#endif
 #include "manifest_info.h"
 #include "version_comp.h"
 
@@ -306,9 +309,9 @@
     if (llp == NULL && dmllp == NULL) {
         return JNI_FALSE;
     }
-#ifdef __linux
+#ifndef __solaris__
     /*
-     * On linux, if a binary is running as sgid or suid, glibc sets
+     * On linux and BSD, if a binary is running as sgid or suid, glibc/libc sets
      * LD_LIBRARY_PATH to the empty string for security purposes. (In contrast,
      * on Solaris the LD_LIBRARY_PATH variable for a privileged binary does not
      * lose its settings; but the dynamic linker does apply more scrutiny to the
@@ -319,12 +322,18 @@
      * libraries will be handled by the RPATH. In reality, this check is
      * redundant, as the previous check for a non-null LD_LIBRARY_PATH will
      * return back to the calling function forthwith, it is left here to safe
-     * guard against any changes, in the glibc's existing security policy.
+     * guard against any changes, in the glibc/libc's existing security policy.
      */
+#ifndef _ALLBSD_SOURCE
     if ((getgid() != getegid()) || (getuid() != geteuid())) {
         return JNI_FALSE;
     }
-#endif /* __linux */
+#else
+    if (issetugid()) {
+        return JNI_FALSE;
+    }
+#endif /* ! _ALLBSD_SOURCE */
+#endif /* ! __solaris__ */
 
     /*
      * Prevent recursions. Since LD_LIBRARY_PATH is the one which will be set by
@@ -929,8 +938,9 @@
  * onwards the filename returned in DL_info structure from dladdr is
  * an absolute pathname so technically realpath isn't required.
  * On Linux we read the executable name from /proc/self/exe.
- * As a fallback, and for platforms other than Solaris and Linux,
- * we use FindExecName to compute the executable name.
+ * On FreeBSD, we get the executable name via sysctl(3).
+ * As a fallback, and for platforms other than Solaris, Linux, and
+ * FreeBSD, we use FindExecName to compute the executable name.
  */
 const char*
 SetExecname(char **argv)
@@ -967,7 +977,17 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__solaris__ && !__linux__ */
+#elif defined(__FreeBSD__)
+    {
+        char buf[PATH_MAX+1];
+        int name[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+        size_t len = sizeof(buf);
+        if (sysctl(name, 4, buf, &len, NULL, 0) == 0 && len > 0) {
+            buf[len] = '\0';
+            exec_path = JLI_StringDup(buf);
+        }
+    }
+#else /* !__solaris__ && !__linux__ && !__FreeBSD__ */
     {
         /* Not implemented */
     }
@@ -1073,13 +1093,13 @@
 #define MAX_PID_STR_SZ   20
 
 void SetJavaLauncherPlatformProps() {
-   /* Linux only */
-#ifdef __linux__
+   /* Linux and BSD only */
+#ifndef __solaris__
     const char *substr = "-Dsun.java.launcher.pid=";
     char *pid_prop_str = (char *)JLI_MemAlloc(JLI_StrLen(substr) + MAX_PID_STR_SZ + 1);
     sprintf(pid_prop_str, "%s%d", substr, getpid());
     AddOption(pid_prop_str, NULL);
-#endif /* __linux__ */
+#endif /* ! __solaris__ */
 }
 
 int
--- ./jdk/src/solaris/bin/java_md_solinux.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/bin/java_md_solinux.h	Sun Sep 02 07:33:40 2018 -0700
@@ -26,17 +26,26 @@
 #ifndef JAVA_MD_SOLINUX_H
 #define JAVA_MD_SOLINUX_H
 
-#ifdef HAVE_GETHRTIME
+#if defined(HAVE_GETHRTIME) || defined(__FreeBSD__)
 /*
  * Support for doing cheap, accurate interval timing.
  */
+#ifdef HAVE_GETHRTIME
 #include <sys/time.h>
+#else /* __FreeBSD__ */
+#include <time.h>
+#define gethrtime() __extension__ ({ \
+    struct timespec tp; \
+    clock_gettime(CLOCK_MONOTONIC, &tp); \
+    (uint64_t)tp.tv_sec*1000000 + tp.tv_nsec/1000; \
+})
+#endif /* HAVE_GETHRTIME */
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
-#else  /* ! HAVE_GETHRTIME */
+#else /* ! HAVE_GETHRTIME && ! __FreeBSD__ */
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
-#endif /* HAVE_GETHRTIME */
+#endif /* HAVE_GETHRTIME || __FreeBSD__ */
 
 /* pointer to environment */
 extern char **environ;
@@ -48,6 +57,9 @@
 #ifdef __solaris__
 static const char *system_dir   = "/usr/jdk";
 static const char *user_dir     = "/jdk";
+#elif defined(__FreeBSD__)
+static const char *system_dir  = PACKAGE_PATH "/openjdk8";
+static const char *user_dir    = "/java";
 #else /* !__solaris__, i.e. Linux, AIX,.. */
 static const char *system_dir   = "/usr/java";
 static const char *user_dir     = "/java";
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java	Sun Sep 02 07:33:40 2018 -0700
@@ -82,6 +82,8 @@
 
         LINUX(LaunchMechanism.VFORK, LaunchMechanism.FORK),
 
+        MACOS(LaunchMechanism.POSIX_SPAWN, LaunchMechanism.FORK),
+
         BSD(LaunchMechanism.POSIX_SPAWN, LaunchMechanism.FORK),
 
         SOLARIS(LaunchMechanism.POSIX_SPAWN, LaunchMechanism.FORK),
@@ -105,9 +107,10 @@
                     // fall through...
                 case LINUX:
                 case AIX:
+                case BSD:
                     return javahome + "/lib/" + osArch + "/jspawnhelper";
 
-                case BSD:
+                case MACOS:
                     return javahome + "/lib/jspawnhelper";
 
                 default:
@@ -157,7 +160,8 @@
             );
 
             if (osName.equals("Linux")) { return LINUX; }
-            if (osName.contains("OS X")) { return BSD; }
+            if (osName.contains("OS X")) { return MACOS; }
+            if (osName.endsWith("BSD")) { return BSD; }
             if (osName.equals("SunOS")) { return SOLARIS; }
             if (osName.equals("AIX")) { return AIX; }
 
@@ -272,6 +276,7 @@
     void initStreams(int[] fds) throws IOException {
         switch (platform) {
             case LINUX:
+            case MACOS:
             case BSD:
                 stdin = (fds[0] == -1) ?
                         ProcessBuilder.NullOutputStream.INSTANCE :
@@ -430,6 +435,7 @@
     private void destroy(boolean force) {
         switch (platform) {
             case LINUX:
+            case MACOS:
             case BSD:
             case AIX:
                 // There is a risk that pid will be recycled, causing us to
--- ./jdk/src/solaris/classes/sun/awt/X11FontManager.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11FontManager.java	Sun Sep 02 07:33:40 2018 -0700
@@ -234,7 +234,7 @@
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && FontUtilities.isLinux && !isOpenJDK()) {
+            if (fileName == null && (FontUtilities.isLinux || FontUtilities.isBSD) && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -733,7 +733,7 @@
         if (fontConfigDirs == null) {
             return;
         }
-        if (FontUtilities.isLinux) {
+        if (FontUtilities.isLinux || FontUtilities.isBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
@@ -761,7 +761,7 @@
          */
         FontConfiguration mFontConfig = new MFontConfiguration(this);
         if (FontUtilities.isOpenSolaris ||
-            (FontUtilities.isLinux &&
+            ((FontUtilities.isLinux || FontUtilities.isBSD) &&
              (!mFontConfig.foundOsSpecificFile() ||
               !mFontConfig.fontFilesArePresent()) ||
              (FontUtilities.isSolaris && !mFontConfig.fontFilesArePresent()))) {
--- ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.properties	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.properties	Sun Sep 02 07:33:40 2018 -0700
@@ -26,134 +26,134 @@
 
 # Version
 
-# Uses Fedora Core 6 fonts and file paths.
+# Uses FreeBSD ports Tree fonts and file paths.
 version=1
 
 # Component Font Mappings
 
-dialog.plain.latin-1=DejaVu LGC Sans
+dialog.plain.latin-1=DejaVu Sans
 dialog.plain.japanese-x0208=Sazanami Gothic
-dialog.plain.korean=Baekmuk Gulim
-dialog.plain.chinese-big5=AR PL ShanHeiSun Uni
-dialog.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.plain.korean=NanumGothic
+dialog.plain.chinese-big5=AR PL UMing
+dialog.plain.chinese-gb18030=AR PL UMing
 
-dialog.bold.latin-1=DejaVu LGC Sans Bold
+dialog.bold.latin-1=DejaVu Sans Bold
 dialog.bold.japanese-x0208=Sazanami Gothic
-dialog.bold.korean=Baekmuk Gulim
-dialog.bold.chinese-big5=AR PL ShanHeiSun Uni
-dialog.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.bold.korean=NanumGothic Bold
+dialog.bold.chinese-big5=AR PL UMing
+dialog.bold.chinese-gb18030=AR PL UMing
 
-dialog.italic.latin-1=DejaVu LGC Sans Oblique
+dialog.italic.latin-1=DejaVu Sans Oblique
 dialog.italic.japanese-x0208=Sazanami Gothic
-dialog.italic.korean=Baekmuk Gulim
-dialog.italic.chinese-big5=AR PL ShanHeiSun Uni
-dialog.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.italic.korean=NanumGothic
+dialog.italic.chinese-big5=AR PL UMing
+dialog.italic.chinese-gb18030=AR PL UMing
 
-dialog.bolditalic.latin-1=DejaVu LGC Sans Bold Oblique
+dialog.bolditalic.latin-1=DejaVu Sans Bold Oblique
 dialog.bolditalic.japanese-x0208=Sazanami Gothic
-dialog.bolditalic.korean=Baekmuk Gulim
-dialog.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-dialog.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialog.bolditalic.korean=NanumGothic Bold
+dialog.bolditalic.chinese-big5=AR PL UMing
+dialog.bolditalic.chinese-gb18030=AR PL UMing
 
 
-sansserif.plain.latin-1=DejaVu LGC Sans
+sansserif.plain.latin-1=DejaVu Sans
 sansserif.plain.japanese-x0208=Sazanami Gothic
-sansserif.plain.korean=Baekmuk Gulim
-sansserif.plain.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.plain.korean=NanumGothic
+sansserif.plain.chinese-big5=AR PL UMing
+sansserif.plain.chinese-gb18030=AR PL UMing
 
-sansserif.bold.latin-1=DejaVu LGC Sans Bold
+sansserif.bold.latin-1=DejaVu Sans Bold
 sansserif.bold.japanese-x0208=Sazanami Gothic
-sansserif.bold.korean=Baekmuk Gulim
-sansserif.bold.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.bold.korean=NanumGothic Bold
+sansserif.bold.chinese-big5=AR PL UMing
+sansserif.bold.chinese-gb18030=AR PL UMing
 
-sansserif.italic.latin-1=DejaVu LGC Sans Oblique
+sansserif.italic.latin-1=DejaVu Sans Oblique
 sansserif.italic.japanese-x0208=Sazanami Gothic
-sansserif.italic.korean=Baekmuk Gulim
-sansserif.italic.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.italic.korean=NanumGothic
+sansserif.italic.chinese-big5=AR PL UMing
+sansserif.italic.chinese-gb18030=AR PL UMing
 
-sansserif.bolditalic.latin-1=DejaVu LGC Sans Bold Oblique
+sansserif.bolditalic.latin-1=DejaVu Sans Bold Oblique
 sansserif.bolditalic.japanese-x0208=Sazanami Gothic
-sansserif.bolditalic.korean=Baekmuk Gulim
-sansserif.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+sansserif.bolditalic.korean=NanumGothic Bold
+sansserif.bolditalic.chinese-big5=AR PL UMing
+sansserif.bolditalic.chinese-gb18030=AR PL UMing
 
 
-serif.plain.latin-1=DejaVu LGC Serif
+serif.plain.latin-1=DejaVu Serif
 serif.plain.japanese-x0208=Sazanami Mincho
-serif.plain.korean=Baekmuk Batang
-serif.plain.chinese-big5=AR PL ZenKai Uni
-serif.plain.chinese-gb18030=AR PL ZenKai Uni
+serif.plain.korean=NanumMyeongjo
+serif.plain.chinese-big5=AR PL UKai
+serif.plain.chinese-gb18030=AR PL UKai
 
-serif.bold.latin-1=DejaVu LGC Serif Bold
+serif.bold.latin-1=DejaVu Serif Bold
 serif.bold.japanese-x0208=Sazanami Mincho
-serif.bold.korean=Baekmuk Batang
-serif.bold.chinese-big5=AR PL ZenKai Uni
-serif.bold.chinese-gb18030=AR PL ZenKai Uni
+serif.bold.korean=NanumMyeongjo Bold
+serif.bold.chinese-big5=AR PL UKai
+serif.bold.chinese-gb18030=AR PL UKai
 
-serif.italic.latin-1=DejaVu LGC Serif Oblique
+serif.italic.latin-1=DejaVu Serif Italic
 serif.italic.japanese-x0208=Sazanami Mincho
-serif.italic.korean=Baekmuk Batang
-serif.italic.chinese-big5=AR PL ZenKai Uni
-serif.italic.chinese-gb18030=AR PL ZenKai Uni
+serif.italic.korean=NanumMyeongjo
+serif.italic.chinese-big5=AR PL UKai
+serif.italic.chinese-gb18030=AR PL UKai
 
-serif.bolditalic.latin-1=DejaVu LGC Serif Bold Oblique
+serif.bolditalic.latin-1=DejaVu Serif Bold Italic
 serif.bolditalic.japanese-x0208=Sazanami Mincho
-serif.bolditalic.korean=Baekmuk Batang
-serif.bolditalic.chinese-big5=AR PL ZenKai Uni
-serif.bolditalic.chinese-gb18030=AR PL ZenKai Uni
+serif.bolditalic.korean=NanumMyeongjo Bold
+serif.bolditalic.chinese-big5=AR PL UKai
+serif.bolditalic.chinese-gb18030=AR PL UKai
 
 
-monospaced.plain.latin-1=DejaVu LGC Sans Mono
+monospaced.plain.latin-1=DejaVu Sans Mono
 monospaced.plain.japanese-x0208=Sazanami Gothic
-monospaced.plain.korean=Baekmuk Gulim
-monospaced.plain.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.plain.korean=NanumGothic
+monospaced.plain.chinese-big5=AR PL UMing
+monospaced.plain.chinese-gb18030=AR PL UMing
 
-monospaced.bold.latin-1=DejaVu LGC Sans Mono Bold
+monospaced.bold.latin-1=DejaVu Sans Mono Bold
 monospaced.bold.japanese-x0208=Sazanami Gothic
-monospaced.bold.korean=Baekmuk Gulim
-monospaced.bold.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.bold.korean=NanumGothic Bold
+monospaced.bold.chinese-big5=AR PL UMing
+monospaced.bold.chinese-gb18030=AR PL UMing
 
-monospaced.italic.latin-1=DejaVu LGC Sans Mono Oblique
+monospaced.italic.latin-1=DejaVu Sans Mono Oblique
 monospaced.italic.japanese-x0208=Sazanami Gothic
-monospaced.italic.korean=Baekmuk Gulim
-monospaced.italic.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.italic.korean=NanumGothic
+monospaced.italic.chinese-big5=AR PL UMing
+monospaced.italic.chinese-gb18030=AR PL UMing
 
-monospaced.bolditalic.latin-1=DejaVu LGC Sans Mono Bold Oblique
+monospaced.bolditalic.latin-1=DejaVu Sans Mono Bold Oblique
 monospaced.bolditalic.japanese-x0208=Sazanami Gothic
-monospaced.bolditalic.korean=Baekmuk Gulim
-monospaced.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+monospaced.bolditalic.korean=NanumGothic Bold
+monospaced.bolditalic.chinese-big5=AR PL UMing
+monospaced.bolditalic.chinese-gb18030=AR PL UMing
 
 
-dialoginput.plain.latin-1=DejaVu LGC Sans Mono
+dialoginput.plain.latin-1=DejaVu Sans Mono
 dialoginput.plain.japanese-x0208=Sazanami Gothic
-dialoginput.plain.korean=Baekmuk Gulim
-dialoginput.plain.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.plain.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.plain.korean=NanumGothic
+dialoginput.plain.chinese-big5=AR PL UMing
+dialoginput.plain.chinese-gb18030=AR PL UMing
 
-dialoginput.bold.latin-1=DejaVu LGC Sans Mono Bold
+dialoginput.bold.latin-1=DejaVu Sans Mono Bold
 dialoginput.bold.japanese-x0208=Sazanami Gothic
-dialoginput.bold.korean=Baekmuk Gulim
-dialoginput.bold.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.bold.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.bold.korean=NanumGothic Bold
+dialoginput.bold.chinese-big5=AR PL UMing
+dialoginput.bold.chinese-gb18030=AR PL UMing
 
-dialoginput.italic.latin-1=DejaVu LGC Sans Mono Oblique
+dialoginput.italic.latin-1=DejaVu Sans Mono Oblique
 dialoginput.italic.japanese-x0208=Sazanami Gothic
-dialoginput.italic.korean=Baekmuk Gulim
-dialoginput.italic.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.italic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.italic.korean=NanumGothic
+dialoginput.italic.chinese-big5=AR PL UMing
+dialoginput.italic.chinese-gb18030=AR PL UMing
 
-dialoginput.bolditalic.latin-1=DejaVu LGC Sans Mono Bold Oblique
+dialoginput.bolditalic.latin-1=DejaVu Sans Mono Bold Oblique
 dialoginput.bolditalic.japanese-x0208=Sazanami Gothic
-dialoginput.bolditalic.korean=Baekmuk Gulim
-dialoginput.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
+dialoginput.bolditalic.korean=NanumGothic Bold
+dialoginput.bolditalic.chinese-big5=AR PL UMing
+dialoginput.bolditalic.chinese-gb18030=AR PL UMing
 
 # Search Sequences
 
@@ -166,24 +166,27 @@
 
 # Font File Names
 
-filename.DejaVu_LGC_Sans=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans.ttf
-filename.DejaVu_LGC_Sans_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-Bold.ttf
-filename.DejaVu_LGC_Sans_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-Oblique.ttf
-filename.DejaVu_LGC_Sans_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-BoldOblique.ttf
+## FIXME: Should not hardcode /usr/local
+filename.DejaVu_Sans=/usr/local/lib/X11/fonts/dejavu/DejaVuSans.ttf
+filename.DejaVu_Sans_Bold=/usr/local/lib/X11/fonts/dejavu/DejaVuSans-Bold.ttf
+filename.DejaVu_Sans_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSans-Oblique.ttf
+filename.DejaVu_Sans_Bold_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSans-BoldOblique.ttf
 
-filename.DejaVu_LGC_Sans_Mono=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono.ttf
-filename.DejaVu_LGC_Sans_Mono_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-Bold.ttf
-filename.DejaVu_LGC_Sans_Mono_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-Oblique.ttf
-filename.DejaVu_LGC_Sans_Mono_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-BoldOblique.ttf
+filename.DejaVu_Sans_Mono=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono.ttf
+filename.DejaVu_Sans_Mono_Bold=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono-Bold.ttf
+filename.DejaVu_Sans_Mono_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono-Oblique.ttf
+filename.DejaVu_Sans_Mono_Bold_Oblique=/usr/local/lib/X11/fonts/dejavu/DejaVuSansMono-BoldOblique.ttf
 
-filename.DejaVu_LGC_Serif=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif.ttf
-filename.DejaVu_LGC_Serif_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-Bold.ttf
-filename.DejaVu_LGC_Serif_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-Oblique.ttf
-filename.DejaVu_LGC_Serif_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-BoldOblique.ttf
+filename.DejaVu_Serif=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif.ttf
+filename.DejaVu_Serif_Bold=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif-Bold.ttf
+filename.DejaVu_Serif_Italic=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif-Italic.ttf
+filename.DejaVu_Serif_Bold_Italic=/usr/local/lib/X11/fonts/dejavu/DejaVuSerif-BoldItalic.ttf
 
-filename.Sazanami_Gothic=/usr/share/fonts/japanese/TrueType/sazanami-gothic.ttf
-filename.Sazanami_Mincho=/usr/share/fonts/japanese/TrueType/sazanami-mincho.ttf
-filename.AR_PL_ShanHeiSun_Uni=/usr/share/fonts/chinese/TrueType/uming.ttf
-filename.AR_PL_ZenKai_Uni=/usr/share/fonts/chinese/TrueType/ukai.ttf
-filename.Baekmuk_Gulim=/usr/share/fonts/korean/TrueType/gulim.ttf
-filename.Baekmuk_Batang=/usr/share/fonts/korean/TrueType/batang.ttf
+filename.Sazanami_Gothic=/usr/local/share/font-sazanami/sazanami-gothic.ttf
+filename.Sazanami_Mincho=/usr/local/share/font-sazanami/sazanami-mincho.ttf
+filename.AR_PL_ShanHeiSun_Uni=/usr/local/share/fonts/TrueType/uming.ttc
+filename.AR_PL_ZenKai_Uni=/usr/local/share/fonts/TrueType/ukai.ttc
+filename.NanumGothic=/usr/local/lib/X11/fonts/nanum-ttf/NanumGothic.ttf
+filename.NanumGothic_Bold=/usr/local/lib/X11/fonts/nanum-ttf/NanumGothicBold.ttf
+filename.NanumMyeongjo=/usr/local/lib/X11/fonts/nanum-ttf/NanumMyeongjo.ttf
+filename.NanumMyeongjo_Bold=/usr/local/lib/X11/fonts/nanum-ttf/NanumMyeongjoBold.ttf
--- ./jdk/src/solaris/classes/sun/net/PortConfig.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/net/PortConfig.java	Sun Sep 02 07:33:40 2018 -0700
@@ -52,7 +52,7 @@
                     } else if (os.startsWith("SunOS")) {
                         defaultLower = 32768;
                         defaultUpper = 65535;
-                    } else if (os.contains("OS X")) {
+                    } else if (os.endsWith("BSD") || os.contains("OS X")) {
                         defaultLower = 49152;
                         defaultUpper = 65535;
                     } else if (os.startsWith("AIX")) {
--- ./jdk/src/solaris/classes/sun/nio/ch/DefaultAsynchronousChannelProvider.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/nio/ch/DefaultAsynchronousChannelProvider.java	Sun Sep 02 07:33:40 2018 -0700
@@ -66,7 +66,7 @@
             return createProvider("sun.nio.ch.SolarisAsynchronousChannelProvider");
         if (osname.equals("Linux"))
             return createProvider("sun.nio.ch.LinuxAsynchronousChannelProvider");
-        if (osname.contains("OS X"))
+        if (osname.endsWith("BSD") || osname.contains("OS X"))
             return createProvider("sun.nio.ch.BsdAsynchronousChannelProvider");
         if (osname.equals("AIX"))
             return createProvider("sun.nio.ch.AixAsynchronousChannelProvider");
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdFileSystemProvider.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdFileSystemProvider.java	Sun Sep 02 07:33:40 2018 -0700
@@ -25,10 +25,14 @@
 
 package sun.nio.fs;
 
+import java.nio.file.*;
+import java.nio.file.spi.FileTypeDetector;
 import java.io.IOException;
+import java.security.AccessController;
+import sun.security.action.GetPropertyAction;
 
 /**
- * Bsd implementation of FileSystemProvider
+ * BSD implementation of FileSystemProvider
  */
 
 public class BsdFileSystemProvider extends UnixFileSystemProvider {
@@ -45,4 +49,16 @@
     BsdFileStore getFileStore(UnixPath path) throws IOException {
         return new BsdFileStore(path);
     }
+
+    @Override
+    FileTypeDetector getFileTypeDetector() {
+        Path userMimeTypes = Paths.get(AccessController.doPrivileged(
+            new GetPropertyAction("user.home")), ".mime.types");
+        Path etcMimeTypes = Paths.get("/etc/mime.types");
+
+        return chain(new GnomeFileTypeDetector(),
+                     new MimeTypesFileTypeDetector(userMimeTypes),
+                     new MimeTypesFileTypeDetector(etcMimeTypes),
+                     new MagicFileTypeDetector());
+    }
 }
--- ./jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	Sun Sep 02 07:33:40 2018 -0700
@@ -61,6 +61,8 @@
             return createProvider("sun.nio.fs.SolarisFileSystemProvider");
         if (osname.equals("Linux"))
             return createProvider("sun.nio.fs.LinuxFileSystemProvider");
+        if (osname.endsWith("BSD"))
+            return createProvider("sun.nio.fs.BsdFileSystemProvider");
         if (osname.contains("OS X"))
             return createProvider("sun.nio.fs.MacOSXFileSystemProvider");
         if (osname.equals("AIX"))
--- ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	Sun Sep 02 07:33:40 2018 -0700
@@ -161,6 +161,7 @@
 
     static boolean isBSD() {
         return (osname.equals("Linux") ||
+                osname.endsWith("BSD") ||
                 osname.contains("OS X"));
     }
 
@@ -175,12 +176,12 @@
     static int cmdIndex = UNINITIALIZED;
 
     String[] lpcFirstCom = {
-        "/usr/sbin/lpc status | grep : | sed -ne '1,1 s/://p'",
+        "/usr/sbin/lpc status all | grep ':$' | sed -ne '1,1 s/://p'",
         "/usr/sbin/lpc status | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}'"
     };
 
     String[] lpcAllCom = {
-        "/usr/sbin/lpc status all | grep : | sed -e 's/://'",
+        "/usr/sbin/lpc status all | grep ':$' | sed -e 's/://'",
         "/usr/sbin/lpc status all | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}' | sort"
     };
 
--- ./jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java	Sun Sep 02 07:33:40 2018 -0700
@@ -273,7 +273,7 @@
             try {
                 b = s.getBytes("UTF-8");
             } catch (java.io.UnsupportedEncodingException x) {
-                throw new InternalError();
+                throw new InternalError(x);
             }
             BsdVirtualMachine.write(fd, b, 0, b.length);
         }
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_LinuxOS_ALSA_PCM.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_LinuxOS_ALSA_PCM.c	Sun Sep 02 07:33:40 2018 -0700
@@ -675,6 +675,7 @@
             return -1;
         }
         return 1;
+#ifdef ESTRPIPE
     } else if (err == -ESTRPIPE) {
         TRACE0("xrun_recovery: suspended.\n");
         ret = snd_pcm_resume(info->handle);
@@ -690,6 +691,7 @@
             return -1;
         }
         return 1;
+#endif
     } else if (err == -EAGAIN) {
         TRACE0("xrun_recovery: EAGAIN try again flag.\n");
         return 0;
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_PCM.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_PCM.c	Sun Sep 02 07:33:40 2018 -0700
@@ -140,7 +140,7 @@
                                       (float) ((int) sr->samp_rates[s]),
                                       DAUDIO_PCM, /* encoding - let's only do PCM */
                                       (bits[b] > 8)?TRUE:TRUE, /* isSigned */
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
                                       FALSE /* little endian */
 #else
                                       (bits[b] > 8)?TRUE:FALSE  /* big endian */
--- ./jdk/src/solaris/native/common/jni_util_md.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/common/jni_util_md.c	Sun Sep 02 07:33:40 2018 -0700
@@ -28,6 +28,7 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "dlfcn.h"
+#include <string.h>
 
 jstring nativeNewStringPlatform(JNIEnv *env, const char *str) {
     return NULL;
--- ./jdk/src/solaris/native/java/lang/java_props_md.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/lang/java_props_md.c	Sun Sep 02 07:33:40 2018 -0700
@@ -111,7 +111,7 @@
     lc = setlocale(cat, NULL);
 #endif
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__FreeBSD__)
     if (lc == NULL) {
         return 0;
     }
@@ -528,23 +528,11 @@
     sprops.sun_jnu_encoding = sprops.encoding;
 #endif
 
-#ifdef _ALLBSD_SOURCE
-#if BYTE_ORDER == _LITTLE_ENDIAN
-     sprops.unicode_encoding = "UnicodeLittle";
- #else
-     sprops.unicode_encoding = "UnicodeBig";
- #endif
-#else /* !_ALLBSD_SOURCE */
-#ifdef __linux__
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
     sprops.unicode_encoding = "UnicodeLittle";
 #else
     sprops.unicode_encoding = "UnicodeBig";
 #endif
-#else
-    sprops.unicode_encoding = "UnicodeBig";
-#endif
-#endif /* _ALLBSD_SOURCE */
 
     /* user properties */
     {
--- ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	Sun Sep 02 07:33:40 2018 -0700
@@ -36,20 +36,13 @@
 #include <stdlib.h>
 #include <ctype.h>
 
-#ifdef _ALLBSD_SOURCE
-#include <unistd.h>
-#include <sys/param.h>
-#endif
-
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
 
 #include "java_net_Inet4AddressImpl.h"
 
-#if defined(__GLIBC__) || (defined(__FreeBSD__) && (__FreeBSD_version >= 601104))
-#define HAS_GLIBC_GETHOSTBY_R   1
-#endif
+extern jobjectArray lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6);
 
 
 #if defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R)
@@ -417,6 +410,17 @@
     }
 #endif
 
+#ifdef _ALLBSD_SOURCE
+    /* If we're looking up the local machine, bypass DNS lookups and get
+     * address from getifaddrs.
+     */
+    ret = lookupIfLocalhost(env, hostname, JNI_FALSE);
+    if (ret != NULL || (*env)->ExceptionCheck(env)) {
+        JNU_ReleaseStringPlatformChars(env, host, hostname);
+        return ret;
+    }
+#endif
+
     error = getaddrinfo(hostname, NULL, &hints, &res);
 
     if (error) {
--- ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	Sun Sep 02 07:33:40 2018 -0700
@@ -33,7 +33,7 @@
 #include <strings.h>
 #include <stdlib.h>
 #include <ctype.h>
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #include <ifaddrs.h>
 #include <net/if.h>
 #include <unistd.h> /* gethostname */
@@ -112,9 +112,9 @@
     return (*env)->NewStringUTF(env, hostname);
 }
 
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 /* also called from Inet4AddressImpl.c */
-__private_extern__ jobjectArray
+jobjectArray
 lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6)
 {
     jobjectArray result = NULL;
@@ -269,6 +269,19 @@
     hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);
     CHECK_NULL_RETURN(hostname, NULL);
 
+#ifdef _ALLBSD_SOURCE
+    /*
+     * If we're looking up the local machine, attempt to get the address
+     * from getifaddrs. This ensures we get an IPv6 address for the local
+     * machine.
+     */
+    ret = lookupIfLocalhost(env, hostname, JNI_TRUE);
+    if (ret != NULL || (*env)->ExceptionCheck(env)) {
+        JNU_ReleaseStringPlatformChars(env, host, hostname);
+        return ret;
+    }
+#endif
+
 #ifdef AF_INET6
     /* Try once, with our static buffer. */
     memset(&hints, 0, sizeof(hints));
--- ./jdk/src/solaris/native/java/net/NetworkInterface.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/NetworkInterface.c	Sun Sep 02 07:33:40 2018 -0700
@@ -58,14 +58,19 @@
 #include <sys/param.h>
 #include <sys/ioctl.h>
 #include <sys/sockio.h>
-#if defined(__APPLE__)
+#if defined(__APPLE__) || defined(__FreeBSD__)
 #include <net/ethernet.h>
 #include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#include <netinet6/in6_var.h>
+#elif defined(__NetBSD__)
+#include <net/if_ether.h>
+#endif
 #include <net/if_dl.h>
 #include <netinet/in_var.h>
 #include <ifaddrs.h>
 #endif
-#endif
 
 #include "jvm.h"
 #include "jni_util.h"
--- ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	Sun Sep 02 07:33:40 2018 -0700
@@ -2243,7 +2243,7 @@
                 }
             }
 #endif
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
             if (family == AF_INET6 && index == 0) {
                 index = getDefaultScopeID(env);
             }
--- ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	Sun Sep 02 07:33:40 2018 -0700
@@ -215,6 +215,7 @@
     }
 
 #ifdef AF_INET6
+#ifndef __OpenBSD__
     /* Disable IPV6_V6ONLY to ensure dual-socket support */
     if (domain == AF_INET6) {
         int arg = 0;
@@ -225,6 +226,7 @@
             return;
         }
     }
+#endif /* ! __OpenBSD__ */
 #endif /* AF_INET6 */
 
     /*
--- ./jdk/src/solaris/native/java/net/bsd_close.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/bsd_close.c	Sun Sep 02 07:33:40 2018 -0700
@@ -320,11 +320,8 @@
 }
 
 int NET_Accept(int s, struct sockaddr *addr, int *addrlen) {
-    socklen_t len = *addrlen;
-    int error = accept(s, addr, &len);
-    if (error != -1)
-        *addrlen = (int)len;
-    BLOCKING_IO_RETURN_INT( s, error );
+    /* See NET_RecvFrom() */
+    BLOCKING_IO_RETURN_INT( s, accept(s, addr, (socklen_t *)addrlen) );
 }
 
 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
@@ -349,6 +346,68 @@
  * signal other than our wakeup signal.
  */
 int NET_Timeout0(int s, long timeout, long currentTime) {
+/*
+ * On MacOS X, poll(2) is not working correctly, so a select(2) based
+ * implementation is preferred.  See
+ *
+ * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7131399
+ *
+ * However, on FreeBSD, the select(2) based implementation can cause
+ * crashes under load and poll(2) is preferred.  See
+ *
+ * http://docs.freebsd.org/cgi/getmsg.cgi?fetch=215525+0+current/freebsd-java
+ *
+ * Other *BSD will use poll(2) for now, but please adjust as appropriate.
+ */
+#ifndef __APPLE__
+    long prevtime = currentTime, newtime;
+    struct timeval t;
+    fdEntry_t *fdEntry = getFdEntry(s);
+
+    /*
+     * Check that fd hasn't been closed.
+     */
+    if (fdEntry == NULL) {
+        errno = EBADF;
+        return -1;
+    }
+
+    for(;;) {
+        struct pollfd pfd;
+        int rv;
+        threadEntry_t self;
+
+        /*
+         * Poll the fd. If interrupted by our wakeup signal
+         * errno will be set to EBADF.
+         */
+        pfd.fd = s;
+        pfd.events = POLLIN | POLLERR;
+
+        startOp(fdEntry, &self);
+        rv = poll(&pfd, 1, timeout);
+        endOp(fdEntry, &self);
+
+        /*
+         * If interrupted then adjust timeout. If timeout
+         * has expired return 0 (indicating timeout expired).
+         */
+        if (rv < 0 && errno == EINTR) {
+            if (timeout > 0) {
+                gettimeofday(&t, NULL);
+                newtime = t.tv_sec * 1000  +  t.tv_usec / 1000;
+                timeout -= newtime - prevtime;
+                if (timeout <= 0) {
+                    return 0;
+                }
+                prevtime = newtime;
+            }
+        } else {
+            return rv;
+        }
+
+    }
+#else
     long prevtime = currentTime, newtime;
     struct timeval t, *tp = &t;
     fd_set fds;
@@ -432,4 +491,5 @@
         }
 
     }
+#endif
 }
--- ./jdk/src/solaris/native/java/net/net_util_md.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/net/net_util_md.c	Sun Sep 02 07:33:40 2018 -0700
@@ -46,6 +46,10 @@
 #endif
 #endif
 
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -81,7 +85,7 @@
 
 void setDefaultScopeID(JNIEnv *env, struct sockaddr *him)
 {
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
     static jclass ni_class = NULL;
     static jfieldID ni_defaultIndexID;
     if (ni_class == NULL) {
--- ./jdk/src/solaris/native/java/util/TimeZone_md.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/java/util/TimeZone_md.c	Sun Sep 02 07:33:40 2018 -0700
@@ -56,7 +56,11 @@
 #endif
 
 #if defined(__linux__) || defined(_ALLBSD_SOURCE)
+#ifdef __FreeBSD__
+static const char *ETC_TIMEZONE_FILE = "/var/db/zoneinfo";
+#else
 static const char *ETC_TIMEZONE_FILE = "/etc/timezone";
+#endif
 static const char *ZONEINFO_DIR = "/usr/share/zoneinfo";
 static const char *DEFAULT_ZONEINFO_FILE = "/etc/localtime";
 #else
@@ -69,7 +73,7 @@
 static const char *ETC_ENVIRONMENT_FILE = "/etc/environment";
 #endif
 
-#if defined(__linux__) || defined(MACOSX) || defined(__solaris__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(__solaris__)
 
 /*
  * Returns a pointer to the zone ID portion of the given zoneinfo file
@@ -215,7 +219,7 @@
     return tz;
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 /*
  * Performs Linux specific mapping and returns a zone ID
@@ -231,7 +235,7 @@
     char *buf;
     size_t size;
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /*
      * Try reading the /etc/timezone file for Debian distros. There's
      * no spec of the file format available. This parsing assumes that
@@ -255,7 +259,7 @@
             return tz;
         }
     }
-#endif /* defined(__linux__) */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     /*
      * Next, try /etc/localtime to find the zone ID.
@@ -815,7 +819,7 @@
  * Returns a GMT-offset-based zone ID. (e.g., "GMT-08:00")
  */
 
-#if defined(MACOSX)
+#if defined(_ALLBSD_SOURCE)
 
 char *
 getGMTOffsetID()
@@ -877,4 +881,4 @@
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
 }
-#endif /* MACOSX */
+#endif /* _ALLBSD_SOURCE */
--- ./jdk/src/solaris/native/sun/awt/awt_Font.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Font.c	Sun Sep 02 07:33:40 2018 -0700
@@ -255,7 +255,7 @@
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
--- ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Sun Sep 02 07:33:40 2018 -0700
@@ -121,7 +121,7 @@
  */
 
 #define MAXFRAMEBUFFERS 16
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -427,20 +427,15 @@
     if (XQueryExtension(awt_display, "RENDER",
                         &major_opcode, &first_event, &first_error))
     {
-        xrenderLibHandle = dlopen("libXrender.so.1", RTLD_LAZY | RTLD_GLOBAL);
-
-#ifdef MACOSX
-#define XRENDER_LIB "/usr/X11/lib/libXrender.dylib"
-#else
-#define XRENDER_LIB "libXrender.so"
-#endif
+        xrenderLibHandle = dlopen(VERSIONED_JNI_LIB_NAME("Xrender", "1"),
+                                  RTLD_LAZY | RTLD_GLOBAL);
 
         if (xrenderLibHandle == NULL) {
-            xrenderLibHandle = dlopen(XRENDER_LIB,
+            xrenderLibHandle = dlopen(JNI_LIB_NAME("Xrender"),
                                       RTLD_LAZY | RTLD_GLOBAL);
         }
 
-#ifndef __linux__ /* SOLARIS */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* SOLARIS */
         if (xrenderLibHandle == NULL) {
             xrenderLibHandle = dlopen("/usr/sfw/lib/libXrender.so.1",
                                       RTLD_LAZY | RTLD_GLOBAL);
@@ -584,7 +579,7 @@
 }
 
 #ifndef HEADLESS
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
     void* libHandle = NULL;
@@ -635,7 +630,7 @@
     }
 }
 #endif
-#if !defined(__linux__) && !defined(MACOSX) /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
     void* libHandle = NULL;
@@ -695,11 +690,11 @@
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1597,7 +1592,7 @@
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1610,7 +1605,7 @@
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ || MACOSX */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
--- ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	Sun Sep 02 07:33:40 2018 -0700
@@ -52,7 +52,7 @@
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -66,7 +66,7 @@
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -84,14 +84,14 @@
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -124,7 +124,7 @@
     XIMCallback *callbacks;     /* callback parameters */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #endif
     char        *lookup_buf;    /* buffer used for XmbLookupString */
@@ -370,7 +370,7 @@
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -473,7 +473,7 @@
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -481,7 +481,7 @@
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -573,7 +573,7 @@
     return result;
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
                                 Window parent) {
     StatusWindow *statusWindow;
@@ -886,7 +886,7 @@
         }
     }
 }
-#endif  /* __linux__ || MACOSX */
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -929,7 +929,7 @@
         return FALSE ;
     }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -942,9 +942,9 @@
             break;
         }
     }
-#else /*! __linux__ && !MACOSX */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
     on_the_spot_styles |= XIMStatusNothing;
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -998,7 +998,7 @@
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1020,7 +1020,7 @@
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ && !MACOSX */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
             pX11IMData->ic_active = XCreateIC(X11im,
                                               XNClientWindow, w,
                                               XNFocusWindow, w,
@@ -1028,7 +1028,7 @@
                                               XNPreeditAttributes, preedit,
                                               NULL);
         XFree((void *)preedit);
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
     } else {
         pX11IMData->ic_active = XCreateIC(X11im,
                                           XNClientWindow, w,
@@ -1188,7 +1188,7 @@
 
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1256,7 +1256,7 @@
  finally:
     AWT_UNLOCK();
 }
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1353,14 +1353,14 @@
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIDProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1395,9 +1395,9 @@
 
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1447,14 +1447,14 @@
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  w;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1471,7 +1471,7 @@
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1639,7 +1639,7 @@
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
--- ./jdk/src/solaris/native/sun/awt/awt_Robot.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Robot.c	Sun Sep 02 07:33:40 2018 -0700
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
--- ./jdk/src/solaris/native/sun/awt/extutil.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/awt/extutil.h	Sun Sep 02 07:33:40 2018 -0700
@@ -58,7 +58,7 @@
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
--- ./jdk/src/solaris/native/sun/awt/fontpath.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/awt/fontpath.c	Sun Sep 02 07:33:40 2018 -0700
@@ -23,9 +23,9 @@
  * questions.
  */
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 #include <stdio.h>
 #include <stdlib.h>
 #include <strings.h>
@@ -113,7 +113,6 @@
     OPENWINHOMELIB "locale/ar/X11/fonts/Type1",
     NULL, /* terminates the list */
 };
-
 #elif defined( __linux__)
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
@@ -140,6 +139,20 @@
     "/usr/lpp/X11/lib/X11/fonts/TrueType", /* from X11.fnt.ucs.ttf */
     NULL, /* terminates the list */
 };
+#elif defined(_ALLBSD_SOURCE)
+static char *fullBSDFontPath[] = {
+    PACKAGE_PATH "/lib/X11/fonts/TrueType",
+    PACKAGE_PATH "/lib/X11/fonts/truetype",
+    PACKAGE_PATH "/lib/X11/fonts/TTF",
+    PACKAGE_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    PACKAGE_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #endif
 
 static char **getFontConfigLocations();
@@ -381,7 +394,7 @@
 
 #endif /* !HEADLESS */
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -512,6 +525,8 @@
     knowndirs = fullSolarisFontPath;
 #elif defined(_AIX)
     knowndirs = fullAixFontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #endif
     /* REMIND: this code requires to be executed when the GraphicsEnvironment
      * is already initialised. That is always true, but if it were not so,
@@ -520,8 +535,8 @@
      */
 #ifndef HEADLESS
     if (isX11) { // The following only works in an x11 environment.
-#if defined(__linux__)
-    /* There's no headless build on linux ... */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    /* There's no headless build on linux and BSD ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
       /* Using the X11 font path to locate font files is now a fallback
@@ -536,7 +551,7 @@
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#if defined(__linux__)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
     }
@@ -1237,7 +1252,7 @@
              */
             if (fontformat != NULL
                 && (strcmp((char*)fontformat, "TrueType") != 0)
-#if defined(__linux__) || defined(_AIX)
+#if defined(__linux__) || defined(_AIX) || defined(_ALLBSD_SOURCE)
                 && (strcmp((char*)fontformat, "Type 1") != 0)
 #endif
              ) {
--- ./jdk/src/solaris/native/sun/java2d/j2d_md.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/java2d/j2d_md.h	Sun Sep 02 07:33:40 2018 -0700
@@ -28,11 +28,11 @@
 #include <sys/types.h>
 
 /*
- * Linux and MACOSX's version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's version of <sys/types.h> does not define intptr_t
  */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 typedef unsigned char   jubyte;
 typedef unsigned short  jushort;
--- ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	Sun Sep 02 07:33:40 2018 -0700
@@ -63,9 +63,6 @@
  *    MLIB_EDGE_SRC_PADDED
  */
 
-#ifdef MACOSX
-#include <machine/endian.h>
-#endif
 #include <mlib_image.h>
 #include <mlib_ImageZoom.h>
 
@@ -102,7 +99,7 @@
 
 /***************************************************************/
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -111,7 +108,7 @@
   0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
 };
 
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
@@ -120,7 +117,7 @@
   0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 /***************************************************************/
 
@@ -344,11 +341,11 @@
 #ifdef _NO_LONGLONG
 
 typedef struct {
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
   mlib_u32 uint1, uint0;
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
   mlib_u32 uint0, uint1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 } two_uint;
 
 /***************************************************************/
@@ -511,11 +508,11 @@
         DTYPE mask;
         MASK(mask);
         off *= 8;
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         LSHIFT(dd_old, da[0], 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
         RSHIFT(dd_old, da[0], 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
 
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
@@ -540,30 +537,30 @@
 
           res = (res & 0xff) | (res >> 8);
           dd = gray_mask[res];
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 /* *da++ = (dd_old >> (64 - off)) | (dd << off);*/
           RSHIFT(dd_old, dd_old, 64 - off);
           LSHIFT(dtmp, dd, off);
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 /* *da++ = (dd_old << (64 - off)) | (dd >> off);*/
           LSHIFT(dd_old, dd_old, 64 - off);
           RSHIFT(dtmp, dd, off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
           LOGIC(*da++, dd_old, dtmp, |);
           dd_old = dd;
         }
 
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
 /* da[0] = (dd_old >> (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) << off));*/
         LSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         RSHIFT(dtmp1, dd_old, 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* VM_LITTLE_ENDIAN */
 /* da[0] = (dd_old << (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) >> off));*/
         RSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         LSHIFT(dtmp1, dd_old, 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* VM_LITTLE_ENDIAN */
         LOGIC(da[0], dtmp, dtmp1, |);
       }
       else {                                               /* aligned */
--- ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	Sun Sep 02 07:33:40 2018 -0700
@@ -804,7 +804,7 @@
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/native/sun/management/BsdOperatingSystem.c	Sun Sep 02 07:33:40 2018 -0700
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <jni.h>
+#include "jvm.h"
+#include "sun_management_OperatingSystemImpl.h"
+
+JNIEXPORT jdouble JNICALL
+Java_sun_management_OperatingSystemImpl_getSystemCpuLoad
+(JNIEnv *env, jobject dummy)
+{
+    return (jdouble) -1;
+}
+
+JNIEXPORT jdouble JNICALL
+Java_sun_management_OperatingSystemImpl_getProcessCpuLoad
+(JNIEnv *env, jobject dummy)
+{
+    return (jdouble) -1;
+}
--- ./jdk/src/solaris/native/sun/management/OperatingSystemImpl.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/management/OperatingSystemImpl.c	Sun Sep 02 07:33:40 2018 -0700
@@ -56,6 +56,9 @@
 #include <limits.h>
 #include <stdlib.h>
 #include <unistd.h>
+#ifdef __FreeBSD__
+#include <vm/vm_param.h>
+#endif
 
 #if defined(_AIX)
 #include <libperfstat.h>
@@ -168,6 +171,25 @@
         throw_internal_error(env, "sysctlbyname failed");
     }
     return available ? (jlong)vmusage.xsu_avail : (jlong)vmusage.xsu_total;
+#elif defined(__FreeBSD__)
+    struct xswdev xsw;
+    size_t mibsize, size;
+    jlong npages;
+    int mib[16], n;
+
+    mibsize = sizeof(mib) / sizeof(mib[0]);
+    if (sysctlnametomib("vm.swap_info", mib, &mibsize) == -1)
+       return (0);
+    for (n = 0, npages = 0; ; n++) {
+       mib[mibsize] = n;
+       size = sizeof(xsw);
+       if (sysctl(mib, mibsize + 1, &xsw, &size, NULL, 0) == -1)
+           break;
+       npages += xsw.xsw_nblks;
+       if (available)
+           npages -= xsw.xsw_used;
+    }
+    return (npages * page_size);
 #else /* _ALLBSD_SOURCE */
     /*
      * XXXBSD: there's no way available to get swap info in
@@ -243,11 +265,30 @@
         throw_internal_error(env, "task_info failed");
     }
     return t_info.virtual_size;
+#elif defined(__FreeBSD__)
+    FILE *fp;
+    unsigned long end, start;
+    jlong total = 0;
+
+    if ((fp = fopen("/proc/curproc/map", "r")) == NULL) {
+        throw_internal_error(env, "Unable to open /proc/curproc/map");
+        return -1;
+    }
+
+    for (;;) {
+       // Ignore everything except start and end entries
+       if (fscanf(fp, "0x%lx 0x%lx %*[^\n]\n", &start, &end) != 2 || start > end)
+           break;
+       total += end - start;
+    }
+
+    fclose(fp);
+    return total;
 #else /* _ALLBSD_SOURCE */
     /*
-     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     * XXXBSD: there's no way available to do it in BSD, AFAIK.
      */
-    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    // throw_internal_error(env, "Unimplemented in BSD");
     return (64 * MB);
 #endif
 }
@@ -324,11 +365,27 @@
         return -1;
     }
     return (jlong)vm_stats.free_count * page_size;
+#elif defined(__FreeBSD__)
+    static const char *vm_stats[] = {
+       "vm.stats.vm.v_free_count",
+       "vm.stats.vm.v_cache_count",
+       /* "vm.stats.vm.v_inactive_count", */
+       NULL
+    };
+    size_t size;
+    jlong free_pages;
+    u_int i, npages;
+    for (i = 0, free_pages = 0, size = sizeof(npages); vm_stats[i] != NULL; i++) {
+       if (sysctlbyname(vm_stats[i], &npages, &size, NULL, 0) == -1)
+           return 0;
+       free_pages += npages;
+    }
+    return (free_pages * page_size);
 #elif defined(_ALLBSD_SOURCE)
     /*
-     * XXBSDL no way to do it in FreeBSD
+     * XXBSDL no way to do it in BSD
      */
-    // throw_internal_error(env, "unimplemented in FreeBSD")
+    // throw_internal_error(env, "unimplemented in BSD")
     return (128 * MB);
 #elif defined(_AIX)
     perfstat_memory_total_t memory_info;
@@ -346,13 +403,19 @@
 Java_sun_management_OperatingSystemImpl_getTotalPhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
-#ifdef _ALLBSD_SOURCE
+#if defined(_ALLBSD_SOURCE) && !defined(_SC_PHYS_PAGES)
     jlong result = 0;
     int mib[2];
     size_t rlen;
 
     mib[0] = CTL_HW;
+#if defined (HW_MEMSIZE) // Apple
     mib[1] = HW_MEMSIZE;
+#elif defined(HW_PHYSMEM) // Most of BSD
+    mib[1] = HW_PHYSMEM;
+#else
+  #error No ways to get physmem
+#endif
     rlen = sizeof(result);
     if (sysctl(mib, 2, &result, &rlen, NULL, 0) != 0) {
         throw_internal_error(env, "sysctl failed");
@@ -372,6 +435,11 @@
 }
 
 
+#ifdef _ALLBSD_SOURCE
+#define FD_DIR "/dev/fd"
+#else
+#define FD_DIR "/proc/self/fd"
+#endif
 
 JNIEXPORT jlong JNICALL
 Java_sun_management_OperatingSystemImpl_getOpenFileDescriptorCount
@@ -421,12 +489,8 @@
     free(fds);
 
     return nfiles;
-#elif defined(_ALLBSD_SOURCE)
-    /*
-     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
-     */
-    // throw_internal_error(env, "Unimplemented in FreeBSD");
-    return (100);
+#elif defined(__OpenBSD__)
+    return getdtablecount();
 #else /* solaris/linux */
     DIR *dirp;
     struct dirent dbuf;
@@ -438,13 +502,15 @@
 #define FD_DIR aix_fd_dir
     char aix_fd_dir[32];     /* the pid has at most 19 digits */
     snprintf(aix_fd_dir, 32, "/proc/%d/fd", getpid());
+#elif defined(_ALLBSD_SOURCE)
+#define FD_DIR "/dev/fd"
 #else
 #define FD_DIR "/proc/self/fd"
 #endif
 
     dirp = opendir(FD_DIR);
     if (dirp == NULL) {
-        throw_internal_error(env, "Unable to open directory /proc/self/fd");
+        throw_internal_error(env, "Unable to open directory " FD_DIR);
         return -1;
     }
 
--- ./jdk/src/solaris/native/sun/net/portconfig.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/net/portconfig.c	Sun Sep 02 07:33:40 2018 -0700
@@ -67,6 +67,24 @@
         range->lower = net_getParam("/dev/tcp", "tcp_smallest_anon_port");
         return 0;
     }
+#elif defined(__OpenBSD__)
+    {
+        int mib[3];
+        mib[0] = CTL_NET;
+        mib[1] = PF_INET;
+
+        mib[2] = IPCTL_IPPORT_HIFIRSTAUTO;
+        size_t rlen = sizeof(range->lower);
+        if (sysctl(mib, 3, &range->lower, &rlen, NULL, 0) == -1)
+            return -1;
+
+        mib[2] = IPCTL_IPPORT_HILASTAUTO;
+        rlen = sizeof(range->higher);
+        if (sysctl(mib, 3, &range->higher, &rlen, NULL, 0) == -1)
+            return -1;
+
+        return 0;
+    }
 #elif defined(_ALLBSD_SOURCE)
     {
         int ret;
--- ./jdk/src/solaris/native/sun/nio/ch/sctp/Sctp.h	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/sctp/Sctp.h	Sun Sep 02 07:33:40 2018 -0700
@@ -67,7 +67,7 @@
 
 
 
-#else /* __linux__ */
+#elif defined(__linux__)
 #include <stdint.h>
 #include <linux/types.h>
 #include <sys/socket.h>
@@ -319,9 +319,20 @@
 typedef int sctp_bindx_func(int sd, struct sockaddr *addrs, int addrcnt, int flags);
 typedef int sctp_peeloff_func(int sock, sctp_assoc_t id);
 
+#elif defined(__FreeBSD__)
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/sctp.h>
+#include <netinet/sctp_peeloff.h>
+#include <netinet/sctp_uio.h>
+#include "jni.h"
 
 #endif /* __linux__ */
 
+#ifndef __FreeBSD__
+
 sctp_getladdrs_func* nio_sctp_getladdrs;
 sctp_freeladdrs_func* nio_sctp_freeladdrs;
 sctp_getpaddrs_func* nio_sctp_getpaddrs;
@@ -329,6 +340,17 @@
 sctp_bindx_func* nio_sctp_bindx;
 sctp_peeloff_func* nio_sctp_peeloff;
 
+#else
+
+#define nio_sctp_getladdrs     sctp_getladdrs
+#define nio_sctp_freeladdrs    sctp_freeladdrs
+#define nio_sctp_getpaddrs     sctp_getpaddrs
+#define nio_sctp_freepaddrs    sctp_freepaddrs
+#define nio_sctp_bindx         sctp_bindx
+#define nio_sctp_peeloff       sctp_peeloff
+
+#endif
+
 jboolean loadSocketExtensionFuncs(JNIEnv* env);
 
 #endif /* !SUN_NIO_CH_SCTP_H */
--- ./jdk/src/solaris/native/sun/nio/ch/sctp/SctpNet.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/sctp/SctpNet.c	Sun Sep 02 07:33:40 2018 -0700
@@ -58,6 +58,7 @@
  */
 jboolean loadSocketExtensionFuncs
   (JNIEnv* env) {
+#ifndef __FreeBSD__
     if (dlopen(nativeSctpLib, RTLD_GLOBAL | RTLD_LAZY) == NULL) {
         JNU_ThrowByName(env, "java/lang/UnsupportedOperationException",
               dlerror());
@@ -105,6 +106,7 @@
               dlerror());
         return JNI_FALSE;
     }
+#endif
 
     funcsLoaded = JNI_TRUE;
     return JNI_TRUE;
--- ./jdk/src/solaris/native/sun/nio/fs/MagicFileTypeDetector.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/MagicFileTypeDetector.c	Sun Sep 02 07:33:40 2018 -0700
@@ -31,6 +31,12 @@
 #include <dlfcn.h>
 #include <string.h>
 
+#ifdef __FreeBSD__
+#define MAGIC_MAJOR_VERSION "4"
+#else
+#define MAGIC_MAJOR_VERSION "1"
+#endif
+
 #define MAGIC_MIME_TYPE 0x000010 /* Return the MIME type */
 
 typedef struct magic_set magic_t;
@@ -54,7 +60,7 @@
 {
     magic_handle = dlopen("libmagic.so", RTLD_LAZY);
     if (magic_handle == NULL) {
-        magic_handle = dlopen("libmagic.so.1", RTLD_LAZY);
+        magic_handle = dlopen("libmagic.so." MAGIC_MAJOR_VERSION, RTLD_LAZY);
         if (magic_handle == NULL) {
             return JNI_FALSE;
         }
--- ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	Sun Sep 02 07:33:40 2018 -0700
@@ -54,7 +54,7 @@
     }
 
     // look up existing handle only, do not load
-#if defined(AIX)
+#if defined(AIX) || !defined(RTLD_NOLOAD)
     void *hModule = dlopen(libName, RTLD_LAZY);
 #else
     void *hModule = dlopen(libName, RTLD_NOLOAD);
--- ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	Sun Sep 02 07:33:40 2018 -0700
@@ -38,7 +38,9 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#ifndef __FreeBSD__
 #include <sys/syslimits.h>
+#endif
 #include <sys/un.h>
 #include <fcntl.h>
 
--- ./jdk/src/solaris/native/sun/xawt/XWindow.c	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/solaris/native/sun/xawt/XWindow.c	Sun Sep 02 07:33:40 2018 -0700
@@ -886,7 +886,7 @@
 {
     KeySym originalKeysym = *keysym;
 
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
--- ./jdk/src/windows/native/com/sun/media/sound/PLATFORM_API_WinOS_DirectSound.cpp	Sat Jun 23 21:02:10 2018 -0700
+++ ./jdk/src/windows/native/com/sun/media/sound/PLATFORM_API_WinOS_DirectSound.cpp	Sun Sep 02 07:33:40 2018 -0700
@@ -308,7 +308,7 @@
                                       DAUDIO_PCM,
                                       (bitsArray[bitIndex]==8)?FALSE:TRUE,  /* signed */
                                       (bitsArray[bitIndex]==8)?FALSE:
-#ifndef _LITTLE_ENDIAN
+#ifndef VM_LITTLE_ENDIAN
                                       TRUE /* big endian */
 #else
                                       FALSE /* little endian */
@@ -864,7 +864,7 @@
         return NULL;
     }
     if (sampleSizeInBits > 8 &&
-#ifdef _LITTLE_ENDIAN
+#ifdef VM_LITTLE_ENDIAN
         isBigEndian
 #else
         !isBigEndian
