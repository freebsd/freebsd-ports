--- Makefile.in	2014-04-02 06:21:18.672343000 -0400
+++ Makefile.in	2014-05-15 18:30:56.000000000 -0400
@@ -769,8 +769,8 @@
 # Flags
 export IT_CFLAGS=$(CFLAGS) $(ARCHFLAG)
 export IT_JAVAC_SETTINGS=-g -encoding utf-8 $(JAVACFLAGS) $(MEMORY_LIMIT) $(PREFER_SOURCE)
-export IT_LANGUAGE_SOURCE_VERSION=6
-export IT_CLASS_TARGET_VERSION=6
+export IT_LANGUAGE_SOURCE_VERSION=7
+export IT_CLASS_TARGET_VERSION=7
 export IT_JAVACFLAGS=$(IT_JAVAC_SETTINGS) -source $(IT_LANGUAGE_SOURCE_VERSION) -target $(IT_CLASS_TARGET_VERSION)
 
 #
--- configure	2014-04-02 06:21:18.000335000 -0400
+++ configure	2014-05-15 17:04:42.000000000 -0400
@@ -626,6 +626,8 @@
 VERSION_DEFS
 HAVE_JAVA7_FALSE
 HAVE_JAVA7_TRUE
+HAVE_JAVA8_FALSE
+HAVE_JAVA8_TRUE
 JAVA
 SYSTEM_JRE_DIR
 X11_LIBS
@@ -7226,8 +7228,9 @@
 
   JAVA_VERSION=`$JAVA -version 2>&1 | sed -n '1s/[^"]*"\(.*\)"$/\1/p'`
   HAVE_JAVA7=`echo $JAVA_VERSION | awk '{if ($(0) >= 1.7) print "yes"}'`
-  if  ! test -z "$HAVE_JAVA7" ; then
-    VERSION_DEFS='-DHAVE_JAVA7'
+  HAVE_JAVA8=`echo $JAVA_VERSION | awk '{if ($(0) >= 1.8) print "yes"}'`
+  if  ! test -z "$HAVE_JAVA8" ; then
+    VERSION_DEFS='-DHAVE_JAVA8'
   fi
 
    if test x"${HAVE_JAVA7}" = "xyes" ; then
@@ -7237,6 +7240,13 @@
   HAVE_JAVA7_TRUE='#'
   HAVE_JAVA7_FALSE=
 fi
+if test x"${HAVE_JAVA8}" = "xyes" ; then
+  HAVE_JAVA8_TRUE=
+  HAVE_JAVA8_FALSE='#'
+else
+  HAVE_JAVA8_TRUE='#'
+  HAVE_JAVA8_FALSE=
+fi
 
 
 
@@ -10444,6 +10454,10 @@
   as_fn_error $? "conditional \"HAVE_JAVA7\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${HAVE_JAVA8_TRUE}" && test -z "${HAVE_JAVA8_FALSE}"; then
+  as_fn_error $? "conditional \"HAVE_JAVA8\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${WITH_XSLTPROC_TRUE}" && test -z "${WITH_XSLTPROC_FALSE}"; then
   as_fn_error $? "conditional \"WITH_XSLTPROC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
--- netx/net/sourceforge/jnlp/JNLPFile.java	2014-04-02 06:20:59.682125000 -0400
+++ netx/net/sourceforge/jnlp/JNLPFile.java	2014-05-15 16:57:19.000000000 -0400
@@ -267,7 +267,6 @@
     /**
      * Create a JNLPFile from an input stream.
      *
-     * @throws IOException if an IO exception occurred
      * @throws ParseException if the JNLP file was invalid
      */
     public JNLPFile(InputStream input, ParserSettings settings) throws ParseException {
@@ -281,7 +280,6 @@
      * @param input input stream of JNLP file.
      * @param codebase codebase to use if not specified in JNLP file..
      * @param settings the {@link ParserSettings} to use when parsing
-     * @throws IOException if an IO exception occurred
      * @throws ParseException if the JNLP file was invalid
      */
     public JNLPFile(InputStream input, URL codebase, ParserSettings settings) throws ParseException {
--- netx/net/sourceforge/jnlp/SecurityDesc.java	2014-04-02 06:20:59.680124000 -0400
+++ netx/net/sourceforge/jnlp/SecurityDesc.java	2014-05-15 16:57:19.000000000 -0400
@@ -90,7 +90,7 @@
          * The HTML permission level corresponding to the given String. If null is given, null comes
          * back. If there is no permission level that can be granted in HTML matching the given String,
          * null is also returned.
-         * @param jnlpString the JNLP permission String
+         * @param htmlString the JNLP permission String
          * @return the matching RequestedPermissionLevel
          */
         public RequestedPermissionLevel fromHtmlString(final String htmlString) {
--- netx/net/sourceforge/jnlp/controlpanel/ControlPanel.java	2014-04-02 06:20:59.683125000 -0400
+++ netx/net/sourceforge/jnlp/controlpanel/ControlPanel.java	2014-05-15 16:57:19.000000000 -0400
@@ -292,12 +292,13 @@
             settingsPanel.add(p, panel.toString());
         }
 
-        final JList settingsList = new JList(panels);
+        final JList<SettingsPanel> settingsList = new JList<>(panels);
         settingsList.addListSelectionListener(new ListSelectionListener() {
             @Override
             public void valueChanged(ListSelectionEvent e) {
-                JList list = (JList) e.getSource();
-                SettingsPanel panel = (SettingsPanel) list.getSelectedValue();
+                @SuppressWarnings("unchecked")
+                JList<SettingsPanel> list = (JList<SettingsPanel>) e.getSource();
+                SettingsPanel panel = list.getSelectedValue();
                 CardLayout cl = (CardLayout) settingsPanel.getLayout();
                 cl.show(settingsPanel, panel.toString());
             }
--- netx/net/sourceforge/jnlp/controlpanel/DebuggingPanel.java	2014-04-02 06:20:59.683125000 -0400
+++ netx/net/sourceforge/jnlp/controlpanel/DebuggingPanel.java	2014-05-15 16:57:19.000000000 -0400
@@ -27,6 +27,7 @@
 import java.awt.event.ActionListener;
 import java.awt.event.ItemEvent;
 import java.awt.event.ItemListener;
+
 import javax.swing.Box;
 import javax.swing.JButton;
 import javax.swing.JCheckBox;
@@ -36,6 +37,7 @@
 import javax.swing.JTextField;
 import javax.swing.event.DocumentEvent;
 import javax.swing.event.DocumentListener;
+
 import net.sourceforge.jnlp.config.Defaults;
 import net.sourceforge.jnlp.config.DeploymentConfiguration;
 import net.sourceforge.jnlp.runtime.Translator;
@@ -139,7 +141,7 @@
                 new ComboItem(Translator.R("DPShowJavawsOnly"), DeploymentConfiguration.CONSOLE_SHOW_JAVAWS) };
 
         JLabel consoleLabel = new JLabel(Translator.R("DPJavaConsole"));
-        JComboBox consoleComboBox = new JComboBox();
+        JComboBox<ComboItem> consoleComboBox = new JComboBox<>();
         consoleComboBox.setActionCommand(DeploymentConfiguration.KEY_CONSOLE_STARTUP_MODE); // The property this comboBox affects.
 
         JPanel consolePanel = new JPanel();
@@ -201,7 +203,6 @@
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public void itemStateChanged(ItemEvent e) {
 
         Object o = e.getSource();
@@ -210,7 +211,8 @@
             JCheckBox jcb = (JCheckBox) o;
             config.setProperty(jcb.getActionCommand(), String.valueOf(jcb.isSelected()));
         } else if (o instanceof JComboBox) {
-            JComboBox jcb = (JComboBox) o;
+            @SuppressWarnings("unchecked")
+            JComboBox<ComboItem> jcb = (JComboBox<ComboItem>) o;
             ComboItem c = (ComboItem) e.getItem();
             config.setProperty(jcb.getActionCommand(), c.getValue());
         }
--- netx/net/sourceforge/jnlp/controlpanel/DesktopShortcutPanel.java	2014-04-02 06:20:59.683125000 -0400
+++ netx/net/sourceforge/jnlp/controlpanel/DesktopShortcutPanel.java	2014-05-15 16:57:19.000000000 -0400
@@ -62,7 +62,7 @@
     private void addComponents() {
         GridBagConstraints c = new GridBagConstraints();
         JLabel description = new JLabel("<html>" + Translator.R("CPDesktopIntegrationDescription") + "<hr /></html>");
-        JComboBox shortcutComboOptions = new JComboBox();
+        JComboBox<ComboItem> shortcutComboOptions = new JComboBox<>();
         ComboItem[] items = { new ComboItem(Translator.R("DSPNeverCreate"), "NEVER"),
                 new ComboItem(Translator.R("DSPAlwaysAllow"), "ALWAYS"),
                 new ComboItem(Translator.R("DSPAskUser"), "ASK_USER"),
@@ -94,8 +94,9 @@
         add(filler, c);
     }
 
+    @SuppressWarnings("unchecked")
     public void itemStateChanged(ItemEvent e) {
         ComboItem c = (ComboItem) e.getItem();
-        config.setProperty(((JComboBox) e.getSource()).getActionCommand(), c.getValue());
+        config.setProperty(((JComboBox<ComboItem>) e.getSource()).getActionCommand(), c.getValue());
     }
 }
--- netx/net/sourceforge/jnlp/controlpanel/TemporaryInternetFilesPanel.java	2014-04-02 06:20:59.683125000 -0400
+++ netx/net/sourceforge/jnlp/controlpanel/TemporaryInternetFilesPanel.java	2014-05-15 16:57:19.000000000 -0400
@@ -163,7 +163,7 @@
                 new ComboItem("7", "7"),
                 new ComboItem("8", "8"),
                 new ComboItem(Translator.R("TIFPMax"), "9"), };
-        JComboBox cbCompression = new JComboBox(compressionOptions);
+        JComboBox<ComboItem> cbCompression = new JComboBox<>(compressionOptions);
         cbCompression.setSelectedIndex(Integer.parseInt(this.config.getProperty(properties[3])));
         cbCompression.addItemListener(new ItemListener() {
             @Override
--- netx/net/sourceforge/jnlp/controlpanel/UnsignedAppletsTrustingListPanel.java	2014-04-02 06:20:59.683125000 -0400
+++ netx/net/sourceforge/jnlp/controlpanel/UnsignedAppletsTrustingListPanel.java	2014-05-15 16:57:19.000000000 -0400
@@ -51,6 +51,7 @@
 import java.util.Date;
 import java.util.List;
 import java.util.regex.Pattern;
+
 import javax.swing.DefaultCellEditor;
 import javax.swing.JComboBox;
 import javax.swing.JDialog;
@@ -72,6 +73,7 @@
 import javax.swing.table.TableCellRenderer;
 import javax.swing.table.TableModel;
 import javax.swing.table.TableRowSorter;
+
 import net.sourceforge.jnlp.config.DeploymentConfiguration;
 import net.sourceforge.jnlp.runtime.Translator;
 import net.sourceforge.jnlp.security.appletextendedsecurity.AppletSecurityLevel;
@@ -95,9 +97,9 @@
     private javax.swing.JButton moveRowDownButton;
     private javax.swing.JCheckBox askBeforeActionCheckBox;
     private javax.swing.JCheckBox filterRegexesCheckBox;
-    private javax.swing.JComboBox mainPolicyComboBox;
-    private javax.swing.JComboBox deleteTypeComboBox;
-    private javax.swing.JComboBox viewFilter;
+    private javax.swing.JComboBox<AppletSecurityLevel> mainPolicyComboBox;
+    private javax.swing.JComboBox<String> deleteTypeComboBox;
+    private javax.swing.JComboBox<String> viewFilter;
     private javax.swing.JLabel globalBehaviourLabel;
     private javax.swing.JLabel securityLevelLabel;
     private javax.swing.JScrollPane userTableScrollPane;
@@ -175,7 +177,7 @@
         setButtons((!currentModel.back.isReadOnly()));
     }
 
-    public String appletItemsToCaption(List<UnsignedAppletActionEntry> ii, String caption) {
+    public static String appletItemsToCaption(List<UnsignedAppletActionEntry> ii, String caption) {
         StringBuilder sb = new StringBuilder();
         for (UnsignedAppletActionEntry i : ii) {
             sb.append(appletItemToCaption(i, caption)).append("\n");
@@ -197,7 +199,7 @@
 
     public static void removeSelectedFromTable(JTable table, boolean ask, UnsignedAppletActionTableModel data, Component forDialog) {
         int[] originalIndexes = table.getSelectedRows();
-        List<Integer> newIndexes = new ArrayList<Integer>(originalIndexes.length);
+        List<Integer> newIndexes = new ArrayList<>(originalIndexes.length);
         for (int i = 0; i < originalIndexes.length; i++) {
             //we need to remap values first
             int modelRow = table.convertRowIndexToModel(originalIndexes[i]);
@@ -249,7 +251,7 @@
         userTable = createTbale(customModel);
         globalTable = createTbale(globalModel);
         helpButton = new javax.swing.JButton();
-        mainPolicyComboBox = new JComboBox(new AppletSecurityLevel[]{
+        mainPolicyComboBox = new JComboBox<>(new AppletSecurityLevel[] {
                     AppletSecurityLevel.DENY_ALL,
                     AppletSecurityLevel.DENY_UNSIGNED,
                     AppletSecurityLevel.ASK_UNSIGNED,
@@ -258,8 +260,8 @@
         mainPolicyComboBox.setSelectedItem(AppletSecurityLevel.getDefault());
         securityLevelLabel = new javax.swing.JLabel();
         globalBehaviourLabel = new javax.swing.JLabel();
-        deleteTypeComboBox = new javax.swing.JComboBox();
-        viewFilter = new javax.swing.JComboBox();
+        deleteTypeComboBox = new javax.swing.JComboBox<>();
+        viewFilter = new javax.swing.JComboBox<>();
         deleteButton = new javax.swing.JButton();
         testUrlButton = new javax.swing.JButton();
         addRowButton = new javax.swing.JButton();
@@ -335,7 +337,7 @@
 
         globalBehaviourLabel.setText(Translator.R("APPEXTSECguiPanelGlobalBehaviourCaption"));
 
-        deleteTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[]{
+        deleteTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] {
                     Translator.R("APPEXTSECguiPanelDeleteMenuSelected"),
                     Translator.R("APPEXTSECguiPanelDeleteMenuAllA"),
                     Translator.R("APPEXTSECguiPanelDeleteMenuAllN"),
@@ -343,7 +345,7 @@
                     Translator.R("APPEXTSECguiPanelDeleteMenuAlln"),
                     Translator.R("APPEXTSECguiPanelDeleteMenuAllAll")}));
 
-        viewFilter.setModel(new javax.swing.DefaultComboBoxModel(new String[]{
+        viewFilter.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] {
                     Translator.R("APPEXTSECguiPanelShowOnlyPermanent"),
                     Translator.R("APPEXTSECguiPanelShowOnlyTemporal"),
                     Translator.R("APPEXTSECguiPanelShowAll"),
@@ -681,7 +683,7 @@
         }
     }
 
-    private void helpButtonActionPerformed(java.awt.event.ActionEvent evt) {
+    private static void helpButtonActionPerformed(java.awt.event.ActionEvent evt) {
         JDialog d = new ExtendedAppletSecurityHelp(null, false);
         ScreenFinder.centerWindowsToCurrentScreen(d);
         d.setVisible(true);
@@ -701,7 +703,11 @@
             public TableCellEditor getCellEditor(int row, int column) {
                 int columnx = convertColumnIndexToModel(column);
                 if (columnx == 0) {
-                    return new DefaultCellEditor(new JComboBox(new ExecuteAppletAction[]{ExecuteAppletAction.ALWAYS, ExecuteAppletAction.NEVER, ExecuteAppletAction.YES, ExecuteAppletAction.NO}));
+                    return new DefaultCellEditor(new JComboBox<>(new ExecuteAppletAction[] {
+                            ExecuteAppletAction.ALWAYS,
+                            ExecuteAppletAction.NEVER,
+                            ExecuteAppletAction.YES,
+                            ExecuteAppletAction.NO }));
                 }
                 if (columnx == 2) {
                     column = convertColumnIndexToModel(column);
@@ -761,7 +767,7 @@
     private void removeByBehaviour(ExecuteAppletAction unsignedAppletAction) {
         UnsignedAppletActionEntry[] items = currentModel.back.toArray();
         if (askBeforeActionCheckBox.isSelected()) {
-            List<UnsignedAppletActionEntry> toBeDeleted = new ArrayList<UnsignedAppletActionEntry>();
+            List<UnsignedAppletActionEntry> toBeDeleted = new ArrayList<>();
             for (int i = 0; i < items.length; i++) {
                 UnsignedAppletActionEntry unsignedAppletActionEntry = items[i];
                 if (unsignedAppletActionEntry.getUnsignedAppletAction() == unsignedAppletAction) {
--- netx/net/sourceforge/jnlp/security/VariableX509TrustManagerJDK6.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/VariableX509TrustManagerJDK6.java	2014-05-15 16:57:19.000000000 -0400
@@ -1,75 +0,0 @@
-/* VariableX509TrustManagerJDK6.java
-   Copyright (C) 2012 Red Hat, Inc.
-
-This file is part of IcedTea.
-
-IcedTea is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as published by
-the Free Software Foundation, version 2.
-
-IcedTea is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with IcedTea; see the file COPYING.  If not, write to
-the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
-
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
-
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version.
-*/
-
-package net.sourceforge.jnlp.security;
-
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-import com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager;
-
-public class VariableX509TrustManagerJDK6 extends X509ExtendedTrustManager {
-
-    private VariableX509TrustManager vX509TM = VariableX509TrustManager.getInstance();
-
-    @Override
-    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-        checkClientTrusted(chain, authType, null, null);
-    }
-
-    @Override
-    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-        vX509TM.checkTrustServer(chain, authType, null /* hostname*/, null /* socket */, null /* engine */);
-    }
-
-    @Override
-    public X509Certificate[] getAcceptedIssuers() {
-        return vX509TM.getAcceptedIssuers();
-    }
-
-    @Override
-    public void checkClientTrusted(X509Certificate[] chain, String authType, String hostname, String algorithm) throws CertificateException {
-        vX509TM.checkTrustClient(chain, authType, hostname); // We don't need algorithm, we will always use this for TLS only
-    }
-
-    @Override
-    public void checkServerTrusted(X509Certificate[] chain, String authType, String hostname, String algorithm) throws CertificateException {
-        // We don't need to pass algorithm, we will always use this for TLS only
-        vX509TM.checkTrustServer(chain, authType, hostname, null /* socket */, null /* engine */);
-    }
-
-}
--- netx/net/sourceforge/jnlp/security/policyeditor/CustomPolicyViewer.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/policyeditor/CustomPolicyViewer.java	2014-05-15 16:57:20.000000000 -0400
@@ -66,14 +66,14 @@
  */
 public class CustomPolicyViewer extends JFrame {
 
-    private final Collection<CustomPermission> customPermissions = new TreeSet<CustomPermission>();
+    private final Collection<CustomPermission> customPermissions = new TreeSet<>();
     private final JScrollPane scrollPane = new JScrollPane();
-    private final DefaultListModel listModel = new DefaultListModel();
-    private final JList list = new JList(listModel);
+    private final DefaultListModel<CustomPermission> listModel = new DefaultListModel<>();
+    private final JList<CustomPermission> list = new JList<>(listModel);
     private final JButton addButton = new JButton(), removeButton = new JButton(), closeButton = new JButton();
     private final JLabel listLabel = new JLabel();
     private final ActionListener addButtonAction, removeButtonAction, closeButtonAction;
-    private final WeakReference<CustomPolicyViewer> weakThis = new WeakReference<CustomPolicyViewer>(this);
+    private final WeakReference<CustomPolicyViewer> weakThis = new WeakReference<>(this);
 
     /**
      * @param parent the parent PolicyEditor which created this CustomPolicyViewer
--- netx/net/sourceforge/jnlp/security/policyeditor/PermissionActions.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/policyeditor/PermissionActions.java	2014-05-15 16:57:20.000000000 -0400
@@ -88,7 +88,7 @@
     }
 
     private static Set<String> setFromString(final String string) {
-        final Set<String> set = new HashSet<String>();
+        final Set<String> set = new HashSet<>();
         Collections.addAll(set, string.split(","));
         return set;
     }
--- netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditor.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditor.java	2014-05-15 16:57:20.000000000 -0400
@@ -165,18 +165,18 @@
     private File file;
     private boolean changesMade = false;
     private boolean closed = false;
-    private final Map<String, Map<PolicyEditorPermissions, Boolean>> codebasePermissionsMap = new HashMap<String, Map<PolicyEditorPermissions, Boolean>>();
-    private final Map<String, Set<CustomPermission>> customPermissionsMap = new HashMap<String, Set<CustomPermission>>();
-    private final Map<PolicyEditorPermissions, JCheckBox> checkboxMap = new TreeMap<PolicyEditorPermissions, JCheckBox>();
-    private final List<JCheckBoxWithGroup> groupBoxList = new ArrayList<JCheckBoxWithGroup>(Group.values().length);
+    private final Map<String, Map<PolicyEditorPermissions, Boolean>> codebasePermissionsMap = new HashMap<>();
+    private final Map<String, Set<CustomPermission>> customPermissionsMap = new HashMap<>();
+    private final Map<PolicyEditorPermissions, JCheckBox> checkboxMap = new TreeMap<>();
+    private final List<JCheckBoxWithGroup> groupBoxList = new ArrayList<>(Group.values().length);
     private final JScrollPane scrollPane = new JScrollPane();
-    private final DefaultListModel listModel = new DefaultListModel();
-    private final JList list = new JList(listModel);
+    private final DefaultListModel<String> listModel = new DefaultListModel<>();
+    private final JList<String> list = new JList<>(listModel);
     private final JButton okButton = new JButton(), closeButton = new JButton(),
             addCodebaseButton = new JButton(), removeCodebaseButton = new JButton();
     private final JFileChooser fileChooser;
     private CustomPolicyViewer cpViewer = null;
-    private final WeakReference<PolicyEditor> weakThis = new WeakReference<PolicyEditor>(this);
+    private final WeakReference<PolicyEditor> weakThis = new WeakReference<>(this);
     private MD5SumWatcher fileWatcher;
 
     private final ActionListener okButtonAction, addCodebaseButtonAction,
@@ -196,13 +196,13 @@
             return group;
         }
 
-        private void setState(Map<PolicyEditorPermissions, Boolean> map) {
-            List<ActionListener> backup = new LinkedList<ActionListener>();
+        private void setState(final Map<PolicyEditorPermissions, Boolean> map) {
+            final List<ActionListener> backup = new LinkedList<>();
             for (final ActionListener l : this.getActionListeners()) {
                 backup.add(l);
                 this.removeActionListener(l);
             }
-            int i = group.getState(map);
+            final int i = group.getState(map);
             this.setBackground(getParent().getBackground());
             if (i > 0) {
                 this.setSelected(true);
@@ -215,7 +215,7 @@
                 this.setSelected(false);
             }
 
-            for (ActionListener al : backup) {
+            for (final ActionListener al : backup) {
                 this.addActionListener(al);
             }
         }
@@ -273,7 +273,7 @@
         removeCodebaseButtonAction = new ActionListener() {
             @Override
             public void actionPerformed(final ActionEvent e) {
-                removeCodebase((String) list.getSelectedValue());
+                removeCodebase(getSelectedCodebase());
             }
         };
         removeCodebaseButton.setText(R("PERemoveCodebase"));
@@ -324,7 +324,7 @@
                     @Override
                     public void run() {
                         String codebase = getSelectedCodebase();
-                        if (codebase == null){
+                        if (codebase == null) {
                             return;
                         }
                         if (cpViewer == null) {
@@ -343,9 +343,9 @@
 
         setupLayout();
     }
-    
+
     private String getSelectedCodebase() {
-        String codebase = (String) list.getSelectedValue();
+        final String codebase = list.getSelectedValue();
         if (codebase == null || codebase.isEmpty()) {
             return null;
         }
@@ -355,7 +355,7 @@
         return codebase;
     }
 
-    private static void preparePolicyEditorWindow(final PolicyEditorWindow w, PolicyEditor e) {
+    private static void preparePolicyEditorWindow(final PolicyEditorWindow w, final PolicyEditor e) {
         w.setModalityType(ModalityType.MODELESS); //at least some default
         w.setPolicyEditor(e);
         w.setTitle(R("PETitle"));
@@ -386,7 +386,6 @@
         editor.closeButton.setText(R("ButClose"));
         editor.closeButton.addActionListener(editor.closeButtonAction);
 
-
         final Action saveAct = new AbstractAction() {
             @Override
             public void actionPerformed(final ActionEvent e) {
@@ -437,7 +436,7 @@
 
         private PolicyEditorFrame(final PolicyEditor editor) {
             super();
-            preparePolicyEditorWindow((PolicyEditorWindow)this, editor);
+            preparePolicyEditorWindow((PolicyEditorWindow) this, editor);
         }
 
         @Override
@@ -451,17 +450,17 @@
         }
 
         @Override
-        public final void setPolicyEditor(PolicyEditor e) {
+        public final void setPolicyEditor(final PolicyEditor e) {
             editor = e;
         }
 
         @Override
-        public final void setDefaultCloseOperation(int operation) {
+        public final void setDefaultCloseOperation(final int operation) {
             super.setDefaultCloseOperation(operation);
         }
 
         @Override
-        public final void setJMenuBar(JMenuBar menu) {
+        public final void setJMenuBar(final JMenuBar menu) {
             super.setJMenuBar(menu);
         }
 
@@ -471,7 +470,7 @@
         }
 
         @Override
-        public void setModalityType(ModalityType type) {
+        public void setModalityType(final ModalityType type) {
             //no op for frame
         }
 
@@ -502,11 +501,11 @@
 
         private PolicyEditorDialog(final PolicyEditor editor) {
             super();
-            preparePolicyEditorWindow((PolicyEditorWindow)this, editor);
+            preparePolicyEditorWindow((PolicyEditorWindow) this, editor);
         }
 
         @Override
-        public final void setTitle(String title) {
+        public final void setTitle(final String title) {
             super.setTitle(title);
         }
 
@@ -516,17 +515,17 @@
         }
 
         @Override
-        public final void setPolicyEditor(PolicyEditor e) {
+        public final void setPolicyEditor(final PolicyEditor e) {
             editor = e;
         }
 
         @Override
-        public final void setDefaultCloseOperation(int operation) {
+        public final void setDefaultCloseOperation(final int operation) {
             super.setDefaultCloseOperation(operation);
         }
 
         @Override
-        public final void setJMenuBar(JMenuBar menu) {
+        public final void setJMenuBar(final JMenuBar menu) {
             super.setJMenuBar(menu);
         }
 
@@ -536,7 +535,7 @@
         }
 
         @Override
-        public void setModalityType(ModalityType type) {
+        public void setModalityType(final ModalityType type) {
             super.setModalityType(type);
         }
 
@@ -641,7 +640,7 @@
         final Action act = new AbstractAction() {
             @Override
             public void actionPerformed(final ActionEvent e) {
-                removeCodebase((String) list.getSelectedValue());
+                removeCodebase(getSelectedCodebase());
             }
         };
         setAccelerator(R("PERemoveCodebaseMnemonic"), ActionEvent.ALT_MASK, act, "RemoveCodebaseAccelerator");
@@ -726,6 +725,7 @@
                             stopAsking = true;
                         }
                     } catch (final MalformedURLException mfue) {
+                        // ignore - loop/ask again
                     }
                 }
                 addNewCodebase(codebase);
@@ -773,7 +773,7 @@
         if (permissions != null) {
             return new HashMap<PolicyEditorPermissions, Boolean>(permissions);
         } else {
-            final Map<PolicyEditorPermissions, Boolean> blank = new HashMap<PolicyEditorPermissions, Boolean>();
+            final Map<PolicyEditorPermissions, Boolean> blank = new HashMap<>();
             for (final PolicyEditorPermissions perm : PolicyEditorPermissions.values()) {
                 blank.put(perm, false);
             }
@@ -800,10 +800,10 @@
      */
     private void updateCheckboxes(final String codebase) {
         try {
-            if (SwingUtilities.isEventDispatchThread()){
-             updateCheckboxesImpl(codebase);   
+            if (SwingUtilities.isEventDispatchThread()) {
+                updateCheckboxesImpl(codebase);
             } else {
-            updateCheckboxesInvokeAndWait(codebase);
+                updateCheckboxesInvokeAndWait(codebase);
             }
         } catch (InterruptedException ex) {
             OutputController.getLogger().log(ex);
@@ -811,52 +811,52 @@
             OutputController.getLogger().log(ex);
         }
     }
-    
+
     private void updateCheckboxesInvokeAndWait(final String codebase) throws InterruptedException, InvocationTargetException {
         SwingUtilities.invokeAndWait(new Runnable() {
             @Override
             public void run() {
-               updateCheckboxesImpl(codebase);
+                updateCheckboxesImpl(codebase);
             }
         });
 
     }
-    
-     private void updateCheckboxesImpl(String codebase) {
-                 for (final PolicyEditorPermissions perm : PolicyEditorPermissions.values()) {
-                    final JCheckBox box = checkboxMap.get(perm);
-                    for (final ActionListener l : box.getActionListeners()) {
-                        box.removeActionListener(l);
-                    }
-                    initializeMapForCodebase(codebase);
-                    final Map<PolicyEditorPermissions, Boolean> map = codebasePermissionsMap.get(codebase);
-                    final boolean state;
-                    if (map != null) {
-                        final Boolean s = map.get(perm);
-                        if (s != null) {
-                            state = s;
-                        } else {
-                            state = false;
-                        }
-                    } else {
-                        state = false;
-                    }
+
+    private void updateCheckboxesImpl(final String codebase) {
+        for (final PolicyEditorPermissions perm : PolicyEditorPermissions.values()) {
+            final JCheckBox box = checkboxMap.get(perm);
+            for (final ActionListener l : box.getActionListeners()) {
+                box.removeActionListener(l);
+            }
+            initializeMapForCodebase(codebase);
+            final Map<PolicyEditorPermissions, Boolean> map = codebasePermissionsMap.get(codebase);
+            final boolean state;
+            if (map != null) {
+                final Boolean s = map.get(perm);
+                if (s != null) {
+                    state = s;
+                } else {
+                    state = false;
+                }
+            } else {
+                state = false;
+            }
+            for (final JCheckBoxWithGroup jg : groupBoxList) {
+                jg.setState(map);
+            }
+            box.setSelected(state);
+            box.addActionListener(new ActionListener() {
+                @Override
+                public void actionPerformed(final ActionEvent e) {
+                    changesMade = true;
+                    map.put(perm, box.isSelected());
                     for (JCheckBoxWithGroup jg : groupBoxList) {
                         jg.setState(map);
                     }
-                    box.setSelected(state);
-                    box.addActionListener(new ActionListener() {
-                        @Override
-                        public void actionPerformed(final ActionEvent e) {
-                            changesMade = true;
-                            map.put(perm, box.isSelected());
-                            for (JCheckBoxWithGroup jg : groupBoxList) {
-                                jg.setState(map);
-                            }
-                        }
-                    });
                 }
-            }
+            });
+        }
+    }
 
     /**
      * Set a mnemonic key for a menu item or button
@@ -947,8 +947,8 @@
         checkboxConstraints.gridy = 1;
 
         for (final JCheckBox box : checkboxMap.values()) {
-             if (PolicyEditorPermissions.Group.anyContains(box, checkboxMap)){
-                 //do not show boxes in any group
+            if (PolicyEditorPermissions.Group.anyContains(box, checkboxMap)) {
+                //do not show boxes in any group
                 continue;
             }
             add(box, checkboxConstraints);
@@ -960,7 +960,7 @@
             }
         }
         //add groups
-        for (PolicyEditorPermissions.Group g : PolicyEditorPermissions.Group.values()) {
+        for (final PolicyEditorPermissions.Group g : PolicyEditorPermissions.Group.values()) {
             //no metter what, put group title on new line
             checkboxConstraints.gridy++;
             //all groups are in second column
@@ -977,14 +977,14 @@
                         groupPanel.setVisible(!groupPanel.isVisible());
                         PolicyEditor.this.validate();
                         Container c = PolicyEditor.this.getParent();
-                        //find the window and repack it
+                        // find the window and repack it
                         while (!(c instanceof Window)) {
                             if (c == null) {
                                 return;
                             }
                             c = c.getParent();
                         }
-                        Window w = (Window) c;
+                        final Window w = (Window) c;
                         w.pack();
 
                     }
@@ -993,34 +993,34 @@
             groupCh.addActionListener(new ActionListener() {
                 @Override
                 public void actionPerformed(ActionEvent e) {
-                    String codebase = getSelectedCodebase();
+                    final String codebase = getSelectedCodebase();
                     if (codebase == null) {
                         return;
                     }
-                    List<ActionListener> backup = new LinkedList<ActionListener>();
+                    List<ActionListener> backup = new LinkedList<>();
                     for (final ActionListener l : groupCh.getActionListeners()) {
                         backup.add(l);
                         groupCh.removeActionListener(l);
                     }
                     final Map<PolicyEditorPermissions, Boolean> map = codebasePermissionsMap.get(codebase);
-                    for (PolicyEditorPermissions p : groupCh.getGroup().getPermissions()) {
+                    for (final PolicyEditorPermissions p : groupCh.getGroup().getPermissions()) {
                         map.put(p, groupCh.isSelected());
                     }
                     changesMade = true;
                     updateCheckboxes(codebase);
-                    for (ActionListener al : backup) {
+                    for (final ActionListener al : backup) {
                         groupCh.addActionListener(al);
                     }
 
                 }
             });
             add(groupCh, checkboxConstraints);
-            //place panel with mebers below the title
+            // place panel with members below the title
             checkboxConstraints.gridy++;
             checkboxConstraints.gridx = 2;
-            //spread group's panel over two columns
+            // spread group's panel over two columns
             checkboxConstraints.gridwidth = 2;
-            checkboxConstraints.fill = checkboxConstraints.BOTH;
+            checkboxConstraints.fill = GridBagConstraints.BOTH;
             add(groupPanel, checkboxConstraints);
             final GridBagConstraints groupCheckboxLabelConstraints = new GridBagConstraints();
             groupCheckboxLabelConstraints.anchor = GridBagConstraints.LINE_START;
@@ -1028,7 +1028,7 @@
             groupCheckboxLabelConstraints.weighty = 0;
             groupCheckboxLabelConstraints.gridx = 1;
             groupCheckboxLabelConstraints.gridy = 1;
-            for (PolicyEditorPermissions p : g.getPermissions()) {
+            for (final PolicyEditorPermissions p : g.getPermissions()) {
                 groupPanel.add(checkboxMap.get(p), groupCheckboxLabelConstraints);
                 // Two columns of checkboxes
                 groupCheckboxLabelConstraints.gridx++;
@@ -1042,7 +1042,6 @@
             checkboxConstraints.gridwidth = 1;
         }
 
-
         final JLabel codebaseListLabel = new JLabel(R("PECodebaseLabel"));
         codebaseListLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
         final GridBagConstraints listLabelConstraints = new GridBagConstraints();
@@ -1152,7 +1151,7 @@
                         // If this fails we'll end up handling it a few lines down anyway.
                     }
                 }
-                OpenFileResult ofr = FileUtils.testFilePermissions(file);
+                final OpenFileResult ofr = FileUtils.testFilePermissions(file);
                 if (ofr == OpenFileResult.FAILURE || ofr == OpenFileResult.NOT_FILE) {
                     FileUtils.showCouldNotOpenFilepathDialog(weakThis.get(), file.getPath());
                     return;
@@ -1258,7 +1257,7 @@
         }
 
         if (codebasePermissionsMap.get(codebase) == null) {
-            final Map<PolicyEditorPermissions, Boolean> map = new HashMap<PolicyEditorPermissions, Boolean>();
+            final Map<PolicyEditorPermissions, Boolean> map = new HashMap<>();
             for (final PolicyEditorPermissions perm : PolicyEditorPermissions.values()) {
                 map.put(perm, false);
             }
@@ -1266,7 +1265,7 @@
         }
 
         if (customPermissionsMap.get(codebase) == null) {
-            final Set<CustomPermission> set = new HashSet<CustomPermission>();
+            final Set<CustomPermission> set = new HashSet<>();
             customPermissionsMap.put(codebase, set);
         }
 
@@ -1307,8 +1306,10 @@
                 }
                 final StringBuilder sb = new StringBuilder();
                 sb.append(AUTOGENERATED_NOTICE);
-                sb.append("\n/* Generated by PolicyEditor at ").append(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
-                              .format(Calendar.getInstance().getTime())).append(" */").append(System.getProperty("line.separator"));
+                sb.append("\n/* Generated by PolicyEditor at ")
+                    .append(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(Calendar.getInstance().getTime()))
+                    .append(" */")
+                    .append(System.getProperty("line.separator"));
                 final Set<PolicyEditorPermissions> enabledPermissions = new HashSet<PolicyEditorPermissions>();
                 FileLock fileLock;
                 try {
@@ -1456,7 +1457,7 @@
      */
     static Map<String, String> argsToMap(final String[] args) {
         final List<String> argsList = Arrays.<String> asList(args);
-        final Map<String, String> map = new HashMap<String, String>();
+        final Map<String, String> map = new HashMap<>();
 
         if (argsList.contains(HELP_FLAG)) {
             map.put(HELP_FLAG, null);
--- netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditorPermissions.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditorPermissions.java	2014-05-15 16:57:20.000000000 -0400
@@ -123,13 +123,14 @@
 
         private final PolicyEditorPermissions[] permissions;
         private final String title; 
-        private Group(String title, PolicyEditorPermissions... permissions) {
+
+        private Group(final String title, final PolicyEditorPermissions... permissions) {
             this.title = title;
             this.permissions = permissions;
         
         }
 
-        public static boolean anyContains(PolicyEditorPermissions permission) {
+        public static boolean anyContains(final PolicyEditorPermissions permission) {
             for (Group g : Group.values()) {
                 if (g.contains(permission)) {
                     return true;
@@ -138,10 +139,10 @@
             return false;
         }
 
-        public static boolean anyContains(JCheckBox view, Map<PolicyEditorPermissions, JCheckBox> checkboxMap) {
-            for (Map.Entry<PolicyEditorPermissions, JCheckBox> pairs : checkboxMap.entrySet()){
+        public static boolean anyContains(final JCheckBox view, final Map<PolicyEditorPermissions, JCheckBox> checkboxMap) {
+            for (final Map.Entry<PolicyEditorPermissions, JCheckBox> pairs : checkboxMap.entrySet()) {
                 if (pairs.getValue() == view) {
-                    for (Group g : Group.values()) {
+                    for (final Group g : Group.values()) {
                         if (g.contains(pairs.getKey())) {
                             return true;
                         }
@@ -157,10 +158,10 @@
          * - none is selected
          */
         public int getState (final Map<PolicyEditorPermissions, Boolean> map) {
-            boolean allTrue=true;
-            boolean allFalse=true;
-            for (PolicyEditorPermissions pp: getPermissions()){
-                Boolean b = map.get(pp);
+            boolean allTrue = true;
+            boolean allFalse = true;
+            for (final PolicyEditorPermissions pp : getPermissions()) {
+                final Boolean b = map.get(pp);
                 if (b == null){
                     return 0;
                 }
@@ -170,23 +171,22 @@
                     allTrue = false;
                 }
             }
-            if (allFalse){
+            if (allFalse) {
                 return -1;
             }
-            if (allTrue){
+            if (allTrue) {
                 return 1;
             }
             return 0;
         }
 
-        public boolean contains(PolicyEditorPermissions permission) {
-            for (PolicyEditorPermissions policyEditorPermissions : permissions) {
+        public boolean contains(final PolicyEditorPermissions permission) {
+            for (final PolicyEditorPermissions policyEditorPermissions : permissions) {
                 if (policyEditorPermissions == permission) {
                     return true;
                 }
             }
             return false;
-
         }
 
         public String getTitle() {
@@ -199,7 +199,7 @@
 
     }
 
-    
+
     private final String name, description;
     private final PermissionType type;
     private final PermissionTarget target;
--- netx/net/sourceforge/jnlp/security/policyeditor/PolicyEntry.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/policyeditor/PolicyEntry.java	2014-05-15 16:57:20.000000000 -0400
@@ -51,8 +51,8 @@
 public class PolicyEntry {
 
     private final String codebase;
-    private final Set<PolicyEditorPermissions> permissions = new HashSet<PolicyEditorPermissions>();
-    private final Set<CustomPermission> customPermissions = new HashSet<CustomPermission>();
+    private final Set<PolicyEditorPermissions> permissions = new HashSet<>();
+    private final Set<CustomPermission> customPermissions = new HashSet<>();
 
     public PolicyEntry(final String codebase, final Collection<PolicyEditorPermissions> permissions,
             final Collection<CustomPermission> customPermissions) {
--- netx/net/sourceforge/jnlp/security/viewer/CertificatePane.java	2014-04-02 06:20:59.679124000 -0400
+++ netx/net/sourceforge/jnlp/security/viewer/CertificatePane.java	2014-05-15 16:57:20.000000000 -0400
@@ -108,7 +108,7 @@
     JTabbedPane tabbedPane;
     private final JTable userTable;
     private final JTable systemTable;
-    private JComboBox certificateTypeCombo;
+    private JComboBox<CertificateType> certificateTypeCombo;
     private KeyStores.Type currentKeyStoreType;
     private KeyStores.Level currentKeyStoreLevel;
 
@@ -130,7 +130,7 @@
 
         userTable = new JTable(null);
         systemTable = new JTable(null);
-        disableForSystem = new ArrayList<JComponent>();
+        disableForSystem = new ArrayList<>();
 
         addComponents();
 
@@ -165,7 +165,7 @@
 
         JLabel certificateTypeLabel = new JLabel(R("CVCertificateType"));
 
-        certificateTypeCombo = new JComboBox(certificateTypes);
+        certificateTypeCombo = new JComboBox<>(certificateTypes);
         certificateTypeCombo.addActionListener(new CertificateTypeListener());
 
         certificateTypePanel.add(certificateTypeLabel, BorderLayout.LINE_START);
@@ -257,7 +257,7 @@
     private void readKeyStore() {
 
         Enumeration<String> aliases = null;
-        certs = new ArrayList<X509Certificate>();
+        certs = new ArrayList<>();
         try {
 
             //Get all of the X509Certificates and put them into an ArrayList
@@ -279,7 +279,7 @@
                                         SecurityUtil.getCN(c.getIssuerX500Principal().getName());
             }
         } catch (Exception e) {
-            //TODO
+            // TODO handle exception
            OutputController.getLogger().log(OutputController.Level.ERROR_ALL, e);
         }
     }
@@ -314,9 +314,7 @@
         if (result == JOptionPane.OK_OPTION) {
             return jpf.getPassword();
         }
-        else {
-            return null;
-        }
+        return null;
     }
 
     /** Allows storing KeyStores.Types in a JComponent */
@@ -342,7 +340,7 @@
         @Override
         @SuppressWarnings("unchecked")//this is just certificateTypeCombo, nothing else
         public void actionPerformed(ActionEvent e) {
-            JComboBox source = (JComboBox) e.getSource();
+            JComboBox<CertificateType> source = (JComboBox<CertificateType>) e.getSource();
             CertificateType type = (CertificateType) source.getSelectedItem();
             currentKeyStoreType = type.getType();
             repopulateTables();
--- netx/net/sourceforge/jnlp/util/FileUtils.java	2014-04-02 06:20:59.685125000 -0400
+++ netx/net/sourceforge/jnlp/util/FileUtils.java	2014-05-15 16:57:20.000000000 -0400
@@ -394,7 +394,6 @@
     /**
      * Show a dialog informing the user that the file could not be opened
      * @param frame a {@link JFrame} to act as parent to this dialog
-     * @param filePath a {@link String} representing the path to the file we failed to open
      * @param message a {@link String} giving the specific reason the file could not be opened
      */
     public static void showCouldNotOpenDialog(final Component frame, final String message) {
--- netx/net/sourceforge/jnlp/util/JarFile.java	2014-04-02 06:20:59.685125000 -0400
+++ netx/net/sourceforge/jnlp/util/JarFile.java	2014-05-15 16:57:20.000000000 -0400
@@ -43,94 +43,82 @@
 import java.io.InputStream;
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
 
-//in jdk6 java.util.jar.JarFile is not Closeable - fixing
-//overwritening  class can add duplicate occurence of interface so this should be perfectly safe
-public class JarFile extends java.util.jar.JarFile implements Closeable{
+/**
+ * A wrapper over {@link java.util.jar.JarFile} that verifies zip headers to
+ * protect against GIFAR attacks.
+ *
+ * @see <a href="http://en.wikipedia.org/wiki/Gifar">Gifar</a>
+ */
+public class JarFile extends java.util.jar.JarFile implements Closeable {
 
     public JarFile(String name) throws IOException {
-       super(name);
-       verifyZipHeader(new File(name));
+        super(name);
+        verifyZipHeader(new File(name));
     }
 
-    /**
-     */
     public JarFile(String name, boolean verify) throws IOException {
         super(name, verify);
         verifyZipHeader(new File(name));
     }
 
-    /**
-     */
     public JarFile(File file) throws IOException {
         super(file);
         verifyZipHeader(file);
     }
 
-    /**
-     */
     public JarFile(File file, boolean verify) throws IOException {
         super(file, verify);
         verifyZipHeader(file);
     }
 
-    /*
-     */
     public JarFile(File file, boolean verify, int mode) throws IOException {
         super(file, verify, mode);
-         verifyZipHeader(file);
+        verifyZipHeader(file);
     }
-    
-    
-    
-    
+
     /**
-     * According to specification -
-     * http://www.pkware.com/documents/casestudies/APPNOTE.TXT or just google
-     * around zip header all entries in zip-compressed must start with well
-     * known "PK" which is defined as hexa x50 x4b x03 x04, which in decimal are
-     * 80 75 3 4.
-     * 
+     * The ZIP specification requires that the zip header for all entries in a
+     * zip-compressed archive must start with a well known "PK" which is
+     * defined as hex x50 x4b x03 x04.
+     * <p>
      * Note - this is not file-header, it is item-header.
-     *
-     * Actually most of compressing formats have some n-bytes header se eg:
+     * <p>
+     * Actually most of compressing formats have some n-bytes headers. Eg:
      * http://www.gzip.org/zlib/rfc-gzip.html#header-trailer for ID1 and ID2 so
      * in case that some differently compressed jars will come to play, this is
-     * the palce where to fix it.
+     * the place where to fix it.
      *
+     * @see <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">ZIP Specification</a>
      */
-    private static final byte[] ZIP_LOCAL_FILE_HEADER_SIGNATURE = new byte[]{80, 75, 3, 4};
+    private static final byte[] ZIP_ENTRY_HEADER_SIGNATURE = new byte[] {0x50, 0x4b, 0x03, 0x04};
 
     /**
-     * This method is checking first four bytes of jar-file against
-     * ZIP_LOCAL_FILE_HEADER_SIGNATURE
-     *
+     * Verify the header for the zip entry.
+     * <p>
      * Although zip specification allows to skip all corrupted entries, it is
-     * not safe for jars. If first four bytes of file are not zip
-     * ZIP_LOCAL_FILE_HEADER_SIGNATURE then exception is thrown
-     * 
-     * As noted, ZIP_LOCAL_FILE_HEADER_SIGNATURE is not ile-header, but is item-header.
-     * Possible attack is using the fact that entries without header are considered
-     * corrupted and so can be ignoered. However, for other they can have some meaning.
-     * 
-     * So for our purposes we must insists on first record to be valid.
-     *
-     * @param file
-     * @throws IOException
-     * @throws InvalidJarHeaderException
+     * not safe for jars since it allows a different format to fake itself as
+     * a Jar.
      */
-    public static void verifyZipHeader(File file) throws IOException {
+    private void verifyZipHeader(File file) throws IOException {
         if (!JNLPRuntime.isIgnoreHeaders()) {
             InputStream s = new FileInputStream(file);
+
+            /*
+             * Theoretically, a valid ZIP file can begin with anything. We
+             * ensure it begins with a valid entry header to confirm it only
+             * contains zip entries.
+             */
+
             try {
-                byte[] buffer = new byte[ZIP_LOCAL_FILE_HEADER_SIGNATURE.length];
+                byte[] buffer = new byte[ZIP_ENTRY_HEADER_SIGNATURE.length];
                 /*
                  * for case that new byte[] will accidently initialize same
                  * sequence as zip header and during the read the buffer will not be filled
-                 */                
+                 */
                 for (int i = 0; i < buffer.length; i++) {
                     buffer[i] = 0;
                 }
-                int toRead = ZIP_LOCAL_FILE_HEADER_SIGNATURE.length;
+                int toRead = ZIP_ENTRY_HEADER_SIGNATURE.length;
                 int readSoFar = 0;
                 int n = 0;
                 /*
@@ -144,7 +132,7 @@
                     }
                 }
                 for (int i = 0; i < buffer.length; i++) {
-                    if (buffer[i] != ZIP_LOCAL_FILE_HEADER_SIGNATURE[i]) {
+                    if (buffer[i] != ZIP_ENTRY_HEADER_SIGNATURE[i]) {
                         throw new InvalidJarHeaderException("Jar " + file.getName() + " do not heave valid header. You can skip this check by -Xignoreheaders");
                     }
                 }
--- netx/net/sourceforge/jnlp/util/logging/ConsoleOutputPane.java	2014-04-02 06:20:59.684125000 -0400
+++ netx/net/sourceforge/jnlp/util/logging/ConsoleOutputPane.java	2014-05-15 16:57:20.000000000 -0400
@@ -15,6 +15,7 @@
 import java.util.Observer;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Pattern;
+
 import javax.swing.ButtonGroup;
 import javax.swing.JFrame;
 import javax.swing.JMenuItem;
@@ -26,6 +27,7 @@
 import javax.swing.text.Document;
 import javax.swing.text.PlainDocument;
 import javax.swing.text.html.HTMLDocument;
+
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
 import net.sourceforge.jnlp.runtime.Translator;
 import net.sourceforge.jnlp.util.logging.headers.ObservableMessagesProvider;
@@ -247,7 +249,6 @@
         statistics.setText(model.createStatisticHint());
     }
 
-    @SuppressWarnings("unchecked")
     private void initComponents() {
 
         jPanel2 = new javax.swing.JPanel();
@@ -267,7 +268,7 @@
         showPreInit = new javax.swing.JCheckBox();
         sortByLabel = new javax.swing.JLabel();
         regExLabel = new javax.swing.JCheckBox();
-        sortBy = new javax.swing.JComboBox();
+        sortBy = new javax.swing.JComboBox<>();
         searchLabel = new javax.swing.JLabel();
         autorefresh = new javax.swing.JCheckBox();
         refresh = new javax.swing.JButton();
@@ -362,7 +363,7 @@
         regExLabel.setText(Translator.R("COPregex") + ":");
         regExLabel.addActionListener(getDefaultActionSingleton());
 
-        sortBy.setModel(new javax.swing.DefaultComboBoxModel(new String[]{
+        sortBy.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] {
             Translator.R("COPAsArrived"),
             Translator.R("COPuser"),
             Translator.R("COPorigin"),
@@ -943,7 +944,7 @@
     private javax.swing.JCheckBox showThread2;
     private javax.swing.JCheckBox showUser;
     private javax.swing.JCheckBox sortCopyAll;
-    private javax.swing.JComboBox sortBy;
+    private javax.swing.JComboBox<String> sortBy;
     private javax.swing.JLabel sortByLabel;
     private javax.swing.JLabel statistics;
     private javax.swing.JCheckBox wordWrap;
--- netx/net/sourceforge/nanoxml/XMLElement.java	2014-04-02 06:20:59.669124000 -0400
+++ netx/net/sourceforge/nanoxml/XMLElement.java	2014-05-15 16:57:20.000000000 -0400
@@ -39,7 +39,7 @@
 /**
  * XMLElement is a representation of an XML object. The object is able to parse
  * XML code.
- * <p><dl>
+ * <dl>
  * <dt><b>Parsing XML Data</b></dt>
  * <dd>
  * You can parse XML data using the following code:
@@ -83,7 +83,6 @@
  * {@link #createAnotherElement() createAnotherElement}
  * which has to return a new copy of the receiver.
  * </dd></dl>
- * </p>
  *
  * @see net.sourceforge.nanoxml.XMLParseException
  *
@@ -178,7 +177,8 @@
     private boolean ignoreWhitespace;
 
     /**
-     * Character read too much.<br/>
+     * Character read too much.
+     * <p>
      * This character provides push-back functionality to the input reader
      * without having to use a PushbackReader.
      * If there is no such character, this field is {@code '\0'}.
@@ -210,7 +210,8 @@
     private int parserLineNr;
 
     /**
-     * Creates and initializes a new XML element.<br/>
+     * Creates and initializes a new XML element.
+     * <p>
      * Calling the construction is equivalent to:
      * <ul><li>{@code new XMLElement(new Hashtable(), false, true)}</li></ul>
      *
@@ -400,7 +401,8 @@
     }
 
     /**
-     * Returns an attribute of the element.<br/>
+     * Returns an attribute of the element.
+     * <p>
      * If the attribute doesn't exist, {@code null} is returned.
      *
      * @param name The name of the attribute.
@@ -535,7 +537,7 @@
      *     The new name.
      *
      * <dl><dt><b>Preconditions:</b></dt><dd>
-     * <ul><li{@code name != null}</li>
+     * <ul><li>{@code name != null}</li>
      *     <li>{@code name} is a valid XML identifier</li>
      * </ul></dd></dl>
      */
@@ -597,7 +599,8 @@
     }
 
     /**
-     * This method scans an identifier from the current reader.<br/>
+     * This method scans an identifier from the current reader.
+     * <p>
      * The scanned whitespace is appended to {@code result}.
      *
      * @return the next character following the whitespace.
@@ -625,7 +628,8 @@
     }
 
     /**
-     * This method scans a delimited string from the current reader.<br/>
+     * This method scans a delimited string from the current reader.
+     * <p>
      * The scanned string without delimiters is appended to {@code string}.
      *
      * <dl><dt><b>Preconditions:</b></dt><dd>
@@ -653,8 +657,10 @@
 
     /**
      * Scans a {@code #PCDATA} element. CDATA sections and entities are
-     * resolved.<br/>
-     * The next &lt; char is skipped.<br/>
+     * resolved.
+     * <p>
+     * The next &lt; char is skipped.
+     * <p>
      * The scanned data is appended to {@code data}.
      *
      * <dl><dt><b>Preconditions:</b></dt><dd>
@@ -831,7 +837,8 @@
     }
 
     /**
-     * Scans the data for literal text.<br/>
+     * Scans the data for literal text.
+     * <p>
      * Scanning stops when a character does not match or after the complete
      * text has been checked, whichever comes first.
      *
@@ -985,7 +992,8 @@
     }
 
     /**
-     * Resolves an entity. The name of the entity is read from the reader.<br/>
+     * Resolves an entity. The name of the entity is read from the reader.
+     * <p>
      * The value of the entity is appended to {@code buf}.
      *
      * @param buf Where to put the entity value.
--- netx/net/sourceforge/nanoxml/XMLParseException.java	2014-04-02 06:20:59.669124000 -0400
+++ netx/net/sourceforge/nanoxml/XMLParseException.java	2014-05-15 16:57:20.000000000 -0400
@@ -32,7 +32,8 @@
  * An XMLParseException is thrown when an error occures while parsing an XML
  * string.
  * <p>
- * $Revision: 1.1 $<br/>
+ * $Revision: 1.1 $</p>
+ * <p>
  * $Date: 2002/08/03 04:05:32 $</p>
  *
  * @see net.sourceforge.nanoxml.XMLElement
--- plugin/icedteanp/IcedTeaNPPlugin.cc	2014-04-02 06:20:59.687125000 -0400
+++ plugin/icedteanp/IcedTeaNPPlugin.cc	2014-05-15 16:57:20.000000000 -0400
@@ -64,16 +64,16 @@
 #define PLUGIN_FULL_NAME PLUGIN_NAME " (using " PLUGIN_VERSION ")"
 #define PLUGIN_DESC "The <a href=\"" PACKAGE_URL "\">" PLUGIN_NAME "</a> executes Java applets."
 
-#ifdef HAVE_JAVA7
- #define JPI_VERSION "1.7.0_" JDK_UPDATE_VERSION
- #define PLUGIN_APPLET_MIME_DESC7 \
-  "application/x-java-applet;version=1.7:class,jar:IcedTea;"
- #define PLUGIN_BEAN_MIME_DESC7 \
-  "application/x-java-bean;version=1.7:class,jar:IcedTea;"
+#ifdef HAVE_JAVA8
+ #define JPI_VERSION "1.8.0_" JDK_UPDATE_VERSION
+ #define PLUGIN_APPLET_MIME_DESC \
+  "application/x-java-applet;version=1.8:class,jar:IcedTea;"
+ #define PLUGIN_BEAN_MIME_DESC \
+  "application/x-java-bean;version=1.8:class,jar:IcedTea;"
 #else
- #define JPI_VERSION "1.6.0_" JDK_UPDATE_VERSION
- #define PLUGIN_APPLET_MIME_DESC7
- #define PLUGIN_BEAN_MIME_DESC7
+ #define JPI_VERSION "1.7.0_" JDK_UPDATE_VERSION
+ #define PLUGIN_APPLET_MIME_DESC
+ #define PLUGIN_BEAN_MIME_DESC
 #endif
 
 #define PLUGIN_MIME_DESC                                               \
@@ -93,7 +93,8 @@
   "application/x-java-applet;version=1.4.2:class,jar:IcedTea;"         \
   "application/x-java-applet;version=1.5:class,jar:IcedTea;"           \
   "application/x-java-applet;version=1.6:class,jar:IcedTea;"           \
-  PLUGIN_APPLET_MIME_DESC7 \
+  "application/x-java-applet;version=1.7:class,jar:IcedTea;"           \
+  PLUGIN_APPLET_MIME_DESC \
   "application/x-java-applet;jpi-version=" JPI_VERSION ":class,jar:IcedTea;"  \
   "application/x-java-bean:class,jar:IcedTea;"                         \
   "application/x-java-bean;version=1.1:class,jar:IcedTea;"             \
@@ -110,7 +111,8 @@
   "application/x-java-bean;version=1.4.2:class,jar:IcedTea;"           \
   "application/x-java-bean;version=1.5:class,jar:IcedTea;"             \
   "application/x-java-bean;version=1.6:class,jar:IcedTea;"             \
-  PLUGIN_BEAN_MIME_DESC7 \
+  "application/x-java-bean;version=1.7:class,jar:IcedTea;"             \
+  PLUGIN_BEAN_MIME_DESC \
   "application/x-java-bean;jpi-version=" JPI_VERSION ":class,jar:IcedTea;"    \
   "application/x-java-vm-npruntime::IcedTea;"
 
--- tests/test-extensions/net/sourceforge/jnlp/tools/CodeSignerCreator.java	2014-04-02 06:20:59.637124000 -0400
+++ tests/test-extensions/net/sourceforge/jnlp/tools/CodeSignerCreator.java	2014-05-15 16:57:20.000000000 -0400
@@ -25,17 +25,24 @@
 
 package net.sourceforge.jnlp.tools;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.security.CodeSigner;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.security.NoSuchProviderException;
 import java.security.PrivateKey;
+import java.security.SignatureException;
 import java.security.Timestamp;
 import java.security.cert.CertPath;
+import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.Date;
 
 import sun.security.x509.AlgorithmId;
-import sun.security.x509.CertAndKeyGen;
 import sun.security.x509.CertificateAlgorithmId;
 import sun.security.x509.CertificateIssuerName;
 import sun.security.x509.CertificateSerialNumber;
@@ -72,13 +79,10 @@
         // KeyTool#doGenKeyPair
         X500Name x500Name = new X500Name(dname);
 
-        CertAndKeyGen keypair = new CertAndKeyGen(keyAlgName, sigAlgName);
+        KeyPair keyPair = new KeyPair(keyAlgName, sigAlgName, keysize);
+        PrivateKey privKey = keyPair.getPrivateKey();
 
-        keypair.generate(keysize);
-        PrivateKey privKey = keypair.getPrivateKey();
-
-        X509Certificate oldCert = keypair.getSelfCertificate(x500Name,
-                notBefore, validity * 24L * 60L * 60L);
+        X509Certificate oldCert = keyPair.getSelfCertificate(x500Name, notBefore, validity);
 
         // KeyTool#doSelfCert
         byte[] encoded = oldCert.getEncoded();
@@ -142,4 +146,70 @@
         Timestamp certTimestamp = new Timestamp(jarEntryCert.getNotBefore(), certPath);
         return new CodeSigner(certPath, certTimestamp);
     }
+
+    /**
+     * A wrapper over JDK-internal CertAndKeyGen Class.
+     * <p>
+     * This is an internal class whose package changed between OpenJDK 7 and 8.
+     * Use reflection to access the right thing.
+     */
+    public static class KeyPair {
+
+        private /* CertAndKeyGen */ Object keyPair;
+
+        public KeyPair(String keyAlgName, String sigAlgName, int keySize) throws NoSuchAlgorithmException, InvalidKeyException {
+            try {
+                // keyPair = new CertAndKeyGen(keyAlgName, sigAlgName);
+                Class<?> certAndKeyGenClass = Class.forName(getCertAndKeyGenClass());
+                Constructor<?> constructor = certAndKeyGenClass.getDeclaredConstructor(String.class, String.class);
+                keyPair = constructor.newInstance(keyAlgName, sigAlgName);
+
+                // keyPair.generate(keySize);
+                Method generate = certAndKeyGenClass.getMethod("generate", int.class);
+                generate.invoke(keyPair, keySize);
+            } catch (ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException |
+                    IllegalAccessException | IllegalArgumentException | InvocationTargetException certAndKeyGenClassError) {
+                throw new AssertionError("Unable to use CertAndKeyGen class", certAndKeyGenClassError);
+            }
+        }
+
+        public PrivateKey getPrivateKey() {
+            try {
+                // return keyPair.getPrivateKey();
+                Class<?> klass = keyPair.getClass();
+                Method method = klass.getMethod("getPrivateKey");
+                return (PrivateKey) method.invoke(keyPair);
+            } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | InvocationTargetException error) {
+                throw new AssertionError(error);
+            }
+        }
+
+        public X509Certificate getSelfCertificate(X500Name name, Date notBefore, long validityInDays)
+                throws InvalidKeyException, CertificateException, SignatureException,
+                NoSuchAlgorithmException, NoSuchProviderException {
+            try {
+                // return keyPair.getSelfCertificate(name, notBefore, validityInDays * 24L * 60L * 60L);
+                Class<?> klass = keyPair.getClass();
+                Method method = klass.getMethod("getSelfCertificate", X500Name.class, Date.class, long.class);
+                return (X509Certificate) method.invoke(keyPair, name, notBefore, validityInDays * 24L * 60L * 60L);
+            } catch (InvocationTargetException ite) {
+                throw new RuntimeException(ite.getCause());
+            } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException error) {
+                throw new AssertionError(error);
+            }
+        }
+
+        private String getCertAndKeyGenClass() {
+            String javaVersion = System.getProperty("java.version");
+            String className = null;
+            if (javaVersion.startsWith("1.7")) {
+                className = "sun.security.x509.CertAndKeyGen";
+            } else if (javaVersion.startsWith("1.8")) {
+                className = "sun.security.tools.keytool.CertAndKeyGen";
+            } else {
+                throw new AssertionError("Unrecognized Java Version");
+            }
+            return className;
+        }
+    }
 }
