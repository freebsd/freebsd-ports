--- .hgtags	2012-08-10 09:07:00.000000000 -0700
+++ .hgtags	2013-05-05 09:39:37.000000000 -0700
@@ -123,6 +123,7 @@
 2d38c2a79c144c30cd04d143d83ee7ec6af40771 jdk7-b146
 3ac30b3852876ccad6bd61697b5f9efa91ca7bc6 jdk7u1-b01
 d91364304d7c4ecd34caffdba2b840aeb0d10b51 jdk7-b147
+00b623147f23ef8a92a25c4c28ef8681dc1d1b52 7u0
 34451dc0580d5c95d97b95a564e6198f36545d68 jdk7u1-b02
 bf735d852f79bdbb3373c777eec3ff27e035e7ba jdk7u1-b03
 f66a2bada589f4157789e6f66472954d2f1c114e jdk7u1-b04
@@ -197,5 +198,69 @@
 29f6fb1833eb2a696b95e8985126f2d70f511a82 jdk7u6-b21
 31cdab09d719fe60876c7f3a472386c1455d93e2 jdk7u6-b22
 d1c709f1196a73d1df10d04a221b10e30fd2eb48 jdk7u6-b23
-1ab3edf5061fdde3a6f6510373a92444445af710 jdk7u8-b01
-d7a94c8cbbbfadbd9e2f3e4737eb7deb572dedc9 jdk7u8-b02
+e4def733cc8c58e83b7cefa7edd89a3e2b793520 jdk7u6-b24
+f5f546dba006778854e7a81141fc1b44acd257a4 jdk7u6-b30
+43775eae8df6c874fb3631c86009505cf3821b1f jdk7u6-b31
+43775eae8df6c874fb3631c86009505cf3821b1f jdk7u7-b10
+a380c75873bfb578e605d4362edb18c08698cc3e jdk7u7-b30
+d7f2b3949f9c9ff1115ea61c496d3cd4c62e2759 jdk7u7-b11
+82c51e6a3bea0dd8feb1bd3033e847dbdc5d9f99 jdk7u7-b31
+5ca487420f9c2cf6d39acf1e842d13bf8ef0ca07 jdk7u7-b01
+dbfa9c57853c2dd9cd4e4a139d83b519573d8031 jdk7u7-b02
+bae912f95f2aa1d22dbc0ff62816b71861965cd6 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+5ca487420f9c2cf6d39acf1e842d13bf8ef0ca07 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+dbfa9c57853c2dd9cd4e4a139d83b519573d8031 jdk7u9-b02
+3159fbe20e2d9501007aae8ca3db58978d754561 jdk7u9-b04
+d9c8fa0606fdfff242175ce904c525a6fc40d6e5 jdk7u9-b05
+81f8b620894e275012a1b447f13319b7d2148b28 jdk7u9-b31
+d247cdeb828f4463b55ea53c4b2d6346f7706c3c jdk7u9-b32
+d934ce27cddbc9ba7236791f177872491204a41e jdk7u10-b10
+5a5ee5b70d563d5817b6ec023d275e9b17256459 jdk7u10-b11
+48b58c2d665c9a1d3598b981e46f87f9bcdd5b46 jdk7u10-b12
+1b9618b61e29c09b92f83956c613acf36ccabb38 jdk7u10-b13
+c50e1a044e4fcc1a94b79b42f3629beb07624010 jdk7u10-b14
+137087461db28f935493940658f31be760098f00 jdk7u10-b15
+c8a37a49fc90ae31b864544d6d4a9f6137d4995d jdk7u10-b16
+494e838439db7f0f4e36f7dcfeba06d2bef78c8d jdk7u10-b17
+dce9058d2151e6b5c84898c13cfd1521a627a296 jdk7u10-b18
+b5fb925394331313dbe3859fdc408bfd37193476 jdk7u10-b30
+337ce65c8c356766212812b78f49f5632995987d jdk7u10-b31
+c2d5141baeda6c9b5bbc83c21eff9c3940fefae4 jdk7u11-b20
+168aa0f1417b3651a955ae66068dc148b660f829 jdk7u11-b21
+7c0710ed65b097d415f772ff4fb58c4822890aa3 jdk7u11-b32
+61cee7a518a4ae05439490ec388c3ab1d1d899f2 jdk7u11-b33
+c8a37a49fc90ae31b864544d6d4a9f6137d4995d jdk7u11-b03
+0b418e2ccf9093718609144689d1a8b316ad951f jdk7u11-b04
+e127e6c94b56f7348df67d9672c16a7dc9c5ec5e jdk7u11-b05
+f6abff072aabfee866342d9f7f4aac7d13450ddf jdk7u11-b06
+80a3d0bcd3d4c9e83b75416178bdd60a2d23ebbc jdk7u11-b07
+e7c55def6796d3c426631b5717084ef122908847 jdk7u11-b08
+2412f7b8551ede5296cb6e1d6189f40aad9eeffe jdk7u13-b09
+3b7815df113f8044039739276237b964ee8fa015 jdk7u13-b10
+527d3cf769ec073d7348e4c31f97c47c943c96b6 jdk7u13-b30
+3b7815df113f8044039739276237b964ee8fa015 jdk7u13-b20
+0e52db2d9bb8bc789f6c66f2cfb7cd2d3b0b16c6 jdk7u15-b01
+0324fca94d073b3aad77658224f17679f25c18b1 jdk7u15-b02
+25a9d44cebf2a7ac6dd1748c94e00b242403acb1 jdk7u15-b30
+5c1b2900a65b5ebe9d2a5c9b48903081c8196b04 jdk7u15-b31
+e7adbfbcd837ad4e9f88db45612e5704b7a249fd jdk7u15-b33
+f37a75bd39595ba38bdc53ee957c63bbb3cbb12d jdk7u15-b03
+2412f7b8551ede5296cb6e1d6189f40aad9eeffe jdk7u15-b32
+0c2b2dae93e7a720bbcc2e13a1913a2264335554 jdk7u17-b01
+8e49ff2feda30801d7826ca1778eb7b901a7089c jdk7u17-b02
+933d424580f967ed11eda2bbfd690f985a72df6e jdk7u17-b30
+790582955edb617b41abbc73cf82544dbf8c1d97 jdk7u17-b31
+527d3cf769ec073d7348e4c31f97c47c943c96b6 jdk7u21-b01
+bc264b362dc7b4f2bda34e1a5b87a4f0c2bd4d82 jdk7u21-b02
+20603c659295a40c7f16259cb08c91475092efed jdk7u21-b03
+d2b1fdd8ee0affe640c7493ab3ae04fcc1961446 jdk7u21-b04
+2d6657f92359d1d46b355fd0c99b8aa5f34832e4 jdk7u21-b05
+14522481739dc6981beb5cc55d543dcc62cda067 jdk7u21-b06
+0df382e8c17bf817d55fc8759c7f5c9e9d0337f0 jdk7u21-b07
+1aff32a21aba64c3767e9a72ebf1b8ba490e99ec jdk7u21-b08
+a2e0099b4cf70be026a7a0ba7918fcd71d57fdce jdk7u21-b09
+602ad1a5b09fb9136e8bf1b708e0524fbdb35324 jdk7u21-b10
+fa322ca378324750ea049f2e92357e51eca27ae4 jdk7u21-b11
+450e8dde919df278fe75ae95e0eb0a6464f5bc41 jdk7u21-b30
--- corba/.hgtags	2012-08-10 09:09:50.000000000 -0700
+++ corba/.hgtags	2013-05-05 09:39:37.000000000 -0700
@@ -123,6 +123,7 @@
 770227a4087e4e401fe87ccd19738440111c3948 jdk7-b146
 36f0efbc66ef8ace3cca8aa8d0c88f3334080f8a jdk7u1-b01
 73323cb3396260d93e0ab731fd2d431096ceed0f jdk7-b147
+578c4d2c534cc761f5f5cc0d8360471bb8d5f94f 7u0
 9515a2d034b4727c11aeea36354a549fbc469c4f jdk7u1-b02
 dd71cb354c573c1addcda269a7dd9144bfce9587 jdk7u1-b03
 eaee830124aa453627591d8f9eccb39d7e040876 jdk7u1-b04
@@ -197,5 +198,69 @@
 353c15c4bc371f2f8258344c988d1403477cc140 jdk7u6-b21
 793b80c0316fcafa18668bced26acb41af3be07d jdk7u6-b22
 2a8376123fbb81bc4b2f643ff7cfaf7f87b21c35 jdk7u6-b23
-353c15c4bc371f2f8258344c988d1403477cc140 jdk7u8-b01
-d17ca8d088f7cc0dd42230472f534c8d1e415bcb jdk7u8-b02
+02512f61591f55d84458d1ea4ce84eecb7324f89 jdk7u6-b24
+8b20875b3faa01ef56331045de88747df278eaeb jdk7u6-b30
+d7fe6c13adf9e06d98c061449d171bc06c2ba0a3 jdk7u6-b31
+d7fe6c13adf9e06d98c061449d171bc06c2ba0a3 jdk7u7-b10
+496baf62d0550c704505b0ff6f390279f6a569e0 jdk7u7-b30
+e57e4274a3575f278115cc8ef03c5bdf3c43a7ed jdk7u7-b11
+06cbc4af754ea8f2e3b7d0b1701d1a69ce9d5075 jdk7u7-b31
+8737f43e092ea52dd85dcf164736eea3b9b364e6 jdk7u7-b01
+ec602836c4e173927911673d253bb8baa1e3d170 jdk7u7-b02
+a163e56c6679d10dc64ec48f35e67c3a5942afba jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+8737f43e092ea52dd85dcf164736eea3b9b364e6 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+ec602836c4e173927911673d253bb8baa1e3d170 jdk7u9-b02
+268470f3f0d0d7e9b04c579c551571097f0b0305 jdk7u9-b04
+a5dced409c4b7f940db80846f6efabac74523b0e jdk7u9-b05
+b426254b45bcd7cdb38003497fdd4168e366d3cb jdk7u9-b31
+0fa70374aa257929e2541e57c55c4cdebec91fd4 jdk7u9-b32
+ba68d4ad02c465a36344a34eba34491466ec17d4 jdk7u10-b10
+a738921b001a92381bf355a2bb1ecd742ecee352 jdk7u10-b11
+e52708ecb2c32b366c251e4083fbb37e22a425c3 jdk7u10-b12
+5cd2ef642635a7d0a79a7c28343b2ddfd0e6aa4a jdk7u10-b13
+2d53a2c7e4b989ceba356abfc8dc2129269a134f jdk7u10-b14
+c488cd628db35eb09d8ef9e10ffd00c9a93d0778 jdk7u10-b15
+64f09d7549d304fbfd3c29b4f148bf44e8e3e979 jdk7u10-b16
+57c3355153d1624fd98618097c1a82ab3ffc66f8 jdk7u10-b17
+f2a347637a55fa4de9542a8dcab72ad6fac44d2b jdk7u10-b18
+22cf8bc2ec47498fe548b308a81be0486dd7e3d0 jdk7u10-b30
+2723612f5983e7d65490d7d4a3d8577026448736 jdk7u10-b31
+e7952daece16b27d69cb78f6912407c3bbaf8e83 jdk7u11-b20
+dff0f0272891b1d53497d9525567959b73476ff9 jdk7u11-b21
+24f8cb8a0a615686f8baba4d746514bae92f064d jdk7u11-b32
+4bfef14df261d69dc32e37d189e12e3fa572a83c jdk7u11-b33
+96a3c68e5741dc9ab5cb0da426511eb15fd29ede jdk7u11-b03
+1413b173730f4796fca42c89eeb804a5935b0264 jdk7u11-b04
+5c49a17bc15f4fd4722746788f5130df132cd038 jdk7u11-b05
+30057c20fbb3caa61857656d05421e56731184f2 jdk7u11-b06
+9d9440d1fa2dd872c2a2b564fc5fa4d3555afab6 jdk7u11-b07
+983fac5b27376839142ac5a8770461e4e48c2dc8 jdk7u11-b08
+b192d148731916e4b1b47b7a3e6b0a1d7ddf3f14 jdk7u13-b09
+b9ab9b203a41469a274419d26be2c04558b57ce8 jdk7u13-b10
+f5ef46204dba19679edd7492b221110fd1a0bd33 jdk7u13-b30
+b9ab9b203a41469a274419d26be2c04558b57ce8 jdk7u13-b20
+622e370c2d1e8c5f48d8f520f486dc6fcc1239c5 jdk7u15-b01
+30188388048333e213a839363329ac2cb0cf0e0d jdk7u15-b02
+7f0e7ce088ff554f64e2c102ae3718ae4d580c34 jdk7u15-b30
+3714b558333e1089e2649ead8586873abd9c0ed1 jdk7u15-b31
+f0c038610b6da1a0d4214b730aa6cb17b64d0a3b jdk7u15-b33
+e5b996dabec6ac6aa12705ce678642605ea9d476 jdk7u15-b03
+b192d148731916e4b1b47b7a3e6b0a1d7ddf3f14 jdk7u15-b32
+94e8b9b0e0ef1685e2f2fcc886e08a42a85c8e03 jdk7u17-b01
+e82d31e1f1189ae6f02d6855f0cd78074599b2e1 jdk7u17-b02
+d4366e557c4c5af62a94fc9885aed87c99abc848 jdk7u17-b30
+a6f066dd2cd526da73070d1e46c9b1e1ab1a6756 jdk7u17-b31
+f5ef46204dba19679edd7492b221110fd1a0bd33 jdk7u21-b01
+17ecd70a2247ed86a095aae9f1a201fa7feea861 jdk7u21-b02
+bf0877613aeba816d5f18ea6316d535819f628e9 jdk7u21-b03
+3e39240d7314e82b3ccff3b2a64413be9c0b6665 jdk7u21-b04
+f5a291dc9d219f68a2d4bcc72c65c014e9ec3b8b jdk7u21-b05
+94f2ebfccc5e057169284bb2c858296b235868ea jdk7u21-b06
+23a57aceeb69e688f8ce8b8361fad3a49cf4ac5f jdk7u21-b07
+ebedf04bfffe289e8bf9661b38f73ca6c0dad17c jdk7u21-b08
+b8f92ad1f0cc86d8571a0e23192e667f0ef8e421 jdk7u21-b09
+b2adfd931a2504948d4fee780e4175122be10484 jdk7u21-b10
+61e2e2d9cfcea20132b50d8fb7ead66a8a373db7 jdk7u21-b11
+3c774492beaaff241c654add2c4e683b9ff002f2 jdk7u21-b30
--- corba/make/com/sun/corba/minclude/com_sun_corba_se_impl_orbutil.jmk	2012-08-10 09:09:53.000000000 -0700
+++ corba/make/com/sun/corba/minclude/com_sun_corba_se_impl_orbutil.jmk	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2009, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -29,10 +29,6 @@
 	com/sun/corba/se/impl/orbutil/DenseIntMapImpl.java \
 	com/sun/corba/se/impl/orbutil/GetPropertyAction.java \
 	com/sun/corba/se/impl/orbutil/HexOutputStream.java \
-	com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java \
-	com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java \
-	com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java \
 	com/sun/corba/se/impl/orbutil/LegacyHookGetFields.java \
 	com/sun/corba/se/impl/orbutil/LegacyHookPutFields.java \
 	com/sun/corba/se/impl/orbutil/LogKeywords.java \
@@ -45,19 +41,11 @@
 	com/sun/corba/se/impl/orbutil/ORBUtility.java \
 	com/sun/corba/se/impl/orbutil/ORBClassLoader.java \
 	com/sun/corba/se/impl/orbutil/RepIdDelegator.java \
-	com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java \
-	com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java \
-	com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdStrings.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdUtility.java \
 	com/sun/corba/se/impl/orbutil/RepositoryIdInterface.java \
-	com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java \
 	com/sun/corba/se/impl/orbutil/StackImpl.java \
-	com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java \
-	com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java \
 	com/sun/corba/se/impl/orbutil/closure/Future.java \
 	com/sun/corba/se/impl/orbutil/closure/Constant.java \
 	com/sun/corba/se/impl/orbutil/concurrent/Sync.java \
--- corba/src/share/classes/com/sun/corba/se/impl/activation/ServerMain.java	2012-08-10 09:10:11.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/activation/ServerMain.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -322,9 +322,9 @@
     com.sun.corba.se.spi.activation._ServerImplBase
 {
     private ORB orb;
-    private Method installMethod ;
-    private Method uninstallMethod ;
-    private Method shutdownMethod ;
+    private transient Method installMethod ;
+    private transient Method uninstallMethod ;
+    private transient Method shutdownMethod ;
     private Object methodArgs[] ;
 
     ServerCallback(ORB orb, Method installMethod, Method uninstallMethod,
--- corba/src/share/classes/com/sun/corba/se/impl/corba/AnyImpl.java	2012-08-10 09:10:12.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/corba/AnyImpl.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1218,7 +1218,7 @@
         // See bug 4391648 for more info about the tcORB in this
         // case.
         RepositoryIdStrings repStrs
-            = RepositoryIdFactory.getRepIdStringsFactory(tcORB);
+            = RepositoryIdFactory.getRepIdStringsFactory();
 
 
         // Assertion: c instanceof Serializable?
@@ -1251,7 +1251,7 @@
         // Anything else
         // We know that this is a TypeCodeImpl since it is our ORB
         classTC = (TypeCodeImpl)ValueUtility.createTypeCodeForClass(
-            tcORB, c, ORBUtility.createValueHandler(tcORB));
+            tcORB, c, ORBUtility.createValueHandler());
         // Intruct classTC to store its buffer
         classTC.setCaching(true);
         // Update the cache
--- corba/src/share/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java	2012-08-10 09:10:15.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -269,8 +269,8 @@
 
     private final void createRepositoryIdHandlers()
     {
-        repIdUtil = RepositoryIdFactory.getRepIdUtility(orb);
-        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory(orb);
+        repIdUtil = RepositoryIdFactory.getRepIdUtility();
+        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
     }
 
     public GIOPVersion getGIOPVersion() {
@@ -564,10 +564,7 @@
 
         checkForNegativeLength(len);
 
-        if (orb != null && ORBUtility.isLegacyORB((ORB)orb))
-            return legacyReadString(len);
-        else
-            return internalReadString(len);
+        return internalReadString(len);
     }
 
     private final String internalReadString(int len) {
@@ -588,54 +585,6 @@
         return new String(result, 0, getCharConverter().getNumChars());
     }
 
-    private final String legacyReadString(int len) {
-
-        //
-        // Workaround for ORBs which send string lengths of
-        // zero to mean empty string.
-        //
-        //
-        // IMPORTANT: Do not replace 'new String("")' with "", it may result
-        // in a Serialization bug (See serialization.zerolengthstring) and
-        // bug id: 4728756 for details
-        if (len == 0)
-            return new String("");
-
-        len--;
-        char[] c = new char[len];
-
-        int n = 0;
-        while (n < len) {
-            int avail;
-            int bytes;
-            int wanted;
-
-            avail = bbwi.buflen - bbwi.position();
-            if (avail <= 0) {
-                grow(1, 1);
-                avail = bbwi.buflen - bbwi.position();
-            }
-            wanted = len - n;
-            bytes = (wanted < avail) ? wanted : avail;
-            // Microbenchmarks are showing a loop of ByteBuffer.get(int) being
-            // faster than ByteBuffer.get(byte[], int, int).
-            for (int i=0; i<bytes; i++) {
-                c[n+i] = (char) (bbwi.byteBuffer.get(bbwi.position()+i) & 0xFF);
-            }
-            bbwi.position(bbwi.position() + bytes);
-            n += bytes;
-        }
-
-        //
-        // Skip past terminating null byte
-        //
-        if (bbwi.position() + 1 > bbwi.buflen)
-            alignAndCheck(1, 1);
-        bbwi.position(bbwi.position() + 1);
-
-        return new String(c);
-    }
-
     public final String read_string() {
         return readStringOrIndirection(false);
     }
@@ -1045,7 +994,7 @@
 
                 try {
                     if (valueHandler == null)
-                        valueHandler = ORBUtility.createValueHandler(orb);
+                        valueHandler = ORBUtility.createValueHandler();
 
                     value = valueHandler.readValue(parent,
                                                    indirection,
--- corba/src/share/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java	2012-08-10 09:10:15.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -189,18 +189,8 @@
 
     private final void createRepositoryIdHandlers()
     {
-        if (orb != null) {
-            // Get the appropriate versions based on the ORB version.  The
-            // ORB versioning info is only in the core ORB.
-            repIdUtil
-                = RepositoryIdFactory.getRepIdUtility(orb);
-            repIdStrs
-                = RepositoryIdFactory.getRepIdStringsFactory(orb);
-        } else {
-            // Get the latest versions
-            repIdUtil = RepositoryIdFactory.getRepIdUtility();
-            repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
-        }
+        repIdUtil = RepositoryIdFactory.getRepIdUtility();
+        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
     }
 
     public BufferManagerWrite getBufferManager()
@@ -705,7 +695,7 @@
     private void writeArray(Serializable array, Class clazz) {
 
         if (valueHandler == null)
-            valueHandler = ORBUtility.createValueHandler(orb); //d11638
+            valueHandler = ORBUtility.createValueHandler(); //d11638
 
         // Write value_tag
         int indirection = writeValueTag(mustChunk, true,
@@ -768,7 +758,7 @@
 
     private void writeRMIIIOPValueType(Serializable object, Class clazz) {
         if (valueHandler == null)
-            valueHandler = ORBUtility.createValueHandler(orb); //d11638
+            valueHandler = ORBUtility.createValueHandler(); //d11638
 
         Serializable key = object;
 
--- corba/src/share/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java	2012-08-10 09:10:18.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -86,7 +86,7 @@
             // default to using the current ORB version in case the
             // vhandler is not set
             if (vhandler == null) {
-                vhandler = new ValueHandlerImpl(false);
+                vhandler = ValueHandlerImpl.getInstance(false);
             }
 
             // Util.getCodebase may return null which would
@@ -120,7 +120,7 @@
                 // default to using the current ORB version in case the
                 // vhandler is not set
                 if (vhandler == null) {
-                    vhandler = new ValueHandlerImpl(false);
+                    vhandler = ValueHandlerImpl.getInstance(false);
                 }
 
                 try{
@@ -161,7 +161,7 @@
             // default to using the current ORB version in case the
             // vhandler is not set
             if (vhandler == null) {
-                vhandler = new ValueHandlerImpl(false);
+                vhandler = ValueHandlerImpl.getInstance(false);
             }
 
             Stack repIds = new Stack();
--- corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java	2012-08-10 09:10:18.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,7 @@
 /*
  * Licensed Materials - Property of IBM
  * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
+ * Copyright IBM Corp. 1998 2012  All Rights Reserved
  *
  */
 
@@ -56,7 +56,8 @@
 
 import java.util.Arrays;
 import java.util.Comparator;
-import java.util.Hashtable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 import com.sun.corba.se.impl.util.RepositoryId;
 
@@ -83,8 +84,6 @@
     private static Object noArgsList[] = {};
     private static Class noTypesList[] = {};
 
-    private static Hashtable translatedFields;
-
     /** true if represents enum type */
     private boolean isEnum;
 
@@ -384,6 +383,55 @@
          */
     }
 
+    private static final class PersistentFieldsValue {
+        private final ConcurrentMap map = new ConcurrentHashMap();
+        private static final Object NULL_VALUE =
+            (PersistentFieldsValue.class.getName() + ".NULL_VALUE");
+
+        PersistentFieldsValue() { }
+
+        ObjectStreamField[] get(Class type) {
+            Object value = map.get(type);
+            if (value == null) {
+                value = computeValue(type);
+                map.putIfAbsent(type, value);
+            }
+            return ((value == NULL_VALUE) ? null : (ObjectStreamField[])value);
+        }
+
+        private static Object computeValue(Class<?> type) {
+            try {
+                Field pf = type.getDeclaredField("serialPersistentFields");
+                int mods = pf.getModifiers();
+                if (Modifier.isPrivate(mods) && Modifier.isStatic(mods) &&
+                        Modifier.isFinal(mods)) {
+                    pf.setAccessible(true);
+                    java.io.ObjectStreamField[] fields =
+                        (java.io.ObjectStreamField[])pf.get(type);
+                    return translateFields(fields);
+                }
+            } catch (NoSuchFieldException e1) {
+            } catch (IllegalAccessException e2) {
+            } catch (IllegalArgumentException e3) {
+            } catch (ClassCastException e4) { }
+            return NULL_VALUE;
+        }
+
+        private static ObjectStreamField[] translateFields(
+                java.io.ObjectStreamField[] fields) {
+            ObjectStreamField[] translation =
+                new ObjectStreamField[fields.length];
+            for (int i = 0; i < fields.length; i++) {
+                translation[i] = new ObjectStreamField(fields[i].getName(),
+                        fields[i].getType());
+            }
+            return translation;
+        }
+    }
+
+    private static final PersistentFieldsValue persistentFieldsValue =
+        new PersistentFieldsValue();
+
     /*
      * Initialize class descriptor.  This method is only invoked on class
      * descriptors created via calls to lookupInternal().  This method is kept
@@ -416,35 +464,7 @@
                  * If it is declared, use the declared serialPersistentFields.
                  * Otherwise, extract the fields from the class itself.
                  */
-                try {
-                    Field pf = cl.getDeclaredField("serialPersistentFields");
-                    // serial bug 7; the serialPersistentFields were not
-                    // being read and stored as Accessible bit was not set
-                    pf.setAccessible(true);
-                    // serial bug 7; need to find if the field is of type
-                    // java.io.ObjectStreamField
-                    java.io.ObjectStreamField[] f =
-                           (java.io.ObjectStreamField[])pf.get(cl);
-                    int mods = pf.getModifiers();
-                    if ((Modifier.isPrivate(mods)) &&
-                        (Modifier.isStatic(mods)) &&
-                        (Modifier.isFinal(mods)))
-                    {
-                        fields = (ObjectStreamField[])translateFields((Object[])pf.get(cl));
-                    }
-                } catch (NoSuchFieldException e) {
-                    fields = null;
-                } catch (IllegalAccessException e) {
-                    fields = null;
-                } catch (IllegalArgumentException e) {
-                    fields = null;
-                } catch (ClassCastException e) {
-                    /* Thrown if a field serialPersistentField exists
-                     * but it is not of type ObjectStreamField.
-                     */
-                    fields = null;
-                }
-
+                fields = persistentFieldsValue.get(cl);
 
                 if (fields == null) {
                     /* Get all of the declared fields for this
@@ -641,44 +661,6 @@
         superclass = null;
     }
 
-    private static Object[] translateFields(Object objs[])
-        throws NoSuchFieldException {
-        try{
-            java.io.ObjectStreamField fields[] = (java.io.ObjectStreamField[])objs;
-            Object translation[] = null;
-
-            if (translatedFields == null)
-                translatedFields = new Hashtable();
-
-            translation = (Object[])translatedFields.get(fields);
-
-            if (translation != null)
-                return translation;
-            else {
-                Class osfClass = Class.forName("com.sun.corba.se.impl.io.ObjectStreamField");
-                translation = (Object[])java.lang.reflect.Array.newInstance(osfClass, objs.length);
-                Object arg[] = new Object[2];
-                Class types[] = {String.class, Class.class};
-                Constructor constructor = osfClass.getDeclaredConstructor(types);
-                for (int i = fields.length -1; i >= 0; i--){
-                    arg[0] = fields[i].getName();
-                    arg[1] = fields[i].getType();
-
-                    translation[i] = constructor.newInstance(arg);
-                }
-                translatedFields.put(fields, translation);
-
-            }
-
-            return (Object[])translation;
-        }
-        catch(Throwable t){
-            NoSuchFieldException nsfe = new NoSuchFieldException();
-            nsfe.initCause( t ) ;
-            throw nsfe ;
-        }
-    }
-
     /*
      * Set the class this version descriptor matches.
      * The base class name and serializable hash must match.
@@ -1555,8 +1537,8 @@
     private boolean hasExternalizableBlockData;
     Method writeObjectMethod;
     Method readObjectMethod;
-    private Method writeReplaceObjectMethod;
-    private Method readResolveObjectMethod;
+    private transient Method writeReplaceObjectMethod;
+    private transient Method readResolveObjectMethod;
     private Constructor cons ;
 
     /**
--- corba/src/share/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.java	2012-08-10 09:10:19.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -53,7 +53,7 @@
 import com.sun.corba.se.impl.logging.OMGSystemException;
 import com.sun.corba.se.impl.logging.UtilSystemException;
 
-public class ValueHandlerImpl implements javax.rmi.CORBA.ValueHandlerMultiFormat {
+public final class ValueHandlerImpl implements javax.rmi.CORBA.ValueHandlerMultiFormat {
 
     // Property to override our maximum stream format version
     public static final String FORMAT_VERSION_PROPERTY
@@ -150,14 +150,22 @@
         writeValueWithVersion(out, value, streamFormatVersion);
     }
 
-    public ValueHandlerImpl(){}
+    private ValueHandlerImpl(){}
 
-    public ValueHandlerImpl(boolean isInputStream) {
+    private ValueHandlerImpl(boolean isInputStream) {
         this();
         useHashtables = false;
         this.isInputStream = isInputStream;
     }
 
+    static ValueHandlerImpl getInstance() {
+        return new ValueHandlerImpl();
+    }
+
+    static ValueHandlerImpl getInstance(boolean isInputStream) {
+        return new ValueHandlerImpl(isInputStream);
+    }
+
     /**
      * Writes the value to the stream using java semantics.
      * @param out The stream to write the value to
@@ -458,12 +466,7 @@
         return ObjectStreamClass.lookup(value.getClass()).writeReplace(value);
     }
 
-    /**
-     * Encapsulates writing of Java char arrays so that the 1.3 subclass
-     * can override it without exposing internals across packages.  This
-     * is a fix for bug 4367783.
-     */
-    protected void writeCharArray(org.omg.CORBA_2_3.portable.OutputStream out,
+    private void writeCharArray(org.omg.CORBA_2_3.portable.OutputStream out,
                                 char[] array,
                                 int offset,
                                 int length)
@@ -576,12 +579,7 @@
         }
     }
 
-    /**
-     * Encapsulates reading of Java char arrays so that the 1.3 subclass
-     * can override it without exposing internals across packages.  This
-     * is a fix for bug 4367783.
-     */
-    protected void readCharArray(org.omg.CORBA_2_3.portable.InputStream in,
+    private void readCharArray(org.omg.CORBA_2_3.portable.InputStream in,
                                  char[] array,
                                  int offset,
                                  int length)
@@ -795,7 +793,7 @@
         return RepositoryId.cache.getId(repId).isSequence();
     }
 
-    protected String getOutputStreamClassName() {
+    private String getOutputStreamClassName() {
         return "com.sun.corba.se.impl.io.IIOPOutputStream";
     }
 
@@ -843,29 +841,11 @@
     private IIOPOutputStream createOutputStreamBuiltInNoPriv(
         final String name
     ) throws IOException {
-        return
-            name.equals(
-                IIOPOutputStream
-                    .class.getName()
-            ) ?
-            new IIOPOutputStream() :
-
-            name.equals(
-                com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3
-                    .class.getName()
-            ) ?
-            new com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3() :
-
-            name.equals(
-                com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3_1
-                    .class.getName()
-            ) ?
-            new com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3_1() :
-
-            null;
+        return name.equals(IIOPOutputStream.class.getName()) ?
+                new IIOPOutputStream() : null;
     }
 
-    protected String getInputStreamClassName() {
+    private String getInputStreamClassName() {
         return "com.sun.corba.se.impl.io.IIOPInputStream";
     }
 
@@ -913,26 +893,8 @@
      private IIOPInputStream createInputStreamBuiltInNoPriv(
          final String name
      ) throws IOException {
-         return
-             name.equals(
-                 IIOPInputStream
-                     .class.getName()
-             ) ?
-             new IIOPInputStream() :
-
-             name.equals(
-                 com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3
-                     .class.getName()
-             ) ?
-             new com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3() :
-
-             name.equals(
-                 com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3_1
-                     .class.getName()
-             ) ?
-             new com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3_1() :
-
-             null;
+         return name.equals(IIOPInputStream.class.getName()) ?
+                new IIOPInputStream() : null;
      }
 
      /**
@@ -958,12 +920,7 @@
 
     }
 
-    /**
-     * Our JDK 1.3 and JDK 1.3.1 behavior subclasses override this.
-     * The correct behavior is for a Java char to map to a CORBA wchar,
-     * but our older code mapped it to a CORBA char.
-     */
-    protected TCKind getJavaCharTCKind() {
+    TCKind getJavaCharTCKind() {
         return TCKind.tk_wchar;
     }
 }
--- corba/src/share/classes/com/sun/corba/se/impl/io/ValueUtility.java	2012-08-10 09:10:19.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/io/ValueUtility.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -93,6 +93,14 @@
         null,       // tk_abstract_interface 32
     };
 
+    static {
+        sun.corba.SharedSecrets.setJavaCorbaAccess(new sun.corba.JavaCorbaAccess() {
+            public ValueHandlerImpl newValueHandlerImpl() {
+                return ValueHandlerImpl.getInstance();
+            }
+        });
+    }
+
     public static String getSignature(ValueMember member)
         throws ClassNotFoundException {
 
--- corba/src/share/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.java	2012-08-10 09:10:23.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.java	2013-05-05 09:39:34.000000000 -0700
@@ -112,6 +112,9 @@
 import com.sun.corba.se.impl.orbutil.ORBClassLoader;
 import com.sun.corba.se.impl.logging.UtilSystemException;
 import com.sun.corba.se.spi.logging.CORBALogDomains;
+import sun.corba.SharedSecrets;
+import sun.corba.JavaCorbaAccess;
+
 
 /**
  * Provides utility methods that can be used by stubs and ties to
@@ -125,7 +128,8 @@
     // Maps targets to ties.
     private static IdentityHashtable exportedServants = new IdentityHashtable();
 
-    private static ValueHandlerImpl valueHandlerSingleton = new ValueHandlerImpl();
+    private static final ValueHandlerImpl valueHandlerSingleton =
+        SharedSecrets.getJavaCorbaAccess().newValueHandlerImpl();
 
     private UtilSystemException utilWrapper = UtilSystemException.get(
                                                   CORBALogDomains.RPC_ENCODING);
--- corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java	2012-08-10 09:10:31.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java	2013-05-05 09:39:34.000000000 -0700
@@ -840,7 +840,7 @@
         // backward compatability 4365188
         CodeBase cb;
 
-        ValueHandler vh = ORBUtility.createValueHandler(this);
+        ValueHandler vh = ORBUtility.createValueHandler();
 
         cb = (CodeBase)vh.getRunTimeCodeBase();
         return ORBUtility.connectAndGetIOR( this, cb ) ;
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java	2012-08-10 09:10:32.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-import java.util.Hashtable;
-
-/**
- * Implements legacy behavior from before Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPInputStream_1_3 extends com.sun.corba.se.impl.io.IIOPInputStream
-{
-    // The newer version in the io package correctly reads a wstring instead.
-    // This concerns bug 4379597.
-    protected String internalReadUTF(org.omg.CORBA.portable.InputStream stream)
-    {
-        return stream.read_string();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectInputStream.GetField readFields()
-        throws IOException, ClassNotFoundException, NotActiveException {
-        Hashtable fields = (Hashtable)readObject();
-        return new LegacyHookGetFields(fields);
-    }
-
-    public IIOPInputStream_1_3()
-        throws java.io.IOException {
-        super();
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java	2012-08-10 09:10:32.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPInputStream_1_3_1.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-import java.util.Hashtable;
-
-/**
- * Implements legacy behavior from Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPInputStream_1_3_1 extends com.sun.corba.se.impl.io.IIOPInputStream
-{
-    public IIOPInputStream_1_3_1()
-        throws java.io.IOException {
-        super();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectInputStream.GetField readFields()
-        throws IOException, ClassNotFoundException, NotActiveException {
-
-        Hashtable fields = (Hashtable)readObject();
-        return new LegacyHookGetFields(fields);
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java	2012-08-10 09:10:32.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-
-/**
- * Implements legacy behavior from before Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPOutputStream_1_3 extends com.sun.corba.se.impl.io.IIOPOutputStream
-{
-    // We can't assume that the superclass's putFields
-    // member will be non-private.  We must allow
-    // the RI to run on JDK 1.3.1 FCS as well as
-    // the JDK 1.3.1_01 patch.
-    private ObjectOutputStream.PutField putFields_1_3;
-
-    // The newer version in the io package correctly writes a wstring instead.
-    // This concerns bug 4379597.
-    protected void internalWriteUTF(org.omg.CORBA.portable.OutputStream stream,
-                                    String data)
-    {
-        stream.write_string(data);
-    }
-
-    public IIOPOutputStream_1_3()
-        throws java.io.IOException {
-        super();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectOutputStream.PutField putFields()
-        throws IOException {
-        putFields_1_3 = new LegacyHookPutFields();
-        return putFields_1_3;
-    }
-
-    public void writeFields()
-        throws IOException {
-        putFields_1_3.write(this);
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java	2012-08-10 09:10:32.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/IIOPOutputStream_1_3_1.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.io.*;
-import java.util.Hashtable;
-
-/**
- * Implements legacy behavior from Ladybird to maintain
- * backwards compatibility.
- */
-public class IIOPOutputStream_1_3_1 extends com.sun.corba.se.impl.io.IIOPOutputStream
-{
-    // We can't assume that the superclass's putFields
-    // member will be non-private.  We must allow
-    // the RI to run on JDK 1.3.1 FCS as well as
-    // the JDK 1.3.1_01 patch.
-    private ObjectOutputStream.PutField putFields_1_3_1;
-
-    public IIOPOutputStream_1_3_1()
-        throws java.io.IOException {
-        super();
-    }
-
-    /**
-     * Before JDK 1.3.1_01, the PutField/GetField implementation
-     * actually sent a Hashtable.
-     */
-    public ObjectOutputStream.PutField putFields()
-        throws IOException {
-
-        putFields_1_3_1 = new LegacyHookPutFields();
-        return putFields_1_3_1;
-    }
-
-    public void writeFields()
-        throws IOException {
-
-        putFields_1_3_1.write(this);
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ORBUtility.java	2012-08-10 09:10:33.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ORBUtility.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -160,45 +160,13 @@
     }
 
     /**
-     * Creates the correct ValueHandler for the given ORB,
-     * querying ORBVersion information.  If the ORB or
-     * ORBVersion is null, gets the ValueHandler from
-     * Util.createValueHandler.
+     * Return default ValueHandler
      */
-    public static ValueHandler createValueHandler(ORB orb) {
-
-        if (orb == null)
-            return Util.createValueHandler();
-
-        ORBVersion version = orb.getORBVersion();
-
-        if (version == null)
-            return Util.createValueHandler();
-
-        if (version.equals(ORBVersionFactory.getOLD()))
-            return new ValueHandlerImpl_1_3();
-        if (version.equals(ORBVersionFactory.getNEW()))
-            return new ValueHandlerImpl_1_3_1();
-
+    public static ValueHandler createValueHandler() {
         return Util.createValueHandler();
     }
 
     /**
-     * Returns true if the given ORB could accurately be determined to be a
-     * Kestrel or earlier ORB.  Note: If passed the ORBSingleton, this will return
-     * false.
-     */
-    public static boolean isLegacyORB(ORB orb)
-    {
-        try {
-            ORBVersion currentORB = orb.getORBVersion();
-            return currentORB.equals( ORBVersionFactory.getOLD() ) ;
-        } catch (SecurityException se) {
-            return false;
-        }
-    }
-
-    /**
      * Returns true if it was accurately determined that the remote ORB is
      * a foreign (non-JavaSoft) ORB.  Note:  If passed the ORBSingleton, this
      * will return false.
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java	2012-08-10 09:10:33.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1119,8 +1119,8 @@
     private boolean hasExternalizableBlockData;
     Method writeObjectMethod;
     Method readObjectMethod;
-    private Method writeReplaceObjectMethod;
-    private Method readResolveObjectMethod;
+    private transient Method writeReplaceObjectMethod;
+    private transient Method readResolveObjectMethod;
 
     /*
      * ObjectStreamClass_1_3_1 that this one was built from.
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java	2012-08-10 09:10:33.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import org.omg.CORBA.ORB;
-import java.io.Serializable;
-import java.util.Hashtable;
-import java.net.MalformedURLException;
-import com.sun.corba.se.impl.io.TypeMismatchException;
-import com.sun.corba.se.impl.util.RepositoryId;
-
-/**
- * Delegates to the RepositoryId_1_3 implementation in
- * com.sun.corba.se.impl.orbutil.  This is necessary to
- * overcome the fact that many of RepositoryId's methods
- * are static.
- */
-public final class RepIdDelegator_1_3
-    implements RepositoryIdStrings,
-               RepositoryIdUtility,
-               RepositoryIdInterface
-{
-    // RepositoryIdFactory methods
-
-    public String createForAnyType(Class type) {
-        return RepositoryId_1_3.createForAnyType(type);
-    }
-
-    public String createForJavaType(Serializable ser)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3.createForJavaType(ser);
-    }
-
-    public String createForJavaType(Class clz)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3.createForJavaType(clz);
-    }
-
-    public String createSequenceRepID(java.lang.Object ser) {
-        return RepositoryId_1_3.createSequenceRepID(ser);
-    }
-
-    public String createSequenceRepID(Class clazz) {
-        return RepositoryId_1_3.createSequenceRepID(clazz);
-    }
-
-    public RepositoryIdInterface getFromString(String repIdString) {
-        return new RepIdDelegator_1_3(RepositoryId_1_3.cache.getId(repIdString));
-    }
-
-    // RepositoryIdUtility methods
-
-    public boolean isChunkedEncoding(int valueTag) {
-        return RepositoryId.isChunkedEncoding(valueTag);
-    }
-
-    public boolean isCodeBasePresent(int valueTag) {
-        return RepositoryId.isCodeBasePresent(valueTag);
-    }
-
-    public String getClassDescValueRepId() {
-        return RepositoryId_1_3.kClassDescValueRepID;
-    }
-
-    public String getWStringValueRepId() {
-        return RepositoryId_1_3.kWStringValueRepID;
-    }
-
-    public int getTypeInfo(int valueTag) {
-        return RepositoryId.getTypeInfo(valueTag);
-    }
-
-    public int getStandardRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked_NoRep;
-    }
-
-    public int getCodeBaseRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked_NoRep;
-    }
-
-    public int getStandardRMIChunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked;
-    }
-
-    public int getCodeBaseRMIChunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked;
-    }
-
-    public int getStandardRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked;
-    }
-
-    public int getCodeBaseRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked;
-    }
-
-    public int getStandardRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked_NoRep;
-    }
-
-    public int getCodeBaseRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked_NoRep;
-    }
-
-    // RepositoryIdInterface methods
-
-    public Class getClassFromType() throws ClassNotFoundException {
-        return delegate.getClassFromType();
-    }
-
-    public Class getClassFromType(String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(codebaseURL);
-    }
-
-    public Class getClassFromType(Class expectedType,
-                                  String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(expectedType, codebaseURL);
-    }
-
-    public String getClassName() {
-        return delegate.getClassName();
-    }
-
-    // Constructor used for factory/utility cases
-    public RepIdDelegator_1_3() {}
-
-    // Constructor used by getIdFromString.  All non-static
-    // RepositoryId methods will use the provided delegate.
-    private RepIdDelegator_1_3(RepositoryId_1_3 _delegate) {
-        this.delegate = _delegate;
-    }
-
-    private RepositoryId_1_3 delegate = null;
-
-    public String toString() {
-        if (delegate != null)
-            return delegate.toString();
-        else
-            return this.getClass().getName();
-    }
-
-    public boolean equals(Object obj) {
-        if (delegate != null)
-            return delegate.equals(obj);
-        else
-            return super.equals(obj);
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java	2012-08-10 09:10:34.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator_1_3_1.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import org.omg.CORBA.ORB;
-import java.io.Serializable;
-import java.util.Hashtable;
-import java.net.MalformedURLException;
-import com.sun.corba.se.impl.io.TypeMismatchException;
-import com.sun.corba.se.impl.util.RepositoryId;
-
-/**
- * Delegates to the RepositoryId_1_3_1 implementation in
- * com.sun.corba.se.impl.orbutil.  This is necessary to
- * overcome the fact that many of RepositoryId's methods
- * are static.
- */
-public final class RepIdDelegator_1_3_1
-    implements RepositoryIdStrings,
-               RepositoryIdUtility,
-               RepositoryIdInterface
-{
-    // RepositoryIdFactory methods
-
-    public String createForAnyType(Class type) {
-        return RepositoryId_1_3_1.createForAnyType(type);
-    }
-
-    public String createForJavaType(Serializable ser)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3_1.createForJavaType(ser);
-    }
-
-    public String createForJavaType(Class clz)
-        throws TypeMismatchException
-    {
-        return RepositoryId_1_3_1.createForJavaType(clz);
-    }
-
-    public String createSequenceRepID(java.lang.Object ser) {
-        return RepositoryId_1_3_1.createSequenceRepID(ser);
-    }
-
-    public String createSequenceRepID(Class clazz) {
-        return RepositoryId_1_3_1.createSequenceRepID(clazz);
-    }
-
-    public RepositoryIdInterface getFromString(String repIdString) {
-        return new RepIdDelegator_1_3_1(RepositoryId_1_3_1.cache.getId(repIdString));
-    }
-
-    // RepositoryIdUtility methods
-
-    public boolean isChunkedEncoding(int valueTag) {
-        return RepositoryId.isChunkedEncoding(valueTag);
-    }
-
-    public boolean isCodeBasePresent(int valueTag) {
-        return RepositoryId.isCodeBasePresent(valueTag);
-    }
-
-    public String getClassDescValueRepId() {
-        return RepositoryId_1_3_1.kClassDescValueRepID;
-    }
-
-    public String getWStringValueRepId() {
-        return RepositoryId_1_3_1.kWStringValueRepID;
-    }
-
-    public int getTypeInfo(int valueTag) {
-        return RepositoryId.getTypeInfo(valueTag);
-    }
-
-    public int getStandardRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked_NoRep;
-    }
-
-    public int getCodeBaseRMIChunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked_NoRep;
-    }
-
-    public int getStandardRMIChunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIChunked;
-    }
-
-    public int getCodeBaseRMIChunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIChunked;
-    }
-
-    public int getStandardRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked;
-    }
-
-    public int getCodeBaseRMIUnchunkedId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked;
-    }
-
-    public int getStandardRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_StandardRMIUnchunked_NoRep;
-    }
-
-    public int getCodeBaseRMIUnchunkedNoRepStrId() {
-        return RepositoryId.kPreComputed_CodeBaseRMIUnchunked_NoRep;
-    }
-
-    // RepositoryIdInterface methods
-
-    public Class getClassFromType() throws ClassNotFoundException {
-        return delegate.getClassFromType();
-    }
-
-    public Class getClassFromType(String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(codebaseURL);
-    }
-
-    public Class getClassFromType(Class expectedType,
-                                  String codebaseURL)
-        throws ClassNotFoundException, MalformedURLException
-    {
-        return delegate.getClassFromType(expectedType, codebaseURL);
-    }
-
-    public String getClassName() {
-        return delegate.getClassName();
-    }
-
-    // Constructor used for factory/utility cases
-    public RepIdDelegator_1_3_1() {}
-
-    // Constructor used by getIdFromString.  All non-static
-    // RepositoryId methods will use the provided delegate.
-    private RepIdDelegator_1_3_1(RepositoryId_1_3_1 _delegate) {
-        this.delegate = _delegate;
-    }
-
-    private RepositoryId_1_3_1 delegate = null;
-
-    public String toString() {
-        if (delegate != null)
-            return delegate.toString();
-        else
-            return this.getClass().getName();
-    }
-
-    public boolean equals(Object obj) {
-        if (delegate != null)
-            return delegate.equals(obj);
-        else
-            return super.equals(obj);
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java	2012-08-10 09:10:34.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-/*
- * Licensed Materials - Property of IBM
- * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
- *
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.Stack;
-import java.util.Hashtable;
-import java.util.EmptyStackException;
-import java.util.Enumeration;
-
-// Really limited pool - in this case just creating several at a time...
-class RepositoryIdPool_1_3 extends Stack {
-
-    private static int MAX_CACHE_SIZE = 4;
-    private RepositoryIdCache_1_3 cache;
-
-    public final synchronized RepositoryId_1_3 popId() {
-
-        try {
-            return (RepositoryId_1_3)super.pop();
-        }
-        catch(EmptyStackException e) {
-            increasePool(5);
-            return (RepositoryId_1_3)super.pop();
-        }
-
-    }
-
-    // Pool management
-    final void increasePool(int size) {
-        //if (cache.size() <= MAX_CACHE_SIZE)
-        for (int i = size; i > 0; i--)
-            push(new RepositoryId_1_3());
-        /*
-          // _REVISIT_ This will not work w/out either thread tracing or weak references.  I am
-          // betting that thread tracing almost completely negates benefit of reuse.  Until either
-          // 1.2 only inclusion or proof to the contrary, I'll leave it this way...
-          else {
-          int numToReclaim = cache.size() / 2;
-          Enumeration keys = cache.keys();
-          Enumeration elements = cache.elements();
-          for (int i = numToReclaim; i > 0; i--) {
-          Object key = keys.nextElement();
-          Object element = elements.nextElement();
-
-          push(element);
-          cache.remove(key);
-          }
-          }
-        */
-    }
-
-    final void setCaches(RepositoryIdCache_1_3 cache) {
-        this.cache = cache;
-    }
-
-}
-
-public class RepositoryIdCache_1_3 extends Hashtable {
-
-    private RepositoryIdPool_1_3 pool = new RepositoryIdPool_1_3();
-
-    public RepositoryIdCache_1_3() {
-        pool.setCaches(this);
-    }
-
-    public final synchronized RepositoryId_1_3 getId(String key) {
-        RepositoryId_1_3 repId = (RepositoryId_1_3)super.get(key);
-
-        if (repId != null)
-            return repId;
-        else {
-            //repId = pool.popId().init(key);
-            repId = new RepositoryId_1_3(key);
-            put(key, repId);
-            return repId;
-        }
-
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java	2012-08-10 09:10:34.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdCache_1_3_1.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.Stack;
-import java.util.Hashtable;
-import java.util.EmptyStackException;
-import java.util.Enumeration;
-
-// Really limited pool - in this case just creating several at a time...
-class RepositoryIdPool_1_3_1 extends Stack {
-
-    private static int MAX_CACHE_SIZE = 4;
-    private RepositoryIdCache_1_3_1 cache;
-
-    public final synchronized RepositoryId_1_3_1 popId() {
-
-        try {
-            return (RepositoryId_1_3_1)super.pop();
-        }
-        catch(EmptyStackException e) {
-            increasePool(5);
-            return (RepositoryId_1_3_1)super.pop();
-        }
-
-    }
-
-    // Pool management
-    final void increasePool(int size) {
-        //if (cache.size() <= MAX_CACHE_SIZE)
-        for (int i = size; i > 0; i--)
-            push(new RepositoryId_1_3_1());
-        /*
-          // _REVISIT_ This will not work w/out either thread tracing or weak references.  I am
-          // betting that thread tracing almost completely negates benefit of reuse.  Until either
-          // 1.2 only inclusion or proof to the contrary, I'll leave it this way...
-          else {
-          int numToReclaim = cache.size() / 2;
-          Enumeration keys = cache.keys();
-          Enumeration elements = cache.elements();
-          for (int i = numToReclaim; i > 0; i--) {
-          Object key = keys.nextElement();
-          Object element = elements.nextElement();
-
-          push(element);
-          cache.remove(key);
-          }
-          }
-        */
-    }
-
-    final void setCaches(RepositoryIdCache_1_3_1 cache) {
-        this.cache = cache;
-    }
-
-}
-
-public class RepositoryIdCache_1_3_1 extends Hashtable {
-
-    private RepositoryIdPool_1_3_1 pool = new RepositoryIdPool_1_3_1();
-
-    public RepositoryIdCache_1_3_1() {
-        pool.setCaches(this);
-    }
-
-    public final synchronized RepositoryId_1_3_1 getId(String key) {
-        RepositoryId_1_3_1 repId = (RepositoryId_1_3_1)super.get(key);
-
-        if (repId != null)
-            return repId;
-        else {
-            //repId = pool.popId().init(key);
-            repId = new RepositoryId_1_3_1(key);
-            put(key, repId);
-            return repId;
-        }
-
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java	2012-08-10 09:10:34.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.java	2013-05-05 09:39:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,12 +30,6 @@
 
 public abstract class RepositoryIdFactory
 {
-    private static final RepIdDelegator_1_3 legacyDelegator
-        = new RepIdDelegator_1_3();
-
-    private static final RepIdDelegator_1_3_1 ladybirdDelegator
-        = new RepIdDelegator_1_3_1();
-
     private static final RepIdDelegator currentDelegator
         = new RepIdDelegator();
 
@@ -48,29 +42,6 @@
     }
 
     /**
-     * Checks the version of the ORB and returns the appropriate
-     * RepositoryIdStrings instance.
-     */
-    public static RepositoryIdStrings getRepIdStringsFactory(ORB orb)
-    {
-        if (orb != null) {
-            switch (orb.getORBVersion().getORBType()) {
-                case ORBVersion.NEWER:
-                case ORBVersion.FOREIGN:
-                case ORBVersion.JDK1_3_1_01:
-                    return currentDelegator;
-                case ORBVersion.OLD:
-                    return legacyDelegator;
-                case ORBVersion.NEW:
-                    return ladybirdDelegator;
-                default:
-                    return currentDelegator;
-            }
-        } else
-            return currentDelegator;
-    }
-
-    /**
      * Returns the latest version RepositoryIdUtility instance
      */
     public static RepositoryIdUtility getRepIdUtility()
@@ -78,26 +49,4 @@
         return currentDelegator;
     }
 
-    /**
-     * Checks the version of the ORB and returns the appropriate
-     * RepositoryIdUtility instance.
-     */
-    public static RepositoryIdUtility getRepIdUtility(ORB orb)
-    {
-        if (orb != null) {
-            switch (orb.getORBVersion().getORBType()) {
-                case ORBVersion.NEWER:
-                case ORBVersion.FOREIGN:
-                case ORBVersion.JDK1_3_1_01:
-                    return currentDelegator;
-                case ORBVersion.OLD:
-                    return legacyDelegator;
-                case ORBVersion.NEW:
-                    return ladybirdDelegator;
-                default:
-                    return currentDelegator;
-            }
-        } else
-            return currentDelegator;
-    }
 }
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java	2012-08-10 09:10:34.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,990 +0,0 @@
-/*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-/*
- * Licensed Materials - Property of IBM
- * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
- *
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.StringTokenizer;
-import java.util.Hashtable;
-import java.io.IOException;
-import java.lang.reflect.Method;
-
-// Imports for using codebase URL to load class
-import java.net.MalformedURLException;
-import org.omg.CORBA.portable.ValueBase;
-import org.omg.CORBA.portable.IDLEntity;
-
-import com.sun.corba.se.impl.util.JDKBridge;
-import com.sun.corba.se.impl.util.Utility;
-import com.sun.corba.se.impl.util.PackagePrefixChecker;
-import com.sun.corba.se.impl.util.IdentityHashtable;
-import com.sun.corba.se.impl.io.ObjectStreamClass;
-
-import javax.rmi.CORBA.Util;
-
-// keeping the original RepositoryId class that was shipped in
-// JDK 1.3.  It has interoperability bugs
-
-public class RepositoryId_1_3 {
-
-    // Legal IDL Identifier characters (1 = legal). Note
-    // that '.' (2E) is marked as legal even though it is
-    // not legal in IDL. This allows us to treat a fully
-    // qualified Java name with '.' package separators
-    // uniformly, and is safe because that is the only
-    // legal use of '.' in a Java name.
-
-    public static final RepositoryIdCache_1_3 cache = new RepositoryIdCache_1_3();
-    private static final byte[] IDL_IDENTIFIER_CHARS = {
-
-        // 0 1 2 3  4 5 6 7  8 9 a b  c d e f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 00-0f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 10-1f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0, // 20-2f
-        1,1,1,1, 1,1,1,1, 1,1,0,0, 0,0,0,0, // 30-3f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 40-4f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,1, // 50-5f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 60-6f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,0, // 70-7f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 80-8f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 90-9f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // a0-af
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // b0-bf
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // c0-cf
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // d0-df
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // e0-ef
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // f0-ff
-    };
-
-    private static String defaultServerURL = null;
-    private static boolean useCodebaseOnly = false;
-
-    static {
-        if (defaultServerURL == null)
-            defaultServerURL = (String)JDKBridge.getLocalCodebase();
-        useCodebaseOnly = JDKBridge.useCodebaseOnly();
-
-    }
-
-    private static IdentityHashtable classToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classIDLToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classSeqToRepStr = new IdentityHashtable();
-
-    private static IdentityHashtable repStrToByteArray = new IdentityHashtable();
-    private static Hashtable repStrToClass = new Hashtable();
-
-    private String repId = null;
-    private boolean isSupportedFormat = true;
-    private String typeString = null;
-    private String versionString = null;
-    private boolean isSequence = false;
-    private boolean isRMIValueType = false;
-    private boolean isIDLType = false;
-    private String completeClassName = null;
-    private String unqualifiedName = null;
-    private String definedInId = null;
-    private Class clazz = null;
-    private String suid = null, actualSuid = null;
-    private long suidLong = ObjectStreamClass.kDefaultUID, actualSuidLong = ObjectStreamClass.kDefaultUID;
-
-    // Repository ID fragments
-    private static final String kValuePrefix = "RMI:";
-    private static final String kIDLPrefix = "IDL:";
-    private static final String kIDLNamePrefix = "omg.org/";
-    private static final String kIDLClassnamePrefix = "org.omg.";
-    private static final String kSequencePrefix = "[";
-    private static final String kCORBAPrefix = "CORBA/";
-    private static final String kArrayPrefix = kValuePrefix + kSequencePrefix + kCORBAPrefix;
-    private static final int kValuePrefixLength = kValuePrefix.length();
-    private static final int kIDLPrefixLength = kIDLPrefix.length();
-    private static final int kSequencePrefixLength = kSequencePrefix.length();
-    private static final String kInterfaceHashCode = ":0000000000000000";
-    private static final String kInterfaceOnlyHashStr = "0000000000000000";
-    private static final String kExternalizableHashStr = "0000000000000001";
-
-    // Value tag utility methods and constants
-    public static final int kInitialValueTag= 0x7fffff00;
-    public static final int kNoTypeInfo = 0;
-    public static final int kSingleRepTypeInfo = 0x02;
-    public static final int  kPartialListTypeInfo = 0x06;
-    public static final int  kChunkedMask = 0x08;
-
-    // Public, well known repository IDs
-
-    // _REVISIT_ : A table structure with a good search routine for all of this
-    // would be more efficient and easier to maintain...
-
-    // String
-    public static final String kWStringValueVersion = "1.0";
-    public static final String kWStringValueHash = ":"+kWStringValueVersion;
-    public static final String kWStringStubValue = "WStringValue";
-    public static final String kWStringTypeStr = "omg.org/CORBA/"+kWStringStubValue;
-    public static final String kWStringValueRepID = kIDLPrefix + kWStringTypeStr + kWStringValueHash;
-
-    // Any
-    public static final String kAnyRepID = kIDLPrefix + "omg.org/CORBA/Any";
-
-    // Class
-    public static final String kClassDescValueHash = ":" + Long.toHexString(
-       ObjectStreamClass.getSerialVersionUID(javax.rmi.CORBA.ClassDesc.class));
-    public static final String kClassDescStubValue = "ClassDesc";
-    public static final String kClassDescTypeStr = "javax.rmi.CORBA."+kClassDescStubValue;
-    public static final String kClassDescValueRepID = kValuePrefix + kClassDescTypeStr + kClassDescValueHash;
-
-    // Object
-    public static final String kObjectValueHash = ":1.0";
-    public static final String kObjectStubValue = "Object";
-
-    // Sequence
-    public static final String kSequenceValueHash = ":1.0";
-    public static final String kPrimitiveSequenceValueHash = ":0000000000000000";
-
-    // Serializable
-    public static final String kSerializableValueHash = ":1.0";
-    public static final String kSerializableStubValue = "Serializable";
-
-    // Externalizable
-    public static final String kExternalizableValueHash = ":1.0";
-    public static final String kExternalizableStubValue = "Externalizable";
-
-    // Remote (The empty string is used for java.rmi.Remote)
-    public static final String kRemoteValueHash = "";
-    public static final String kRemoteStubValue = "";
-    public static final String kRemoteTypeStr = "";
-    public static final String kRemoteValueRepID = "";
-
-    private static final Hashtable kSpecialArrayTypeStrings = new Hashtable();
-
-    static {
-        kSpecialArrayTypeStrings.put("CORBA.WStringValue", new StringBuffer(java.lang.String.class.getName()));
-        kSpecialArrayTypeStrings.put("javax.rmi.CORBA.ClassDesc", new StringBuffer(java.lang.Class.class.getName()));
-        kSpecialArrayTypeStrings.put("CORBA.Object", new StringBuffer(java.rmi.Remote.class.getName()));
-
-    }
-
-    private static final Hashtable kSpecialCasesRepIDs = new Hashtable();
-
-    static {
-        kSpecialCasesRepIDs.put(java.lang.String.class, kWStringValueRepID);
-        kSpecialCasesRepIDs.put(java.lang.Class.class, kClassDescValueRepID);
-        kSpecialCasesRepIDs.put(java.rmi.Remote.class, kRemoteValueRepID);
-    }
-
-    private static final Hashtable kSpecialCasesStubValues = new Hashtable();
-
-    static {
-        kSpecialCasesStubValues.put(java.lang.String.class, kWStringStubValue);
-        kSpecialCasesStubValues.put(java.lang.Class.class, kClassDescStubValue);
-        kSpecialCasesStubValues.put(java.lang.Object.class, kObjectStubValue);
-        kSpecialCasesStubValues.put(java.io.Serializable.class, kSerializableStubValue);
-        kSpecialCasesStubValues.put(java.io.Externalizable.class, kExternalizableStubValue);
-        kSpecialCasesStubValues.put(java.rmi.Remote.class, kRemoteStubValue);
-    }
-
-
-    private static final Hashtable kSpecialCasesVersions = new Hashtable();
-
-    static {
-        kSpecialCasesVersions.put(java.lang.String.class, kWStringValueHash);
-        kSpecialCasesVersions.put(java.lang.Class.class, kClassDescValueHash);
-        kSpecialCasesVersions.put(java.lang.Object.class, kObjectValueHash);
-        kSpecialCasesVersions.put(java.io.Serializable.class, kSerializableValueHash);
-        kSpecialCasesVersions.put(java.io.Externalizable.class, kExternalizableValueHash);
-        kSpecialCasesVersions.put(java.rmi.Remote.class, kRemoteValueHash);
-    }
-
-    private static final Hashtable kSpecialCasesClasses = new Hashtable();
-
-    static {
-        kSpecialCasesClasses.put(kWStringTypeStr, java.lang.String.class);
-        kSpecialCasesClasses.put(kClassDescTypeStr, java.lang.Class.class);
-        kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-
-        kSpecialCasesClasses.put("org.omg.CORBA.WStringValue", java.lang.String.class);
-        kSpecialCasesClasses.put("javax.rmi.CORBA.ClassDesc", java.lang.Class.class);
-        //kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-    }
-
-    private static final Hashtable kSpecialCasesArrayPrefix = new Hashtable();
-
-    static {
-        kSpecialCasesArrayPrefix.put(java.lang.String.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-        kSpecialCasesArrayPrefix.put(java.lang.Class.class, kValuePrefix + kSequencePrefix + "javax/rmi/CORBA/");
-        kSpecialCasesArrayPrefix.put(java.lang.Object.class, kValuePrefix + kSequencePrefix + "java/lang/");
-        kSpecialCasesArrayPrefix.put(java.io.Serializable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.io.Externalizable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.rmi.Remote.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-    }
-
-    private static final Hashtable kSpecialPrimitives = new Hashtable();
-
-    static {
-        kSpecialPrimitives.put("int","long");
-        kSpecialPrimitives.put("long","longlong");
-        kSpecialPrimitives.put("byte","octet");
-    }
-
-    /**
-     * Used to convert ascii to hex.
-     */
-    private static final byte ASCII_HEX[] =     {
-        (byte)'0',
-        (byte)'1',
-        (byte)'2',
-        (byte)'3',
-        (byte)'4',
-        (byte)'5',
-        (byte)'6',
-        (byte)'7',
-        (byte)'8',
-        (byte)'9',
-        (byte)'A',
-        (byte)'B',
-        (byte)'C',
-        (byte)'D',
-        (byte)'E',
-        (byte)'F',
-    };
-
-
-    // Interface Rep ID Strings
-    public static final String kjava_rmi_Remote = createForAnyType(java.rmi.Remote.class);
-    public static final String korg_omg_CORBA_Object = createForAnyType(org.omg.CORBA.Object.class);
-
-    // Dummy arguments for getIdFromHelper method
-    public static final Class kNoParamTypes[] ={};
-    public static final Object kNoArgs[] = {};
-
-
-    RepositoryId_1_3(){}
-
-    RepositoryId_1_3(String aRepId){
-        init(aRepId);
-    }
-
-    RepositoryId_1_3 init(String aRepId){
-
-        this.repId = aRepId;
-
-        // Special case for remote
-        if (aRepId.length() == 0) {
-            clazz = java.rmi.Remote.class;
-            typeString = "";
-            isRMIValueType = true;
-            suid = kInterfaceOnlyHashStr;
-            return this;
-        }
-        else if (aRepId.equals(kWStringValueRepID)) {
-            clazz = java.lang.String.class;
-            typeString = kWStringTypeStr;
-            isIDLType = true;
-            versionString = kWStringValueVersion;
-            return this;
-        }
-        else {
-
-        String repId = convertFromISOLatin1(aRepId);
-
-        versionString = repId.substring(repId.indexOf(':', repId.indexOf(':')+1));
-        if (repId.startsWith(kIDLPrefix)) {
-            typeString =
-                repId.substring(kIDLPrefixLength, repId.indexOf(':', kIDLPrefixLength));
-            isIDLType = true;
-            if (typeString.startsWith(kIDLNamePrefix))
-                completeClassName = kIDLClassnamePrefix +
-                    typeString.substring(kIDLNamePrefix.length()).replace('/','.');
-            else completeClassName = typeString.replace('/','.');
-
-        }
-        else if (repId.startsWith(kValuePrefix)) {
-            typeString =
-                repId.substring(kValuePrefixLength, repId.indexOf(':', kValuePrefixLength));
-            isRMIValueType = true;
-
-            if (versionString.indexOf('.') == -1) {
-                    actualSuid = versionString.substring(1);
-                    suid = actualSuid;  // default if not explicitly specified
-
-                    if (actualSuid.indexOf(':') != -1){
-                    // we have a declared hash also
-                        int pos = actualSuid.indexOf(':')+1;
-                        // actualSuid = suid.substring(pos);
-                        // suid = suid.substring(0, pos-1);
-                        suid = actualSuid.substring(pos);
-                        actualSuid = actualSuid.substring(0, pos-1);
-                }
-
-            }
-            else {
-                    // _REVISIT_ : Special case version failure ?
-            }
-        }
-        else isSupportedFormat = false;
-
-        if (typeString.startsWith(kSequencePrefix)) {
-            isSequence = true;
-        }
-
-
-        return this;
-    }
-    }
-
-    public final String getUnqualifiedName() {
-        if (unqualifiedName == null){
-            String className = getClassName();
-            int index = (className != null) ? className.lastIndexOf('.') : -1;
-            if (index == -1){
-                unqualifiedName = className;
-                definedInId = "IDL::1.0";
-            }
-            else {
-                unqualifiedName = className.substring(index);
-                definedInId = "IDL:" + className.substring(0, index).replace('.','/') + ":1.0";
-            }
-        }
-
-        return unqualifiedName;
-    }
-
-    public final String getDefinedInId() {
-        if (definedInId == null){
-            getUnqualifiedName();
-        }
-
-        return definedInId;
-    }
-
-    public final String getTypeString() {
-        return typeString;
-    }
-
-    public final String getVersionString() {
-        return versionString;
-    }
-
-    public final String getSerialVersionUID() {
-        return suid;
-    }
-
-    public final String getActualSerialVersionUID() {
-        return actualSuid;
-    }
-    public final long getSerialVersionUIDAsLong() {
-        return suidLong;
-    }
-
-    public final long getActualSerialVersionUIDAsLong() {
-        return actualSuidLong;
-    }
-
-    public final boolean isRMIValueType() {
-        return isRMIValueType;
-    }
-
-    public final boolean isIDLType() {
-        return isIDLType;
-    }
-
-    public final String getRepositoryId() {
-        return repId;
-    }
-
-    public static byte[] getByteArray(String repStr) {
-        synchronized (repStrToByteArray){
-            return (byte[]) repStrToByteArray.get(repStr);
-        }
-    }
-
-    public static void setByteArray(String repStr, byte[] repStrBytes) {
-        synchronized (repStrToByteArray){
-            repStrToByteArray.put(repStr, repStrBytes);
-        }
-    }
-
-    public final boolean isSequence() {
-        return isSequence;
-    }
-
-    public final boolean isSupportedFormat() {
-        return isSupportedFormat;
-    }
-
-
-    // This method will return the classname from the typestring OR if the classname turns out to be
-    // a special class "pseudo" name, then the matching real classname is returned.
-    public final String getClassName() {
-
-        if (isRMIValueType)
-            return typeString;
-        else if (isIDLType)
-            return completeClassName;
-        else return null;
-
-    }
-
-    // This method calls getClazzFromType() and falls back to the repStrToClass
-    // cache if no class was found.  It's used where any class matching the
-    // given repid is an acceptable result.
-    public final Class getAnyClassFromType() throws ClassNotFoundException {
-        try {
-            return getClassFromType();
-        } catch (ClassNotFoundException cnfe) {
-            Class clz = (Class)repStrToClass.get(repId);
-            if (clz != null)
-                return clz;
-            else
-                throw cnfe;
-        }
-    }
-
-    public final Class getClassFromType()
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        }
-        else
-            {
-                try{
-                    return Util.loadClass(getClassName(), null, null);
-                }
-                catch(ClassNotFoundException cnfe){
-                    if (defaultServerURL != null) {
-                        try{
-                            return getClassFromType(defaultServerURL);
-                        }
-                        catch(MalformedURLException mue){
-                            throw cnfe;
-                        }
-                    }
-                    else throw cnfe;
-                }
-            }
-
-    }
-
-    public final Class getClassFromType(Class expectedType, String codebase)
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        } else {
-            ClassLoader expectedTypeClassLoader = (expectedType == null ? null : expectedType.getClassLoader());
-            return loadClassOfType(getClassName(),
-                                            codebase,
-                                            expectedTypeClassLoader,
-                                            expectedType,
-                                            expectedTypeClassLoader);
-        }
-
-    }
-
-    public final Class getClassFromType(String url)
-        throws ClassNotFoundException, MalformedURLException {
-        return Util.loadClass(getClassName(), url, null);
-    }
-
-    public final String toString() {
-        return repId;
-    }
-
-    private static String createHashString(java.io.Serializable ser) {
-
-        return createHashString(ser.getClass());
-    }
-
-    private static String createHashString(java.lang.Class clazz) {
-
-        if (clazz.isInterface() || !java.io.Serializable.class.isAssignableFrom(clazz))
-            return kInterfaceHashCode;
-
-
-        long actualLong = ObjectStreamClassUtil_1_3.computeStructuralUID(false, clazz);
-        String hash = null;
-        if (actualLong == 0)
-            hash = kInterfaceOnlyHashStr;
-        else if (actualLong == 1)
-            hash = kExternalizableHashStr;
-        else
-            hash = Long.toHexString(actualLong).toUpperCase();
-        while(hash.length() < 16){
-            hash = "0" + hash;
-        }
-
-        long declaredLong = ObjectStreamClassUtil_1_3.computeSerialVersionUID(clazz);
-        String declared = null;
-        if (declaredLong == 0)
-            declared = kInterfaceOnlyHashStr;
-        else if (declaredLong == 1)
-            declared = kExternalizableHashStr;
-        else
-            declared = Long.toHexString(declaredLong).toUpperCase();
-        while (declared.length() < 16){
-            declared = "0" + declared;
-    }
-        hash = hash + ":" + declared;
-
-        return ":" + hash;
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a rep id for a sequence of zero
-     * length.  This would be an error.
-     * @param ser The Java object to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Object ser){
-        return createSequenceRepID(ser.getClass());
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a malformed rep id.
-     * @param clazz The Java class to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Class clazz){
-        synchronized (classSeqToRepStr){
-
-        String repid = (String)classSeqToRepStr.get(clazz);
-        if (repid != null)
-            return repid;
-
-        Class originalClazz = clazz;
-
-        Class type = null;
-        int numOfDims = 0;
-
-        while ((type = clazz.getComponentType()) != null) {
-            numOfDims++;
-            clazz = type;
-        }
-
-        if (clazz.isPrimitive())
-            repid = kValuePrefix + originalClazz.getName() + kPrimitiveSequenceValueHash;
-        else {
-            StringBuffer buf = new StringBuffer();
-            buf.append(kValuePrefix);
-            while(numOfDims-- > 0) {
-                buf.append("[");
-            }
-            buf.append("L");
-            buf.append(convertToISOLatin1(clazz.getName()));
-            buf.append(";");
-            buf.append(createHashString(clazz));
-            repid = buf.toString();
-        }
-        classSeqToRepStr.put(originalClazz,repid);
-        return repid;
-        }
-
-    }
-
-
-    public static String createForSpecialCase(java.lang.Class clazz){
-        if (clazz.isArray()){
-            return createSequenceRepID(clazz);
-        }
-        else {
-            return (String)kSpecialCasesRepIDs.get(clazz);
-        }
-    }
-
-    public static String createForSpecialCase(java.io.Serializable ser){
-        Class clazz = ser.getClass();
-        if (clazz.isArray()){
-            return createSequenceRepID(ser);
-        }
-        else
-            return createForSpecialCase(clazz);
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param ser The Java object to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(java.io.Serializable ser)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr) {
-        String repid = createForSpecialCase(ser);
-        if (repid != null)
-            return repid;
-        Class clazz = ser.getClass();
-        repid = (String)classToRepStr.get(clazz);
-
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clazz.getName()) +
-            createHashString(clazz);
-
-        classToRepStr.put(clazz, repid);
-            repStrToClass.put(repid, clazz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param clz The Java class to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(Class clz)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr){
-        String repid = createForSpecialCase(clz);
-        if (repid != null)
-            return repid;
-
-        repid = (String)classToRepStr.get(clz);
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clz.getName()) +
-            createHashString(clz);
-
-        classToRepStr.put(clz, repid);
-            repStrToClass.put(repid, clz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for an IDL Java Type.
-     * @param ser The IDL Value object to create a repository ID for
-     * @param major The major version number
-     * @param minor The minor version number
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser does not implement the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForIDLType(Class ser, int major, int minor)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classIDLToRepStr){
-        String repid = (String)classIDLToRepStr.get(ser);
-        if (repid != null)
-            return repid;
-
-        repid = kIDLPrefix + convertToISOLatin1(ser.getName()).replace('.','/') +
-            ":" + major + "." + minor;
-        classIDLToRepStr.put(ser, repid);
-        return repid;
-    }
-    }
-
-    private static String getIdFromHelper(Class clazz){
-        try {
-            Class helperClazz = Utility.loadClassForClass(clazz.getName()+"Helper", null,
-                                    clazz.getClassLoader(), clazz, clazz.getClassLoader());
-            Method idMethod = helperClazz.getDeclaredMethod("id", kNoParamTypes);
-            return (String)idMethod.invoke(null, kNoArgs);
-        }
-        catch(java.lang.ClassNotFoundException cnfe)
-            {
-                throw new org.omg.CORBA.MARSHAL(cnfe.toString());
-            }
-        catch(java.lang.NoSuchMethodException nsme)
-            {
-                throw new org.omg.CORBA.MARSHAL(nsme.toString());
-            }
-        catch(java.lang.reflect.InvocationTargetException ite)
-            {
-                throw new org.omg.CORBA.MARSHAL(ite.toString());
-            }
-        catch(java.lang.IllegalAccessException iae)
-            {
-                throw new org.omg.CORBA.MARSHAL(iae.toString());
-    }
-    }
-
-    /**
-     * Createa a repository ID for the type if it is either a java type
-     * or an IDL type.
-     * @param type The type to create rep. id for
-     * @return The rep. id.
-     **/
-    public static String createForAnyType(Class type) {
-        try{
-            if (type.isArray())
-                return createSequenceRepID(type);
-            else if (IDLEntity.class.isAssignableFrom(type))
-                {
-                    try{
-                        return getIdFromHelper(type);
-                    }
-                    catch(Throwable t) {
-                        return createForIDLType(type, 1, 0);
-                    }
-                }
-            else return createForJavaType(type);
-        }
-        catch(com.sun.corba.se.impl.io.TypeMismatchException e){
-            return null;
-        }
-
-    }
-
-    public static boolean isAbstractBase(Class clazz) {
-        return (clazz.isInterface() &&
-                IDLEntity.class.isAssignableFrom(clazz) &&
-                (!ValueBase.class.isAssignableFrom(clazz)) &&
-                (!org.omg.CORBA.Object.class.isAssignableFrom(clazz)));
-
-    }
-
-    /**
-     * Convert strings with illegal IDL identifier characters.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertToISOLatin1 (String name) {
-
-        int length = name.length();
-        if (length == 0) {
-            return name;
-        }
-        StringBuffer buffer = null;
-
-        for (int i = 0; i < length; i++) {
-
-            char c = name.charAt(i);
-
-            if (c > 255 || IDL_IDENTIFIER_CHARS[c] == 0) {
-
-                // We gotta convert. Have we already started?
-
-                if (buffer == null) {
-
-                    // No, so get set up...
-
-                    buffer = new StringBuffer(name.substring(0,i));
-                }
-
-                // Convert the character into the IDL escape syntax...
-                buffer.append(
-                              "\\U" +
-                              (char)ASCII_HEX[(c & 0xF000) >>> 12] +
-                              (char)ASCII_HEX[(c & 0x0F00) >>> 8] +
-                              (char)ASCII_HEX[(c & 0x00F0) >>> 4] +
-                              (char)ASCII_HEX[(c & 0x000F)]);
-
-            } else {
-                if (buffer != null) {
-                    buffer.append(c);
-                }
-            }
-        }
-
-        if (buffer != null) {
-            name = buffer.toString();
-        }
-
-        return name;
-    }
-
-    /**
-     * Convert strings with ISO Latin 1 escape sequences back to original strings.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertFromISOLatin1 (String name) {
-
-        int index = -1;
-        StringBuffer buf = new StringBuffer(name);
-
-        while ((index = buf.toString().indexOf("\\U")) != -1){
-            String str = "0000" + buf.toString().substring(index+2, index+6);
-
-            // Convert Hexadecimal
-            byte[] buffer = new byte[(str.length() - 4) / 2];
-            for (int i=4, j=0; i < str.length(); i +=2, j++) {
-                buffer[j] = (byte)((ORBUtility.hexOf(str.charAt(i)) << 4) & 0xF0);
-                buffer[j] |= (byte)((ORBUtility.hexOf(str.charAt(i+1)) << 0) & 0x0F);
-            }
-            buf = new StringBuffer(delete(buf.toString(), index, index+6));
-            buf.insert(index, (char)buffer[1]);
-        }
-
-        return buf.toString();
-
-
-    }
-
-    private static String delete(String str, int from, int to)
-    {
-        return str.substring(0, from) + str.substring(to, str.length());
-    }
-
-    private static String replace(String target, String arg, String source)
-    {
-        int i = 0;
-        i = target.indexOf(arg);
-
-        while(i != -1)
-            {
-                String left = target.substring(0, i);
-                String right = target.substring(i+arg.length());
-                target = new String(left+source+right);
-                i = target.indexOf(arg);
-            }
-        return target;
-    }
-
-    /*
-     * Load a class and check that it is assignable to a given type.
-     * @param className the class name.
-     * @param remoteCodebase the codebase to use. May be null.
-     * @param loader the class loader of last resort. May be null.
-     * @param expectedType the expected type. May be null.
-     * @return the loaded class.
-     */
-    private Class loadClassOfType (String className,
-                                  String remoteCodebase,
-                                  ClassLoader loader,
-                                  Class expectedType,
-                                  ClassLoader expectedTypeClassLoader)
-        throws ClassNotFoundException {
-
-        Class loadedClass = null;
-
-        try {
-            //Sequence finding of the stubs according to spec
-            try{
-                //If-else is put here for speed up of J2EE.
-                //According to the OMG spec, the if clause is not dead code.
-                //It can occur if some compiler has allowed generation
-                //into org.omg.stub hierarchy for non-offending
-                //classes. This will encourage people to
-                //produce non-offending class stubs in their own hierarchy.
-                if(!PackagePrefixChecker
-                   .hasOffendingPrefix(PackagePrefixChecker
-                                       .withoutPackagePrefix(className))){
-                    loadedClass = Util.loadClass
-                        (PackagePrefixChecker.withoutPackagePrefix(className),
-                         remoteCodebase,
-                         loader);
-                } else {
-                    loadedClass = Util.loadClass
-                        (className,
-                         remoteCodebase,
-                         loader);
-                }
-            } catch (ClassNotFoundException cnfe) {
-                loadedClass = Util.loadClass
-                    (className,
-                     remoteCodebase,
-                     loader);
-            }
-            if (expectedType == null)
-                return loadedClass;
-        } catch (ClassNotFoundException cnfe) {
-            if (expectedType == null)
-                throw cnfe;
-        }
-
-        // If no class was not loaded, or if the loaded class is not of the
-        // correct type, make a further attempt to load the correct class
-        // using the classloader of the expected type.
-        // _REVISIT_ Is this step necessary, or should the Util,loadClass
-        // algorithm always produce a valid class if the setup is correct?
-        // Does the OMG standard algorithm need to be changed to include
-        // this step?
-        if (loadedClass == null || !expectedType.isAssignableFrom(loadedClass)) {
-            if (expectedType.getClassLoader() != expectedTypeClassLoader)
-                throw new IllegalArgumentException("expectedTypeClassLoader not class loader of expectedType.");
-
-            if (expectedTypeClassLoader != null)
-                loadedClass = expectedTypeClassLoader.loadClass(className);
-            else
-                loadedClass = ORBClassLoader.loadClass(className);
-        }
-
-        return loadedClass;
-    }
-
-    /**
-     * Checks to see if the FullValueDescription should be retrieved.
-     * @exception Throws IOException if suids do not match or if the repositoryID
-     * is not an RMIValueType
-     */
-    public static boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws IOException{
-
-        String clazzRepIDStr = createForAnyType(clazz);
-
-        if (clazzRepIDStr.equals(repositoryID))
-            return false;
-
-        RepositoryId_1_3 targetRepid;
-        RepositoryId_1_3 clazzRepid;
-
-        synchronized(cache) {
-        // to avoid race condition where multiple threads could be
-        // accessing this method, and their access to the cache may
-        // be interleaved giving unexpected results
-
-            targetRepid = cache.getId(repositoryID);
-            clazzRepid = cache.getId(clazzRepIDStr);
-        }
-
-        if ((targetRepid.isRMIValueType()) && (clazzRepid.isRMIValueType())){
-            if (!targetRepid.getSerialVersionUID().equals(clazzRepid.getSerialVersionUID())) {
-
-                String mssg = "Mismatched serialization UIDs : Source (Rep. ID" +
-                    clazzRepid + ") = " +
-                    clazzRepid.getSerialVersionUID() + " whereas Target (Rep. ID " + repositoryID +
-                    ") = " + targetRepid.getSerialVersionUID();
-                throw new IOException(mssg);
-            } else {
-                return true;
-            }
-        } else {
-
-            throw new IOException("The repository ID is not of an RMI value type (Expected ID = " + clazzRepIDStr + "; Received ID = " + repositoryID +")");
-        }
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java	2012-08-10 09:10:34.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/RepositoryId_1_3_1.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,1065 +0,0 @@
-/*
- * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- */
-package com.sun.corba.se.impl.orbutil;
-
-import java.util.StringTokenizer;
-import java.util.Hashtable;
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.net.MalformedURLException;
-import org.omg.CORBA.portable.ValueBase;
-import org.omg.CORBA.portable.IDLEntity;
-
-//d11638 files in the same package, therefore remove their reference
-//import com.sun.corba.se.impl.util.JDKBridge;
-//import com.sun.corba.se.impl.util.IdentityHashtable;
-import com.sun.corba.se.impl.util.JDKBridge;
-import com.sun.corba.se.impl.util.Utility;
-import com.sun.corba.se.impl.util.PackagePrefixChecker;
-import com.sun.corba.se.impl.util.IdentityHashtable;
-
-import javax.rmi.CORBA.Util;
-
-/**
- * Because all methods in RepositoryId are static, we have
- * to duplicate all of this code, freezing it in its 1.3.1
- * form for backwards compatibility.
- *
- * For security reasons, we can't expose enough of
- * io/ObjectStreamClass, so it has to be duplicated in
- * orbutil.
- */
-public class RepositoryId_1_3_1 {
-
-    // Legal IDL Identifier characters (1 = legal). Note
-    // that '.' (2E) is marked as legal even though it is
-    // not legal in IDL. This allows us to treat a fully
-    // qualified Java name with '.' package separators
-    // uniformly, and is safe because that is the only
-    // legal use of '.' in a Java name.
-
-    private static final byte[] IDL_IDENTIFIER_CHARS = {
-
-        // 0 1 2 3  4 5 6 7  8 9 a b  c d e f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 00-0f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 10-1f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0, // 20-2f
-        1,1,1,1, 1,1,1,1, 1,1,0,0, 0,0,0,0, // 30-3f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 40-4f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,1, // 50-5f
-        0,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // 60-6f
-        1,1,1,1, 1,1,1,1, 1,1,1,0, 0,0,0,0, // 70-7f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 80-8f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // 90-9f
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // a0-af
-        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, // b0-bf
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // c0-cf
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // d0-df
-        1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1, // e0-ef
-        0,1,1,1, 1,1,1,0, 1,1,1,1, 1,0,0,1, // f0-ff
-    };
-
-
-    private static final long serialVersionUID = 123456789L;
-
-    private static String defaultServerURL = null;
-    private static boolean useCodebaseOnly = false;
-
-    static {
-        if (defaultServerURL == null)
-            defaultServerURL = (String)JDKBridge.getLocalCodebase();
-        useCodebaseOnly = JDKBridge.useCodebaseOnly();
-
-    }
-
-    private static IdentityHashtable classToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classIDLToRepStr = new IdentityHashtable();
-    private static IdentityHashtable classSeqToRepStr = new IdentityHashtable();
-
-    private static IdentityHashtable repStrToByteArray = new IdentityHashtable();
-    private static Hashtable repStrToClass = new Hashtable();
-
-    private String repId = null;
-    private boolean isSupportedFormat = true;
-    private String typeString = null;
-    private String versionString = null;
-    private boolean isSequence = false;
-    private boolean isRMIValueType = false;
-    private boolean isIDLType = false;
-    private String completeClassName = null;
-    private String unqualifiedName = null;
-    private String definedInId = null;
-    private Class clazz = null;
-    private String suid = null, actualSuid = null;
-    private long suidLong = ObjectStreamClass_1_3_1.kDefaultUID, actualSuidLong = ObjectStreamClass_1_3_1.kDefaultUID;
-
-    // Repository ID fragments
-    private static final String kSequenceKeyword = "seq";
-    private static final String kValuePrefix = "RMI:";
-    private static final String kIDLPrefix = "IDL:";
-    private static final String kIDLNamePrefix = "omg.org/";
-    private static final String kIDLClassnamePrefix = "org.omg.";
-    private static final String kSequencePrefix = "[";
-    private static final String kCORBAPrefix = "CORBA/";
-    private static final String kArrayPrefix = kValuePrefix + kSequencePrefix + kCORBAPrefix;
-    private static final int kValuePrefixLength = kValuePrefix.length();
-    private static final int kIDLPrefixLength = kIDLPrefix.length();
-    private static final int kSequencePrefixLength = kSequencePrefix.length();
-    private static final String kInterfaceHashCode = ":0000000000000000";
-    private static final String kInterfaceOnlyHashStr = "0000000000000000";
-    private static final String kExternalizableHashStr = "0000000000000001";
-
-    // Value tag utility methods and constants
-    public static final int kInitialValueTag= 0x7fffff00;
-    public static final int kNoTypeInfo = 0;
-    public static final int kSingleRepTypeInfo = 0x02;
-    public static final int  kPartialListTypeInfo = 0x06;
-    public static final int  kChunkedMask = 0x08;
-    public static final int kPreComputed_StandardRMIUnchunked = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kSingleRepTypeInfo, false);
-    public static final int kPreComputed_CodeBaseRMIUnchunked = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kSingleRepTypeInfo, false);
-    public static final int kPreComputed_StandardRMIChunked = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kSingleRepTypeInfo, true);
-    public static final int kPreComputed_CodeBaseRMIChunked = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kSingleRepTypeInfo, true);
-
-    public static final int kPreComputed_StandardRMIUnchunked_NoRep = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kNoTypeInfo, false);
-    public static final int kPreComputed_CodeBaseRMIUnchunked_NoRep = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kNoTypeInfo, false);
-    public static final int kPreComputed_StandardRMIChunked_NoRep = RepositoryId_1_3_1.computeValueTag(false, RepositoryId_1_3_1.kNoTypeInfo, true);
-    public static final int kPreComputed_CodeBaseRMIChunked_NoRep = RepositoryId_1_3_1.computeValueTag(true, RepositoryId_1_3_1.kNoTypeInfo, true);
-
-    // Public, well known repository IDs
-
-    // _REVISIT_ : A table structure with a good search routine for all of this
-    // would be more efficient and easier to maintain...
-
-    // String
-    public static final String kWStringValueVersion = "1.0";
-    public static final String kWStringValueHash = ":"+kWStringValueVersion;
-    public static final String kWStringStubValue = "WStringValue";
-    public static final String kWStringTypeStr = "omg.org/CORBA/"+kWStringStubValue;
-    public static final String kWStringValueRepID = kIDLPrefix + kWStringTypeStr + kWStringValueHash;
-
-    // Any
-    public static final String kAnyRepID = kIDLPrefix + "omg.org/CORBA/Any";
-
-    // Class
-    // Anita4: convert to uppercase
-    public static final String kClassDescValueHash = ":" +
-       Long.toHexString(
-       ObjectStreamClass_1_3_1.getActualSerialVersionUID(javax.rmi.CORBA.ClassDesc.class)).toUpperCase() + ":" +
-      Long.toHexString(
-       ObjectStreamClass_1_3_1.getSerialVersionUID(javax.rmi.CORBA.ClassDesc.class)).toUpperCase();
-    public static final String kClassDescStubValue = "ClassDesc";
-    public static final String kClassDescTypeStr = "javax.rmi.CORBA."+kClassDescStubValue;
-    public static final String kClassDescValueRepID = kValuePrefix + kClassDescTypeStr + kClassDescValueHash;
-
-    // Object
-    public static final String kObjectValueHash = ":1.0";
-    public static final String kObjectStubValue = "Object";
-
-    // Sequence
-    public static final String kSequenceValueHash = ":1.0";
-    public static final String kPrimitiveSequenceValueHash = ":0000000000000000";
-
-    // Serializable
-    public static final String kSerializableValueHash = ":1.0";
-    public static final String kSerializableStubValue = "Serializable";
-
-    // Externalizable
-    public static final String kExternalizableValueHash = ":1.0";
-    public static final String kExternalizableStubValue = "Externalizable";
-
-    // Remote (The empty string is used for java.rmi.Remote)
-    public static final String kRemoteValueHash = "";
-    public static final String kRemoteStubValue = "";
-    public static final String kRemoteTypeStr = "";
-    public static final String kRemoteValueRepID = "";
-
-    private static final Hashtable kSpecialArrayTypeStrings = new Hashtable();
-
-    static {
-        kSpecialArrayTypeStrings.put("CORBA.WStringValue", new StringBuffer(java.lang.String.class.getName()));
-        kSpecialArrayTypeStrings.put("javax.rmi.CORBA.ClassDesc", new StringBuffer(java.lang.Class.class.getName()));
-        kSpecialArrayTypeStrings.put("CORBA.Object", new StringBuffer(java.rmi.Remote.class.getName()));
-
-    }
-
-    private static final Hashtable kSpecialCasesRepIDs = new Hashtable();
-
-    static {
-        kSpecialCasesRepIDs.put(java.lang.String.class, kWStringValueRepID);
-        kSpecialCasesRepIDs.put(java.lang.Class.class, kClassDescValueRepID);
-        kSpecialCasesRepIDs.put(java.rmi.Remote.class, kRemoteValueRepID);
-    }
-
-    private static final Hashtable kSpecialCasesStubValues = new Hashtable();
-
-    static {
-        kSpecialCasesStubValues.put(java.lang.String.class, kWStringStubValue);
-        kSpecialCasesStubValues.put(java.lang.Class.class, kClassDescStubValue);
-        kSpecialCasesStubValues.put(java.lang.Object.class, kObjectStubValue);
-        kSpecialCasesStubValues.put(java.io.Serializable.class, kSerializableStubValue);
-        kSpecialCasesStubValues.put(java.io.Externalizable.class, kExternalizableStubValue);
-        kSpecialCasesStubValues.put(java.rmi.Remote.class, kRemoteStubValue);
-    }
-
-
-    private static final Hashtable kSpecialCasesVersions = new Hashtable();
-
-    static {
-        kSpecialCasesVersions.put(java.lang.String.class, kWStringValueHash);
-        kSpecialCasesVersions.put(java.lang.Class.class, kClassDescValueHash);
-        kSpecialCasesVersions.put(java.lang.Object.class, kObjectValueHash);
-        kSpecialCasesVersions.put(java.io.Serializable.class, kSerializableValueHash);
-        kSpecialCasesVersions.put(java.io.Externalizable.class, kExternalizableValueHash);
-        kSpecialCasesVersions.put(java.rmi.Remote.class, kRemoteValueHash);
-    }
-
-    private static final Hashtable kSpecialCasesClasses = new Hashtable();
-
-    static {
-        kSpecialCasesClasses.put(kWStringTypeStr, java.lang.String.class);
-        kSpecialCasesClasses.put(kClassDescTypeStr, java.lang.Class.class);
-        kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-
-        kSpecialCasesClasses.put("org.omg.CORBA.WStringValue", java.lang.String.class);
-        kSpecialCasesClasses.put("javax.rmi.CORBA.ClassDesc", java.lang.Class.class);
-        //kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);
-    }
-
-    private static final Hashtable kSpecialCasesArrayPrefix = new Hashtable();
-
-    static {
-        kSpecialCasesArrayPrefix.put(java.lang.String.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-        kSpecialCasesArrayPrefix.put(java.lang.Class.class, kValuePrefix + kSequencePrefix + "javax/rmi/CORBA/");
-        kSpecialCasesArrayPrefix.put(java.lang.Object.class, kValuePrefix + kSequencePrefix + "java/lang/");
-        kSpecialCasesArrayPrefix.put(java.io.Serializable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.io.Externalizable.class, kValuePrefix + kSequencePrefix + "java/io/");
-        kSpecialCasesArrayPrefix.put(java.rmi.Remote.class, kValuePrefix + kSequencePrefix + kCORBAPrefix);
-    }
-
-    private static final Hashtable kSpecialPrimitives = new Hashtable();
-
-    static {
-        kSpecialPrimitives.put("int","long");
-        kSpecialPrimitives.put("long","longlong");
-        kSpecialPrimitives.put("byte","octet");
-    }
-
-    /**
-     * Used to convert ascii to hex.
-     */
-    private static final byte ASCII_HEX[] =     {
-        (byte)'0',
-        (byte)'1',
-        (byte)'2',
-        (byte)'3',
-        (byte)'4',
-        (byte)'5',
-        (byte)'6',
-        (byte)'7',
-        (byte)'8',
-        (byte)'9',
-        (byte)'A',
-        (byte)'B',
-        (byte)'C',
-        (byte)'D',
-        (byte)'E',
-        (byte)'F',
-    };
-
-
-    // bug fix for 4328952; to eliminate possibility of overriding this
-    // in a subclass.
-    public static final RepositoryIdCache_1_3_1 cache = new RepositoryIdCache_1_3_1();
-
-    // Interface Rep ID Strings
-    public static final String kjava_rmi_Remote = createForAnyType(java.rmi.Remote.class);
-    public static final String korg_omg_CORBA_Object = createForAnyType(org.omg.CORBA.Object.class);
-
-    // Dummy arguments for getIdFromHelper method
-    public static final Class kNoParamTypes[] ={};
-    public static final Object kNoArgs[] = {};
-
-
-    // To create a RepositoryID, use code similar to the following:
-    // RepositoryId.cache.getId( id );
-
-    RepositoryId_1_3_1(){}
-
-    RepositoryId_1_3_1(String aRepId){
-        init(aRepId);
-    }
-
-    RepositoryId_1_3_1 init(String aRepId){
-
-        this.repId = aRepId;
-
-        // Special case for remote
-        if (aRepId.length() == 0) {
-            clazz = java.rmi.Remote.class;
-            typeString = "";
-            isRMIValueType = true;
-            suid = kInterfaceOnlyHashStr;
-            return this;
-        }
-        else if (aRepId.equals(kWStringValueRepID)) {
-            clazz = java.lang.String.class;
-            typeString = kWStringTypeStr;
-            isIDLType = true;
-            // fix where Attempting to obtain a FullValueDescription
-            // for an RMI value type with a String field causes an exception.
-            completeClassName = "java.lang.String";
-            versionString = kWStringValueVersion;
-            return this;
-        }
-        else {
-
-        String repId = convertFromISOLatin1(aRepId);
-
-        versionString = repId.substring(repId.indexOf(':', repId.indexOf(':')+1));
-        if (repId.startsWith(kIDLPrefix)) {
-            typeString =
-                repId.substring(kIDLPrefixLength, repId.indexOf(':', kIDLPrefixLength));
-            isIDLType = true;
-            if (typeString.startsWith(kIDLNamePrefix))
-                completeClassName = kIDLClassnamePrefix +
-                    typeString.substring(kIDLNamePrefix.length()).replace('/','.');
-            else completeClassName = typeString.replace('/','.');
-
-        }
-        else if (repId.startsWith(kValuePrefix)) {
-            typeString =
-                repId.substring(kValuePrefixLength, repId.indexOf(':', kValuePrefixLength));
-            isRMIValueType = true;
-
-            if (versionString.indexOf('.') == -1) {
-                    actualSuid = versionString.substring(1);
-                    suid = actualSuid;  // default if not explicitly specified
-
-                    if (actualSuid.indexOf(':') != -1){
-                    // we have a declared hash also
-                        int pos = actualSuid.indexOf(':')+1;
-                        // actualSuid = suid.substring(pos);
-                        // suid = suid.substring(0, pos-1);
-                        suid = actualSuid.substring(pos);
-                        actualSuid = actualSuid.substring(0, pos-1);
-                }
-
-            }
-            else {
-                    // _REVISIT_ : Special case version failure ?
-            }
-        }
-        else isSupportedFormat = false;
-
-        if (typeString.startsWith(kSequencePrefix)) {
-            isSequence = true;
-        }
-
-
-        return this;
-    }
-    }
-
-    public final String getUnqualifiedName() {
-        if (unqualifiedName == null){
-            String className = getClassName();
-            int index = className.lastIndexOf('.');
-            if (index == -1){
-                unqualifiedName = className;
-                definedInId = "IDL::1.0";
-            }
-            else {
-                unqualifiedName = className.substring(index);
-                definedInId = "IDL:" + className.substring(0, index).replace('.','/') + ":1.0";
-            }
-        }
-
-        return unqualifiedName;
-    }
-
-    public final String getDefinedInId() {
-        if (definedInId == null){
-            getUnqualifiedName();
-        }
-
-        return definedInId;
-    }
-
-    public final String getTypeString() {
-        return typeString;
-    }
-
-    public final String getVersionString() {
-        return versionString;
-    }
-
-    public final String getSerialVersionUID() {
-        return suid;
-    }
-
-    public final String getActualSerialVersionUID() {
-        return actualSuid;
-    }
-    public final long getSerialVersionUIDAsLong() {
-        return suidLong;
-    }
-
-    public final long getActualSerialVersionUIDAsLong() {
-        return actualSuidLong;
-    }
-
-    public final boolean isRMIValueType() {
-        return isRMIValueType;
-    }
-
-    public final boolean isIDLType() {
-        return isIDLType;
-    }
-
-    public final String getRepositoryId() {
-        return repId;
-    }
-
-    public static byte[] getByteArray(String repStr) {
-        synchronized (repStrToByteArray){
-            return (byte[]) repStrToByteArray.get(repStr);
-        }
-    }
-
-    public static void setByteArray(String repStr, byte[] repStrBytes) {
-        synchronized (repStrToByteArray){
-            repStrToByteArray.put(repStr, repStrBytes);
-        }
-    }
-
-    public final boolean isSequence() {
-        return isSequence;
-    }
-
-    public final boolean isSupportedFormat() {
-        return isSupportedFormat;
-    }
-
-
-    // This method will return the classname from the typestring OR if the classname turns out to be
-    // a special class "pseudo" name, then the matching real classname is returned.
-    public final String getClassName() {
-
-        if (isRMIValueType)
-            return typeString;
-        else if (isIDLType)
-            return completeClassName;
-        else return null;
-
-    }
-
-    // This method calls getClazzFromType() and falls back to the repStrToClass
-    // cache if no class was found.  It's used where any class matching the
-    // given repid is an acceptable result.
-    public final Class getAnyClassFromType() throws ClassNotFoundException {
-        try {
-            return getClassFromType();
-        } catch (ClassNotFoundException cnfe) {
-            Class clz = (Class)repStrToClass.get(repId);
-            if (clz != null)
-                return clz;
-            else
-                throw cnfe;
-        }
-    }
-
-    public final Class getClassFromType()
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        }
-        else
-            {
-                try{
-                    return Util.loadClass(getClassName(), null, null);
-                }
-                catch(ClassNotFoundException cnfe){
-                    if (defaultServerURL != null) {
-                        try{
-                            return getClassFromType(defaultServerURL);
-                        }
-                        catch(MalformedURLException mue){
-                            throw cnfe;
-                        }
-                    }
-                    else throw cnfe;
-                }
-            }
-
-    }
-
-    public final Class getClassFromType(Class expectedType, String codebase)
-        throws ClassNotFoundException {
-        if (clazz != null)
-            return clazz;
-
-        Class specialCase = (Class)kSpecialCasesClasses.get(getClassName());
-
-        if (specialCase != null){
-            clazz = specialCase;
-            return specialCase;
-        } else {
-            ClassLoader expectedTypeClassLoader = (expectedType == null ? null : expectedType.getClassLoader());
-            return loadClassOfType(getClassName(),
-                                   codebase,
-                                   expectedTypeClassLoader,
-                                   expectedType,
-                                   expectedTypeClassLoader);
-        }
-
-    }
-
-    public final Class getClassFromType(String url)
-        throws ClassNotFoundException, MalformedURLException {
-        return Util.loadClass(getClassName(), url, null);
-    }
-
-    public final String toString() {
-        return repId;
-    }
-
-    /**
-     * Checks to see if the FullValueDescription should be retrieved.
-     * @exception Throws IOException if suids do not match or if the repositoryID
-     * is not an RMIValueType
-     */
-    public static boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws IOException{
-
-        String clazzRepIDStr = createForAnyType(clazz);
-
-        if (clazzRepIDStr.equals(repositoryID))
-            return false;
-
-        RepositoryId_1_3_1 targetRepid;
-        RepositoryId_1_3_1 clazzRepid;
-
-        synchronized(cache) {
-        // to avoid race condition where multiple threads could be
-        // accessing this method, and their access to the cache may
-        // be interleaved giving unexpected results
-
-            targetRepid = cache.getId(repositoryID);
-            clazzRepid = cache.getId(clazzRepIDStr);
-        }
-        //ObjectStreamClass osc = ObjectStreamClass.lookup(clazz);
-
-        if ((targetRepid.isRMIValueType()) && (clazzRepid.isRMIValueType())){
-            if (!targetRepid.getSerialVersionUID().equals(clazzRepid.getSerialVersionUID())) {
-
-                String mssg = "Mismatched serialization UIDs : Source (Rep. ID" +
-                    clazzRepid + ") = " +
-                    clazzRepid.getSerialVersionUID() + " whereas Target (Rep. ID " + repositoryID +
-                    ") = " + targetRepid.getSerialVersionUID();
-                                //com.sun.corba.se.impl.io.ValueUtility.log("RepositoryId",mssg);
-                throw new IOException(mssg);
-        }
-            else {
-                return true;
-            }
-        }
-        else {
-
-            throw new IOException("The repository ID is not of an RMI value type (Expected ID = " + clazzRepIDStr + "; Received ID = " + repositoryID +")");
-    }
-    }
-
-    private static String createHashString(java.io.Serializable ser) {
-
-        return createHashString(ser.getClass());
-    }
-
-    private static String createHashString(java.lang.Class clazz) {
-
-        if (clazz.isInterface() || !java.io.Serializable.class.isAssignableFrom(clazz))
-            return kInterfaceHashCode;
-
-        //ObjectStreamClass osc = ObjectStreamClass.lookup(clazz);
-
-        long actualLong = ObjectStreamClass_1_3_1.getActualSerialVersionUID(clazz);
-        String hash = null;
-        if (actualLong == 0)
-            hash = kInterfaceOnlyHashStr;
-        else if (actualLong == 1)
-            hash = kExternalizableHashStr;
-        else
-            hash = Long.toHexString(actualLong).toUpperCase();
-        while(hash.length() < 16){
-            hash = "0" + hash;
-        }
-
-        long declaredLong = ObjectStreamClass_1_3_1.getSerialVersionUID(clazz);
-        String declared = null;
-        if (declaredLong == 0)
-            declared = kInterfaceOnlyHashStr;
-        else if (declaredLong == 1)
-            declared = kExternalizableHashStr;
-        else
-            declared = Long.toHexString(declaredLong).toUpperCase();
-        while (declared.length() < 16){
-            declared = "0" + declared;
-    }
-        hash = hash + ":" + declared;
-
-        return ":" + hash;
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a rep id for a sequence of zero
-     * length.  This would be an error.
-     * @param ser The Java object to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Object ser){
-        return createSequenceRepID(ser.getClass());
-    }
-
-    /**
-     * Creates a repository ID for a sequence.  This is for expert users only as
-     * this method assumes the object passed is an array.  If passed an object
-     * that is not an array, it will produce a malformed rep id.
-     * @param clazz The Java class to create a repository ID for
-     **/
-    public static String createSequenceRepID(java.lang.Class clazz){
-        synchronized (classSeqToRepStr){
-
-        String repid = (String)classSeqToRepStr.get(clazz);
-        if (repid != null)
-            return repid;
-
-        Class originalClazz = clazz;
-
-        Class type = null;
-        int numOfDims = 0;
-
-        while ((type = clazz.getComponentType()) != null) {
-            numOfDims++;
-            clazz = type;
-        }
-
-        if (clazz.isPrimitive())
-            repid = kValuePrefix + originalClazz.getName() + kPrimitiveSequenceValueHash;
-        else {
-            StringBuffer buf = new StringBuffer();
-            buf.append(kValuePrefix);
-            while(numOfDims-- > 0) {
-                buf.append("[");
-            }
-            buf.append("L");
-            buf.append(convertToISOLatin1(clazz.getName()));
-            buf.append(";");
-            buf.append(createHashString(clazz));
-            repid = buf.toString();
-        }
-        classSeqToRepStr.put(originalClazz,repid);
-        return repid;
-        }
-
-    }
-
-
-    public static String createForSpecialCase(java.lang.Class clazz){
-        if (clazz.isArray()){
-            return createSequenceRepID(clazz);
-        }
-        else {
-            return (String)kSpecialCasesRepIDs.get(clazz);
-        }
-    }
-
-    public static String createForSpecialCase(java.io.Serializable ser){
-        Class clazz = ser.getClass();
-        if (clazz.isArray()){
-            return createSequenceRepID(ser);
-        }
-        else
-            return createForSpecialCase(clazz);
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param ser The Java object to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(java.io.Serializable ser)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr) {
-        String repid = createForSpecialCase(ser);
-        if (repid != null)
-            return repid;
-        Class clazz = ser.getClass();
-        repid = (String)classToRepStr.get(clazz);
-
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clazz.getName()) +
-            createHashString(clazz);
-
-        classToRepStr.put(clazz, repid);
-            repStrToClass.put(repid, clazz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for a normal Java Type.
-     * @param clz The Java class to create a repository ID for
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser implements the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForJavaType(Class clz)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classToRepStr){
-        String repid = createForSpecialCase(clz);
-        if (repid != null)
-            return repid;
-
-        repid = (String)classToRepStr.get(clz);
-        if (repid != null)
-            return repid;
-
-        repid = kValuePrefix + convertToISOLatin1(clz.getName()) +
-            createHashString(clz);
-
-        classToRepStr.put(clz, repid);
-            repStrToClass.put(repid, clz);
-        return repid;
-    }
-    }
-
-    /**
-     * Creates a repository ID for an IDL Java Type.
-     * @param ser The IDL Value object to create a repository ID for
-     * @param major The major version number
-     * @param minor The minor version number
-     * @exception com.sun.corba.se.impl.io.TypeMismatchException if ser does not implement the
-     * org.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.
-     **/
-    public static String createForIDLType(Class ser, int major, int minor)
-        throws com.sun.corba.se.impl.io.TypeMismatchException
-    {
-        synchronized (classIDLToRepStr){
-        String repid = (String)classIDLToRepStr.get(ser);
-        if (repid != null)
-            return repid;
-
-        repid = kIDLPrefix + convertToISOLatin1(ser.getName()).replace('.','/') +
-            ":" + major + "." + minor;
-        classIDLToRepStr.put(ser, repid);
-        return repid;
-    }
-    }
-
-    private static String getIdFromHelper(Class clazz){
-        try {
-            Class helperClazz = Utility.loadClassForClass(clazz.getName()+"Helper", null,
-                                    clazz.getClassLoader(), clazz, clazz.getClassLoader());
-            Method idMethod = helperClazz.getDeclaredMethod("id", kNoParamTypes);
-            return (String)idMethod.invoke(null, kNoArgs);
-        }
-        catch(java.lang.ClassNotFoundException cnfe)
-            {
-                throw new org.omg.CORBA.MARSHAL(cnfe.toString());
-            }
-        catch(java.lang.NoSuchMethodException nsme)
-            {
-                throw new org.omg.CORBA.MARSHAL(nsme.toString());
-            }
-        catch(java.lang.reflect.InvocationTargetException ite)
-            {
-                throw new org.omg.CORBA.MARSHAL(ite.toString());
-            }
-        catch(java.lang.IllegalAccessException iae)
-            {
-                throw new org.omg.CORBA.MARSHAL(iae.toString());
-    }
-    }
-
-    /**
-     * Createa a repository ID for the type if it is either a java type
-     * or an IDL type.
-     * @param type The type to create rep. id for
-     * @return The rep. id.
-     **/
-    public static String createForAnyType(Class type) {
-        try{
-            if (type.isArray())
-                return createSequenceRepID(type);
-            else if (IDLEntity.class.isAssignableFrom(type))
-                {
-                    try{
-                        return getIdFromHelper(type);
-                    }
-                    catch(Throwable t) {
-                        return createForIDLType(type, 1, 0);
-                    }
-                }
-            else return createForJavaType(type);
-        }
-        catch(com.sun.corba.se.impl.io.TypeMismatchException e){
-            return null;
-        }
-
-    }
-
-    public static boolean isAbstractBase(Class clazz) {
-        return (clazz.isInterface() &&
-                IDLEntity.class.isAssignableFrom(clazz) &&
-                (!ValueBase.class.isAssignableFrom(clazz)) &&
-                (!org.omg.CORBA.Object.class.isAssignableFrom(clazz)));
-
-    }
-
-    public static boolean isAnyRequired(Class clazz) {
-        return ((clazz == java.lang.Object.class) ||
-                (clazz == java.io.Serializable.class) ||
-                (clazz == java.io.Externalizable.class));
-    }
-
-    public static long fromHex(String hexNumber) {
-        if (hexNumber.startsWith("0x"))
-            return Long.valueOf(hexNumber.substring(2), 16).longValue();
-        else return Long.valueOf(hexNumber, 16).longValue();
-    }
-
-    /**
-     * Convert strings with illegal IDL identifier characters.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertToISOLatin1 (String name) {
-
-        int length = name.length();
-        if (length == 0) {
-            return name;
-        }
-        StringBuffer buffer = null;
-
-        for (int i = 0; i < length; i++) {
-
-            char c = name.charAt(i);
-
-            if (c > 255 || IDL_IDENTIFIER_CHARS[c] == 0) {
-
-                // We gotta convert. Have we already started?
-
-                if (buffer == null) {
-
-                    // No, so get set up...
-
-                    buffer = new StringBuffer(name.substring(0,i));
-                }
-
-                // Convert the character into the IDL escape syntax...
-                buffer.append(
-                              "\\U" +
-                              (char)ASCII_HEX[(c & 0xF000) >>> 12] +
-                              (char)ASCII_HEX[(c & 0x0F00) >>> 8] +
-                              (char)ASCII_HEX[(c & 0x00F0) >>> 4] +
-                              (char)ASCII_HEX[(c & 0x000F)]);
-
-            } else {
-                if (buffer != null) {
-                    buffer.append(c);
-                }
-            }
-        }
-
-        if (buffer != null) {
-            name = buffer.toString();
-        }
-
-        return name;
-    }
-
-    /**
-     * Convert strings with ISO Latin 1 escape sequences back to original strings.
-     * <p>
-     * Section 5.5.7 of OBV spec.
-     */
-    private static String convertFromISOLatin1 (String name) {
-
-        int index = -1;
-        StringBuffer buf = new StringBuffer(name);
-
-        while ((index = buf.toString().indexOf("\\U")) != -1){
-            String str = "0000" + buf.toString().substring(index+2, index+6);
-
-            // Convert Hexadecimal
-            byte[] buffer = new byte[(str.length() - 4) / 2];
-            for (int i=4, j=0; i < str.length(); i +=2, j++) {
-                buffer[j] = (byte)((ORBUtility.hexOf(str.charAt(i)) << 4) & 0xF0);
-                buffer[j] |= (byte)((ORBUtility.hexOf(str.charAt(i+1)) << 0) & 0x0F);
-            }
-            buf = new StringBuffer(delete(buf.toString(), index, index+6));
-            buf.insert(index, (char)buffer[1]);
-        }
-
-        return buf.toString();
-
-
-    }
-
-    private static String delete(String str, int from, int to)
-    {
-        return str.substring(0, from) + str.substring(to, str.length());
-    }
-
-    private static String replace(String target, String arg, String source)
-    {
-        int i = 0;
-        i = target.indexOf(arg);
-
-        while(i != -1)
-            {
-                String left = target.substring(0, i);
-                String right = target.substring(i+arg.length());
-                target = new String(left+source+right);
-                i = target.indexOf(arg);
-            }
-        return target;
-    }
-
-    public static int computeValueTag(boolean codeBasePresent, int typeInfo, boolean chunkedEncoding){
-        int value_tag = kInitialValueTag;
-
-        if (codeBasePresent)
-            value_tag = value_tag | 0x00000001;
-
-        value_tag = value_tag | typeInfo;
-
-        if (chunkedEncoding)
-            value_tag = value_tag | kChunkedMask;
-
-        return value_tag;
-    }
-
-    public static boolean isCodeBasePresent(int value_tag){
-        return ((value_tag & 0x00000001) == 1);
-    }
-
-    public static int getTypeInfo(int value_tag){
-        return (value_tag & 0x00000006);
-    }
-
-    public static boolean isChunkedEncoding(int value_tag){
-        return ((value_tag & kChunkedMask) != 0);
-    }
-
-    public static String getServerURL(){
-        return defaultServerURL;
-    }
-
-    /*
-     * Load a class and check that it is assignable to a given type.
-     * @param className the class name.
-     * @param remoteCodebase the codebase to use. May be null.
-     * @param loader the class loader of last resort. May be null.
-     * @param expectedType the expected type. May be null.
-     * @return the loaded class.
-     */
-    private Class loadClassOfType (String className,
-                                  String remoteCodebase,
-                                  ClassLoader loader,
-                                  Class expectedType,
-                                  ClassLoader expectedTypeClassLoader)
-        throws ClassNotFoundException {
-
-        Class loadedClass = null;
-
-        try {
-            //Sequence finding of the stubs according to spec
-            try{
-                //If-else is put here for speed up of J2EE.
-                //According to the OMG spec, the if clause is not dead code.
-                //It can occur if some compiler has allowed generation
-                //into org.omg.stub hierarchy for non-offending
-                //classes. This will encourage people to
-                //produce non-offending class stubs in their own hierarchy.
-                if(!PackagePrefixChecker
-                   .hasOffendingPrefix(PackagePrefixChecker
-                                       .withoutPackagePrefix(className))){
-                    loadedClass = Util.loadClass
-                        (PackagePrefixChecker.withoutPackagePrefix(className),
-                         remoteCodebase,
-                         loader);
-                } else {
-                    loadedClass = Util.loadClass
-                        (className,
-                         remoteCodebase,
-                         loader);
-                }
-            } catch (ClassNotFoundException cnfe) {
-                loadedClass = Util.loadClass
-                    (className,
-                     remoteCodebase,
-                     loader);
-            }
-            if (expectedType == null)
-                return loadedClass;
-        } catch (ClassNotFoundException cnfe) {
-            if (expectedType == null)
-                throw cnfe;
-        }
-
-        // If no class was not loaded, or if the loaded class is not of the
-        // correct type, make a further attempt to load the correct class
-        // using the classloader of the expected type.
-        // _REVISIT_ Is this step necessary, or should the Util,loadClass
-        // algorithm always produce a valid class if the setup is correct?
-        // Does the OMG standard algorithm need to be changed to include
-        // this step?
-        if (loadedClass == null || !expectedType.isAssignableFrom(loadedClass)) {
-            if (expectedType.getClassLoader() != expectedTypeClassLoader)
-                throw new IllegalArgumentException("expectedTypeClassLoader not class loader of expectedType.");
-
-            if (expectedTypeClassLoader != null)
-                loadedClass = expectedTypeClassLoader.loadClass(className);
-            else
-                loadedClass = Class.forName(className);
-        }
-
-        return loadedClass;
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java	2012-08-10 09:10:35.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,251 +0,0 @@
-/*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-/*
- * Licensed Materials - Property of IBM
- * RMI-IIOP v1.0
- * Copyright IBM Corp. 1998 1999  All Rights Reserved
- *
- */
-
-package com.sun.corba.se.impl.orbutil;
-
-import javax.rmi.CORBA.Util;
-import javax.rmi.PortableRemoteObject;
-
-import java.util.Hashtable;
-import java.util.Stack;
-import java.io.IOException;
-import java.util.EmptyStackException;
-
-import com.sun.corba.se.impl.util.Utility;
-import com.sun.corba.se.impl.io.IIOPInputStream;
-import com.sun.corba.se.impl.io.IIOPOutputStream;
-import com.sun.corba.se.impl.util.RepositoryId;
-import com.sun.corba.se.impl.util.Utility;
-
-import org.omg.CORBA.TCKind;
-import org.omg.CORBA.MARSHAL;
-import org.omg.CORBA.CompletionStatus;
-import org.omg.CORBA.portable.IndirectionException;
-import com.sun.org.omg.SendingContext.CodeBase;
-
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
-/**
- * This class overrides behavior of our current ValueHandlerImpl to
- * provide backwards compatibility with JDK 1.3.0.
- */
-public class ValueHandlerImpl_1_3 extends com.sun.corba.se.impl.io.ValueHandlerImpl {
-
-    public ValueHandlerImpl_1_3(){
-        super();
-    }
-
-    public ValueHandlerImpl_1_3(boolean isInputStream) {
-        super(isInputStream);
-    }
-
-    /**
-     * Writes the value to the stream using java semantics.
-     * @param out The stream to write the value to
-     * @param value The value to be written to the stream
-     **/
-    public void writeValue(org.omg.CORBA.portable.OutputStream _out, java.io.Serializable value) {
-        super.writeValue(_out, value);
-    }
-
-    /**
-     * Reads a value from the stream using java semantics.
-     * @param in The stream to read the value from
-     * @param clazz The type of the value to be read in
-     * @param sender The sending context runtime
-     **/
-    public java.io.Serializable readValue(org.omg.CORBA.portable.InputStream _in,
-                                          int offset,
-                                          java.lang.Class clazz,
-                                          String repositoryID,
-                                          org.omg.SendingContext.RunTime _sender)
-    {
-        return super.readValue(_in, offset, clazz, repositoryID, _sender);
-    }
-
-    /**
-     * Returns the repository ID for the given RMI value Class.
-     * @param clz The class to return a repository ID for.
-     * @return the repository ID of the Class.
-     **/
-    public java.lang.String getRMIRepositoryID(java.lang.Class clz) {
-        return RepositoryId_1_3.createForJavaType(clz);
-    }
-
-    /**
-     * Indicates whether the given Class performs custom or
-     * default marshaling.
-     * @param clz The class to test for custom marshaling.
-     * @return True if the class performs custom marshaling, false
-     * if it does not.
-     **/
-    public boolean isCustomMarshaled(java.lang.Class clz) {
-        return super.isCustomMarshaled(clz);
-    }
-
-    /**
-     * Returns the CodeBase for this ValueHandler.  This is used by
-     * the ORB runtime.  The server sends the service context containing
-     * the IOR for this CodeBase on the first GIOP reply.  The clients
-     * do the same on the first GIOP request.
-     * @return the SendingContext.CodeBase of this ValueHandler.
-     **/
-    public org.omg.SendingContext.RunTime getRunTimeCodeBase() {
-        return super.getRunTimeCodeBase();
-    }
-
-    /**
-     * If the value contains a writeReplace method then the result
-     * is returned.  Otherwise, the value itself is returned.
-     * @return the true value to marshal on the wire.
-     **/
-    public java.io.Serializable writeReplace(java.io.Serializable value) {
-        return super.writeReplace(value);
-    }
-
-    // methods supported for backward compatability so that the appropriate
-    // Rep-id calculations take place based on the ORB version
-
-    /**
-     *  Returns a boolean of whether or not RepositoryId indicates
-     *  FullValueDescriptor.
-     *  used for backward compatability
-     */
-
-     public boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws IOException
-
-     {
-        return RepositoryId_1_3.useFullValueDescription(clazz, repositoryID);
-     }
-
-     public String getClassName(String id)
-     {
-        RepositoryId_1_3 repID = RepositoryId_1_3.cache.getId(id);
-        return repID.getClassName();
-     }
-
-     public Class getClassFromType(String id)
-        throws ClassNotFoundException
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getClassFromType();
-     }
-
-     public Class getAnyClassFromType(String id)
-        throws ClassNotFoundException
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getAnyClassFromType();
-     }
-
-     public String createForAnyType(Class cl)
-     {
-        return RepositoryId_1_3.createForAnyType(cl);
-     }
-
-     public String getDefinedInId(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getDefinedInId();
-     }
-
-     public String getUnqualifiedName(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getUnqualifiedName();
-     }
-
-     public String getSerialVersionUID(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.getSerialVersionUID();
-     }
-
-     public boolean isAbstractBase(Class clazz)
-     {
-        return RepositoryId_1_3.isAbstractBase(clazz);
-     }
-
-     public boolean isSequence(String id)
-     {
-        RepositoryId_1_3 repId = RepositoryId_1_3.cache.getId(id);
-        return repId.isSequence();
-     }
-
-    /**
-     * Preserves the incorrect 1.3 behavior which truncates Java chars in
-     * arrays to 8-bit CORBA chars.  Bug 4367783.  This enables us to
-     * continue interoperating with our legacy ORBs.  If this goes into
-     * Ladybird, then Ladybird and Kestrel will interoperate as long as
-     * people don't use chars greater than 8-bits.
-     */
-    protected void writeCharArray(org.omg.CORBA_2_3.portable.OutputStream out,
-                                char[] array,
-                                int offset,
-                                int length)
-    {
-        out.write_char_array(array, offset, length);
-    }
-
-    /**
-     * Preserves the incorrect 1.3 behavior which truncates Java chars in
-     * arrays to 8-bit CORBA chars.  Bug 4367783.  This enables us to
-     * continue interoperating with our legacy ORBs.  If this goes into
-     * Ladybird, then Ladybird and Kestrel will interoperate as long as
-     * people don't use chars greater than 8-bits.
-     */
-    protected void readCharArray(org.omg.CORBA_2_3.portable.InputStream in,
-                                 char[] array,
-                                 int offset,
-                                 int length)
-    {
-        in.read_char_array(array, offset, length);
-    }
-
-    protected final String getOutputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3";
-    }
-
-    protected final String getInputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3";
-    }
-
-    /**
-     * Our JDK 1.3 and JDK 1.3.1 behavior subclasses override this.
-     * The correct behavior is for a Java char to map to a CORBA wchar,
-     * but our older code mapped it to a CORBA char.
-     */
-    protected TCKind getJavaCharTCKind() {
-        return TCKind.tk_char;
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java	2012-08-10 09:10:35.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ValueHandlerImpl_1_3_1.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.orbutil;
-
-import org.omg.CORBA.TCKind;
-
-/**
- * This class overrides behavior of our current ValueHandlerImpl to
- * provide backwards compatibility with JDK 1.3.1.
- */
-public class ValueHandlerImpl_1_3_1
-    extends com.sun.corba.se.impl.io.ValueHandlerImpl
-{
-    public ValueHandlerImpl_1_3_1() {}
-
-    public ValueHandlerImpl_1_3_1(boolean isInputStream) {
-        super(isInputStream);
-    }
-
-    /**
-     * Our JDK 1.3 and JDK 1.3.1 behavior subclasses override this.
-     * The correct behavior is for a Java char to map to a CORBA wchar,
-     * but our older code mapped it to a CORBA char.
-     */
-    protected TCKind getJavaCharTCKind() {
-        return TCKind.tk_char;
-    }
-
-    /**
-     * RepositoryId_1_3_1 performs an incorrect repId calculation
-     * when using serialPersistentFields and one of the fields no longer
-     * exists on the class itself.
-     */
-    public boolean useFullValueDescription(Class clazz, String repositoryID)
-        throws java.io.IOException
-    {
-        return RepositoryId_1_3_1.useFullValueDescription(clazz, repositoryID);
-    }
-
-    /**
-     * Installs the legacy IIOPOutputStream_1_3_1 which does
-     * PutFields/GetFields incorrectly.  Bug 4407244.
-     */
-    protected final String getOutputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPOutputStream_1_3_1";
-    }
-
-    /**
-     * Installs the legacy IIOPInputStream_1_3_1 which does
-     * PutFields/GetFields incorrectly.  Bug 4407244.
-     */
-    protected final String getInputStreamClassName() {
-        return "com.sun.corba.se.impl.orbutil.IIOPInputStream_1_3_1";
-    }
-}
--- corba/src/share/classes/com/sun/corba/se/spi/orb/ORB.java	2012-08-10 09:11:09.000000000 -0700
+++ corba/src/share/classes/com/sun/corba/se/spi/orb/ORB.java	2013-05-05 09:39:34.000000000 -0700
@@ -98,6 +98,7 @@
 import com.sun.corba.se.impl.presentation.rmi.PresentationManagerImpl ;
 
 import com.sun.corba.se.impl.orbutil.ORBClassLoader ;
+import sun.awt.AppContext;
 
 public abstract class ORB extends com.sun.corba.se.org.omg.CORBA.ORB
     implements Broker, TypeCodeFactory
@@ -173,14 +174,7 @@
 
     protected MonitoringManager monitoringManager;
 
-    // There is only one instance of the PresentationManager
-    // that is shared between all ORBs.  This is necessary
-    // because RMI-IIOP requires the PresentationManager in
-    // places where no ORB is available, so the PresentationManager
-    // must be global.  It is initialized here as well.
-    protected static PresentationManager globalPM = null ;
-
-    static {
+    private static PresentationManager setupPresentationManager() {
         staticWrapper = ORBUtilSystemException.get(
             CORBALogDomains.RPC_PRESENTATION ) ;
 
@@ -218,12 +212,13 @@
                         return sff ;
                     }
                 }
-            ) ;
+            );
 
-        globalPM = new PresentationManagerImpl( useDynamicStub ) ;
-        globalPM.setStubFactoryFactory( false,
+        PresentationManager pm = new PresentationManagerImpl( useDynamicStub ) ;
+        pm.setStubFactoryFactory( false,
             PresentationDefaults.getStaticStubFactoryFactory() ) ;
-        globalPM.setStubFactoryFactory( true, dynamicStubFactoryFactory ) ;
+        pm.setStubFactoryFactory( true, dynamicStubFactoryFactory ) ;
+        return pm;
     }
 
     public void destroy() {
@@ -234,11 +229,19 @@
         byteBufferPool = null;
     }
 
-    /** Get the single instance of the PresentationManager
+    /**
+     * Returns the Presentation Manager for the current thread group, using the ThreadGroup-specific
+     * AppContext to hold it. Creates and records one if needed.
      */
     public static PresentationManager getPresentationManager()
     {
-        return globalPM ;
+        AppContext ac = AppContext.getAppContext();
+        PresentationManager pm = (PresentationManager) ac.get(PresentationManager.class);
+        if (pm == null) {
+            pm = setupPresentationManager();
+            ac.put(PresentationManager.class, pm);
+        }
+        return pm;
     }
 
     /** Get the appropriate StubFactoryFactory.  This
@@ -248,8 +251,9 @@
     public static PresentationManager.StubFactoryFactory
         getStubFactoryFactory()
     {
-        boolean useDynamicStubs = globalPM.useDynamicStubs() ;
-        return globalPM.getStubFactoryFactory( useDynamicStubs ) ;
+        PresentationManager gPM = getPresentationManager();
+        boolean useDynamicStubs = gPM.useDynamicStubs() ;
+        return gPM.getStubFactoryFactory( useDynamicStubs ) ;
     }
 
     protected ORB()
@@ -543,6 +547,7 @@
     public abstract ThreadPoolManager getThreadPoolManager();
 
     public abstract CopierManager getCopierManager() ;
+
 }
 
 // End of file.
--- corba/src/share/classes/sun/corba/JavaCorbaAccess.java	1969-12-31 16:00:00.000000000 -0800
+++ corba/src/share/classes/sun/corba/JavaCorbaAccess.java	2013-05-05 09:39:35.000000000 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.corba;
+
+import com.sun.corba.se.impl.io.ValueHandlerImpl;
+
+public interface JavaCorbaAccess {
+    public ValueHandlerImpl newValueHandlerImpl();
+}
--- corba/src/share/classes/sun/corba/SharedSecrets.java	1969-12-31 16:00:00.000000000 -0800
+++ corba/src/share/classes/sun/corba/SharedSecrets.java	2013-05-05 09:39:35.000000000 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.corba;
+
+import com.sun.corba.se.impl.io.ValueUtility;
+import sun.misc.Unsafe;
+
+import java.security.AccessController;
+
+/** A repository of "shared secrets", which are a mechanism for
+    calling implementation-private methods in another package without
+    using reflection. A package-private class implements a public
+    interface and provides the ability to call package-private methods
+    within that package; the object implementing that interface is
+    provided through a third package to which access is restricted.
+    This framework avoids the primary disadvantage of using reflection
+    for this purpose, namely the loss of compile-time checking. */
+
+// SharedSecrets cloned in corba repo to avoid build issues
+public class SharedSecrets {
+    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static JavaCorbaAccess javaCorbaAccess;
+
+    public static JavaCorbaAccess getJavaCorbaAccess() {
+        if (javaCorbaAccess == null) {
+            // Ensure ValueUtility is initialized; we know that that class
+            // provides the shared secret
+            unsafe.ensureClassInitialized(ValueUtility.class);
+        }
+        return javaCorbaAccess;
+    }
+
+    public static void setJavaCorbaAccess(JavaCorbaAccess access) {
+        javaCorbaAccess = access;
+    }
+
+}
--- hotspot/.hgtags	2012-08-10 09:20:36.000000000 -0700
+++ hotspot/.hgtags	2013-05-05 09:39:19.000000000 -0700
@@ -182,6 +182,7 @@
 38fa55e5e79232d48f1bb8cf27d88bc094c9375a hs21-b16
 81d815b05abb564aa1f4100ae13491c949b9a07e jdk7-b147
 81d815b05abb564aa1f4100ae13491c949b9a07e hs21-b17
+f1a18ada5853af49fce54d43dd5a5b67dc291470 7u0
 9b0ca45cd756d538c4c30afab280a91868eee1a5 jdk7u2-b01
 0cc8a70952c368e06de2adab1f2649a408f5e577 jdk8-b01
 31e253c1da429124bb87570ab095d9bc89850d0a jdk8-b02
@@ -318,5 +319,69 @@
 02a6c89432d724119565f9ba25672829b136fc5f jdk7u6-b21
 a79d86eef6ac995a1fc35554f082f3a61abe9ae0 jdk7u6-b22
 df57f6208cb76b4e8d1a0bd0eea3d2ad577cb79b jdk7u6-b23
-02a6c89432d724119565f9ba25672829b136fc5f jdk7u8-b01
-528502f930967f70c320472a002418f1e38029e0 jdk7u8-b02
+b03c2687fb16514652e79261ad68d2c601dcee62 jdk7u6-b24
+cffde29ea7cc8647f17002a4d0e94065dcd82839 jdk7u6-b30
+7566374c3c89b7d99be9bcdb9342283a3bea6930 jdk7u6-b31
+f7933fecea9aa494e4032e17ff07e5fcec4b5961 jdk7u7-b10
+eeef33dc4b40f9ba50c4c9b1ac61b30f0f2523bf jdk7u7-b30
+f1551c70c7f598b7049bcc33e530fc738a81c7a4 jdk7u7-b11
+6b9db7216dd4b7846faf372f19566a418c8e391f jdk7u7-b31
+b66bb0e3224ff15259361a5b501bf8fa6b346113 jdk7u7-b01
+ca6943c94e6075fc28353d52ac6ea52c80aef9bb jdk7u7-b02
+e043d96d767d8ba4d74d53c477af8e07b78b6128 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+b66bb0e3224ff15259361a5b501bf8fa6b346113 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+ca6943c94e6075fc28353d52ac6ea52c80aef9bb jdk7u9-b02
+ed42837374ac730ddaf2fd28814017c665634a8b jdk7u9-b04
+da4aa289ac100017f850ed4d492e8054db6a1e28 jdk7u9-b05
+8eaa45ed5f804199c0823b409dc37f72e808926f jdk7u9-b31
+ea83168282c8c3a9f4a8ca723cc86972a3188d58 jdk7u9-b32
+d2e25680db9d4209b3f0f51e5c848284cedea508 jdk7u10-b10
+d37fd995683ab5bc2d941648ce7bf8bd194732f2 jdk7u10-b11
+f26f3d92e6d9ef7842b2d785f92439dbb15e670e jdk7u10-b12
+58881c615a5179bcea69148d0b3eb47a1f1a7de8 jdk7u10-b13
+cdbf4d442b56ece8ac521c65b59087682e5ae918 jdk7u10-b14
+63e8b49b329e4b50547b13f5c732665bed535732 jdk7u10-b15
+1cb34ef50bddc334c8538cf85d8612383debc74f jdk7u10-b16
+5c154a591de987d515f5b102a988bcf96d439f53 jdk7u10-b17
+78c7e1b4a006342230e04fbb73f637834207abef jdk7u10-b18
+c6b78bbaf6976197ead9d5aa3f65e0224cd13541 jdk7u10-b30
+07f7daeb261073a4a2946d988979ee65ba8ed753 jdk7u10-b31
+25a92b94ad538963d009bf8a53ce548e13f55c82 jdk7u11-b20
+7a2cf85fc36e845db9ccb2a22af195c70af33bdf jdk7u11-b21
+06b5c3f663b81f11da2080a91d215a96ae431f84 jdk7u11-b32
+abb5b690122caabf09f93958c747358cc22f8a59 jdk7u11-b33
+db7028c8a953f46225fceb6148f97de87c784dda jdk7u11-b03
+4d418a1b8be04220f504cf414b47877821a22a26 jdk7u11-b04
+f71032f398a3baea567710ba7161c64b94495cac jdk7u11-b05
+0cbce123c9027d531e585fd81fbc361c5f8407f1 jdk7u11-b06
+94bf1e3dafef3cc06d3f97f81d304313ccd999ee jdk7u11-b07
+2b543aa340e4a75671fe05803fcee08bf3e136db jdk7u11-b08
+34a7b6dda06e2ff6f7e9ad563e3fc3ecd8993579 jdk7u13-b09
+e0e52e35e0c53a84daadae95f626e36fd74f3eba jdk7u13-b10
+be57a8d7a1a75971c3b1e7777dcacd20f3d33264 jdk7u13-b30
+e0e52e35e0c53a84daadae95f626e36fd74f3eba jdk7u13-b20
+5fbe0cae3a2a78a73946cfd08c56a64860f1afd9 jdk7u15-b01
+30d72c9abb560bc424d16d96bfd396ccd3c62cbc jdk7u15-b02
+221c64550c5b4411d78b63820835de1a8cd0c118 jdk7u15-b30
+0b905a04f573565515aa8614085099abd73dcac4 jdk7u15-b31
+8b349f332a66ebe5982b5680c85f903efb03da8e jdk7u15-b33
+5b55cef461b034766f05a46640caa123aa4247d4 jdk7u15-b03
+34a7b6dda06e2ff6f7e9ad563e3fc3ecd8993579 jdk7u15-b32
+a4dfda7a2655209abb170b2fa4914dbbba89bcd3 jdk7u17-b01
+0d82bf449a610602b6e9ddcc9e076839d5351449 jdk7u17-b02
+7b357c079370e2fd324c229f2e24c982915c80a0 jdk7u17-b30
+22b6fd616cfe61774525a944f162bf5e7c418f03 jdk7u17-b31
+be57a8d7a1a75971c3b1e7777dcacd20f3d33264 jdk7u21-b01
+5119d89c7cc844190c0799dca85710e7592d42e7 jdk7u21-b02
+ad14169fb640ca532193cca0fd6e14910f226075 jdk7u21-b03
+c954aab38a7f8f62e33ae5103494576f67fc36d9 jdk7u21-b04
+0e8e9d990d91dc0f8b8807bb82c090de3264c809 jdk7u21-b05
+beeb3d6b76f06d9f60c31d6c5b9e04d82f01ad79 jdk7u21-b06
+663b5c744e82d1c884048cd9b38f625e52004773 jdk7u21-b07
+87e9bb582938552180b024dd99bc5166816f3921 jdk7u21-b08
+1f195ee7856aecb6527bc5c957f66e1960e51a12 jdk7u21-b09
+d4a4c2bd389abcd80c25d20e0ffb7d5cee356715 jdk7u21-b10
+d07dafb51e1d75f110a3c506c250d995235acca6 jdk7u21-b11
+a977dedec81c346247631ead6f3364c76949d67a jdk7u21-b30
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java	2012-08-10 09:21:14.000000000 -0700
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java	2013-05-05 09:39:09.000000000 -0700
@@ -33,6 +33,7 @@
 import sun.jvm.hotspot.debugger.remote.*;
 import sun.jvm.hotspot.debugger.windbg.*;
 import sun.jvm.hotspot.debugger.linux.*;
+import sun.jvm.hotspot.debugger.bsd.*;
 import sun.jvm.hotspot.memory.*;
 import sun.jvm.hotspot.oops.*;
 import sun.jvm.hotspot.runtime.*;
--- hotspot/agent/src/share/classes/sun/jvm/hotspot/bugspot/BugSpotAgent.java	2012-08-10 09:21:38.000000000 -0700
+++ hotspot/agent/src/share/classes/sun/jvm/hotspot/bugspot/BugSpotAgent.java	2013-05-05 09:39:09.000000000 -0700
@@ -35,6 +35,7 @@
 import sun.jvm.hotspot.debugger.windbg.*;
 import sun.jvm.hotspot.debugger.linux.*;
 import sun.jvm.hotspot.debugger.sparc.*;
+import sun.jvm.hotspot.debugger.bsd.*;
 import sun.jvm.hotspot.debugger.remote.*;
 import sun.jvm.hotspot.livejvm.*;
 import sun.jvm.hotspot.memory.*;
--- hotspot/make/bsd/Makefile	2012-08-10 09:22:55.000000000 -0700
+++ hotspot/make/bsd/Makefile	2013-05-05 09:39:09.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -211,6 +211,8 @@
 BUILDTREE_VARS    = GAMMADIR=$(GAMMADIR) OS_FAMILY=$(OSNAME) SRCARCH=$(SRCARCH) BUILDARCH=$(BUILDARCH) LIBARCH=$(LIBARCH) LIBRARY_SUFFIX=$(LIBRARY_SUFFIX)
 BUILDTREE_VARS   += HOTSPOT_RELEASE_VERSION=$(HOTSPOT_RELEASE_VERSION) HOTSPOT_BUILD_VERSION=$(HOTSPOT_BUILD_VERSION) JRE_RELEASE_VERSION=$(JRE_RELEASE_VERSION)
 
+BUILDTREE_VARS   += ENABLE_FULL_DEBUG_SYMBOLS=$(ENABLE_FULL_DEBUG_SYMBOLS) OBJCOPY=$(OBJCOPY) STRIP_POLICY=$(STRIP_POLICY) ZIP_DEBUGINFO_FILES=$(ZIP_DEBUGINFO_FILES) ZIPEXE=$(ZIPEXE)
+
 BUILDTREE         = $(MAKE) -f $(BUILDTREE_MAKE) $(BUILDTREE_VARS)
 
 #-------------------------------------------------------------------------------
@@ -337,9 +339,11 @@
 
 # Doc target.  This is the same for all build options.
 #     Hence create a docs directory beside ...$(ARCH)_[...]
+# We specify 'BUILD_FLAVOR=product' so that the proper
+# ENABLE_FULL_DEBUG_SYMBOLS value is used.
 docs: checks
 	$(QUIETLY) mkdir -p $(SUBDIR_DOCS)
-	$(MAKE) -f $(GAMMADIR)/make/$(OSNAME)/makefiles/jvmti.make $(MFLAGS) $(BUILDTREE_VARS) JvmtiOutDir=$(SUBDIR_DOCS) jvmtidocs
+	$(MAKE) -f $(GAMMADIR)/make/$(OSNAME)/makefiles/jvmti.make $(MFLAGS) $(BUILDTREE_VARS) JvmtiOutDir=$(SUBDIR_DOCS) BUILD_FLAVOR=product jvmtidocs
 
 # Synonyms for win32-like targets.
 compiler2:  jvmg product
--- hotspot/make/bsd/makefiles/buildtree.make	2012-08-10 09:22:57.000000000 -0700
+++ hotspot/make/bsd/makefiles/buildtree.make	2013-05-05 09:39:09.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -242,6 +242,16 @@
 	echo "$(call gamma-path,commonsrc,os/posix/vm)"; \
 	[ -n "$(CFLAGS_BROWSE)" ] && \
 	    echo && echo "CFLAGS_BROWSE = $(CFLAGS_BROWSE)"; \
+	[ -n "$(ENABLE_FULL_DEBUG_SYMBOLS)" ] && \
+	    echo && echo "ENABLE_FULL_DEBUG_SYMBOLS = $(ENABLE_FULL_DEBUG_SYMBOLS)"; \
+	[ -n "$(OBJCOPY)" ] && \
+	    echo && echo "OBJCOPY = $(OBJCOPY)"; \
+	[ -n "$(STRIP_POLICY)" ] && \
+	    echo && echo "STRIP_POLICY = $(STRIP_POLICY)"; \
+	[ -n "$(ZIP_DEBUGINFO_FILES)" ] && \
+	    echo && echo "ZIP_DEBUGINFO_FILES = $(ZIP_DEBUGINFO_FILES)"; \
+	[ -n "$(ZIPEXE)" ] && \
+	    echo && echo "ZIPEXE = $(ZIPEXE)"; \
 	[ -n "$(HOTSPOT_EXTRA_SYSDEFS)" ] && \
 	    echo && \
 	    echo "HOTSPOT_EXTRA_SYSDEFS\$$(HOTSPOT_EXTRA_SYSDEFS) = $(HOTSPOT_EXTRA_SYSDEFS)" && \
@@ -359,7 +369,7 @@
 	$(QUIETLY) ( \
 	$(BUILDTREE_COMMENT); \
 	echo "JDK=${JAVA_HOME}"; \
-	) > $@	   
+	) > $@
 
 .dbxrc:  $(BUILDTREE_MAKE)
 	@echo Creating $@ ...
--- hotspot/make/bsd/makefiles/defs.make	2012-08-10 09:22:57.000000000 -0700
+++ hotspot/make/bsd/makefiles/defs.make	2013-05-05 09:39:09.000000000 -0700
@@ -86,7 +86,7 @@
     VM_PLATFORM     = bsd_i486
     HS_ARCH         = x86
     # We have to reset ARCH to i386 since SRCARCH relies on it
-    ARCH            = i386   
+    ARCH            = i386
   endif
 endif
 
@@ -124,6 +124,107 @@
   HS_ARCH          = ppc
 endif
 
+# determine if HotSpot is being built in JDK6 or earlier version
+JDK6_OR_EARLIER=0
+ifeq "$(shell expr \( '$(JDK_MAJOR_VERSION)' != '' \& '$(JDK_MINOR_VERSION)' != '' \& '$(JDK_MICRO_VERSION)' != '' \))" "1"
+  # if the longer variable names (newer build style) are set, then check those
+  ifeq "$(shell expr \( $(JDK_MAJOR_VERSION) = 1 \& $(JDK_MINOR_VERSION) \< 7 \))" "1"
+    JDK6_OR_EARLIER=1
+  endif
+else
+  # the longer variables aren't set so check the shorter variable names
+  ifeq "$(shell expr \( '$(JDK_MAJOR_VER)' = 1 \& '$(JDK_MINOR_VER)' \< 7 \))" "1"
+    JDK6_OR_EARLIER=1
+  endif
+endif
+
+ifeq ($(JDK6_OR_EARLIER),0)
+  # Full Debug Symbols is supported on JDK7 or newer.
+  # The Full Debug Symbols (FDS) default for BUILD_FLAVOR == product
+  # builds is enabled with debug info files ZIP'ed to save space. For
+  # BUILD_FLAVOR != product builds, FDS is always enabled, after all a
+  # debug build without debug info isn't very useful.
+  # The ZIP_DEBUGINFO_FILES option only has meaning when FDS is enabled.
+  #
+  # If you invoke a build with FULL_DEBUG_SYMBOLS=0, then FDS will be
+  # disabled for a BUILD_FLAVOR == product build.
+  #
+  # Note: Use of a different variable name for the FDS override option
+  # versus the FDS enabled check is intentional (FULL_DEBUG_SYMBOLS
+  # versus ENABLE_FULL_DEBUG_SYMBOLS). For auto build systems that pass
+  # in options via environment variables, use of distinct variables
+  # prevents strange behaviours. For example, in a BUILD_FLAVOR !=
+  # product build, the FULL_DEBUG_SYMBOLS environment variable will be
+  # 0, but the ENABLE_FULL_DEBUG_SYMBOLS make variable will be 1. If
+  # the same variable name is used, then different values can be picked
+  # up by different parts of the build. Just to be clear, we only need
+  # two variable names because the incoming option value can be
+  # overridden in some situations, e.g., a BUILD_FLAVOR != product
+  # build.
+
+  ifeq ($(BUILD_FLAVOR), product)
+    FULL_DEBUG_SYMBOLS ?= 1
+    ENABLE_FULL_DEBUG_SYMBOLS = $(FULL_DEBUG_SYMBOLS)
+  else
+    # debug variants always get Full Debug Symbols (if available)
+    ENABLE_FULL_DEBUG_SYMBOLS = 1
+  endif
+  _JUNK_ := $(shell \
+    echo >&2 "INFO: ENABLE_FULL_DEBUG_SYMBOLS=$(ENABLE_FULL_DEBUG_SYMBOLS)")
+  # since objcopy is optional, we set ZIP_DEBUGINFO_FILES later
+
+  ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+    # Default OBJCOPY comes from GNU Binutils on Linux:
+    DEF_OBJCOPY=/usr/bin/objcopy
+    ifdef CROSS_COMPILE_ARCH
+      # don't try to generate .debuginfo files when cross compiling
+      _JUNK_ := $(shell \
+        echo >&2 "INFO: cross compiling for ARCH $(CROSS_COMPILE_ARCH)," \
+          "skipping .debuginfo generation.")
+      OBJCOPY=
+    else
+      OBJCOPY=$(shell test -x $(DEF_OBJCOPY) && echo $(DEF_OBJCOPY))
+      ifneq ($(ALT_OBJCOPY),)
+        _JUNK_ := $(shell echo >&2 "INFO: ALT_OBJCOPY=$(ALT_OBJCOPY)")
+        OBJCOPY=$(shell test -x $(ALT_OBJCOPY) && echo $(ALT_OBJCOPY))
+      endif
+    endif
+  else
+    OBJCOPY=
+  endif
+
+  ifeq ($(OBJCOPY),)
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: no objcopy cmd found so cannot create .debuginfo files.")
+    ENABLE_FULL_DEBUG_SYMBOLS=0
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: ENABLE_FULL_DEBUG_SYMBOLS=$(ENABLE_FULL_DEBUG_SYMBOLS)")
+  else
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: $(OBJCOPY) cmd found so will create .debuginfo files.")
+
+    # Library stripping policies for .debuginfo configs:
+    #   all_strip - strips everything from the library
+    #   min_strip - strips most stuff from the library; leaves minimum symbols
+    #   no_strip  - does not strip the library at all
+    #
+    # Oracle security policy requires "all_strip". A waiver was granted on
+    # 2011.09.01 that permits using "min_strip" in the Java JDK and Java JRE.
+    #
+    # Currently, STRIP_POLICY is only used when Full Debug Symbols is enabled.
+    #
+    STRIP_POLICY ?= min_strip
+
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: STRIP_POLICY=$(STRIP_POLICY)")
+
+    ZIP_DEBUGINFO_FILES ?= 1
+
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: ZIP_DEBUGINFO_FILES=$(ZIP_DEBUGINFO_FILES)")
+  endif
+endif
+
 JDK_INCLUDE_SUBDIR=bsd
 
 # Library suffix
@@ -141,18 +242,39 @@
 
 # client and server subdirectories have symbolic links to ../libjsig.so
 EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.$(LIBRARY_SUFFIX)
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  ifeq ($(ZIP_DEBUGINFO_FILES),1)
+    EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.diz
+  else
+    EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.debuginfo
+  endif
+endif
 EXPORT_SERVER_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/server
 EXPORT_CLIENT_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/client
 
 ifndef BUILD_CLIENT_ONLY
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.$(LIBRARY_SUFFIX)
+  ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+    ifeq ($(ZIP_DEBUGINFO_FILES),1)
+      EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.diz
+    else
+      EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.debuginfo
+    endif
+  endif
 endif
 
 ifneq ($(ZERO_BUILD), true)
   ifeq ($(ARCH_DATA_MODEL), 32)
     EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
     EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX)
+    ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+      ifeq ($(ZIP_DEBUGINFO_FILES),1)
+        EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.diz
+      else
+        EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.debuginfo
+      endif
+    endif
   endif
 endif
 
@@ -164,6 +286,15 @@
                         $(EXPORT_LIB_DIR)/sa-jdi.jar
 ADD_SA_BINARIES/universal = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
                             $(EXPORT_LIB_DIR)/sa-jdi.jar
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  ifeq ($(ZIP_DEBUGINFO_FILES),1)
+    ADD_SA_BINARIES/x86   += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.diz
+    ADD_SA_BINARIES/sparc += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.diz
+  else
+    ADD_SA_BINARIES/x86   += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.debuginfo
+    ADD_SA_BINARIES/sparc += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.debuginfo
+  endif
+endif
 ADD_SA_BINARIES/ppc   =
 ADD_SA_BINARIES/ia64  =
 ADD_SA_BINARIES/arm   =
--- hotspot/make/bsd/makefiles/gcc.make	2012-08-10 09:22:57.000000000 -0700
+++ hotspot/make/bsd/makefiles/gcc.make	2013-05-05 09:39:09.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -124,7 +124,11 @@
 ARCHFLAG/ia64    =
 ARCHFLAG/sparc   = -m32 -mcpu=v9
 ARCHFLAG/sparcv9 = -m64 -mcpu=v9
+ARCHFLAG/arm     =  -fsigned-char
 ARCHFLAG/zero    = $(ZERO_ARCHFLAG)
+ifndef E500V2
+ARCHFLAG/ppc     =  -mcpu=powerpc
+endif
 
 # Darwin-specific build flags
 ifeq ($(OS_VENDOR), Darwin)
@@ -285,6 +289,26 @@
 DEBUG_CFLAGS += -gstabs
 endif
 
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  FASTDEBUG_CFLAGS/ia64  = -g
+  FASTDEBUG_CFLAGS/amd64 = -g
+  FASTDEBUG_CFLAGS/arm   = -g
+  FASTDEBUG_CFLAGS/ppc   = -g
+  FASTDEBUG_CFLAGS += $(DEBUG_CFLAGS/$(BUILDARCH))
+  ifeq ($(FASTDEBUG_CFLAGS/$(BUILDARCH)),)
+    FASTDEBUG_CFLAGS += -gstabs
+  endif
+
+  OPT_CFLAGS/ia64  = -g
+  OPT_CFLAGS/amd64 = -g
+  OPT_CFLAGS/arm   = -g
+  OPT_CFLAGS/ppc   = -g
+  OPT_CFLAGS += $(OPT_CFLAGS/$(BUILDARCH))
+  ifeq ($(OPT_CFLAGS/$(BUILDARCH)),)
+    OPT_CFLAGS += -gstabs
+  endif
+endif
+
 # DEBUG_BINARIES overrides everything, use full -g debug information
 ifeq ($(DEBUG_BINARIES), true)
   DEBUG_CFLAGS = -g
@@ -302,3 +326,9 @@
 ifdef MINIMIZE_RAM_USAGE
 CFLAGS += -DMINIMIZE_RAM_USAGE
 endif
+
+ifdef CROSS_COMPILE_ARCH
+  STRIP = $(ALT_COMPILER_PATH)/strip
+else
+  STRIP = strip
+endif
--- hotspot/make/bsd/makefiles/jsig.make	2012-08-10 09:22:58.000000000 -0700
+++ hotspot/make/bsd/makefiles/jsig.make	2013-05-05 09:39:09.000000000 -0700
@@ -36,9 +36,16 @@
   LIBJSIG_G = lib$(JSIG_G).so
 endif
 
+LIBJSIG_DEBUGINFO   = lib$(JSIG).debuginfo
+LIBJSIG_DIZ         = lib$(JSIG).diz
+LIBJSIG_G_DEBUGINFO = lib$(JSIG_G).debuginfo
+LIBJSIG_G_DIZ       = lib$(JSIG_G).diz
+
 JSIGSRCDIR = $(GAMMADIR)/src/os/$(Platform_os_family)/vm
 
 DEST_JSIG  = $(JDK_LIBDIR)/$(LIBJSIG)
+DEST_JSIG_DEBUGINFO = $(JDK_LIBDIR)/$(LIBJSIG_DEBUGINFO)
+DEST_JSIG_DIZ       = $(JDK_LIBDIR)/$(LIBJSIG_DIZ)
 
 LIBJSIG_MAPFILE = $(MAKEFILES_DIR)/mapfile-vers-jsig
 
@@ -57,11 +64,33 @@
 $(LIBJSIG): $(JSIGSRCDIR)/jsig.c $(LIBJSIG_MAPFILE)
 	@echo Making signal interposition lib...
 	$(QUIETLY) $(CC) $(SYMFLAG) $(ARCHFLAG) $(SHARED_FLAG) $(PICFLAG) \
-                         $(LFLAGS_JSIG) $(JSIG_DEBUG_CFLAGS) -o $@ $<
+			$(LFLAGS_JSIG) $(JSIG_DEBUG_CFLAGS) -o $@ $<
 	$(QUIETLY) [ -f $(LIBJSIG_G) ] || { ln -s $@ $(LIBJSIG_G); }
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+	$(QUIETLY) $(OBJCOPY) --only-keep-debug $@ $(LIBJSIG_DEBUGINFO)
+	$(QUIETLY) $(OBJCOPY) --add-gnu-debuglink=$(LIBJSIG_DEBUGINFO) $@
+  ifeq ($(STRIP_POLICY),all_strip)
+	$(QUIETLY) $(STRIP) $@
+  else
+    ifeq ($(STRIP_POLICY),min_strip)
+	$(QUIETLY) $(STRIP) -S $@
+    # implied else here is no stripping at all
+    endif
+  endif
+	[ -f $(LIBJSIG_G_DEBUGINFO) ] || { ln -s $(LIBJSIG_DEBUGINFO) $(LIBJSIG_G_DEBUGINFO); }
+  ifeq ($(ZIP_DEBUGINFO_FILES),1)
+	$(ZIPEXE) -q -y $(LIBJSIG_DIZ) $(LIBJSIG_DEBUGINFO) $(LIBJSIG_G_DEBUGINFO)
+	$(RM) $(LIBJSIG_DEBUGINFO) $(LIBJSIG_G_DEBUGINFO)
+	[ -f $(LIBJSIG_G_DIZ) ] || { ln -s $(LIBJSIG_DIZ) $(LIBJSIG_G_DIZ); }
+  endif
+endif
 
 install_jsig: $(LIBJSIG)
 	@echo "Copying $(LIBJSIG) to $(DEST_JSIG)"
+	$(QUIETLY) test -f $(LIBJSIG_DEBUGINFO) && \
+	    cp -f $(LIBJSIG_DEBUGINFO) $(DEST_JSIG_DEBUGINFO)
+	$(QUIETLY) test -f $(LIBJSIG_DIZ) && \
+	    cp -f $(LIBJSIG_DIZ) $(DEST_JSIG_DIZ)
 	$(QUIETLY) cp -f $(LIBJSIG) $(DEST_JSIG) && echo "Done"
 
 .PHONY: install_jsig
--- hotspot/make/bsd/makefiles/launcher.make	2012-08-10 09:22:58.000000000 -0700
+++ hotspot/make/bsd/makefiles/launcher.make	2013-05-05 09:39:09.000000000 -0700
@@ -50,7 +50,7 @@
   LIBS_LAUNCHER             += $(STATIC_STDCXX) $(LIBS)
 else
   LAUNCHER.o                 = launcher.o
-  LFLAGS_LAUNCHER           += -L`pwd` 
+  LFLAGS_LAUNCHER           += -L`pwd`
 
   # The gamma launcher runs the JDK from $JAVA_HOME, overriding the JVM with a
   # freshly built JVM at ./libjvm.{so|dylib}.  This is accomplished by setting 
--- hotspot/make/bsd/makefiles/mapfile-vers-debug	2012-08-10 09:22:58.000000000 -0700
+++ hotspot/make/bsd/makefiles/mapfile-vers-debug	2013-05-05 09:39:09.000000000 -0700
@@ -221,6 +221,7 @@
                 JVM_SetArrayElement;
                 JVM_SetClassSigners;
                 JVM_SetLength;
+                JVM_SetNativeThreadName;
                 JVM_SetPrimitiveArrayElement;
                 JVM_SetProtectionDomain;
                 JVM_SetSockOpt;
@@ -244,24 +245,6 @@
                 JVM_Yield;
                 JVM_handle_bsd_signal;
 
-                # Old reflection routines
-                # These do not need to be present in the product build in JDK 1.4
-                # but their code has not been removed yet because there will not
-                # be a substantial code savings until JVM_InvokeMethod and
-                # JVM_NewInstanceFromConstructor can also be removed; see
-                # reflectionCompat.hpp.
-                JVM_GetClassConstructor;
-                JVM_GetClassConstructors;
-                JVM_GetClassField;
-                JVM_GetClassFields;
-                JVM_GetClassMethod;
-                JVM_GetClassMethods;
-                JVM_GetField;
-                JVM_GetPrimitiveField;
-                JVM_NewInstance;
-                JVM_SetField;
-                JVM_SetPrimitiveField;
-
                 # debug JVM
                 JVM_AccessVMBooleanFlag;
                 JVM_AccessVMIntFlag;
--- hotspot/make/bsd/makefiles/mapfile-vers-product	2012-08-10 09:22:58.000000000 -0700
+++ hotspot/make/bsd/makefiles/mapfile-vers-product	2013-05-05 09:39:09.000000000 -0700
@@ -221,6 +221,7 @@
                 JVM_SetArrayElement;
                 JVM_SetClassSigners;
                 JVM_SetLength;
+                JVM_SetNativeThreadName;
                 JVM_SetPrimitiveArrayElement;
                 JVM_SetProtectionDomain;
                 JVM_SetSockOpt;
@@ -244,24 +245,6 @@
                 JVM_Yield;
                 JVM_handle_bsd_signal;
 
-                # Old reflection routines
-                # These do not need to be present in the product build in JDK 1.4
-                # but their code has not been removed yet because there will not
-                # be a substantial code savings until JVM_InvokeMethod and
-                # JVM_NewInstanceFromConstructor can also be removed; see
-                # reflectionCompat.hpp.
-                JVM_GetClassConstructor;
-                JVM_GetClassConstructors;
-                JVM_GetClassField;
-                JVM_GetClassFields;
-                JVM_GetClassMethod;
-                JVM_GetClassMethods;
-                JVM_GetField;
-                JVM_GetPrimitiveField;
-                JVM_NewInstance;
-                JVM_SetField;
-                JVM_SetPrimitiveField;
-
                 # miscellaneous functions
                 jio_fprintf;
                 jio_printf;
--- hotspot/make/bsd/makefiles/ppc.make	2012-08-10 09:22:58.000000000 -0700
+++ hotspot/make/bsd/makefiles/ppc.make	2013-05-05 09:39:09.000000000 -0700
@@ -28,3 +28,6 @@
 # Must also specify if CPU is big endian
 CFLAGS += -DVM_BIG_ENDIAN
 
+ifdef E500V2
+ASFLAGS += -Wa,-mspe -Wa,--defsym -Wa,E500V2=1 
+endif
--- hotspot/make/bsd/makefiles/saproc.make	2012-08-10 09:22:59.000000000 -0700
+++ hotspot/make/bsd/makefiles/saproc.make	2013-05-05 09:39:09.000000000 -0700
@@ -36,6 +36,11 @@
   LIBSAPROC_G = lib$(SAPROC_G).so
 endif
 
+LIBSAPROC_DEBUGINFO   = lib$(SAPROC).debuginfo
+LIBSAPROC_DIZ         = lib$(SAPROC).diz
+LIBSAPROC_G_DEBUGINFO = lib$(SAPROC_G).debuginfo
+LIBSAPROC_G_DIZ       = lib$(SAPROC_G).diz
+
 AGENT_DIR = $(GAMMADIR)/agent
 
 SASRCDIR = $(AGENT_DIR)/src/os/$(Platform_os_family)
@@ -66,7 +71,9 @@
 
 SAMAPFILE = $(SASRCDIR)/mapfile
 
-DEST_SAPROC = $(JDK_LIBDIR)/$(LIBSAPROC)
+DEST_SAPROC           = $(JDK_LIBDIR)/$(LIBSAPROC)
+DEST_SAPROC_DEBUGINFO = $(JDK_LIBDIR)/$(LIBSAPROC_DEBUGINFO)
+DEST_SAPROC_DIZ       = $(JDK_LIBDIR)/$(LIBSAPROC_DIZ)
 
 # DEBUG_BINARIES overrides everything, use full -g debug information
 ifeq ($(DEBUG_BINARIES), true)
@@ -114,10 +121,32 @@
 	           -o $@                                                \
 	           $(SALIBS)
 	$(QUIETLY) [ -f $(LIBSAPROC_G) ] || { ln -s $@ $(LIBSAPROC_G); }
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+	$(QUIETLY) $(OBJCOPY) --only-keep-debug $@ $(LIBSAPROC_DEBUGINFO)
+	$(QUIETLY) $(OBJCOPY) --add-gnu-debuglink=$(LIBSAPROC_DEBUGINFO) $@
+  ifeq ($(STRIP_POLICY),all_strip)
+	$(QUIETLY) $(STRIP) $@
+  else
+    ifeq ($(STRIP_POLICY),min_strip)
+	$(QUIETLY) $(STRIP) -S $@
+    # implied else here is no stripping at all
+    endif
+  endif
+	[ -f $(LIBSAPROC_G_DEBUGINFO) ] || { ln -s $(LIBSAPROC_DEBUGINFO) $(LIBSAPROC_G_DEBUGINFO); }
+  ifeq ($(ZIP_DEBUGINFO_FILES),1)
+	$(ZIPEXE) -q -y $(LIBSAPROC_DIZ) $(LIBSAPROC_DEBUGINFO) $(LIBSAPROC_G_DEBUGINFO)
+	$(RM) $(LIBSAPROC_DEBUGINFO) $(LIBSAPROC_G_DEBUGINFO)
+	[ -f $(LIBSAPROC_G_DIZ) ] || { ln -s $(LIBSAPROC_DIZ) $(LIBSAPROC_G_DIZ); }
+  endif
+endif
 
 install_saproc: $(BUILDLIBSAPROC)
 	$(QUIETLY) if [ -e $(LIBSAPROC) ] ; then             \
 	  echo "Copying $(LIBSAPROC) to $(DEST_SAPROC)";     \
+	  test -f $(LIBSAPROC_DEBUGINFO) &&                  \
+	    cp -f $(LIBSAPROC_DEBUGINFO) $(DEST_SAPROC_DEBUGINFO); \
+	  test -f $(LIBSAPROC_DIZ) &&                  \
+	    cp -f $(LIBSAPROC_DIZ) $(DEST_SAPROC_DIZ); \
 	  cp -f $(LIBSAPROC) $(DEST_SAPROC) && echo "Done";  \
 	fi
 
--- hotspot/make/bsd/makefiles/vm.make	2012-08-10 09:22:59.000000000 -0700
+++ hotspot/make/bsd/makefiles/vm.make	2013-05-05 09:39:09.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -60,10 +60,16 @@
 # The order is important for the precompiled headers to work.
 INCLUDES += $(PRECOMPILED_HEADER_DIR:%=-I%) $(Src_Dirs_I:%=-I%)
 
-ifeq (${VERSION}, debug)
+# SYMFLAG is used by {jsig,saproc}.make
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  # always build with debug info when we can create .debuginfo files
   SYMFLAG = -g
 else
-  SYMFLAG =
+  ifeq (${VERSION}, debug)
+    SYMFLAG = -g
+  else
+    SYMFLAG =
+  endif
 endif
 
 # HOTSPOT_RELEASE_VERSION and HOTSPOT_BUILD_VERSION are defined 
@@ -100,9 +106,11 @@
 CXXFLAGS += -DDEFAULT_LIBPATH="\"$(DEFAULT_LIBPATH)\""
 endif
 
-ifndef JAVASE_EMBEDDED
+ifndef JAVASE_EMBEDDED 
+ifneq (${ARCH},arm)
 CFLAGS += -DINCLUDE_TRACE
 endif
+endif
 
 # CFLAGS_WARN holds compiler options to suppress/enable warnings.
 CFLAGS += $(CFLAGS_WARN/BYFILE)
@@ -145,6 +153,11 @@
   LIBJVM_G = lib$(JVM)$(G_SUFFIX).so
 endif
 
+LIBJVM_DEBUGINFO   = lib$(JVM).debuginfo
+LIBJVM_DIZ         = lib$(JVM).diz
+LIBJVM_G_DEBUGINFO = lib$(JVM)$(G_SUFFIX).debuginfo
+LIBJVM_G_DIZ       = lib$(JVM)$(G_SUFFIX).diz
+
 SPECIAL_PATHS:=adlc c1 gc_implementation opto shark libadt
 
 SOURCE_PATHS=\
@@ -155,11 +168,13 @@
 SOURCE_PATHS+=$(HS_COMMON_SRC)/cpu/$(Platform_arch)/vm
 SOURCE_PATHS+=$(HS_COMMON_SRC)/os_cpu/$(Platform_os_arch)/vm
 
-ifndef JAVASE_EMBEDDED
+ifndef JAVASE_EMBEDDED 
+ifneq (${ARCH},arm)
 SOURCE_PATHS+=$(shell if [ -d $(HS_ALT_SRC)/share/vm/jfr ]; then \
   find $(HS_ALT_SRC)/share/vm/jfr -type d; \
   fi)
 endif
+endif
 
 CORE_PATHS=$(foreach path,$(SOURCE_PATHS),$(call altsrc,$(path)) $(path))
 CORE_PATHS+=$(GENERATED)/jvmtifiles
@@ -316,11 +331,38 @@
 	    rm -f $@.1; ln -s $@ $@.1;                                  \
 	    [ -f $(LIBJVM_G) ] || { ln -s $@ $(LIBJVM_G); ln -s $@.1 $(LIBJVM_G).1; }; \
 	}
+ifeq ($(CROSS_COMPILE_ARCH),)
+  ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+	$(QUIETLY) $(OBJCOPY) --only-keep-debug $@ $(LIBJVM_DEBUGINFO)
+	$(QUIETLY) $(OBJCOPY) --add-gnu-debuglink=$(LIBJVM_DEBUGINFO) $@
+    ifeq ($(STRIP_POLICY),all_strip)
+	$(QUIETLY) $(STRIP) $@
+    else
+      ifeq ($(STRIP_POLICY),min_strip)
+	$(QUIETLY) $(STRIP) -S $@
+	# implied else here is no stripping at all
+      endif
+    endif
+	$(QUIETLY) [ -f $(LIBJVM_G_DEBUGINFO) ] || ln -s $(LIBJVM_DEBUGINFO) $(LIBJVM_G_DEBUGINFO)
+    ifeq ($(ZIP_DEBUGINFO_FILES),1)
+	$(ZIPEXE) -q -y $(LIBJVM_DIZ) $(LIBJVM_DEBUGINFO) $(LIBJVM_G_DEBUGINFO)
+	$(RM) $(LIBJVM_DEBUGINFO) $(LIBJVM_G_DEBUGINFO)
+	[ -f $(LIBJVM_G_DIZ) ] || { ln -s $(LIBJVM_DIZ) $(LIBJVM_G_DIZ); }
+    endif
+  endif
+endif
 
-DEST_JVM = $(JDK_LIBDIR)/$(VM_SUBDIR)/$(LIBJVM)
+DEST_SUBDIR        = $(JDK_LIBDIR)/$(VM_SUBDIR)
+DEST_JVM           = $(DEST_SUBDIR)/$(LIBJVM)
+DEST_JVM_DEBUGINFO = $(DEST_SUBDIR)/$(LIBJVM_DEBUGINFO)
+DEST_JVM_DIZ       = $(DEST_SUBDIR)/$(LIBJVM_DIZ)
 
 install_jvm: $(LIBJVM)
 	@echo "Copying $(LIBJVM) to $(DEST_JVM)"
+	$(QUIETLY) test -f $(LIBJVM_DEBUGINFO) && \
+	    cp -f $(LIBJVM_DEBUGINFO) $(DEST_JVM_DEBUGINFO)
+	$(QUIETLY) test -f $(LIBJVM_DIZ) && \
+	    cp -f $(LIBJVM_DIZ) $(DEST_JVM_DIZ)
 	$(QUIETLY) cp -f $(LIBJVM) $(DEST_JVM) && echo "Done"
 
 #----------------------------------------------------------------------
--- hotspot/make/hotspot_version	2012-08-10 09:23:01.000000000 -0700
+++ hotspot/make/hotspot_version	2013-05-05 09:39:09.000000000 -0700
@@ -31,11 +31,11 @@
 #
 
 # Don't put quotes (fail windows build).
-HOTSPOT_VM_COPYRIGHT=Copyright 2012
+HOTSPOT_VM_COPYRIGHT=Copyright 2013
 
 HS_MAJOR_VER=23
-HS_MINOR_VER=2
-HS_BUILD_NUMBER=09
+HS_MINOR_VER=21
+HS_BUILD_NUMBER=01
 
 JDK_MAJOR_VER=1
 JDK_MINOR_VER=7
--- hotspot/make/solaris/makefiles/defs.make	2012-08-10 09:23:12.000000000 -0700
+++ hotspot/make/solaris/makefiles/defs.make	2013-05-05 09:39:09.000000000 -0700
@@ -194,8 +194,8 @@
 endif
 ifeq ($(ARCH_DATA_MODEL), 32)
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX) 
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_db.$(LIBRARY_SUFFIX) 
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX)
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_db.$(LIBRARY_SUFFIX)
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_dtrace.$(LIBRARY_SUFFIX)
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/64/libjvm_db.$(LIBRARY_SUFFIX)
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/64/libjvm_dtrace.$(LIBRARY_SUFFIX)
--- hotspot/src/cpu/sparc/vm/globals_sparc.hpp	2012-08-10 09:23:56.000000000 -0700
+++ hotspot/src/cpu/sparc/vm/globals_sparc.hpp	2013-05-05 09:39:10.000000000 -0700
@@ -71,7 +71,11 @@
 define_pd_global(bool, RewriteBytecodes,     true);
 define_pd_global(bool, RewriteFrequentPairs, true);
 
+#ifdef _ALLBSD_SOURCE
+define_pd_global(bool, UseMembar,            true);
+#else
 define_pd_global(bool, UseMembar,            false);
+#endif
 
 // GC Ergo Flags
 define_pd_global(intx, CMSYoungGenPerWorker, 16*M);  // default max size of CMS young gen, per GC worker thread
--- hotspot/src/cpu/sparc/vm/methodHandles_sparc.cpp	2012-08-10 09:23:58.000000000 -0700
+++ hotspot/src/cpu/sparc/vm/methodHandles_sparc.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -698,6 +698,17 @@
   if (arg_slots.is_constant() && arg_slots.as_constant() == 0)
     return;
 
+  // We have to insert at least one word, so bang the stack.
+  if (UseStackBanging) {
+    // Save G3_method_handle since bang_stack_with_offset uses it as a temp register
+    __ mov(G3_method_handle, temp_reg);
+    int frame_size = (arg_slots.is_constant() ? -1 * arg_slots.as_constant() * wordSize : 0);
+    if (frame_size <= 0)
+      frame_size = 256 * Interpreter::stackElementSize;  // conservative
+    __ generate_stack_overflow_check(frame_size);
+    __ mov(temp_reg, G3_method_handle);
+  }
+
   assert_different_registers(argslot_reg, temp_reg, temp2_reg, temp3_reg,
                              (!arg_slots.is_register() ? Gargs : arg_slots.as_register()));
 
@@ -1702,6 +1713,14 @@
                         "copied argument(s) must fall within current frame");
       }
 
+      if (UseStackBanging) {
+        // Save G3_method_handle since bang_stack_with_offset uses it as a temp register
+        __ mov(G3_method_handle, O3_scratch);
+         // Bang the stack before pushing args.
+        int frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+        __ mov(O3_scratch, G3_method_handle);
+      }
       // insert location is always the bottom of the argument list:
       __ neg(O1_stack_move);
       push_arg_slots(_masm, O0_argslot, O1_stack_move, O2_scratch, O3_scratch);
@@ -2118,6 +2137,18 @@
       // The return handler will further cut back the stack when it takes
       // down the RF.  Perhaps there is a way to streamline this further.
 
+      if (UseStackBanging) {
+        // Save G3_method_handle since bang_stack_with_offset uses it as a temp register
+        __ mov(G3_method_handle, O4_scratch);
+        // Bang the stack before recursive call.
+        // Even if slots == 0, we are inside a RicochetFrame.
+        int frame_size = collect_count.is_constant() ? collect_count.as_constant() * wordSize : -1;
+        if (frame_size < 0) {
+          frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        }
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+        __ mov(O4_scratch, G3_method_handle);
+      }
       // State during recursive call:
       // ... keep1 | dest | dest=42 | keep3 | RF... | collect | bounce_pc |
       __ jump_to_method_handle_entry(G3_method_handle, O1_scratch);
--- hotspot/src/cpu/x86/vm/methodHandles_x86.cpp	2012-08-10 09:24:07.000000000 -0700
+++ hotspot/src/cpu/x86/vm/methodHandles_x86.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -691,6 +691,14 @@
   if (VerifyMethodHandles)
     verify_stack_move(_masm, arg_slots, -1);
 
+  // We have to insert at least one word, so bang the stack.
+  if (UseStackBanging) {
+    int frame_size = (arg_slots.is_constant() ? -1 * arg_slots.as_constant() * wordSize : 0);
+    if (frame_size <= 0)
+      frame_size = 256 * Interpreter::stackElementSize;  // conservative
+    __ generate_stack_overflow_check(frame_size);
+  }
+
   // Make space on the stack for the inserted argument(s).
   // Then pull down everything shallower than rax_argslot.
   // The stacked return address gets pulled down with everything else.
@@ -1769,6 +1777,11 @@
                         "copied argument(s) must fall within current frame");
       }
 
+      if (UseStackBanging) {
+        // Bang the stack before pushing args.
+        int frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+      }
       // insert location is always the bottom of the argument list:
       Address insert_location = __ argument_address(constant(0));
       int pre_arg_words = insert_location.disp() / wordSize;   // return PC is pushed
@@ -2206,6 +2219,15 @@
       // The return handler will further cut back the stack when it takes
       // down the RF.  Perhaps there is a way to streamline this further.
 
+      if (UseStackBanging) {
+        // Bang the stack before recursive call.
+        // Even if slots == 0, we are inside a RicochetFrame.
+        int frame_size = collect_count.is_constant() ? collect_count.as_constant() * wordSize : -1;
+        if (frame_size < 0) {
+          frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        }
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+      }
       // State during recursive call:
       // ... keep1 | dest | dest=42 | keep3 | RF... | collect | bounce_pc |
       __ jump_to_method_handle_entry(rcx_recv, rdx_temp);
@@ -2366,10 +2388,15 @@
         // case in a 32-bit version of the VM) we have to save 'rsi'
         // on the stack because later on (at 'L_array_is_empty') 'rsi'
         // will be overwritten.
-        { if (rsi_temp == saved_last_sp)  __ push(saved_last_sp); }
+        if (rsi_temp == saved_last_sp) {
+          __ push(saved_last_sp);
+          // Need to re-push return PC to keep it on stack top.
+          __ lea(saved_last_sp, ExternalAddress(SharedRuntime::ricochet_blob()->bounce_addr()).addr());
+          __ push(saved_last_sp);
+        }
         // Also prepare a handy macro which restores 'rsi' if required.
 #define UNPUSH_RSI                                                      \
-        { if (rsi_temp == saved_last_sp)  __ pop(saved_last_sp); }
+        { if (rsi_temp == saved_last_sp) { __ pop(saved_last_sp); __ pop(saved_last_sp); } }
 
         __ jmp(L_array_is_empty);
         __ bind(L_skip);
@@ -2382,7 +2409,12 @@
       // called in the case of a null pointer exception will not be
       // confused by the extra value on the stack (it expects the
       // return pointer on top of the stack)
-      { if (rsi_temp == saved_last_sp)  __ push(saved_last_sp); }
+      if (rsi_temp == saved_last_sp) {
+        __ push(saved_last_sp);
+        // Need to re-push return PC to keep it on stack top.
+        __ lea(saved_last_sp, ExternalAddress(SharedRuntime::ricochet_blob()->bounce_addr()).addr());
+        __ push(saved_last_sp);
+      }
 
       // Check the array type.
       Register rbx_klass = rbx_temp;
--- hotspot/src/os/bsd/vm/decoder_bsd.cpp	1969-12-31 16:00:00.000000000 -0800
+++ hotspot/src/os/bsd/vm/decoder_bsd.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "prims/jvm.h"
+#include "utilities/decoder_elf.hpp"
+
+#include <cxxabi.h>
+
+bool ElfDecoder::demangle(const char* symbol, char *buf, int buflen) {
+  int   status;
+  char* result;
+  size_t size = (size_t)buflen;
+
+  // Don't pass buf to __cxa_demangle. In case of the 'buf' is too small,
+  // __cxa_demangle will call system "realloc" for additional memory, which
+  // may use different malloc/realloc mechanism that allocates 'buf'.
+  if ((result = abi::__cxa_demangle(symbol, NULL, NULL, &status)) != NULL) {
+    jio_snprintf(buf, buflen, "%s", result);
+      // call c library's free
+      ::free(result);
+      return true;
+  }
+  return false;
+}
+
--- hotspot/src/os/bsd/vm/os_bsd.cpp	2012-08-10 09:24:18.000000000 -0700
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -2341,14 +2341,14 @@
 }
 
 void os::print_os_info_brief(outputStream* st) {
-  st->print("Bsd");
+  st->print("BSD");
 
   os::Posix::print_uname_info(st);
 }
 
 void os::print_os_info(outputStream* st) {
   st->print("OS:");
-  st->print("Bsd");
+  st->print("BSD");
 
   os::Posix::print_uname_info(st);
 
@@ -2357,10 +2357,6 @@
   os::Posix::print_load_average(st);
 }
 
-void os::pd_print_cpu_info(outputStream* st) {
-  // Nothing to do for now.
-}
-
 void os::print_memory_info(outputStream* st) {
 
   st->print("Memory:");
@@ -2377,6 +2373,7 @@
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
 #ifndef _ALLBSD_SOURCE
+  // FIXME: Make this work for *BSD
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
@@ -2384,12 +2381,22 @@
 #endif
   st->cr();
 
+  // FIXME: Make this work for *BSD
   // meminfo
   st->print("\n/proc/meminfo:\n");
   _print_ascii_file("/proc/meminfo", st);
   st->cr();
 }
 
+void os::pd_print_cpu_info(outputStream* st) {
+  // FIXME: Make this work for *BSD
+  st->print("\n/proc/cpuinfo:\n");
+  if (!_print_ascii_file("/proc/cpuinfo", st)) {
+    st->print("  <Not Available>");
+  }
+  st->cr();
+}
+
 // Taken from /usr/include/bits/siginfo.h  Supposed to be architecture specific
 // but they're the same for all the bsd arch that we support
 // and they're the same for solaris but there's no common place to put this.
@@ -2532,6 +2539,25 @@
         len = strlen(buf);
         jrelib_p = buf + len;
 
+#ifndef __APPLE__
+        snprintf(jrelib_p, buflen-len, "/jre/lib/%s", cpu_arch);
+        if (0 != access(buf, F_OK)) {
+          snprintf(jrelib_p, buflen-len, "/lib/%s", cpu_arch);
+        }
+
+        if (0 == access(buf, F_OK)) {
+          // Use current module name "libjvm[_g].so" instead of
+          // "libjvm"debug_only("_g")".so" since for fastdebug version
+          // we should have "libjvm.so" but debug_only("_g") adds "_g"!
+          len = strlen(buf);
+          snprintf(buf + len, buflen-len, "/hotspot/libjvm%s.so", p);
+        } else {
+          // Go back to path of .so
+          rp = realpath(dli_fname, buf);
+          if (rp == NULL)
+            return;
+        }
+#else
         // Add the appropriate library subdir
         snprintf(jrelib_p, buflen-len, "/jre/lib");
         if (0 != access(buf, F_OK)) {
@@ -2561,6 +2587,7 @@
           if (rp == NULL)
             return;
         }
+#endif
       }
     }
   }
@@ -2817,7 +2844,11 @@
 }
 
 void os::free_memory(char *addr, size_t bytes, size_t alignment_hint) {
+#if !defined(__APPLE__) && !defined(__FreeBSD__)
+  commit_memory(addr, bytes, alignment_hint, false);
+#else
   ::madvise(addr, bytes, MADV_DONTNEED);
+#endif
 }
 
 void os::numa_make_global(char *addr, size_t bytes) {
--- hotspot/src/os/bsd/vm/os_bsd.hpp	2012-08-10 09:24:18.000000000 -0700
+++ hotspot/src/os/bsd/vm/os_bsd.hpp	2013-05-05 09:39:10.000000000 -0700
@@ -103,6 +103,12 @@
 
   static bool hugetlbfs_sanity_check(bool warn, size_t page_size);
 
+  static void print_full_memory_info(outputStream* st);
+#ifndef _ALLBSD_SOURCE
+  static void print_distro_info(outputStream* st);
+  static void print_libversion_info(outputStream* st);
+#endif
+
  public:
 
   static void init_thread_fpu_state();
--- hotspot/src/os/bsd/vm/os_bsd.inline.hpp	2012-08-10 09:24:18.000000000 -0700
+++ hotspot/src/os/bsd/vm/os_bsd.inline.hpp	2013-05-05 09:39:10.000000000 -0700
@@ -31,10 +31,22 @@
 # include "atomic_bsd_x86.inline.hpp"
 # include "orderAccess_bsd_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_sparc
+# include "atomic_bsd_sparc.inline.hpp"
+# include "orderAccess_bsd_sparc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_zero
 # include "atomic_bsd_zero.inline.hpp"
 # include "orderAccess_bsd_zero.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_arm
+# include "atomic_bsd_arm.inline.hpp"
+# include "orderAccess_bsd_arm.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "atomic_bsd_ppc.inline.hpp"
+# include "orderAccess_bsd_ppc.inline.hpp"
+#endif
 
 // System includes
 
--- hotspot/src/os/bsd/vm/thread_bsd.inline.hpp	2012-08-10 09:24:18.000000000 -0700
+++ hotspot/src/os/bsd/vm/thread_bsd.inline.hpp	2013-05-05 09:39:10.000000000 -0700
@@ -34,11 +34,26 @@
 # include "orderAccess_bsd_x86.inline.hpp"
 # include "prefetch_bsd_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_sparc
+# include "atomic_bsd_sparc.inline.hpp"
+# include "orderAccess_bsd_sparc.inline.hpp"
+# include "prefetch_bsd_sparc.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_bsd_zero
 # include "atomic_bsd_zero.inline.hpp"
 # include "orderAccess_bsd_zero.inline.hpp"
 # include "prefetch_bsd_zero.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_arm
+# include "atomic_bsd_arm.inline.hpp"
+# include "orderAccess_bsd_arm.inline.hpp"
+# include "prefetch_bsd_arm.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_ppc
+# include "atomic_bsd_ppc.inline.hpp"
+# include "orderAccess_bsd_ppc.inline.hpp"
+# include "prefetch_bsd_ppc.inline.hpp"
+#endif
 
 // Contains inlined functions for class Thread and ThreadLocalStorage
 
--- hotspot/src/os/posix/vm/os_posix.cpp	2012-08-10 09:24:20.000000000 -0700
+++ hotspot/src/os/posix/vm/os_posix.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -75,6 +75,47 @@
   return;
 }
 
+// Multiple threads can race in this code, and can remap over each other with MAP_FIXED,
+// so on posix, unmap the section at the start and at the end of the chunk that we mapped
+// rather than unmapping and remapping the whole chunk to get requested alignment.
+char* os::reserve_memory_aligned(size_t size, size_t alignment) {
+  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,
+      "Alignment must be a multiple of allocation granularity (page size)");
+  assert((size & (alignment -1)) == 0, "size must be 'alignment' aligned");
+
+  size_t extra_size = size + alignment;
+  assert(extra_size >= size, "overflow, size is too large to allow alignment");
+
+  char* extra_base = os::reserve_memory(extra_size, NULL, alignment);
+
+  if (extra_base == NULL) {
+    return NULL;
+  }
+
+  // Do manual alignment
+  char* aligned_base = (char*) align_size_up((uintptr_t) extra_base, alignment);
+
+  // [  |                                       |  ]
+  // ^ extra_base
+  //    ^ extra_base + begin_offset == aligned_base
+  //     extra_base + begin_offset + size       ^
+  //                       extra_base + extra_size ^
+  // |<>| == begin_offset
+  //                              end_offset == |<>|
+  size_t begin_offset = aligned_base - extra_base;
+  size_t end_offset = (extra_base + extra_size) - (aligned_base + size);
+
+  if (begin_offset > 0) {
+      os::release_memory(extra_base, begin_offset);
+  }
+
+  if (end_offset > 0) {
+      os::release_memory(extra_base + begin_offset + size, end_offset);
+  }
+
+  return aligned_base;
+}
+
 void os::Posix::print_load_average(outputStream* st) {
   st->print("load average:");
   double loadavg[3];
@@ -110,11 +151,19 @@
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifdef __OpenBSD__
+  st->print(", DATA ");
+  getrlimit(RLIMIT_DATA, &rlim);
+  if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
+  else st->print("%uk", rlim.rlim_cur >> 10);
+  st->cr();
+#else
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%uk", rlim.rlim_cur >> 10);
   st->cr();
+#endif
 }
 
 void os::Posix::print_uname_info(outputStream* st) {
--- hotspot/src/os/windows/vm/os_windows.cpp	2012-08-10 09:24:30.000000000 -0700
+++ hotspot/src/os/windows/vm/os_windows.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -2941,6 +2941,36 @@
   }
 }
 
+// Multiple threads can race in this code but it's not possible to unmap small sections of
+// virtual space to get requested alignment, like posix-like os's.
+// Windows prevents multiple thread from remapping over each other so this loop is thread-safe.
+char* os::reserve_memory_aligned(size_t size, size_t alignment) {
+  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,
+         "Alignment must be a multiple of allocation granularity (page size)");
+  assert((size & (alignment -1)) == 0, "size must be 'alignment' aligned");
+
+  size_t extra_size = size + alignment;
+  assert(extra_size >= size, "overflow, size is too large to allow alignment");
+
+  char* aligned_base = NULL;
+
+  do {
+    char* extra_base = os::reserve_memory(extra_size, NULL, alignment);
+    if (extra_base == NULL) {
+      return NULL;
+    }
+    // Do manual alignment
+    aligned_base = (char*) align_size_up((uintptr_t) extra_base, alignment);
+
+    os::release_memory(extra_base, extra_size);
+
+    aligned_base = os::reserve_memory(size, aligned_base);
+
+  } while (aligned_base == NULL);
+
+  return aligned_base;
+}
+
 char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
   assert((size_t)addr % os::vm_allocation_granularity() == 0,
          "reserve alignment");
--- hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp	2012-08-10 09:24:32.000000000 -0700
+++ hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp	2013-05-05 09:39:10.000000000 -0700
@@ -52,7 +52,7 @@
   /* Posix Thread IDs   */                                                \
   /**********************/                                                \
                                                                           \
-  declare_unsigned_integer_type(thread_t)                                 \
+  declare_unsigned_integer_type(OS_THREAD_ID_TYPE)                        \
   declare_unsigned_integer_type(pthread_t)                                \
                                                                           \
   /* This must be the last entry, and must be present */                  \
--- hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp	2012-08-10 09:24:33.000000000 -0700
+++ hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp	2013-05-05 09:39:10.000000000 -0700
@@ -24,7 +24,7 @@
  */
 
 #if defined(_ALLBSD_SOURCE) && !defined(__APPLE__) && !defined(__NetBSD__)
-#include <pthread.h>
+# include <pthread.h>
 # include <pthread_np.h> /* For pthread_attr_get_np */
 #endif
 
--- hotspot/src/share/vm/compiler/compilerOracle.cpp	2012-08-10 09:26:19.000000000 -0700
+++ hotspot/src/share/vm/compiler/compilerOracle.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -575,7 +575,7 @@
   char token[1024];
   int  pos = 0;
   int  c = getc(stream);
-  while(c != EOF) {
+  while(c != EOF && pos < (int)(sizeof(token)-1)) {
     if (c == '\n') {
       token[pos++] = '\0';
       parse_from_line(token);
@@ -596,7 +596,7 @@
   int  pos = 0;
   const char* sp = str;
   int  c = *sp++;
-  while (c != '\0') {
+  while (c != '\0' && pos < (int)(sizeof(token)-1)) {
     if (c == '\n') {
       token[pos++] = '\0';
       parse_line(token);
--- hotspot/src/share/vm/interpreter/linkResolver.cpp	2012-08-10 09:27:05.000000000 -0700
+++ hotspot/src/share/vm/interpreter/linkResolver.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -712,7 +712,7 @@
 
     if (check_access &&
         // a) check if ACC_SUPER flag is set for the current class
-        current_klass->is_super() &&
+        (current_klass->is_super() || !AllowNonVirtualCalls) &&
         // b) check if the method class is a superclass of the current class (superclass relation is not reflexive!)
         current_klass->is_subtype_of(method_klass()) && current_klass() != method_klass() &&
         // c) check if the method is not <init>
--- hotspot/src/share/vm/oops/cpCacheOop.cpp	2012-08-10 09:27:18.000000000 -0700
+++ hotspot/src/share/vm/oops/cpCacheOop.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -470,6 +470,24 @@
   return false;
 }
 
+// a constant pool cache entry should never contain old or obsolete methods
+bool ConstantPoolCacheEntry::check_no_old_or_obsolete_entries() {
+  if (is_vfinal()) {
+    // virtual and final so _f2 contains method ptr instead of vtable index
+    methodOop m = (methodOop)_f2;
+    // Return false if _f2 refers to an old or an obsolete method.
+    // _f2 == NULL || !m->is_method() are just as unexpected here.
+    return (m != NULL && m->is_method() && !m->is_old() && !m->is_obsolete());
+  } else if ((oop)_f1 == NULL || !((oop)_f1)->is_method()) {
+    // _f1 == NULL || !_f1->is_method() are OK here
+    return true;
+  }
+
+  methodOop m = (methodOop)_f1;
+  // return false if _f1 refers to an old or an obsolete method
+  return (!m->is_old() && !m->is_obsolete());
+}
+
 bool ConstantPoolCacheEntry::is_interesting_method_entry(klassOop k) {
   if (!is_method_entry()) {
     // not a method entry so not interesting by default
@@ -492,7 +510,7 @@
   }
 
   assert(m != NULL && m->is_method(), "sanity check");
-  if (m == NULL || !m->is_method() || m->method_holder() != k) {
+  if (m == NULL || !m->is_method() || (k != NULL && m->method_holder() != k)) {
     // robustness for above sanity checks or method is not in
     // the interesting class
     return false;
@@ -577,3 +595,22 @@
     }
   }
 }
+
+// the constant pool cache should never contain old or obsolete methods
+bool constantPoolCacheOopDesc::check_no_old_or_obsolete_entries() {
+  for (int i = 1; i < length(); i++) {
+    if (entry_at(i)->is_interesting_method_entry(NULL) &&
+        !entry_at(i)->check_no_old_or_obsolete_entries()) {
+      return false;
+    }
+  }
+  return true;
+}
+
+void constantPoolCacheOopDesc::dump_cache() {
+  for (int i = 1; i < length(); i++) {
+    if (entry_at(i)->is_interesting_method_entry(NULL)) {
+      entry_at(i)->print(tty, i);
+    }
+  }
+}
--- hotspot/src/share/vm/oops/cpCacheOop.hpp	2012-08-10 09:27:18.000000000 -0700
+++ hotspot/src/share/vm/oops/cpCacheOop.hpp	2013-05-05 09:39:12.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -298,6 +298,7 @@
   // group don't print the klass name.
   bool adjust_method_entry(methodOop old_method, methodOop new_method,
          bool * trace_name_printed);
+  bool check_no_old_or_obsolete_entries();
   bool is_interesting_method_entry(klassOop k);
   bool is_field_entry() const                    { return (_flags & (1 << hotSwapBit)) == 0; }
   bool is_method_entry() const                   { return (_flags & (1 << hotSwapBit)) != 0; }
@@ -405,6 +406,8 @@
   // group don't print the klass name.
   void adjust_method_entries(methodOop* old_methods, methodOop* new_methods,
                              int methods_length, bool * trace_name_printed);
+  bool check_no_old_or_obsolete_entries();
+  void dump_cache();
 };
 
 #endif // SHARE_VM_OOPS_CPCACHEOOP_HPP
--- hotspot/src/share/vm/oops/klassVtable.cpp	2012-08-10 09:27:23.000000000 -0700
+++ hotspot/src/share/vm/oops/klassVtable.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -640,11 +640,37 @@
                                 new_method->name()->as_C_string(),
                                 new_method->signature()->as_C_string()));
         }
+        // cannot 'break' here; see for-loop comment above.
       }
     }
   }
 }
 
+// a vtable should never contain old or obsolete methods
+bool klassVtable::check_no_old_or_obsolete_entries() {
+  for (int i = 0; i < length(); i++) {
+    methodOop m = unchecked_method_at(i);
+    if (m != NULL && (m->is_old() || m->is_obsolete())) {
+      return false;
+    }
+  }
+  return true;
+}
+
+void klassVtable::dump_vtable() {
+  tty->print_cr("vtable dump --");
+  for (int i = 0; i < length(); i++) {
+    methodOop m = unchecked_method_at(i);
+    if (m != NULL) {
+      tty->print("      (%5d)  ", i);
+      m->access_flags().print_on(tty);
+      tty->print(" --  ");
+      m->print_name(tty);
+      tty->cr();
+    }
+  }
+}
+
 // CDS/RedefineClasses support - clear vtables so they can be reinitialized
 void klassVtable::clear_vtable() {
   for (int i = 0; i < _length; i++) table()[i].clear();
@@ -994,13 +1020,42 @@
             new_method->name()->as_C_string(),
             new_method->signature()->as_C_string()));
         }
-        break;
+        // cannot 'break' here; see for-loop comment above.
       }
       ime++;
     }
   }
 }
 
+// an itable should never contain old or obsolete methods
+bool klassItable::check_no_old_or_obsolete_entries() {
+  itableMethodEntry* ime = method_entry(0);
+  for (int i = 0; i < _size_method_table; i++) {
+    methodOop m = ime->method();
+    if (m != NULL && (m->is_old() || m->is_obsolete())) {
+      return false;
+    }
+    ime++;
+  }
+  return true;
+}
+
+void klassItable::dump_itable() {
+  itableMethodEntry* ime = method_entry(0);
+  tty->print_cr("itable dump --");
+  for (int i = 0; i < _size_method_table; i++) {
+    methodOop m = ime->method();
+    if (m != NULL) {
+      tty->print("      (%5d)  ", i);
+      m->access_flags().print_on(tty);
+      tty->print(" --  ");
+      m->print_name(tty);
+      tty->cr();
+    }
+    ime++;
+  }
+}
+
 
 // Setup
 class InterfaceVisiterClosure : public StackObj {
@@ -1287,33 +1342,6 @@
   tty->print_cr("%6d bytes total", total);
 }
 
-bool klassVtable::check_no_old_entries() {
-  // Check that there really is no entry
-  for (int i = 0; i < length(); i++) {
-    methodOop m = unchecked_method_at(i);
-    if (m != NULL) {
-        if (m->is_old()) {
-            return false;
-        }
-    }
-  }
-  return true;
-}
-
-void klassVtable::dump_vtable() {
-  tty->print_cr("vtable dump --");
-  for (int i = 0; i < length(); i++) {
-    methodOop m = unchecked_method_at(i);
-    if (m != NULL) {
-      tty->print("      (%5d)  ", i);
-      m->access_flags().print_on(tty);
-      tty->print(" --  ");
-      m->print_name(tty);
-      tty->cr();
-    }
-  }
-}
-
 int  klassItable::_total_classes;   // Total no. of classes with itables
 long klassItable::_total_size;      // Total no. of bytes used for itables
 
--- hotspot/src/share/vm/oops/klassVtable.hpp	2012-08-10 09:27:23.000000000 -0700
+++ hotspot/src/share/vm/oops/klassVtable.hpp	2013-05-05 09:39:12.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -98,6 +98,8 @@
   // group don't print the klass name.
   void adjust_method_entries(methodOop* old_methods, methodOop* new_methods,
                              int methods_length, bool * trace_name_printed);
+  bool check_no_old_or_obsolete_entries();
+  void dump_vtable();
 
   // Garbage collection
   void oop_follow_contents();
@@ -118,11 +120,6 @@
   void verify(outputStream* st, bool force = false);
   static void print_statistics()                            PRODUCT_RETURN;
 
-#ifndef PRODUCT
-  bool check_no_old_entries();
-  void dump_vtable();
-#endif
-
  protected:
   friend class vtableEntry;
  private:
@@ -292,6 +289,8 @@
   // group don't print the klass name.
   void adjust_method_entries(methodOop* old_methods, methodOop* new_methods,
                              int methods_length, bool * trace_name_printed);
+  bool check_no_old_or_obsolete_entries();
+  void dump_itable();
 
   // Garbage collection
   void oop_follow_contents();
--- hotspot/src/share/vm/oops/methodOop.cpp	2012-08-10 09:27:25.000000000 -0700
+++ hotspot/src/share/vm/oops/methodOop.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1346,10 +1346,6 @@
 }
 
 
-//-----------------------------------------------------------------------------------
-// Non-product code
-
-#ifndef PRODUCT
 class SignatureTypePrinter : public SignatureTypeNames {
  private:
   outputStream* _st;
@@ -1386,6 +1382,10 @@
 }
 
 
+//-----------------------------------------------------------------------------------
+// Non-product code
+
+#ifndef PRODUCT
 void methodOopDesc::print_codes_on(outputStream* st) const {
   print_codes_on(0, code_size(), st);
 }
--- hotspot/src/share/vm/oops/methodOop.hpp	2012-08-10 09:27:26.000000000 -0700
+++ hotspot/src/share/vm/oops/methodOop.hpp	2013-05-05 09:39:12.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -703,8 +703,8 @@
   static bool has_unloaded_classes_in_signature(methodHandle m, TRAPS);
 
   // Printing
-  void print_short_name(outputStream* st)        /*PRODUCT_RETURN*/; // prints as klassname::methodname; Exposed so field engineers can debug VM
-  void print_name(outputStream* st)              PRODUCT_RETURN; // prints as "virtual void foo(int)"
+  void print_short_name(outputStream* st); // prints as klassname::methodname; Exposed so field engineers can debug VM
+  void print_name(outputStream* st); // prints as "virtual void foo(int)"; exposed for TraceRedefineClasses
 
   // Helper routine used for method sorting
   static void sort_methods(objArrayOop methods,
--- hotspot/src/share/vm/opto/library_call.cpp	2012-08-10 09:27:37.000000000 -0700
+++ hotspot/src/share/vm/opto/library_call.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -3931,7 +3931,8 @@
       }
     }
   }
-  else if (method->is_method_handle_adapter()) {
+
+  if (method->is_method_handle_adapter()) {
     // This is an internal adapter frame from the MethodHandleCompiler -- skip it
     return true;
   }
@@ -5476,4 +5477,3 @@
   push(result);
   return true;
 }
-
--- hotspot/src/share/vm/opto/loopTransform.cpp	2012-08-10 09:27:38.000000000 -0700
+++ hotspot/src/share/vm/opto/loopTransform.cpp	2013-05-05 09:39:12.000000000 -0700
@@ -2733,6 +2733,8 @@
   result_mem = new (C, 1) ProjNode(call,TypeFunc::Memory);
   _igvn.register_new_node_with_optimizer(result_mem);
 
+/* Disable following optimization until proper fix (add missing checks).
+
   // If this fill is tightly coupled to an allocation and overwrites
   // the whole body, allow it to take over the zeroing.
   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, this);
@@ -2756,6 +2758,7 @@
 #endif
     }
   }
+*/
 
   // Redirect the old control and memory edges that are outside the loop.
   Node* exit = head->loopexit()->proj_out(0);
--- hotspot/src/share/vm/prims/jvmtiRedefineClasses.cpp	2012-08-10 09:27:50.000000000 -0700
+++ hotspot/src/share/vm/prims/jvmtiRedefineClasses.cpp	2013-05-05 09:39:13.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -129,8 +129,15 @@
   // See jvmtiExport.hpp for detailed explanation.
   JvmtiExport::set_has_redefined_a_class();
 
-#ifdef ASSERT
-  SystemDictionary::classes_do(check_class, thread);
+// check_class() is optionally called for product bits, but is
+// always called for non-product bits.
+#ifdef PRODUCT
+  if (RC_TRACE_ENABLED(0x00004000)) {
+#endif
+    RC_TRACE_WITH_THREAD(0x00004000, thread, ("calling check_class"));
+    SystemDictionary::classes_do(check_class, thread);
+#ifdef PRODUCT
+  }
 #endif
 }
 
@@ -3366,76 +3373,116 @@
   }
 }
 
-#ifndef PRODUCT
 void VM_RedefineClasses::check_class(klassOop k_oop,
        oop initiating_loader, TRAPS) {
   Klass *k = k_oop->klass_part();
   if (k->oop_is_instance()) {
     HandleMark hm(THREAD);
     instanceKlass *ik = (instanceKlass *) k;
+    bool no_old_methods = true;  // be optimistic
+    ResourceMark rm(THREAD);
 
-    if (ik->vtable_length() > 0) {
-      ResourceMark rm(THREAD);
-      if (!ik->vtable()->check_no_old_entries()) {
-        tty->print_cr("klassVtable::check_no_old_entries failure -- OLD method found -- class: %s", ik->signature_name());
+    // a vtable should never contain old or obsolete methods
+    if (ik->vtable_length() > 0 &&
+        !ik->vtable()->check_no_old_or_obsolete_entries()) {
+      if (RC_TRACE_ENABLED(0x00004000)) {
+        RC_TRACE_WITH_THREAD(0x00004000, THREAD,
+          ("klassVtable::check_no_old_or_obsolete_entries failure"
+           " -- OLD or OBSOLETE method found -- class: %s",
+           ik->signature_name()));
         ik->vtable()->dump_vtable();
+      }
+      no_old_methods = false;
+    }
+
+    // an itable should never contain old or obsolete methods
+    if (ik->itable_length() > 0 &&
+        !ik->itable()->check_no_old_or_obsolete_entries()) {
+      if (RC_TRACE_ENABLED(0x00004000)) {
+        RC_TRACE_WITH_THREAD(0x00004000, THREAD,
+          ("klassItable::check_no_old_or_obsolete_entries failure"
+           " -- OLD or OBSOLETE method found -- class: %s",
+           ik->signature_name()));
+        ik->itable()->dump_itable();
+      }
+      no_old_methods = false;
+    }
+
+    // the constant pool cache should never contain old or obsolete methods
+    if (ik->constants() != NULL &&
+        ik->constants()->cache() != NULL &&
+        !ik->constants()->cache()->check_no_old_or_obsolete_entries()) {
+      if (RC_TRACE_ENABLED(0x00004000)) {
+        RC_TRACE_WITH_THREAD(0x00004000, THREAD,
+          ("cp-cache::check_no_old_or_obsolete_entries failure"
+           " -- OLD or OBSOLETE method found -- class: %s",
+           ik->signature_name()));
+        ik->constants()->cache()->dump_cache();
+      }
+      no_old_methods = false;
+    }
+
+    if (!no_old_methods) {
+      if (RC_TRACE_ENABLED(0x00004000)) {
         dump_methods();
-        assert(false, "OLD method found");
+      } else {
+        tty->print_cr("INFO: use the '-XX:TraceRedefineClasses=16384' option "
+          "to see more info about the following guarantee() failure.");
       }
+      guarantee(false, "OLD and/or OBSOLETE method(s) found");
     }
   }
 }
 
 void VM_RedefineClasses::dump_methods() {
-        int j;
-        tty->print_cr("_old_methods --");
-        for (j = 0; j < _old_methods->length(); ++j) {
-          methodOop m = (methodOop) _old_methods->obj_at(j);
-          tty->print("%4d  (%5d)  ", j, m->vtable_index());
-          m->access_flags().print_on(tty);
-          tty->print(" --  ");
-          m->print_name(tty);
-          tty->cr();
-        }
-        tty->print_cr("_new_methods --");
-        for (j = 0; j < _new_methods->length(); ++j) {
-          methodOop m = (methodOop) _new_methods->obj_at(j);
-          tty->print("%4d  (%5d)  ", j, m->vtable_index());
-          m->access_flags().print_on(tty);
-          tty->print(" --  ");
-          m->print_name(tty);
-          tty->cr();
-        }
-        tty->print_cr("_matching_(old/new)_methods --");
-        for (j = 0; j < _matching_methods_length; ++j) {
-          methodOop m = _matching_old_methods[j];
-          tty->print("%4d  (%5d)  ", j, m->vtable_index());
-          m->access_flags().print_on(tty);
-          tty->print(" --  ");
-          m->print_name(tty);
-          tty->cr();
-          m = _matching_new_methods[j];
-          tty->print("      (%5d)  ", m->vtable_index());
-          m->access_flags().print_on(tty);
-          tty->cr();
-        }
-        tty->print_cr("_deleted_methods --");
-        for (j = 0; j < _deleted_methods_length; ++j) {
-          methodOop m = _deleted_methods[j];
-          tty->print("%4d  (%5d)  ", j, m->vtable_index());
-          m->access_flags().print_on(tty);
-          tty->print(" --  ");
-          m->print_name(tty);
-          tty->cr();
-        }
-        tty->print_cr("_added_methods --");
-        for (j = 0; j < _added_methods_length; ++j) {
-          methodOop m = _added_methods[j];
-          tty->print("%4d  (%5d)  ", j, m->vtable_index());
-          m->access_flags().print_on(tty);
-          tty->print(" --  ");
-          m->print_name(tty);
-          tty->cr();
-        }
+  int j;
+  RC_TRACE(0x00004000, ("_old_methods --"));
+  for (j = 0; j < _old_methods->length(); ++j) {
+    methodOop m = (methodOop) _old_methods->obj_at(j);
+    RC_TRACE_NO_CR(0x00004000, ("%4d  (%5d)  ", j, m->vtable_index()));
+    m->access_flags().print_on(tty);
+    tty->print(" --  ");
+    m->print_name(tty);
+    tty->cr();
+  }
+  RC_TRACE(0x00004000, ("_new_methods --"));
+  for (j = 0; j < _new_methods->length(); ++j) {
+    methodOop m = (methodOop) _new_methods->obj_at(j);
+    RC_TRACE_NO_CR(0x00004000, ("%4d  (%5d)  ", j, m->vtable_index()));
+    m->access_flags().print_on(tty);
+    tty->print(" --  ");
+    m->print_name(tty);
+    tty->cr();
+  }
+  RC_TRACE(0x00004000, ("_matching_(old/new)_methods --"));
+  for (j = 0; j < _matching_methods_length; ++j) {
+    methodOop m = _matching_old_methods[j];
+    RC_TRACE_NO_CR(0x00004000, ("%4d  (%5d)  ", j, m->vtable_index()));
+    m->access_flags().print_on(tty);
+    tty->print(" --  ");
+    m->print_name(tty);
+    tty->cr();
+    m = _matching_new_methods[j];
+    RC_TRACE_NO_CR(0x00004000, ("      (%5d)  ", m->vtable_index()));
+    m->access_flags().print_on(tty);
+    tty->cr();
+  }
+  RC_TRACE(0x00004000, ("_deleted_methods --"));
+  for (j = 0; j < _deleted_methods_length; ++j) {
+    methodOop m = _deleted_methods[j];
+    RC_TRACE_NO_CR(0x00004000, ("%4d  (%5d)  ", j, m->vtable_index()));
+    m->access_flags().print_on(tty);
+    tty->print(" --  ");
+    m->print_name(tty);
+    tty->cr();
+  }
+  RC_TRACE(0x00004000, ("_added_methods --"));
+  for (j = 0; j < _added_methods_length; ++j) {
+    methodOop m = _added_methods[j];
+    RC_TRACE_NO_CR(0x00004000, ("%4d  (%5d)  ", j, m->vtable_index()));
+    m->access_flags().print_on(tty);
+    tty->print(" --  ");
+    m->print_name(tty);
+    tty->cr();
+  }
 }
-#endif
--- hotspot/src/share/vm/prims/jvmtiRedefineClasses.hpp	2012-08-10 09:27:50.000000000 -0700
+++ hotspot/src/share/vm/prims/jvmtiRedefineClasses.hpp	2013-05-05 09:39:13.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -478,9 +478,8 @@
 
   void flush_dependent_code(instanceKlassHandle k_h, TRAPS);
 
-  static void check_class(klassOop k_oop, oop initiating_loader, TRAPS) PRODUCT_RETURN;
-
-  static void dump_methods()   PRODUCT_RETURN;
+  static void check_class(klassOop k_oop, oop initiating_loader, TRAPS);
+  static void dump_methods();
 
  public:
   VM_RedefineClasses(jint class_count,
--- hotspot/src/share/vm/prims/jvmtiRedefineClassesTrace.hpp	2012-08-10 09:27:50.000000000 -0700
+++ hotspot/src/share/vm/prims/jvmtiRedefineClassesTrace.hpp	2013-05-05 09:39:13.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -54,7 +54,7 @@
 //    0x00000800 |       2048 - previous class breakpoint mgmt
 //    0x00001000 |       4096 - detect calls to obsolete methods
 //    0x00002000 |       8192 - fail a guarantee() in addition to detection
-//    0x00004000 |      16384 - unused
+//    0x00004000 |      16384 - detect old/obsolete methods in metadata
 //    0x00008000 |      32768 - old/new method matching/add/delete
 //    0x00010000 |      65536 - impl details: CP size info
 //    0x00020000 |     131072 - impl details: CP merge pass info
@@ -82,6 +82,13 @@
     tty->print_cr args; \
   } while (0)
 
+#define RC_TRACE_NO_CR(level, args) \
+  if ((TraceRedefineClasses & level) != 0) { \
+    ResourceMark rm; \
+    tty->print("RedefineClasses-0x%x: ", level); \
+    tty->print args; \
+  } while (0)
+
 #define RC_TRACE_WITH_THREAD(level, thread, args) \
   if ((TraceRedefineClasses & level) != 0) { \
     ResourceMark rm(thread); \
--- hotspot/src/share/vm/prims/methodHandles.cpp	2012-08-10 09:27:52.000000000 -0700
+++ hotspot/src/share/vm/prims/methodHandles.cpp	2013-05-05 09:39:13.000000000 -0700
@@ -645,6 +645,13 @@
         }
       }
       methodHandle m = result.resolved_method();
+      KlassHandle mklass = m->method_holder();
+      KlassHandle receiver_limit = result.resolved_klass();
+      if (receiver_limit.is_null() ||
+          // ignore passed-in limit; interfaces are interconvertible
+          receiver_limit->is_interface() && mklass->is_interface()) {
+        receiver_limit = mklass;
+      }
       oop vmtarget = NULL;
       int vmindex = methodOopDesc::nonvirtual_vtable_index;
       if (defc->is_interface()) {
@@ -665,6 +672,7 @@
       java_lang_invoke_MemberName::set_vmtarget(mname(), vmtarget);
       java_lang_invoke_MemberName::set_vmindex(mname(),  vmindex);
       java_lang_invoke_MemberName::set_modifiers(mname(), mods);
+      java_lang_invoke_MemberName::set_clazz(mname(), receiver_limit->java_mirror());
       DEBUG_ONLY(KlassHandle junk1; int junk2);
       assert(decode_MemberName(mname(), junk1, junk2) == result.resolved_method(),
              "properly stored for later decoding");
--- hotspot/src/share/vm/runtime/arguments.cpp	2012-08-10 09:27:53.000000000 -0700
+++ hotspot/src/share/vm/runtime/arguments.cpp	2013-05-05 09:39:13.000000000 -0700
@@ -829,6 +829,9 @@
     } else {
       jio_fprintf(defaultStream::error_stream(), "%s", locked_message_buf);
     }
+  } else {
+    jio_fprintf(defaultStream::error_stream(),
+                "Unrecognized VM option '%s'\n", argname);
   }
 
   // allow for commandline "commenting out" options like -XX:#+Verbose
@@ -857,7 +860,7 @@
   bool result         = true;
 
   int c = getc(stream);
-  while(c != EOF) {
+  while(c != EOF && pos < (int)(sizeof(token)-1)) {
     if (in_white_space) {
       if (in_comment) {
         if (c == '\n') in_comment = false;
--- hotspot/src/share/vm/runtime/atomic.cpp	2012-08-10 09:27:53.000000000 -0700
+++ hotspot/src/share/vm/runtime/atomic.cpp	2013-05-05 09:39:13.000000000 -0700
@@ -54,6 +54,12 @@
 #ifdef TARGET_OS_ARCH_windows_x86
 # include "atomic_windows_x86.inline.hpp"
 #endif
+#ifdef TARGET_OS_ARCH_bsd_x86
+# include "atomic_bsd_x86.inline.hpp"
+#endif
+#ifdef TARGET_OS_ARCH_bsd_zero
+# include "atomic_bsd_zero.inline.hpp"
+#endif
 #ifdef TARGET_OS_ARCH_linux_arm
 # include "atomic_linux_arm.inline.hpp"
 #endif
--- hotspot/src/share/vm/runtime/globals.hpp	2012-08-10 09:27:59.000000000 -0700
+++ hotspot/src/share/vm/runtime/globals.hpp	2013-05-05 09:39:13.000000000 -0700
@@ -3902,7 +3902,10 @@
   product(bool, UseVMInterruptibleIO, false,                                \
           "(Unstable, Solaris-specific) Thread interrupt before or with "   \
           "EINTR for I/O operations results in OS_INTRPT. The default value"\
-          " of this flag is true for JDK 6 and earlier")
+          " of this flag is true for JDK 6 and earlier")                    \
+                                                                            \
+  product(bool, AllowNonVirtualCalls, false,                                \
+         "Obey the ACC_SUPER flag and allow invokenonvirtual calls")
 
 /*
  *  Macros for factoring of globals
--- hotspot/src/share/vm/runtime/os.hpp	2012-08-10 09:28:05.000000000 -0700
+++ hotspot/src/share/vm/runtime/os.hpp	2013-05-05 09:39:13.000000000 -0700
@@ -30,6 +30,9 @@
 #include "runtime/extendedPC.hpp"
 #include "runtime/handles.hpp"
 #include "utilities/top.hpp"
+#ifdef TARGET_OS_FAMILY_bsd
+# include "jvm_bsd.h"
+#endif
 #ifdef TARGET_OS_FAMILY_linux
 # include "jvm_linux.h"
 #endif
@@ -233,6 +236,7 @@
   static int    vm_allocation_granularity();
   static char*  reserve_memory(size_t bytes, char* addr = 0,
                                size_t alignment_hint = 0);
+  static char*  reserve_memory_aligned(size_t size, size_t alignment);
   static char*  attempt_reserve_memory_at(size_t bytes, char* addr);
   static void   split_reserved_memory(char *base, size_t size,
                                       size_t split, bool realloc);
@@ -694,8 +698,8 @@
 # include "os_windows.hpp"
 #endif
 #ifdef TARGET_OS_FAMILY_bsd
-# include "os_posix.hpp"
 # include "os_bsd.hpp"
+# include "os_posix.hpp"
 #endif
 #ifdef TARGET_OS_ARCH_linux_x86
 # include "os_linux_x86.hpp"
--- hotspot/src/share/vm/runtime/thread.cpp	2012-08-10 09:28:14.000000000 -0700
+++ hotspot/src/share/vm/runtime/thread.cpp	2013-05-05 09:39:13.000000000 -0700
@@ -3555,6 +3555,9 @@
       os::dll_build_name(buffer, sizeof(buffer), Arguments::get_dll_dir(), name);
       library = os::dll_load(buffer, ebuf, sizeof ebuf);
 #ifdef KERNEL
+
+      // Dead code, KERNEL is never built in JDK7 or later. This code will be removed in a future update release.
+
       // Download instrument dll
       if (library == NULL && strcmp(name, "instrument") == 0) {
         char *props = Arguments::get_kernel_properties();
--- hotspot/src/share/vm/runtime/virtualspace.cpp	2012-08-10 09:28:16.000000000 -0700
+++ hotspot/src/share/vm/runtime/virtualspace.cpp	2013-05-05 09:39:13.000000000 -0700
@@ -340,20 +340,9 @@
     if ((((size_t)base + noaccess_prefix) & (alignment - 1)) != 0) {
       // Base not aligned, retry
       if (!os::release_memory(base, size)) fatal("os::release_memory failed");
-      // Reserve size large enough to do manual alignment and
-      // increase size to a multiple of the desired alignment
+      // Make sure that size is aligned
       size = align_size_up(size, alignment);
-      size_t extra_size = size + alignment;
-      do {
-        char* extra_base = os::reserve_memory(extra_size, NULL, alignment);
-        if (extra_base == NULL) return;
-        // Do manual alignement
-        base = (char*) align_size_up((uintptr_t) extra_base, alignment);
-        assert(base >= extra_base, "just checking");
-        // Re-reserve the region at the aligned base address.
-        os::release_memory(extra_base, extra_size);
-        base = os::reserve_memory(size, base);
-      } while (base == NULL);
+      base = os::reserve_memory_aligned(size, alignment);
 
       if (requested_address != 0 &&
           failed_to_reserve_as_requested(base, requested_address, size, false)) {
--- hotspot/src/share/vm/utilities/accessFlags.cpp	2012-08-10 09:28:53.000000000 -0700
+++ hotspot/src/share/vm/utilities/accessFlags.cpp	2013-05-05 09:39:11.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -59,8 +59,6 @@
   } while(f != old_flags);
 }
 
-#ifndef PRODUCT
-
 void AccessFlags::print_on(outputStream* st) const {
   if (is_public      ()) st->print("public "      );
   if (is_private     ()) st->print("private "     );
@@ -79,8 +77,6 @@
   if (is_obsolete    ()) st->print("{obsolete} "  );
 }
 
-#endif
-
 void accessFlags_init() {
   assert(sizeof(AccessFlags) == sizeof(jint), "just checking size of flags");
 }
--- hotspot/src/share/vm/utilities/accessFlags.hpp	2012-08-10 09:28:53.000000000 -0700
+++ hotspot/src/share/vm/utilities/accessFlags.hpp	2013-05-05 09:39:11.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -233,7 +233,7 @@
   inline friend AccessFlags accessFlags_from(jint flags);
 
   // Printing/debugging
-  void print_on(outputStream* st) const PRODUCT_RETURN;
+  void print_on(outputStream* st) const;
 };
 
 inline AccessFlags accessFlags_from(jint flags) {
--- hotspot/test/compiler/5091921/Test7005594.sh	2012-08-10 09:28:58.000000000 -0700
+++ hotspot/test/compiler/5091921/Test7005594.sh	2013-05-05 09:39:13.000000000 -0700
@@ -71,6 +71,9 @@
   # Windows/MKS
   MEM=`"$ROOTDIR/mksnt/sysinf" memory -v | grep "Total Physical Memory: " | sed 's/Total Physical Memory: *//g'`
   MEM="$(($machine_memory / 1024))"
+elif [ -n `sysctl -n hw.physmem64 2> /dev/null` -o -n `sysctl -n hw.physmem 2> /dev/null` ];
+  # BSD
+  MEM=`sysctl -n hw.physmem64 2> /dev/null || sysctl -n hw.physmem) | awk '{print int($$NF / 1048576); }'`
 else
   echo "Unable to determine amount of physical memory on the machine"
 fi
--- hotspot/test/compiler/7158807/Test7158807.java	1969-12-31 16:00:00.000000000 -0800
+++ hotspot/test/compiler/7158807/Test7158807.java	2013-05-05 09:39:13.000000000 -0700
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/**
+ * @test
+ * @bug 7158807
+ * @summary Revise stack management with volatile call sites
+ * @author Marc Schonefeld
+ *
+ * @run main/othervm -XX:CompileThreshold=100 -Xbatch -Xss248k Test7158807
+ */
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VolatileCallSite;
+
+public class Test7158807 {
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) throws Throwable {
+        for (int i = 0; i < 25600; i++) {
+            MethodType mt = MethodType.methodType(java.lang.String.class);
+            System.out.println(mt);
+            MethodType mt3 = null;
+            try {
+              mt3 = MethodType.genericMethodType(i);
+            } catch (IllegalArgumentException e) {
+              System.out.println("Passed");
+              System.exit(95);
+            }
+            System.out.println(i+":");
+            try {
+                VolatileCallSite vcs = new VolatileCallSite(mt3);
+                System.out.println(vcs);
+                MethodHandle mh = vcs.dynamicInvoker();
+                vcs.setTarget(mh);
+                // System.out.println(mh);
+                mh.invoke(mt, mh);
+            } catch (Throwable e) {
+            }
+        }
+    }
+}
+
--- hotspot/test/gc/6941923/test6941923.sh	2012-08-10 09:29:15.000000000 -0700
+++ hotspot/test/gc/6941923/test6941923.sh	2013-05-05 09:39:13.000000000 -0700
@@ -9,7 +9,7 @@
 ## skip on windows
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD )
     NULL=/dev/null
     PS=":"
     FS="/"
--- hotspot/test/runtime/7020373/Test7020373.sh	2012-08-10 09:29:17.000000000 -0700
+++ hotspot/test/runtime/7020373/Test7020373.sh	2013-05-05 09:39:13.000000000 -0700
@@ -32,7 +32,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- hotspot/test/runtime/7110720/Test7110720.sh	2012-08-10 09:29:18.000000000 -0700
+++ hotspot/test/runtime/7110720/Test7110720.sh	2013-05-05 09:39:13.000000000 -0700
@@ -37,7 +37,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD )
     FS="/"
     RM=/bin/rm
     CP=/bin/cp
--- hotspot/test/runtime/7158800/BadUtf8.java	2012-08-10 09:29:18.000000000 -0700
+++ hotspot/test/runtime/7158800/BadUtf8.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,1254 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 7158800
- * @summary Test that 1200 symbols that hash to the same value triggers
- * the symbol table alternate hashing mechanism.  There isn't actually a
- * way to verify this.
- */
-//
-// Generate large number of strings that hash to the same value
-// to slow down symbol table lookup.
-
-import java.io.BufferedOutputStream;
-import java.io.FileOutputStream;
-
-public class BadUtf8 {
-static String[] strings = {
-    "EOcLKvbddZyPxYpb",
-    "DncLKvbdPxmAGrqj",
-    "DoCjjvbdpxoIHQdY",
-    "EPCkKvbdqYoHfqEY",
-    "DnbkKvbdezvYdiUX",
-    "DnbjjvbdeEoRbXCj",
-    "EObkKvbdbsCkUEKB",
-    "EOcLKvbdnUtyjiqf",
-    "DncLKvbdRWnDcMHc",
-    "DoCkKvbdrSUkOLAm",
-    "DncLKvbdfNFwGmJk",
-    "EPDLKvbdvAdYroFI",
-    "DoDLKvbdiGibyViu",
-    "DncLKvbdYqNEhmFR",
-    "DoCkKvbdEARhlzXX",
-    "DncLKvbdSZjHsCvA",
-    "DncKjvbdqTsgRqkU",
-    "DnbjjvbdqAiFAXHd",
-    "EPDKjvbdGcjvJaij",
-    "DnbkKvbdwtldpxkn",
-    "DoDKjvbdYkrETnMN",
-    "EPCjjvbdbBWEfQQX",
-    "EPCjjvbduMXwAtBX",
-    "DncLKvbdbsCkTcia",
-    "DoCjjvbdczYpYZRC",
-    "EOcKjvbdFeiqmhsq",
-    "DoCkKvbdKCicQibx",
-    "EOcKjvbdZLrEUOLm",
-    "DoCjjvbdaNKbStmH",
-    "DoDKjvbdJbjDQjDY",
-    "EPCkKvbdemFwGmKL",
-    "EPDKjvbdZQleImEq",
-    "DncKjvbdZjShPfbG",
-    "DnbjjvbdqYnhHREY",
-    "DoCkKvbdaRfDIUGL",
-    "DoDKjvbdLrWlyuQz",
-    "DnbjjvbdZisHofaf",
-    "EObjjvbdhtydvrUb",
-    "DnbjjvbdRotHKGEX",
-    "EObjjvbdNeEThhkE",
-    "EPCjjvbdZtJJZESn",
-    "DoDKjvbdnPyxvLYb",
-    "EPDKjvbdeEoRbWbj",
-    "EOcLKvbdFxttaEXb",
-    "EObjjvbddwystRez",
-    "EPCjjvbdJpzEnenF",
-    "DnbkKvbdTppntuIN",
-    "EPCkKvbdTukpKUBR",
-    "DnbkKvbdhlFEOUcZ",
-    "EObkKvbdlhdUQuRa",
-    "DnbjjvbdkClKqHUg",
-    "EOcKjvbdqTtGqqkU",
-    "DncKjvbdtkwvaUBX",
-    "DoDKjvbdsQWOjCuf",
-    "DncLKvbdEKIJuwjA",
-    "DncKjvbdGLErcIMu",
-    "EOcLKvbdNPwpumfs",
-    "EObkKvbdnVUzLJrG",
-    "DoCkKvbdcTDKsdKB",
-    "DncKjvbdKRZdoFme",
-    "EOcLKvbdemFvgNKL",
-    "EPCkKvbdznopdblY",
-    "EPDLKvbdOYPVzdOU",
-    "DnbjjvbdsZlPsAhO",
-    "DoDLKvbdKCjDRKDY",
-    "DoCkKvbdhuZeXSVC",
-    "EPDKjvbdOStVgEtp",
-    "DncLKvbdvwMAvBWV",
-    "EPDKjvbdBcoaWJlf",
-    "EOcKjvbdZxdKODMS",
-    "DoCjjvbdbsCkTcjB",
-    "EOcLKvbdwWlAuaWV",
-    "DnbjjvbdFejRnJUR",
-    "DnbjjvbdmIdTqVSB",
-    "DnbkKvbdqBIeAWhE",
-    "DncKjvbdrMzJyMIJ",
-    "DoCkKvbdZGvdAOsJ",
-    "DncLKvbdjggLfFnL",
-    "DoCjjvbdYqNFJMdq",
-    "DoCkKvbdqZPHfqDx",
-    "DncLKvbdOEdThiLE",
-    "DoCkKvbdZirgpGaf",
-    "EPDLKvbdziuQPdSt",
-    "EObkKvbdKQyeOenF",
-    "DoDLKvbduaDySndh",
-    "DoCjjvbdVUNUGLvK",
-    "DncKjvbdAMhYrvzY",
-    "DnbkKvbdnQZxvKxb",
-    "EPCjjvbdBhjakJFj",
-    "DncLKvbdmfeYNNfy",
-    "DoDLKvbdjlbLydfo",
-    "DoDLKvbdpyPIGpcx",
-    "EOcLKvbdnVUzLJqf",
-    "DoCjjvbdmJETqVSB",
-    "DoDLKvbdJTZAsMxM",
-    "DoCkKvbdnQZxvLZC",
-    "DoDKjvbdACqwizJQ",
-    "DncKjvbdvBEZSoFI",
-    "DncKjvbdGckVjCJj",
-    "DncLKvbdiMFENtcZ",
-    "Dnbjjvbdjuvmcaww",
-    "DnbkKvbdZyEKNblS",
-    "DoCjjvbduMYXBUBX",
-    "DnbjjvbdFWYopNJe",
-    "DoDKjvbdelfXGljL",
-    "DnbjjvbdakLenmcA",
-    "EPDKjvbdfILWRmpg",
-    "EObjjvbdSLYeuHLT",
-    "DoCjjvbdMfbolotk",
-    "EPDLKvbdrRuKnKaN",
-    "EOcKjvbdyzdnRhIh",
-    "DoDLKvbdGAoRZJzm",
-    "DoCjjvbdhlFDnUcZ",
-    "EPDLKvbdmpZyVkYb",
-    "DncKjvbdTpqPUuIN",
-    "DncLKvbdHDjvJaij",
-    "EPDLKvbdYlRcsmkm",
-    "EPDLKvbdvlvAMdFN",
-    "DncKjvbdIsZArmYM",
-    "EOcLKvbdegjuqnQg",
-    "EOcLKvbdZQmFJNFR",
-    "DoCjjvbdZxdJmcMS",
-    "EPCkKvbdlZTSTYgU",
-    "DoDKjvbdqceJPnWB",
-    "DncLKvbdVgwuxGxz",
-    "DncKjvbdDnbkLXDE",
-    "EPDLKvbdatbHYKsh",
-    "DncKjvbdEzsqFLbi",
-    "EPDLKvbdnVVZkKRf",
-    "EOcKjvbdKeegbBQu",
-    "EPCkKvbdKfGHaaRV",
-    "EPDKjvbdmIctRVRa",
-    "EPCjjvbdRMxBxnUz",
-    "DnbjjvbdJYTbILpp",
-    "EPCkKvbdTAEiHbPE",
-    "EOcLKvbdfelZnGgA",
-    "DoCjjvbdOStWGeUp",
-    "EOcLKvbdemGXHNJk",
-    "DoDKjvbdYTMAmUOx",
-    "EPCkKvbdpyOhGpcx",
-    "EPCkKvbdAMgxsWzY",
-    "DnbjjvbdYkrETnMN",
-    "EPDLKvbdUQqPUtgm",
-    "DncKjvbdehKurNqH",
-    "DoCjjvbdZMSETnLm",
-    "DoDKjvbdIHGyyXwg",
-    "EObjjvbdXGYzUAPT",
-    "DoCjjvbdhbPCeWqR",
-    "DoCkKvbdKNADzGuB",
-    "DnbjjvbdFeirOJTq",
-    "DncLKvbdaRecHtFk",
-    "DnbkKvbdzoPpeClY",
-    "EObkKvbdZRMeJMeR",
-    "DnbjjvbdYfvdAPSi",
-    "DncLKvbdJcKCqJcY",
-    "EOcLKvbdqvokbhyR",
-    "DoDLKvbdrRuLNjaN",
-    "DoCjjvbdTlWPBWOi",
-    "DoCkKvbdjvWnEBxX",
-    "DoDLKvbdTkunaVoJ",
-    "DoCkKvbdQZNAHTSK",
-    "EObjjvbdqwPkbhyR",
-    "EOcLKvbdNHDPlpUk",
-    "DncLKvbdIHHZxxYH",
-    "DncLKvbdtkxXAtAw",
-    "DncLKvbdSCEFMJZL",
-    "DnbjjvbdZQmEhldq",
-    "DoCjjvbdNGbolotk",
-    "DnbjjvbdnCKWwnmu",
-    "DncLKvbdzHZMANEw",
-    "DoDKjvbdmttykJrG",
-    "DnbkKvbdlrZUzSci",
-    "EPDKjvbdSKyGVHKs",
-    "DoCjjvbdKVuGEFGi",
-    "EPCjjvbdCIkBkIej",
-    "DncLKvbdzHZMAMeX",
-    "DnbkKvbdaSFbgsek",
-    "DncLKvbdHDjujBij",
-    "DoDKjvbdGZVUaDwb",
-    "DnbjjvbdZnnJFEzK",
-    "DoCkKvbdtcDUwWOo",
-    "DoCkKvbdlBMoNALA",
-    "EOcKjvbdNsUWHFUp",
-    "DoDLKvbdVUNUFlVj",
-    "DnbkKvbdhkdcnUcZ",
-    "DncLKvbdLiBkqYAS",
-    "EOcKjvbdzoPpdcLx",
-    "EPDKjvbdijGIJmXr",
-    "EOcKjvbdZisHofaf",
-    "DoDLKvbdeOdrkUUS",
-    "DoDLKvbdnPyxvKxb",
-    "EPDKjvbdIxUBhMRQ",
-    "DncLKvbdlhctRUqa",
-    "DoDLKvbdmgFXlnGy",
-    "DncKjvbdCJKbKiGK",
-    "EOcLKvbddndrjtUS",
-    "DnbjjvbdkDLjqGuH",
-    "DncKjvbdmIcsptqa",
-    "DoCkKvbdvvlAvBWV",
-    "EObjjvbdjblLQftg",
-    "DnbjjvbdCEQBWKMf",
-    "DnbjjvbdBdPaVilf",
-    "DoCkKvbdZxcjODLr",
-    "DoCkKvbdEObjjwCd",
-    "EPDKjvbdyTNhlqbH",
-    "EPCkKvbdUMVoAvPJ",
-    "DncKjvbdUxhUZjoO",
-    "DncKjvbdqqtjmkAm",
-    "DncKjvbdKfGICBRV",
-    "EPCjjvbdVrOXaeLc",
-    "EPDLKvbdwXLaWBWV",
-    "EPCkKvbdjblKqHUg",
-    "DnbjjvbduDCuWuoP",
-    "EPDKjvbdNGbpMouL",
-    "EObjjvbdBcoaVjNG",
-    "DncLKvbdrWpMDIxq",
-    "DncLKvbdhaoCdwRR",
-    "DnbkKvbdFxtuBDwb",
-    "DncKjvbdIjEAKPgE",
-    "EOcLKvbduCbuXVoP",
-    "DoDKjvbdZtIiZDsO",
-    "DnbjjvbdEztRElCi",
-    "DncLKvbdxmsHwsJD",
-    "DnbjjvbdRbEElIxk",
-    "DoDKjvbdWHwvXgYz",
-    "EOcKjvbdQlwbYnUz",
-    "EOcLKvbdVTltFkuj",
-    "DncKjvbdliETptqa",
-    "DnbkKvbddoErjtTr",
-    "DoCkKvbdgPazvdXh",
-    "DncKjvbdySmhlqag",
-    "DoCjjvbdbPgHDkzd",
-    "DoCkKvbdFWZPomKF",
-    "EObjjvbdssSSxydc",
-    "EObjjvbdzQnliJwA",
-    "EObkKvbdKCjCpibx",
-    "EPCjjvbdpyOhHREY",
-    "DncLKvbddjJqutzn",
-    "EObkKvbdBdQAujMf",
-    "EPCkKvbdLAjflbXq",
-    "DncLKvbdLBLGlaxR",
-    "DoDLKvbdrpWPJbuf",
-    "DoCjjvbdEKHiuxKA",
-    "DoCjjvbdXsMAlsnx",
-    "EObkKvbdptTgSSLU",
-    "DoDKjvbdnHFXmNfy",
-    "DncKjvbdCJKbKhej",
-    "EPCjjvbdhlEdOUby",
-    "EOcKjvbdKWUfEFGi",
-    "DoDKjvbdZQmFJMdq",
-    "EPCjjvbdiGjDZWKV",
-    "EObkKvbdVAbQrprZ",
-    "DoDKjvbdfekzNgHA",
-    "DoDLKvbdnHEwlmgZ",
-    "DncKjvbdwzHeexEr",
-    "DoCjjvbdmpZxujyC",
-    "EPDKjvbdwMvAMcdm",
-    "DoCjjvbdfHkVrNqH",
-    "EPCkKvbdYzbfRiuy",
-    "EPCkKvbdZtIiZDrn",
-    "DnbjjvbdjvWnDbYX",
-    "DoCjjvbdOStVgEtp",
-    "EPDLKvbdZMSETmlN",
-    "EPDKjvbdBhjajhej",
-    "EPCjjvbddoFTLUUS",
-    "DnbkKvbdsQVoJcWG",
-    "EPCjjvbdrEFJQNvB",
-    "DoCjjvbdMpYRWOGs",
-    "EOcLKvbdZirgpHBf",
-    "EPDLKvbdyOTIXsJD",
-    "DoCkKvbdKRZdnfNe",
-    "DnbjjvbdbBWFFoow",
-    "EPCjjvbdgFlZnHHA",
-    "DnbkKvbdGGJrOIsq",
-    "DoDLKvbduDCtwWPP",
-    "EObjjvbdNddUIhjd",
-    "DnbjjvbdxsNiMqag",
-    "EObjjvbddeOrCWbj",
-    "EObjjvbdPxmAGsRj",
-    "EOcLKvbddeOrCXDK",
-    "DoDLKvbddeOrBwCj",
-    "DoCjjvbdVqnYCElD",
-    "DnbkKvbdUyIUZjoO",
-    "EObjjvbdeFOrCXDK",
-    "EObkKvbdVrNxCFLc",
-    "EObjjvbdTfzmkwWF",
-    "EOcKjvbdIHGzZYYH",
-    "EPDKjvbdtbbuXWPP",
-    "DoCjjvbdZisIQHBf",
-    "EObjjvbdbsCkUDjB",
-    "EPCkKvbdVwJXudFH",
-    "EPDKjvbdrouoKDVf",
-    "EPCkKvbdFyVVBEYC",
-    "DncLKvbdZnnIeEzK",
-    "EPDLKvbdxVNFQxkn",
-    "DoDKjvbdpxnggRDx",
-    "DoDLKvbdqZOgfpcx",
-    "DncKjvbdCIjakJGK",
-    "EPCkKvbdCJLBjhej",
-    "DoDLKvbdnPzYvKxb",
-    "EOcKjvbdqTsgSRkU",
-    "EOcLKvbdLBLGlaxR",
-    "DoDLKvbdcbTMrAUN",
-    "DncLKvbdzitoodSt",
-    "DoDKjvbdJvUfDdfi",
-    "EOcLKvbdHDjvKCJj",
-    "EPCkKvbdeOeTKssr",
-    "DnbkKvbdlYrqsYft",
-    "DncLKvbdiiehKMxS",
-    "DncKjvbdURQoVUhN",
-    "DnbkKvbduMYXBUAw",
-    "DoDLKvbdSPtHJfEX",
-    "EObkKvbdqBJFAWgd",
-    "EOcKjvbdFpATWgFy",
-    "DoDLKvbdBsBDTfXS",
-    "DncKjvbdjhHLfFmk",
-    "DoCjjvbdCJKakIfK",
-    "DnbkKvbddoFSjtTr",
-    "EObkKvbdANIYsWzY",
-    "EObjjvbdCTAbtFvr",
-    "EObjjvbdrRtkOLAm",
-    "DnbkKvbdkxsSTYgU",
-    "DoCjjvbdnBiwXnmu",
-    "EObjjvbdwtmEqYlO",
-    "EPDKjvbdrylQTAhO",
-    "DoDLKvbdtbbtvvOo",
-    "EPCjjvbdZLrETmlN",
-    "EPDLKvbdWXJYWDdg",
-    "DoCkKvbdKQzFOfOF",
-    "EPCjjvbdwzIFfXeS",
-    "DncKjvbdRjyFuHLT",
-    "EPDLKvbdULunaWPJ",
-    "DncKjvbdUxhTykOn",
-    "DnbkKvbdJcKCqKDY",
-    "EPDLKvbdcbSmSATm",
-    "DnbkKvbdegjurNqH",
-    "EPDKjvbdZjTIQGbG",
-    "EPCjjvbdiLddNuCy",
-    "DoCjjvbdZQldiNEq",
-    "EOcLKvbdakMGPODA",
-    "EObjjvbdnHEwlmgZ",
-    "EOcLKvbdBsAcUGXS",
-    "EPCkKvbdiVZdwSUb",
-    "EOcLKvbddCTNSAUN",
-    "DnbkKvbdEXxMUUUM",
-    "DncKjvbdYpldiMeR",
-    "DoDKjvbdNddTiIjd",
-    "DoDLKvbdZLqdUNlN",
-    "EPCkKvbdiBncFWpq",
-    "DncLKvbdiCPDEvqR",
-    "EOcKjvbdUyHszKoO",
-    "DncKjvbdhtydvqtb",
-    "EPCjjvbdpxoHgQcx",
-    "EObkKvbdkWWnDaxX",
-    "DnbjjvbdBhkBkJFj",
-    "DoCkKvbdRacdkhyL",
-    "EOcLKvbdZjTHpHCG",
-    "EPCkKvbdMowqWOGs",
-    "DncLKvbdegjurNpg",
-    "EObjjvbdfMfWfmKL",
-    "EPDLKvbdZirgpGaf",
-    "DoDLKvbdiZuFlQnG",
-    "DncLKvbdFxuVAcxC",
-    "EObkKvbdZisHofaf",
-    "EOcKjvbdJSyBSmYM",
-    "EPDLKvbdVYgtZkPO",
-    "EOcKjvbdRbEFMJYk",
-    "DncLKvbdrEFIonWB",
-    "DncKjvbdKDJbqJcY",
-    "EOcLKvbdhfjCxuiu",
-    "EObjjvbdLLAhWAKZ",
-    "DoCkKvbdRXNcblID",
-    "DoDLKvbdcbSmSATm",
-    "EOcLKvbdwWlAvAuu",
-    "EObkKvbdiBnbdvpq",
-    "DoCkKvbdNQXpumgT",
-    "DncLKvbdkVwOECYX",
-    "DnbkKvbdfoazwDxI",
-    "DoDLKvbdbBWFFpPw",
-    "DoDLKvbdvBDxsPEh",
-    "EPDKjvbdJqZdoFme",
-    "DoDLKvbdIryArmXl",
-    "EPCjjvbdANIZSwZx",
-    "EPCkKvbdVhYVxGxz",
-    "DncKjvbdLAjgNCYR",
-    "DncKjvbdxxIjCQZk",
-    "DncKjvbdbiNKKewY",
-    "EPCjjvbdlrZVZsEJ",
-    "EPDKjvbdIryAsMwl",
-    "DoCkKvbdtAHRIAAr",
-    "EPDKjvbdJmAEZfuB",
-    "EPCkKvbdZjSgogBf",
-    "DoDLKvbdOXnuzcnU",
-    "DnbkKvbdehKvRnQg",
-    "EObjjvbdZyDimbkr",
-    "DoDKjvbdmajWwoOV",
-    "EOcKjvbdkMalZeHP",
-    "EOcKjvbdIjEAJpHE",
-    "EPCkKvbdDihKVxKA",
-    "DncKjvbdNddUIiKd",
-    "EObjjvbdqdFIpOWB",
-    "DoCkKvbdxnShXsJD",
-    "DoDLKvbdjmBkzEfo",
-    "EOcLKvbdatagYLTh",
-    "DoCjjvbdVhYVxHYz",
-    "DnbjjvbdJbjDRKDY",
-    "EPCjjvbdLBLHNCYR",
-    "DnbjjvbdnGeYNOGy",
-    "EOcLKvbdUsmTekvK",
-    "EPCjjvbdtkxXBTaX",
-    "EPCjjvbdzoPqFCkx",
-    "DncKjvbdCIjbKhej",
-    "DncKjvbdZLqdTmkm",
-    "DoDKjvbdsPunicVf",
-    "EOcKjvbdmgFXmNgZ",
-    "EObkKvbdiMFENuCy",
-    "DoDKjvbdhanbeXRR",
-    "EObkKvbdACqwiyhp",
-    "DncKjvbdZisIQHBf",
-    "EPCjjvbdgQBzwDwh",
-    "DnbjjvbdyYJJaoyk",
-    "DoDKjvbdxUldqZMO",
-    "EObkKvbdkClLQgVH",
-    "EPCjjvbdZQldiMeR",
-    "EPDLKvbdZyEKOClS",
-    "EPDLKvbdcIlikFvx",
-    "DoDKjvbdrzMQTBHn",
-    "DnbjjvbdVYgtZkPO",
-    "DoDLKvbdHEKuiajK",
-    "EPCkKvbdczZQXxqC",
-    "DoDKjvbdrDdiQNua",
-    "DncLKvbdcImKLGWx",
-    "DoCjjvbdVYgtZkPO",
-    "EPDLKvbdZnnIeFZj",
-    "EPDKjvbdMIakqYAS",
-    "DoCkKvbdSLYfUgLT",
-    "EPDLKvbdiCObdvpq",
-    "DnbjjvbdRpUHKFcw",
-    "DoDLKvbdIHHZyYXg",
-    "EPCjjvbdypoMhiwA",
-    "DnbkKvbdCEPaVjMf",
-    "DnbkKvbderAvzlDP",
-    "DnbkKvbdZQleImFR",
-    "EOcKjvbdKRZdneme",
-    "DoDLKvbdiBnbeXQq",
-    "DncLKvbdEPDKjvcE",
-    "EOcLKvbdauCGwkTh",
-    "DncLKvbdEvZQPmJe",
-    "EPCkKvbdURQnuVIN",
-    "DncLKvbdegjvSOQg",
-    "EPCjjvbdKaKgMawq",
-    "DnbkKvbdRzKISbvA",
-    "DncLKvbdiLdcnUcZ",
-    "EPDLKvbdkDMKpfuH",
-    "DoDLKvbdRbDdkhyL",
-    "DnbjjvbdDwxMUUTl",
-    "DnbkKvbdrpWPKCuf",
-    "DnbkKvbdNVSqjmAX",
-    "DoDKjvbdRbDeMIxk",
-    "EOcLKvbdcyxpXyRC",
-    "DncLKvbdRMwbYnUz",
-    "EObjjvbdqlzJxlHi",
-    "DoCkKvbdJYUCIMQp",
-    "DncLKvbdLZQjSzuG",
-    "EOcKjvbdxVNEqYkn",
-    "DnbkKvbdZoOIeFZj",
-    "DoCjjvbdBraCtFwS",
-    "EOcLKvbdliDsqVSB",
-    "EPCkKvbdeATqNXif",
-    "DncLKvbdkMbLydgP",
-    "EObjjvbdZxdJmbkr",
-    "DoCjjvbdraellHLZ",
-    "EObkKvbduDCuWvPP",
-    "DoCkKvbdpstGrSLU",
-    "DoCjjvbdLGFgbBQu",
-    "DnbkKvbdhtzFWquC",
-    "EObjjvbdoAKztHdO",
-    "EPDLKvbdatafxKtI",
-    "EPDKjvbdkWXNcaww",
-    "DoCkKvbdwkXEHzzG",
-    "EObkKvbdmgEwmNgZ",
-    "DncKjvbdBiLCLJFj",
-    "DoCjjvbdeOdsKssr",
-    "EOcLKvbdfILWSORH",
-    "EObkKvbdCDpAujMf",
-    "EPDKjvbdKDKDQibx",
-    "DoDKjvbdVUMtGLuj",
-    "EObkKvbdrXQMCiYq",
-    "DncKjvbdePEsLTtS",
-    "DncLKvbdDxYLtUTl",
-    "EPCkKvbdGYuVBEYC",
-    "DncLKvbdNeEUIiKd",
-    "EPCkKvbdpxoIHRDx",
-    "EObjjvbdFkEsDHlu",
-    "EObjjvbdssSSxzFD",
-    "DoCkKvbdUtNTfMVj",
-    "DnbjjvbdJcKDRKDY",
-    "DncKjvbdqiAKEmOe",
-    "DoDKjvbdtlXwAtBX",
-    "DnbkKvbdxmsIYTIc",
-    "EObkKvbdLrXMzUpz",
-    "DoCjjvbdkxsSSxft",
-    "DncKjvbdQlwaxnUz",
-    "EObkKvbdjhGlFfNk",
-    "EPCkKvbdxsNhmRag",
-    "DoDLKvbdMfcPmQUk",
-    "DoDKjvbdQvnEDLhD",
-    "EObjjvbdVgxVxHYz",
-    "DoDLKvbdlrYtyrdJ",
-    "DoCjjvbdezvYeIsw",
-    "DncLKvbdNddTiIjd",
-    "EPDLKvbdGGJrNiUR",
-    "EPDLKvbdRzJhTDWA",
-    "EPCjjvbdvvkaWBVu",
-    "EOcKjvbdRXNdCkgc",
-    "EOcKjvbdQZNAHTSK",
-    "EPCkKvbdsCGNLfkZ",
-    "EOcLKvbdDwwktTsl",
-    "EOcLKvbdqlzJyLgi",
-    "EOcLKvbdxsNiMqag",
-    "EOcLKvbdhzVFlROG",
-    "EOcKjvbdEztRFMCi",
-    "DnbkKvbdqiAJdmPF",
-    "EPDLKvbdjcMKqGtg",
-    "EObkKvbdTlWOaWOi",
-    "EPDLKvbdURRPUuHm",
-    "DoDKjvbdelfWgNKL",
-    "EOcLKvbdGAnqZJzm",
-    "EObjjvbdGZUuAdXb",
-    "DoDLKvbduLwwAtAw",
-    "DoCjjvbdZjTIQGbG",
-    "EPCjjvbdRNXbYnUz",
-    "EPDLKvbdiLeENtby",
-    "EObjjvbdMowpunGs",
-    "EOcKjvbdbiNJjevx",
-    "DoDKjvbdEYYLstTl",
-    "DoDLKvbdqUTfrRjt",
-    "DoDKjvbdbsCkUEJa",
-    "DoDKjvbdXsMBNUPY",
-    "EPCjjvbdRNXaxnUz",
-    "DoDLKvbdNGcQNQUk",
-    "DnbjjvbdEARiMywX",
-    "EPDKjvbdSKxfUfkT",
-    "DncKjvbdhtyeXRtb",
-    "DncKjvbdZLqcsnLm",
-    "EObkKvbdZnmheEzK",
-    "EObjjvbdtbcUvuno",
-    "DnbjjvbdrzMQTBHn",
-    "DnbjjvbdDwwktTsl",
-    "EPDKjvbdkxsSTYgU",
-    "DoDKjvbdIryArlxM",
-    "DoDKjvbdnBivxOnV",
-    "DoDKjvbdeATplwif",
-    "EOcLKvbdKeegbApu",
-    "EPCjjvbdMgDQMotk",
-    "DoCjjvbduCbtwWOo",
-    "DnbkKvbdyNsHwrhc",
-    "DnbkKvbdtvNxJpsA",
-    "EOcLKvbdqAheAWgd",
-    "DoCkKvbdURQoUtgm",
-    "EOcKjvbdqceIpOWB",
-    "DoCkKvbdVwIwudFH",
-    "DnbkKvbdbLMFnmcA",
-    "EOcLKvbdZjTHpHBf",
-    "EOcKjvbdRXNdCkhD",
-    "EPDLKvbdiHJcZViu",
-    "DoCjjvbdxxIjCPzL",
-    "DnbkKvbdBcpBWJmG",
-    "EPCkKvbdZyEKOCkr",
-    "EPDKjvbdOTUWHFVQ",
-    "DoCjjvbdIGgZxwwg",
-    "EPDLKvbdFjeSbhMu",
-    "EPDLKvbdhgKCxvJu",
-    "EOcLKvbdNsUWGdtp",
-    "EPDKjvbduVnXipsA",
-    "DncLKvbdGYuVBEXb",
-    "EPDLKvbdZtIhyESn",
-    "DoDKjvbdZxdJmcLr",
-    "DoCjjvbdUsltGLuj",
-    "DoDKjvbdDoDLKvbd",
-    "DncLKvbdrDdhpNvB",
-    "EPDLKvbdKCjDRJbx",
-    "DoDLKvbdxLWdHzyf",
-    "EObkKvbdrzMQTAhO",
-    "EOcLKvbdOFDtJJKd",
-    "EPCkKvbdrSVKmjaN",
-    "EOcKjvbdWWiYVdEg",
-    "EOcKjvbdWWhwvDdg",
-    "DncKjvbdpstHRqjt",
-    "EPCkKvbdKWVFceGi",
-    "DoCkKvbdZjShPfbG",
-    "DoCkKvbdSxKlNzkY",
-    "EPDLKvbdIwtCHkqQ",
-    "EOcKjvbdsCGNLgLZ",
-    "DncKjvbdzaAOfgCM",
-    "DoDLKvbdxmrhYSiD",
-    "DncLKvbdfMfWgMjL",
-    "EPDKjvbdqFdEsuaI",
-    "EOcLKvbdiLeDnUcZ",
-    "DoCjjvbdKVuFceHJ",
-    "DoCjjvbdfekzNgHA",
-    "EOcKjvbdOFEThiLE",
-    "EPDLKvbdqceJPnWB",
-    "DoDLKvbduCbtwWOo",
-    "DncKjvbdTqROtuIN",
-    "DncKjvbdpedFUWBI",
-    "DoDLKvbdrEFJQNua",
-    "DoDLKvbdyXhjCPyk",
-    "EPCkKvbdJYUBhLqQ",
-    "EPCkKvbdtcCuXVno",
-    "DoDLKvbdZLrEUOLm",
-    "EPCkKvbdpstGrRjt",
-    "DncLKvbddePSCXCj",
-    "EObkKvbdauCHXjsh",
-    "DoDLKvbdkHfkefNk",
-    "EObjjvbdMRwMzUpz",
-    "EObjjvbdaMkCTVNH",
-    "DoCkKvbdGGJrNhtR",
-    "EPDLKvbdvBDxrneI",
-    "EPDLKvbdIHHZxwxH",
-    "EOcLKvbdrJAJdmPF",
-    "EOcKjvbdGZUuAdXb",
-    "EOcLKvbdbUbHYLUI",
-    "DnbjjvbdJzofYEAN",
-    "EPDKjvbdFxtuBDxC",
-    "DnbkKvbdQvnDbkgc",
-    "EPDKjvbdJmADzGta",
-    "DoDKjvbdZRMdhleR",
-    "DnbkKvbdsrqsZZeD",
-    "EObkKvbdrovPJbuf",
-    "EPCjjvbddeOqbXCj",
-    "EObjjvbdtcDVXVoP",
-    "DncKjvbdMfbpNQVL",
-    "DoCkKvbdhbPCeXQq",
-    "DoCkKvbdNHComQVL",
-    "EObjjvbdvBDxroFI",
-    "EPCjjvbdnBivwoNu",
-    "EObjjvbdbhljKewY",
-    "EPDKjvbdZyDimcMS",
-    "EObkKvbdWSOXbElD",
-    "EOcKjvbdTfznMXVe",
-    "EPCjjvbdZtJJYcsO",
-    "DoCjjvbdRjxfVHLT",
-    "DoCkKvbdVTltGMVj",
-    "DncKjvbdYfwEAOri",
-    "DncKjvbdYkrEUOMN",
-    "EObkKvbdqGEEsuaI",
-    "DncLKvbdjJfHimXr",
-    "EPDLKvbddndsLUTr",
-    "DnbkKvbdqBJFAWhE",
-    "EPDLKvbdEOcKjwDE",
-    "EPCkKvbdtvOYJqTA",
-    "DncLKvbdkyTRsZHU",
-    "DoCjjvbdTppnuVIN",
-    "DncLKvbdwyhFeweS",
-    "DncKjvbdsBelkgKy",
-    "DoCjjvbdKDKCqJcY",
-    "DoCjjvbdkClKqHVH",
-    "DoCjjvbdcTCjtDia",
-    "EPDLKvbdUVkpJtAq",
-    "EPDLKvbdRyjITCvA",
-    "DnbjjvbdJuuFcdgJ",
-    "DoDKjvbdrJAJdmOe",
-    "DncKjvbdJcJbqKCx",
-    "DoDLKvbdJcJbqJcY",
-    "DoDKjvbdeEoSCXDK",
-    "DoDLKvbdSwjlNzkY",
-    "EObjjvbdzitopDrt",
-    "DoCkKvbdKWVGEEgJ",
-    "DncKjvbdpssfqrKt",
-    "EOcLKvbdUMWPBVoJ",
-    "DncKjvbdyzdmrIIh",
-    "EPCjjvbdxUldqZLn",
-    "DoDLKvbdySnImRbH",
-    "DoCjjvbdGdKvJaij",
-    "DoCkKvbdxZgeewdr",
-    "EObkKvbdiLddNuDZ",
-    "DnbjjvbdSCDdkiZL",
-    "DncKjvbdznpREcMY",
-    "EOcLKvbdaRebhTfL",
-    "DnbjjvbdZQldiMdq",
-    "EPCjjvbdbrbjtEKB",
-    "EOcKjvbdEARiMzXX",
-    "DoDLKvbdXrkaNTnx",
-    "EPCkKvbdQZNAHTRj",
-    "DoDLKvbdEzspeLcJ",
-    "EPCjjvbduVnYKRTA",
-    "EObjjvbdJXtBhMQp",
-    "EPDKjvbdeOdrjssr",
-    "EPCjjvbdLqwMytpz",
-    "EPDKjvbdUMVoBVoJ",
-    "DncKjvbdRpUGifDw",
-    "EPDLKvbdZyDinDLr",
-    "DnbkKvbdNrsufeVQ",
-    "EPCkKvbdZMSDtNlN",
-    "EPCkKvbdySnJNSCH",
-    "EPCjjvbdfMevfljL",
-    "DncLKvbdXsMBNTnx",
-    "DnbkKvbdpxoHfqDx",
-    "DncLKvbdUQpntthN",
-    "DncKjvbdIsZArlwl",
-    "DoDLKvbdZGwEAOsJ",
-    "EOcKjvbdVvhwvDdg",
-    "EOcLKvbduWNxJqTA",
-    "EPCjjvbdHEKvJaij",
-    "DoDKjvbdrpWOjCuf",
-    "DncLKvbdrpWOjDVf",
-    "DoCjjvbdIHGzYwwg",
-    "DoDLKvbdpxoIGqEY",
-    "DoDLKvbdJcJbqKDY",
-    "DoCjjvbdRWmdClHc",
-    "EPCjjvbdFWYopNJe",
-    "DncKjvbdmfdwlmfy",
-    "DoCkKvbdxUleQxlO",
-    "EObjjvbdnGdxMnGy",
-    "EPCjjvbdvvlAvBVu",
-    "DncLKvbddndsKssr",
-    "EObjjvbdZMRcsnLm",
-    "EOcKjvbdFxttaEXb",
-    "DncKjvbdVUNTfMVj",
-    "EOcLKvbdNrtWHFUp",
-    "DoDKjvbdwuMdqYlO",
-    "EPDLKvbdrXPkbhxq",
-    "EObjjvbdrEFIpNua",
-    "EObjjvbdziuQQDrt",
-    "EOcLKvbdqYoIGpcx",
-    "DnbjjvbdsQVoJcVf",
-    "EObkKvbdkDMKpgUg",
-    "EObjjvbdvBDyTPFI",
-    "DncKjvbduCbuWvOo",
-    "EPCjjvbdkVvnECYX",
-    "DncLKvbdZGvdAOri",
-    "DoCkKvbdrXPlDJZR",
-    "EOcLKvbduCcVWvOo",
-    "DoDKjvbdCEPaWJlf",
-    "EPDKjvbddoErjssr",
-    "DncKjvbdACqxKZiQ",
-    "EPCjjvbdUVlPitAq",
-    "EPDKjvbdjJfHjMxS",
-    "EObkKvbdAMhYsWzY",
-    "DoDKjvbdnBivxOmu",
-    "EOcLKvbdbiNKKfXY",
-    "EPDKjvbdYqMeIleR",
-    "EObkKvbdJmADygUa",
-    "EObjjvbdEPDLLWcE",
-    "EPCjjvbdrXPkcIxq",
-    "EOcLKvbdliDtQtqa",
-    "DoCjjvbdmoyxujyC",
-    "EPDLKvbddoFTLTsr",
-    "EOcLKvbdCWzdJEpW",
-    "DnbjjvbdrEEhpOWB",
-    "DoDKjvbdZLrDtNkm",
-    "EOcLKvbdLFfHbAqV",
-    "EOcKjvbdmttzLKSG",
-    "EOcLKvbdmbJvwoOV",
-    "EOcKjvbdUaCQrqSZ",
-    "DnbjjvbdmgExMnGy",
-    "EPDKjvbddndrkUUS",
-    "EObkKvbdDwwkstTl",
-    "DoCkKvbdcJMjLFwY",
-    "DnbjjvbdaNLBruMg",
-    "DoDLKvbdQYmAHTRj",
-    "DnbkKvbdsQWOicWG",
-    "EObkKvbdMRwMzUpz",
-    "DoDLKvbdZshiZDrn",
-    "EPDLKvbdnPzYujxb",
-    "EOcKjvbdCEQAujMf",
-    "EPDLKvbdKefHbApu",
-    "DoDLKvbdYpldiNFR",
-    "DoCkKvbdFWZQQNJe",
-    "DncLKvbdznpQeCkx",
-    "EOcKjvbdnQZxvKxb",
-    "DoCkKvbdVBBprpqy",
-    "DnbkKvbdZirhPfaf",
-    "DnbkKvbdegjvSNqH",
-    "EOcLKvbdqdEiPnWB",
-    "EObjjvbdBhkCKiGK",
-    "EObjjvbdxZgfGYFS",
-    "DnbjjvbdNQYQumgT",
-    "EPCjjvbdxsNhlrBg",
-    "DoCkKvbdQdDApRDr",
-    "DoCkKvbdxxIiaoyk",
-    "EPDKjvbdFeirNhtR",
-    "DoCjjvbdegjvSOQg",
-    "EObkKvbdqcdiQNvB",
-    "DncLKvbdiMEdNtcZ",
-    "DncLKvbdTqRPUthN",
-    "EPCkKvbdwygeexFS",
-    "DoDKjvbdyTOJMrBg",
-    "DncLKvbdeEoRavbj",
-    "EPCjjvbdtbcUvvOo",
-    "EObjjvbdKCicRJcY",
-    "EObjjvbdZyEKODMS",
-    "DnbjjvbdmJDtQtrB",
-    "DncLKvbdEARhlyvw",
-    "DnbjjvbdIxTbILqQ",
-    "EOcLKvbdwygefYFS",
-    "DoCjjvbdznoqFCkx",
-    "DoCjjvbdRpUGjGDw",
-    "DncKjvbdhzVGMQnG",
-    "EPCjjvbdhkeDnVCy",
-    "EObkKvbdOEdUIiKd",
-    "DncKjvbdrDeIomua",
-    "DncLKvbdiHJbxuiu",
-    "EPDKjvbddxZstRez",
-    "EPDLKvbdmSYuZrdJ",
-    "EObkKvbdVUNUFkvK",
-    "EPDLKvbdNeEUJIjd",
-    "DoCkKvbdiMEdNuCy",
-    "DoDLKvbdRDcApQcr",
-    "EPCjjvbdTlVoBVoJ",
-    "EObjjvbdLBKgNBwq",
-    "EPCkKvbdsCFllHKy",
-    "EObjjvbdnVUzLJqf",
-    "DoDKjvbdqrVLNkBN",
-    "DoCkKvbdqFcdtWBI",
-    "DncLKvbdbVCGxLTh",
-    "EOcLKvbdeFPSCXCj",
-    "EOcLKvbdRpTgKFdX",
-    "EObjjvbdznpQeDLx",
-    "EOcKjvbdjvXNcaxX",
-    "DnbjjvbdHDkWJbJj",
-    "DncKjvbdhkeENuDZ",
-    "DnbkKvbdnUtyjjSG",
-    "DoDKjvbdSQUHJfDw",
-    "DncKjvbdbUbHYLUI",
-    "EOcLKvbdNsTvGduQ",
-    "EPDLKvbdSZigsCvA",
-    "DncKjvbdMfcPlpUk",
-    "DoDLKvbdxrnIlrBg",
-    "DncKjvbdiLdcnVCy",
-    "EPCjjvbdmfeYNOHZ",
-    "DoCkKvbdjvWmcaxX",
-    "DoDKjvbdbUbHXkUI",
-    "DncKjvbdBhkBjiFj",
-    "DoDLKvbdNHColpVL",
-    "EOcKjvbdrykosAhO",
-    "DncLKvbdqGDeUVaI",
-    "DnbkKvbdhgJcZViu",
-    "DnbjjvbduLxXAtBX",
-    "EPCjjvbdYpleJNFR",
-    "EPDLKvbdQvmdClHc",
-    "DnbjjvbdJYTbIMRQ",
-    "DncLKvbdznpRFDMY",
-    "EOcLKvbdZnmiFEyj",
-    "DnbkKvbdrRuLOLAm",
-    "EObkKvbdhkeEOUby",
-    "DncLKvbdYlSEUOLm",
-    "DoCjjvbdhkdcmtby",
-    "DncLKvbdddnrCXDK",
-    "DoDLKvbdKaLHNCYR",
-    "EOcKjvbdcyxpYZQb",
-    "EPDLKvbdACqwjZhp",
-    "DoCkKvbdBsBDTevr",
-    "EObkKvbdeKJqvUzn",
-    "EObkKvbdcImJkGWx",
-    "DncLKvbdYSlAltOx",
-    "DncLKvbdlrYtyrdJ",
-    "EObkKvbdKxqJrztf",
-    "EOcKjvbdsQWPJcVf",
-    "DoDKjvbdkySqrxgU",
-    "EObjjvbdeEoRbXCj",
-    "EOcKjvbdHDkVjBij",
-    "DoDLKvbdCTBCsfXS",
-    "DoCjjvbdKCjDQibx",
-    "DoCjjvbdlhdTqUrB",
-    "DoDKjvbdTulQKTaR",
-    "DoCkKvbdRjxetfkT",
-    "EPCjjvbdEuyQQNKF",
-    "EPCjjvbdDoDKkXDE",
-    "DoCjjvbdsQWPJbuf",
-    "DoDKjvbdhuZdvqtb",
-    "EPDLKvbdiHKCyWJu",
-    "EPDLKvbdLFegaaQu",
-    "DoCjjvbdqZPHgRDx",
-    "DncKjvbdUWMPjUAq",
-    "DoDLKvbdTYKkmzjx",
-    "DoDKjvbdegjvSOQg",
-    "DnbkKvbdUtNTekvK",
-    "EObkKvbdNsTvGeVQ",
-    "DoDLKvbdfNFvgMjL",
-    "EOcLKvbdZQmEiNEq",
-    "EPDKjvbdBraDTfWr",
-    "EPDKjvbdNGcQNQVL",
-    "EPDLKvbdZyEKODMS",
-    "EOcKjvbdBvzdIdpW",
-    "EPCjjvbdACqwiyiQ",
-    "DoCjjvbddePRawCj",
-    "EPDKjvbdWWiXucdg",
-    "DoDKjvbdWexzUAPT",
-    "DnbjjvbdwXMBWBWV",
-    "EOcLKvbdUyHszLOn",
-    "EPCkKvbdOYOuzcnU",
-    "EPCkKvbdhancEwQq",
-    "DnbkKvbdjggLefOL",
-    "EPCkKvbdFjdsDIMu",
-    "DoDKjvbdrSUjmkBN",
-    "DoDLKvbdZjTIQGaf",
-    "DoDKjvbdMgDPmPtk",
-    "EPDLKvbdWRmwbFMD",
-    "DoCkKvbdzROmJKXA",
-    "DnbkKvbdrDdiQNvB",
-    "DnbjjvbduDCtwVoP",
-    "EOcLKvbdCIjbLJFj",
-    "EPDKjvbdXrkaMsnx",
-    "EPDKjvbdVhXvXfxz",
-    "DncKjvbdhbPDEwRR",
-    "DoCkKvbdpxoHgQcx",
-    "DoCkKvbduMXwBUBX",
-    "EObjjvbdNeEThhjd",
-    "DoCjjvbdirzhrkJz",
-    "DoDLKvbdaMkCTUlg",
-    "DncLKvbdWRnYBeLc",
-    "DnbjjvbdGBPRZJzm",
-    "EOcLKvbdeOeSjstS",
-    "DoDLKvbdmIctRVSB",
-    "DoCjjvbdZxdJnDMS",
-    "DoCkKvbdRpTgKFcw",
-    "DncLKvbdTukojTaR",
-    "DnbjjvbdKRZdoFme",
-    "DnbkKvbdURQoVUhN",
-    "DoDLKvbdyYJKBozL",
-    "EObkKvbdfNFwHMjL",
-    "DoDLKvbdZisIQHBf",
-    "EObkKvbdqFcdsuaI",
-    "DncLKvbdzoPqFDLx",
-    "DoDKjvbdSKxeuHLT",
-    "EPDKjvbdsBemLfjy",
-    "DoCjjvbdJbjCqJcY",
-    "DoCjjvbdNPxRVnGs",
-    "DncLKvbdGcjvJbKK",
-    "EOcKjvbdrWpMDIxq",
-    "EOcLKvbdQdDApQcr",
-    "DoDKjvbdZMRdTnLm",
-    "EOcLKvbddxZssrFz",
-    "EObjjvbdUtNTfLuj",
-    "EPCjjvbdLLBIWAKZ",
-    "DoCkKvbdgFlZmfgA",
-    "EPCjjvbdUVkoitAq",
-    "DoDKjvbdDncKjvcE",
-    "DoDLKvbdRpUHJfEX",
-    "EPDKjvbdLqvlzVQz",
-    "EPDKjvbdZMRdUOLm",
-    "EOcLKvbdCJLBkIfK",
-    "DncKjvbdaSFbhUFk",
-    "EPDLKvbdZoNheEzK",
-    "DncKjvbdUVlPjUAq",
-    "DnbkKvbdKNADyfuB",
-    "EObkKvbdZdwfzghb",
-    "EPDLKvbdZtIhxcrn",
-    "EObkKvbdGckViajK",
-    "DncLKvbdFfJqmiUR",
-    "DncKjvbdKWUfDdgJ",
-    "DoDKjvbdMtrqjmAX",
-    "EOcLKvbdsQWPKDVf",
-    "DoCjjvbdwtleRZMO",
-    "EObjjvbduaDxsPEh",
-    "EPDLKvbdKxqJrzuG",
-    "EOcKjvbdVAaprprZ",
-    "EObjjvbdEuxopMjF",
-    "DnbjjvbdyOTHwriD",
-    "EPDLKvbdrpVnibvG",
-    "EPDKjvbdkWWnDaww",
-    "DncLKvbdrXPkbiYq",
-    "DoDLKvbddxZssqez",
-    "EOcLKvbdHDkWJbJj",
-    "DncLKvbdEPCkLWcE",
-    "DnbkKvbdEXwkstTl",
-    "EObjjvbdqiAKEmOe",
-    "DncLKvbdjAQGaQGj",
-    "EPCjjvbdNeDtJJKd",
-    "EPCjjvbdvwMBWBVu",
-    "EPDKjvbdFejSOItR",
-    "EOcLKvbdNPwqWOHT",
-    "EPDKjvbdbsCjscia",
-    "EObkKvbdyYIiaoyk",
-    "DoDKjvbdLZQirzuG",
-    "EObjjvbdSLZGVGjs",
-    "DoCjjvbdAMgxsWzY",
-    "DoDLKvbdEObjjwCd",
-    "DnbkKvbdsPvOicWG",
-    "EPCkKvbdrJAKElne",
-    "EPCkKvbdauCGwjsh",
-    "DncLKvbdegkWRnQg",
-    "EPCkKvbdYpmEiNFR",
-    "DoDKjvbduaDxsPFI",
-    "DoCjjvbdcyxoxYqC",
-    "DoCkKvbdkMakzFHP",
-    "DnbjjvbdJbibqJbx",
-    "DnbkKvbdWWhxWDeH",
-    "DoCjjvbdssRsYzFD",
-    "DoDKjvbdpyPIHRDx",
-    "DncLKvbdwNWANDeN",
-    "DoDKjvbdJYUBglRQ",
-    "EObkKvbdXnRAYVVt",
-    "DoCjjvbdUWLpKTaR",
-    "DoDKjvbdTqROttgm",
-    "EPCkKvbdVqnXaeMD",
-    "EObjjvbdADRwiyiQ",
-    "DoDKjvbdlrZUyrci",
-    "EPDKjvbdvAdZSndh",
-    "DoCkKvbdzoQQeDLx",
-    "DnbkKvbdSQUGjFdX",
-    "EOcLKvbdqBJFAXIE",
-    "EObkKvbdSCEFLiZL",
-    "DnbjjvbdzoQQdcMY",
-    "DnbkKvbdpxngfqEY",
-    "DncLKvbdbsDLUEKB",
-    "DoCjjvbdXrlBMtOx",
-    "EObjjvbdKCjDQicY",
-    "DncLKvbdLrWlzUpz",
-    "EObjjvbdaaWEfQQX",
-    "EObjjvbdtlYWaTaX",
-    "DnbkKvbdMowpunGs",
-    "EObkKvbdSLYeuHKs",
-    "EObkKvbdTAEhhCOd",
-    "EPCkKvbdmSYtyrci",
-    "DncLKvbdYkqcsnLm",
-    "DoDLKvbdrylQTAgn",
-    "DncLKvbdJXtCIMRQ",
-    "EObkKvbdSBdElIyL",
-    "DoDLKvbdwygefYFS",
-    "DncKjvbdyXhibPzL",
-    "EPCjjvbduaDxsPFI",
-    "EObjjvbdZoNiFEzK",
-    "EPCjjvbdkNBkyeHP",
-    "EPCkKvbdWRnXadlD",
-    "DncLKvbdRWmdDLhD",
-    "DnbkKvbdmSYtzTDi",
-    "EOcKjvbdkVwODbXw",
-    "DncLKvbdQlxCZOUz",
-    "EObjjvbdbhlijfXY",
-    "EOcLKvbdXmqAXtut",
-    "EOcLKvbdmbKXXnnV",
-    "DoDKjvbdkHgMFfOL",
-    "EPCkKvbdfekymgHA",
-    "DoCjjvbdeKKRvUzn",
-    "DoDKjvbdkHfkefNk",
-    "DoCjjvbdyqPMiKXA",
-    "DnbjjvbdUQqOtuIN",
-    "EOcKjvbdEPCkKwDE",
-    "DoDLKvbdZRNFIleR",
-    "DnbjjvbdRacdlJZL",
-    "EOcLKvbdTukoitAq",
-    "EOcLKvbdZLrDtOMN",
-    "EOcLKvbdgKfzcGAE",
-    "EObjjvbdzjVQQESt",
-    "EOcLKvbdcIlijevx",
-    "EOcKjvbdGKdsDHmV",
-    "DncLKvbdKkBHvAJy",
-    "EOcKjvbdZMRctOLm",
-    "EPCkKvbdADRxKZiQ",
-    "EObjjvbdDwxLsssl",
-    "EPDLKvbdUxgszLPO",
-    "EPCkKvbdSQTfiedX",
-    "EPCjjvbdNeEUJIkE",
-    "DoDLKvbdpyPHfqDx",
-    "DnbkKvbdyOShXsJD",
-    "DncLKvbdLiBkpxAS",
-    "DoDKjvbdaaWEepQX",
-    "DoCjjvbdWSOYBeLc",
-    "EOcKjvbdLFegbAqV",
-    "EPDKjvbdffLzOGgA",
-    "EObkKvbdFkErbglu",
-    "DncLKvbdiZuFlROG",
-    "DncKjvbdegkWRnQg",
-    "DoDLKvbdQdDApRDr",
-    "EOcLKvbdeYZtURez",
-    "EObjjvbdrXQLcIxq",
-    "DoDLKvbdxZhGGXeS",
-    "DoDLKvbdGGKSOItR",
-    "EObjjvbdjhHLfFnL",
-    "EOcLKvbdUQpoUuHm",
-    "DoCkKvbdXrlBNUPY",
-    "DoDKjvbdJXtCIMRQ",
-    "DnbkKvbdZMSDsnLm",
-    "DncKjvbdCTBDUGWr",
-    "DncKjvbdbhlikGXY",
-    "DoDKjvbdXmqAYVWU",
-    "DnbjjvbdliDsqVRa",
-    "DnbkKvbdmajXYOnV",
-    "EObjjvbdJpyePGNe",
-    "DnbkKvbdCTAcUGXS",
-    "DoDLKvbdCDpBVjNG",
-    "EOcLKvbdxwhiaoyk",
-    "DoDKjvbdxVNFQyMO",
-    "EPCkKvbdVvhwvEEg",
-    "DnbkKvbdFWYoomJe",
-    "EOcKjvbdlrZUysEJ",
-    "EPDKjvbdqquKnKaN",
-    "DoCkKvbdTkunaVoJ",
-    "EOcLKvbdfHkVrOQg",
-    "EPDLKvbdiUzFWrUb",
-    "DoDLKvbdtAGqIABS",
-    "DoCkKvbdZRMdhmEq",
-    "DnbkKvbdNsUVfeVQ",
-    "EPDLKvbdqwPkbiZR",
-    "DoCkKvbdNUsSLNAX",
-    "DncKjvbdmpZxvKyC",
-    "EPCkKvbdLYqKSztf",
-    "EPDKjvbdZyEKODMS",
-    "EPDKjvbdNGbomPuL",
-    "DncKjvbdZMSDtNlN",
-    "EPCjjvbdTXjkmzjx",
-    "EObkKvbdBdQAvKMf",
-    "EOcLKvbdkySrTYgU",
-    "DnbkKvbdZoOIddzK",
-    "DoCkKvbdZMSDsmkm",
-    "EPCkKvbdCWzdIdpW",
-    "DncLKvbdBvzdIdov",
-    "DoCjjvbdaRfDHtFk",
-    "DnbkKvbdWeyZtAOs",
-    "DoDLKvbdnCJwYPOV",
-    "DoCjjvbdEYYLstUM",
-    "EOcLKvbdwtldqZMO",
-    "EPCjjvbdFVxoomKF",
-    "EObkKvbdyqPMhiwA",
-    "DoDLKvbdkxrrSxgU",
-    "DoCjjvbdeATqNYKG",
-    "DncLKvbdJKEAJpHE",
-    "DoCkKvbddndsLUTr",
-    "DnbjjvbdqFceUWBI",
-    "DoDLKvbdhkddOUby",
-    "DncKjvbdGKdrcIMu",
-    "EPCkKvbdelevflik",
-    "DoDKjvbdhaoDFWqR",
-    "DoCjjvbdYlSDsmlN",
-    "EPCjjvbdiZuGLpmf",
-    "EObkKvbdnCJvxPNu",
-    "DnbkKvbdhzUelRNf",
-    "DnbkKvbdZeYGzgiC",
-    "DoCkKvbdDnbkLWbd",
-    "DnbkKvbdnHFYMmfy",
-    "DoCjjvbdePEsKtTr",
-    "DnbjjvbdZQmEhleR",
-    "DnbkKvbdTkunaVoJ",
-    "DnbkKvbdFWZPpMjF",
-    "DoDKjvbdSwkMNzkY",
-    "EOcLKvbdwtldpyMO",
-    "EOcKjvbdhkdcmtby",
-    "DoCjjvbdNQXqWNfs",
-    "EPDKjvbdzjUpPdTU",
-    "DnbjjvbdqceJPnWB",
-    "EPDKjvbdUyHsyjoO",
-    "EPCkKvbdZshhxcsO",
-    "DncKjvbdqAiFAWgd",
-    "EObkKvbdgFkzOGgA",
-    "DncKjvbdmgFYNNgZ",
-    "DoDLKvbdDjHjWYKA",
-    "DnbjjvbdJbicRKCx",
-    "DnbkKvbdfNFwHMjL",
-    "EPCkKvbdWSNxBdlD",
-    "EPDLKvbdCJKbLJFj",
-    "EPDKjvbdEOcKkXDE",
-    "EPCkKvbdVrOYCElD",
-    "DnbjjvbdCIkBjhej",
-    "DoDLKvbddoFTKstS",
-    "DnbjjvbduDDVXVoP",
-    "EObkKvbdxwiKCPzL",
-    "DnbkKvbdZGvdAPTJ",
-    "DoDLKvbdBdPaVjNG",
-    "EOcKjvbdIHGzYwxH",
-    "DoCjjvbdGFjSNhsq",
-    "DnbjjvbdlYsSSxgU",
-    "EPCjjvbdqrUjnKaN",
-    "EOcLKvbdtvOXipsA",
-    "DoDLKvbdrounjCuf",
-    "DoCkKvbdFVyPomKF",
-    "EOcKjvbdNHCpNPtk",
-    "EPDLKvbdWeyZtAPT",
-    "EPDKjvbdjcLkQfuH",
-    "EOcLKvbdzHZMAMeX",
-    "DoCjjvbdUMWPBVni",
-    "EOcKjvbdHELWKBjK",
-    "DoDKjvbdMgComQUk",
-    "DnbkKvbdiGjDZWJu",
-    "DncKjvbdyqOmJKXA",
-    "DoDKjvbdVZITyjoO",
-    "DoCjjvbdzQoNJJwA",
-    "EOcLKvbdGAoQxizm",
-    "DoDKjvbdatagYKsh",
-    "EPDKjvbdSBceMJYk",
-    "DoDLKvbdMpYQvOHT",
-    "DncKjvbdiCOcFWpq",
-    "DoCjjvbdUGznLvvF",
-    "EPDLKvbdANIYrvyx",
-    "EPCjjvbdIwtCHkpp",
-    "EObkKvbdJSyBSmYM",
-    "EObkKvbdwuMdqYlO",
-    "EObjjvbdmuVZkKSG",
-    "DncLKvbdSPsfjFdX",
-    "DoDLKvbdSQUHJedX",
-    "DoDKjvbdiVZdwSUb",
-    "EPDLKvbdRjxfVGkT",
-    "EObjjvbdmpZyVkZC",
-    "DncLKvbdhzUelROG",
-    "EPCkKvbdxVMeRZMO",
-    "EOcKjvbdxxIiapZk",
-    "EOcKjvbdJSyBTNYM",
-    "EPDKjvbdMSXMzUpz",
-    "EObkKvbdJmADzHVB" };
-
-  public static void main(java.lang.String[] unused) {
-    try {
-      BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("bad.out"));
-      for (int i = 0; i < strings.length; i++) {
-        out.write(strings[i].getBytes());
-        out.write("\n".getBytes());
-      }
-      out.close();
-    } catch (Exception e) {
-      System.out.println("Some exception occurred");
-    }
-  }
-}
--- hotspot/test/runtime/7158800/InternTest.java	2012-08-10 09:29:18.000000000 -0700
+++ hotspot/test/runtime/7158800/InternTest.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 7158800
- * @run shell/timeout=400 Test7158800.sh
- * @summary This test performs poorly if alternate hashing isn't used for
- * string table.
- * The timeout is handled by the shell file (which kills the process)
- */
-import java.util.*;
-import java.io.*;
-
-public class InternTest {
-    public static void main (String args[]) throws Exception {
-        final String badStringsFilename = "badstrings.txt";
-
-        if (args.length == 0 || (!args[0].equals("bad") && !args[0].equals("normal"))) {
-            System.out.println("Usage:  java InternTest [normal|bad]");
-            System.exit(1);
-        }
-
-        FileInputStream fstream = new FileInputStream(badStringsFilename);
-        DataInputStream in = new DataInputStream(fstream);
-        BufferedReader br = new BufferedReader(new InputStreamReader(in));
-        String toIntern, toDiscard;
-        int count = 0;
-        long current = 0L;
-        long last = System.currentTimeMillis();
-
-        if (args[0].equals("bad")) {
-            while ((toIntern = br.readLine()) != null) {
-                toDiscard = new String((new Integer((int)(Math.random() * Integer.MAX_VALUE))).toString());
-                toIntern.intern();
-                count++;
-                if (count % 10000 == 0 && count != 0) {
-                    current = System.currentTimeMillis();
-                    System.out.println(new Date(current) + ": interned " + count + " 0-hash strings - last 10000 took " + ((float)(current - last))/1000 + "s (" + ((float)(current - last))/10000000 + "s per String)");
-                    last = current;
-                }
-            }
-        }
-        if (args[0].equals("normal")) {
-            while ((toDiscard = br.readLine()) != null) { // do the same read from the file to try and make the test fair
-                toIntern = new String((new Integer((int)(Math.random() * Integer.MAX_VALUE))).toString());
-                toIntern.intern();
-                count++;
-                if (count % 10000 == 0 && count != 0) {
-                    current = System.currentTimeMillis();
-                    System.out.println(new Date(current) + ": interned " + count + " normal strings - last 10000 took " + ((float)(current - last))/1000 + "s (" + ((float)(current - last))/10000000 + "s per String)");
-                    last = current;
-                }
-            }
-        }
-        in.close();
-    }
-}
-
-
--- hotspot/test/runtime/7158800/Test7158800.sh	2012-08-10 09:29:19.000000000 -0700
+++ hotspot/test/runtime/7158800/Test7158800.sh	2013-05-05 09:39:14.000000000 -0700
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD )
     NULL=/dev/null
     PS=":"
     FS="/"
--- hotspot/test/runtime/7158804/Test7158804.sh	1969-12-31 16:00:00.000000000 -0800
+++ hotspot/test/runtime/7158804/Test7158804.sh	2013-05-05 09:39:14.000000000 -0700
@@ -0,0 +1,30 @@
+#!/bin/sh
+#
+# Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+
+##
+## @test Test7158804.sh
+## @bug 7158804
+## @summary Improve config file parsing
+## @run shell Test7158804.sh
+##
+
+if [ "${TESTJAVA}" = "" ]
+then
+  echo "TESTJAVA not set.  Test cannot execute.  Failed."
+  exit 1
+fi
+echo "TESTJAVA=${TESTJAVA}"
+
+rm -f .hotspotrc
+echo -XX:+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >.hotspotrc
+${TESTJAVA}/bin/java ${TESTVMOPTS} -XX:+IgnoreUnrecognizedVMOptions -XX:Flags=.hotspotrc -version
+if [ $? -ne 0 ]
+then
+    echo "Test Failed"
+    exit 1
+fi
+rm -f .hotspotrc
+exit 0
--- hotspot/test/runtime/7162488/Test7162488.sh	1969-12-31 16:00:00.000000000 -0800
+++ hotspot/test/runtime/7162488/Test7162488.sh	2013-05-05 09:39:14.000000000 -0700
@@ -0,0 +1,77 @@
+#
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+#  This code is free software; you can redistribute it and/or modify it
+#  under the terms of the GNU General Public License version 2 only, as
+#  published by the Free Software Foundation.
+#
+#  This code is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+#  version 2 for more details (a copy is included in the LICENSE file that
+#  accompanied this code).
+#
+#  You should have received a copy of the GNU General Public License version
+#  2 along with this work; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+#  or visit www.oracle.com if you need additional information or have any
+#  questions.
+#
+
+
+# @test Test7162488.sh
+# @bug 7162488
+# @summary VM not printing unknown -XX options
+# @run shell Test7162488.sh
+#
+
+if [ "${TESTSRC}" = "" ]
+  then TESTSRC=.
+fi
+
+if [ "${TESTJAVA}" = "" ]
+then
+  PARENT=`dirname \`which java\``
+  TESTJAVA=`dirname ${PARENT}`
+  printf "TESTJAVA not set, selecting " ${TESTJAVA}
+  printf "  If this is incorrect, try setting the variable manually.\n"
+fi
+
+# set platform-dependent variables
+OS=`uname -s`
+case "$OS" in
+  Windows_* )
+    FS="\\"
+    ;;
+  * )
+    FS="/"
+    ;;
+esac
+
+JAVA=${TESTJAVA}${FS}bin${FS}java
+
+#
+# Just run with an option we are confident will not be recognized,
+# and check for the message:
+#
+OPTION=this_is_not_an_option
+
+${JAVA} ${TESTVMOPTS} -showversion -XX:${OPTION} 2>&1 | grep "Unrecognized VM option" 
+if [ "$?" != "0" ]
+then
+  printf "FAILED: option not flagged as unrecognized.\n"
+  exit 1
+fi
+
+${JAVA} ${TESTVMOPTS} -showversion -XX:${OPTION} 2>&1 | grep ${OPTION}
+if [ "$?" != "0" ]
+then
+  printf "FAILED: bad option not named as being bad.\n"
+  exit 1
+fi
+
+printf "Passed.\n"
+
--- jaxp/.hgtags	2012-08-10 09:35:08.000000000 -0700
+++ jaxp/.hgtags	2013-05-05 09:39:24.000000000 -0700
@@ -123,6 +123,7 @@
 bcd31fa1e3c6f51b4fdd427ef905188cdac57164 jdk7-b146
 067fb18071e3872698f6218724958bd0cebf30a3 jdk7u1-b01
 fc268cd1dd5d2e903ccd4b0275e1f9c2461ed30c jdk7-b147
+3170972bd3928a331c4c64a5c0c9632077fb399a 7u0
 104ca42e1e7ca66b074a4619ce6420f15d8f454d jdk7u1-b02
 64e323faadf65018c1ffc8bb9c97f7b664e87347 jdk7u1-b03
 2256c20e66857f80cacda14ffdbc0979c929d7f8 jdk7u1-b04
@@ -197,5 +198,69 @@
 7403701aa75848ca2a7b297909908b858134e132 jdk7u6-b21
 fcf35906d1d88583878cd2e2d7c63dfba4e9f679 jdk7u6-b22
 8824bcbfd7cd8059ededf70f1e7f2b06f02cb33f jdk7u6-b23
-1365e7472a3b737dda4a73e06ad41718d667d9be jdk7u8-b01
-0a313d4307930be3a64106b9b8c90f9342673aa0 jdk7u8-b02
+378f719cfb9491b766cd9f7cd47ad7fa3503e141 jdk7u6-b24
+5f1b80e8baec46fc28826a3a6ab8e1913c872f4c jdk7u6-b30
+2eafa8a6fd8fdb54b10045e247d1a57f9817f473 jdk7u6-b31
+2eafa8a6fd8fdb54b10045e247d1a57f9817f473 jdk7u7-b10
+c4aa15da8529451cc678d5747e7b82e9cc38627e jdk7u7-b30
+f6e11679b12e1548f407b78a940c568401dd2a19 jdk7u7-b11
+7840a267c777e22004912ad0aadd5258ac3d36c6 jdk7u7-b31
+61fc72e9fe26b3acf1572866143c22719c088b62 jdk7u7-b01
+78d9e4853388a2e7be18ff18c0b5330c074cb514 jdk7u7-b02
+fc7c5aa8c722f28c59560ce83140e803d853afc9 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+61fc72e9fe26b3acf1572866143c22719c088b62 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+78d9e4853388a2e7be18ff18c0b5330c074cb514 jdk7u9-b02
+b12a2d557c5e302b614c5f7e25ad6c8a0e138742 jdk7u9-b04
+ab4bbb93b3831aca230c62431f7fe02b56793450 jdk7u9-b05
+039b21e98d2b2d0b26a19c325b37ce522bae39de jdk7u9-b31
+d80a8e81fef0bc6e0bdb7891895bda527853add1 jdk7u9-b32
+254ed6ae237ee631179819570cf7fb265c6fb3a8 jdk7u10-b10
+c1df39bcc9c1bcdfb2a92682650264b3b7771ce8 jdk7u10-b11
+00cfd60368048c4969785eb52ec50cf5691c4367 jdk7u10-b12
+51efccc2b4e908fa0475075739c1463d1dd50efc jdk7u10-b13
+c245a6332320a86342683e6f732f3f8f2f4de69a jdk7u10-b14
+89b043ba2e01e969090e23a5a7a2e9f7165ff5a0 jdk7u10-b15
+5449d5396bd8deee90f18f29899343129e3cdc4e jdk7u10-b16
+86c75e6aa3a7fa9a587fc7dd2d08af8aa8ffb9a9 jdk7u10-b17
+162a2c6ad8718a63253fa53724f704a4f85731bc jdk7u10-b18
+c59eb287de720ae5ce8087f179ec01f4f6525a32 jdk7u10-b30
+ec1e8ead41ee49d2b3f84a26ae0fac88e226692d jdk7u10-b31
+853059839d38432f86e345ba951397ede235a374 jdk7u11-b20
+453a52320a1b8bd425fdb55e14b64067b536f1e2 jdk7u11-b21
+71353182d3f7c237047c5386d9f31186a5bd1519 jdk7u11-b32
+af8f33c558d05aacdff5b5787be0cbaba9f10e98 jdk7u11-b33
+5df9207c4378b7f4b24d70b365714c5ee6318982 jdk7u11-b03
+6ee19b9c8313db32e6d8989aa3782830d2b09710 jdk7u11-b04
+3312b258392eaeab9c4a20e3deb36d3ae3337efe jdk7u11-b05
+86d0250b62bbb4aabab2a7c249aeb14847be2631 jdk7u11-b06
+225aa78c36e9b776c87e585329bbb7ee0e3259a3 jdk7u11-b07
+48491f5a58172f0fbdf9b774842c2ec1a42f609a jdk7u11-b08
+eb9d57159e5126cf4316c9571ac39324a8b442a8 jdk7u13-b09
+f9fe0d38b1103cb33073538c959d982e28ed7b11 jdk7u13-b10
+0a6a09e5174a4c15632ff7e06d6b215164e3fa15 jdk7u13-b30
+f9fe0d38b1103cb33073538c959d982e28ed7b11 jdk7u13-b20
+99c114990b191f32e72c6158072033aec5816aaf jdk7u15-b01
+edbaa584f09a78d0ad3c73389faf20409a552e46 jdk7u15-b02
+14a9b60a2086f4e2f6ec43bee3375042946f6510 jdk7u15-b30
+de6df3c10ebc0f8c704a11ad86c8eea1e1cc1442 jdk7u15-b31
+039c31ff1fe6789859f2f55588218147623a9a9f jdk7u15-b33
+a55f67cfe182dc42a86aae836674eb8ba5b79891 jdk7u15-b03
+eb9d57159e5126cf4316c9571ac39324a8b442a8 jdk7u15-b32
+8a9867ee429440b657eb5852c4dae5f029356022 jdk7u17-b01
+7863a60ae4b4a0c7d762a95e77e589fafa4e50ae jdk7u17-b02
+a5e6594fc1ae20101b5d69632f65078d7a99b76d jdk7u17-b30
+8fb34202383ece5386acecc3a6c1dac68dccbf05 jdk7u17-b31
+0a6a09e5174a4c15632ff7e06d6b215164e3fa15 jdk7u21-b01
+99ed1a3d29509fee659aabec4810c896b7234d80 jdk7u21-b02
+38d4d23d167c5a623e6d771a15b1fe2ee771ce38 jdk7u21-b03
+acde12ee462d650d34cc148d9d3649f9a9bbca8a jdk7u21-b04
+56b1ad031df90d20c52941c15ceae0e5a90893b8 jdk7u21-b05
+ab51202418c1c96e01a45893a26829a2d9c7b956 jdk7u21-b06
+3ab71deee4a4477d89530ee9e92a36017a6092fa jdk7u21-b07
+f5ef2e76669bc3179f17dac42a8a407fb6bd4d91 jdk7u21-b08
+65977091d010402ccbed41c96748866a1d50f0c4 jdk7u21-b09
+bf2d62ea518d5e4130e442e07705e7a50b821ad9 jdk7u21-b10
+3e0e331bdfb8f3adfd0cc78118e0ac588e73a2b5 jdk7u21-b11
+980fe893d8fd86d8aee14771167b6e0ac75fa208 jdk7u21-b30
--- jaxp/src/com/sun/org/apache/bcel/internal/classfile/JavaClass.java	2012-08-10 09:35:19.000000000 -0700
+++ jaxp/src/com/sun/org/apache/bcel/internal/classfile/JavaClass.java	2013-05-05 09:39:19.000000000 -0700
@@ -63,6 +63,7 @@
 import  com.sun.org.apache.bcel.internal.util.ClassVector;
 import  com.sun.org.apache.bcel.internal.util.ClassQueue;
 import  com.sun.org.apache.bcel.internal.generic.Type;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 import  java.io.*;
 import  java.util.StringTokenizer;
@@ -77,6 +78,7 @@
  * class file.  Those interested in programatically generating classes
  * should see the <a href="../generic/ClassGen.html">ClassGen</a> class.
 
+ * @version $Id: JavaClass.java,v 1.4 2007-07-19 04:34:42 ofung Exp $
  * @see com.sun.org.apache.bcel.internal.generic.ClassGen
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  */
@@ -451,9 +453,9 @@
     String debug = null, sep = null;
 
     try {
-      debug = System.getProperty("JavaClass.debug");
+      debug = SecuritySupport.getSystemProperty("JavaClass.debug");
       // Get path separator either / or \ usually
-      sep = System.getProperty("file.separator");
+      sep = SecuritySupport.getSystemProperty("file.separator");
     }
     catch (SecurityException e) {
         // falls through
--- jaxp/src/com/sun/org/apache/bcel/internal/util/Class2HTML.java	2012-08-10 09:36:04.000000000 -0700
+++ jaxp/src/com/sun/org/apache/bcel/internal/util/Class2HTML.java	2013-05-05 09:39:19.000000000 -0700
@@ -82,6 +82,7 @@
  * method in the Method's frame will jump to the appropiate method in
  * the Code frame.
  *
+ * @version $Id: Class2HTML.java,v 1.3 2007-07-19 04:34:52 ofung Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 */
 public class Class2HTML implements Constants
@@ -137,7 +138,7 @@
     ClassParser parser=null;
     JavaClass   java_class=null;
     String      zip_file = null;
-    char        sep = System.getProperty("file.separator").toCharArray()[0];
+    char        sep = SecuritySupport.getSystemProperty("file.separator").toCharArray()[0];
     String      dir = "." + sep; // Where to store HTML files
 
     try {
--- jaxp/src/com/sun/org/apache/bcel/internal/util/ClassPath.java	2012-08-10 09:36:04.000000000 -0700
+++ jaxp/src/com/sun/org/apache/bcel/internal/util/ClassPath.java	2013-05-05 09:39:19.000000000 -0700
@@ -66,6 +66,7 @@
  * Responsible for loading (class) files from the CLASSPATH. Inspired by
  * sun.tools.ClassPath.
  *
+ * @version $Id: ClassPath.java,v 1.4 2007-07-19 04:34:52 ofung Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  */
 public class ClassPath implements Serializable {
@@ -83,7 +84,7 @@
     ArrayList vec = new ArrayList();
 
     for(StringTokenizer tok=new StringTokenizer(class_path,
-                                                System.getProperty("path.separator"));
+                            SecuritySupport.getSystemProperty("path.separator"));
         tok.hasMoreTokens();)
     {
       String path = tok.nextToken();
@@ -92,7 +93,7 @@
         File file = new File(path);
 
         try {
-          if(file.exists()) {
+          if(SecuritySupport.getFileExists(file)) {
             if(file.isDirectory())
               vec.add(new Dir(path));
             else
@@ -143,8 +144,9 @@
         String name = tok.nextToken();
         File   file = new File(name);
 
-        if(file.exists())
+        if(SecuritySupport.getFileExists(file)) {
           list.add(name);
+        }
       }
     }
   }
@@ -159,9 +161,9 @@
     String class_path, boot_path, ext_path;
 
     try {
-      class_path = System.getProperty("java.class.path");
-      boot_path  = System.getProperty("sun.boot.class.path");
-      ext_path   = System.getProperty("java.ext.dirs");
+      class_path = SecuritySupport.getSystemProperty("java.class.path");
+      boot_path  = SecuritySupport.getSystemProperty("sun.boot.class.path");
+      ext_path   = SecuritySupport.getSystemProperty("java.ext.dirs");
     }
     catch (SecurityException e) {
         return "";
@@ -176,8 +178,8 @@
     getPathComponents(ext_path, dirs);
 
     for(Iterator e = dirs.iterator(); e.hasNext(); ) {
-      File     ext_dir    = new File((String)e.next());
-      String[] extensions = ext_dir.list(new FilenameFilter() {
+      File ext_dir = new File((String)e.next());
+      String[] extensions = SecuritySupport.getFileList(ext_dir, new FilenameFilter() {
         public boolean accept(File dir, String name) {
           name = name.toLowerCase();
           return name.endsWith(".zip") || name.endsWith(".jar");
@@ -342,7 +344,7 @@
       final File file = new File(dir + File.separatorChar +
                                  name.replace('.', File.separatorChar) + suffix);
 
-      return file.exists()? new ClassFile() {
+      return SecuritySupport.getFileExists(file)? new ClassFile() {
         public InputStream getInputStream() throws IOException { return new FileInputStream(file); }
 
         public String      getPath()        { try {
--- jaxp/src/com/sun/org/apache/bcel/internal/util/JavaWrapper.java	2012-08-10 09:36:05.000000000 -0700
+++ jaxp/src/com/sun/org/apache/bcel/internal/util/JavaWrapper.java	2013-05-05 09:39:19.000000000 -0700
@@ -72,6 +72,7 @@
  * <pre>java com.sun.org.apache.bcel.internal.util.JavaWrapper -Dbcel.classloader=foo.MyLoader &lt;real.class.name&gt; [arguments]</pre>
  * </p>
  *
+ * @version $Id: JavaWrapper.java,v 1.3 2007-07-19 04:34:52 ofung Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * @see ClassLoader
  */
@@ -79,7 +80,7 @@
   private java.lang.ClassLoader loader;
 
   private static java.lang.ClassLoader getClassLoader() {
-    String s = System.getProperty("bcel.classloader");
+    String s = SecuritySupport.getSystemProperty("bcel.classloader");
 
     if((s == null) || "".equals(s))
       s = "com.sun.org.apache.bcel.internal.util.ClassLoader";
--- jaxp/src/com/sun/org/apache/bcel/internal/util/SecuritySupport.java	1969-12-31 16:00:00.000000000 -0800
+++ jaxp/src/com/sun/org/apache/bcel/internal/util/SecuritySupport.java	2013-05-05 09:39:19.000000000 -0700
@@ -0,0 +1,223 @@
+/*
+ * reserved comment block
+ * DO NOT REMOVE OR ALTER!
+ */
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.sun.org.apache.bcel.internal.util;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FilenameFilter;
+import java.io.InputStream;
+import java.lang.ClassLoader;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.ListResourceBundle;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+
+/**
+ * This class is duplicated for each subpackage so keep it in sync. It is
+ * package private and therefore is not exposed as part of any API.
+ *
+ * @xerces.internal
+ */
+public final class SecuritySupport {
+
+    private static final SecuritySupport securitySupport = new SecuritySupport();
+
+    /**
+     * Return an instance of this class.
+     */
+    public static SecuritySupport getInstance() {
+        return securitySupport;
+    }
+
+    static ClassLoader getContextClassLoader() {
+        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                ClassLoader cl = null;
+                try {
+                    cl = Thread.currentThread().getContextClassLoader();
+                } catch (SecurityException ex) {
+                }
+                return cl;
+            }
+        });
+    }
+
+    static ClassLoader getSystemClassLoader() {
+        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                ClassLoader cl = null;
+                try {
+                    cl = ClassLoader.getSystemClassLoader();
+                } catch (SecurityException ex) {
+                }
+                return cl;
+            }
+        });
+    }
+
+    static ClassLoader getParentClassLoader(final ClassLoader cl) {
+        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                ClassLoader parent = null;
+                try {
+                    parent = cl.getParent();
+                } catch (SecurityException ex) {
+                }
+
+                // eliminate loops in case of the boot
+                // ClassLoader returning itself as a parent
+                return (parent == cl) ? null : parent;
+            }
+        });
+    }
+
+    public static String getSystemProperty(final String propName) {
+        return (String) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return System.getProperty(propName);
+            }
+        });
+    }
+
+    static FileInputStream getFileInputStream(final File file)
+            throws FileNotFoundException {
+        try {
+            return (FileInputStream) AccessController.doPrivileged(new PrivilegedExceptionAction() {
+                public Object run() throws FileNotFoundException {
+                    return new FileInputStream(file);
+                }
+            });
+        } catch (PrivilegedActionException e) {
+            throw (FileNotFoundException) e.getException();
+        }
+    }
+
+    /**
+     * Return resource using the same classloader for the ObjectFactory by
+     * default or bootclassloader when Security Manager is in place
+     */
+    public static InputStream getResourceAsStream(final String name) {
+        if (System.getSecurityManager() != null) {
+            return getResourceAsStream(null, name);
+        } else {
+            return getResourceAsStream(findClassLoader(), name);
+        }
+    }
+
+    public static InputStream getResourceAsStream(final ClassLoader cl,
+            final String name) {
+        return (InputStream) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                InputStream ris;
+                if (cl == null) {
+                    ris = Object.class.getResourceAsStream("/" + name);
+                } else {
+                    ris = cl.getResourceAsStream(name);
+                }
+                return ris;
+            }
+        });
+    }
+
+    /**
+     * Gets a resource bundle using the specified base name, the default locale,
+     * and the caller's class loader.
+     *
+     * @param bundle the base name of the resource bundle, a fully qualified
+     * class name
+     * @return a resource bundle for the given base name and the default locale
+     */
+    public static ListResourceBundle getResourceBundle(String bundle) {
+        return getResourceBundle(bundle, Locale.getDefault());
+    }
+
+    /**
+     * Gets a resource bundle using the specified base name and locale, and the
+     * caller's class loader.
+     *
+     * @param bundle the base name of the resource bundle, a fully qualified
+     * class name
+     * @param locale the locale for which a resource bundle is desired
+     * @return a resource bundle for the given base name and locale
+     */
+    public static ListResourceBundle getResourceBundle(final String bundle, final Locale locale) {
+        return AccessController.doPrivileged(new PrivilegedAction<ListResourceBundle>() {
+            public ListResourceBundle run() {
+                try {
+                    return (ListResourceBundle) ResourceBundle.getBundle(bundle, locale);
+                } catch (MissingResourceException e) {
+                    try {
+                        return (ListResourceBundle) ResourceBundle.getBundle(bundle, new Locale("en", "US"));
+                    } catch (MissingResourceException e2) {
+                        throw new MissingResourceException(
+                                "Could not load any resource bundle by " + bundle, bundle, "");
+                    }
+                }
+            }
+        });
+    }
+
+    public static String[] getFileList(final File f, final FilenameFilter filter) {
+        return ((String[]) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return f.list(filter);
+            }
+        }));
+    }
+
+    public static boolean getFileExists(final File f) {
+        return ((Boolean) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return f.exists() ? Boolean.TRUE : Boolean.FALSE;
+            }
+        })).booleanValue();
+    }
+
+    static long getLastModified(final File f) {
+        return ((Long) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return new Long(f.lastModified());
+            }
+        })).longValue();
+    }
+
+
+    /**
+     * Figure out which ClassLoader to use.
+     */
+    public static ClassLoader findClassLoader()
+    {
+        if (System.getSecurityManager()!=null) {
+            //this will ensure bootclassloader is used
+            return null;
+        } else {
+            return SecuritySupport.class.getClassLoader();
+        }
+    } // findClassLoader():ClassLoader
+
+    private SecuritySupport() {
+    }
+}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLMessages.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLMessages.java	2013-05-05 09:39:19.000000000 -0700
@@ -22,68 +22,72 @@
  */
 package com.sun.org.apache.xalan.internal.res;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.util.ListResourceBundle;
 
 import com.sun.org.apache.xpath.internal.res.XPATHMessages;
 
 /**
- * Sets things up for issuing error messages.  This class is misnamed, and
- * should be called XalanMessages, or some such.
+ * Sets things up for issuing error messages. This class is misnamed, and should
+ * be called XalanMessages, or some such.
+ *
  * @xsl.usage internal
  */
-public class XSLMessages extends XPATHMessages
-{
+public class XSLMessages extends XPATHMessages {
 
-  /** The language specific resource object for Xalan messages.  */
-  private static ListResourceBundle XSLTBundle = null;
-
-  /** The class name of the Xalan error message string table.    */
-  private static final String XSLT_ERROR_RESOURCES =
-    "com.sun.org.apache.xalan.internal.res.XSLTErrorResources";
-
-  /**
-   * Creates a message from the specified key and replacement
-   * arguments, localized to the given locale.
-   *
-   * @param msgKey    The key for the message text.
-   * @param args      The arguments to be used as replacement text
-   *                  in the message created.
-   *
-   * @return The formatted message string.
-   */
-  public static final String createMessage(String msgKey, Object args[])  //throws Exception
-  {
-    if (XSLTBundle == null)
-      XSLTBundle = loadResourceBundle(XSLT_ERROR_RESOURCES);
-
-    if (XSLTBundle != null)
+    /**
+     * The language specific resource object for Xalan messages.
+     */
+    private static ListResourceBundle XSLTBundle = null;
+    /**
+     * The class name of the Xalan error message string table.
+     */
+    private static final String XSLT_ERROR_RESOURCES =
+            "com.sun.org.apache.xalan.internal.res.XSLTErrorResources";
+
+    /**
+     * Creates a message from the specified key and replacement arguments,
+     * localized to the given locale.
+     *
+     * @param msgKey The key for the message text.
+     * @param args The arguments to be used as replacement text in the message
+     * created.
+     *
+     * @return The formatted message string.
+     */
+    public static String createMessage(String msgKey, Object args[]) //throws Exception
     {
-      return createMsg(XSLTBundle, msgKey, args);
+        if (XSLTBundle == null) {
+            XSLTBundle = SecuritySupport.getResourceBundle(XSLT_ERROR_RESOURCES);
+        }
+
+        if (XSLTBundle != null) {
+            return createMsg(XSLTBundle, msgKey, args);
+        } else {
+            return "Could not load any resource bundles.";
+        }
     }
-    else
-      return "Could not load any resource bundles.";
-  }
-
-  /**
-   * Creates a message from the specified key and replacement
-   * arguments, localized to the given locale.
-   *
-   * @param msgKey    The key for the message text.
-   * @param args      The arguments to be used as replacement text
-   *                  in the message created.
-   *
-   * @return The formatted warning string.
-   */
-  public static final String createWarning(String msgKey, Object args[])  //throws Exception
-  {
-    if (XSLTBundle == null)
-      XSLTBundle = loadResourceBundle(XSLT_ERROR_RESOURCES);
 
-    if (XSLTBundle != null)
+    /**
+     * Creates a message from the specified key and replacement arguments,
+     * localized to the given locale.
+     *
+     * @param msgKey The key for the message text.
+     * @param args The arguments to be used as replacement text in the message
+     * created.
+     *
+     * @return The formatted warning string.
+     */
+    public static String createWarning(String msgKey, Object args[]) //throws Exception
     {
-      return createMsg(XSLTBundle, msgKey, args);
+        if (XSLTBundle == null) {
+            XSLTBundle = SecuritySupport.getResourceBundle(XSLT_ERROR_RESOURCES);
+        }
+
+        if (XSLTBundle != null) {
+            return createMsg(XSLTBundle, msgKey, args);
+        } else {
+            return "Could not load any resource bundles.";
+        }
     }
-    else
-      return "Could not load any resource bundles.";
-  }
 }
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_de.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_de.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_es.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_es.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_fr.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_fr.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_it.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_it.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ja.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ja.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ko.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ko.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_pt_BR.java	2012-08-10 09:36:07.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_pt_BR.java	2013-05-05 09:39:19.000000000 -0700
@@ -1449,68 +1449,5 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 
 }
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_sv.java	2012-08-10 09:36:08.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_sv.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_CN.java	2012-08-10 09:36:08.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_CN.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_TW.java	2012-08-10 09:36:08.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_TW.java	2013-05-05 09:39:19.000000000 -0700
@@ -1448,68 +1448,4 @@
   public static final String QUERY_HEADER = "PATTERN ";
 
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XSLTErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XSLTErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XSLTErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
     }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
-
-}
--- jaxp/src/com/sun/org/apache/xalan/internal/utils/ObjectFactory.java	2012-08-10 09:36:09.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/utils/ObjectFactory.java	2013-05-05 09:39:19.000000000 -0700
@@ -54,6 +54,8 @@
     //
     // Constants
     //
+     private static final String XALAN_INTERNAL = "com.sun.org.apache.xalan.internal";
+     private static final String XERCES_INTERNAL = "com.sun.org.apache.xerces.internal";
 
     // name of default properties file to look for in JDK's jre/lib directory
     private static final String DEFAULT_PROPERTIES_FILENAME =
@@ -514,12 +516,17 @@
         //class. Restrict the access to the package classes as specified in java.security policy.
         SecurityManager security = System.getSecurityManager();
         try{
-                if (security != null){
+            if (security != null){
+                if (className.startsWith(XALAN_INTERNAL) ||
+                    className.startsWith(XERCES_INTERNAL)) {
+                    cl = null;
+                } else {
                     final int lastDot = className.lastIndexOf(".");
                     String packageName = className;
                     if (lastDot != -1) packageName = className.substring(0, lastDot);
                     security.checkPackageAccess(packageName);
-                 }
+                }
+             }
         }catch(SecurityException e){
             throw e;
         }
--- jaxp/src/com/sun/org/apache/xalan/internal/utils/SecuritySupport.java	2012-08-10 09:36:09.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/utils/SecuritySupport.java	2013-05-05 09:39:19.000000000 -0700
@@ -32,10 +32,14 @@
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.util.ListResourceBundle;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
 
 /**
- * This class is duplicated for each subpackage so keep it in sync.
- * It is package private and therefore is not exposed as part of any API.
+ * This class is duplicated for each subpackage so keep it in sync. It is
+ * package private and therefore is not exposed as part of any API.
  *
  * @xerces.internal
  */
@@ -51,39 +55,39 @@
     }
 
     static ClassLoader getContextClassLoader() {
-        return (ClassLoader)
-        AccessController.doPrivileged(new PrivilegedAction() {
+        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 ClassLoader cl = null;
                 try {
                     cl = Thread.currentThread().getContextClassLoader();
-                } catch (SecurityException ex) { }
+                } catch (SecurityException ex) {
+                }
                 return cl;
             }
         });
     }
 
     static ClassLoader getSystemClassLoader() {
-        return (ClassLoader)
-        AccessController.doPrivileged(new PrivilegedAction() {
+        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 ClassLoader cl = null;
                 try {
                     cl = ClassLoader.getSystemClassLoader();
-                } catch (SecurityException ex) {}
+                } catch (SecurityException ex) {
+                }
                 return cl;
             }
         });
     }
 
     static ClassLoader getParentClassLoader(final ClassLoader cl) {
-        return (ClassLoader)
-        AccessController.doPrivileged(new PrivilegedAction() {
+        return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 ClassLoader parent = null;
                 try {
                     parent = cl.getParent();
-                } catch (SecurityException ex) {}
+                } catch (SecurityException ex) {
+                }
 
                 // eliminate loops in case of the boot
                 // ClassLoader returning itself as a parent
@@ -93,20 +97,25 @@
     }
 
     public static String getSystemProperty(final String propName) {
-        return (String)
-        AccessController.doPrivileged(new PrivilegedAction() {
+        return (String) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 return System.getProperty(propName);
             }
         });
     }
 
+    public static String getSystemProperty(final String propName, final String def) {
+        return (String) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return System.getProperty(propName, def);
+            }
+        });
+    }
+
     static FileInputStream getFileInputStream(final File file)
-    throws FileNotFoundException
-    {
+            throws FileNotFoundException {
         try {
-            return (FileInputStream)
-            AccessController.doPrivileged(new PrivilegedExceptionAction() {
+            return (FileInputStream) AccessController.doPrivileged(new PrivilegedExceptionAction() {
                 public Object run() throws FileNotFoundException {
                     return new FileInputStream(file);
                 }
@@ -115,9 +124,10 @@
             throw (FileNotFoundException)e.getException();
         }
     }
+
     /**
-     * Return resource using the same classloader for the ObjectFactory by default
-     * or bootclassloader when Security Manager is in place
+     * Return resource using the same classloader for the ObjectFactory by
+     * default or bootclassloader when Security Manager is in place
      */
     public static InputStream getResourceAsStream(final String name) {
         if (System.getSecurityManager()!=null) {
@@ -128,10 +138,8 @@
     }
 
     public static InputStream getResourceAsStream(final ClassLoader cl,
-            final String name)
-    {
-        return (InputStream)
-        AccessController.doPrivileged(new PrivilegedAction() {
+            final String name) {
+        return (InputStream) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 InputStream ris;
                 if (cl == null) {
@@ -144,9 +152,40 @@
         });
     }
 
-    static boolean getFileExists(final File f) {
-        return ((Boolean)
-                AccessController.doPrivileged(new PrivilegedAction() {
+    /**
+     * Gets a resource bundle using the specified base name, the default locale, and the caller's class loader.
+     * @param bundle the base name of the resource bundle, a fully qualified class name
+     * @return a resource bundle for the given base name and the default locale
+     */
+    public static ListResourceBundle getResourceBundle(String bundle) {
+        return getResourceBundle(bundle, Locale.getDefault());
+    }
+
+    /**
+     * Gets a resource bundle using the specified base name and locale, and the caller's class loader.
+     * @param bundle the base name of the resource bundle, a fully qualified class name
+     * @param locale the locale for which a resource bundle is desired
+     * @return a resource bundle for the given base name and locale
+     */
+    public static ListResourceBundle getResourceBundle(final String bundle, final Locale locale) {
+        return AccessController.doPrivileged(new PrivilegedAction<ListResourceBundle>() {
+            public ListResourceBundle run() {
+                try {
+                    return (ListResourceBundle)ResourceBundle.getBundle(bundle, locale);
+                } catch (MissingResourceException e) {
+                    try {
+                        return (ListResourceBundle)ResourceBundle.getBundle(bundle, new Locale("en", "US"));
+                    } catch (MissingResourceException e2) {
+                        throw new MissingResourceException(
+                                "Could not load any resource bundle by " + bundle, bundle, "");
+                    }
+                }
+            }
+        });
+    }
+
+    public static boolean getFileExists(final File f) {
+        return ((Boolean) AccessController.doPrivileged(new PrivilegedAction() {
                     public Object run() {
                         return f.exists() ? Boolean.TRUE : Boolean.FALSE;
                     }
@@ -154,13 +193,14 @@
     }
 
     static long getLastModified(final File f) {
-        return ((Long)
-                AccessController.doPrivileged(new PrivilegedAction() {
+        return ((Long) AccessController.doPrivileged(new PrivilegedAction() {
                     public Object run() {
                         return new Long(f.lastModified());
                     }
                 })).longValue();
     }
 
-    private SecuritySupport () {}
+
+    private SecuritySupport() {
+    }
 }
--- jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java	2012-08-10 09:36:09.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java	2013-05-05 09:39:19.000000000 -0700
@@ -23,6 +23,7 @@
 package com.sun.org.apache.xalan.internal.xslt;
 
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 import java.io.File;
 import java.io.FileWriter;
@@ -574,7 +575,7 @@
     // Grab java version for later use
     try
     {
-      String javaVersion = System.getProperty("java.version");
+      String javaVersion = SecuritySupport.getSystemProperty("java.version");
 
       h.put("java.version", javaVersion);
     }
@@ -593,7 +594,7 @@
     {
 
       // This is present in all JVM's
-      String cp = System.getProperty("java.class.path");
+      String cp = SecuritySupport.getSystemProperty("java.class.path");
 
       h.put("java.class.path", cp);
 
@@ -603,7 +604,7 @@
         h.put(FOUNDCLASSES + "java.class.path", classpathJars);
 
       // Also check for JDK 1.2+ type classpaths
-      String othercp = System.getProperty("sun.boot.class.path");
+      String othercp = SecuritySupport.getSystemProperty("sun.boot.class.path");
 
       if (null != othercp)
       {
@@ -617,7 +618,7 @@
 
       //@todo NOTE: We don't actually search java.ext.dirs for
       //  *.jar files therein! This should be updated
-      othercp = System.getProperty("java.ext.dirs");
+      othercp = SecuritySupport.getSystemProperty("java.ext.dirs");
 
       if (null != othercp)
       {
@@ -1005,7 +1006,7 @@
     {
       Class clazz = ObjectFactory.findProviderClass(DOM_CLASS, true);
 
-      Method method = clazz.getMethod(DOM_LEVEL3_METHOD, null);
+      Method method = clazz.getMethod(DOM_LEVEL3_METHOD, (Class<?>[])null);
 
       // If we succeeded, we have loaded interfaces from a
       //  level 3 DOM somewhere
--- jaxp/src/com/sun/org/apache/xalan/internal/xslt/Process.java	2012-08-10 09:36:09.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xslt/Process.java	2013-05-05 09:39:19.000000000 -0700
@@ -57,6 +57,7 @@
 import com.sun.org.apache.xalan.internal.res.XSLTErrorResources;
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
 import com.sun.org.apache.xalan.internal.utils.ConfigurationError;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 //J2SE does not support Xalan interpretive
 /*
@@ -180,7 +181,7 @@
     java.io.PrintWriter diagnosticsWriter = new PrintWriter(System.err, true);
     java.io.PrintWriter dumpWriter = diagnosticsWriter;
     ResourceBundle resbundle =
-      (XSLMessages.loadResourceBundle(
+      (SecuritySupport.getResourceBundle(
         com.sun.org.apache.xml.internal.utils.res.XResourceBundle.ERROR_RESOURCES));
     String flavor = "s2s";
 
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java	2012-08-10 09:36:18.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java	2013-05-05 09:39:19.000000000 -0700
@@ -410,7 +410,7 @@
             }
         }
         catch (TypeCheckError e) {
-            reportError(ERROR, new ErrorMsg(e));
+            reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
     }
 
@@ -430,7 +430,7 @@
         }
         catch (IOException e) {
             if (_xsltc.debug()) e.printStackTrace();
-            reportError(ERROR,new ErrorMsg(e));
+            reportError(ERROR,new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
         catch (SAXException e) {
             Throwable ex = e.getException();
@@ -438,15 +438,15 @@
                 e.printStackTrace();
                 if (ex != null) ex.printStackTrace();
             }
-            reportError(ERROR, new ErrorMsg(e));
+            reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
         catch (CompilerException e) {
             if (_xsltc.debug()) e.printStackTrace();
-            reportError(ERROR, new ErrorMsg(e));
+            reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
         catch (Exception e) {
             if (_xsltc.debug()) e.printStackTrace();
-            reportError(ERROR, new ErrorMsg(e));
+            reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
         return null;
     }
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java	2012-08-10 09:36:22.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java	2013-05-05 09:39:19.000000000 -0700
@@ -41,10 +41,12 @@
 import java.util.jar.Manifest;
 
 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
 import com.sun.org.apache.xml.internal.dtm.DTM;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import org.xml.sax.InputSource;
 import org.xml.sax.XMLReader;
 
@@ -278,7 +280,7 @@
             return compile(input, _className);
         }
         catch (IOException e) {
-            _parser.reportError(Constants.FATAL, new ErrorMsg(e));
+            _parser.reportError(Constants.FATAL, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
             return false;
         }
     }
@@ -297,7 +299,7 @@
             return compile(input, name);
         }
         catch (IOException e) {
-            _parser.reportError(Constants.FATAL, new ErrorMsg(e));
+            _parser.reportError(Constants.FATAL, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
             return false;
         }
     }
@@ -382,11 +384,11 @@
         }
         catch (Exception e) {
             /*if (_debug)*/ e.printStackTrace();
-            _parser.reportError(Constants.FATAL, new ErrorMsg(e));
+            _parser.reportError(Constants.FATAL, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
         catch (Error e) {
             if (_debug) e.printStackTrace();
-            _parser.reportError(Constants.FATAL, new ErrorMsg(e));
+            _parser.reportError(Constants.FATAL, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
         }
         finally {
             _reader = null; // reset this here to be sure it is not re-used
@@ -594,7 +596,7 @@
      */
     public boolean setDestDirectory(String dstDirName) {
         final File dir = new File(dstDirName);
-        if (dir.exists() || dir.mkdirs()) {
+        if (SecuritySupport.getFileExists(dir) || dir.mkdirs()) {
             _destDir = dir;
             return true;
         }
@@ -767,7 +769,7 @@
             String parentDir = outFile.getParent();
             if (parentDir != null) {
                 File parentFile = new File(parentDir);
-                if (!parentFile.exists())
+                if (!SecuritySupport.getFileExists(parentFile))
                     parentFile.mkdirs();
             }
         }
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages.java	2012-08-10 09:36:23.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages.java	2013-05-05 09:39:19.000000000 -0700
@@ -997,7 +997,12 @@
          "kilobytes.  This is usually caused by templates in a stylesheet " +
          "that are very large.  Try restructuring your stylesheet to use " +
          "smaller templates."
-        }
+        },
+
+         {ErrorMsg.DESERIALIZE_TRANSLET_ERR, "When Java security is enabled, " +
+                        "support for deserializing TemplatesImpl is disabled." +
+                        "This can be overridden by setting the jdk.xml.enableTemplatesImplDeserialization" +
+                        " system property to true."}
 
     };
 
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMsg.java	2012-08-10 09:36:25.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMsg.java	2013-05-05 09:39:19.000000000 -0700
@@ -23,6 +23,7 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler.util;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.text.MessageFormat;
 import java.util.Locale;
 import java.util.ResourceBundle;
@@ -46,6 +47,8 @@
     Object[] _params = null;
     private boolean _isWarningError;
 
+    Throwable _cause;
+
     // Compiler error messages
     public static final String MULTIPLE_STYLESHEET_ERR = "MULTIPLE_STYLESHEET_ERR";
     public static final String TEMPLATE_REDEF_ERR = "TEMPLATE_REDEF_ERR";
@@ -165,6 +168,8 @@
     public static final String OUTLINE_ERR_METHOD_TOO_BIG =
                                             "OUTLINE_ERR_METHOD_TOO_BIG";
 
+    public static final String DESERIALIZE_TRANSLET_ERR = "DESERIALIZE_TEMPLATES_ERR";
+
     // All error messages are localized and are stored in resource bundles.
     // This array and the following 4 strings are read from that bundle.
     private static ResourceBundle _bundle;
@@ -175,7 +180,7 @@
     public final static String RUNTIME_ERROR_KEY    = "RUNTIME_ERROR_KEY";
 
     static {
-        _bundle = ResourceBundle.getBundle(
+        _bundle = SecuritySupport.getResourceBundle(
                           "com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMessages",
                           Locale.getDefault());
     }
@@ -185,10 +190,11 @@
         _line = 0;
     }
 
-    public ErrorMsg(Throwable e) {
-        _code = null;
+    public ErrorMsg(String code, Throwable e) {
+        _code = code;
         _message = e.getMessage();
         _line = 0;
+        _cause = e;
     }
 
     public ErrorMsg(String message, int line) {
@@ -240,6 +246,10 @@
         _params[1] = param2;
     }
 
+    public Throwable getCause() {
+        return _cause;
+    }
+
     private String getFileName(SyntaxTreeNode node) {
         Stylesheet stylesheet = node.getStylesheet();
         if (stylesheet != null)
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/Util.java	2012-08-10 09:36:26.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/Util.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.StringTokenizer;
 
 import com.sun.org.apache.bcel.internal.generic.Type;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.Constants;
 import com.sun.org.apache.xml.internal.utils.XML11Char;
 
@@ -37,7 +38,7 @@
     private static char filesep;
 
     static {
-        String temp = System.getProperty("file.separator", "/");
+        String temp = SecuritySupport.getSystemProperty("file.separator", "/");
         filesep = temp.charAt(0);
     }
 
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/NodeSortRecord.java	2012-08-10 09:36:28.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/NodeSortRecord.java	2013-05-05 09:39:19.000000000 -0700
@@ -33,6 +33,7 @@
 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
 import com.sun.org.apache.xml.internal.utils.StringComparable;
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 /**
  * Base class for sort records containing application specific sort keys
@@ -112,7 +113,7 @@
         try {
             // -- W. Eliot Kimber (eliot@isogen.com)
             colFactClassname =
-                System.getProperty("com.sun.org.apache.xalan.internal.xsltc.COLLATOR_FACTORY");
+                SecuritySupport.getSystemProperty("com.sun.org.apache.xalan.internal.xsltc.COLLATOR_FACTORY");
         }
         catch (SecurityException e) {
             // If we can't read the propery, just use default collator
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java	2012-08-10 09:36:29.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java	2013-05-05 09:39:19.000000000 -0700
@@ -23,6 +23,7 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.runtime;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.FieldPosition;
@@ -1583,7 +1584,7 @@
 
     static {
         String resource = "com.sun.org.apache.xalan.internal.xsltc.runtime.ErrorMessages";
-        m_bundle = ResourceBundle.getBundle(resource);
+        m_bundle = SecuritySupport.getResourceBundle(resource);
     }
 
     /**
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/output/WriterOutputBuffer.java	2012-08-10 09:36:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/output/WriterOutputBuffer.java	2013-05-05 09:39:19.000000000 -0700
@@ -23,6 +23,7 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.runtime.output;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.io.Writer;
@@ -36,7 +37,7 @@
 
     static {
         // Set a larger buffer size for Solaris
-        final String osName = System.getProperty("os.name");
+        final String osName = SecuritySupport.getSystemProperty("os.name");
         if (osName.equalsIgnoreCase("solaris")) {
             BUFFER_SIZE = 32 * KB;
         }
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java	2012-08-10 09:36:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java	2013-05-05 09:39:19.000000000 -0700
@@ -43,6 +43,7 @@
 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 /**
  * @author Morten Jorgensen
@@ -52,6 +53,8 @@
  */
 public final class TemplatesImpl implements Templates, Serializable {
     static final long serialVersionUID = 673094361519270707L;
+    public final static String DESERIALIZE_TRANSLET = "jdk.xml.enableTemplatesImplDeserialization";
+
     /**
      * Name of the superclass of all translets. This is needed to
      * determine which, among all classes comprising a translet,
@@ -186,6 +189,15 @@
     private void  readObject(ObjectInputStream is)
       throws IOException, ClassNotFoundException
     {
+        SecurityManager security = System.getSecurityManager();
+        if (security != null){
+            String temp = SecuritySupport.getSystemProperty(DESERIALIZE_TRANSLET);
+            if (temp == null || !(temp.length()==0 || temp.equalsIgnoreCase("true"))) {
+                ErrorMsg err = new ErrorMsg(ErrorMsg.DESERIALIZE_TRANSLET_ERR);
+                throw new UnsupportedOperationException(err.toString());
+            }
+        }
+
         is.defaultReadObject();
         if (is.readBoolean()) {
             _uriResolver = (URIResolver) is.readObject();
--- jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java	2012-08-10 09:36:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java	2013-05-05 09:39:19.000000000 -0700
@@ -73,7 +73,7 @@
 import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
 import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
-
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 import org.xml.sax.InputSource;
 import org.xml.sax.XMLFilter;
@@ -881,8 +881,14 @@
         // Check that the transformation went well before returning
     if (bytecodes == null) {
 
-        ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR);
-        TransformerConfigurationException exc =  new TransformerConfigurationException(err.toString());
+        Vector errs = xsltc.getErrors();
+        ErrorMsg err = null;
+        if (errs != null) {
+            err = (ErrorMsg)errs.get(errs.size()-1);
+        } else {
+            err = new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR);
+        }
+        TransformerConfigurationException exc =  new TransformerConfigurationException(err.toString(), err.getCause());
 
         // Pass compiler errors to the error listener
         if (_errorListener != null) {
@@ -1229,7 +1235,7 @@
         // Find the parent directory of the translet.
         String transletParentDir = transletFile.getParent();
         if (transletParentDir == null)
-            transletParentDir = System.getProperty("user.dir");
+            transletParentDir = SecuritySupport.getSystemProperty("user.dir");
 
         File transletParentFile = new File(transletParentDir);
 
--- jaxp/src/com/sun/org/apache/xerces/internal/dom/DOMMessageFormatter.java	2012-08-10 09:36:33.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/dom/DOMMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,10 +20,10 @@
 
 
 package com.sun.org.apache.xerces.internal.dom;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.util.PropertyResourceBundle;
 
 /**
  * Used to format DOM error messages, using the system locale.
@@ -31,6 +31,7 @@
  * @xerces.internal
  *
  * @author Sandy Gao, IBM
+ * @version $Id: DOMMessageFormatter.java,v 1.6 2010-11-01 04:39:38 joehw Exp $
  */
 public class DOMMessageFormatter {
     public static final String DOM_DOMAIN = "http://www.w3.org/dom/DOMTR";
@@ -122,13 +123,13 @@
      */
     public static void init(){
         if (locale != null) {
-            domResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.DOMMessages", locale);
-            serResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSerializerMessages", locale);
-            xmlResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+            domResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.DOMMessages", locale);
+            serResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSerializerMessages", locale);
+            xmlResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
         }else{
-            domResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.DOMMessages");
-            serResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSerializerMessages");
-            xmlResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+            domResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.DOMMessages");
+            serResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSerializerMessages");
+            xmlResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
     }
 
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java	2012-08-10 09:36:39.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java	2013-05-05 09:39:20.000000000 -0700
@@ -51,6 +51,7 @@
 import com.sun.org.apache.xerces.internal.xni.XNIException;
 import com.sun.org.apache.xerces.internal.xni.parser.*;
 import com.sun.org.apache.xerces.internal.impl.Constants;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import com.sun.xml.internal.stream.Entity;
 import com.sun.org.apache.xerces.internal.xni.Augmentations;
 
@@ -1727,7 +1728,7 @@
         // get the user.dir property
         String userDir = "";
         try {
-            userDir = System.getProperty("user.dir");
+            userDir = SecuritySupport.getSystemProperty("user.dir");
         }
         catch (SecurityException se) {
         }
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/DatatypeException.java	2012-08-10 09:36:42.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/DatatypeException.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,6 +20,7 @@
 
 package com.sun.org.apache.xerces.internal.impl.dv;
 
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.ResourceBundle;
 import java.util.PropertyResourceBundle;
 import java.util.MissingResourceException;
@@ -34,6 +35,7 @@
  *
  * @author Sandy Gao, IBM
  *
+ * @version $Id: DatatypeException.java,v 1.6 2010-11-01 04:39:43 joehw Exp $
  */
 public class DatatypeException extends Exception {
 
@@ -84,7 +86,7 @@
      */
     public String getMessage() {
         ResourceBundle resourceBundle = null;
-        resourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages");
+        resourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages");
         if (resourceBundle == null)
             throw new MissingResourceException("Property file not found!", "com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages", key);
 
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter.java	2012-08-10 09:36:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter.java	2013-05-05 09:39:19.000000000 -0700
@@ -20,12 +20,11 @@
 
 package com.sun.org.apache.xerces.internal.impl.msg;
 
+import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.util.PropertyResourceBundle;
-
-import com.sun.org.apache.xerces.internal.util.MessageFormatter;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +33,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter.java 3020 2011-02-28 23:51:33Z joehw $
+ * @version $Id: XMLMessageFormatter.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter implements MessageFormatter {
@@ -72,12 +71,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_de.java	2012-08-10 09:36:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_de.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_de.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_de.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_de implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_es.java	2012-08-10 09:36:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_es.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_es.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_es.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_es implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_fr.java	2012-08-10 09:36:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_fr.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_fr.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_fr.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_fr implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_it.java	2012-08-10 09:36:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_it.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_it.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_it.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_it implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_ja.java	2012-08-10 09:36:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_ja.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_ja.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_ja.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_ja implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_ko.java	2012-08-10 09:36:53.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_ko.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_ko.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_ko.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_ko implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_pt_BR.java	2012-08-10 09:36:53.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_pt_BR.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_pt_BR.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_pt_BR.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_pt_BR implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_sv.java	2012-08-10 09:36:53.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_sv.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_sv.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_sv.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_sv implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_zh_CN.java	2012-08-10 09:36:53.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_zh_CN.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_zh_CN.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_zh_CN.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_zh_CN implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_zh_TW.java	2012-08-10 09:36:53.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/msg/XMLMessageFormatter_zh_TW.java	2013-05-05 09:39:19.000000000 -0700
@@ -26,6 +26,7 @@
 import java.util.PropertyResourceBundle;
 
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for
@@ -34,7 +35,7 @@
  * @xerces.internal
  *
  * @author Eric Ye, IBM
- * @version $Id: XMLMessageFormatter_zh_TW.java 3021 2011-03-01 00:12:28Z joehw $
+ * @version $Id: XMLMessageFormatter_zh_TW.java 3094 2012-03-21 05:50:01Z joehw $
  *
  */
 public class XMLMessageFormatter_zh_TW implements MessageFormatter {
@@ -72,12 +73,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java	2012-08-10 09:36:59.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,6 +20,7 @@
 
 package com.sun.org.apache.xerces.internal.impl.xpath.regex;
 
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
@@ -95,10 +96,10 @@
     public void setLocale(Locale locale) {
         try {
             if (locale != null) {
-                this.resources = ResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.xpath.regex.message", locale);
+                this.resources = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.xpath.regex.message", locale);
             }
             else {
-                this.resources = ResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.xpath.regex.message");
+                this.resources = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.xpath.regex.message");
             }
         }
         catch (MissingResourceException mre) {
--- jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XSMessageFormatter.java	2012-08-10 09:37:02.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XSMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,11 +20,11 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs;
 
+import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.util.PropertyResourceBundle;
-import com.sun.org.apache.xerces.internal.util.MessageFormatter;
 
 
 /**
@@ -34,6 +34,7 @@
  * @xerces.internal
  *
  * @author Elena Litani, IBM
+ * @version $Id: XSMessageFormatter.java,v 1.6 2010-11-01 04:39:55 joehw Exp $
  */
 public class XSMessageFormatter implements MessageFormatter {
     /**
@@ -66,12 +67,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XMLSchemaMessages");
         }
 
         String msg = fResourceBundle.getString(key);
--- jaxp/src/com/sun/org/apache/xerces/internal/jaxp/validation/JAXPValidationMessageFormatter.java	2012-08-10 09:37:14.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/jaxp/validation/JAXPValidationMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,15 +20,16 @@
 
 package com.sun.org.apache.xerces.internal.jaxp.validation;
 
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.util.PropertyResourceBundle;
 
 /**
  * <p>Used to format JAXP Validation API error messages using a specified locale.</p>
  *
  * @author Michael Glavassevich, IBM
+ * @version $Id: JAXPValidationMessageFormatter.java,v 1.5 2010-11-01 04:40:08 joehw Exp $
  */
 final class JAXPValidationMessageFormatter {
 
@@ -54,11 +55,11 @@
         ResourceBundle resourceBundle = null;
         if (locale != null) {
             resourceBundle =
-                PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.JAXPValidationMessages", locale);
+                SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.JAXPValidationMessages", locale);
         }
         else {
             resourceBundle =
-                PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.JAXPValidationMessages");
+                SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.JAXPValidationMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/util/DatatypeMessageFormatter.java	2012-08-10 09:37:18.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/util/DatatypeMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,15 +20,16 @@
 
 package com.sun.org.apache.xerces.internal.util;
 
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
-import java.util.PropertyResourceBundle;
 import java.util.ResourceBundle;
 
 /**
  * <p>Used to format JAXP 1.3 Datatype API error messages using a specified locale.</p>
  *
  * @author  Neeraj Bajaj, Sun Microsystems
+ * @version $Id: DatatypeMessageFormatter.java,v 1.6 2010-11-01 04:40:14 joehw Exp $
  */
 public class DatatypeMessageFormatter {
 
@@ -56,11 +57,11 @@
         ResourceBundle resourceBundle = null;
         if (locale != null) {
             resourceBundle =
-                PropertyResourceBundle.getBundle(BASE_NAME, locale);
+                SecuritySupport.getResourceBundle(BASE_NAME, locale);
         }
         else {
             resourceBundle =
-                PropertyResourceBundle.getBundle(BASE_NAME);
+                SecuritySupport.getResourceBundle(BASE_NAME);
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/util/SAXMessageFormatter.java	2012-08-10 09:37:19.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/util/SAXMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -19,16 +19,17 @@
  */
 package com.sun.org.apache.xerces.internal.util;
 
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.util.PropertyResourceBundle;
 
 /**
  * Used to format SAX error messages using a specified locale.
  *
  * @author Michael Glavassevich, IBM
  *
+ * @version $Id: SAXMessageFormatter.java,v 1.6 2010-11-01 04:40:14 joehw Exp $
  */
 public class SAXMessageFormatter {
 
@@ -54,11 +55,11 @@
         ResourceBundle resourceBundle = null;
         if (locale != null) {
             resourceBundle =
-                PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.SAXMessages", locale);
+                SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.SAXMessages", locale);
         }
         else {
             resourceBundle =
-                PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.SAXMessages");
+                SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.SAXMessages");
         }
 
         // format message
--- jaxp/src/com/sun/org/apache/xerces/internal/util/SecurityManager.java	2012-08-10 09:37:20.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/util/SecurityManager.java	2013-05-05 09:39:20.000000000 -0700
@@ -61,6 +61,8 @@
 
 package com.sun.org.apache.xerces.internal.util;
 import com.sun.org.apache.xerces.internal.impl.Constants;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 /**
  * This class is a container for parser settings that relate to
  * security, or more specifically, it is intended to be used to prevent denial-of-service
@@ -77,6 +79,7 @@
  *
  * @author  Neil Graham, IBM
  *
+ * @version $Id: SecurityManager.java,v 1.5 2010-11-01 04:40:14 joehw Exp $
  */
 public final class SecurityManager {
 
@@ -176,41 +179,48 @@
 
         private void readSystemProperties(){
 
-                //TODO: also read SYSTEM_PROPERTY_ELEMENT_ATTRIBUTE_LIMIT
-                try {
-                        String value = System.getProperty(Constants.ENTITY_EXPANSION_LIMIT);
-                        if(value != null && !value.equals("")){
-                                entityExpansionLimit = Integer.parseInt(value);
-                                if (entityExpansionLimit < 0)
-                                        entityExpansionLimit = DEFAULT_ENTITY_EXPANSION_LIMIT;
-                        }
-                        else
-                                entityExpansionLimit = DEFAULT_ENTITY_EXPANSION_LIMIT;
-                }catch(Exception ex){}
-
-                try {
-                        String value = System.getProperty(Constants.MAX_OCCUR_LIMIT);
-                        if(value != null && !value.equals("")){
-                                maxOccurLimit = Integer.parseInt(value);
-                                if (maxOccurLimit < 0)
-                                        maxOccurLimit = DEFAULT_MAX_OCCUR_NODE_LIMIT;
-                        }
-                        else
-                                maxOccurLimit = DEFAULT_MAX_OCCUR_NODE_LIMIT;
-                }catch(Exception ex){}
-
-                try {
-                        String value = System.getProperty(Constants.SYSTEM_PROPERTY_ELEMENT_ATTRIBUTE_LIMIT);
-                        if(value != null && !value.equals("")){
-                                fElementAttributeLimit = Integer.parseInt(value);
-                                if ( fElementAttributeLimit < 0)
-                                        fElementAttributeLimit = DEFAULT_ELEMENT_ATTRIBUTE_LIMIT;
-                        }
-                        else
-                                fElementAttributeLimit = DEFAULT_ELEMENT_ATTRIBUTE_LIMIT;
+            //TODO: also read SYSTEM_PROPERTY_ELEMENT_ATTRIBUTE_LIMIT
+            try {
+                    String value = getSystemProperty(Constants.ENTITY_EXPANSION_LIMIT);
+                    if(value != null && !value.equals("")){
+                            entityExpansionLimit = Integer.parseInt(value);
+                            if (entityExpansionLimit < 0)
+                                    entityExpansionLimit = DEFAULT_ENTITY_EXPANSION_LIMIT;
+                    }
+                    else
+                            entityExpansionLimit = DEFAULT_ENTITY_EXPANSION_LIMIT;
+            }catch(Exception ex){}
+
+            try {
+                    String value = getSystemProperty(Constants.MAX_OCCUR_LIMIT);
+                    if(value != null && !value.equals("")){
+                            maxOccurLimit = Integer.parseInt(value);
+                            if (maxOccurLimit < 0)
+                                    maxOccurLimit = DEFAULT_MAX_OCCUR_NODE_LIMIT;
+                    }
+                    else
+                            maxOccurLimit = DEFAULT_MAX_OCCUR_NODE_LIMIT;
+            }catch(Exception ex){}
+
+            try {
+                    String value = getSystemProperty(Constants.SYSTEM_PROPERTY_ELEMENT_ATTRIBUTE_LIMIT);
+                    if(value != null && !value.equals("")){
+                            fElementAttributeLimit = Integer.parseInt(value);
+                            if ( fElementAttributeLimit < 0)
+                                    fElementAttributeLimit = DEFAULT_ELEMENT_ATTRIBUTE_LIMIT;
+                    }
+                    else
+                            fElementAttributeLimit = DEFAULT_ELEMENT_ATTRIBUTE_LIMIT;
 
                 }catch(Exception ex){}
 
         }
 
+    private String getSystemProperty(final String propName) {
+        return AccessController.doPrivileged(new PrivilegedAction<String>() {
+            public String run() {
+                return System.getProperty(propName);
+            }
+        });
+    }
 } // class SecurityManager
--- jaxp/src/com/sun/org/apache/xerces/internal/utils/ObjectFactory.java	2012-08-10 09:37:21.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/utils/ObjectFactory.java	2013-05-05 09:39:19.000000000 -0700
@@ -48,6 +48,7 @@
     //
     // Constants
     //
+    private static final String DEFAULT_INTERNAL_CLASSES = "com.sun.org.apache.";
 
     // name of default properties file to look for in JDK's jre/lib directory
     private static final String DEFAULT_PROPERTIES_FILENAME = "xerces.properties";
@@ -305,10 +306,14 @@
         //restrict the access to package as speicified in java.security policy
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
-            final int lastDot = className.lastIndexOf(".");
-            String packageName = className;
-            if (lastDot != -1) packageName = className.substring(0, lastDot);
-            security.checkPackageAccess(packageName);
+            if (className.startsWith(DEFAULT_INTERNAL_CLASSES)) {
+                cl = null;
+            } else {
+                final int lastDot = className.lastIndexOf(".");
+                String packageName = className;
+                if (lastDot != -1) packageName = className.substring(0, lastDot);
+                security.checkPackageAccess(packageName);
+            }
         }
         Class providerClass;
         if (cl == null) {
--- jaxp/src/com/sun/org/apache/xerces/internal/utils/SecuritySupport.java	2012-08-10 09:37:21.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/utils/SecuritySupport.java	2013-05-05 09:39:19.000000000 -0700
@@ -29,6 +29,10 @@
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.PropertyResourceBundle;
+import java.util.ResourceBundle;
 
 /**
  * This class is duplicated for each subpackage so keep it in sync.
@@ -141,6 +145,38 @@
         });
     }
 
+    /**
+     * Gets a resource bundle using the specified base name, the default locale, and the caller's class loader.
+     * @param bundle the base name of the resource bundle, a fully qualified class name
+     * @return a resource bundle for the given base name and the default locale
+     */
+    public static ResourceBundle getResourceBundle(String bundle) {
+        return getResourceBundle(bundle, Locale.getDefault());
+    }
+
+    /**
+     * Gets a resource bundle using the specified base name and locale, and the caller's class loader.
+     * @param bundle the base name of the resource bundle, a fully qualified class name
+     * @param locale the locale for which a resource bundle is desired
+     * @return a resource bundle for the given base name and locale
+     */
+    public static ResourceBundle getResourceBundle(final String bundle, final Locale locale) {
+        return AccessController.doPrivileged(new PrivilegedAction<ResourceBundle>() {
+            public ResourceBundle run() {
+                try {
+                    return PropertyResourceBundle.getBundle(bundle, locale);
+                } catch (MissingResourceException e) {
+                    try {
+                        return PropertyResourceBundle.getBundle(bundle, new Locale("en", "US"));
+                    } catch (MissingResourceException e2) {
+                        throw new MissingResourceException(
+                                "Could not load any resource bundle by " + bundle, bundle, "");
+                    }
+                }
+            }
+        });
+    }
+
     static boolean getFileExists(final File f) {
         return ((Boolean)
                 AccessController.doPrivileged(new PrivilegedAction() {
--- jaxp/src/com/sun/org/apache/xerces/internal/xinclude/XIncludeMessageFormatter.java	2012-08-10 09:37:22.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/xinclude/XIncludeMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -20,11 +20,11 @@
 
 package com.sun.org.apache.xerces.internal.xinclude;
 
+import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.util.PropertyResourceBundle;
-import com.sun.org.apache.xerces.internal.util.MessageFormatter;
 
 // TODO: fix error messages in XIncludeMessages.properties
 /**
@@ -32,6 +32,7 @@
  *
  * @author Peter McCracken, IBM
  *
+ * @version $Id: XIncludeMessageFormatter.java,v 1.7 2010-11-01 04:40:18 joehw Exp $
  */
 public class XIncludeMessageFormatter implements MessageFormatter {
 
@@ -61,12 +62,12 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XIncludeMessages", locale);
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XIncludeMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle.getBundle("com.sun.org.apache.xerces.internal.impl.msg.XIncludeMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle("com.sun.org.apache.xerces.internal.impl.msg.XIncludeMessages");
         }
 
         String msg = fResourceBundle.getString(key);
--- jaxp/src/com/sun/org/apache/xerces/internal/xpointer/XPointerMessageFormatter.java	2012-08-10 09:37:27.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xerces/internal/xpointer/XPointerMessageFormatter.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,6 +24,7 @@
 import java.util.ResourceBundle;
 import java.util.PropertyResourceBundle;
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * XPointerMessageFormatter provides error messages for the XPointer Framework
@@ -31,6 +32,7 @@
  *
  * @xerces.internal
  *
+ * @version $Id: XPointerMessageFormatter.java,v 1.5 2010-11-01 04:40:26 joehw Exp $
  */
 class XPointerMessageFormatter implements MessageFormatter {
 
@@ -64,14 +66,14 @@
 
         if (fResourceBundle == null || locale != fLocale) {
             if (locale != null) {
-                fResourceBundle = PropertyResourceBundle.getBundle(
+                fResourceBundle = SecuritySupport.getResourceBundle(
                         "com.sun.org.apache.xerces.internal.impl.msg.XPointerMessages", locale);
                 // memorize the most-recent locale
                 fLocale = locale;
             }
             if (fResourceBundle == null)
-                fResourceBundle = PropertyResourceBundle
-                        .getBundle("com.sun.org.apache.xerces.internal.impl.msg.XPointerMessages");
+                fResourceBundle = SecuritySupport.getResourceBundle(
+                        "com.sun.org.apache.xerces.internal.impl.msg.XPointerMessages");
         }
 
         String msg = fResourceBundle.getString(key);
--- jaxp/src/com/sun/org/apache/xml/internal/dtm/DTMManager.java	2012-08-10 09:37:37.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/dtm/DTMManager.java	2013-05-05 09:39:20.000000000 -0700
@@ -27,6 +27,7 @@
 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
 import com.sun.org.apache.xml.internal.utils.XMLStringFactory;
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 
 /**
  * A DTMManager instance can be used to create DTM and
@@ -383,7 +384,7 @@
   {
     try
     {
-      debug = System.getProperty("dtm.debug") != null;
+      debug = SecuritySupport.getSystemProperty("dtm.debug") != null;
     }
     catch (SecurityException ex){}
   }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources.java	2012-08-10 09:37:40.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_ca.java	2012-08-10 09:37:40.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_ca.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -443,67 +440,4 @@
     return _contents;
   }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("ca", "ES"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_cs.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_cs.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -443,67 +440,4 @@
     return _contents;
   }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("cs", "CZ"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_de.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_de.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_es.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_es.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_fr.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_fr.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_it.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_it.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_ja.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_ja.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_ko.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_ko.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_pt_BR.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_pt_BR.java	2013-05-05 09:39:20.000000000 -0700
@@ -25,9 +25,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -463,67 +460,4 @@
         return msgCopy;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_sk.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_sk.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -443,67 +440,4 @@
     return _contents;
   }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_sv.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_sv.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -452,68 +449,4 @@
     protected Object[][] getContents() {
         return _contents;
     }
-
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_tr.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_tr.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -443,67 +440,4 @@
     return _contents;
   }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("tr", "TR"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_zh_CN.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_zh_CN.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_zh_TW.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLErrorResources_zh_TW.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -453,67 +450,4 @@
         return _contents;
     }
 
-  /**
-   *   Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   *   of ResourceBundle.getBundle().
-   *
-   *   @param className the name of the class that implements the resource bundle.
-   *   @return the ResourceBundle
-   *   @throws MissingResourceException
-   */
-  public static final XMLErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XMLErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XMLErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xml/internal/res/XMLMessages.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/res/XMLMessages.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,10 +22,9 @@
  */
 package com.sun.org.apache.xml.internal.res;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.util.ListResourceBundle;
 import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * A utility class for issuing XML error messages.
@@ -82,8 +81,9 @@
    */
   public static final String createXMLMessage(String msgKey, Object args[])
   {
-    if (XMLBundle == null)
-      XMLBundle = loadResourceBundle(XML_ERROR_RESOURCES);
+    if (XMLBundle == null) {
+        XMLBundle = SecuritySupport.getResourceBundle(XML_ERROR_RESOURCES);
+    }
 
     if (XMLBundle != null)
     {
@@ -156,61 +156,4 @@
     return fmsg;
   }
 
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className The class name of the resource bundle.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static ListResourceBundle loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-    Locale locale = Locale.getDefault();
-
-    try
-    {
-      return (ListResourceBundle)ResourceBundle.getBundle(className, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (ListResourceBundle)ResourceBundle.getBundle(
-          className, new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles." + className, className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which can be appended to a resource name
-   */
-  protected static String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
 }
--- jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java	2012-08-10 09:37:41.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,6 +24,7 @@
 package com.sun.org.apache.xml.internal.resolver;
 
 import com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.io.IOException;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
@@ -821,7 +822,7 @@
       // tack on a basename because URLs point to files not dirs
       catalogCwd = FileURL.makeURL("basename");
     } catch (MalformedURLException e) {
-      String userdir = System.getProperty("user.dir");
+      String userdir = SecuritySupport.getSystemProperty("user.dir");
       userdir.replace('\\', '/');
       catalogManager.debug.message(1, "Malformed URL on cwd", userdir);
       catalogCwd = null;
@@ -1717,7 +1718,7 @@
   protected String resolveLocalSystem(String systemId)
     throws MalformedURLException, IOException {
 
-    String osname = System.getProperty("os.name");
+    String osname = SecuritySupport.getSystemProperty("os.name");
     boolean windows = (osname.indexOf("Windows") >= 0);
     Enumeration en = catalogEntries.elements();
     while (en.hasMoreElements()) {
--- jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogManager.java	2012-08-10 09:37:42.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogManager.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,6 +23,7 @@
 
 package com.sun.org.apache.xml.internal.resolver;
 
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.io.InputStream;
 
 import java.net.URL;
@@ -142,8 +143,8 @@
 
   /** Flag to ignore missing property files and/or properties */
   private boolean ignoreMissingProperties
-    = (System.getProperty(pIgnoreMissing) != null
-       || System.getProperty(pFiles) != null);
+    = (SecuritySupport.getSystemProperty(pIgnoreMissing) != null
+       || SecuritySupport.getSystemProperty(pFiles) != null);
 
   /** Holds the resources after they are loaded from the file. */
   private ResourceBundle resources;
@@ -338,7 +339,7 @@
   private int queryVerbosity () {
     String defaultVerbStr = Integer.toString(defaultVerbosity);
 
-    String verbStr = System.getProperty(pVerbosity);
+    String verbStr = SecuritySupport.getSystemProperty(pVerbosity);
 
     if (verbStr == null) {
       if (resources==null) readProperties();
@@ -473,7 +474,7 @@
    * @return A semicolon delimited list of catlog file URIs
    */
   private String queryCatalogFiles () {
-    String catalogList = System.getProperty(pFiles);
+    String catalogList = SecuritySupport.getSystemProperty(pFiles);
     fromPropertiesFile = false;
 
     if (catalogList == null) {
@@ -558,7 +559,7 @@
    * defaultPreferSetting.
    */
   private boolean queryPreferPublic () {
-    String prefer = System.getProperty(pPrefer);
+    String prefer = SecuritySupport.getSystemProperty(pPrefer);
 
     if (prefer == null) {
       if (resources==null) readProperties();
@@ -617,7 +618,7 @@
    * defaultUseStaticCatalog.
    */
   private boolean queryUseStaticCatalog () {
-    String staticCatalog = System.getProperty(pStatic);
+    String staticCatalog = SecuritySupport.getSystemProperty(pStatic);
 
     if (staticCatalog == null) {
       if (resources==null) readProperties();
@@ -748,7 +749,7 @@
    * defaultOasisXMLCatalogPI.
    */
   public boolean queryAllowOasisXMLCatalogPI () {
-    String allow = System.getProperty(pAllowPI);
+    String allow = SecuritySupport.getSystemProperty(pAllowPI);
 
     if (allow == null) {
       if (resources==null) readProperties();
@@ -804,7 +805,7 @@
    *
    */
   public String queryCatalogClassName () {
-    String className = System.getProperty(pClassname);
+    String className = SecuritySupport.getSystemProperty(pClassname);
 
     if (className == null) {
       if (resources==null) readProperties();
--- jaxp/src/com/sun/org/apache/xml/internal/resolver/Resolver.java	2012-08-10 09:37:42.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/resolver/Resolver.java	2013-05-05 09:39:20.000000000 -0700
@@ -33,6 +33,7 @@
 import java.net.MalformedURLException;
 import javax.xml.parsers.SAXParserFactory;
 import com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import com.sun.org.apache.xml.internal.resolver.readers.SAXCatalogReader;
 import com.sun.org.apache.xml.internal.resolver.readers.OASISXMLCatalogReader;
 import com.sun.org.apache.xml.internal.resolver.readers.TR9401CatalogReader;
@@ -524,7 +525,7 @@
      */
     private Vector resolveAllLocalSystem(String systemId) {
         Vector map = new Vector();
-        String osname = System.getProperty("os.name");
+        String osname = SecuritySupport.getSystemProperty("os.name");
         boolean windows = (osname.indexOf("Windows") >= 0);
         Enumeration en = catalogEntries.elements();
         while (en.hasMoreElements()) {
@@ -552,7 +553,7 @@
      */
     private Vector resolveLocalSystemReverse(String systemId) {
         Vector map = new Vector();
-        String osname = System.getProperty("os.name");
+        String osname = SecuritySupport.getSystemProperty("os.name");
         boolean windows = (osname.indexOf("Windows") >= 0);
         Enumeration en = catalogEntries.elements();
         while (en.hasMoreElements()) {
--- jaxp/src/com/sun/org/apache/xml/internal/serialize/SerializerFactory.java	2012-08-10 09:37:47.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/serialize/SerializerFactory.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,7 @@
 package com.sun.org.apache.xml.internal.serialize;
 
 import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.io.OutputStream;
 import java.io.Writer;
 import java.io.UnsupportedEncodingException;
@@ -64,7 +65,7 @@
         factory =  new SerializerFactoryImpl( Method.TEXT );
         registerSerializerFactory( factory );
 
-        list = System.getProperty( FactoriesProperty );
+        list = SecuritySupport.getSystemProperty( FactoriesProperty );
         if ( list != null ) {
             token = new StringTokenizer( list, " ;,:" );
             while ( token.hasMoreTokens() ) {
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/Encodings.java	2012-08-10 09:37:52.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/Encodings.java	2013-05-05 09:39:20.000000000 -0700
@@ -219,7 +219,7 @@
                 // Get the default system character encoding.  This may be
                 // incorrect if they passed in a writer, but right now there
                 // seems to be no way to get the encoding from a writer.
-                encoding = System.getProperty("file.encoding", "UTF8");
+                encoding = SecuritySupport.getSystemProperty("file.encoding", "UTF8");
 
                 if (null != encoding)
                 {
@@ -313,7 +313,7 @@
 
             try
             {
-                urlString = System.getProperty(ENCODINGS_PROP, "");
+                urlString = SecuritySupport.getSystemProperty(ENCODINGS_PROP, "");
             }
             catch (SecurityException e)
             {
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/OutputPropertiesFactory.java	2012-08-10 09:37:56.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/OutputPropertiesFactory.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,7 @@
  */
 package com.sun.org.apache.xml.internal.serializer;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -471,7 +472,7 @@
             String value = null;
             try
             {
-                value = System.getProperty(key);
+                value = SecuritySupport.getSystemProperty(key);
             }
             catch (SecurityException se)
             {
@@ -484,7 +485,7 @@
             String newValue = null;
             try
             {
-                newValue = System.getProperty(newKey);
+                newValue = SecuritySupport.getSystemProperty(newKey);
             }
             catch (SecurityException se)
             {
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/ToStream.java	2012-08-10 09:38:02.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/ToStream.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,7 @@
  */
 package com.sun.org.apache.xml.internal.serializer;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
@@ -140,7 +141,7 @@
      * extension attribute xalan:line-separator.
      */
     protected char[] m_lineSep =
-        System.getProperty("line.separator").toCharArray();
+        SecuritySupport.getSystemProperty("line.separator").toCharArray();
 
     /**
      * True if the the system line separator is to be used.
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/TreeWalker.java	2012-08-10 09:38:02.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/TreeWalker.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,7 @@
  */
 package com.sun.org.apache.xml.internal.serializer;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.io.File;
 
 import com.sun.org.apache.xml.internal.serializer.utils.AttList;
@@ -104,7 +105,7 @@
       else {
           try {
             // Bug see Bugzilla  26741
-            m_locator.setSystemId(System.getProperty("user.dir") + File.separator + "dummy.xsl");
+            m_locator.setSystemId(SecuritySupport.getSystemProperty("user.dir") + File.separator + "dummy.xsl");
            }
            catch (SecurityException se) {// user.dir not accessible from applet
            }
@@ -115,7 +116,7 @@
                         m_contentHandler.setDocumentLocator(m_locator);
                 try {
                    // Bug see Bugzilla  26741
-                  m_locator.setSystemId(System.getProperty("user.dir") + File.separator + "dummy.xsl");
+                  m_locator.setSystemId(SecuritySupport.getSystemProperty("user.dir") + File.separator + "dummy.xsl");
                 }
                 catch (SecurityException se){// user.dir not accessible from applet
 
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/utils/Messages.java	2012-08-10 09:38:06.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/utils/Messages.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,7 @@
  */
 package com.sun.org.apache.xml.internal.serializer.utils;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.util.ListResourceBundle;
 import java.util.Locale;
 import java.util.MissingResourceException;
@@ -87,9 +88,6 @@
  * can have the Message strings translated in an alternate language
  * in a errorResourceClass with a language suffix.
  *
- * More sophisticated use of this class would be to pass null
- * when contructing it, but then call loadResourceBundle()
- * before creating any messages.
  *
  * This class is not a public API, it is only public because it is
  * used in com.sun.org.apache.xml.internal.serializer.
@@ -126,18 +124,6 @@
         m_resourceBundleName = resourceBundle;
     }
 
-    /*
-     * Set the Locale object to use. If this method is not called the
-     * default locale is used. This method needs to be called before
-     * loadResourceBundle().
-     *
-     * @param locale non-null reference to Locale object.
-     * @xsl.usage internal
-     */
-//    public void setLocale(Locale locale)
-//    {
-//        m_locale = locale;
-//    }
 
     /**
      * Get the Locale object that is being used.
@@ -151,16 +137,6 @@
     }
 
     /**
-     * Get the ListResourceBundle being used by this Messages instance which was
-     * previously set by a call to loadResourceBundle(className)
-     * @xsl.usage internal
-     */
-    private ListResourceBundle getResourceBundle()
-    {
-        return m_resourceBundle;
-    }
-
-    /**
      * Creates a message from the specified key and replacement
      * arguments, localized to the given locale.
      *
@@ -174,7 +150,7 @@
     public final String createMessage(String msgKey, Object args[])
     {
         if (m_resourceBundle == null)
-            m_resourceBundle = loadResourceBundle(m_resourceBundleName);
+            m_resourceBundle = SecuritySupport.getResourceBundle(m_resourceBundleName);
 
         if (m_resourceBundle != null)
         {
@@ -293,76 +269,4 @@
         return fmsg;
     }
 
-    /**
-     * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-     * of ResourceBundle.getBundle().
-     *
-     * @param className the name of the class that implements ListResourceBundle,
-     * without language suffix.
-     * @return the ResourceBundle
-     * @throws MissingResourceException
-     * @xsl.usage internal
-     */
-    private ListResourceBundle loadResourceBundle(String resourceBundle)
-        throws MissingResourceException
-    {
-        m_resourceBundleName = resourceBundle;
-        Locale locale = getLocale();
-
-        ListResourceBundle lrb;
-
-        try
-        {
-
-            ResourceBundle rb =
-                ResourceBundle.getBundle(m_resourceBundleName, locale);
-            lrb = (ListResourceBundle) rb;
-        }
-        catch (MissingResourceException e)
-        {
-            try // try to fall back to en_US if we can't load
-                {
-
-                // Since we can't find the localized property file,
-                // fall back to en_US.
-                lrb =
-                    (ListResourceBundle) ResourceBundle.getBundle(
-                        m_resourceBundleName,
-                        new Locale("en", "US"));
-            }
-            catch (MissingResourceException e2)
-            {
-
-                // Now we are really in trouble.
-                // very bad, definitely very bad...not going to get very far
-                throw new MissingResourceException(
-                    "Could not load any resource bundles." + m_resourceBundleName,
-                    m_resourceBundleName,
-                    "");
-            }
-        }
-        m_resourceBundle = lrb;
-        return lrb;
-    }
-
-    /**
-     * Return the resource file suffic for the indicated locale
-     * For most locales, this will be based the language code.  However
-     * for Chinese, we do distinguish between Taiwan and PRC
-     *
-     * @param locale the locale
-     * @return an String suffix which can be appended to a resource name
-     * @xsl.usage internal
-     */
-    private static String getResourceSuffix(Locale locale)
-    {
-
-        String suffix = "_" + locale.getLanguage();
-        String country = locale.getCountry();
-
-        if (country.equals("TW"))
-            suffix += "_" + country;
-
-        return suffix;
-    }
 }
--- jaxp/src/com/sun/org/apache/xml/internal/utils/TreeWalker.java	2012-08-10 09:38:11.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/utils/TreeWalker.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,7 @@
  */
 package com.sun.org.apache.xml.internal.utils;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import java.io.File;
 
 import org.w3c.dom.Comment;
@@ -93,7 +94,7 @@
     else {
         try {
           // Bug see Bugzilla  26741
-          m_locator.setSystemId(System.getProperty("user.dir") + File.separator + "dummy.xsl");
+          m_locator.setSystemId(SecuritySupport.getSystemProperty("user.dir") + File.separator + "dummy.xsl");
          }
          catch (SecurityException se) {// user.dir not accessible from applet
          }
@@ -112,7 +113,7 @@
     m_contentHandler.setDocumentLocator(m_locator);
     try {
        // Bug see Bugzilla  26741
-      m_locator.setSystemId(System.getProperty("user.dir") + File.separator + "dummy.xsl");
+      m_locator.setSystemId(SecuritySupport.getSystemProperty("user.dir") + File.separator + "dummy.xsl");
     }
     catch (SecurityException se){// user.dir not accessible from applet
     }
@@ -131,7 +132,7 @@
                         m_contentHandler.setDocumentLocator(m_locator);
                 try {
                    // Bug see Bugzilla  26741
-                  m_locator.setSystemId(System.getProperty("user.dir") + File.separator + "dummy.xsl");
+                  m_locator.setSystemId(SecuritySupport.getSystemProperty("user.dir") + File.separator + "dummy.xsl");
                 }
                 catch (SecurityException se){// user.dir not accessible from applet
 
--- jaxp/src/com/sun/org/apache/xml/internal/utils/res/XResourceBundle.java	2012-08-10 09:38:12.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xml/internal/utils/res/XResourceBundle.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,6 +22,8 @@
  */
 package com.sun.org.apache.xml.internal.utils.res;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ListResourceBundle;
 import java.util.Locale;
 import java.util.MissingResourceException;
@@ -29,114 +31,45 @@
 
 /**
  * The default (english) resource bundle.
+ *
  * @xsl.usage internal
  */
-public class XResourceBundle extends ListResourceBundle
-{
+public class XResourceBundle extends ListResourceBundle {
 
-  /** Error resource constants */
-  public static final String ERROR_RESOURCES =
-    "com.sun.org.apache.xalan.internal.res.XSLTErrorResources", XSLT_RESOURCE =
-    "com.sun.org.apache.xml.internal.utils.res.XResourceBundle", LANG_BUNDLE_NAME =
-    "com.sun.org.apache.xml.internal.utils.res.XResources", MULT_ORDER =
-    "multiplierOrder", MULT_PRECEDES = "precedes", MULT_FOLLOWS =
-    "follows", LANG_ORIENTATION = "orientation", LANG_RIGHTTOLEFT =
-    "rightToLeft", LANG_LEFTTORIGHT = "leftToRight", LANG_NUMBERING =
-    "numbering", LANG_ADDITIVE = "additive", LANG_MULT_ADD =
-    "multiplicative-additive", LANG_MULTIPLIER =
-    "multiplier", LANG_MULTIPLIER_CHAR =
-    "multiplierChar", LANG_NUMBERGROUPS = "numberGroups", LANG_NUM_TABLES =
-    "tables", LANG_ALPHABET = "alphabet", LANG_TRAD_ALPHABET = "tradAlphabet";
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @param locale the locale to prefer when searching for the bundle
-   */
-  public static final XResourceBundle loadResourceBundle(
-          String className, Locale locale) throws MissingResourceException
-  {
-
-    String suffix = getResourceSuffix(locale);
-
-    //System.out.println("resource " + className + suffix);
-    try
-    {
-
-      // first try with the given locale
-      String resourceName = className + suffix;
-      return (XResourceBundle) ResourceBundle.getBundle(resourceName, locale);
+    /**
+     * Error resource constants
+     */
+    public static final String ERROR_RESOURCES =
+            "com.sun.org.apache.xalan.internal.res.XSLTErrorResources", XSLT_RESOURCE =
+            "com.sun.org.apache.xml.internal.utils.res.XResourceBundle", LANG_BUNDLE_NAME =
+            "com.sun.org.apache.xml.internal.utils.res.XResources", MULT_ORDER =
+            "multiplierOrder", MULT_PRECEDES = "precedes", MULT_FOLLOWS =
+            "follows", LANG_ORIENTATION = "orientation", LANG_RIGHTTOLEFT =
+            "rightToLeft", LANG_LEFTTORIGHT = "leftToRight", LANG_NUMBERING =
+            "numbering", LANG_ADDITIVE = "additive", LANG_MULT_ADD =
+            "multiplicative-additive", LANG_MULTIPLIER =
+            "multiplier", LANG_MULTIPLIER_CHAR =
+            "multiplierChar", LANG_NUMBERGROUPS = "numberGroups", LANG_NUM_TABLES =
+            "tables", LANG_ALPHABET = "alphabet", LANG_TRAD_ALPHABET = "tradAlphabet";
+
+
+    /**
+     * Get the association list.
+     *
+     * @return The association list.
+     */
+    public Object[][] getContents() {
+        return new Object[][]{
+                    {"ui_language", "en"}, {"help_language", "en"}, {"language", "en"},
+                    {"alphabet", new CharArrayWrapper(new char[]{'A', 'B', 'C', 'D', 'E', 'F', 'G',
+                            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
+                            'V', 'W', 'X', 'Y', 'Z'})},
+                    {"tradAlphabet", new CharArrayWrapper(new char[]{'A', 'B', 'C', 'D', 'E', 'F',
+                            'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
+                            'U', 'V', 'W', 'X', 'Y', 'Z'})},
+                    //language orientation
+                    {"orientation", "LeftToRight"},
+                    //language numbering
+                    {"numbering", "additive"},};
     }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XResourceBundle) ResourceBundle.getBundle(
-          XSLT_RESOURCE, new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String lang = locale.getLanguage();
-    String country = locale.getCountry();
-    String variant = locale.getVariant();
-    String suffix = "_" + locale.getLanguage();
-
-    if (lang.equals("zh"))
-      suffix += "_" + country;
-
-    if (country.equals("JP"))
-      suffix += "_" + country + "_" + variant;
-
-    return suffix;
-  }
-
-  /**
-   * Get the association list.
-   *
-   * @return The association list.
-   */
-  public Object[][] getContents()
-  {
-    return new Object[][]
-  {
-    { "ui_language", "en" }, { "help_language", "en" }, { "language", "en" },
-    { "alphabet", new CharArrayWrapper(new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G',
-         'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
-         'V', 'W', 'X', 'Y', 'Z' })},
-    { "tradAlphabet", new CharArrayWrapper(new char[]{ 'A', 'B', 'C', 'D', 'E', 'F',
-         'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
-         'U', 'V', 'W', 'X', 'Y', 'Z' }) },
-
-    //language orientation
-    { "orientation", "LeftToRight" },
-
-    //language numbering
-    { "numbering", "additive" },
-  };
-  }
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/functions/FuncSystemProperty.java	2012-08-10 09:38:25.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/functions/FuncSystemProperty.java	2013-05-05 09:39:20.000000000 -0700
@@ -102,7 +102,7 @@
 
         try
         {
-          result = System.getProperty(propName);
+          result = SecuritySupport.getSystemProperty(propName);
 
           if (null == result)
           {
@@ -124,7 +124,7 @@
     {
       try
       {
-        result = System.getProperty(fullName);
+        result = SecuritySupport.getSystemProperty(fullName);
 
         if (null == result)
         {
@@ -170,7 +170,6 @@
     try
     {
       // Use SecuritySupport class to provide priveleged access to property file
-
       InputStream is = SecuritySupport.getResourceAsStream(ObjectFactory.findClassLoader(),
                                               file);
 
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources.java	2012-08-10 09:38:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_de.java	2012-08-10 09:38:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_de.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_es.java	2012-08-10 09:38:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_es.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_fr.java	2012-08-10 09:38:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_fr.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_it.java	2012-08-10 09:38:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_it.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_ja.java	2012-08-10 09:38:31.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_ja.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_ko.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_ko.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_pt_BR.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_pt_BR.java	2013-05-05 09:39:20.000000000 -0700
@@ -24,9 +24,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -940,68 +937,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_sv.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_sv.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_zh_CN.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_zh_CN.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_zh_TW.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHErrorResources_zh_TW.java	2013-05-05 09:39:20.000000000 -0700
@@ -23,9 +23,6 @@
 package com.sun.org.apache.xpath.internal.res;
 
 import java.util.ListResourceBundle;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
 
 /**
  * Set up error messages.
@@ -939,68 +936,4 @@
   /** Field QUERY_HEADER          */
   public static final String QUERY_HEADER = "PATTERN ";
 
-
-  /**
-   * Return a named ResourceBundle for a particular locale.  This method mimics the behavior
-   * of ResourceBundle.getBundle().
-   *
-   * @param className Name of local-specific subclass.
-   * @return the ResourceBundle
-   * @throws MissingResourceException
-   */
-  public static final XPATHErrorResources loadResourceBundle(String className)
-          throws MissingResourceException
-  {
-
-    Locale locale = Locale.getDefault();
-    String suffix = getResourceSuffix(locale);
-
-    try
-    {
-
-      // first try with the given locale
-      return (XPATHErrorResources) ResourceBundle.getBundle(className
-              + suffix, locale);
-    }
-    catch (MissingResourceException e)
-    {
-      try  // try to fall back to en_US if we can't load
-      {
-
-        // Since we can't find the localized property file,
-        // fall back to en_US.
-        return (XPATHErrorResources) ResourceBundle.getBundle(className,
-                new Locale("en", "US"));
-      }
-      catch (MissingResourceException e2)
-      {
-
-        // Now we are really in trouble.
-        // very bad, definitely very bad...not going to get very far
-        throw new MissingResourceException(
-          "Could not load any resource bundles.", className, "");
-      }
-    }
-  }
-
-  /**
-   * Return the resource file suffic for the indicated locale
-   * For most locales, this will be based the language code.  However
-   * for Chinese, we do distinguish between Taiwan and PRC
-   *
-   * @param locale the locale
-   * @return an String suffix which canbe appended to a resource name
-   */
-  private static final String getResourceSuffix(Locale locale)
-  {
-
-    String suffix = "_" + locale.getLanguage();
-    String country = locale.getCountry();
-
-    if (country.equals("TW"))
-      suffix += "_" + country;
-
-    return suffix;
-  }
-
 }
--- jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHMessages.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/org/apache/xpath/internal/res/XPATHMessages.java	2013-05-05 09:39:20.000000000 -0700
@@ -22,130 +22,128 @@
  */
 package com.sun.org.apache.xpath.internal.res;
 
-import java.util.ListResourceBundle;
-
+import com.sun.org.apache.bcel.internal.util.SecuritySupport;
 import com.sun.org.apache.xml.internal.res.XMLMessages;
+import java.util.ListResourceBundle;
 
 /**
  * A utility class for issuing XPath error messages.
+ *
  * @xsl.usage internal
  */
-public class XPATHMessages extends XMLMessages
-{
-  /** The language specific resource object for XPath messages.  */
-  private static ListResourceBundle XPATHBundle = null;
-
-  /** The class name of the XPath error message string table.     */
-  private static final String XPATH_ERROR_RESOURCES =
-    "com.sun.org.apache.xpath.internal.res.XPATHErrorResources";
-
-  /**
-   * Creates a message from the specified key and replacement
-   * arguments, localized to the given locale.
-   *
-   * @param msgKey    The key for the message text.
-   * @param args      The arguments to be used as replacement text
-   *                  in the message created.
-   *
-   * @return The formatted message string.
-   */
-  public static final String createXPATHMessage(String msgKey, Object args[])  //throws Exception
-  {
-    if (XPATHBundle == null)
-      XPATHBundle = loadResourceBundle(XPATH_ERROR_RESOURCES);
+public class XPATHMessages extends XMLMessages {
 
-    if (XPATHBundle != null)
+    /**
+     * The language specific resource object for XPath messages.
+     */
+    private static ListResourceBundle XPATHBundle = null;
+    /**
+     * The class name of the XPath error message string table.
+     */
+    private static final String XPATH_ERROR_RESOURCES =
+            "com.sun.org.apache.xpath.internal.res.XPATHErrorResources";
+
+    /**
+     * Creates a message from the specified key and replacement arguments,
+     * localized to the given locale.
+     *
+     * @param msgKey The key for the message text.
+     * @param args The arguments to be used as replacement text in the message
+     * created.
+     *
+     * @return The formatted message string.
+     */
+    public static final String createXPATHMessage(String msgKey, Object args[]) //throws Exception
     {
-      return createXPATHMsg(XPATHBundle, msgKey, args);
-    }
-    else
-      return "Could not load any resource bundles.";
-  }
-
-  /**
-   * Creates a message from the specified key and replacement
-   * arguments, localized to the given locale.
-   *
-   * @param msgKey The key for the message text.
-   * @param args      The arguments to be used as replacement text
-   *                  in the message created.
-   *
-   * @return The formatted warning string.
-   */
-  public static final String createXPATHWarning(String msgKey, Object args[])  //throws Exception
-  {
-    if (XPATHBundle == null)
-      XPATHBundle = loadResourceBundle(XPATH_ERROR_RESOURCES);
+        if (XPATHBundle == null) {
+            XPATHBundle = SecuritySupport.getResourceBundle(XPATH_ERROR_RESOURCES);
+        }
 
-    if (XPATHBundle != null)
-    {
-      return createXPATHMsg(XPATHBundle, msgKey, args);
+        if (XPATHBundle != null) {
+            return createXPATHMsg(XPATHBundle, msgKey, args);
+        } else {
+            return "Could not load any resource bundles.";
+        }
     }
-    else
-      return "Could not load any resource bundles.";
-  }
-
-  /**
-   * Creates a message from the specified key and replacement
-   * arguments, localized to the given locale.
-   *
-   * @param fResourceBundle The resource bundle to use.
-   * @param msgKey  The message key to use.
-   * @param args      The arguments to be used as replacement text
-   *                  in the message created.
-   *
-   * @return The formatted message string.
-   */
-  public static final String createXPATHMsg(ListResourceBundle fResourceBundle,
-                                            String msgKey, Object args[])  //throws Exception
-  {
-
-    String fmsg = null;
-    boolean throwex = false;
-    String msg = null;
-
-    if (msgKey != null)
-      msg = fResourceBundle.getString(msgKey);
 
-    if (msg == null)
+    /**
+     * Creates a message from the specified key and replacement arguments,
+     * localized to the given locale.
+     *
+     * @param msgKey The key for the message text.
+     * @param args The arguments to be used as replacement text in the message
+     * created.
+     *
+     * @return The formatted warning string.
+     */
+    public static final String createXPATHWarning(String msgKey, Object args[]) //throws Exception
     {
-      msg = fResourceBundle.getString(XPATHErrorResources.BAD_CODE);
-      throwex = true;
+        if (XPATHBundle == null) {
+            XPATHBundle = SecuritySupport.getResourceBundle(XPATH_ERROR_RESOURCES);
+        }
+
+        if (XPATHBundle != null) {
+            return createXPATHMsg(XPATHBundle, msgKey, args);
+        } else {
+            return "Could not load any resource bundles.";
+        }
     }
 
-    if (args != null)
+    /**
+     * Creates a message from the specified key and replacement arguments,
+     * localized to the given locale.
+     *
+     * @param fResourceBundle The resource bundle to use.
+     * @param msgKey The message key to use.
+     * @param args The arguments to be used as replacement text in the message
+     * created.
+     *
+     * @return The formatted message string.
+     */
+    public static final String createXPATHMsg(ListResourceBundle fResourceBundle,
+            String msgKey, Object args[]) //throws Exception
     {
-      try
-      {
 
-        // Do this to keep format from crying.
-        // This is better than making a bunch of conditional
-        // code all over the place.
-        int n = args.length;
-
-        for (int i = 0; i < n; i++)
-        {
-          if (null == args[i])
-            args[i] = "";
-        }
-
-        fmsg = java.text.MessageFormat.format(msg, args);
-      }
-      catch (Exception e)
-      {
-        fmsg = fResourceBundle.getString(XPATHErrorResources.FORMAT_FAILED);
-        fmsg += " " + msg;
-      }
-    }
-    else
-      fmsg = msg;
+        String fmsg = null;
+        boolean throwex = false;
+        String msg = null;
 
-    if (throwex)
-    {
-      throw new RuntimeException(fmsg);
-    }
+        if (msgKey != null) {
+            msg = fResourceBundle.getString(msgKey);
+        }
+
+        if (msg == null) {
+            msg = fResourceBundle.getString(XPATHErrorResources.BAD_CODE);
+            throwex = true;
+        }
 
-    return fmsg;
-  }
+        if (args != null) {
+            try {
 
+                // Do this to keep format from crying.
+                // This is better than making a bunch of conditional
+                // code all over the place.
+                int n = args.length;
+
+                for (int i = 0; i < n; i++) {
+                    if (null == args[i]) {
+                        args[i] = "";
+                    }
+                }
+
+                fmsg = java.text.MessageFormat.format(msg, args);
+            } catch (Exception e) {
+                fmsg = fResourceBundle.getString(XPATHErrorResources.FORMAT_FAILED);
+                fmsg += " " + msg;
+            }
+        } else {
+            fmsg = msg;
+        }
+
+        if (throwex) {
+            throw new RuntimeException(fmsg);
+        }
+
+        return fmsg;
+    }
 }
--- jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java	2012-08-10 09:38:32.000000000 -0700
+++ jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java	2013-05-05 09:39:20.000000000 -0700
@@ -36,6 +36,7 @@
 import com.sun.org.apache.xerces.internal.impl.PropertyManager;
 import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
 import com.sun.org.apache.xerces.internal.impl.Constants;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.util.Enumeration;
 
 /**
@@ -414,7 +415,7 @@
         // get the user.dir property
         String userDir = "";
         try {
-            userDir = System.getProperty("user.dir");
+            userDir = SecuritySupport.getSystemProperty("user.dir");
         }
         catch (SecurityException se) {
         }
--- jaxp/src/com/sun/xml/internal/stream/writers/WriterUtility.java	2012-08-10 09:38:35.000000000 -0700
+++ jaxp/src/com/sun/xml/internal/stream/writers/WriterUtility.java	2013-05-05 09:39:20.000000000 -0700
@@ -32,6 +32,7 @@
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 
 /**
  * Implements common xml writer functions.
@@ -240,7 +241,7 @@
 
     private CharsetEncoder getDefaultEncoder(){
         try{
-            String encoding = System.getProperty("file.encoding");
+            String encoding = SecuritySupport.getSystemProperty("file.encoding");
             if(encoding != null){
                 return Charset.forName(encoding).newEncoder();
             }
--- jaxp/src/com/sun/xml/internal/stream/writers/XMLStreamWriterImpl.java	2012-08-10 09:38:36.000000000 -0700
+++ jaxp/src/com/sun/xml/internal/stream/writers/XMLStreamWriterImpl.java	2013-05-05 09:39:20.000000000 -0700
@@ -53,6 +53,7 @@
 import com.sun.org.apache.xerces.internal.impl.PropertyManager;
 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import com.sun.org.apache.xerces.internal.xni.QName;
 
 import com.sun.xml.internal.stream.util.ReadOnlyIterator;
@@ -340,7 +341,7 @@
                 fEncoder = Charset.forName(encoding).newEncoder();
             }
         } else {
-            encoding = System.getProperty("file.encoding");
+            encoding = SecuritySupport.getSystemProperty("file.encoding");
             if (encoding != null && encoding.equalsIgnoreCase("utf-8")) {
                 fWriter = new UTF8OutputStreamWriter(os);
             } else {
--- jaxp/src/javax/xml/datatype/FactoryFinder.java	2012-08-10 09:38:38.000000000 -0700
+++ jaxp/src/javax/xml/datatype/FactoryFinder.java	2013-05-05 09:39:21.000000000 -0700
@@ -44,6 +44,7 @@
  * @author Santiago.PericasGeertsen@sun.com
  */
 class FactoryFinder {
+    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
 
     /**
      * Internal debug flag.
@@ -95,18 +96,24 @@
      * If the class loader supplied is <code>null</code>, first try using the
      * context class loader followed by the current (i.e. bootstrap) class
      * loader.
+     *
+     * Use bootstrap classLoader if cl = null and useBSClsLoader is true
      */
     static private Class getProviderClass(String className, ClassLoader cl,
-            boolean doFallback) throws ClassNotFoundException
+            boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
     {
         try {
             if (cl == null) {
-                cl = ss.getContextClassLoader();
-                if (cl == null) {
-                    throw new ClassNotFoundException();
-                }
-                else {
-                    return cl.loadClass(className);
+                if (useBSClsLoader) {
+                    return Class.forName(className, true, FactoryFinder.class.getClassLoader());
+                } else {
+                    cl = ss.getContextClassLoader();
+                    if (cl == null) {
+                        throw new ClassNotFoundException();
+                    }
+                    else {
+                        return cl.loadClass(className);
+                    }
                 }
             }
             else {
@@ -131,17 +138,47 @@
      * @param className Name of the concrete class corresponding to the
      * service provider
      *
+     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
+     * current <code>Thread</code>'s context classLoader is used to load the factory class.
+     *
+     * @param doFallback True if the current ClassLoader should be tried as
+     * a fallback if the class is not found using cl
+     */
+    static Object newInstance(String className, ClassLoader cl, boolean doFallback)
+        throws ConfigurationError
+    {
+        return newInstance(className, cl, doFallback, false);
+    }
+
+    /**
+     * Create an instance of a class. Delegates to method
+     * <code>getProviderClass()</code> in order to load the class.
+     *
+     * @param className Name of the concrete class corresponding to the
+     * service provider
+     *
      * @param cl ClassLoader to use to load the class, null means to use
      * the bootstrap ClassLoader
      *
      * @param doFallback True if the current ClassLoader should be tried as
      * a fallback if the class is not found using cl
+     *
+     * @param useBSClsLoader True if cl=null actually meant bootstrap classLoader. This parameter
+     * is needed since DocumentBuilderFactory/SAXParserFactory defined null as context classLoader.
      */
-    static Object newInstance(String className, ClassLoader cl, boolean doFallback)
+    static Object newInstance(String className, ClassLoader cl, boolean doFallback, boolean useBSClsLoader)
         throws ConfigurationError
     {
+        // make sure we have access to restricted packages
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                cl = null;
+                useBSClsLoader = true;
+            }
+        }
+
         try {
-            Class providerClass = getProviderClass(className, cl, doFallback);
+            Class providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
             Object instance = providerClass.newInstance();
             if (debug) {    // Extra check to avoid computing cl strings
                 dPrint("created new instance of " + providerClass +
@@ -244,6 +281,7 @@
 
         // First try the Context ClassLoader
         ClassLoader cl = ss.getContextClassLoader();
+        boolean useBSClsLoader = false;
         if (cl != null) {
             is = ss.getResourceAsStream(cl, serviceId);
 
@@ -251,11 +289,13 @@
             if (is == null) {
                 cl = FactoryFinder.class.getClassLoader();
                 is = ss.getResourceAsStream(cl, serviceId);
+                useBSClsLoader = true;
             }
         } else {
             // No Context ClassLoader, try the current ClassLoader
             cl = FactoryFinder.class.getClassLoader();
             is = ss.getResourceAsStream(cl, serviceId);
+            useBSClsLoader = true;
         }
 
         if (is == null) {
@@ -293,7 +333,7 @@
             // ClassLoader because we want to avoid the case where the
             // resource file was found using one ClassLoader and the
             // provider class was instantiated using a different one.
-            return newInstance(factoryClassName, cl, false);
+            return newInstance(factoryClassName, cl, false, useBSClsLoader);
         }
 
         // No provider found
--- jaxp/src/javax/xml/parsers/FactoryFinder.java	2012-08-10 09:38:39.000000000 -0700
+++ jaxp/src/javax/xml/parsers/FactoryFinder.java	2013-05-05 09:39:21.000000000 -0700
@@ -42,7 +42,7 @@
  * @author Huizhe.Wang@oracle.com
  */
 class FactoryFinder {
-
+    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
     /**
      * Internal debug flag.
      */
@@ -166,6 +166,14 @@
     static Object newInstance(String className, ClassLoader cl, boolean doFallback, boolean useBSClsLoader)
         throws ConfigurationError
     {
+        // make sure we have access to restricted packages
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                cl = null;
+                useBSClsLoader = true;
+            }
+        }
+
         try {
             Class providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
             Object instance = providerClass.newInstance();
--- jaxp/src/javax/xml/stream/FactoryFinder.java	2012-08-10 09:38:41.000000000 -0700
+++ jaxp/src/javax/xml/stream/FactoryFinder.java	2013-05-05 09:39:21.000000000 -0700
@@ -25,14 +25,12 @@
 
 package javax.xml.stream;
 
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.File;
-import java.io.FileInputStream;
-
-import java.util.Properties;
 import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.util.Properties;
 
 /**
  * <p>Implements pluggable Datatypes.</p>
@@ -43,6 +41,8 @@
  * @author Santiago.PericasGeertsen@sun.com
  */
 class FactoryFinder {
+    // Check we have access to package.
+    private static final String DEFAULT_PACKAGE = "com.sun.xml.internal.";
 
     /**
      * Internal debug flag.
@@ -94,18 +94,24 @@
      * If the class loader supplied is <code>null</code>, first try using the
      * context class loader followed by the current (i.e. bootstrap) class
      * loader.
+     *
+     * Use bootstrap classLoader if cl = null and useBSClsLoader is true
      */
     static private Class getProviderClass(String className, ClassLoader cl,
-            boolean doFallback) throws ClassNotFoundException
+            boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
     {
         try {
             if (cl == null) {
-                cl = ss.getContextClassLoader();
-                if (cl == null) {
-                    throw new ClassNotFoundException();
-                }
-                else {
-                    return cl.loadClass(className);
+                if (useBSClsLoader) {
+                    return Class.forName(className, true, FactoryFinder.class.getClassLoader());
+                } else {
+                    cl = ss.getContextClassLoader();
+                    if (cl == null) {
+                        throw new ClassNotFoundException();
+                    }
+                    else {
+                        return cl.loadClass(className);
+                    }
                 }
             }
             else {
@@ -130,8 +136,8 @@
      * @param className Name of the concrete class corresponding to the
      * service provider
      *
-     * @param cl ClassLoader to use to load the class, null means to use
-     * the bootstrap ClassLoader
+     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
+     * current <code>Thread</code>'s context classLoader is used to load the factory class.
      *
      * @param doFallback True if the current ClassLoader should be tried as
      * a fallback if the class is not found using cl
@@ -139,8 +145,38 @@
     static Object newInstance(String className, ClassLoader cl, boolean doFallback)
         throws ConfigurationError
     {
+        return newInstance(className, cl, doFallback, false);
+    }
+
+    /**
+     * Create an instance of a class. Delegates to method
+     * <code>getProviderClass()</code> in order to load the class.
+     *
+     * @param className Name of the concrete class corresponding to the
+     * service provider
+     *
+     * @param cl <code>ClassLoader</code> used to load the factory class. If <code>null</code>
+     * current <code>Thread</code>'s context classLoader is used to load the factory class.
+     *
+     * @param doFallback True if the current ClassLoader should be tried as
+     * a fallback if the class is not found using cl
+     *
+     * @param useBSClsLoader True if cl=null actually meant bootstrap classLoader. This parameter
+     * is needed since DocumentBuilderFactory/SAXParserFactory defined null as context classLoader.
+     */
+    static Object newInstance(String className, ClassLoader cl, boolean doFallback, boolean useBSClsLoader)
+        throws ConfigurationError
+    {
+        // make sure we have access to restricted packages
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                cl = null;
+                useBSClsLoader = true;
+            }
+        }
+
         try {
-            Class providerClass = getProviderClass(className, cl, doFallback);
+            Class providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
             Object instance = providerClass.newInstance();
             if (debug) {    // Extra check to avoid computing cl strings
                 dPrint("created new instance of " + providerClass +
@@ -233,11 +269,11 @@
                             if (ss.doesFileExist(f)) {
                                 dPrint("Read properties file "+f);
                                 cacheProps.load(ss.getFileInputStream(f));
-                            }
-                        }
                     }
                 }
             }
+                }
+            }
             factoryClassName = cacheProps.getProperty(factoryId);
 
             if (factoryClassName != null) {
@@ -276,6 +312,7 @@
 
         // First try the Context ClassLoader
         ClassLoader cl = ss.getContextClassLoader();
+        boolean useBSClsLoader = false;
         if (cl != null) {
             is = ss.getResourceAsStream(cl, serviceId);
 
@@ -283,11 +320,13 @@
             if (is == null) {
                 cl = FactoryFinder.class.getClassLoader();
                 is = ss.getResourceAsStream(cl, serviceId);
+                useBSClsLoader = true;
             }
         } else {
             // No Context ClassLoader, try the current ClassLoader
             cl = FactoryFinder.class.getClassLoader();
             is = ss.getResourceAsStream(cl, serviceId);
+            useBSClsLoader = true;
         }
 
         if (is == null) {
@@ -325,7 +364,7 @@
             // ClassLoader because we want to avoid the case where the
             // resource file was found using one ClassLoader and the
             // provider class was instantiated using a different one.
-            return newInstance(factoryClassName, cl, false);
+            return newInstance(factoryClassName, cl, false, useBSClsLoader);
         }
 
         // No provider found
--- jaxp/src/javax/xml/transform/FactoryFinder.java	2012-08-10 09:38:44.000000000 -0700
+++ jaxp/src/javax/xml/transform/FactoryFinder.java	2013-05-05 09:39:21.000000000 -0700
@@ -43,6 +43,7 @@
  * @author Huizhe.Wang@oracle.com
  */
 class FactoryFinder {
+    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xalan.internal.";
 
     /**
      * Internal debug flag.
@@ -169,6 +170,14 @@
     static Object newInstance(String className, ClassLoader cl, boolean doFallback, boolean useBSClsLoader, boolean useServicesMechanism)
         throws ConfigurationError
     {
+        // make sure we have access to restricted packages
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                cl = null;
+                useBSClsLoader = true;
+            }
+        }
+
         try {
             Class providerClass = getProviderClass(className, cl, doFallback, useBSClsLoader);
             Object instance = null;
@@ -210,7 +219,7 @@
                 providerClass.getDeclaredMethod(
                     "newTransformerFactoryNoServiceLoader"
                 );
-                return creationMethod.invoke(null, null);
+                return creationMethod.invoke(null, (Object[])null);
             } catch (NoSuchMethodException exc) {
                 return null;
             } catch (Exception exc) {
--- jaxp/src/javax/xml/validation/SchemaFactoryFinder.java	2012-08-10 09:38:49.000000000 -0700
+++ jaxp/src/javax/xml/validation/SchemaFactoryFinder.java	2013-05-05 09:39:21.000000000 -0700
@@ -54,6 +54,7 @@
      *<p> Take care of restrictions imposed by java security model </p>
      */
     private static SecuritySupport ss = new SecuritySupport();
+    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
     /**
      * <p>Cache properties for performance.</p>
      */
@@ -213,28 +214,6 @@
             }
         }
 
-        /**
-        // try to read from $java.home/lib/jaxp.properties
-        try {
-            String javah = ss.getSystemProperty( "java.home" );
-            String configFile = javah + File.separator +
-            "lib" + File.separator + "jaxp.properties";
-            File f = new File( configFile );
-            if( ss.doesFileExist(f)) {
-                sf = loadFromProperty(
-                        propertyName,f.getAbsolutePath(), new FileInputStream(f));
-                if(sf!=null)    return sf;
-            } else {
-                debugPrintln("Tried to read "+ f.getAbsolutePath()+", but it doesn't exist.");
-            }
-        } catch(Throwable e) {
-            if( debug ) {
-                debugPrintln("failed to read $java.home/lib/jaxp.properties");
-                e.printStackTrace();
-            }
-        }
-         */
-
         // try META-INF/services files
         Iterator sitr = createServiceFileIterator();
         while(sitr.hasNext()) {
@@ -269,14 +248,20 @@
      */
     private Class createClass(String className) {
             Class clazz;
+        // make sure we have access to restricted packages
+        boolean internal = false;
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                internal = true;
+            }
+        }
 
-            // use approprite ClassLoader
             try {
-                    if (classLoader != null) {
-                            clazz = classLoader.loadClass(className);
-                    } else {
-                            clazz = Class.forName(className);
-                    }
+                if (classLoader != null && !internal) {
+                        clazz = classLoader.loadClass(className);
+                } else {
+                        clazz = Class.forName(className);
+                }
             } catch (Throwable t) {
                 if(debug)   t.printStackTrace();
                     return null;
@@ -357,7 +342,7 @@
                 providerClass.getDeclaredMethod(
                     "newXMLSchemaFactoryNoServiceLoader"
                 );
-                return creationMethod.invoke(null, null);
+                return creationMethod.invoke(null, (Object[])null);
             } catch (NoSuchMethodException exc) {
                 return null;
             } catch (Exception exc) {
--- jaxp/src/javax/xml/xpath/XPathFactoryFinder.java	2012-08-10 09:38:54.000000000 -0700
+++ jaxp/src/javax/xml/xpath/XPathFactoryFinder.java	2013-05-05 09:39:20.000000000 -0700
@@ -48,6 +48,7 @@
  * @since 1.5
  */
 class XPathFactoryFinder  {
+    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xpath.internal";
 
     private static SecuritySupport ss = new SecuritySupport() ;
     /** debug support code. */
@@ -246,18 +247,25 @@
      */
     private Class createClass(String className) {
             Class clazz;
+        // make sure we have access to restricted packages
+        boolean internal = false;
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                internal = true;
+            }
+        }
 
-            // use approprite ClassLoader
-            try {
-                    if (classLoader != null) {
-                            clazz = classLoader.loadClass(className);
-                    } else {
-                            clazz = Class.forName(className);
-                    }
-            } catch (Throwable t) {
-                if(debug)   t.printStackTrace();
-                    return null;
+        // use approprite ClassLoader
+        try {
+            if (classLoader != null && !internal) {
+                    clazz = classLoader.loadClass(className);
+            } else {
+                    clazz = Class.forName(className);
             }
+        } catch (Throwable t) {
+            if(debug)   t.printStackTrace();
+                return null;
+        }
 
             return clazz;
     }
@@ -333,7 +341,7 @@
                 providerClass.getDeclaredMethod(
                     "newXPathFactoryNoServiceLoader"
                 );
-                return creationMethod.invoke(null, null);
+                return creationMethod.invoke(null, (Object[])null);
             } catch (NoSuchMethodException exc) {
                 return null;
             } catch (Exception exc) {
--- jaxp/src/org/w3c/dom/bootstrap/DOMImplementationRegistry.java	2012-08-10 09:38:59.000000000 -0700
+++ jaxp/src/org/w3c/dom/bootstrap/DOMImplementationRegistry.java	2013-05-05 09:39:21.000000000 -0700
@@ -104,6 +104,8 @@
      */
     private static final String FALLBACK_CLASS =
             "com.sun.org.apache.xerces.internal.dom.DOMXSImplementationSourceImpl";
+    private static final String DEFAULT_PACKAGE =
+            "com.sun.org.apache.xerces.internal.dom";
     /**
      * Private constructor.
      * @param srcs Vector List of DOMImplementationSources
@@ -168,10 +170,15 @@
             StringTokenizer st = new StringTokenizer(p);
             while (st.hasMoreTokens()) {
                 String sourceName = st.nextToken();
-                // Use context class loader, falling back to Class.forName
-                // if and only if this fails...
+                // make sure we have access to restricted packages
+                boolean internal = false;
+                if (System.getSecurityManager() != null) {
+                    if (sourceName != null && sourceName.startsWith(DEFAULT_PACKAGE)) {
+                        internal = true;
+                    }
+                }
                 Class sourceClass = null;
-                if (classLoader != null) {
+                if (classLoader != null && !internal) {
                     sourceClass = classLoader.loadClass(sourceName);
                 } else {
                     sourceClass = Class.forName(sourceName);
--- jaxp/src/org/xml/sax/helpers/NewInstance.java	2012-08-10 09:39:17.000000000 -0700
+++ jaxp/src/org/xml/sax/helpers/NewInstance.java	2013-05-05 09:39:21.000000000 -0700
@@ -54,9 +54,10 @@
  * including versions of Java 2.</p>
  *
  * @author Edwin Goei, David Brownell
+ * @version 2.0.1 (sax2r2)
  */
 class NewInstance {
-
+    private static final String DEFAULT_PACKAGE = "com.sun.org.apache.xerces.internal";
     /**
      * Creates a new instance of the specified class name
      *
@@ -66,8 +67,16 @@
         throws ClassNotFoundException, IllegalAccessException,
             InstantiationException
     {
+        // make sure we have access to restricted packages
+        boolean internal = false;
+        if (System.getSecurityManager() != null) {
+            if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
+                internal = true;
+            }
+        }
+
         Class driverClass;
-        if (classLoader == null) {
+        if (classLoader == null || internal) {
             driverClass = Class.forName(className);
         } else {
             driverClass = classLoader.loadClass(className);
@@ -75,29 +84,4 @@
         return driverClass.newInstance();
     }
 
-    /**
-     * Figure out which ClassLoader to use.  For JDK 1.2 and later use
-     * the context ClassLoader.
-     */
-    static ClassLoader getClassLoader ()
-    {
-        Method m = null;
-
-        try {
-            m = Thread.class.getMethod("getContextClassLoader", (Class[]) null);
-        } catch (NoSuchMethodException e) {
-            // Assume that we are running JDK 1.1, use the current ClassLoader
-            return NewInstance.class.getClassLoader();
-        }
-
-        try {
-            return (ClassLoader) m.invoke(Thread.currentThread(), (Object[]) null);
-        } catch (IllegalAccessException e) {
-            // assert(false)
-            throw new UnknownError(e.getMessage());
-        } catch (InvocationTargetException e) {
-            // assert(e.getTargetException() instanceof SecurityException)
-            throw new UnknownError(e.getMessage());
-        }
-    }
 }
--- jaxp/src/org/xml/sax/helpers/ParserAdapter.java	2012-08-10 09:39:17.000000000 -0700
+++ jaxp/src/org/xml/sax/helpers/ParserAdapter.java	2013-05-05 09:39:21.000000000 -0700
@@ -74,13 +74,14 @@
  *
  * @since SAX 2.0
  * @author David Megginson
+ * @version 2.0.1 (sax2r2)
  * @see org.xml.sax.helpers.XMLReaderAdapter
  * @see org.xml.sax.XMLReader
  * @see org.xml.sax.Parser
  */
 public class ParserAdapter implements XMLReader, DocumentHandler
 {
-
+    private static SecuritySupport ss = new SecuritySupport();
 
     ////////////////////////////////////////////////////////////////////
     // Constructors.
@@ -102,7 +103,7 @@
     {
         super();
 
-        String driver = System.getProperty("org.xml.sax.parser");
+        String driver = ss.getSystemProperty("org.xml.sax.parser");
 
         try {
             setup(ParserFactory.makeParser());
--- jaxp/src/org/xml/sax/helpers/ParserFactory.java	2012-08-10 09:39:17.000000000 -0700
+++ jaxp/src/org/xml/sax/helpers/ParserFactory.java	2013-05-05 09:39:21.000000000 -0700
@@ -30,12 +30,6 @@
 
 package org.xml.sax.helpers;
 
-import java.lang.ClassNotFoundException;
-import java.lang.IllegalAccessException;
-import java.lang.InstantiationException;
-import java.lang.SecurityException;
-import java.lang.ClassCastException;
-
 import org.xml.sax.Parser;
 
 
@@ -69,9 +63,10 @@
  *             interface.
  * @since SAX 1.0
  * @author David Megginson
+ * @version 2.0.1 (sax2r2)
  */
 public class ParserFactory {
-
+    private static SecuritySupport ss = new SecuritySupport();
 
     /**
      * Private null constructor.
@@ -109,7 +104,7 @@
         NullPointerException,
         ClassCastException
     {
-        String className = System.getProperty("org.xml.sax.parser");
+        String className = ss.getSystemProperty("org.xml.sax.parser");
         if (className == null) {
             throw new NullPointerException("No value for sax.parser property");
         } else {
@@ -146,7 +141,7 @@
         ClassCastException
     {
         return (Parser) NewInstance.newInstance (
-                NewInstance.getClassLoader (), className);
+                ss.getContextClassLoader(), className);
     }
 
 }
--- jaxp/src/org/xml/sax/helpers/SecuritySupport.java	1969-12-31 16:00:00.000000000 -0800
+++ jaxp/src/org/xml/sax/helpers/SecuritySupport.java	2013-05-05 09:39:21.000000000 -0700
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2004, 2006, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package org.xml.sax.helpers;
+
+import java.io.*;
+import java.security.*;
+
+/**
+ * This class is duplicated for each JAXP subpackage so keep it in sync.
+ * It is package private and therefore is not exposed as part of the JAXP
+ * API.
+ *
+ * Security related methods that only work on J2SE 1.2 and newer.
+ */
+class SecuritySupport  {
+
+
+    ClassLoader getContextClassLoader() throws SecurityException{
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                ClassLoader cl = null;
+                //try {
+                cl = Thread.currentThread().getContextClassLoader();
+                //} catch (SecurityException ex) { }
+
+                if (cl == null)
+                    cl = ClassLoader.getSystemClassLoader();
+
+                return cl;
+            }
+        });
+    }
+
+    String getSystemProperty(final String propName) {
+        return (String)
+            AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    return System.getProperty(propName);
+                }
+            });
+    }
+
+    FileInputStream getFileInputStream(final File file)
+        throws FileNotFoundException
+    {
+        try {
+            return (FileInputStream)
+                AccessController.doPrivileged(new PrivilegedExceptionAction() {
+                    public Object run() throws FileNotFoundException {
+                        return new FileInputStream(file);
+                    }
+                });
+        } catch (PrivilegedActionException e) {
+            throw (FileNotFoundException)e.getException();
+        }
+    }
+
+    InputStream getResourceAsStream(final ClassLoader cl,
+                                           final String name)
+    {
+        return (InputStream)
+            AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    InputStream ris;
+                    if (cl == null) {
+                        ris = Object.class.getResourceAsStream(name);
+                    } else {
+                        ris = cl.getResourceAsStream(name);
+                    }
+                    return ris;
+                }
+            });
+    }
+
+    boolean doesFileExist(final File f) {
+    return ((Boolean)
+            AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    return new Boolean(f.exists());
+                }
+            })).booleanValue();
+    }
+
+}
--- jaxp/src/org/xml/sax/helpers/XMLReaderFactory.java	2012-08-10 09:39:17.000000000 -0700
+++ jaxp/src/org/xml/sax/helpers/XMLReaderFactory.java	2013-05-05 09:39:21.000000000 -0700
@@ -34,8 +34,6 @@
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import org.xml.sax.XMLReader;
 import org.xml.sax.SAXException;
 
@@ -85,8 +83,8 @@
     }
 
     private static final String property = "org.xml.sax.driver";
+    private static SecuritySupport ss = new SecuritySupport();
 
-    private static String _clsFromJar = null;
     private static boolean _jarread = false;
     /**
      * Attempt to create an XMLReader from system defaults.
@@ -134,43 +132,45 @@
         throws SAXException
     {
         String          className = null;
-        ClassLoader     loader = NewInstance.getClassLoader ();
+        ClassLoader     cl = ss.getContextClassLoader();
 
         // 1. try the JVM-instance-wide system property
-        try { className = System.getProperty (property); }
-        catch (RuntimeException e) { /* normally fails for applets */ }
+        try {
+            className = ss.getSystemProperty(property);
+        }
+        catch (RuntimeException e) { /* continue searching */ }
 
         // 2. if that fails, try META-INF/services/
         if (className == null) {
             if (!_jarread) {
-                final ClassLoader       loader1 = loader;
                 _jarread = true;
-                _clsFromJar =  (String)
-                AccessController.doPrivileged(new PrivilegedAction() {
-                    public Object run() {
-                        String clsName = null;
-                        try {
-                            String      service = "META-INF/services/" + property;
-                            InputStream in;
-                            BufferedReader      reader;
-                            if (loader1 == null)
-                                in = ClassLoader.getSystemResourceAsStream (service);
-                            else
-                                in = loader1.getResourceAsStream (service);
-
-                            if (in != null) {
-                                reader = new BufferedReader (
-                                        new InputStreamReader (in, "UTF8"));
-                                clsName = reader.readLine ();
-                                in.close ();
-                            }
-                        } catch (Exception e) {
+                String      service = "META-INF/services/" + property;
+                InputStream in;
+                BufferedReader      reader;
+
+                try {
+                    if (cl != null) {
+                        in = ss.getResourceAsStream(cl, service);
+
+                        // If no provider found then try the current ClassLoader
+                        if (in == null) {
+                            cl = null;
+                            in = ss.getResourceAsStream(cl, service);
                         }
-                        return clsName;
+                    } else {
+                        // No Context ClassLoader, try the current ClassLoader
+                        in = ss.getResourceAsStream(cl, service);
+                    }
+
+                    if (in != null) {
+                        reader = new BufferedReader (
+                                new InputStreamReader (in, "UTF8"));
+                        className = reader.readLine ();
+                        in.close ();
                     }
-                });
+                } catch (Exception e) {
+                }
             }
-            className = _clsFromJar;
         }
 
         // 3. Distro-specific fallback
@@ -187,7 +187,7 @@
 
         // do we know the XMLReader implementation class yet?
         if (className != null)
-            return loadClass (loader, className);
+            return loadClass (cl, className);
 
         // 4. panic -- adapt any SAX1 parser
         try {
@@ -217,7 +217,7 @@
     public static XMLReader createXMLReader (String className)
         throws SAXException
     {
-        return loadClass (NewInstance.getClassLoader (), className);
+        return loadClass (ss.getContextClassLoader(), className);
     }
 
     private static XMLReader loadClass (ClassLoader loader, String className)
--- jaxws/.hgtags	2012-08-10 09:46:32.000000000 -0700
+++ jaxws/.hgtags	2013-05-05 09:39:34.000000000 -0700
@@ -123,6 +123,7 @@
 05469dd4c3662c454f8a019e492543add60795cc jdk7-b146
 c01bfd68d0528bc88348813c4d75d7f5c62bc4e2 jdk7u1-b01
 d13b1f877bb5ed8dceb2f7ec10365d1db5f70b2d jdk7-b147
+ce6378e3c791c56b98cbf161804a07d0225b41c0 7u0
 4c24f7019ce939a452154a83151294ad7da66a9d jdk7u1-b02
 272778f529d11081f548f37fcd6a7aec0b11a8dd jdk7u1-b03
 48b06a6e6f46e5bcd610f4bed57cd5067cf31f8c jdk7u1-b04
@@ -197,5 +198,69 @@
 55dcda93e8c8b5c3170def946de35dd0407eab59 jdk7u6-b21
 0fec2efe2452aed9736da39add4c7f71be561838 jdk7u6-b22
 afb6d773328fa76cea65dc024a448cd931d111f2 jdk7u6-b23
-55dcda93e8c8b5c3170def946de35dd0407eab59 jdk7u8-b01
-c025e953f655b375f27f8f94493ceeb43ef1d979 jdk7u8-b02
+b8b85e62d2c5347df8cf2e825e51e3de178508ea jdk7u6-b24
+fb03d08f73e98f0dd67cb81632eb9b685de49b7e jdk7u6-b30
+739ffa9dffad4cc2febe66ca1c2d86496e80741a jdk7u6-b31
+739ffa9dffad4cc2febe66ca1c2d86496e80741a jdk7u7-b10
+e9a5a78329d0518efafd9f6f6149f359a7db4e2e jdk7u7-b30
+ed6262e7bb0db4cd116c31f3c88cbd7c0288de40 jdk7u7-b11
+538c248de3ef0fcb34c28295c1eab61269708137 jdk7u7-b31
+dc2e6882056c2d400d4cf3c78d67da8e20fc37cc jdk7u7-b01
+45cf55bc1732e8495425dceb385740c6852c0fc8 jdk7u7-b02
+0289894a64a628133bb63f1dc48b45593f96a14d jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+dc2e6882056c2d400d4cf3c78d67da8e20fc37cc jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+45cf55bc1732e8495425dceb385740c6852c0fc8 jdk7u9-b02
+66a2e01550a9e84e907a7f7b96e64ee90a4ec0e4 jdk7u9-b04
+f3e42e044584b1b21de29eef1b82974d273c77dc jdk7u9-b05
+5e5703e9d18d66d7388057040d3c36e978488dc5 jdk7u9-b31
+987bb65e7b73ad94fb0edecce80d84ee5f8bda6e jdk7u9-b32
+dd8e4098681aa581d0398ad7d2d1e2547517c7e5 jdk7u10-b10
+1784290b63bcf021334b0accdb3868fdc4ca854e jdk7u10-b11
+fde9a060a04d9f9b54f36d645e91ec9a2b40cb81 jdk7u10-b12
+d7bf349cf0c60bc41a33c1f70969f11668deddb3 jdk7u10-b13
+17ec7a59002695c35dbd83a120b705e21d982d68 jdk7u10-b14
+75ecadd1f8fc5a218b1ed71b3c3df776d76e048e jdk7u10-b15
+ed609545e38c2e499437292c1541e4d1c2b8b992 jdk7u10-b16
+e63292c59ed8481864302cc3f53b498cbdea3470 jdk7u10-b17
+6a372e9b4ae978cdaf0b95277db31827794e2c1f jdk7u10-b18
+df3e4c85e26c651d098cddd546916a625fd777cd jdk7u10-b30
+29d469fac9106ce7c2f8656ee125e792908aca98 jdk7u10-b31
+846f4e01218ffe37b2dbceaf89c222c0aea43180 jdk7u11-b20
+1f06394ca182cb392e472ba7b63b28a40725629d jdk7u11-b21
+ac21be8046e06e5460d041b7e4f8140d635887fb jdk7u11-b32
+41abf18b24e9483de775bf938f8d5e673c08209d jdk7u11-b33
+ed609545e38c2e499437292c1541e4d1c2b8b992 jdk7u11-b03
+4e1dd1192649575e80d893bcab411077b77c9a0c jdk7u11-b04
+0e1eefefc2d0c8f0d0cd9e7fb7d78ae026aa8ba0 jdk7u11-b05
+7365410bb417d6a40996920bb4dbb44bdb1225a9 jdk7u11-b06
+66786f9d73c479ce70a306e14dd7f653f5b3a4f9 jdk7u11-b07
+a3cadd00459f1146fdcfa8702bbb29efdcd58960 jdk7u11-b08
+c7ea4220ad61b125bd7c4b7f112dd9ff18e9be33 jdk7u13-b09
+1d2eb88cadaf29bf577a71c69b04afe2468d8ff6 jdk7u13-b10
+21dbdd72a46a29c148ea3519268447c467540637 jdk7u13-b30
+1d2eb88cadaf29bf577a71c69b04afe2468d8ff6 jdk7u13-b20
+abcaebcead605f89cd0919add20d8ac16637ddc2 jdk7u15-b01
+62f9e7f5eb644fedd93dd93bd36bcf817a8d9c8a jdk7u15-b02
+ed9f270009f2b8606e9e0f58aeedbed36e13963e jdk7u15-b30
+297240e69d8ffcf85fc68b12af6523f7ea16397e jdk7u15-b31
+4fda3b01c75ecd80dba505f6152c21f3e1db5cce jdk7u15-b33
+eaf9b299067069826a5acdc88e15402e5a22cb5d jdk7u15-b03
+c7ea4220ad61b125bd7c4b7f112dd9ff18e9be33 jdk7u15-b32
+b8496d1dc0058341da1790bc2e7d2dbba6d4f90e jdk7u17-b01
+defde3ef03605b1660a246ea85d2e810e3fe4f6e jdk7u17-b02
+ae4272d61bc738e2d9265a68aefdc20ec648f22c jdk7u17-b30
+52c4fbd4f58f336dfdf4f680b7e7d7361ec0c3f8 jdk7u17-b31
+e07c518282bad3b315d8064da5fad222a5e3f7ed jdk7u21-b01
+0c1365d2fefb652aea34775749d68774c171ba1a jdk7u21-b02
+017171d6bc217f26e230503dd38bcf4473f339d2 jdk7u21-b03
+68e8364feffcc98b57d59675994dcb12e170ddf0 jdk7u21-b04
+8c43fd5d8cfef4d97bddc4fee7747f23a3c2bffa jdk7u21-b05
+dab51e98ee7d0f3a30b9e18b0d3591b944346868 jdk7u21-b06
+4a9533495068359d574da1060bc5a8fa6946cbc6 jdk7u21-b07
+ab11cef1dfaaec32281dc3d24a366f6691b51b7a jdk7u21-b08
+53c87e8a2ac494b57f6220bd7e25c7380aa7f418 jdk7u21-b09
+29c03ced9215a0bb63a4527dc5858b486cc4099d jdk7u21-b10
+fe6f5b57b9e67a7c6f52a5f926ac17e5c337d4a4 jdk7u21-b11
+12183763c6205c5cfe27924ccc4ca5480106c3b4 jdk7u21-b30
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.java	2012-08-10 09:48:50.000000000 -0700
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.java	2013-05-05 09:39:26.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -235,7 +235,7 @@
                         String pkg = nav.getPackageName(ci.getClazz());
                         if(!registries.containsKey(pkg)) {
                             // insert the package's object factory
-                            C c = nav.findClass(pkg + ".ObjectFactory",ci.getClazz());
+                            C c = loadObjectFactory(ci, pkg);
                             if(c!=null)
                                 addRegistry(c,(Locatable)p);
                         }
@@ -264,6 +264,15 @@
         return r;
     }
 
+    private C loadObjectFactory(ClassInfoImpl<T, C, F, M> ci, String pkg) {
+        try {
+            return nav.findClass(pkg + ".ObjectFactory", ci.getClazz());
+        } catch (SecurityException ignored) {
+            // treat SecurityException in same way as ClassNotFoundException in this case
+            return null;
+        }
+    }
+
     /**
      * Checks the uniqueness of the type name.
      */
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/MemoryData.java	2012-08-10 09:50:08.000000000 -0700
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/MemoryData.java	2013-05-05 09:39:26.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 import java.nio.ByteBuffer;
 import java.io.File;
 import java.io.IOException;
+import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
@@ -50,41 +51,45 @@
     }
 
     // size of the chunk given by the parser
+    @Override
     public int size() {
         return len;
     }
 
+    @Override
     public byte[] read() {
         return data;
     }
 
+    @Override
     public long writeTo(DataFile file) {
         return file.writeTo(data, 0, len);
     }
 
     /**
-     *
      * @param dataHead
      * @param buf
      * @return
      */
+    @Override
     public Data createNext(DataHead dataHead, ByteBuffer buf) {
         if (!config.isOnlyMemory() && dataHead.inMemory >= config.memoryThreshold) {
             try {
                 String prefix = config.getTempFilePrefix();
                 String suffix = config.getTempFileSuffix();
-                File dir = config.getTempDir();
-                File tempFile = (dir == null)
-                        ? File.createTempFile(prefix, suffix)
-                        : File.createTempFile(prefix, suffix, dir);
-                LOGGER.fine("Created temp file = "+tempFile);
+                File tempFile = TempFiles.createTempFile(prefix, suffix, config.getTempDir());
+                // delete the temp file when VM exits as a last resort for file clean up
+                tempFile.deleteOnExit();
+                if (LOGGER.isLoggable(Level.FINE)) {
+                    LOGGER.log(Level.FINE, "Created temp file = {0}", tempFile);
+                }
                 dataHead.dataFile = new DataFile(tempFile);
-            } catch(IOException ioe) {
+            } catch (IOException ioe) {
                 throw new MIMEParsingException(ioe);
             }
 
             if (dataHead.head != null) {
-                for(Chunk c=dataHead.head; c != null; c=c.next) {
+                for (Chunk c = dataHead.head; c != null; c = c.next) {
                     long pointer = c.data.writeTo(dataHead.dataFile);
                     c.data = new FileData(dataHead.dataFile, pointer, len);
                 }
@@ -94,4 +99,5 @@
             return new MemoryData(buf, config);
         }
     }
+
 }
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/TempFiles.java	1969-12-31 16:00:00.000000000 -0800
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/TempFiles.java	2013-05-05 09:39:26.000000000 -0700
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Array;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Helper utility to support jdk <= jdk1.6. After jdk1.6 EOL reflection can be removed and API can be used directly.
+ */
+class TempFiles {
+
+    private static final Logger LOGGER = Logger.getLogger(TempFiles.class.getName());
+
+    private static final Class<?> CLASS_FILES;
+    private static final Class<?> CLASS_PATH;
+    private static final Class<?> CLASS_FILE_ATTRIBUTE;
+    private static final Class<?> CLASS_FILE_ATTRIBUTES;
+    private static final Method METHOD_FILE_TO_PATH;
+    private static final Method METHOD_FILES_CREATE_TEMP_FILE;
+    private static final Method METHOD_FILES_CREATE_TEMP_FILE_WITHPATH;
+
+    private static final Method METHOD_PATH_TO_FILE;
+
+    private static boolean useJdk6API;
+
+    static {
+        useJdk6API = isJdk6();
+
+        CLASS_FILES = safeGetClass("java.nio.file.Files");
+        CLASS_PATH = safeGetClass("java.nio.file.Path");
+        CLASS_FILE_ATTRIBUTE = safeGetClass("java.nio.file.attribute.FileAttribute");
+        CLASS_FILE_ATTRIBUTES = safeGetClass("[Ljava.nio.file.attribute.FileAttribute;");
+        METHOD_FILE_TO_PATH = safeGetMethod(File.class, "toPath");
+        METHOD_FILES_CREATE_TEMP_FILE = safeGetMethod(CLASS_FILES, "createTempFile", String.class, String.class, CLASS_FILE_ATTRIBUTES);
+        METHOD_FILES_CREATE_TEMP_FILE_WITHPATH = safeGetMethod(CLASS_FILES, "createTempFile", CLASS_PATH, String.class, String.class, CLASS_FILE_ATTRIBUTES);
+        METHOD_PATH_TO_FILE = safeGetMethod(CLASS_PATH, "toFile");
+    }
+
+    private static boolean isJdk6() {
+        String javaVersion = System.getProperty("java.version");
+        LOGGER.log(Level.FINEST, "Detected java version = {0}", javaVersion);
+        return javaVersion.startsWith("1.6.");
+    }
+
+    private static Class<?> safeGetClass(String className) {
+        // it is jdk 6 or something failed already before
+        if (useJdk6API) return null;
+        try {
+            return Class.forName(className);
+        } catch (ClassNotFoundException e) {
+            LOGGER.log(Level.SEVERE, "Exception cought", e);
+            LOGGER.log(Level.WARNING, "Class {0} not found. Temp files will be created using old java.io API.", className);
+            useJdk6API = true;
+            return null;
+        }
+    }
+
+    private static Method safeGetMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
+        // it is jdk 6 or something failed already before
+        if (useJdk6API) return null;
+        try {
+            return clazz.getMethod(methodName, parameterTypes);
+        } catch (NoSuchMethodException e) {
+            LOGGER.log(Level.SEVERE, "Exception cought", e);
+            LOGGER.log(Level.WARNING, "Method {0} not found. Temp files will be created using old java.io API.", methodName);
+            useJdk6API = true;
+            return null;
+        }
+    }
+
+
+    static Object toPath(File f) throws InvocationTargetException, IllegalAccessException {
+        return METHOD_FILE_TO_PATH.invoke(f);
+    }
+
+    static File toFile(Object path) throws InvocationTargetException, IllegalAccessException {
+        return (File) METHOD_PATH_TO_FILE.invoke(path);
+    }
+
+    static File createTempFile(String prefix, String suffix, File dir) throws IOException {
+
+        if (useJdk6API) {
+            LOGGER.log(Level.FINEST, "Jdk6 detected, temp file (prefix:{0}, suffix:{1}) being created using old java.io API.", new Object[]{prefix, suffix});
+            return File.createTempFile(prefix, suffix, dir);
+
+        } else {
+
+            try {
+                if (dir != null) {
+                    Object path = toPath(dir);
+                    LOGGER.log(Level.FINEST, "Temp file (path: {0}, prefix:{1}, suffix:{2}) being created using NIO API.", new Object[]{dir.getAbsolutePath(), prefix, suffix});
+                    return toFile(METHOD_FILES_CREATE_TEMP_FILE_WITHPATH.invoke(null, path, prefix, suffix, Array.newInstance(CLASS_FILE_ATTRIBUTE, 0)));
+                } else {
+                    LOGGER.log(Level.FINEST, "Temp file (prefix:{0}, suffix:{1}) being created using NIO API.", new Object[]{prefix, suffix});
+                    return toFile(METHOD_FILES_CREATE_TEMP_FILE.invoke(null, prefix, suffix, Array.newInstance(CLASS_FILE_ATTRIBUTE, 0)));
+                }
+
+            } catch (IllegalAccessException e) {
+                LOGGER.log(Level.SEVERE, "Exception caught", e);
+                LOGGER.log(Level.WARNING, "Error invoking java.nio API, temp file (path: {0}, prefix:{1}, suffix:{2}) being created using old java.io API.",
+                        new Object[]{dir != null ? dir.getAbsolutePath() : null, prefix, suffix});
+                return File.createTempFile(prefix, suffix, dir);
+
+            } catch (InvocationTargetException e) {
+                LOGGER.log(Level.SEVERE, "Exception caught", e);
+                LOGGER.log(Level.WARNING, "Error invoking java.nio API, temp file (path: {0}, prefix:{1}, suffix:{2}) being created using old java.io API.",
+                        new Object[]{dir != null ? dir.getAbsolutePath() : null, prefix, suffix});
+                return File.createTempFile(prefix, suffix, dir);
+            }
+        }
+
+    }
+
+
+}
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/client/WSServiceDelegate.java	2012-08-10 09:50:57.000000000 -0700
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/client/WSServiceDelegate.java	2013-05-05 09:39:27.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,6 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-
 package com.sun.xml.internal.ws.client;
 
 import com.sun.istack.internal.NotNull;
@@ -30,13 +29,11 @@
 import com.sun.xml.internal.ws.Closeable;
 import com.sun.xml.internal.ws.api.BindingID;
 import com.sun.xml.internal.ws.api.EndpointAddress;
-import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.WSService;
 import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
 import com.sun.xml.internal.ws.api.client.ServiceInterceptor;
 import com.sun.xml.internal.ws.api.client.ServiceInterceptorFactory;
-import com.sun.xml.internal.ws.api.model.SEIModel;
-import com.sun.xml.internal.ws.api.pipe.*;
+import com.sun.xml.internal.ws.api.pipe.Stubs;
 import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.server.ContainerResolver;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension;
@@ -45,8 +42,8 @@
 import com.sun.xml.internal.ws.client.HandlerConfigurator.AnnotationConfigurator;
 import com.sun.xml.internal.ws.client.HandlerConfigurator.HandlerResolverImpl;
 import com.sun.xml.internal.ws.client.sei.SEIStub;
-import com.sun.xml.internal.ws.developer.WSBindingProvider;
 import com.sun.xml.internal.ws.developer.UsesJAXBContextFeature;
+import com.sun.xml.internal.ws.developer.WSBindingProvider;
 import com.sun.xml.internal.ws.model.AbstractSEIModelImpl;
 import com.sun.xml.internal.ws.model.RuntimeModeler;
 import com.sun.xml.internal.ws.model.SOAPSEIModel;
@@ -59,7 +56,6 @@
 import com.sun.xml.internal.ws.util.JAXWSUtils;
 import com.sun.xml.internal.ws.util.ServiceConfigurationError;
 import com.sun.xml.internal.ws.util.ServiceFinder;
-import static com.sun.xml.internal.ws.util.xml.XmlUtil.createDefaultCatalogResolver;
 import com.sun.xml.internal.ws.wsdl.parser.RuntimeWSDLParser;
 import org.xml.sax.SAXException;
 
@@ -74,16 +70,17 @@
 import javax.xml.ws.handler.HandlerResolver;
 import javax.xml.ws.soap.AddressingFeature;
 import java.io.IOException;
+import java.lang.RuntimePermission;
 import java.lang.reflect.Proxy;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
+import java.security.*;
 import java.util.*;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 
+import static com.sun.xml.internal.ws.util.xml.XmlUtil.createDefaultCatalogResolver;
+
 /**
  * <code>Service</code> objects provide the client view of a Web service.
  *
@@ -578,7 +575,7 @@
         }
     }
 
-    private <T> T createEndpointIFBaseProxy(@Nullable WSEndpointReference epr,QName portName, Class<T> portInterface,
+    private <T> T createEndpointIFBaseProxy(@Nullable WSEndpointReference epr,QName portName, final Class<T> portInterface,
                                             WebServiceFeature[] webServiceFeatures, SEIPortInfo eif) {
         //fail if service doesnt have WSDL
         if (wsdlService == null)
@@ -592,14 +589,37 @@
         BindingImpl binding = eif.createBinding(webServiceFeatures,portInterface);
         SEIStub pis = new SEIStub(eif, binding, eif.model, epr);
 
-        T proxy = portInterface.cast(Proxy.newProxyInstance(portInterface.getClassLoader(),
-                new Class[]{portInterface, WSBindingProvider.class, Closeable.class}, pis));
+        T proxy = createProxy(portInterface, pis);
+
         if (serviceInterceptor != null) {
             serviceInterceptor.postCreateProxy((WSBindingProvider)proxy, portInterface);
         }
         return proxy;
     }
 
+    private <T> T createProxy(final Class<T> portInterface, final SEIStub pis) {
+
+        // accessClassInPackage privilege needs to be granted ...
+        RuntimePermission perm = new RuntimePermission("accessClassInPackage.com.sun." + "xml.internal.*");
+        PermissionCollection perms = perm.newPermissionCollection();
+        perms.add(perm);
+
+        return AccessController.doPrivileged(
+                new PrivilegedAction<T>() {
+                    @Override
+                    public T run() {
+                        Object proxy = Proxy.newProxyInstance(portInterface.getClassLoader(),
+                                new Class[]{portInterface, WSBindingProvider.class, Closeable.class}, pis);
+                        return portInterface.cast(proxy);
+                    }
+                },
+                new AccessControlContext(
+                        new ProtectionDomain[]{
+                                new ProtectionDomain(null, perms)
+                        })
+        );
+    }
+
     /**
      * Lists up the port names in WSDL. For error diagnostics.
      */
--- jaxws/src/share/jaxws_classes/javax/xml/soap/FactoryFinder.java	2012-08-10 09:51:59.000000000 -0700
+++ jaxws/src/share/jaxws_classes/javax/xml/soap/FactoryFinder.java	2013-05-05 09:39:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,20 +43,12 @@
         throws SOAPException
     {
         try {
-            Class spiClass;
-            if (classLoader == null) {
-                spiClass = Class.forName(className);
-            } else {
-                spiClass = classLoader.loadClass(className);
-            }
+            Class spiClass = safeLoadClass(className, classLoader);
             return spiClass.newInstance();
         } catch (ClassNotFoundException x) {
-            throw new SOAPException(
-                "Provider " + className + " not found", x);
+            throw new SOAPException("Provider " + className + " not found", x);
         } catch (Exception x) {
-            throw new SOAPException(
-                "Provider " + className + " could not be instantiated: " + x,
-                x);
+            throw new SOAPException("Provider " + className + " could not be instantiated: " + x, x);
         }
     }
 
@@ -73,11 +65,65 @@
      *                              a system property
      * @exception SOAPException if there is a SOAP error
      */
-    static Object find(String factId)
+    static Object find(String factoryId)
+        throws SOAPException
+    {
+        return find(factoryId, null, false);
+    }
+
+    /**
+     * Finds the implementation <code>Class</code> object for the given
+     * factory name, or if that fails, finds the <code>Class</code> object
+     * for the given fallback class name. The arguments supplied must be
+     * used in order. If using the first argument is successful, the second
+     * one will not be used.
+     * <P>
+     * This method is package private so that this code can be shared.
+     *
+     * @return the <code>Class</code> object of the specified message factory;
+     *         may be <code>null</code>
+     *
+     * @param factoryId             the name of the factory to find, which is
+     *                              a system property
+     * @param fallbackClassName     the implementation class name, which is
+     *                              to be used only if nothing else
+     *                              is found; <code>null</code> to indicate that
+     *                              there is no fallback class name
+     * @exception SOAPException if there is a SOAP error
+     */
+    static Object find(String factoryId, String fallbackClassName)
         throws SOAPException
     {
-        final ClassLoader classLoader;
-        final String factoryId = factId;
+        return find(factoryId, fallbackClassName, true);
+    }
+
+    /**
+     * Finds the implementation <code>Class</code> object for the given
+     * factory name, or if that fails, finds the <code>Class</code> object
+     * for the given default class name, but only if <code>tryFallback</code>
+     * is <code>true</code>.  The arguments supplied must be used in order
+     * If using the first argument is successful, the second one will not
+     * be used.  Note the default class name may be needed even if fallback
+     * is not to be attempted, so certain error conditions can be handled.
+     * <P>
+     * This method is package private so that this code can be shared.
+     *
+     * @return the <code>Class</code> object of the specified message factory;
+     *         may not be <code>null</code>
+     *
+     * @param factoryId             the name of the factory to find, which is
+     *                              a system property
+     * @param defaultClassName      the implementation class name, which is
+     *                              to be used only if nothing else
+     *                              is found; <code>null</code> to indicate
+     *                              that there is no default class name
+     * @param tryFallback           whether to try the default class as a
+     *                              fallback
+     * @exception SOAPException if there is a SOAP error
+     */
+    static Object find(String factoryId, String defaultClassName,
+            boolean tryFallback) throws SOAPException {
+        ClassLoader classLoader;
         try {
             classLoader = Thread.currentThread().getContextClassLoader();
         } catch (Exception x) {
@@ -99,7 +145,7 @@
             String javah=System.getProperty( "java.home" );
             String configFile = javah + File.separator +
                 "lib" + File.separator + "jaxm.properties";
-            final File f=new File( configFile );
+            File f=new File( configFile );
             if( f.exists()) {
                 Properties props=new Properties();
                 props.load( new FileInputStream(f));
@@ -134,49 +180,56 @@
         } catch( Exception ex ) {
         }
 
-        return null;
+        // If not found and fallback should not be tried, return a null result.
+        if (!tryFallback)
+            return null;
+
+        // We didn't find the class through the usual means so try the default
+        // (built in) factory if specified.
+        if (defaultClassName == null) {
+            throw new SOAPException(
+                "Provider for " + factoryId + " cannot be found", null);
+        }
+        return newInstance(defaultClassName, classLoader);
     }
 
     /**
-     * Finds the implementation <code>Class</code> object for the given
-     * factory name, or if that fails, finds the <code>Class</code> object
-     * for the given fallback class name. The arguments supplied must be
-     * used in order. If using the first argument is successful, the second
-     * one will not be used.
-     * <P>
-     * This method is package private so that this code can be shared.
-     *
-     * @return the <code>Class</code> object of the specified message factory;
-     *         may not be <code>null</code>
-     *
-     * @param factoryId             the name of the factory to find, which is
-     *                              a system property
-     * @param fallbackClassName     the implementation class name, which is
-     *                              to be used only if nothing else
-     *                              is found; <code>null</code> to indicate that
-     *                              there is no fallback class name
-     * @exception SOAPException if there is a SOAP error
+     * Loads the class, provided that the calling thread has an access to the
+     * class being loaded. If this is the specified default factory class and it
+     * is restricted by package.access we get a SecurityException and can do a
+     * Class.forName() on it so it will be loaded by the bootstrap class loader.
      */
-    static Object find(String factoryId, String fallbackClassName)
-        throws SOAPException
-    {
-
-        Object obj = find(factoryId);
-        if (obj != null)
-            return obj;
+    private static Class safeLoadClass(String className,
+            ClassLoader classLoader)
+            throws ClassNotFoundException {
+        try {
+            // make sure that the current thread has an access to the package of the given name.
+            SecurityManager s = System.getSecurityManager();
+            if (s != null) {
+                int i = className.lastIndexOf('.');
+                if (i != -1) {
+                    s.checkPackageAccess(className.substring(0, i));
+                }
+            }
 
-        ClassLoader classLoader;
-        try {
-            classLoader = Thread.currentThread().getContextClassLoader();
-        } catch (Exception x) {
-            throw new SOAPException(x.toString(), x);
-        }
+            if (classLoader == null)
+                return Class.forName(className);
+            else
+                return classLoader.loadClass(className);
+        } catch (SecurityException se) {
+            // (only) default implementation can be loaded
+            // using bootstrap class loader ...
+            if (isDefaultImplementation(className))
+                return Class.forName(className);
 
-        if (fallbackClassName == null) {
-            throw new SOAPException(
-                "Provider for " + factoryId + " cannot be found", null);
+            throw se;
         }
+    }
 
-        return newInstance(fallbackClassName, classLoader);
+    private static boolean isDefaultImplementation(String className) {
+        return MessageFactory.DEFAULT_MESSAGE_FACTORY.equals(className) ||
+                SOAPFactory.DEFAULT_SOAP_FACTORY.equals(className) ||
+                SOAPConnectionFactory.DEFAULT_SOAP_CONNECTION_FACTORY.equals(className) ||
+                SAAJMetaFactory.DEFAULT_META_FACTORY_CLASS.equals(className);
     }
 }
--- jaxws/src/share/jaxws_classes/javax/xml/soap/MessageFactory.java	2012-08-10 09:51:59.000000000 -0700
+++ jaxws/src/share/jaxws_classes/javax/xml/soap/MessageFactory.java	2013-05-05 09:39:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -66,7 +66,7 @@
  */
 public abstract class MessageFactory {
 
-    static private final String DEFAULT_MESSAGE_FACTORY
+    static final String DEFAULT_MESSAGE_FACTORY
         = "com.sun.xml.internal.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl";
 
     static private final String MESSAGE_FACTORY_PROPERTY
@@ -99,11 +99,14 @@
     public static MessageFactory newInstance()
         throws SOAPException {
         try {
-            MessageFactory factory = (MessageFactory)
-                FactoryFinder.find(MESSAGE_FACTORY_PROPERTY);
+            MessageFactory factory = (MessageFactory) FactoryFinder.find(
+                    MESSAGE_FACTORY_PROPERTY,
+                    DEFAULT_MESSAGE_FACTORY,
+                    false);
 
-            if (factory != null)
+            if (factory != null) {
                 return factory;
+            }
 
             return newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
         } catch (Exception ex) {
--- jaxws/src/share/jaxws_classes/javax/xml/soap/SAAJMetaFactory.java	2012-08-10 09:51:59.000000000 -0700
+++ jaxws/src/share/jaxws_classes/javax/xml/soap/SAAJMetaFactory.java	2013-05-05 09:39:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -44,7 +44,7 @@
 public abstract class SAAJMetaFactory {
     static private final String META_FACTORY_CLASS_PROPERTY =
         "javax.xml.soap.MetaFactory";
-    static private final String DEFAULT_META_FACTORY_CLASS =
+    static final String DEFAULT_META_FACTORY_CLASS =
         "com.sun.xml.internal.messaging.saaj.soap.SAAJMetaFactoryImpl";
 
     /**
--- jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPConnectionFactory.java	2012-08-10 09:51:59.000000000 -0700
+++ jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPConnectionFactory.java	2013-05-05 09:39:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,7 +38,7 @@
      * A constant representing the default value for a <code>SOAPConnection</code>
      * object. The default is the point-to-point SOAP connection.
      */
-    static private final String DEFAULT_SOAP_CONNECTION_FACTORY
+    static final String DEFAULT_SOAP_CONNECTION_FACTORY
         = "com.sun.xml.internal.messaging.saaj.client.p2p.HttpSOAPConnectionFactory";
 
     /**
--- jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFactory.java	2012-08-10 09:52:00.000000000 -0700
+++ jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFactory.java	2013-05-05 09:39:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -54,6 +54,12 @@
         "javax.xml.soap.SOAPFactory";
 
     /**
+     * Class name of default <code>SOAPFactory</code> implementation.
+     */
+    static final String DEFAULT_SOAP_FACTORY
+        = "com.sun.xml.internal.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl";
+
+    /**
      * Creates a <code>SOAPElement</code> object from an existing DOM
      * <code>Element</code>. If the DOM <code>Element</code> that is passed in
      * as an argument is already a <code>SOAPElement</code> then this method
@@ -255,7 +261,7 @@
         throws SOAPException
     {
         try {
-            SOAPFactory factory = (SOAPFactory) FactoryFinder.find(SOAP_FACTORY_PROPERTY);
+            SOAPFactory factory = (SOAPFactory) FactoryFinder.find(SOAP_FACTORY_PROPERTY, DEFAULT_SOAP_FACTORY, false);
             if (factory != null)
                 return factory;
             return newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
--- jdk/.hgtags	2012-08-10 10:21:29.000000000 -0700
+++ jdk/.hgtags	2013-05-05 09:39:08.000000000 -0700
@@ -123,6 +123,7 @@
 539e576793a8e64aaf160e0d6ab0b9723cd0bef0 jdk7-b146
 69e973991866c948cf1808b06884ef2d28b64fcb jdk7u1-b01
 f097ca2434b1412b12ab4a5c2397ce271bf681e7 jdk7-b147
+0870207843e2a74816dff1e33a717ffaf6f0a919 7u0
 2baf612764d215e6f3a5b48533f74c6924ac98d7 jdk7u1-b02
 a4781b6d9cfb6901452579adee17c9a17c1b584c jdk7u1-b03
 b223ed9a5fdf8ce3af42adfa8815975811d70eae jdk7u1-b04
@@ -197,5 +198,65 @@
 243717d7fe9589148951ffb5551264af0e446314 jdk7u6-b21
 d78f2b600d393f45d6ace8ca0f29ad677624a775 jdk7u6-b22
 0ae89e53f5300da1961984a7d81c220c7cf717d7 jdk7u6-b23
-df945ef30444adf08f3ef14b0c49c8bda6dda587 jdk7u8-b01
-dd1e513c05b8b8c8402e9ecf9c0d5bdbebb1a089 jdk7u8-b02
+1c775da998735711853cfe1ae1d6baddc5f12a66 jdk7u6-b24
+4bd0528374971157afd6372890f4250e1cf712d9 jdk7u6-b30
+8c2c5d63a17ee5aa85face026d6f60fb7d34aded jdk7u6-b31
+78e01a6ca8d30e8fc4eb297d297a098edfb3fec6 jdk7u7-b10
+9666d4e4bbf3f80614e246d5c15df86154544013 jdk7u7-b30
+94154c14973aee7c5ff4846af7bcb71fe7a82fa5 jdk7u7-b11
+f93d2e3b2610b612401c95dd56d1a1122d35f676 jdk7u7-b31
+94a7d51992ae6fd31f9adc15c4976d6354dca14d jdk7u7-b01
+901c290c9c8b495a2696f10a87523363239d001b jdk7u7-b02
+0e2200a8762c1fdbd1ea812ba3f6535245372c81 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+94a7d51992ae6fd31f9adc15c4976d6354dca14d jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+901c290c9c8b495a2696f10a87523363239d001b jdk7u9-b02
+7302c386ca9c6cd20c27d0a2adb0b142f679d6b3 jdk7u9-b04
+ffad06d7009576c3098705e05452ebc309a59e56 jdk7u9-b05
+3b1a395f1948c7063d342a0c3e26c8450c6e7acb jdk7u9-b31
+77f7e5f13763fed11afb6e12840d78bd55c2d979 jdk7u9-b32
+c1efb11d7db509dafd7882811b2562ba593f6431 jdk7u10-b10
+0243e41000c6f76654725cac31ffdc95633c63e7 jdk7u10-b11
+c86a49dd4a0dca3a56f00429cfcffb2ad5f2a224 jdk7u10-b12
+c6de70ed568d190c9c7d9641b88b9b5f1bc36fd5 jdk7u10-b13
+abe96e9e10f973cf0fdacc1475e69a274ef76fcf jdk7u10-b14
+c9a0e381cd8eaf62bcacfd59b01c249de81ae167 jdk7u10-b15
+ed59989fb0635f2d4461173e218c43494f06bb82 jdk7u10-b16
+a1c5bac982a6d4aa58f551cb46cde53f526aca48 jdk7u10-b17
+115d1e4365293846bbc911cf312886c471e37fbd jdk7u10-b18
+84218dff5e4c7bc00fd9266769c0d12bdde866f5 jdk7u10-b30
+3515fd583ede49b125a0b5f72ac403b3984d199b jdk7u10-b31
+ecc14534318c80dc7612c8b1d328a67849c5b07f jdk7u11-b20
+d9969a953f693f5760b1d2759f11a2cb222e4f20 jdk7u11-b21
+c7282a85c6bcc717b7099a03db028ecb77b41098 jdk7u11-b32
+8fd5e105c6a288b01f8809a6c84a5a64a63f39be jdk7u11-b33
+84da14fbd3ac12a3c6734fa4b6a366cfde1426af jdk7u11-b03
+932ef74edbf984299a68c126c70bbe04ffbde9b5 jdk7u11-b04
+fb35fb91f6478f8076993bcc4112746bcd9a2985 jdk7u11-b05
+f26def552d2c4873aeaee00241f60efc462a11a7 jdk7u11-b06
+1d14a3d7bac870423e52a889d2f5f60ee76ddc6a jdk7u11-b07
+ee61b528b3f866b20095f5e9593896d4ea4be468 jdk7u11-b08
+0b9564dab118d40bc5edc60269f736f97ab6f385 jdk7u13-b09
+cbbb166b38eb15f5d5c68e913ee18f6f352b7af0 jdk7u13-b10
+28700a56b69d80e70aecf230ab7f9ad4bb5acf23 jdk7u13-b30
+8eb180a284b0911b2645d5cbdff5be499a75d6b2 jdk7u13-b20
+835448d525a10bb826f4f7ebe272fc410bdb0f5d jdk7u15-b01
+0443fe2d8023111b52f4c8db32e038f4a5a9f373 jdk7u15-b02
+70b0f967c0649c501fb14a27bb06daeccbff823a jdk7u15-b30
+9f20468265071696b4d2ece286bc228a4d5a302a jdk7u15-b31
+3ef25219292f57ea56ac0ef338ceadf5fd098bdf jdk7u15-b33
+87e45d30e24db726ea03b20d861f0a025e437641 jdk7u15-b03
+b5ae6fb92e71df1833221026efe50863593bf682 jdk7u17-b01
+b130c8cfecfc552614047b3244d5d94439827fcd jdk7u17-b02
+a474615061bf610105a426780a7ac4c95bd76456 jdk7u17-b30
+1ad6f413e250bd2671b4908e232bd0d244c917a7 jdk7u17-b31
+8261e56b7f91c7553e8485b206bdc9030a3546e4 jdk7u21-b01
+af6be9d7aed7c323858932c908b049f4bcdb6a3e jdk7u21-b05
+ffc1454e644a39265cd6d80ef4b4c12c5dbf35c9 jdk7u21-b06
+b453d9be6b3f5496aa217ade7478d3b7fa32b13b jdk7u21-b07
+de4e41c5c549136209a68154d847cf126e563b88 jdk7u21-b08
+622aedcdda610a148a082558a0c25d8b3b735d07 jdk7u21-b09
+f447c3bbf074439ece0ce9fea82c857f93817801 jdk7u21-b10
+f9323b9d020ce8d313af2d2e2682e2b6cabcc40d jdk7u21-b11
+08ed0bfc9668f04ce4e3803f16aad92f6e50f885 jdk7u21-b30
--- jdk/make/com/oracle/security/ucrypto/Makefile	2012-08-10 10:21:29.000000000 -0700
+++ jdk/make/com/oracle/security/ucrypto/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -198,9 +198,9 @@
   #
   # Build ucrypto.jar.
   #
-  $(UNSIGNED_DIR)/ucrypto.jar: build
+  $(UNSIGNED_DIR)/ucrypto.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
--- jdk/make/com/sun/nio/Makefile	2012-08-10 10:21:31.000000000 -0700
+++ jdk/make/com/sun/nio/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -31,11 +31,18 @@
 include $(BUILDDIR)/common/Defs.gmk
 
 # MMM: disable for now
-ifneq ($(PLATFORM), macosx)
+ifeq (,$(findstring $(PLATFORM), bsd macosx))
 include $(BUILDDIR)/common/Subdirs.gmk
 SUBDIRS = sctp
 endif
 
+ifeq ($(OS_VENDOR), FreeBSD)
+# FreeBSD 5.x and lower are unsupported, 6.x has no sctp support.
+ifneq ($(call MajorVersion,$(shell uname -r)), 6)
+include $(BUILDDIR)/common/Subdirs.gmk
+SUBDIRS = sctp
+endif
+endif
 
 all build clean clobber::
 	$(SUBDIRS-loop)
--- jdk/make/com/sun/nio/sctp/Makefile	2012-08-10 10:21:31.000000000 -0700
+++ jdk/make/com/sun/nio/sctp/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -59,15 +59,11 @@
   -I$(PLATFORM_SRC)/native/java/net \
   -I$(CLASSHDRDIR)/../../../../java/java.nio/nio/CClassHeaders
 
+OTHER_LDLIBS += $(LIBSOCKET) -L$(LIBDIR)/$(LIBARCH) -lnet -lnio
 ifeq ($(PLATFORM), linux)
 COMPILER_WARNINGS_FATAL=true
-#OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -lpthread -ldl
-OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -lnio -lnet -lpthread -ldl
+OTHER_LDLIBS += -lpthread $(LIBDL)
 endif
-ifeq ($(PLATFORM), solaris)
-#LIBSCTP = -lsctp
-OTHER_LDLIBS += $(LIBSOCKET) -L$(LIBDIR)/$(LIBARCH) -lnet -lnio
-endif # PLATFORM
 
 else # windows
 include $(BUILDDIR)/common/Classes.gmk
--- jdk/make/com/sun/security/auth/module/Makefile	2012-08-10 10:21:32.000000000 -0700
+++ jdk/make/com/sun/security/auth/module/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -67,7 +67,7 @@
   include FILES_c_solaris.gmk
 endif # solaris
 
-ifneq (,$(findstring $(PLATFORM), linux macosx))
+ifneq (,$(findstring $(PLATFORM), linux bsd macosx))
   LIBRARY = jaas_unix
   include FILES_export_unix.gmk
   include FILES_c_unix.gmk
--- jdk/make/com/sun/tools/attach/Exportedfiles.gmk	2012-08-10 10:21:32.000000000 -0700
+++ jdk/make/com/sun/tools/attach/Exportedfiles.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -43,7 +43,7 @@
 	sun/tools/attach/LinuxVirtualMachine.java
 endif
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_export = \
 	sun/tools/attach/BsdVirtualMachine.java
 endif
--- jdk/make/com/sun/tools/attach/FILES_c.gmk	2012-08-10 10:21:32.000000000 -0700
+++ jdk/make/com/sun/tools/attach/FILES_c.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -39,7 +39,7 @@
 	LinuxVirtualMachine.c
 endif
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_c = \
 	BsdVirtualMachine.c
 endif
--- jdk/make/com/sun/tools/attach/FILES_java.gmk	2012-08-10 10:21:32.000000000 -0700
+++ jdk/make/com/sun/tools/attach/FILES_java.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -43,7 +43,7 @@
 	sun/tools/attach/LinuxAttachProvider.java
 endif
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_java += \
 	sun/tools/attach/BsdAttachProvider.java
 endif
--- jdk/make/com/sun/tools/attach/Makefile	2012-08-10 10:21:32.000000000 -0700
+++ jdk/make/com/sun/tools/attach/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -38,7 +38,7 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_m = mapfile-bsd 
 endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
@@ -57,7 +57,7 @@
 EXTRA_LIBS += psapi.lib
 endif
 
-ifeq ($PLATFORM), macosx)
+ifeq ($(PLATFORM), macosx)
   vpath %.c $(call NativeSrcDirList,,native/sun/tools/attach)
 else
   vpath %.c $(PLATFORM_SRC)/native/sun/tools/attach
--- jdk/make/common/Defs-bsd.gmk	1969-12-31 16:00:00.000000000 -0800
+++ jdk/make/common/Defs-bsd.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -0,0 +1,490 @@
+#
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+#
+# Makefile to specify compiler flags for programs and libraries
+# targeted to BSD.  Should not contain any rules.
+#
+# WARNING: This file is shared with other workspaces. 
+#          So when it includes other files, it must use JDK_TOPDIR.
+#
+
+# Warning: the following variables are overriden by Defs.gmk. Set
+# values will be silently ignored:
+#   CFLAGS        (set $(OTHER_CFLAGS) instead)
+#   CPPFLAGS      (set $(OTHER_CPPFLAGS) instead)
+#   CXXFLAGS      (set $(OTHER_CXXFLAGS) instead)
+#   LDFLAGS       (set $(OTHER_LDFAGS) instead)
+#   LDLIBS        (set $(EXTRA_LIBS) instead)
+#   LDLIBS_COMMON (set $(EXTRA_LIBS) instead)
+
+# Get shared JDK settings
+include $(JDK_MAKE_SHARED_DIR)/Defs.gmk
+
+# Part of INCREMENTAL_BUILD mechanism.
+#   Compiler emits things like:  path/file.o: file.h
+#   We want something like: relative_path/file.o relative_path/file.d: file.h
+CC_DEPEND	 = -MM
+CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
+
+ifndef PLATFORM_SRC
+  PLATFORM_SRC = $(BUILDDIR)/../src/solaris
+endif # PLATFORM_SRC
+
+# Location of the various .properties files specific to BSD platform
+ifndef PLATFORM_PROPERTIES
+  PLATFORM_PROPERTIES  = $(BUILDDIR)/../src/solaris/lib
+endif # PLATFORM_SRC
+
+# BSD build pulls its platform sources from the solaris tree.
+JAVA_SRCDIR_LIST = src/macosx src/solaris src/share
+NATIVE_SRCDIR_LIST = src/macosx src/solaris src/share
+
+# Platform specific closed sources
+ifndef OPENJDK
+  ifndef CLOSED_PLATFORM_SRC
+    CLOSED_PLATFORM_SRC = $(BUILDDIR)/../src/closed/solaris
+  endif
+endif
+
+# platform specific include files
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
+PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
+
+# suffix used for make dependencies files.
+DEPEND_SUFFIX = d
+# The suffix applied to the library name for FDLIBM
+FDDLIBM_SUFFIX = a
+# The suffix applied to scripts (.bat for windows, nothing for unix)
+SCRIPT_SUFFIX =
+# CC compiler object code output directive flag value
+CC_OBJECT_OUTPUT_FLAG = -o #trailing blank required!
+CC_PROGRAM_OUTPUT_FLAG = -o #trailing blank required!
+
+# The Full Debug Symbols (FDS) default for VARIANT == OPT builds is
+# enabled with debug info files ZIP'ed to save space. For VARIANT !=
+# OPT builds, FDS is always enabled, after all a debug build without
+# debug info isn't very useful. The ZIP_DEBUGINFO_FILES option only has
+# meaning when FDS is enabled.
+#
+# If you invoke a build with FULL_DEBUG_SYMBOLS=0, then FDS will be
+# disabled for a VARIANT == OPT build.
+#
+# Note: Use of a different variable name for the FDS override option
+# versus the FDS enabled check is intentional (FULL_DEBUG_SYMBOLS
+# versus ENABLE_FULL_DEBUG_SYMBOLS). For auto build systems that pass
+# in options via environment variables, use of distinct variables
+# prevents strange behaviours. For example, in a VARIANT != OPT build,
+# the FULL_DEBUG_SYMBOLS environment variable will be 0, but the
+# ENABLE_FULL_DEBUG_SYMBOLS make variable will be 1. If the same
+# variable name is used, then different values can be picked up by
+# different parts of the build. Just to be clear, we only need two
+# variable names because the incoming option value can be overridden
+# in some situations, e.g., a VARIANT != OPT build.
+
+ifeq ($(VARIANT), OPT)
+  FULL_DEBUG_SYMBOLS ?= 1
+  ENABLE_FULL_DEBUG_SYMBOLS = $(FULL_DEBUG_SYMBOLS)
+else
+  # debug variants always get Full Debug Symbols (if available)
+  ENABLE_FULL_DEBUG_SYMBOLS = 1
+endif
+_JUNK_ := $(shell \
+  echo >&2 "INFO: ENABLE_FULL_DEBUG_SYMBOLS=$(ENABLE_FULL_DEBUG_SYMBOLS)")
+# since objcopy is optional, we set ZIP_DEBUGINFO_FILES later
+
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  # Default OBJCOPY comes from GNU Binutils on BSD:
+  DEF_OBJCOPY=/usr/bin/objcopy
+  ifdef CROSS_COMPILE_ARCH
+    # don't try to generate .debuginfo files when cross compiling
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: cross compiling for ARCH $(CROSS_COMPILE_ARCH)," \
+        "skipping .debuginfo generation.")
+    OBJCOPY=
+  else
+    OBJCOPY=$(shell test -x $(DEF_OBJCOPY) && echo $(DEF_OBJCOPY))
+    ifneq ($(ALT_OBJCOPY),)
+      _JUNK_ := $(shell echo >&2 "INFO: ALT_OBJCOPY=$(ALT_OBJCOPY)")
+      # disable .debuginfo support by setting ALT_OBJCOPY to a non-existent path
+      OBJCOPY=$(shell test -x $(ALT_OBJCOPY) && echo $(ALT_OBJCOPY))
+    endif
+  endif
+
+  # Setting ENABLE_FULL_DEBUG_SYMBOLS=1 (and OBJCOPY) above enables the
+  # JDK build to import .debuginfo or .diz files from the HotSpot build.
+  # However, adding FDS support to the JDK build will occur in phases
+  # so a different make variable (LIBRARY_SUPPORTS_FULL_DEBUG_SYMBOLS
+  # and PROGRAM_SUPPORTS_FULL_DEBUG_SYMBOLS) is used to indicate that a
+  # particular library or program supports FDS.
+
+  ifeq ($(OBJCOPY),)
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: no objcopy cmd found so cannot create .debuginfo files.")
+    ENABLE_FULL_DEBUG_SYMBOLS=0
+  else
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: $(OBJCOPY) cmd found so will create .debuginfo files.")
+
+    # Library stripping policies for .debuginfo configs:
+    #   all_strip - strips everything from the library
+    #   min_strip - strips most stuff from the library; leaves minimum symbols
+    #   no_strip  - does not strip the library at all
+    #
+    # Oracle security policy requires "all_strip". A waiver was granted on
+    # 2011.09.01 that permits using "min_strip" in the Java JDK and Java JRE.
+    #
+    # Currently, STRIP_POLICY is only used when Full Debug Symbols is enabled.
+    STRIP_POLICY ?= min_strip
+
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: STRIP_POLICY=$(STRIP_POLICY)")
+
+    ZIP_DEBUGINFO_FILES ?= 1
+
+    _JUNK_ := $(shell \
+      echo >&2 "INFO: ZIP_DEBUGINFO_FILES=$(ZIP_DEBUGINFO_FILES)")
+  endif
+endif
+
+#
+# Default optimization
+#
+
+ifndef OPTIMIZATION_LEVEL
+  ifeq ($(PRODUCT), java)
+    OPTIMIZATION_LEVEL = HIGHER
+  else
+    OPTIMIZATION_LEVEL = LOWER
+  endif
+endif
+ifndef FASTDEBUG_OPTIMIZATION_LEVEL
+  FASTDEBUG_OPTIMIZATION_LEVEL = LOWER
+endif
+
+CC_OPT/NONE     = 
+CC_OPT/LOWER    = -O2
+CC_OPT/HIGHER   = -O3
+CC_OPT/HIGHEST  = -O3
+
+CC_OPT          = $(CC_OPT/$(OPTIMIZATION_LEVEL))
+
+# For all platforms, do not omit the frame pointer register usage. 
+#    We need this frame pointer to make it easy to walk the stacks.
+#    This should be the default on X86, but ia64 and amd64 may not have this
+#    as the default.
+CFLAGS_REQUIRED_amd64   += -m64 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_amd64    += -m64
+CFLAGS_REQUIRED_i586    += -m32 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_i586     += -m32
+CFLAGS_REQUIRED_ia64    += -m64 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
+LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
+CFLAGS_REQUIRED_sparc   += -m32 -mcpu=v9
+LDFLAGS_COMMON_sparc    += -m32 -mcpu=v9
+CFLAGS_REQUIRED_arm     += -fsigned-char -D_LITTLE_ENDIAN
+CFLAGS_REQUIRED_ppc     += -fsigned-char -D_BIG_ENDIAN
+ifeq ($(ZERO_BUILD), true)
+  CFLAGS_REQUIRED       =  $(ZERO_ARCHFLAG)
+  ifeq ($(ZERO_ENDIANNESS), little)
+    CFLAGS_REQUIRED     += -D_LITTLE_ENDIAN
+  endif
+  LDFLAGS_COMMON        += $(ZERO_ARCHFLAG)
+else
+  CFLAGS_REQUIRED       =  $(CFLAGS_REQUIRED_$(ARCH))
+  LDFLAGS_COMMON        += $(LDFLAGS_COMMON_$(ARCH))
+endif
+
+# If this is a --hash-style=gnu system, use --hash-style=both
+#   The gnu .hash section won't work on some Linux systems like SuSE 10.
+_HAS_HASH_STYLE_GNU:=$(shell $(CC) -dumpspecs | $(GREP) -- '--hash-style=gnu')
+ifneq ($(_HAS_HASH_STYLE_GNU),)
+  LDFLAGS_HASH_STYLE = -Wl,--hash-style=both
+endif
+LDFLAGS_COMMON          += $(LDFLAGS_HASH_STYLE)
+
+#
+# Selection of warning messages
+#
+GCC_INHIBIT	= -Wno-unused -Wno-parentheses
+GCC_STYLE	= 
+GCC_WARNINGS	= -W -Wall $(GCC_STYLE) $(GCC_INHIBIT)
+
+#
+# Treat compiler warnings as errors, if warnings not allowed
+#
+ifeq ($(COMPILER_WARNINGS_FATAL),true)
+  GCC_WARNINGS += -Werror
+endif
+
+#
+# Misc compiler options
+#
+ifneq ($(ARCH),ppc)
+  CFLAGS_COMMON   = -fno-strict-aliasing
+endif 
+PIC_CODE_LARGE = -fPIC
+PIC_CODE_SMALL = -fpic
+GLOBAL_KPIC = $(PIC_CODE_LARGE)
+CFLAGS_COMMON   += $(GLOBAL_KPIC) $(GCC_WARNINGS)
+ifeq ($(ARCH), amd64)
+ CFLAGS_COMMON += -pipe
+endif
+
+# BSD 64bit machines use Dwarf2, which can be HUGE, have fastdebug use -g1
+DEBUG_FLAG = -g
+ifeq ($(FASTDEBUG), true)
+  ifeq ($(ARCH_DATA_MODEL), 64)
+    DEBUG_FLAG = -g1
+  endif
+endif
+
+# DEBUG_BINARIES overrides everything, use full -g debug information
+ifeq ($(DEBUG_BINARIES), true)
+  DEBUG_FLAG = -g
+  CFLAGS_REQUIRED += $(DEBUG_FLAG)
+endif
+
+# If Full Debug Symbols is enabled, then we want the same debug and
+# optimization flags as used by FASTDEBUG.
+#
+ifeq ($(ENABLE_FULL_DEBUG_SYMBOLS),1)
+  ifeq ($(LIBRARY_SUPPORTS_FULL_DEBUG_SYMBOLS),1)
+    ifeq ($(VARIANT), OPT)
+      CC_OPT = $(DEBUG_FLAG) $(CC_OPT/$(FASTDEBUG_OPTIMIZATION_LEVEL))
+    endif
+  endif
+endif
+
+CFLAGS_OPT      = $(CC_OPT)
+CFLAGS_DBG      = $(DEBUG_FLAG)
+CFLAGS_COMMON += $(CFLAGS_REQUIRED)
+
+CXXFLAGS_COMMON = $(GLOBAL_KPIC) -DCC_NOEX $(GCC_WARNINGS)
+CXXFLAGS_OPT	= $(CC_OPT)
+CXXFLAGS_DBG	= $(DEBUG_FLAG)
+CXXFLAGS_COMMON += $(CFLAGS_REQUIRED)
+
+# FASTDEBUG: Optimize the code in the -g versions, gives us a faster debug java
+ifeq ($(FASTDEBUG), true)
+  CFLAGS_DBG    += $(CC_OPT/$(FASTDEBUG_OPTIMIZATION_LEVEL))
+  CXXFLAGS_DBG	+= $(CC_OPT/$(FASTDEBUG_OPTIMIZATION_LEVEL))
+endif
+
+CPP_ARCH_FLAGS = -DARCH='"$(ARCH)"'
+
+# Alpha arch does not like "alpha" defined (potential general arch cleanup issue here)
+ifneq ($(ARCH),alpha)
+  CPP_ARCH_FLAGS += -D$(ARCH)
+else
+  CPP_ARCH_FLAGS += -D_$(ARCH)_
+endif
+
+CPPFLAGS_COMMON = $(CPP_ARCH_FLAGS) -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
+		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
+
+ifeq ($(ARCH_DATA_MODEL), 64)
+CPPFLAGS_COMMON += -D_LP64=1
+endif
+
+CPPFLAGS_OPT    = -DNDEBUG
+CPPFLAGS_DBG    = -DDEBUG
+ifneq ($(PRODUCT), java)
+  CPPFLAGS_DBG    += -DLOGGING 
+endif
+
+# Libraries need to locate other libraries at runtime, and you can tell
+#   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
+#   buried inside the .so. The $ORIGIN says to look relative to where
+#   the library itself is and it can be followed with relative paths from
+#   that. By default we always look in $ORIGIN, optionally we add relative
+#   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
+#   On BSD we add a flag -z origin, not sure if this is necessary, but
+#   doesn't seem to hurt.
+#   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
+#   Try: 'readelf -d lib*.so' to see these settings in a library.
+#
+Z_ORIGIN_FLAG/sparc = -Xlinker -z -Xlinker origin
+Z_ORIGIN_FLAG/i586  = -Xlinker -z -Xlinker origin
+Z_ORIGIN_FLAG/amd64 = -Xlinker -z -Xlinker origin
+Z_ORIGIN_FLAG/ia64  = -Xlinker -z -Xlinker origin
+Z_ORIGIN_FLAG/arm   =
+Z_ORIGIN_FLAG/ppc   =
+Z_ORIGIN_FLAG/zero  = -Xlinker -z -Xlinker origin
+
+LDFLAG_Z_ORIGIN = $(Z_ORIGIN_FLAG/$(ARCH_FAMILY))
+
+LDFLAGS_COMMON += $(LDFLAG_Z_ORIGIN) -Xlinker -rpath -Xlinker \$$ORIGIN
+LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=$(LDFLAG_Z_ORIGIN) -Xlinker -rpath -Xlinker \$$ORIGIN/%)
+
+#
+# -L paths for finding and -ljava
+#
+LDFLAGS_OPT     = -Xlinker -O1
+LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+
+#
+# -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
+# statically link libgcc but will print a warning with the flag. We don't 
+# want the warning, so check gcc version first.
+#
+ifeq ($(CC_MAJORVER),3)
+  OTHER_LDFLAGS  += -static-libgcc
+endif
+
+# Automatic precompiled header option to use (if COMPILE_APPROACH=batch)
+#   (See Rules.gmk) The gcc 5 compiler might have an option for this?
+AUTOMATIC_PCH_OPTION = 
+
+#
+# Post Processing of libraries/executables
+#
+ifeq ($(VARIANT), OPT)
+  ifneq ($(NO_STRIP), true)
+    ifneq ($(DEBUG_BINARIES), true)
+      # Debug 'strip -S' leaves local function Elf symbols (better stack
+      # traces)
+      POST_STRIP_PROCESS = $(STRIP) -S
+    endif
+  endif
+endif
+
+#
+# Use: ld $(LD_MAPFILE_FLAG) mapfile *.o
+#
+LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
+
+#
+# Support for Quantify.
+#
+ifdef QUANTIFY
+QUANTIFY_CMD = quantify
+QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
+LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+endif
+
+# Using map files currently break compilation on FreeBSD during shared library
+# checks for some of the AWT native libraries.
+ifeq ($(OS_VENDOR), FreeBSD)
+LDNOMAP=true
+endif
+
+#
+# Path and option to link against the VM, if you have to.  Note that
+# there are libraries that link against only -ljava, but they do get
+# -L to the -ljvm, this is because -ljava depends on -ljvm, whereas
+# the library itself should not.
+#
+VM_NAME         = server
+JVMLIB          = -L$(LIBDIR)/$(LIBARCH)/$(VM_NAME) -ljvm
+JAVALIB         = -ljava $(JVMLIB)
+
+#
+# We want to privatize JVM symbols on Solaris. This is so the user can
+# write a function called FindClass and this should not override the 
+# FindClass that is inside the JVM. At this point in time we are not
+# concerned with other JNI libraries because we hope that there will
+# not be as many clashes there.
+#
+PRIVATIZE_JVM_SYMBOLS = false
+
+USE_PTHREADS = true
+override ALT_CODESET_KEY         = _NL_CTYPE_CODESET_NAME
+override AWT_RUNPATH             =
+override HAVE_ALTZONE            = false
+override HAVE_FILIOH             = false
+override HAVE_GETHRTIME          = false
+override HAVE_GETHRVTIME         = false
+override LEX_LIBRARY             = -lfl
+ifeq ($(STATIC_CXX),true)
+override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
+else
+override LIBCXX                  = -lstdc++
+endif
+override LIBPOSIX4               =
+override LIBSOCKET               =
+override LIBNSL                  =
+override LIBSCF                  =
+override LIBTHREAD               =
+override LIBDL                   =
+override MOOT_PRIORITIES         = true
+override NO_INTERRUPTIBLE_IO     = true
+override OPENWIN_HOME            = $(X11_PATH)
+override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
+override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
+override SUN_CMM_SUBDIR          =
+override THREADS_FLAG            = native
+override USE_GNU_M4              = true
+override USING_GNU_TAR           = true
+override WRITE_LIBVERSION        = false
+
+# USE_EXECNAME forces the launcher to look up argv[0] on $PATH, and put the
+# resulting resolved absolute name of the executable in the environment
+# variable EXECNAME.  That executable name is then used that to locate the
+# installation area.
+override USE_EXECNAME            = true
+
+# If your platform has DPS, it will have Type1 fonts too, in which case
+# it is best to enable DPS support until such time as 2D's rasteriser
+# can fully handle Type1 fonts in all cases. Default is "yes".
+# HAVE_DPS should only be "no" if the platform has no DPS headers or libs
+# DPS (Displayable PostScript) is available on Solaris machines
+HAVE_DPS = no
+
+ifeq ($(OS_VENDOR), FreeBSD)
+  SYSTEM_ZLIB = true
+endif
+
+ifeq ($(OS_VENDOR), OpenBSD)
+  SYSTEM_ZLIB = true
+endif
+
+#
+# Japanese manpages
+#
+JA_SOURCE_ENCODING = eucJP
+JA_TARGET_ENCODINGS = UTF-8
+
+# Settings for the JDI - Serviceability Agent binding.
+HOTSPOT_SALIB_PATH   = $(HOTSPOT_IMPORT_PATH)/jre/lib/$(LIBARCH)
+SALIB_NAME = $(LIB_PREFIX)saproc.$(LIBRARY_SUFFIX)
+SA_DEBUGINFO_NAME = $(LIB_PREFIX)saproc.debuginfo
+SA_DIZ_NAME = $(LIB_PREFIX)saproc.diz
+
+# The JDI - Serviceability Agent binding is not currently supported
+# on ia64.
+ifeq ($(ARCH), ia64)
+  INCLUDE_SA = false
+else
+  INCLUDE_SA = true
+endif
+
+ifdef CROSS_COMPILE_ARCH
+  # X11 headers are not under /usr/include
+  OTHER_CFLAGS += -I$(OPENWIN_HOME)/include
+  OTHER_CXXFLAGS += -I$(OPENWIN_HOME)/include
+  OTHER_CPPFLAGS += -I$(OPENWIN_HOME)/include
+endif
--- jdk/make/common/Defs-linux.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Defs-linux.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -429,6 +429,7 @@
 override LIBDL                   = -ldl
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
--- jdk/make/common/Defs-solaris.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Defs-solaris.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -753,6 +753,9 @@
 # Network Services library
 LIBNSL = -lnsl
 
+# Dynamic Loading library
+LIBDL = -ldl
+
 # service configuration facility library
 LIBSCF = -lscf
 
--- jdk/make/common/Defs.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Defs.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -179,15 +179,15 @@
 
   ifdef ALT_FREETYPE_LIB_PATH
     FREETYPE_LIB_PATH = $(ALT_FREETYPE_LIB_PATH)
-    ifeq ($(PLATFORM), macosx)
+    ifneq (,$(findstring $(PLATFORM), bsd macosx))
       USING_SYSTEM_FT_LIB=true
     endif
   else
     ifeq ($(DEVTOOLS_FT_DIR_EXISTS), true)
       FREETYPE_LIB_PATH = $(DEVTOOLS_FT_DIR)/lib
     else
-      ifeq ($(PLATFORM), macosx)
-        FREETYPE_LIB_PATH = /usr/X11R6/lib
+      ifneq (,$(findstring $(PLATFORM), bsd macosx))
+        FREETYPE_LIB_PATH = $(X11_PATH)/lib
       else
         FREETYPE_LIB_PATH = /usr/lib
       endif
@@ -201,8 +201,8 @@
     ifeq ($(DEVTOOLS_FT_DIR_EXISTS), true)
       FREETYPE_HEADERS_PATH = $(DEVTOOLS_FT_DIR)/include
     else
-      ifeq ($(PLATFORM), macosx)
-        FREETYPE_HEADERS_PATH = /usr/X11R6/include
+      ifneq (,$(findstring $(PLATFORM), bsd macosx))
+        FREETYPE_HEADERS_PATH = $(X11_PATH)/include
       else
         FREETYPE_HEADERS_PATH = /usr/include
       endif
@@ -258,6 +258,10 @@
     LDLIBS_COMMON = -pthread
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
+
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
@@ -312,6 +316,7 @@
 
 JDK_IMAGE_DIR = $(ABS_OUTPUTDIR)/j2sdk-image
 JRE_IMAGE_DIR = $(ABS_OUTPUTDIR)/j2re-image
+JDK_SERVER_IMAGE_DIR = $(ABS_OUTPUTDIR)/j2sdk-server-image
 
 #where the demo source can be found
 DEMOSRCDIR          = $(SHARE_SRC)/demo
@@ -399,7 +404,7 @@
 # We define an intermediate variable for Java files because
 # we use its value later to help define $SOURCEPATH
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
   VPATH0.java = $(subst $(ONESPACE),:,$(GENSRCDIR) $(call JavaSrcDirList,,classes))
 else
   VPATH0.java = $(GENSRCDIR)$(CLASSPATH_SEPARATOR)$(PLATFORM_SRC)/classes$(CLASSPATH_SEPARATOR)$(SHARE_SRC)/classes
--- jdk/make/common/Library.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Library.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -299,8 +299,12 @@
             ifeq ($(PLATFORM), solaris)
 	      $(STRIP) -x $@
             else
-              # assume Linux
-	      $(STRIP) -g $@
+              ifeq ($(PLATFORM), linux)
+	        $(STRIP) -g $@
+              else
+                # assume BSD
+	        $(STRIP) -S $@
+              endif
             endif
           # implied else here is no stripping at all
           endif
--- jdk/make/common/Mapfile-vers.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Mapfile-vers.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -76,7 +76,7 @@
 
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 ifeq ($(VARIANT), OPT)
   # OPT build MUST have a mapfile?
--- jdk/make/common/Program.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Program.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -95,6 +95,17 @@
   endif # SYSTEM_ZLIB
 endif # PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+  LDFLAGS += -Wl,--whole-archive
+  LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  LDFLAGS += -Wl,--no-whole-archive
+# Work-around an dlsym(RTLD_DEFAULT) bug in at least FreeBSD & OpenBSD
+  LDFLAGS += -Wl,--export-dynamic
+  ifeq ($(SYSTEM_ZLIB),true)
+      OTHER_LDLIBS += -lz
+  endif
+endif #PLATFORM
+
 ifneq (,$(findstring $(PLATFORM), linux solaris)) # UNIX systems
   LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
   OTHER_LDLIBS += -ljli
@@ -153,7 +164,6 @@
   ifndef LOCAL_RESOURCE_FILE
 	@$(ECHO) $(OBJDIR)/$(PROGRAM).res >> $@
   endif # LOCAL_RESOURCE_FILE
-	@$(ECHO) setargv.obj >> $@
 	@$(ECHO) Created $@ 
 
   $(ACTUAL_PROGRAM):: $(OBJDIR)/$(PROGRAM)$(EXE_SUFFIX)
@@ -227,6 +237,11 @@
     INFO_PLIST_FILE=
   endif # MACOSX
 
+  ifeq ($(PLATFORM), bsd)
+    THREADLIBS = -pthread
+    OTHER_CPPFLAGS += -DPACKAGE_PATH='"$(PACKAGE_PATH)"'
+  endif
+
   #
   # This rule only applies on unix.  It supports quantify and its ilk.
   #
@@ -281,8 +296,12 @@
             ifeq ($(PLATFORM), solaris)
 	      $(STRIP) -x $@
             else
-              # assume Linux
-	      $(STRIP) -g $@
+              ifeq ($(PLATFORM), linux)
+	        $(STRIP) -g $@
+              else
+                # assume BSD
+	        $(STRIP) -S $@
+              endif
             endif
           # implied else here is no stripping at all
           endif
@@ -350,7 +369,9 @@
 
 
 ifneq ($(PLATFORM), windows)
-  HAVE_GETHRTIME=true
+  ifneq ($(PLATFORM), bsd)
+    HAVE_GETHRTIME=true
+  endif
 endif #PLATFORM
 
 ifeq ($(HAVE_GETHRTIME),true)
@@ -360,12 +381,10 @@
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)/bin -I$(LAUNCHER_PLATFORM_SRC)/bin
 ifeq ($(PLATFORM), macosx)
   OTHER_INCLUDES += -I$(LAUNCHER_SOLARIS_PLATFORM_SRC)/bin
-  ifneq ($(SYSTEM_ZLIB), true)
-    OTHER_INCLUDES += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
-  endif # SYSTEM_ZLIB
-else # PLATFORM !MACOSX
+endif # PLATFORM
+ifneq ($(SYSTEM_ZLIB), true)
   OTHER_INCLUDES += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
-endif
+endif # SYSTEM_ZLIB
 
 OTHER_CPPFLAGS  += -DPROGNAME='"$(PROGRAM)"'
 VERSION_DEFINES += -DFULL_VERSION='"$(FULL_VERSION)"'
--- jdk/make/common/Release-macosx.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Release-macosx.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -31,6 +31,8 @@
 
 JDK_BUNDLE_DIR = $(ABS_OUTPUTDIR)/j2sdk-bundle/jdk$(JDK_VERSION).jdk/Contents
 JRE_BUNDLE_DIR = $(ABS_OUTPUTDIR)/j2re-bundle/jre$(JDK_VERSION).jre/Contents
+JDK_SERVER_BUNDLE_DIR = $(ABS_OUTPUTDIR)/j2sdk-server-bundle/jdk$(JDK_VERSION).jdk/Contents
+JDK_SERVER_IMAGE_DIR = $(ABS_OUTPUTDIR)/j2sdk-server-image
 
 MACOSX_SRC	 = $(JDK_TOPDIR)/src/macosx
 
@@ -70,6 +72,13 @@
 	$(SED) -e "s/@@ID@@/$(BUNDLE_ID_JDK)/g" -e "s/@@NAME@@/$(BUNDLE_NAME_JDK)/g" -e "s/@@INFO@@/$(BUNDLE_INFO_JDK)/g" -e "s/@@PLATFORM_VERSION@@/$(BUNDLE_PLATFORM_VERSION)/g" -e "s/@@VERSION@@/$(BUNDLE_VERSION)/g" -e "s/@@VENDOR@@/$(BUNDLE_VENDOR)/g" < $(MACOSX_SRC)/bundle/JDK-Info.plist > $(JDK_BUNDLE_DIR)/Info.plist
 	/usr/bin/SetFile -a B $(JDK_BUNDLE_DIR)/../
 
-EXTRA_IMAGE_TARGETS += jre-bundle-setup jdk-bundle-setup jre-bundle-files jdk-bundle-files
+jdk-server-bundle-files:
+	$(MKDIR) -p $(JDK_SERVER_BUNDLE_DIR)/MacOS
+	ln -s ../Home/jre/lib/jli/libjli.dylib $(JDK_SERVER_BUNDLE_DIR)/MacOS/
+	$(CP) -r $(JDK_IMAGE_DIR) $(JDK_SERVER_BUNDLE_DIR)/Home
+	$(SED) -e "s/@@ID@@/$(BUNDLE_ID_JDK)/g" -e "s/@@NAME@@/$(BUNDE_NAME_JDK)/g" -e "s/@@INFO@@/$(BUNDLE_INFO_JDK)/g" -e "s/@@PLATFORM_VERSION@@/$(BUNDLE_PLATFORM_VERSION)/g" -e "s/@@VERSION@@/$(BUNDLE_VERSION)/g" -e "s/@@VENDOR@@/$(BUNDLE_VENDOR)/g" < $(MACOSX_SRC)/bundle/JDK-Info.plist > $(JDK_SERVER_BUNDLE_DIR)/Info.plist
+	/usr/bin/SetFile -a B $(JDK_SERVER_BUNDLE_DIR)/../
+
+EXTRA_IMAGE_TARGETS += jre-bundle-setup jdk-bundle-setup jre-bundle-files jdk-bundle-files jdk-server-bundle-files
 
 .PHONY: $(EXTRA_JRE_TARGETS) $(EXTRA_IMAGE_TARGETS)
--- jdk/make/common/Release.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Release.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -178,6 +178,12 @@
   JA_DIRNAME=ja_JP.UTF-8
 endif # linux
 
+ifeq ($(PLATFORM), bsd)
+  MANBASEDIRS=$(JDK_TOPDIR)/src/linux/doc $(IMPORTDOCDIR)
+  MAN1SUBDIR=man
+  JA_DIRNAME=ja_JP.UTF-8
+endif # linux
+
 define copy-man-pages
 $(MKDIR) -p $1/man/man1
 for manbase in $(MANBASEDIRS:%=%/$(MAN1SUBDIR)) ; do \
@@ -233,8 +239,8 @@
 trim-image-jre trim-image-jdk \
 identify-image-jre identify-image-jdk \
 process-image-jre process-image-jdk \
-compare-image \
-sec-files sec-files-win jgss-files ::
+compare-image  \
+sec-files sec-files-win jgss-files server-jdk-image ::
 	@$(ECHO) ">>>Making "$@" @ `$(DATE)` ..."
 
 # Order is important here, trim jre after jdk image is created
@@ -243,16 +249,17 @@
 images:: sanity-images post-sanity-images  \
 	 $(INITIAL_IMAGE_JRE) $(EXTRA_JRE_TARGETS) $(INITIAL_IMAGE_JDK) \
 	 trim-image-jre trim-image-jdk \
-     identify-image-jre identify-image-jdk \
-	 process-image-jre process-image-jdk sec-files sec-files-win jgss-files \
-	 $(EXTRA_IMAGE_TARGETS)
+	 identify-image-jre identify-image-jdk \
+	 process-image-jre process-image-jdk sec-files sec-files-win \
+	jgss-files $(EXTRA_IMAGE_TARGETS) server-jdk-image 
 else
 
 images:: sanity-images post-sanity-images  \
 	 $(INITIAL_IMAGE_JRE) $(INITIAL_IMAGE_JDK) \
 	 trim-image-jre trim-image-jdk \
          identify-image-jre identify-image-jdk \
-	 process-image-jre process-image-jdk sec-files sec-files-win jgss-files 
+	 process-image-jre process-image-jdk sec-files sec-files-win \
+	 jgss-files server-jdk-image
 endif
 
 # Don't use these
@@ -399,10 +406,29 @@
 	sun/tools/jinfo         \
 	sun/tools/jmap
 
+JFR_SRCDIRS_EXIST := $(shell \
+  if [ -d $(CLOSED_SHARE_SRC)/classes/com/oracle/jrockit/jfr ] ; then \
+   echo true; \
+  else \
+   echo false; \
+  fi)
+
+BUILD_JFR=
+ifndef OPENJDK
+ifndef JAVASE_EMBEDDED
+ifeq ($(JFR_SRCDIRS_EXIST), true)
+BUILD_JFR=true
+endif
+endif
+endif
+
 # classes that go into jfr.jar
+JFR_CLASSES_DIRS=
+ifdef BUILD_JFR
 JFR_CLASSES_DIRS= \
 	com/oracle/jrockit/jfr \
 	oracle/jrockit/jfr
+endif
 
 # classes that go into jsse.jar
 JSSE_CLASSES_DIRS = \
@@ -606,8 +632,7 @@
 	$(ECHO) "sun/tools/jstack/" >> $@
 	$(ECHO) "sun/tools/jinfo/" >> $@
 	$(ECHO) "sun/tools/jmap/" >> $@
-ifndef OPENJDK
-ifndef JAVASE_EMBEDDED
+ifdef BUILD_JFR
 	$(ECHO) "com/oracle/jrockit/jfr/" >> $@
 	$(ECHO) "com/oracle/jrockit/jfr/client/" >> $@
 	$(ECHO) "com/oracle/jrockit/jfr/management/" >> $@
@@ -618,7 +643,7 @@
 	$(ECHO) "oracle/jrockit/jfr/settings/" >> $@
 	$(ECHO) "oracle/jrockit/jfr/tools/" >> $@
 endif
-endif
+
 
 
 # File order list for rt.jar
@@ -645,8 +670,7 @@
 
 # Create jfr.jar
 JFR_JAR=
-ifndef OPENJDK
-ifndef JAVASE_EMBEDDED
+ifdef BUILD_JFR
 JFR_JAR=$(ABS_TEMPDIR)/jfr-orig.jar
 $(JFR_JAR): $(OTHER_JAR_MANIFEST_FILE)
 	$(prep-target)
@@ -655,7 +679,6 @@
 		$(JFR_CLASSES_DIRS) $(BOOT_JAR_JFLAGS)
 	@$(CD) $(CLASSBINDIR) && $(java-vm-cleanup)
 endif
-endif
 
 # Create the rt.jar file list & non-class files list
 
@@ -912,6 +935,27 @@
 	done
 	$(RM) $(JRE_BIN_LIST)
 
+# Duplicate current j2re-image contents to server-j2re-image 
+# for the server version of jre, before deploy build
+server-jdk-image::
+ifeq ($(PLATFORM), macosx)
+	$(RM) -r $(JDK_SERVER_BUNDLE_DIR)/Home/demo
+	$(RM) -r $(JDK_SERVER_BUNDLE_DIR)/Home/sample
+	$(RM) $(JDK_SERVER_BUNDLE_DIR)/Home/bin/jcontrol
+	$(RM) $(JDK_SERVER_BUNDLE_DIR)/Home/jre/bin/jcontrol
+	$(RM) $(JDK_SERVER_BUNDLE_DIR)/Home/man/ja_JP.UTF-8/man1/javaws.1
+	$(RM) $(JDK_SERVER_BUNDLE_DIR)/Home/man/man1/javaws.1
+else
+	$(RM) -r $(JDK_SERVER_IMAGE_DIR)
+	$(CP) -r $(JDK_IMAGE_DIR) $(JDK_SERVER_IMAGE_DIR)
+	$(RM) -r $(JDK_SERVER_IMAGE_DIR)/demo
+	$(RM) -r $(JDK_SERVER_IMAGE_DIR)/sample
+	$(RM) $(JDK_SERVER_IMAGE_DIR)/bin/jcontrol
+	$(RM) $(JDK_SERVER_IMAGE_DIR)/jre/bin/jcontrol
+	$(RM) $(JDK_SERVER_IMAGE_DIR)/man/ja_JP.UTF-8/man1/javaws.1
+	$(RM) $(JDK_SERVER_IMAGE_DIR)/man/man1/javaws.1
+endif
+
 ######################################################
 # JDK Image
 ######################################################
@@ -983,6 +1027,12 @@
 FILES_launcher = $(wildcard $(SHARE_SRC)/bin/*) \
                  $(wildcard $(PLATFORM_SRC)/bin/java_md*)
 
+ifeq ($(OS_VENDOR), OpenBSD)
+  FILES_FROM_ARG=-I
+else
+  FILES_FROM_ARG=-T
+endif
+
 # Standard jdk image
 initial-image-jdk:: initial-image-jdk-setup \
 		    initial-image-jdk-db \
@@ -1070,7 +1120,7 @@
 	@# So for Linux, make use of the -T option (like Solaris' -I option) of
 	@# obtaining the list of files from a file. MKS tar has no such option.
 
-  ifneq (,$(findstring $(PLATFORM), linux macosx))
+  ifneq (,$(findstring $(PLATFORM), linux macosx bsd))
 	for d in $(SOURCE_DIRS); do \
 	  $(RM) $(ABS_TEMPDIR)/src-files.list; \
 	  ($(CD) $$d &&  \
@@ -1083,7 +1133,7 @@
 	    done ; \
 	  ) ; \
 	  if [ -f  $(ABS_TEMPDIR)/src-files.list ] ; then \
-	    ($(CD) $$d && $(TAR) cf - -T $(ABS_TEMPDIR)/src-files.list ) \
+	    ($(CD) $$d && $(TAR) cf - $(FILES_FROM_ARG) $(ABS_TEMPDIR)/src-files.list ) \
 	       | ($(CD) $(JDK_IMAGE_DIR)/src && $(TAR) xf -); \
 	  fi; \
 	done
--- jdk/make/common/Rules.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/Rules.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -51,7 +51,7 @@
 #
 # All source tree areas for java/properties files (a few may be closed)
 #
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
   ifdef OPENJDK
     ALL_CLASSES_SRC = $(call JavaSrcDirList,,classes)
   else
@@ -212,7 +212,7 @@
 $(CLASSDESTDIR)/%.class: $(GENSRCDIR)/%.java
 	@$(add-java-file)
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 # TODO(cpc): need to document why this is necessary...
 $(CLASSDESTDIR)/%.class: $(JDK_TOPDIR)/src/macosx/classes/%.java
 	@$(add-java-file)
--- jdk/make/common/shared/Compiler-gcc.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/shared/Compiler-gcc.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -72,6 +72,21 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+
+  # Settings specific to BSD
+  CC             = $(COMPILER_PATH)gcc
+  CPP            = $(COMPILER_PATH)gcc -E
+  CXX            = $(COMPILER_PATH)g++
+
+  # Option used to create a shared library
+  ifeq ($(OS_VENDOR), Apple)
+    SHARED_LIBRARY_FLAG = -dynamiclib 
+  else
+    SHARED_LIBRARY_FLAG = -shared
+  endif
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- jdk/make/common/shared/Defs-bsd.gmk	1969-12-31 16:00:00.000000000 -0800
+++ jdk/make/common/shared/Defs-bsd.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -0,0 +1,262 @@
+#
+# Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+#
+# Definitions for BSD.
+#
+
+# Default for COMPILER_WARNINGS_FATAL on BSD (C & C++ compiler warnings)
+ifndef COMPILER_WARNINGS_FATAL
+  COMPILER_WARNINGS_FATAL=false
+endif
+
+# BSD should use parallel compilation for best build times
+ifndef COMPILE_APPROACH
+  COMPILE_APPROACH = parallel
+endif
+
+# Indication that we are doing an incremental build.
+#    This may trigger the creation of make depend files.
+ifndef INCREMENTAL_BUILD
+  INCREMENTAL_BUILD = false
+endif
+
+# FullPath just makes sure it never ends with a / and no duplicates
+define FullPath
+$(shell cd $1 2> $(DEV_NULL) && pwd)
+endef
+
+# OptFullPath: Absolute path name of a dir that might not initially exist.
+define OptFullPath
+$(shell if [ "$1" != "" -a -d "$1" ]; then (cd $1 && pwd); else echo "$1"; fi)
+endef
+
+ifdef ALT_X11_PATH
+  X11_PATH = $(ALT_X11_PATH)
+else
+  ifeq ($(OS_VENDOR), NetBSD)
+    X11_PATH = /usr/X11R7
+  else
+    ifeq ($(OS_VENDOR), FreeBSD)
+      X11_PATH = /usr/local
+    else
+      X11_PATH = /usr/X11R6
+    endif
+  endif
+endif
+
+ifdef ALT_PACKAGE_PATH
+  PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+else
+  ifeq ($(OS_VENDOR), NetBSD)
+    PACKAGE_PATH = /usr/pkg
+  else
+    PACKAGE_PATH = /usr/local
+  endif
+endif
+
+# ALSA
+ifdef ALT_ALSA_LIB_PATH
+  ALSA_LIB_PATH = $(ALT_ALSA_LIB_PATH)
+else
+  ALSA_LIB_PATH = $(PACKAGE_PATH)/lib
+endif
+
+ifdef ALT_ALSA_HEADERS_PATH
+  ALSA_HEADERS_PATH = $(ALT_ALSA_HEADERS_PATH)
+else
+  ALSA_HEADERS_PATH = $(PACKAGE_PATH)/include
+endif
+
+# Location on system where jdk installs might be
+USRJDKINSTANCES_PATH = $(PACKAGE_PATH)
+
+# UNIXCOMMAND_PATH: path to where the most common Unix commands are.
+#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
+ifneq "$(origin ALT_UNIXCOMMAND_PATH)" "undefined"
+  UNIXCOMMAND_PATH :=$(call PrefixPath,$(ALT_UNIXCOMMAND_PATH))
+else
+  UNIXCOMMAND_PATH  = /bin/
+endif
+
+# USRBIN_PATH: path to where the most common Unix commands are.
+#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
+ifneq "$(origin ALT_USRBIN_PATH)" "undefined"
+  USRBIN_PATH :=$(call PrefixPath,$(ALT_USRBIN_PATH))
+else
+  USRBIN_PATH  = /usr/bin/
+endif
+
+# UNIXCCS_PATH: path to where the Solaris ported UNIX commands can be found
+#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
+ifneq "$(origin ALT_UNIXCCS_PATH)" "undefined"
+  UNIXCCS_PATH :=$(call PrefixPath,$(ALT_UNIXCCS_PATH))
+else
+  UNIXCCS_PATH = /usr/ccs/bin/
+endif
+
+# SLASH_JAVA: location of all network accessable files
+ifdef ALT_SLASH_JAVA
+  SLASH_JAVA  :=$(ALT_SLASH_JAVA)
+else
+  SLASH_JAVA  := $(call DirExists,/java,/java,/NOT-SET)
+endif
+
+# JDK_DEVTOOLS_DIR: common path for all the java devtools
+ifdef ALT_JDK_DEVTOOLS_DIR
+  JDK_DEVTOOLS_DIR  =$(ALT_JDK_DEVTOOLS_DIR)
+else
+  JDK_DEVTOOLS_DIR =$(SLASH_JAVA)/devtools
+endif
+
+# COMPILER_PATH: path to where the compiler and tools are installed.
+#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
+ifneq "$(origin ALT_COMPILER_PATH)" "undefined"
+  COMPILER_PATH :=$(call PrefixPath,$(ALT_COMPILER_PATH))
+else
+  COMPILER_PATH  =/usr/bin/
+endif
+
+# OPENWIN_HOME: path to where the X11 environment is installed.
+#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
+ifneq ($(ALT_OPENWIN_HOME),)
+  OPENWIN_HOME :=$(call PrefixPath,$(ALT_OPENWIN_HOME))
+else
+  OPENWIN_HOME  =$(X11_PATH)
+endif
+
+# DEVTOOLS_PATH: for other tools required for building (such as zip, etc.)
+#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
+ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
+  DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
+else
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
+endif
+
+# _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
+# _BOOTDIR2: Second choice
+ifndef ALT_BOOTDIR
+  _BOOTDIR1  =$(SLASH_JAVA)/re/jdk/$(PREVIOUS_JDK_VERSION)/archive/fcs/binaries/$(PLATFORM)-$(ARCH)
+  _BOOTDIR2  =$(USRJDKINSTANCES_PATH)/jdk$(PREVIOUS_JDK_VERSION)
+endif
+
+# Always build headless on BSD
+BUILD_HEADLESS = true
+LIBM=-lm
+
+_CUPS_HEADERS_PATH=$(PACKAGE_PATH)/include
+
+# Import JDK images allow for partial builds, components not built are
+#    imported (or copied from) these import areas when needed.
+
+# BUILD_JDK_IMPORT_PATH: location of JDK install trees to import for 
+#   multiple platforms, e.g. windows-i586, solaris-sparc, linux-586, etc.
+ifdef ALT_BUILD_JDK_IMPORT_PATH
+  BUILD_JDK_IMPORT_PATH  :=$(call FullPath,$(ALT_BUILD_JDK_IMPORT_PATH))
+else
+  BUILD_JDK_IMPORT_PATH   = $(PROMOTED_BUILD_BINARIES)
+endif
+BUILD_JDK_IMPORT_PATH:=$(call AltCheckValue,BUILD_JDK_IMPORT_PATH)
+
+# JDK_IMPORT_PATH: location of JDK install tree (this version) to import
+ifdef ALT_JDK_IMPORT_PATH
+  JDK_IMPORT_PATH  :=$(call FullPath,$(ALT_JDK_IMPORT_PATH))
+else
+  JDK_IMPORT_PATH   = $(BUILD_JDK_IMPORT_PATH)/$(PLATFORM)-$(ARCH)$(_JDK_IMPORT_VARIANT)
+endif
+JDK_IMPORT_PATH:=$(call AltCheckValue,JDK_IMPORT_PATH)
+
+# HOTSPOT_IMPORT_PATH: location of hotspot pre-built files
+ifdef ALT_HOTSPOT_IMPORT_PATH
+  HOTSPOT_IMPORT_PATH :=$(call FullPath,$(ALT_HOTSPOT_IMPORT_PATH))
+else
+  HOTSPOT_IMPORT_PATH =$(JDK_IMPORT_PATH)
+endif
+HOTSPOT_IMPORT_PATH:=$(call AltCheckValue,HOTSPOT_IMPORT_PATH)
+
+# HOTSPOT_CLIENT_PATH: location of client jvm library file.
+ifeq ($(ARCH_DATA_MODEL), 32)
+  ifdef ALT_HOTSPOT_CLIENT_PATH
+    HOTSPOT_CLIENT_PATH :=$(call FullPath,$(ALT_HOTSPOT_CLIENT_PATH))
+  else
+    HOTSPOT_CLIENT_PATH   =$(HOTSPOT_IMPORT_PATH)/$(ARCH_VM_SUBDIR)/client
+  endif
+  HOTSPOT_CLIENT_PATH:=$(call AltCheckValue,HOTSPOT_CLIENT_PATH)
+endif
+
+# HOTSPOT_SERVER_PATH: location of server jvm library file.
+ifdef ALT_HOTSPOT_SERVER_PATH
+  HOTSPOT_SERVER_PATH :=$(call FullPath,$(ALT_HOTSPOT_SERVER_PATH))
+else
+  HOTSPOT_SERVER_PATH   =$(HOTSPOT_IMPORT_PATH)/$(ARCH_VM_SUBDIR)/server
+endif
+HOTSPOT_SERVER_PATH:=$(call AltCheckValue,HOTSPOT_SERVER_PATH)
+
+# Special define for checking the binaries
+
+# Debug builds should downgrade warnings to just info
+MAPFILE_WARNING-DBG=INFO
+MAPFILE_WARNING-OPT=WARNING
+MAPFILE_WARNING-=WARNING
+MAPFILE_WARNING=$(MAPFILE_WARNING-$(VARIANT))
+
+# Macro to check it's input file for banned dependencies and verify the
+#   binary built properly. Relies on process exit code.
+ifndef CROSS_COMPILE_ARCH
+ifeq ($(OS_VENDOR), OpenBSD)
+define binary_file_verification # binary_file
+( \
+  $(ECHO) "Checking for mapfile use in: $1" && \
+  if [ "`$(OBJDUMP) -T $1 | $(EGREP) '[0-9a-f]* g *DF \.text.*SUNWprivate'`" = "" ] ; then \
+    $(ECHO) "$(MAPFILE_WARNING): File was not built with a mapfile: $1"; \
+ fi && \
+  $(ECHO) "Library loads for: $1" && \
+  $(LDD) $1 && \
+  $(ECHO) "RUNPATH for: $1" && \
+  ( $(READELF) -d $1 | $(EGREP) 'NEEDED|RUNPATH|RPATH' ) \
+) || true
+endef
+else
+define binary_file_verification # binary_file
+( \
+  $(ECHO) "Checking for mapfile use in: $1" && \
+  if [ "`$(NM) -D -g --defined-only $1 | $(EGREP) 'SUNWprivate'`" = "" ] ; then \
+    $(ECHO) "$(MAPFILE_WARNING): File was not built with a mapfile: $1"; \
+  fi && \
+  $(ECHO) "Library loads for: $1" && \
+  $(LDD) $1 && \
+  $(ECHO) "RUNPATH for: $1" && \
+  ( $(READELF) -d $1 | $(EGREP) 'NEEDED|RUNPATH|RPATH' ) \
+)
+endef
+endif
+else
+define binary_file_verification 
+( \
+  $(ECHO) "Skipping binary file verification for cross-compile build" \
+)
+endef
+endif
+
--- jdk/make/common/shared/Defs-utils.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/shared/Defs-utils.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -74,6 +74,13 @@
   UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 # Utilities
 ifdef CROSS_COMPILE_ARCH
   AR             = $(COMPILER_PATH)ar
@@ -251,3 +258,35 @@
   # Builtin shell command, no -e option needed
   ECHO         = echo
 endif
+
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), OpenBSD)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    OBJDUMP    = $(UTILS_USR_BIN_PATH)objdump
+  else
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+  ifeq ($(OS_VENDOR), NetBSD)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    ZIPEXE     = $(UTILS_DEVTOOL_PATH)zip
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+endif
--- jdk/make/common/shared/Defs-versions.gmk	2012-08-10 10:21:33.000000000 -0700
+++ jdk/make/common/shared/Defs-versions.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -44,6 +44,11 @@
   override CC_VERSION = gcc
 endif
 
+# BSD uses GNU compilers by default
+ifeq ($(PLATFORM), bsd)
+  override CC_VERSION = gcc
+endif
+
 # Mac OS X uses LLVM by default
 ifeq ($(PLATFORM), macosx)
   override CC_VERSION = llvm
@@ -169,6 +174,13 @@
   endif
 endif
 
+# BSD specific
+ifeq ($(PLATFORM), macosx)
+  REQUIRED_COMPILER_NAME      = GCC4
+  REQUIRED_COMPILER_VERSION   = GCC4
+  REQUIRED_CC_VER             = 4.2.1
+endif
+
 # Mac specific
 ifeq ($(PLATFORM), macosx)
   REQUIRED_OS_NAME            = Darwin
--- jdk/make/common/shared/Defs.gmk	2012-08-10 10:21:34.000000000 -0700
+++ jdk/make/common/shared/Defs.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -181,7 +181,7 @@
 # platform and shared sources/headers.  This is mainly useful for the
 # Mac OS X build, which pulls its platform sources from the solaris and/or
 # macosx trees, depending on the component.
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
   define JavaSrcDirList
   $(JAVA_SRCDIR_LIST:%=$1$(JDK_TOPDIR)/%/$2)
   endef
--- jdk/make/common/shared/Platform.gmk	2012-08-10 10:21:34.000000000 -0700
+++ jdk/make/common/shared/Platform.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -298,6 +298,85 @@
   # How much RAM does this machine have:
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+  REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.9
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                sparc64) \
+                    echo sparcv9 \
+                    ;; \
+                sparc*) \
+                    echo sparc \
+                    ;; \
+                x86_64) \
+                    echo amd64 \
+                    ;; \
+                "Power Macintosh") \
+                    echo ppc \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586, sparc, and ppc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc ppc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  ifeq ($(OS_VENDOR), OpenBSD)
+    MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+  else
+    MB_OF_MEMORY=$(shell (sysctl -n hw.physmem64 2> /dev/null || sysctl -n hw.physmem) | awk '{print int($$NF / 1048576); }' )
+  endif
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
--- jdk/make/java/Makefile	2012-08-10 10:21:34.000000000 -0700
+++ jdk/make/java/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -53,7 +53,7 @@
   endif
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   SUBDIRS += jexec
 endif # PLATFORM
 
--- jdk/make/java/instrument/Makefile	2012-08-10 10:21:34.000000000 -0700
+++ jdk/make/java/instrument/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -104,12 +104,24 @@
   # equivalent of strcasecmp is stricmp on Windows
   CPPFLAGS_COMMON += -Dstrcasecmp=stricmp
 else
-ifneq (,$(findstring $(PLATFORM), macosx))
-  ifneq ($(ARCH), universal)
-    LDFLAGS += -Wl,-all_load
+ifneq (,$(findstring $(PLATFORM), macosx bsd))
+  ifeq ($(OS_VENDOR), Apple)
+    ifneq ($(ARCH), universal)
+      LDFLAGS += -Wl,-all_load
+    endif
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    OTHER_LDLIBS += -liconv
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+    ifneq ($(OS_NAME), netbsd)
+# Use CPPFLAGS instead of OTHER_INCLUDES to force this last
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
   endif
-  LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
-  OTHER_LDLIBS += -liconv
+
   ifeq ($(SYSTEM_ZLIB), true)
     OTHER_LDLIBS += -lz
   endif
--- jdk/make/java/java/FILES_java.gmk	2012-08-10 10:21:34.000000000 -0700
+++ jdk/make/java/java/FILES_java.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -476,6 +476,7 @@
     sun/misc/MessageUtils.java \
     sun/misc/GC.java \
     sun/misc/Service.java \
+    sun/misc/JavaAWTAccess.java \
     sun/misc/JavaLangAccess.java \
     sun/misc/JavaIOAccess.java \
     sun/misc/JavaIOFileDescriptorAccess.java \
--- jdk/make/java/java/Makefile	2012-08-10 10:21:35.000000000 -0700
+++ jdk/make/java/java/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -175,9 +175,11 @@
 #
 ifneq ($(PLATFORM), windows)
 ifneq ($(PLATFORM), macosx)
+ifneq ($(PLATFORM), bsd)
 HAVE_ALTZONE=true
 endif
 endif
+endif
 
 ifeq ($(HAVE_ALTZONE),true)
 OTHER_CPPFLAGS += -DHAVE_ALTZONE
--- jdk/make/java/java/genlocales.gmk	2012-08-10 10:21:35.000000000 -0700
+++ jdk/make/java/java/genlocales.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -93,18 +93,66 @@
 
 else
 
+ifeq ($(PLATFORM), bsd)
+
+$(LocaleDataMetaInfo_Dest):$(LocaleDataMetaInfo_Src) $(LOCALEGEN_SH)
+	@$(RM) $@.tmp.euro $@.tmp.noneuro;
+	@$(prep-target) 
+	@$(ECHO) $(Euro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.euro;
+	@$(ECHO) $(Euro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.euro;
+	@$(ECHO) $(NonEuro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.noneuro;
+	@$(ECHO) $(NonEuro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.noneuro;
+	NAWK="$(NAWK)" SED="$(SED)" SORT="$(SORT)" \
+	     $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
+		$@.tmp.noneuro $< $@
+	@$(RM) $@.tmp.euro $@.tmp.noneuro;
+
+else
+
+ifeq ($(PLATFORM), bsd)
+
+$(LocaleDataMetaInfo_Dest):$(LocaleDataMetaInfo_Src) $(LOCALEGEN_SH)
+	@$(RM) $@.tmp.euro $@.tmp.noneuro;
+	@$(prep-target) 
+	@$(ECHO) $(Euro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.euro;
+	@$(ECHO) $(Euro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.euro;
+	@$(ECHO) $(NonEuro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.noneuro;
+	@$(ECHO) $(NonEuro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.noneuro;
+	NAWK="$(NAWK)" SED="$(SED)" SORT="$(SORT)" \
+	     $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
+		$@.tmp.noneuro $< $@
+	@$(RM) $@.tmp.euro $@.tmp.noneuro;
+
+else
+
 $(LocaleDataMetaInfo_Dest):$(LocaleDataMetaInfo_Src) $(LOCALEGEN_SH)
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 	@$(prep-target) 
-	@$(ECHO) $(subst .properties,'\n',$(Euro_Resources_properties)) > $@.tmp.euro;
-	@$(ECHO) $(subst .java,'\n',$(Euro_Resources_java)) >> $@.tmp.euro;	
-	@$(ECHO) $(subst .properties,'\n',$(NonEuro_Resources_properties)) > $@.tmp.noneuro;
-	@$(ECHO) $(subst .java,'\n',$(NonEuro_Resources_java)) >> $@.tmp.noneuro;
+	@$(ECHO) $(Euro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.euro;
+	@$(ECHO) $(Euro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.euro;
+	@$(ECHO) $(NonEuro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.noneuro;
+	@$(ECHO) $(NonEuro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.noneuro;
 	NAWK="$(NAWK)" SED="$(SED)" SORT="$(SORT)" \
 	     $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
 		$@.tmp.noneuro $< $@
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 endif
+
+endif
+
+endif
 	
 genlocales : $(LocaleDataMetaInfo_Dest)  
 
--- jdk/make/java/jli/Makefile	2012-08-10 10:21:36.000000000 -0700
+++ jdk/make/java/jli/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -90,7 +90,8 @@
 
 # add platform specific files
 ifeq ($(PLATFORM), windows)
-  FILES_c += java_md.c
+  FILES_c += java_md.c \
+	     cmdtoargs.c
 else # NIXES
   FILES_c += java_md_common.c
   ifeq ($(PLATFORM), macosx)
@@ -116,9 +117,9 @@
   LIBARCH_DEFINES += -DLIBARCH64NAME='"$(LIBARCH64)"'
 endif # PLATFORM
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), macosx bsd))
   OTHER_CPPFLAGS += $(LIBARCH_DEFINES) -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
-else # ! MACOSX
+else # ! MACOSX || BSD
   OTHER_CPPFLAGS += $(LIBARCH_DEFINES)
 endif #PLATFORM
 
@@ -131,7 +132,7 @@
     # Note: it is important to keep this order, meaning -lc as the
     # last library, otherwise it could cause compatibility issues
     # by pulling in SUNW_private symbols from libc
-    LDLIBS = -ldl -lc
+    LDLIBS = $(LIBDL) -lc
     ifeq ($(USE_PTHREADS),true)
       LDLIBS += -lpthread
     endif # USE_PTHREADS 
@@ -149,7 +150,11 @@
               -export:JLI_ReportErrorMessage \
               -export:JLI_ReportErrorMessageSys \
               -export:JLI_ReportMessage \
-              -export:JLI_ReportExceptionDescription
+              -export:JLI_ReportExceptionDescription \
+              -export:JLI_MemAlloc \
+              -export:JLI_CmdToArgs \
+              -export:JLI_GetStdArgc \
+              -export:JLI_GetStdArgs
 endif # PLATFORM
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)
--- jdk/make/java/jli/mapfile-vers	2012-08-10 10:21:36.000000000 -0700
+++ jdk/make/java/jli/mapfile-vers	2013-05-05 09:38:27.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -35,9 +35,8 @@
 		JLI_ReportErrorMessageSys;
 		JLI_ReportMessage;
 		JLI_ReportExceptionDescription;
-#		JNI_CreateJavaVM;
-#		JNI_GetCreatedJavaVMs;
-#		JNI_GetDefaultJavaVMInitArgs;
+		JLI_GetStdArgs;
+		JLI_GetStdArgc;
 	local:
 		*;
 };
--- jdk/make/java/net/FILES_c.gmk	2012-08-10 10:21:36.000000000 -0700
+++ jdk/make/java/net/FILES_c.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -47,6 +47,10 @@
     FILES_c += bsd_close.c
 endif
 
+ifeq ($(OS_VENDOR), FreeBSD)
+    FILES_c += bsd_close.c
+endif
+
 ifeq ($(PLATFORM), windows)
     FILES_c += TwoStacksPlainSocketImpl.c
     FILES_c += DualStackPlainSocketImpl.c
--- jdk/make/java/net/Makefile	2012-08-10 10:21:36.000000000 -0700
+++ jdk/make/java/net/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -74,6 +74,7 @@
     FILES_export += java/net/DualStackPlainSocketImpl.java
     FILES_export += java/net/TwoStacksPlainDatagramSocketImpl.java
     FILES_export += java/net/DualStackPlainDatagramSocketImpl.java
+    FILES_export += sun/net/www/protocol/http/ntlm/NTLMAuthSequence.java
 else
     FILES_export += java/net/PlainDatagramSocketImpl.java
 endif
@@ -91,7 +92,7 @@
 
 include $(BUILDDIR)/common/Library.gmk
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), macosx bsd))
 ifdef DONT_ENABLE_IPV6
   OTHER_CFLAGS += -DDONT_ENABLE_IPV6
 endif
--- jdk/make/java/nio/Makefile	2012-08-10 10:21:36.000000000 -0700
+++ jdk/make/java/nio/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -260,7 +260,7 @@
 	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = linux
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_java += \
         sun/nio/ch/AbstractPollSelectorImpl.java \
 	sun/nio/ch/BsdAsynchronousChannelProvider.java \
@@ -331,7 +331,7 @@
 	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = bsd, macosx
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_java += \
     sun/nio/ch/KQueueSelectorProvider.java \
     sun/nio/ch/KQueueSelectorImpl.java \
@@ -339,6 +339,9 @@
 
 FILES_c += \
     KQueueArrayWrapper.c
+endif # PLATFORM = bsd, macosx
+
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 
 vpath %.c $(call NativeSrcDirList,,native/sun/nio/fs)
 vpath %.c $(call NativeSrcDirList,,native/sun/nio/ch)
@@ -381,7 +384,7 @@
 ifeq ($(PLATFORM), linux)
 OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -lpthread $(LIBDL)
 endif
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 OTHER_LDLIBS += -L$(LIBDIR) -ljava -lnet -pthread
 endif
 ifeq ($(PLATFORM), solaris)
@@ -406,7 +409,7 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 FILES_m = mapfile-bsd
 endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
--- jdk/make/java/nio/mapfile-bsd	2012-08-10 10:21:37.000000000 -0700
+++ jdk/make/java/nio/mapfile-bsd	2013-05-05 09:38:27.000000000 -0700
@@ -70,6 +70,7 @@
                 Java_sun_nio_ch_IOUtil_drain;
                 Java_sun_nio_ch_IOUtil_fdVal;
                 Java_sun_nio_ch_IOUtil_initIDs;
+                Java_sun_nio_ch_IOUtil_iovMax;
                 Java_sun_nio_ch_IOUtil_makePipe;
                 Java_sun_nio_ch_IOUtil_randomBytes;
                 Java_sun_nio_ch_IOUtil_setfdVal;
@@ -80,6 +81,11 @@
 		Java_sun_nio_ch_KQueue_identOffset;
 		Java_sun_nio_ch_KQueue_filterOffset;
 		Java_sun_nio_ch_KQueue_flagsOffset;
+		Java_sun_nio_ch_KQueueArrayWrapper_initStructSizes;
+		Java_sun_nio_ch_KQueueArrayWrapper_init;
+		Java_sun_nio_ch_KQueueArrayWrapper_register0;
+		Java_sun_nio_ch_KQueueArrayWrapper_kevent0;
+		Java_sun_nio_ch_KQueueArrayWrapper_interrupt;
 		Java_sun_nio_ch_KQueuePort_socketpair;
 		Java_sun_nio_ch_KQueuePort_interrupt;
 		Java_sun_nio_ch_KQueuePort_drain1;
--- jdk/make/java/npt/Makefile	2012-08-10 10:21:37.000000000 -0700
+++ jdk/make/java/npt/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -74,6 +74,14 @@
   OTHER_LDLIBS += -liconv
 endif
 
+# Add location of iconv headers
+ifeq ($(PLATFORM), bsd)
+  ifneq ($(OS_NAME), netbsd)
+    CPPFLAGS += -I$(PACKAGE_PATH)/include
+    OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+  endif
+endif
+
 #
 # Add to ambient vpath so we pick up the library files
 #
--- jdk/make/java/redist/fonts/Makefile	2012-08-10 10:21:37.000000000 -0700
+++ jdk/make/java/redist/fonts/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -42,7 +42,7 @@
 	$(LIBDIR)/fonts/LucidaSansRegular.ttf       	\
 	$(LIBDIR)/fonts/LucidaSansDemiBold.ttf       	\
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique versions of the font are derived from the base versions
 # and since 2D can do this derivation on the fly at run time there is no
@@ -82,7 +82,7 @@
 $(FONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.fonts.dir
 	$(install-file)
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique fonts are only needed/wanted on Linux.
 
@@ -96,7 +96,7 @@
 $(OBLFONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.oblique-fonts.dir
 	$(install-file)
 
-endif # linux
+endif # linux || bsd
 
 all build : $(INTERNAL_IMPORT_LIST)
 
--- jdk/make/javax/crypto/Defs-jce.gmk	2012-08-10 10:21:39.000000000 -0700
+++ jdk/make/javax/crypto/Defs-jce.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,7 @@
 JCE_MANIFEST_FILE    = $(TEMPDIR)/manifest.mf
 $(JCE_MANIFEST_FILE): $(MAINMANIFEST)
 	$(prep-target)
-	$(SED) -e "s#@@RELEASE@@#$(RELEASE)#"           \
+	$(SED) -e "s#@@RELEASE@@#$(JDK_VERSION)#"       \
                -e "s#@@COMPANY_NAME@@#$(COMPANY_NAME)#" \
                $(MAINMANIFEST) >> $@
 	$(ECHO) "Extension-Name: javax.crypto" >> $@
--- jdk/make/javax/sound/Makefile	2012-08-10 10:21:40.000000000 -0700
+++ jdk/make/javax/sound/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -111,6 +111,21 @@
   #MXSPP_ADD = $(PLATFORM)-$(ARCH)/
 endif # PLATFORM linux
 
+ifeq ($(PLATFORM), bsd)
+ifeq ($(OS_VENDOR), FreeBSD)
+  # ALSA handles directaudio, ports, and MIDI
+  SUBDIRS += jsoundalsa
+  EXTRA_SOUND_JNI_LIBS += jsoundalsa
+else
+    # build with empty MIDI i/o
+    INCLUDE_MIDI = TRUE
+    # build with empty ports
+    INCLUDE_PORTS = TRUE
+    # build with empty direct audio
+    INCLUDE_DAUDIO = TRUE
+endif
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), macosx)
   CPPFLAGS += -DUSE_PORTS=TRUE \
               -DUSE_DAUDIO=TRUE \
--- jdk/make/javax/sound/SoundDefs.gmk	2012-08-10 10:21:40.000000000 -0700
+++ jdk/make/javax/sound/SoundDefs.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -40,6 +40,10 @@
   CPPFLAGS += -DX_PLATFORM=X_LINUX
 endif # PLATFORM linux
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -DX_PLATFORM=X_BSD
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), macosx)
   CPPFLAGS += -DX_PLATFORM=X_MACOSX
 endif # PLATFORM macosx
--- jdk/make/javax/sound/jsoundalsa/Makefile	2012-08-10 10:21:40.000000000 -0700
+++ jdk/make/javax/sound/jsoundalsa/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -51,6 +51,7 @@
 	$(PORTFILES_c)
 
 # platform dependent files
+ifeq ($(PLATFORM), linux)
 FILES_c += \
 	PLATFORM_API_LinuxOS_ALSA_CommonUtils.c   \
 	PLATFORM_API_LinuxOS_ALSA_PCM.c     \
@@ -60,19 +61,37 @@
 	PLATFORM_API_LinuxOS_ALSA_MidiUtils.c \
 	PLATFORM_API_LinuxOS_ALSA_Ports.c
 
+MIDI_CPPFLAGS= \
+	-DUSE_PLATFORM_MIDI_OUT=TRUE \
+	-DUSE_PLATFORM_MIDI_IN=TRUE
+endif
+
+ifeq ($(PLATFORM), bsd)
+FILES_c += \
+	PLATFORM_API_BsdOS_ALSA_CommonUtils.c   \
+	PLATFORM_API_BsdOS_ALSA_PCM.c     \
+	PLATFORM_API_BsdOS_ALSA_PCMUtils.c   \
+	PLATFORM_API_BsdOS_ALSA_MidiIn.c  \
+	PLATFORM_API_BsdOS_ALSA_MidiOut.c \
+	PLATFORM_API_BsdOS_ALSA_MidiUtils.c \
+	PLATFORM_API_BsdOS_ALSA_Ports.c
+
+MIDI_CPPFLAGS=
+endif
+
 FILES_export = \
 	$(DAUDIOFILES_export) \
 	$(MIDIFILES_export) \
 	$(PORTFILES_export)
 
-OTHER_LDLIBS += -lasound
+OTHER_LDLIBS += -L$(ALSA_LIB_PATH) -lasound
 
 CPPFLAGS += \
 	-DUSE_DAUDIO=TRUE \
 	-DUSE_PORTS=TRUE  \
-	-DUSE_PLATFORM_MIDI_OUT=TRUE \
-	-DUSE_PLATFORM_MIDI_IN=TRUE \
-	-I$(SHARE_SRC)/native/com/sun/media/sound
+	$(MIDI_CPPFLAGS) \
+	-I$(SHARE_SRC)/native/com/sun/media/sound \
+	-I$(ALSA_HEADERS_PATH)
 
 #
 # Add to the ambient VPATH.
--- jdk/make/jpda/transport/socket/Makefile	2012-08-10 10:21:40.000000000 -0700
+++ jdk/make/jpda/transport/socket/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -38,6 +38,11 @@
 
 include $(BUILDDIR)/common/Defs.gmk
 
+ifeq ($(PLATFORM), bsd))
+  LIBSOCKET =
+  OTHER_LDLIBS += -pthread
+endif
+
 ifeq ($(PLATFORM), linux)
   OTHER_LDLIBS += $(LIBNSL) $(LIBSOCKET) -lpthread
 endif
--- jdk/make/sun/awt/Makefile	2012-08-10 10:21:49.000000000 -0700
+++ jdk/make/sun/awt/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -123,7 +123,12 @@
 OTHER_LDLIBS = $(JVMLIB) $(LIBM) $(LIBDL)
 endif
 
-FILES_c += initIDs.c
+ifeq  ($(PLATFORM), bsd)
+FILES_c = $(FILES_2D_c)
+FILES_c += awt_LoadLibrary.c
+OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
+OTHER_LDLIBS = $(JVMLIB) $(LIBM)
+endif
 
 ifeq ($(PLATFORM), macosx)
 FILES_c = $(FILES_2D_c)
@@ -132,6 +137,8 @@
 OTHER_LDLIBS = $(JVMLIB) $(LIBM)
 endif
 
+FILES_c += initIDs.c
+
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS/LINUX
 endif # PLATFORM 
 
@@ -425,6 +432,17 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS
 endif # PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BSD
+
+FONTCONFIGS_SRC = $(PLATFORM_SRC)/classes/sun/awt/fontconfigs
+_FONTCONFIGS   = \
+	fontconfig.properties
+
+FONTCONFIGS_SRC_PREFIX = $(PLATFORM).
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ BSD
+endif # PLATFORM
 
 ifeq ($(PLATFORM), macosx)
 # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv MAC OS X
@@ -530,6 +548,9 @@
             -I$(OPENWIN_HOME)/include/X11/extensions \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
 endif
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/font
+endif
 CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/../font \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../font \
@@ -551,7 +572,13 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR) \
 	    $(EVENT_MODEL)
 
-ifeq ($(PLATFORM), linux)
+# include these last so we don't pick up unintentional includes
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(OPENWIN_HOME)/include \
+	    -I$(OPENWIN_HOME)/include/X11/extensions
+endif
+
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 LDFLAGS += -L$(OPENWIN_LIB)
 endif
 
--- jdk/make/sun/awt/mawt.gmk	2012-08-10 10:21:49.000000000 -0700
+++ jdk/make/sun/awt/mawt.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -169,7 +169,7 @@
 OTHER_LDLIBS = -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
 endif
 
-ifneq (,$(findstring $(PLATFORM), linux macosx))
+ifneq (,$(findstring $(PLATFORM), bsd linux macosx))
 OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
 # XXX what is this define below? Isn't it motif-related?
 OTHER_CFLAGS += -DXMSTRINGDEFINES=1
@@ -193,6 +193,7 @@
 #
 # Other extra flags needed for compiling.
 #
+ifneq ($(PLATFORM), bsd))
 CPPFLAGS += -I$(CUPS_HEADERS_PATH)
 
 ifndef HEADLESS
@@ -200,6 +201,7 @@
 LDFLAGS  += -L$(OPENWIN_LIB)
 
 endif # !HEADLESS
+endif # !PLATFORM
 
 CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/../font \
@@ -223,13 +225,16 @@
         -I$(PLATFORM_SRC)/native/$(PKGDIR) \
         $(EVENT_MODEL)
 
-ifeq ($(PLATFORM), macosx)
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 CPPFLAGS += -I$(CUPS_HEADERS_PATH)
 
 ifndef HEADLESS
 CPPFLAGS += -I$(MOTIF_DIR)/include \
             -I$(OPENWIN_HOME)/include 
 LDFLAGS  += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
+ifeq ($(OS_NAME), netbsd)
+LDFLAGS  += -Wl,-R$(OPENWIN_LIB)
+endif
 
 endif # !HEADLESS
 endif # PLATFORM
@@ -240,6 +245,12 @@
                         $(wildcard /usr/include/X11/extensions))
 endif
 
+ifeq ($(PLATFORM), bsd))
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
+              -I$(OPENWIN_HOME)/include \
+              -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
+
 ifeq ($(PLATFORM), macosx))
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
               -I$(OPENWIN_HOME)/include 
--- jdk/make/sun/font/FILES_c.gmk	2012-08-10 10:21:49.000000000 -0700
+++ jdk/make/sun/font/FILES_c.gmk	2013-05-05 09:38:27.000000000 -0700
@@ -106,7 +106,21 @@
         OpenTypeLayoutEngine.cpp \
         ThaiLayoutEngine.cpp \
         ScriptAndLanguageTags.cpp \
-        FontInstanceAdapter.cpp
+        FontInstanceAdapter.cpp \
+        ContextualGlyphInsertionProc2.cpp \
+        ContextualGlyphSubstProc2.cpp \
+        GXLayoutEngine2.cpp \
+        IndicRearrangementProcessor2.cpp \
+        LigatureSubstProc2.cpp \
+        MorphTables2.cpp \
+        NonContextualGlyphSubstProc2.cpp \
+        SegmentArrayProcessor2.cpp \
+        SegmentSingleProcessor2.cpp \
+        SimpleArrayProcessor2.cpp \
+        SingleTableProcessor2.cpp \
+        StateTableProcessor2.cpp \
+        SubtableProcessor2.cpp \
+        TrimmedArrayProcessor2.cpp
 
 
 ifeq ($(PLATFORM),windows)
--- jdk/make/sun/font/Makefile	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/font/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -91,7 +91,7 @@
 endif # PLATFORM
 
 # Turn off aliasing with GCC for ExtensionSubtables.cpp
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), bsd linux))
   CXXFLAGS += $(CXXFLAGS_$(@F))
   CXXFLAGS_ExtensionSubtables.o = -fno-strict-aliasing
 endif
@@ -178,7 +178,7 @@
 # Libraries to link, and other C flags.
 #
 
-ifeq ($(PLATFORM), macosx))
+ifneq (,$(findstring $(PLATFORM), bsd macosx))
 OTHER_INCLUDES += -I$(X11_PATH)/include
 OTHER_LDLIBS  += -lawt $(LIBM) $(LIBCXX)
  ifeq ($(OS_VENDOR),Apple)
--- jdk/make/sun/javazic/tzdata/VERSION	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/VERSION	2013-05-05 09:38:27.000000000 -0700
@@ -21,4 +21,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-tzdata2012c
+tzdata2012i
--- jdk/make/sun/javazic/tzdata/africa	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/africa	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)africa	8.35
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -261,7 +260,7 @@
 # I received a mail from an airline which says that the daylight
 # saving time in Egypt will end in the night of 2007-09-06 to 2007-09-07.
 # From Jesper Norgaard Welen (2007-08-15): [The following agree:]
-# http://www.nentjes.info/Bill/bill5.htm 
+# http://www.nentjes.info/Bill/bill5.htm
 # http://www.timeanddate.com/worldclock/city.html?n=53
 # From Steffen Thorsen (2007-09-04): The official information...:
 # http://www.sis.gov.eg/En/EgyptOnline/Miscellaneous/000002/0207000000000000001580.htm
@@ -315,18 +314,18 @@
 # in September.
 
 # From Steffen Thorsen (2009-08-11):
-# We have been able to confirm the August change with the Egyptian Cabinet 
+# We have been able to confirm the August change with the Egyptian Cabinet
 # Information and Decision Support Center:
 # <a href="http://www.timeanddate.com/news/time/egypt-dst-ends-2009.html">
 # http://www.timeanddate.com/news/time/egypt-dst-ends-2009.html
 # </a>
-# 
+#
 # The Middle East News Agency
 # <a href="http://www.mena.org.eg/index.aspx">
 # http://www.mena.org.eg/index.aspx
 # </a>
 # also reports "Egypt starts winter time on August 21"
-# today in article numbered "71, 11/08/2009 12:25 GMT." 
+# today in article numbered "71, 11/08/2009 12:25 GMT."
 # Only the title above is available without a subscription to their service,
 # and can be found by searching for "winter" in their search engine
 # (at least today).
@@ -505,7 +504,7 @@
 # From Steffen Thorsen (2008-06-25):
 # Mauritius plans to observe DST from 2008-11-01 to 2009-03-31 on a trial
 # basis....
-# It seems that Mauritius observed daylight saving time from 1982-10-10 to 
+# It seems that Mauritius observed daylight saving time from 1982-10-10 to
 # 1983-03-20 as well, but that was not successful....
 # http://www.timeanddate.com/news/time/mauritius-daylight-saving-time.html
 
@@ -529,12 +528,12 @@
 # than previously announced (2008-11-01 to 2009-03-31).  The new start
 # date is 2008-10-26 at 02:00 and the new end date is 2009-03-27 (no time
 # given, but it is probably at either 2 or 3 wall clock time).
-# 
-# A little strange though, since the article says that they moved the date 
-# to align itself with Europe and USA which also change time on that date, 
-# but that means they have not paid attention to what happened in 
-# USA/Canada last year (DST ends first Sunday in November). I also wonder 
-# why that they end on a Friday, instead of aligning with Europe which 
+#
+# A little strange though, since the article says that they moved the date
+# to align itself with Europe and USA which also change time on that date,
+# but that means they have not paid attention to what happened in
+# USA/Canada last year (DST ends first Sunday in November). I also wonder
+# why that they end on a Friday, instead of aligning with Europe which
 # changes two days later.
 
 # From Alex Krivenyshev (2008-07-11):
@@ -593,7 +592,7 @@
 # </a>
 
 # From Arthur David Olson (2009-07-11):
-# The "mauritius-dst-will-not-repeat" wrapup includes this: 
+# The "mauritius-dst-will-not-repeat" wrapup includes this:
 # "The trial ended on March 29, 2009, when the clocks moved back by one hour
 # at 2am (or 02:00) local time..."
 
@@ -687,8 +686,8 @@
 # XXX--guess that it is only Morocco for now; guess only 2008 for now.
 
 # From Steffen Thorsen (2008-08-27):
-# Morocco will change the clocks back on the midnight between August 31 
-# and September 1. They originally planned to observe DST to near the end 
+# Morocco will change the clocks back on the midnight between August 31
+# and September 1. They originally planned to observe DST to near the end
 # of September:
 #
 # One article about it (in French):
@@ -822,6 +821,23 @@
 # "...&agrave; partir du dernier dimance d'avril et non fins mars,
 # comme annonc&eacute; pr&eacute;c&eacute;demment."
 
+# From Milamber Space Network (2012-07-17):
+# The official return to GMT is announced by the Moroccan government:
+# <a href="http://www.mmsp.gov.ma/fr/actualites.aspx?id=288">
+# http://www.mmsp.gov.ma/fr/actualites.aspx?id=288 [in French]
+# </a>
+#
+# Google translation, lightly edited:
+# Back to the standard time of the Kingdom (GMT)
+# Pursuant to Decree No. 2-12-126 issued on 26 Jumada (I) 1433 (April 18,
+# 2012) and in accordance with the order of Mr. President of the
+# Government No. 3-47-12 issued on 24 Sha'ban (11 July 2012), the Ministry
+# of Public Service and Administration Modernization announces the return
+# of the legal time of the Kingdom (GMT) from Friday, July 20, 2012 until
+# Monday, August 20, 2012.  So the time will be delayed by 60 minutes from
+# 3:00 am Friday, July 20, 2012 and will again be advanced by 60 minutes
+# August 20, 2012 from 2:00 am.
+
 # RULE	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 
 Rule	Morocco	1939	only	-	Sep	12	 0:00	1:00	S
@@ -849,6 +865,8 @@
 Rule	Morocco	2011	only	-	Jul	 31	 0	0	-
 Rule	Morocco	2012	max	-	Apr	 lastSun 2:00	1:00	S
 Rule	Morocco	2012	max	-	Sep	 lastSun 3:00	0	-
+Rule	Morocco	2012	only	-	Jul	 20	 3:00	0	-
+Rule	Morocco	2012	only	-	Aug	 20	 2:00	1:00	S
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Africa/Casablanca	-0:30:20 -	LMT	1913 Oct 26
@@ -877,7 +895,7 @@
 # Forecasting Riaan van Zyl explained that the far eastern parts of
 # the country are close to 40 minutes earlier in sunrise than the rest
 # of the country.
-# 
+#
 # From Paul Eggert (2007-03-31):
 # Apparently the Caprivi Strip informally observes Botswana time, but
 # we have no details.  In the meantime people there can use Africa/Gaborone.
--- jdk/make/sun/javazic/tzdata/antarctica	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/antarctica	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)antarctica	8.10
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/asia	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/asia	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)asia	8.73
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -125,7 +124,7 @@
 # From Alexander Krivenyshev (2012-02-10):
 # According to News Armenia, on Feb 9, 2012,
 # http://newsarmenia.ru/society/20120209/42609695.html
-# 
+#
 # The Armenia National Assembly adopted final reading of Amendments to the
 # Law "On procedure of calculation time on the territory of the Republic of
 # Armenia" according to which Armenia [is] abolishing Daylight Saving Time.
@@ -205,15 +204,15 @@
 # </a>
 
 # From A. N. M. Kamrus Saadat (2009-06-15):
-# Finally we've got the official mail regarding DST start time where DST start 
-# time is mentioned as Jun 19 2009, 23:00 from BTRC (Bangladesh 
-# Telecommunication Regulatory Commission). 
+# Finally we've got the official mail regarding DST start time where DST start
+# time is mentioned as Jun 19 2009, 23:00 from BTRC (Bangladesh
+# Telecommunication Regulatory Commission).
 #
 # No DST end date has been announced yet.
 
 # From Alexander Krivenyshev (2009-09-25):
-# Bangladesh won't go back to Standard Time from October 1, 2009, 
-# instead it will continue DST measure till the cabinet makes a fresh decision. 
+# Bangladesh won't go back to Standard Time from October 1, 2009,
+# instead it will continue DST measure till the cabinet makes a fresh decision.
 #
 # Following report by same newspaper-"The Daily Star Friday":
 # "DST change awaits cabinet decision-Clock won't go back by 1-hr from Oct 1"
@@ -227,8 +226,8 @@
 
 # From Steffen Thorsen (2009-10-13):
 # IANS (Indo-Asian News Service) now reports:
-# Bangladesh has decided that the clock advanced by an hour to make 
-# maximum use of daylight hours as an energy saving measure would 
+# Bangladesh has decided that the clock advanced by an hour to make
+# maximum use of daylight hours as an energy saving measure would
 # "continue for an indefinite period."
 #
 # One of many places where it is published:
@@ -256,7 +255,7 @@
 
 # From Alexander Krivenyshev (2010-03-22):
 # According to Bangladesh newspaper "The Daily Star,"
-# Cabinet cancels Daylight Saving Time 
+# Cabinet cancels Daylight Saving Time
 # <a href="http://www.thedailystar.net/newDesign/latest_news.php?nid=22817">
 # http://www.thedailystar.net/newDesign/latest_news.php?nid=22817
 # </a>
@@ -384,11 +383,11 @@
 # observing daylight saving time in 1986.
 #
 # From Thomas S. Mullaney (2008-02-11):
-# I think you're combining two subjects that need to treated 
-# separately: daylight savings (which, you're correct, wasn't 
-# implemented until the 1980s) and the unified time zone centered near 
-# Beijing (which was implemented in 1949). Briefly, there was also a 
-# "Lhasa Time" in Tibet and "Urumqi Time" in Xinjiang. The first was 
+# I think you're combining two subjects that need to treated
+# separately: daylight savings (which, you're correct, wasn't
+# implemented until the 1980s) and the unified time zone centered near
+# Beijing (which was implemented in 1949). Briefly, there was also a
+# "Lhasa Time" in Tibet and "Urumqi Time" in Xinjiang. The first was
 # ceased, and the second eventually recognized (again, in the 1980s).
 #
 # From Paul Eggert (2008-06-30):
@@ -525,7 +524,7 @@
 # as of 2009-10-28:
 # Year        Period
 # 1941        1 Apr to 30 Sep
-# 1942        Whole year 
+# 1942        Whole year
 # 1943        Whole year
 # 1944        Whole year
 # 1945        Whole year
@@ -616,16 +615,16 @@
 # From Arthur David Olson (2010-04-07):
 # Here's Google's translation of the table at the bottom of the "summert.htm" page:
 # Decade 	                                                    Name                      Start and end date
-# Republic of China 34 years to 40 years (AD 1945-1951 years) Summer Time               May 1 to September 30 
-# 41 years of the Republic of China (AD 1952)                 Daylight Saving Time      March 1 to October 31 
-# Republic of China 42 years to 43 years (AD 1953-1954 years) Daylight Saving Time      April 1 to October 31 
-# In the 44 years to 45 years (AD 1955-1956 years)            Daylight Saving Time      April 1 to September 30 
-# Republic of China 46 years to 48 years (AD 1957-1959)       Summer Time               April 1 to September 30 
-# Republic of China 49 years to 50 years (AD 1960-1961)       Summer Time               June 1 to September 30 
-# Republic of China 51 years to 62 years (AD 1962-1973 years) Stop Summer Time 
-# Republic of China 63 years to 64 years (1974-1975 AD)       Daylight Saving Time      April 1 to September 30 
-# Republic of China 65 years to 67 years (1976-1978 AD)       Stop Daylight Saving Time 
-# Republic of China 68 years (AD 1979)                        Daylight Saving Time      July 1 to September 30 
+# Republic of China 34 years to 40 years (AD 1945-1951 years) Summer Time               May 1 to September 30
+# 41 years of the Republic of China (AD 1952)                 Daylight Saving Time      March 1 to October 31
+# Republic of China 42 years to 43 years (AD 1953-1954 years) Daylight Saving Time      April 1 to October 31
+# In the 44 years to 45 years (AD 1955-1956 years)            Daylight Saving Time      April 1 to September 30
+# Republic of China 46 years to 48 years (AD 1957-1959)       Summer Time               April 1 to September 30
+# Republic of China 49 years to 50 years (AD 1960-1961)       Summer Time               June 1 to September 30
+# Republic of China 51 years to 62 years (AD 1962-1973 years) Stop Summer Time
+# Republic of China 63 years to 64 years (1974-1975 AD)       Daylight Saving Time      April 1 to September 30
+# Republic of China 65 years to 67 years (1976-1978 AD)       Stop Daylight Saving Time
+# Republic of China 68 years (AD 1979)                        Daylight Saving Time      July 1 to September 30
 # Republic of China since 69 years (AD 1980)                  Stop Daylight Saving Time
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
@@ -1194,15 +1193,15 @@
 #
 #	ftp://ftp.cs.huji.ac.il/pub/tz/announcements/2005+beyond.ps
 
-# From Paul Eggert (2005-02-22):
+# From Paul Eggert (2012-10-26):
 # I used Ephraim Silverberg's dst-israel.el program
 # <ftp://ftp.cs.huji.ac.il/pub/tz/software/dst-israel.el> (2005-02-20)
 # along with Ed Reingold's cal-hebrew in GNU Emacs 21.4,
-# to generate the transitions in this list.
+# to generate the transitions from 2005 through 2012.
 # (I replaced "lastFri" with "Fri>=26" by hand.)
-# The spring transitions below all correspond to the following Rule:
+# The spring transitions all correspond to the following Rule:
 #
-# Rule	Zion	2005	max	-	Mar	Fri>=26	2:00	1:00	D
+# Rule	Zion	2005	2012	-	Mar	Fri>=26	2:00	1:00	D
 #
 # but older zic implementations (e.g., Solaris 8) do not support
 # "Fri>=26" to mean April 1 in years like 2005, so for now we list the
@@ -1219,39 +1218,36 @@
 Rule	Zion	2010	only	-	Sep	12	2:00	0	S
 Rule	Zion	2011	only	-	Apr	 1	2:00	1:00	D
 Rule	Zion	2011	only	-	Oct	 2	2:00	0	S
-Rule	Zion	2012	2015	-	Mar	Fri>=26	2:00	1:00	D
+Rule	Zion	2012	only	-	Mar	Fri>=26	2:00	1:00	D
 Rule	Zion	2012	only	-	Sep	23	2:00	0	S
-Rule	Zion	2013	only	-	Sep	 8	2:00	0	S
-Rule	Zion	2014	only	-	Sep	28	2:00	0	S
-Rule	Zion	2015	only	-	Sep	20	2:00	0	S
-Rule	Zion	2016	only	-	Apr	 1	2:00	1:00	D
-Rule	Zion	2016	only	-	Oct	 9	2:00	0	S
-Rule	Zion	2017	2021	-	Mar	Fri>=26	2:00	1:00	D
-Rule	Zion	2017	only	-	Sep	24	2:00	0	S
-Rule	Zion	2018	only	-	Sep	16	2:00	0	S
-Rule	Zion	2019	only	-	Oct	 6	2:00	0	S
-Rule	Zion	2020	only	-	Sep	27	2:00	0	S
-Rule	Zion	2021	only	-	Sep	12	2:00	0	S
-Rule	Zion	2022	only	-	Apr	 1	2:00	1:00	D
-Rule	Zion	2022	only	-	Oct	 2	2:00	0	S
-Rule	Zion	2023	2032	-	Mar	Fri>=26	2:00	1:00	D
-Rule	Zion	2023	only	-	Sep	24	2:00	0	S
-Rule	Zion	2024	only	-	Oct	 6	2:00	0	S
-Rule	Zion	2025	only	-	Sep	28	2:00	0	S
-Rule	Zion	2026	only	-	Sep	20	2:00	0	S
-Rule	Zion	2027	only	-	Oct	10	2:00	0	S
-Rule	Zion	2028	only	-	Sep	24	2:00	0	S
-Rule	Zion	2029	only	-	Sep	16	2:00	0	S
-Rule	Zion	2030	only	-	Oct	 6	2:00	0	S
-Rule	Zion	2031	only	-	Sep	21	2:00	0	S
-Rule	Zion	2032	only	-	Sep	12	2:00	0	S
-Rule	Zion	2033	only	-	Apr	 1	2:00	1:00	D
-Rule	Zion	2033	only	-	Oct	 2	2:00	0	S
-Rule	Zion	2034	2037	-	Mar	Fri>=26	2:00	1:00	D
-Rule	Zion	2034	only	-	Sep	17	2:00	0	S
-Rule	Zion	2035	only	-	Oct	 7	2:00	0	S
-Rule	Zion	2036	only	-	Sep	28	2:00	0	S
-Rule	Zion	2037	only	-	Sep	13	2:00	0	S
+
+# From Ephraim Silverberg (2012-10-18):
+
+# Yesterday, the Interior Ministry Committee, after more than a year
+# past, approved sending the proposed June 2011 changes to the Time
+# Decree Law back to the Knesset for second and third (final) votes
+# before the upcoming elections on Jan. 22, 2013.  Hence, although the
+# changes are not yet law, they are expected to be so before February 2013.
+#
+# As of 2013, DST starts at 02:00 on the Friday before the last Sunday in March.
+# DST ends at 02:00 on the first Sunday after October 1, unless it occurs on the
+# second day of the Jewish Rosh Hashana holiday, in which case DST ends a day
+# later (i.e. at 02:00 the first Monday after October 2).
+# [Rosh Hashana holidays are factored in until 2100.]
+
+# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
+Rule	Zion	2013	max	-	Mar	Fri>=23	2:00	1:00	D
+Rule	Zion	2013	2026	-	Oct	Sun>=2	2:00	0	S
+Rule	Zion	2027	only	-	Oct	Mon>=3	2:00	0	S
+Rule	Zion	2028	max	-	Oct	Sun>=2	2:00	0	S
+# The following rules are commented out for now, as they break older
+# versions of zic that support only signed 32-bit timestamps, i.e.,
+# through 2038-01-19 03:14:07 UTC.
+#Rule	Zion	2028	2053	-	Oct	Sun>=2	2:00	0	S
+#Rule	Zion	2054	only	-	Oct	Mon>=3	2:00	0	S
+#Rule	Zion	2055	2080	-	Oct	Sun>=2	2:00	0	S
+#Rule	Zion	2081	only	-	Oct	Mon>=3	2:00	0	S
+#Rule	Zion	2082	max	-	Oct	Sun>=2	2:00	0	S
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Jerusalem	2:20:56 -	LMT	1880
@@ -1386,6 +1382,16 @@
 # From Arthur David Olson (2009-04-06):
 # We still have Jordan switching to DST on Thursdays in 2000 and 2001.
 
+# From Steffen Thorsen (2012-10-25):
+# Yesterday the government in Jordan announced that they will not
+# switch back to standard time this winter, so the will stay on DST
+# until about the same time next year (at least).
+# http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?NewsID=88950
+#
+# From Paul Eggert (2012-10-25):
+# For now, assume this is just a one-year measure.  If it becomes
+# permanent, we should move Jordan from EET to AST effective tomorrow.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Jordan	1973	only	-	Jun	6	0:00	1:00	S
 Rule	Jordan	1973	1975	-	Oct	1	0:00	0	-
@@ -1414,7 +1420,8 @@
 Rule	Jordan	2003	only	-	Oct	24	0:00s	0	-
 Rule	Jordan	2004	only	-	Oct	15	0:00s	0	-
 Rule	Jordan	2005	only	-	Sep	lastFri	0:00s	0	-
-Rule	Jordan	2006	max	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2006	2011	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2013	max	-	Oct	lastFri	0:00s	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Amman	2:23:44 -	LMT	1931
 			2:00	Jordan	EE%sT
@@ -1859,15 +1866,15 @@
 # shown 8 per cent higher consumption of electricity.
 
 # From Alex Krivenyshev (2008-05-15):
-# 
-# Here is an article that Pakistan plan to introduce Daylight Saving Time 
+#
+# Here is an article that Pakistan plan to introduce Daylight Saving Time
 # on June 1, 2008 for 3 months.
-# 
-# "... The federal cabinet on Wednesday announced a new conservation plan to help 
-# reduce load shedding by approving the closure of commercial centres at 9pm and 
-# moving clocks forward by one hour for the next three months. 
+#
+# "... The federal cabinet on Wednesday announced a new conservation plan to help
+# reduce load shedding by approving the closure of commercial centres at 9pm and
+# moving clocks forward by one hour for the next three months.
 # ...."
-# 
+#
 # <a href="http://www.worldtimezone.net/dst_news/dst_news_pakistan01.html">
 # http://www.worldtimezone.net/dst_news/dst_news_pakistan01.html
 # </a>
@@ -1927,7 +1934,7 @@
 # Government has decided to restore the previous time by moving the
 # clocks backward by one hour from October 1. A formal announcement to
 # this effect will be made after the Prime Minister grants approval in
-# this regard." 
+# this regard."
 # <a href="http://www.thenews.com.pk/updates.asp?id=87168">
 # http://www.thenews.com.pk/updates.asp?id=87168
 # </a>
@@ -2223,7 +2230,7 @@
 # <a href="http://www.maannews.net/eng/ViewDetails.aspx?ID=306795">
 # http://www.maannews.net/eng/ViewDetails.aspx?ID=306795
 # </a>
-# the clocks were set back one hour at 2010-08-11 00:00:00 local time in 
+# the clocks were set back one hour at 2010-08-11 00:00:00 local time in
 # Gaza and the West Bank.
 # Some more background info:
 # <a href="http://www.timeanddate.com/news/time/westbank-gaza-end-dst-2010.html">
@@ -2262,7 +2269,7 @@
 # The rules for Egypt are stolen from the `africa' file.
 
 # From Steffen Thorsen (2011-09-30):
-# West Bank did end Daylight Saving Time this morning/midnight (2011-09-30 
+# West Bank did end Daylight Saving Time this morning/midnight (2011-09-30
 # 00:00).
 # So West Bank and Gaza now have the same time again.
 #
@@ -2317,6 +2324,8 @@
 
 # From Arthur David Olson (2011-09-20):
 # 2011 transitions per http://www.timeanddate.com as of 2011-09-20.
+# From Paul Eggert (2012-10-12):
+# 2012 transitions per http://www.timeanddate.com as of 2012-10-12.
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Gaza	2:17:52	-	LMT	1900 Oct
@@ -2327,7 +2336,7 @@
 			2:00 Palestine	EE%sT	2011 Apr  2 12:01
 			2:00	1:00	EEST	2011 Aug  1
 			2:00	-	EET	2012 Mar 30
-			2:00	1:00	EEST	2012 Sep 28
+			2:00	1:00	EEST	2012 Sep 21 1:00
 			2:00	-	EET
 
 Zone	Asia/Hebron	2:20:23	-	LMT	1900 Oct
@@ -2342,7 +2351,7 @@
 			2:00	-	EET	2011 Aug 30
 			2:00	1:00	EEST	2011 Sep 30 3:00
 			2:00	-	EET	2012 Mar 30
-			2:00	1:00	EEST	2012 Sep 28 3:00
+			2:00	1:00	EEST	2012 Sep 21 1:00
 			2:00	-	EET
 
 # Paracel Is
@@ -2536,19 +2545,19 @@
 # having it between Wednesday and Thursday (two workdays in Syria) since the
 # weekend in Syria is not Saturday and Sunday, but Friday and Saturday. So now
 # it is implemented at midnight of the last workday before weekend...
-# 
+#
 # From Steffen Thorsen (2007-10-27):
 # Jesper Norgaard Welen wrote:
-# 
+#
 # > "Winter local time in Syria will be observed at midnight of Thursday 1
 # > November 2007, and the clock will be put back 1 hour."
-# 
+#
 # I found confirmation on this in this gov.sy-article (Arabic):
 # http://wehda.alwehda.gov.sy/_print_veiw.asp?FileName=12521710520070926111247
-# 
+#
 # which using Google's translate tools says:
-# Council of Ministers also approved the commencement of work on 
-# identifying the winter time as of Friday, 2/11/2007 where the 60th 
+# Council of Ministers also approved the commencement of work on
+# identifying the winter time as of Friday, 2/11/2007 where the 60th
 # minute delay at midnight Thursday 1/11/2007.
 Rule	Syria	2007	only	-	Nov	 Fri>=1	0:00	0	-
 
@@ -2614,8 +2623,8 @@
 # </a>
 
 # From Steffen Thorsen (2009-10-27):
-# The Syrian Arab News Network on 2009-09-29 reported that Syria will 
-# revert back to winter (standard) time on midnight between Thursday 
+# The Syrian Arab News Network on 2009-09-29 reported that Syria will
+# revert back to winter (standard) time on midnight between Thursday
 # 2009-10-29 and Friday 2009-10-30:
 # <a href="http://www.sana.sy/ara/2/2009/09/29/247012.htm">
 # http://www.sana.sy/ara/2/2009/09/29/247012.htm (Arabic)
--- jdk/make/sun/javazic/tzdata/australasia	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/australasia	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)australasia	8.30
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -307,9 +306,9 @@
 # </a>
 
 # From Alexander Krivenyshev (2010-10-24):
-# According to Radio Fiji and Fiji Times online, Fiji will end DST 3 
+# According to Radio Fiji and Fiji Times online, Fiji will end DST 3
 # weeks earlier than expected - on March 6, 2011, not March 27, 2011...
-# Here is confirmation from Government of the Republic of the Fiji Islands, 
+# Here is confirmation from Government of the Republic of the Fiji Islands,
 # Ministry of Information (fiji.gov.fj) web site:
 # <a href="http://www.fiji.gov.fj/index.php?option=com_content&view=article&id=2608:daylight-savings&catid=71:press-releases&Itemid=155">
 # http://www.fiji.gov.fj/index.php?option=com_content&view=article&id=2608:daylight-savings&catid=71:press-releases&Itemid=155
@@ -320,15 +319,15 @@
 # </a>
 
 # From Steffen Thorsen (2011-10-03):
-# Now the dates have been confirmed, and at least our start date 
+# Now the dates have been confirmed, and at least our start date
 # assumption was correct (end date was one week wrong).
 #
 # <a href="http://www.fiji.gov.fj/index.php?option=com_content&view=article&id=4966:daylight-saving-starts-in-fiji&catid=71:press-releases&Itemid=155">
 # www.fiji.gov.fj/index.php?option=com_content&view=article&id=4966:daylight-saving-starts-in-fiji&catid=71:press-releases&Itemid=155
 # </a>
 # which says
-# Members of the public are reminded to change their time to one hour in 
-# advance at 2am to 3am on October 23, 2011 and one hour back at 3am to 
+# Members of the public are reminded to change their time to one hour in
+# advance at 2am to 3am on October 23, 2011 and one hour back at 3am to
 # 2am on February 26 next year.
 
 # From Ken Rylander (2011-10-24)
@@ -345,15 +344,23 @@
 # The commencement of daylight saving will remain unchanged and start
 # on the  23rd of October, 2011.
 
+# From the Fiji Government Online Portal (2012-08-21) via Steffen Thorsen:
+# The Minister for Labour, Industrial Relations and Employment Mr Jone Usamate
+# today confirmed that Fiji will start daylight savings at 2 am on Sunday 21st
+# October 2012 and end at 3 am on Sunday 20th January 2013.
+# http://www.fiji.gov.fj/index.php?option=com_content&view=article&id=6702&catid=71&Itemid=155
+#
+# From Paul Eggert (2012-08-31):
+# For now, guess a pattern of the penultimate Sundays in October and January.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Fiji	1998	1999	-	Nov	Sun>=1	2:00	1:00	S
 Rule	Fiji	1999	2000	-	Feb	lastSun	3:00	0	-
 Rule	Fiji	2009	only	-	Nov	29	2:00	1:00	S
 Rule	Fiji	2010	only	-	Mar	lastSun	3:00	0	-
-Rule	Fiji	2010	only	-	Oct	24	2:00	1:00	S
+Rule	Fiji	2010	max	-	Oct	Sun>=18	2:00	1:00	S
 Rule	Fiji	2011	only	-	Mar	Sun>=1	3:00	0	-
-Rule	Fiji	2011	only	-	Oct	23	2:00	1:00	S
-Rule	Fiji	2012	only	-	Jan	22	3:00	0	-
+Rule	Fiji	2012	max	-	Jan	Sun>=18	3:00	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Pacific/Fiji	11:53:40 -	LMT	1915 Oct 26	# Suva
 			12:00	Fiji	FJ%sT	# Fiji Time
@@ -582,7 +589,7 @@
 
 # From David Zuelke (2011-05-09):
 # Subject: Samoa to move timezone from east to west of international date line
-# 
+#
 # <a href="http://www.morningstar.co.uk/uk/markets/newsfeeditem.aspx?id=138501958347963">
 # http://www.morningstar.co.uk/uk/markets/newsfeeditem.aspx?id=138501958347963
 # </a>
@@ -644,6 +651,23 @@
 # Although Samoa has used Daylight Saving Time in the 2010-2011 and 2011-2012
 # seasons, there is not yet any indication that this trend will continue on
 # a regular basis. For now, we have explicitly listed the transitions below.
+#
+# From Nicky (2012-09-10):
+# Daylight Saving Time commences on Sunday 30th September 2012 and
+# ends on Sunday 7th of April 2013.
+#
+# Please find link below for more information.
+# http://www.mcil.gov.ws/mcil_publications.html
+#
+# That publication also includes dates for Summer of 2013/4 as well
+# which give the impression of a pattern in selecting dates for the
+# future, so for now, we will guess this will continue.
+
+# Western Samoa
+# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
+Rule	WS	2012	max	-	Sep	lastSun	3:00	1	D
+Rule	WS	2012	max	-	Apr	Sun>=1	4:00	0	-
+# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Pacific/Apia	 12:33:04 -	LMT	1879 Jul  5
 			-11:26:56 -	LMT	1911
 			-11:30	-	SAMT	1950		# Samoa Time
@@ -651,8 +675,8 @@
 			-11:00	1:00	WSDT	2011 Apr 2 4:00
 			-11:00	-	WST	2011 Sep 24 3:00
 			-11:00	1:00	WSDT	2011 Dec 30
-			 13:00	1:00	WSDT	2012 Apr 1 4:00
-			 13:00	-	WST
+			 13:00	1:00	WSDT	2012 Apr Sun>=1 4:00
+			 13:00	WS	WS%sT
 
 # Solomon Is
 # excludes Bougainville, for which see Papua New Guinea
@@ -664,25 +688,25 @@
 #
 # From Gwillim Law (2011-12-29)
 # A correspondent informed me that Tokelau, like Samoa, will be skipping
-# December 31 this year, thereby changing its time zone from UTC-10 to
-# UTC+14. When I tried to verify this statement, I found a confirming
-# article in Time magazine online
-# <a href="http://www.time.com/time/world/article/0,8599,2103243,00.html">
-# (http://www.time.com/time/world/article/0,8599,2103243,00.html).
-# </a>
+# December 31 this year ...
 #
-# From Jonathan Leffler (2011-12-29)
-# Information from the BBC to the same effect:
-# <a href="http://www.bbc.co.uk/news/world-asia-16351377">
-# http://www.bbc.co.uk/news/world-asia-16351377
-# </a>
-#
-# Patch supplied by Tim Parenti (2011-12-29)
+# From Steffen Thorsen (2012-07-25)
+# ... we double checked by calling hotels and offices based in Tokelau asking
+# about the time there, and they all told a time that agrees with UTC+13....
+# Shanks says UTC-10 from 1901 [but] ... there is a good chance the change
+# actually was to UTC-11 back then.
+#
+# From Paul Eggert (2012-07-25)
+# A Google Books snippet of Appendix to the Journals of the House of
+# Representatives of New Zealand, Session 1948,
+# <http://books.google.com/books?id=ZaVCAQAAIAAJ>, page 65, says Tokelau
+# was "11 hours slow on G.M.T."  Go with Thorsen and assume Shanks & Pottenger
+# are off by an hour starting in 1901.
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Pacific/Fakaofo	-11:24:56 -	LMT	1901
-			-10:00	-	TKT 2011 Dec 30	# Tokelau Time
-			14:00	-	TKT
+			-11:00	-	TKT 2011 Dec 30	# Tokelau Time
+			13:00	-	TKT
 
 # Tonga
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
@@ -1363,22 +1387,22 @@
 # See "southeast Australia" above for 2008 and later.
 
 # From Steffen Thorsen (2009-04-28):
-# According to the official press release, South Australia's extended daylight 
-# saving period will continue with the same rules as used during the 2008-2009 
+# According to the official press release, South Australia's extended daylight
+# saving period will continue with the same rules as used during the 2008-2009
 # summer (southern hemisphere).
-# 
+#
 # From
 # <a href="http://www.safework.sa.gov.au/uploaded_files/DaylightDatesSet.pdf">
 # http://www.safework.sa.gov.au/uploaded_files/DaylightDatesSet.pdf
 # </a>
-# The extended daylight saving period that South Australia has been trialling 
+# The extended daylight saving period that South Australia has been trialling
 # for over the last year is now set to be ongoing.
-# Daylight saving will continue to start on the first Sunday in October each 
+# Daylight saving will continue to start on the first Sunday in October each
 # year and finish on the first Sunday in April the following year.
-# Industrial Relations Minister, Paul Caica, says this provides South Australia 
-# with a consistent half hour time difference with NSW, Victoria, Tasmania and 
+# Industrial Relations Minister, Paul Caica, says this provides South Australia
+# with a consistent half hour time difference with NSW, Victoria, Tasmania and
 # the ACT for all 52 weeks of the year...
-# 
+#
 # We have a wrap-up here:
 # <a href="http://www.timeanddate.com/news/time/south-australia-extends-dst.html">
 # http://www.timeanddate.com/news/time/south-australia-extends-dst.html
--- jdk/make/sun/javazic/tzdata/backward	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/backward	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)backward	8.11
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/etcetera	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/etcetera	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)etcetera	8.3
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/europe	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/europe	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)europe	8.41
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -598,12 +597,12 @@
 # According to Kremlin press service, Russian President Dmitry Medvedev
 # signed a federal law "On calculation of time" on June 9, 2011.
 # According to the law Russia is abolishing daylight saving time.
-# 
-# Medvedev signed a law "On the Calculation of Time" (in russian): 
+#
+# Medvedev signed a law "On the Calculation of Time" (in russian):
 # <a href="http://bmockbe.ru/events/?ID=7583">
 # http://bmockbe.ru/events/?ID=7583
 # </a>
-# 
+#
 # Medvedev signed a law on the calculation of the time (in russian):
 # <a href="http://www.regnum.ru/news/polit/1413906.html">
 # http://www.regnum.ru/news/polit/1413906.html
@@ -1711,7 +1710,7 @@
 # From Alexander Krivenyshev (2011-10-26)
 # NO need to divide Moldova into two timezones at this point.
 # As of today, Transnistria (Pridnestrovie)- Tiraspol reversed its own
-# decision to abolish DST this winter. 
+# decision to abolish DST this winter.
 # Following Moldova and neighboring Ukraine- Transnistria (Pridnestrovie)-
 # Tiraspol will go back to winter time on October 30, 2011.
 # News from Moldova (in russian):
@@ -2601,11 +2600,11 @@
 # http://www.alomaliye.com/bkk_2002_3769.htm
 
 # From G&ouml;kdeniz Karada&#x011f; (2011-03-10):
-# 
+#
 # According to the articles linked below, Turkey will change into summer
 # time zone (GMT+3) on March 28, 2011 at 3:00 a.m. instead of March 27.
 # This change is due to a nationwide exam on 27th.
-# 
+#
 # <a href="http://www.worldbulletin.net/?aType=haber&ArticleID=70872">
 # http://www.worldbulletin.net/?aType=haber&ArticleID=70872
 # </a>
@@ -2722,7 +2721,7 @@
 # time this year after all.
 #
 # From Udo Schwedt (2011-10-18):
-# As far as I understand, the recent change to the Ukranian time zone 
+# As far as I understand, the recent change to the Ukranian time zone
 # (Europe/Kiev) to introduce permanent daylight saving time (similar
 # to Russia) was reverted today:
 #
--- jdk/make/sun/javazic/tzdata/factory	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/factory	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)factory	8.2
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/iso3166.tab	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/iso3166.tab	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)iso3166.tab	8.11
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 # ISO 3166 alpha-2 country codes
--- jdk/make/sun/javazic/tzdata/leapseconds	2012-08-10 10:21:50.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/leapseconds	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)leapseconds	8.13
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -101,8 +100,8 @@
 #
 #
 # A positive leap second will be introduced at the end of June 2012.
-# The sequence of dates of the UTC second markers will be:		
-# 		
+# The sequence of dates of the UTC second markers will be:
+#
 #                          2012 June 30,     23h 59m 59s
 #                          2012 June 30,     23h 59m 60s
 #                          2012 July  1,      0h  0m  0s
@@ -119,6 +118,6 @@
 #
 #
 # Daniel GAMBIS
-# Head		
+# Head
 # Earth Orientation Center of IERS
 # Observatoire de Paris, France
--- jdk/make/sun/javazic/tzdata/northamerica	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/northamerica	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)northamerica	8.54
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -502,7 +501,7 @@
 			 -8:00	US	P%sT	1946
 			 -8:00	-	PST	1969
 			 -8:00	US	P%sT	1980 Apr 27 2:00
-			 -9:00	US	Y%sT	1980 Oct 26 2:00	
+			 -9:00	US	Y%sT	1980 Oct 26 2:00
 			 -8:00	US	P%sT	1983 Oct 30 2:00
 			 -9:00	US	Y%sT	1983 Nov 30
 			 -9:00	US	AK%sT
@@ -1867,7 +1866,7 @@
 # Here is a summary of the three clock change events in Creston's history:
 # 1. 1884 or 1885: adoption of Mountain Standard Time (GMT-7)
 # Exact date unknown
-# 2. Oct 1916: switch to Pacific Standard Time (GMT-8) 
+# 2. Oct 1916: switch to Pacific Standard Time (GMT-8)
 # Exact date in October unknown;  Sunday October 1 is a reasonable guess.
 # 3. June 1918: switch to Pacific Daylight Time (GMT-7)
 # Exact date in June unknown; Sunday June 2 is a reasonable guess.
@@ -2697,20 +2696,20 @@
 # except that it switches at midnight standard time as usual.
 #
 # From Steffen Thorsen (2007-10-25):
-# Carlos Alberto Fonseca Arauz informed me that Cuba will end DST one week 
+# Carlos Alberto Fonseca Arauz informed me that Cuba will end DST one week
 # earlier - on the last Sunday of October, just like in 2006.
-# 
+#
 # He supplied these references:
-# 
+#
 # http://www.prensalatina.com.mx/article.asp?ID=%7B4CC32C1B-A9F7-42FB-8A07-8631AFC923AF%7D&language=ES
 # http://actualidad.terra.es/sociedad/articulo/cuba_llama_ahorrar_energia_cambio_1957044.htm
-# 
+#
 # From Alex Kryvenishev (2007-10-25):
 # Here is also article from Granma (Cuba):
-# 
+#
 # [Regira] el Horario Normal desde el [proximo] domingo 28 de octubre
 # http://www.granma.cubaweb.cu/2007/10/24/nacional/artic07.html
-# 
+#
 # http://www.worldtimezone.com/dst_news/dst_news_cuba03.html
 
 # From Arthur David Olson (2008-03-09):
@@ -2794,7 +2793,7 @@
 # </a>
 #
 # From Steffen Thorsen (2011-10-30)
-# Cuba will end DST two weeks later this year. Instead of going back 
+# Cuba will end DST two weeks later this year. Instead of going back
 # tonight, it has been delayed to 2011-11-13 at 01:00.
 #
 # One source (Spanish)
@@ -2806,11 +2805,11 @@
 # <a href="http://www.timeanddate.com/news/time/cuba-time-changes-2011.html">
 # http://www.timeanddate.com/news/time/cuba-time-changes-2011.html
 # </a>
-# 
+#
 # From Steffen Thorsen (2012-03-01)
-# According to Radio Reloj, Cuba will start DST on Midnight between March 
+# According to Radio Reloj, Cuba will start DST on Midnight between March
 # 31 and April 1.
-# 
+#
 # Radio Reloj has the following info (Spanish):
 # <a href="http://www.radioreloj.cu/index.php/noticias-radio-reloj/71-miscelaneas/7529-cuba-aplicara-el-horario-de-verano-desde-el-1-de-abril">
 # http://www.radioreloj.cu/index.php/noticias-radio-reloj/71-miscelaneas/7529-cuba-aplicara-el-horario-de-verano-desde-el-1-de-abril
@@ -2821,6 +2820,13 @@
 # http://www.timeanddate.com/news/time/cuba-starts-dst-2012.html
 # </a>
 
+# From Steffen Thorsen (2012-11-03):
+# Radio Reloj and many other sources report that Cuba is changing back
+# to standard time on 2012-11-04:
+# http://www.radioreloj.cu/index.php/noticias-radio-reloj/36-nacionales/9961-regira-horario-normal-en-cuba-desde-el-domingo-cuatro-de-noviembre
+# From Paul Eggert (2012-11-03):
+# For now, assume the future rule is first Sunday in November.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Cuba	1928	only	-	Jun	10	0:00	1:00	D
 Rule	Cuba	1928	only	-	Oct	10	0:00	0	S
@@ -2858,7 +2864,7 @@
 Rule	Cuba	2011	only	-	Mar	Sun>=15	0:00s	1:00	D
 Rule	Cuba	2011	only	-	Nov	13	0:00s	0	S
 Rule	Cuba	2012	only	-	Apr	1	0:00s	1:00	D
-Rule	Cuba	2012	max	-	Oct	lastSun	0:00s	0	S
+Rule	Cuba	2012	max	-	Nov	Sun>=1	0:00s	0	S
 Rule	Cuba	2013	max	-	Mar	Sun>=8	0:00s	1:00	D
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
--- jdk/make/sun/javazic/tzdata/pacificnew	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/pacificnew	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)pacificnew	8.2
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/solar87	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/solar87	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)solar87	8.2
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/solar88	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/solar88	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)solar88	8.2
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/solar89	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/solar89	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)solar89	8.2
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/southamerica	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/southamerica	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)southamerica	8.53
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
@@ -255,7 +254,7 @@
 Rule	Arg	2007	only	-	Dec	30	0:00	1:00	S
 Rule	Arg	2008	2009	-	Mar	Sun>=15	0:00	0	-
 Rule	Arg	2008	only	-	Oct	Sun>=15	0:00	1:00	S
- 
+
 # From Mariano Absatz (2004-05-21):
 # Today it was officially published that the Province of Mendoza is changing
 # its timezone this winter... starting tomorrow night....
@@ -345,9 +344,9 @@
 # confirms what Alex Krivenyshev has earlier sent to the tz
 # emailing list about that San Luis plans to return to standard
 # time much earlier than the rest of the country. It also
-# confirms that upon request the provinces San Juan and Mendoza 
-# refused to follow San Luis in this change. 
-# 
+# confirms that upon request the provinces San Juan and Mendoza
+# refused to follow San Luis in this change.
+#
 # The change is supposed to take place Monday the 21.st at 0:00
 # hours. As far as I understand it if this goes ahead, we need
 # a new timezone for San Luis (although there are also documented
@@ -409,7 +408,7 @@
 # <a href="http://www.lanacion.com.ar/nota.asp?nota_id=1107912">
 # http://www.lanacion.com.ar/nota.asp?nota_id=1107912
 # </a>
-# 
+#
 # The press release says:
 #  (...) anunci que el prximo domingo a las 00:00 los puntanos debern
 # atrasar una hora sus relojes.
@@ -823,8 +822,8 @@
 #
 # From Alexander Krivenyshev (2011-10-04):
 # State Bahia will return to Daylight savings time this year after 8 years off.
-# The announcement was made by Governor Jaques Wagner in an interview to a 
-# television station in Salvador. 
+# The announcement was made by Governor Jaques Wagner in an interview to a
+# television station in Salvador.
 
 # In Portuguese:
 # <a href="http://g1.globo.com/bahia/noticia/2011/10/governador-jaques-wagner-confirma-horario-de-verao-na-bahia.html">
@@ -853,6 +852,15 @@
 # http://www.in.gov.br/visualiza/index.jsp?data=13/10/2011&jornal=1000&pagina=6&totalArquivos=6
 # </a>
 
+# From Kelley Cook (2012-10-16):
+# The governor of state of Bahia in Brazil announced on Thursday that
+# due to public pressure, he is reversing the DST policy they implemented
+# last year and will not be going to Summer Time on October 21st....
+# http://www.correio24horas.com.br/r/artigo/apos-pressoes-wagner-suspende-horario-de-verao-na-bahia
+
+# From Rodrigo Severo (2012-10-16):
+# Tocantins state will have DST.
+# http://noticias.terra.com.br/brasil/noticias/0,,OI6232536-EI306.html
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 # Decree <a href="http://pcdsh01.on.br/HV20466.htm">20,466</a> (1931-10-01)
@@ -1072,7 +1080,8 @@
 			-3:00	Brazil	BR%sT	1990 Sep 17
 			-3:00	-	BRT	1995 Sep 14
 			-3:00	Brazil	BR%sT	2003 Sep 24
-			-3:00	-	BRT
+			-3:00	-	BRT	2012 Oct 21
+			-3:00	Brazil	BR%sT
 #
 # Alagoas (AL), Sergipe (SE)
 Zone America/Maceio	-2:22:52 -	LMT	1914
@@ -1091,7 +1100,8 @@
 Zone America/Bahia	-2:34:04 -	LMT	1914
 			-3:00	Brazil	BR%sT	2003 Sep 24
 			-3:00	-	BRT	2011 Oct 16
-			-3:00	Brazil	BR%sT
+			-3:00	Brazil	BR%sT	2012 Oct 21
+			-3:00	-	BRT
 #
 # Goias (GO), Distrito Federal (DF), Minas Gerais (MG),
 # Espirito Santo (ES), Rio de Janeiro (RJ), Sao Paulo (SP), Parana (PR),
@@ -1183,7 +1193,7 @@
 # Due to drought, Chile extends Daylight Time in three weeks.  This
 # is one-time change (Saturday 3/29 at 24:00 for America/Santiago
 # and Saturday 3/29 at 22:00 for Pacific/Easter)
-# The Supreme Decree is located at 
+# The Supreme Decree is located at
 # <a href="http://www.shoa.cl/servicios/supremo316.pdf">
 # http://www.shoa.cl/servicios/supremo316.pdf
 # </a>
@@ -1194,7 +1204,7 @@
 
 # From Jose Miguel Garrido (2008-03-05):
 # ...
-# You could see the announces of the change on 
+# You could see the announces of the change on
 # <a href="http://www.shoa.cl/noticias/2008/04hora/hora.htm">
 # http://www.shoa.cl/noticias/2008/04hora/hora.htm
 # </a>.
--- jdk/make/sun/javazic/tzdata/systemv	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/systemv	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)systemv	8.2
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 
--- jdk/make/sun/javazic/tzdata/zone.tab	2012-08-10 10:21:51.000000000 -0700
+++ jdk/make/sun/javazic/tzdata/zone.tab	2013-05-05 09:38:27.000000000 -0700
@@ -22,7 +22,6 @@
 # questions.
 #
 # <pre>
-# @(#)zone.tab	8.55
 # This file is in the public domain, so clarified as of
 # 2009-05-17 by Arthur David Olson.
 #
--- jdk/make/sun/jawt/Makefile	2012-08-10 10:21:52.000000000 -0700
+++ jdk/make/sun/jawt/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -94,8 +94,7 @@
 #
 # Other extra flags needed for compiling.
 #
-CPPFLAGS += -I$(OPENWIN_HOME)/include \
-	    -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/image \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/image/cvutils \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/alphacomposite \
@@ -109,6 +108,7 @@
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/doe \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/path \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../jdga \
+            -I$(OPENWIN_HOME)/include \
 	    $(EVENT_MODEL)
 
 #
@@ -122,7 +122,7 @@
   endif
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   ifndef BUILD_HEADLESS_ONLY
     OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -lawt -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
   else
--- jdk/make/sun/rmi/rmi/Makefile	2012-08-10 10:21:53.000000000 -0700
+++ jdk/make/sun/rmi/rmi/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -97,6 +97,9 @@
     BUILD_TARGETS += bin
   endif
 endif
+ifeq ($(PLATFORM), bsd)
+  BUILD_TARGETS += bin
+endif
 
 build: $(BUILD_TARGETS)
 
--- jdk/make/sun/security/ec/Makefile	2012-08-10 10:21:53.000000000 -0700
+++ jdk/make/sun/security/ec/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -245,9 +245,9 @@
 #
 # Build sunec.jar.
 #
-$(UNSIGNED_DIR)/sunec.jar: build
+$(UNSIGNED_DIR)/sunec.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
--- jdk/make/sun/security/mscapi/Makefile	2012-08-10 10:21:54.000000000 -0700
+++ jdk/make/sun/security/mscapi/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -210,9 +210,9 @@
 #
 # Build sunmscapi.jar.
 #
-$(UNSIGNED_DIR)/sunmscapi.jar: build
+$(UNSIGNED_DIR)/sunmscapi.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
--- jdk/make/sun/security/pkcs11/Makefile	2012-08-10 10:21:55.000000000 -0700
+++ jdk/make/sun/security/pkcs11/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -224,9 +224,9 @@
 #
 # Build sunpkcs11.jar.
 #
-$(UNSIGNED_DIR)/sunpkcs11.jar: build
+$(UNSIGNED_DIR)/sunpkcs11.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
--- jdk/make/sun/splashscreen/Makefile	2012-08-10 10:21:55.000000000 -0700
+++ jdk/make/sun/splashscreen/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -83,15 +83,16 @@
 				  -framework JavaNativeFoundation
 else ifneq ($(PLATFORM), windows)
   CFLAGS += -DWITH_X11
-  ifeq ($(PLATFORM), macosx))
-    OTHER_LDLIBS += -liconv
-    CPPFLAGS += -I$(OPENWIN_HOME)/include \
-                -I$(OPENWIN_HOME)/include/X11/extensions
-    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -pthread
-  else
-    CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
-    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  ifeq ($(PLATFORM), bsd))
+    ifeq ($(OS_NAME), netbsd)
+      OTHER_LDLIBS += -Wl,-R$(OPENWIN_LIB)
+    else
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
   endif
+  CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+  OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
 else # PLATFORM
   CFLAGS += -DWITH_WIN32
   OTHER_LDLIBS += kernel32.lib user32.lib gdi32.lib delayimp.lib /DELAYLOAD:user32.dll
--- jdk/make/sun/xawt/Makefile	2012-08-10 10:21:55.000000000 -0700
+++ jdk/make/sun/xawt/Makefile	2013-05-05 09:38:27.000000000 -0700
@@ -52,6 +52,9 @@
 AUTO_JAVA_PRUNE = WrapperGenerator.java
 
 LDFLAGS += -L$(OPENWIN_LIB)
+ifeq ($(OS_NAME), netbsd)
+LDFLAGS += -Wl,-R$(OPENWIN_LIB)
+endif
 
 # For Xrender extension.
 ifeq ($(PLATFORM), solaris)
@@ -63,6 +66,11 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
+ifeq ($(PLATFORM), bsd)
+LDFLAGS += -pthread
+dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
+endif
+
 ifeq ($(PLATFORM), macosx))
 LDFLAGS += -pthread
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
@@ -110,8 +118,6 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
-CPPFLAGS += -I$(CUPS_HEADERS_PATH)
-
 CPPFLAGS += -DXAWT -DXAWT_HACK \
         -I$(TEMPDIR)/../../sun.awt/awt/CClassHeaders \
         -I$(PLATFORM_SRC)/native/sun/awt \
@@ -138,6 +144,8 @@
         -I$(SHARE_SRC)/native/sun/awt \
         -I$(PLATFORM_SRC)/native/sun/awt
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
 ifeq ($(PLATFORM), linux)
   ifndef CROSS_COMPILE_ARCH
     # Allows for builds on Debian GNU Linux, X11 is in a different place 
@@ -173,6 +181,11 @@
  endif
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(OPENWIN_HOME)/include
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
+
 ifeq ($(PLATFORM), macosx)
   CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
 endif
--- jdk/make/tools/freetypecheck/Makefile	2012-08-10 10:22:31.000000000 -0700
+++ jdk/make/tools/freetypecheck/Makefile	2013-05-05 09:38:26.000000000 -0700
@@ -52,8 +52,15 @@
   else 
     ifeq ($(PLATFORM), macosx)
       FT_LD_OPTIONS += -lfreetype -lz
-    else # linux
-      FT_LD_OPTIONS += -Wl,-rpath -Wl,$(FREETYPE_LIB_PATH) -lfreetype
+    else
+      ifeq ($(PLATFORM), bsd)
+        ifeq ($(OS_NAME), netbsd)
+          FT_LD_OPTIONS += -Wl,-R$(FREETYPE_LIB_PATH)
+        endif
+        FT_LD_OPTIONS += -lfreetype -lz
+      else # linux
+        FT_LD_OPTIONS += -Wl,-rpath -Wl,$(FREETYPE_LIB_PATH) -lfreetype
+      endif
     endif
   endif
 endif
--- jdk/make/tools/sharing/classlist.bsd	1969-12-31 16:00:00.000000000 -0800
+++ jdk/make/tools/sharing/classlist.bsd	2013-05-05 09:38:27.000000000 -0700
@@ -0,0 +1,2327 @@
+java/lang/Object
+java/lang/String
+java/io/Serializable
+java/lang/Comparable
+java/lang/CharSequence
+java/lang/Class
+java/lang/reflect/GenericDeclaration
+java/lang/reflect/Type
+java/lang/reflect/AnnotatedElement
+java/lang/Cloneable
+java/lang/ClassLoader
+java/lang/System
+java/lang/Throwable
+java/lang/Error
+java/lang/ThreadDeath
+java/lang/Exception
+java/lang/RuntimeException
+java/security/ProtectionDomain
+java/security/AccessControlContext
+java/lang/ClassNotFoundException
+java/lang/NoClassDefFoundError
+java/lang/LinkageError
+java/lang/ClassCastException
+java/lang/ArrayStoreException
+java/lang/VirtualMachineError
+java/lang/OutOfMemoryError
+java/lang/StackOverflowError
+java/lang/IllegalMonitorStateException
+java/lang/ref/Reference
+java/lang/ref/SoftReference
+java/lang/ref/WeakReference
+java/lang/ref/FinalReference
+java/lang/ref/PhantomReference
+java/lang/ref/Finalizer
+java/lang/Thread
+java/lang/Runnable
+java/lang/ThreadGroup
+java/lang/Thread$UncaughtExceptionHandler
+java/util/Properties
+java/util/Hashtable
+java/util/Map
+java/util/Dictionary
+java/lang/reflect/AccessibleObject
+java/lang/reflect/Field
+java/lang/reflect/Member
+java/lang/reflect/Method
+java/lang/reflect/Constructor
+sun/reflect/MagicAccessorImpl
+sun/reflect/MethodAccessorImpl
+sun/reflect/MethodAccessor
+sun/reflect/ConstructorAccessorImpl
+sun/reflect/ConstructorAccessor
+sun/reflect/DelegatingClassLoader
+sun/reflect/ConstantPool
+sun/reflect/UnsafeStaticFieldAccessorImpl
+sun/reflect/UnsafeFieldAccessorImpl
+sun/reflect/FieldAccessorImpl
+sun/reflect/FieldAccessor
+java/util/Vector
+java/util/List
+java/util/Collection
+java/lang/Iterable
+java/util/RandomAccess
+java/util/AbstractList
+java/util/AbstractCollection
+java/lang/StringBuffer
+java/lang/AbstractStringBuilder
+java/lang/Appendable
+java/lang/StackTraceElement
+java/nio/Buffer
+java/lang/Boolean
+java/lang/Character
+java/lang/Float
+java/lang/Number
+java/lang/Double
+java/lang/Byte
+java/lang/Short
+java/lang/Integer
+java/lang/Long
+java/lang/NullPointerException
+java/lang/ArithmeticException
+java/io/ObjectStreamField
+java/lang/String$CaseInsensitiveComparator
+java/util/Comparator
+java/lang/RuntimePermission
+java/security/BasicPermission
+java/security/Permission
+java/security/Guard
+sun/misc/SoftCache
+java/util/AbstractMap
+java/lang/ref/ReferenceQueue
+java/lang/ref/ReferenceQueue$Null
+java/lang/ref/ReferenceQueue$Lock
+java/util/HashMap
+java/lang/annotation/Annotation
+java/util/HashMap$Entry
+java/util/Map$Entry
+java/security/AccessController
+java/lang/reflect/ReflectPermission
+sun/reflect/ReflectionFactory$GetReflectionFactoryAction
+java/security/PrivilegedAction
+java/util/Stack
+sun/reflect/ReflectionFactory
+java/lang/ref/Reference$Lock
+java/lang/ref/Reference$ReferenceHandler
+java/lang/ref/Finalizer$FinalizerThread
+java/util/Enumeration
+java/util/Iterator
+java/util/Hashtable$Entry
+java/nio/charset/Charset
+sun/nio/cs/StandardCharsets
+sun/nio/cs/FastCharsetProvider
+java/nio/charset/spi/CharsetProvider
+sun/nio/cs/StandardCharsets$Aliases
+sun/util/PreHashedMap
+sun/nio/cs/StandardCharsets$Classes
+sun/nio/cs/StandardCharsets$Cache
+java/lang/ThreadLocal
+java/util/concurrent/atomic/AtomicInteger
+sun/misc/Unsafe
+java/lang/NoSuchMethodError
+java/lang/IncompatibleClassChangeError
+sun/reflect/Reflection
+java/util/Collections
+java/util/Collections$EmptySet
+java/util/AbstractSet
+java/util/Set
+java/util/Collections$EmptyList
+java/util/Collections$EmptyMap
+java/util/Collections$ReverseComparator
+java/util/Collections$SynchronizedMap
+java/lang/Class$3
+java/lang/reflect/Modifier
+java/lang/reflect/ReflectAccess
+sun/reflect/LangReflectAccess
+java/util/Arrays
+java/lang/Math
+sun/nio/cs/US_ASCII
+sun/nio/cs/HistoricallyNamedCharset
+sun/misc/VM
+java/lang/StringCoding
+java/lang/ThreadLocal$ThreadLocalMap
+java/lang/ThreadLocal$ThreadLocalMap$Entry
+java/lang/StringCoding$StringDecoder
+sun/nio/cs/US_ASCII$Decoder
+java/nio/charset/CharsetDecoder
+java/nio/charset/CodingErrorAction
+java/nio/ByteBuffer
+java/nio/HeapByteBuffer
+java/nio/Bits
+java/nio/ByteOrder
+java/nio/CharBuffer
+java/lang/Readable
+java/nio/HeapCharBuffer
+java/nio/charset/CoderResult
+java/nio/charset/CoderResult$1
+java/nio/charset/CoderResult$Cache
+java/nio/charset/CoderResult$2
+sun/misc/Version
+java/io/FileInputStream
+java/io/InputStream
+java/io/Closeable
+java/io/FileDescriptor
+java/io/FileOutputStream
+java/io/OutputStream
+java/io/Flushable
+java/io/BufferedInputStream
+java/io/FilterInputStream
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater
+java/util/concurrent/atomic/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl
+sun/reflect/misc/ReflectUtil
+java/io/PrintStream
+java/io/FilterOutputStream
+java/io/BufferedOutputStream
+java/io/OutputStreamWriter
+java/io/Writer
+sun/nio/cs/StreamEncoder
+sun/security/action/GetPropertyAction
+sun/nio/cs/US_ASCII$Encoder
+java/nio/charset/CharsetEncoder
+sun/nio/cs/Surrogate$Parser
+sun/nio/cs/Surrogate
+java/io/BufferedWriter
+java/lang/Runtime
+java/io/File
+java/io/FileSystem
+java/io/UnixFileSystem
+java/io/ExpiringCache
+java/io/ExpiringCache$1
+java/util/LinkedHashMap
+java/util/LinkedHashMap$Entry
+java/lang/StringBuilder
+sun/misc/SharedSecrets
+java/lang/ClassLoader$3
+java/lang/StringCoding$StringEncoder
+java/io/ExpiringCache$Entry
+java/lang/ClassLoader$NativeLibrary
+java/lang/Terminator
+java/lang/Terminator$1
+sun/misc/SignalHandler
+sun/misc/Signal
+sun/misc/NativeSignalHandler
+java/io/Console
+java/io/Console$1
+sun/misc/JavaIOAccess
+java/lang/Shutdown
+java/util/ArrayList
+java/lang/Shutdown$Lock
+java/lang/ApplicationShutdownHooks
+java/util/IdentityHashMap
+sun/misc/OSEnvironment
+java/lang/System$2
+sun/misc/JavaLangAccess
+java/lang/Compiler
+java/lang/Compiler$1
+sun/misc/Launcher
+sun/misc/Launcher$Factory
+java/net/URLStreamHandlerFactory
+sun/misc/Launcher$ExtClassLoader
+java/net/URLClassLoader
+java/security/SecureClassLoader
+sun/security/util/Debug
+java/net/URLClassLoader$7
+sun/misc/JavaNetAccess
+java/util/StringTokenizer
+sun/misc/Launcher$ExtClassLoader$1
+java/security/PrivilegedExceptionAction
+sun/misc/MetaIndex
+java/io/BufferedReader
+java/io/Reader
+java/io/FileReader
+java/io/InputStreamReader
+sun/nio/cs/StreamDecoder
+java/lang/reflect/Array
+sun/net/www/ParseUtil
+java/util/BitSet
+java/io/ObjectStreamClass
+java/net/URL
+java/util/Locale
+java/util/concurrent/ConcurrentHashMap
+java/util/concurrent/ConcurrentMap
+java/util/concurrent/ConcurrentHashMap$Segment
+java/util/concurrent/locks/ReentrantLock
+java/util/concurrent/locks/Lock
+java/util/concurrent/locks/ReentrantLock$NonfairSync
+java/util/concurrent/locks/ReentrantLock$Sync
+java/util/concurrent/locks/AbstractQueuedSynchronizer
+java/util/concurrent/locks/AbstractOwnableSynchronizer
+java/util/concurrent/locks/AbstractQueuedSynchronizer$Node
+java/util/concurrent/ConcurrentHashMap$HashEntry
+java/lang/CharacterDataLatin1
+java/net/Parts
+sun/net/www/protocol/file/Handler
+java/net/URLStreamHandler
+java/lang/Class$1
+sun/reflect/ReflectionFactory$1
+sun/reflect/NativeConstructorAccessorImpl
+sun/reflect/DelegatingConstructorAccessorImpl
+java/util/HashSet
+sun/misc/URLClassPath
+sun/net/www/protocol/jar/Handler
+sun/misc/Launcher$AppClassLoader
+sun/misc/Launcher$AppClassLoader$1
+java/lang/SystemClassLoaderAction
+java/net/URLClassLoader$1
+sun/misc/URLClassPath$3
+sun/misc/URLClassPath$JarLoader
+sun/misc/URLClassPath$Loader
+java/security/PrivilegedActionException
+sun/misc/URLClassPath$FileLoader
+sun/misc/URLClassPath$FileLoader$1
+sun/misc/Resource
+sun/nio/ByteBuffered
+java/security/CodeSource
+java/security/Permissions
+java/security/PermissionCollection
+sun/net/www/protocol/file/FileURLConnection
+sun/net/www/URLConnection
+java/net/URLConnection
+java/net/UnknownContentHandler
+java/net/ContentHandler
+sun/net/www/MessageHeader
+java/io/FilePermission
+java/io/FilePermission$1
+sun/security/provider/PolicyFile
+java/security/Policy
+java/security/Policy$UnsupportedEmptyCollection
+java/io/FilePermissionCollection
+java/security/AllPermission
+java/security/UnresolvedPermission
+java/security/BasicPermissionCollection
+java/security/Principal
+java/security/cert/Certificate
+java/util/AbstractList$Itr
+java/util/IdentityHashMap$KeySet
+java/util/IdentityHashMap$KeyIterator
+java/util/IdentityHashMap$IdentityHashMapIterator
+java/io/DeleteOnExitHook
+java/util/LinkedHashSet
+java/util/HashMap$KeySet
+java/util/LinkedHashMap$KeyIterator
+java/util/LinkedHashMap$LinkedHashIterator
+java/awt/Frame
+java/awt/MenuContainer
+java/awt/Window
+javax/accessibility/Accessible
+java/awt/Container
+java/awt/Component
+java/awt/image/ImageObserver
+java/lang/InterruptedException
+java/awt/Label
+java/util/logging/Logger
+java/util/logging/Handler
+java/util/logging/Level
+java/util/logging/LogManager
+java/util/logging/LogManager$1
+java/beans/PropertyChangeSupport
+java/util/logging/LogManager$LogNode
+java/util/logging/LoggingPermission
+java/util/logging/LogManager$Cleaner
+java/util/logging/LogManager$RootLogger
+java/util/logging/LogManager$2
+java/util/Properties$LineReader
+java/util/Hashtable$Enumerator
+java/beans/PropertyChangeEvent
+java/util/EventObject
+java/awt/Component$AWTTreeLock
+sun/awt/NativeLibLoader
+sun/security/action/LoadLibraryAction
+java/awt/GraphicsEnvironment
+java/awt/GraphicsEnvironment$1
+java/lang/ProcessEnvironment
+java/lang/ProcessEnvironment$Variable
+java/lang/ProcessEnvironment$ExternalData
+java/lang/ProcessEnvironment$Value
+java/lang/ProcessEnvironment$StringEnvironment
+java/util/Collections$UnmodifiableMap
+java/awt/Toolkit
+java/awt/Toolkit$3
+sun/util/CoreResourceBundleControl
+java/util/ResourceBundle$Control
+java/util/Arrays$ArrayList
+java/util/Collections$UnmodifiableRandomAccessList
+java/util/Collections$UnmodifiableList
+java/util/Collections$UnmodifiableCollection
+java/util/ResourceBundle
+java/util/ResourceBundle$1
+java/util/ResourceBundle$RBClassLoader
+java/util/ResourceBundle$RBClassLoader$1
+java/util/ResourceBundle$CacheKey
+java/util/ResourceBundle$LoaderReference
+java/util/ResourceBundle$CacheKeyReference
+java/util/ResourceBundle$SingleFormatControl
+sun/awt/resources/awt
+java/util/ListResourceBundle
+java/awt/Toolkit$1
+java/io/FileNotFoundException
+java/io/IOException
+java/awt/event/KeyEvent
+java/awt/event/InputEvent
+java/awt/event/ComponentEvent
+java/awt/AWTEvent
+java/awt/event/NativeLibLoader
+java/util/WeakHashMap
+java/util/WeakHashMap$Entry
+java/awt/Component$DummyRequestFocusController
+sun/awt/RequestFocusController
+java/awt/LayoutManager
+java/awt/LightweightDispatcher
+java/awt/event/AWTEventListener
+java/util/EventListener
+java/awt/Dimension
+java/awt/geom/Dimension2D
+java/util/concurrent/atomic/AtomicBoolean
+java/awt/ComponentOrientation
+java/awt/Component$2
+java/lang/NoSuchMethodException
+sun/awt/AppContext
+sun/awt/AppContext$1
+sun/awt/AppContext$2
+sun/awt/MostRecentKeyValue
+java/awt/Cursor
+sun/awt/X11GraphicsEnvironment
+sun/java2d/SunGraphicsEnvironment
+sun/java2d/FontSupport
+sun/awt/DisplayChangedListener
+java/io/FilenameFilter
+sun/awt/X11GraphicsEnvironment$1
+sun/awt/SunToolkit
+sun/awt/WindowClosingSupport
+sun/awt/WindowClosingListener
+sun/awt/ComponentFactory
+sun/awt/InputMethodSupport
+java/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject
+java/util/concurrent/locks/Condition
+sun/awt/AWTAutoShutdown
+sun/awt/SunToolkit$6
+java/awt/Dialog$ModalExclusionType
+java/lang/Enum
+java/awt/Dialog
+java/awt/Dialog$ModalityType
+java/awt/ModalEventFilter
+java/awt/EventFilter
+sun/reflect/UnsafeFieldAccessorFactory
+sun/reflect/UnsafeQualifiedStaticObjectFieldAccessorImpl
+sun/reflect/UnsafeQualifiedStaticFieldAccessorImpl
+sun/awt/SunDisplayChanger
+sun/java2d/SunGraphicsEnvironment$1
+java/io/StreamTokenizer
+sun/font/FontManager
+sun/font/FileFont
+sun/font/PhysicalFont
+sun/font/Font2D
+sun/font/CompositeFont
+java/util/HashMap$Values
+java/util/HashMap$ValueIterator
+java/util/HashMap$HashIterator
+java/awt/Font
+java/awt/geom/AffineTransform
+sun/font/AttributeValues
+sun/font/EAttribute
+java/text/AttributedCharacterIterator$Attribute
+java/lang/Class$4
+sun/reflect/NativeMethodAccessorImpl
+sun/reflect/DelegatingMethodAccessorImpl
+java/awt/font/TextAttribute
+java/lang/Integer$IntegerCache
+sun/font/TrueTypeFont
+java/awt/font/FontRenderContext
+java/awt/RenderingHints
+sun/awt/SunHints
+sun/awt/SunHints$Key
+java/awt/RenderingHints$Key
+sun/awt/SunHints$Value
+sun/awt/SunHints$LCDContrastKey
+sun/font/Type1Font
+java/awt/geom/Point2D$Float
+java/awt/geom/Point2D
+sun/font/StrikeMetrics
+java/awt/geom/Rectangle2D$Float
+java/awt/geom/Rectangle2D
+java/awt/geom/RectangularShape
+java/awt/Shape
+java/awt/geom/GeneralPath
+java/awt/geom/Path2D$Float
+java/awt/geom/Path2D
+sun/font/CharToGlyphMapper
+sun/font/PhysicalStrike
+sun/font/FontStrike
+sun/font/GlyphList
+sun/font/StrikeCache
+sun/java2d/Disposer
+sun/java2d/Disposer$1
+sun/font/StrikeCache$1
+sun/awt/motif/MFontConfiguration
+sun/awt/FontConfiguration
+sun/awt/FontDescriptor
+java/util/Scanner
+java/util/regex/Pattern
+java/util/regex/Pattern$Node
+java/util/regex/Pattern$LastNode
+java/util/regex/Pattern$GroupHead
+java/util/regex/Pattern$CharPropertyNames
+java/util/regex/Pattern$CharPropertyNames$1
+java/util/regex/Pattern$CharPropertyNames$CharPropertyFactory
+java/util/regex/Pattern$CharPropertyNames$2
+java/util/regex/Pattern$CharPropertyNames$5
+java/util/regex/Pattern$CharPropertyNames$3
+java/util/regex/Pattern$CharPropertyNames$6
+java/util/regex/Pattern$CharPropertyNames$CloneableProperty
+java/util/regex/Pattern$CharProperty
+java/util/regex/Pattern$CharPropertyNames$4
+java/util/regex/Pattern$CharPropertyNames$7
+java/util/regex/Pattern$CharPropertyNames$8
+java/util/regex/Pattern$CharPropertyNames$9
+java/util/regex/Pattern$CharPropertyNames$10
+java/util/regex/Pattern$CharPropertyNames$11
+java/util/regex/Pattern$CharPropertyNames$12
+java/util/regex/Pattern$CharPropertyNames$13
+java/util/regex/Pattern$CharPropertyNames$14
+java/util/regex/Pattern$CharPropertyNames$15
+java/util/regex/Pattern$CharPropertyNames$16
+java/util/regex/Pattern$CharPropertyNames$17
+java/util/regex/Pattern$CharPropertyNames$18
+java/util/regex/Pattern$CharPropertyNames$19
+java/util/regex/Pattern$CharPropertyNames$20
+java/util/regex/Pattern$CharPropertyNames$21
+java/util/regex/Pattern$Curly
+java/util/regex/Pattern$Slice
+java/util/regex/Pattern$Begin
+java/util/regex/Pattern$First
+java/util/regex/Pattern$Start
+java/util/regex/Pattern$TreeInfo
+java/util/regex/Pattern$All
+java/util/regex/Pattern$BitClass
+java/util/regex/Pattern$BmpCharProperty
+java/util/regex/Pattern$6
+java/util/regex/Pattern$CharProperty$1
+sun/nio/ch/FileChannelImpl
+java/nio/channels/FileChannel
+java/nio/channels/ByteChannel
+java/nio/channels/ReadableByteChannel
+java/nio/channels/Channel
+java/nio/channels/WritableByteChannel
+java/nio/channels/GatheringByteChannel
+java/nio/channels/ScatteringByteChannel
+java/nio/channels/spi/AbstractInterruptibleChannel
+java/nio/channels/InterruptibleChannel
+sun/nio/ch/Util
+sun/nio/ch/IOUtil
+sun/nio/ch/FileDispatcher
+sun/nio/ch/NativeDispatcher
+sun/nio/ch/Reflect
+java/nio/MappedByteBuffer
+sun/nio/ch/Reflect$1
+sun/nio/ch/NativeThreadSet
+java/nio/channels/Channels
+java/util/Scanner$1
+sun/misc/LRUCache
+java/util/regex/Matcher
+java/util/regex/MatchResult
+java/text/NumberFormat
+java/text/Format
+java/text/spi/NumberFormatProvider
+java/util/spi/LocaleServiceProvider
+sun/util/LocaleServiceProviderPool
+sun/util/LocaleServiceProviderPool$1
+java/util/ServiceLoader
+java/util/ServiceLoader$LazyIterator
+java/util/ServiceLoader$1
+java/util/HashMap$EntrySet
+java/util/LinkedHashMap$EntryIterator
+sun/misc/Launcher$1
+sun/misc/URLClassPath$2
+java/lang/ClassLoader$2
+sun/misc/URLClassPath$1
+java/net/URLClassLoader$3
+sun/misc/CompoundEnumeration
+sun/misc/URLClassPath$JarLoader$1
+sun/misc/FileURLMapper
+java/net/URLClassLoader$3$1
+sun/util/resources/LocaleData
+sun/util/resources/LocaleData$1
+sun/util/resources/LocaleData$LocaleDataResourceBundleControl
+sun/util/LocaleDataMetaInfo
+sun/text/resources/FormatData
+java/util/ResourceBundle$BundleReference
+sun/text/resources/FormatData_en
+sun/text/resources/FormatData_en_US
+java/text/DecimalFormatSymbols
+java/text/spi/DecimalFormatSymbolsProvider
+java/util/Currency
+java/util/Currency$1
+java/util/spi/CurrencyNameProvider
+sun/util/resources/CurrencyNames
+sun/util/resources/LocaleNamesBundle
+sun/util/resources/OpenListResourceBundle
+sun/util/resources/CurrencyNames_en_US
+java/text/DecimalFormat
+java/text/FieldPosition
+java/text/DigitList
+java/math/RoundingMode
+java/util/regex/Pattern$GroupTail
+java/util/regex/Pattern$Ctype
+java/util/regex/Pattern$Ques
+java/util/regex/Pattern$GroupCurly
+java/util/regex/Pattern$5
+java/util/regex/Pattern$Loop
+java/util/regex/Pattern$Prolog
+java/util/regex/Pattern$BranchConn
+java/util/regex/Pattern$Branch
+java/nio/channels/spi/AbstractInterruptibleChannel$1
+sun/nio/ch/Interruptible
+sun/nio/ch/NativeThread
+sun/nio/ch/DirectBuffer
+java/nio/DirectByteBuffer
+java/nio/DirectByteBuffer$Deallocator
+sun/misc/Cleaner
+sun/nio/ch/IOStatus
+java/util/regex/ASCII
+java/io/DataInputStream
+java/io/DataInput
+java/lang/Short$ShortCache
+java/util/HashMap$KeyIterator
+sun/font/CompositeFontDescriptor
+sun/font/Font2DHandle
+sun/font/FontFamily
+java/awt/GraphicsDevice
+sun/awt/X11GraphicsDevice
+sun/awt/X11GraphicsConfig
+java/awt/GraphicsConfiguration
+java/awt/ImageCapabilities
+sun/java2d/x11/X11SurfaceData
+sun/java2d/SurfaceData
+java/awt/Transparency
+sun/java2d/DisposerTarget
+sun/java2d/InvalidPipeException
+java/lang/IllegalStateException
+sun/java2d/NullSurfaceData
+sun/java2d/loops/SurfaceType
+sun/awt/image/PixelConverter
+sun/awt/image/PixelConverter$Xrgb
+sun/awt/image/PixelConverter$Argb
+sun/awt/image/PixelConverter$ArgbPre
+sun/awt/image/PixelConverter$Xbgr
+sun/awt/image/PixelConverter$Rgba
+sun/awt/image/PixelConverter$RgbaPre
+sun/awt/image/PixelConverter$Ushort565Rgb
+sun/awt/image/PixelConverter$Ushort555Rgb
+sun/awt/image/PixelConverter$Ushort555Rgbx
+sun/awt/image/PixelConverter$Ushort4444Argb
+sun/awt/image/PixelConverter$ByteGray
+sun/awt/image/PixelConverter$UshortGray
+sun/awt/image/PixelConverter$Rgbx
+sun/awt/image/PixelConverter$Bgrx
+sun/awt/image/PixelConverter$ArgbBm
+java/awt/image/ColorModel
+java/awt/image/DirectColorModel
+java/awt/image/PackedColorModel
+java/awt/color/ColorSpace
+java/awt/color/ICC_Profile
+java/awt/color/ICC_ProfileRGB
+java/awt/color/ICC_Profile$1
+java/awt/color/ICC_ColorSpace
+sun/java2d/pipe/NullPipe
+sun/java2d/pipe/PixelDrawPipe
+sun/java2d/pipe/PixelFillPipe
+sun/java2d/pipe/ShapeDrawPipe
+sun/java2d/pipe/TextPipe
+sun/java2d/pipe/DrawImagePipe
+java/awt/image/IndexColorModel
+sun/java2d/pipe/LoopPipe
+sun/java2d/pipe/OutlineTextRenderer
+sun/java2d/pipe/SolidTextRenderer
+sun/java2d/pipe/GlyphListLoopPipe
+sun/java2d/pipe/GlyphListPipe
+sun/java2d/pipe/AATextRenderer
+sun/java2d/pipe/LCDTextRenderer
+sun/java2d/pipe/AlphaColorPipe
+sun/java2d/pipe/CompositePipe
+sun/java2d/pipe/PixelToShapeConverter
+sun/java2d/pipe/TextRenderer
+sun/java2d/pipe/SpanClipRenderer
+sun/java2d/pipe/Region
+sun/java2d/pipe/RegionIterator
+sun/java2d/pipe/AlphaPaintPipe
+sun/java2d/pipe/SpanShapeRenderer$Composite
+sun/java2d/pipe/SpanShapeRenderer
+sun/java2d/pipe/GeneralCompositePipe
+sun/java2d/pipe/DrawImage
+sun/java2d/loops/RenderCache
+sun/java2d/loops/RenderCache$Entry
+sun/java2d/loops/XORComposite
+java/awt/Composite
+sun/font/X11TextRenderer
+sun/java2d/loops/GraphicsPrimitive
+sun/java2d/x11/X11PMBlitLoops
+sun/java2d/loops/Blit
+sun/java2d/loops/GraphicsPrimitiveMgr
+sun/java2d/loops/CompositeType
+sun/java2d/SunGraphics2D
+sun/awt/ConstrainableGraphics
+java/awt/Graphics2D
+java/awt/Graphics
+java/awt/Color
+java/awt/Paint
+java/awt/AlphaComposite
+sun/java2d/loops/BlitBg
+sun/java2d/loops/ScaledBlit
+sun/java2d/loops/FillRect
+sun/java2d/loops/FillSpans
+sun/java2d/loops/DrawLine
+sun/java2d/loops/DrawRect
+sun/java2d/loops/DrawPolygons
+sun/java2d/loops/DrawPath
+sun/java2d/loops/FillPath
+sun/java2d/loops/MaskBlit
+sun/java2d/loops/MaskFill
+sun/java2d/loops/DrawGlyphList
+sun/java2d/loops/DrawGlyphListAA
+sun/java2d/loops/DrawGlyphListLCD
+sun/java2d/loops/TransformHelper
+java/awt/BasicStroke
+java/awt/Stroke
+sun/misc/PerformanceLogger
+sun/misc/PerformanceLogger$TimeData
+sun/java2d/pipe/ValidatePipe
+sun/java2d/loops/CustomComponent
+sun/java2d/loops/GraphicsPrimitiveProxy
+sun/java2d/loops/GeneralRenderer
+sun/java2d/loops/GraphicsPrimitiveMgr$1
+sun/java2d/loops/GraphicsPrimitiveMgr$2
+sun/java2d/x11/X11PMBlitLoops$DelegateBlitLoop
+sun/java2d/x11/X11PMBlitBgLoops
+sun/java2d/x11/X11SurfaceData$LazyPipe
+sun/awt/X11GraphicsConfig$X11GCDisposerRecord
+sun/java2d/DisposerRecord
+java/awt/BorderLayout
+java/awt/LayoutManager2
+java/awt/Rectangle
+java/awt/Toolkit$2
+sun/awt/X11/XToolkit
+sun/awt/X11/XConstants
+sun/awt/UNIXToolkit
+java/util/TreeMap
+java/util/NavigableMap
+java/util/SortedMap
+sun/awt/X11/XlibWrapper
+sun/awt/X11/XUtilConstants
+sun/awt/X11/XProtocolConstants
+sun/awt/X11/XCursorFontConstants
+sun/awt/X11/XlibWrapper$1
+sun/awt/X11/XToolkit$4
+sun/awt/X11/XModifierKeymap
+sun/awt/X11/XWrapperBase
+sun/awt/X11/Native
+sun/awt/X11/Native$1
+java/awt/EventQueue
+java/util/EmptyStackException
+java/lang/reflect/InvocationTargetException
+java/awt/EventDispatchThread
+java/awt/event/PaintEvent
+java/awt/event/MouseEvent
+sun/awt/PeerEvent
+java/awt/event/InvocationEvent
+java/awt/ActiveEvent
+sun/awt/X11/XToolkit$1
+sun/awt/X11/XEventDispatcher
+sun/awt/SunToolkit$ModalityListenerList
+sun/awt/ModalityListener
+sun/awt/SunToolkit$1
+java/util/MissingResourceException
+java/awt/Queue
+sun/awt/PostEventQueue
+java/util/LinkedList
+java/util/Deque
+java/util/Queue
+java/util/AbstractSequentialList
+sun/awt/X11/AwtScreenData
+sun/awt/X11/XWM
+sun/awt/X11/MWMConstants
+sun/awt/X11/XAtom
+java/awt/Insets
+sun/awt/X11/XWM$1
+sun/awt/X11/XSetWindowAttributes
+sun/awt/X11/XErrorEvent
+sun/awt/X11/XNETProtocol
+sun/awt/X11/XStateProtocol
+sun/awt/X11/XLayerProtocol
+sun/awt/X11/XProtocol
+sun/awt/X11/WindowPropertyGetter
+sun/awt/X11/UnsafeXDisposerRecord
+sun/awt/X11/XPropertyCache
+sun/awt/X11/XWINProtocol
+sun/awt/X11/XAtomList
+sun/awt/X11/XToolkit$3
+sun/awt/X11/XAnyEvent
+java/awt/Window$WindowDisposerRecord
+java/awt/KeyboardFocusManager
+java/awt/KeyEventDispatcher
+java/awt/KeyEventPostProcessor
+java/awt/AWTKeyStroke
+java/awt/AWTKeyStroke$1
+java/awt/DefaultKeyboardFocusManager
+java/awt/DefaultFocusTraversalPolicy
+java/awt/ContainerOrderFocusTraversalPolicy
+java/awt/FocusTraversalPolicy
+java/util/Collections$UnmodifiableSet
+sun/awt/HeadlessToolkit
+sun/awt/X11/XKeyboardFocusManagerPeer
+java/awt/peer/KeyboardFocusManagerPeer
+sun/awt/X11/XKeyboardFocusManagerPeer$1
+sun/awt/X11/XFramePeer
+java/awt/peer/FramePeer
+java/awt/peer/WindowPeer
+java/awt/peer/ContainerPeer
+java/awt/peer/ComponentPeer
+sun/awt/X11/XDecoratedPeer
+sun/awt/X11/XWindowPeer
+sun/awt/X11/XPanelPeer
+java/awt/peer/PanelPeer
+sun/awt/X11/XCanvasPeer
+java/awt/peer/CanvasPeer
+sun/awt/X11/XComponentPeer
+java/awt/dnd/peer/DropTargetPeer
+sun/awt/X11/XWindow
+sun/awt/X11ComponentPeer
+sun/awt/X11/XBaseWindow
+sun/awt/X11/XCreateWindowParams
+java/lang/Long$LongCache
+sun/awt/X11/XBaseWindow$InitialiseState
+sun/awt/X11/XBaseWindow$StateLock
+sun/awt/X11/AwtGraphicsConfigData
+sun/awt/X11/XVisualInfo
+java/awt/SystemColor
+sun/awt/X11/MotifColorUtilities
+java/lang/StrictMath
+sun/awt/X11/XRepaintArea
+sun/awt/RepaintArea
+sun/awt/X11/XWindowAttributesData
+java/util/concurrent/locks/LockSupport
+sun/awt/X11/WindowDimensions
+java/awt/Point
+java/util/TreeMap$Entry
+sun/nio/cs/UTF_8
+sun/nio/cs/Unicode
+sun/nio/cs/UTF_8$Encoder
+sun/nio/cs/UTF_8$Decoder
+sun/nio/cs/Surrogate$Generator
+sun/awt/X11/XPropertyEvent
+sun/awt/X11/XDropTargetEventProcessor
+sun/awt/X11/XDragSourceContextPeer
+sun/awt/X11/XDragSourceProtocolListener
+sun/awt/dnd/SunDragSourceContextPeer
+java/awt/dnd/peer/DragSourceContextPeer
+sun/awt/X11/XAwtState
+sun/awt/X11/XBaseWindow$1
+sun/awt/X11/XRootWindow
+sun/nio/cs/ISO_8859_1
+sun/nio/cs/ISO_8859_1$Encoder
+sun/nio/cs/ISO_8859_1$Decoder
+sun/java2d/x11/X11SurfaceData$X11WindowSurfaceData
+sun/java2d/loops/RenderLoops
+sun/java2d/loops/GraphicsPrimitiveMgr$PrimitiveSpec
+sun/java2d/DefaultDisposerRecord
+sun/java2d/x11/X11Renderer
+sun/awt/X11/XGlobalCursorManager
+sun/awt/GlobalCursorManager
+java/awt/Cursor$CursorDisposer
+java/awt/AWTException
+java/awt/HeadlessException
+java/lang/UnsupportedOperationException
+sun/reflect/UnsafeLongFieldAccessorImpl
+sun/reflect/UnsafeIntegerFieldAccessorImpl
+sun/awt/X11/XClientMessageEvent
+sun/awt/X11/XIconInfo
+sun/awt/X11/XAWTIcon32_java_icon16_png
+sun/awt/X11/XAWTIcon32_java_icon24_png
+sun/awt/X11/XAWTIcon32_java_icon32_png
+sun/awt/X11/XAWTIcon32_java_icon48_png
+sun/awt/X11/XSizeHints
+sun/awt/X11/XContentWindow
+sun/awt/X11/XFocusProxyWindow
+sun/awt/X11/XWMHints
+java/util/LinkedList$ListItr
+java/util/ListIterator
+sun/awt/SunToolkit$2
+java/awt/image/BufferStrategy
+java/awt/dnd/DropTarget
+java/awt/dnd/DropTargetListener
+java/awt/event/ComponentListener
+java/awt/event/FocusListener
+java/awt/event/HierarchyListener
+java/awt/event/HierarchyBoundsListener
+java/awt/event/KeyListener
+java/awt/event/MouseListener
+java/awt/event/MouseMotionListener
+java/awt/event/MouseWheelListener
+java/awt/event/InputMethodListener
+java/awt/event/ContainerListener
+javax/accessibility/AccessibleContext
+sun/reflect/UnsafeObjectFieldAccessorImpl
+java/awt/peer/LightweightPeer
+sun/awt/X11/XLabelPeer
+java/awt/peer/LabelPeer
+sun/awt/X11/XMapEvent
+sun/awt/X11/XQueryTree
+sun/awt/X11/XConfigureEvent
+sun/awt/X11/PropMwmHints
+sun/awt/GlobalCursorManager$NativeUpdater
+javax/swing/JFrame
+javax/swing/WindowConstants
+javax/swing/RootPaneContainer
+javax/swing/TransferHandler$HasGetTransferHandler
+javax/swing/JLabel
+javax/swing/SwingConstants
+javax/swing/JComponent
+javax/swing/JComponent$1
+javax/swing/SwingUtilities
+javax/swing/JRootPane
+sun/security/action/GetBooleanAction
+javax/swing/event/EventListenerList
+javax/swing/JPanel
+java/awt/FlowLayout
+javax/swing/UIManager
+javax/swing/UIManager$LookAndFeelInfo
+sun/swing/SwingUtilities2
+sun/swing/SwingUtilities2$LSBCacheEntry
+javax/swing/UIManager$LAFState
+javax/swing/UIDefaults
+javax/swing/MultiUIDefaults
+javax/swing/UIManager$1
+javax/swing/plaf/metal/MetalLookAndFeel
+javax/swing/plaf/basic/BasicLookAndFeel
+javax/swing/LookAndFeel
+sun/swing/DefaultLookup
+javax/swing/plaf/metal/OceanTheme
+javax/swing/plaf/metal/DefaultMetalTheme
+javax/swing/plaf/metal/MetalTheme
+javax/swing/plaf/ColorUIResource
+javax/swing/plaf/UIResource
+sun/swing/PrintColorUIResource
+javax/swing/plaf/metal/DefaultMetalTheme$FontDelegate
+javax/swing/plaf/FontUIResource
+sun/swing/SwingLazyValue
+javax/swing/UIDefaults$LazyValue
+javax/swing/UIDefaults$ActiveValue
+javax/swing/plaf/InsetsUIResource
+sun/swing/SwingUtilities2$2
+javax/swing/plaf/basic/BasicLookAndFeel$2
+javax/swing/plaf/DimensionUIResource
+javax/swing/UIDefaults$LazyInputMap
+java/lang/Character$CharacterCache
+javax/swing/plaf/metal/MetalLookAndFeel$MetalLazyValue
+javax/swing/plaf/metal/MetalLookAndFeel$FontActiveValue
+java/awt/print/PrinterJob
+sun/swing/SwingUtilities2$AATextInfo
+sun/awt/X11/XAWTXSettings
+sun/awt/X11/XMSelectionListener
+sun/awt/XSettings
+sun/awt/X11/XMSelection
+sun/awt/X11/XMSelection$1
+javax/swing/plaf/metal/MetalLookAndFeel$AATextListener
+java/beans/PropertyChangeListener
+java/beans/PropertyChangeListenerProxy
+java/util/EventListenerProxy
+sun/awt/EventListenerAggregate
+javax/swing/UIDefaults$ProxyLazyValue
+javax/swing/plaf/metal/OceanTheme$1
+javax/swing/plaf/metal/OceanTheme$2
+javax/swing/plaf/metal/OceanTheme$3
+javax/swing/plaf/metal/OceanTheme$4
+javax/swing/plaf/metal/OceanTheme$5
+javax/swing/plaf/metal/OceanTheme$6
+javax/swing/RepaintManager
+javax/swing/RepaintManager$DisplayChangedHandler
+javax/swing/SwingPaintEventDispatcher
+sun/awt/PaintEventDispatcher
+javax/swing/UIManager$2
+java/awt/PopupMenu
+java/awt/Menu
+java/awt/MenuItem
+java/awt/MenuComponent
+java/io/ObjectOutputStream
+java/io/ObjectOutput
+java/io/DataOutput
+java/io/ObjectStreamConstants
+java/io/PrintWriter
+java/io/ObjectInputStream
+java/io/ObjectInput
+java/awt/Event
+java/awt/im/InputContext
+java/awt/event/MouseWheelEvent
+java/awt/BufferCapabilities
+sun/awt/CausedFocusEvent$Cause
+java/awt/PointerInfo
+java/awt/Component$BaselineResizeBehavior
+java/awt/FontMetrics
+java/awt/Image
+java/awt/image/ImageProducer
+java/awt/image/VolatileImage
+java/awt/im/InputMethodRequests
+java/awt/event/FocusEvent
+java/awt/event/InputMethodEvent
+java/awt/event/HierarchyEvent
+javax/accessibility/AccessibleStateSet
+com/sun/swing/internal/plaf/metal/resources/metal
+sun/util/ResourceBundleEnumeration
+com/sun/swing/internal/plaf/basic/resources/basic
+javax/swing/plaf/basic/BasicPanelUI
+javax/swing/plaf/PanelUI
+javax/swing/plaf/ComponentUI
+sun/reflect/misc/MethodUtil
+sun/reflect/misc/MethodUtil$1
+java/util/jar/JarFile
+java/util/zip/ZipFile
+java/util/zip/ZipConstants
+java/util/jar/JavaUtilJarAccessImpl
+sun/misc/JavaUtilJarAccess
+sun/misc/JarIndex
+java/util/zip/ZipEntry
+java/util/jar/JarFile$JarFileEntry
+java/util/jar/JarEntry
+sun/misc/URLClassPath$JarLoader$2
+sun/net/www/protocol/jar/JarURLConnection
+java/net/JarURLConnection
+sun/net/www/protocol/jar/JarFileFactory
+sun/net/www/protocol/jar/URLJarFile$URLJarFileCloseController
+java/net/HttpURLConnection
+sun/net/www/protocol/jar/URLJarFile
+sun/net/www/protocol/jar/URLJarFile$URLJarFileEntry
+sun/net/www/protocol/jar/JarURLConnection$JarURLInputStream
+java/util/zip/ZipFile$ZipFileInputStream
+java/security/AllPermissionCollection
+java/lang/IllegalAccessException
+javax/swing/JPasswordField
+javax/swing/JTextField
+javax/swing/text/JTextComponent
+javax/swing/Scrollable
+javax/swing/JLayeredPane
+javax/swing/JRootPane$1
+javax/swing/ArrayTable
+javax/swing/JInternalFrame
+javax/swing/JRootPane$RootLayout
+javax/swing/BufferStrategyPaintManager
+javax/swing/RepaintManager$PaintManager
+javax/swing/plaf/metal/MetalRootPaneUI
+javax/swing/plaf/basic/BasicRootPaneUI
+javax/swing/plaf/RootPaneUI
+javax/swing/plaf/basic/BasicRootPaneUI$RootPaneInputMap
+javax/swing/plaf/ComponentInputMapUIResource
+javax/swing/ComponentInputMap
+javax/swing/InputMap
+javax/swing/plaf/InputMapUIResource
+javax/swing/KeyStroke
+java/awt/VKCollection
+sun/reflect/UnsafeQualifiedStaticIntegerFieldAccessorImpl
+javax/swing/plaf/basic/LazyActionMap
+javax/swing/plaf/ActionMapUIResource
+javax/swing/ActionMap
+javax/swing/LayoutFocusTraversalPolicy
+javax/swing/SortingFocusTraversalPolicy
+javax/swing/InternalFrameFocusTraversalPolicy
+javax/swing/SwingContainerOrderFocusTraversalPolicy
+javax/swing/SwingDefaultFocusTraversalPolicy
+javax/swing/LayoutComparator
+javax/swing/plaf/metal/MetalLabelUI
+javax/swing/plaf/basic/BasicLabelUI
+javax/swing/plaf/LabelUI
+javax/swing/plaf/metal/DefaultMetalTheme$FontDelegate$1
+javax/swing/plaf/basic/BasicHTML
+sun/awt/NullComponentPeer
+java/awt/event/WindowEvent
+java/awt/EventQueue$1
+java/awt/EventDispatchThread$1
+java/awt/Conditional
+java/awt/EventDispatchThread$HierarchyEventFilter
+java/awt/EventFilter$FilterAction
+sun/awt/dnd/SunDropTargetEvent
+java/awt/event/ActionEvent
+java/util/jar/Manifest
+java/io/ByteArrayInputStream
+java/util/jar/Attributes
+java/util/jar/Manifest$FastInputStream
+java/util/jar/Attributes$Name
+sun/misc/ASCIICaseInsensitiveComparator
+java/util/jar/JarVerifier
+java/io/ByteArrayOutputStream
+sun/misc/ExtensionDependency
+java/lang/Package
+sun/security/util/ManifestEntryVerifier
+java/security/Provider
+java/security/Provider$ServiceKey
+java/security/Provider$EngineDescription
+java/security/Security
+java/security/Security$1
+sun/misc/FloatingDecimal
+sun/misc/FloatingDecimal$1
+sun/security/provider/NativePRNG
+java/security/SecureRandomSpi
+sun/security/provider/NativePRNG$1
+sun/security/provider/NativePRNG$RandomIO
+sun/misc/BASE64Decoder
+sun/misc/CharacterDecoder
+sun/security/util/SignatureFileVerifier
+java/awt/event/KeyAdapter
+java/lang/NumberFormatException
+java/lang/IllegalArgumentException
+java/io/FileWriter
+java/net/Authenticator
+java/net/MalformedURLException
+javax/swing/text/Element
+javax/swing/text/Document
+javax/swing/text/PlainDocument
+javax/swing/text/AbstractDocument
+javax/swing/text/GapContent
+javax/swing/text/AbstractDocument$Content
+javax/swing/text/GapVector
+javax/swing/text/GapContent$MarkVector
+javax/swing/text/GapContent$MarkData
+javax/swing/text/StyleContext
+javax/swing/text/AbstractDocument$AttributeContext
+javax/swing/text/StyleConstants
+javax/swing/text/StyleConstants$CharacterConstants
+javax/swing/text/AttributeSet$CharacterAttribute
+javax/swing/text/StyleConstants$FontConstants
+javax/swing/text/AttributeSet$FontAttribute
+javax/swing/text/StyleConstants$ColorConstants
+javax/swing/text/AttributeSet$ColorAttribute
+javax/swing/text/StyleConstants$ParagraphConstants
+javax/swing/text/AttributeSet$ParagraphAttribute
+javax/swing/text/StyleContext$FontKey
+javax/swing/text/SimpleAttributeSet
+javax/swing/text/MutableAttributeSet
+javax/swing/text/AttributeSet
+javax/swing/text/SimpleAttributeSet$EmptyAttributeSet
+javax/swing/text/StyleContext$NamedStyle
+javax/swing/text/Style
+javax/swing/text/StyleContext$SmallAttributeSet
+javax/swing/text/AbstractDocument$BidiRootElement
+javax/swing/text/AbstractDocument$BranchElement
+javax/swing/text/AbstractDocument$AbstractElement
+javax/swing/tree/TreeNode
+javax/swing/text/AbstractDocument$1
+javax/swing/text/AbstractDocument$BidiElement
+javax/swing/text/AbstractDocument$LeafElement
+javax/swing/text/GapContent$StickyPosition
+javax/swing/text/Position
+javax/swing/text/StyleContext$KeyEnumeration
+javax/swing/text/GapContent$InsertUndo
+javax/swing/undo/AbstractUndoableEdit
+javax/swing/undo/UndoableEdit
+javax/swing/text/AbstractDocument$DefaultDocumentEvent
+javax/swing/event/DocumentEvent
+javax/swing/undo/CompoundEdit
+javax/swing/event/DocumentEvent$EventType
+javax/swing/text/Segment
+java/text/CharacterIterator
+javax/swing/text/Utilities
+javax/swing/text/SegmentCache
+javax/swing/text/SegmentCache$CachedSegment
+javax/swing/event/UndoableEditEvent
+javax/swing/text/AbstractDocument$ElementEdit
+javax/swing/event/DocumentEvent$ElementChange
+java/net/Socket
+java/net/InetAddress
+java/net/InetAddress$Cache
+java/net/InetAddress$Cache$Type
+java/net/InetAddressImplFactory
+java/net/Inet4AddressImpl
+java/net/InetAddressImpl
+java/net/InetAddress$1
+sun/net/spi/nameservice/NameService
+sun/net/util/IPAddressUtil
+java/util/RandomAccessSubList
+java/util/SubList
+java/util/SubList$1
+java/util/AbstractList$ListItr
+java/net/Inet4Address
+java/net/InetSocketAddress
+java/net/SocketAddress
+java/net/SocksSocketImpl
+java/net/SocksConsts
+java/net/PlainSocketImpl
+java/net/SocketImpl
+java/net/SocketOptions
+java/net/SocketException
+java/net/SocksSocketImpl$5
+java/net/ProxySelector
+sun/net/spi/DefaultProxySelector
+sun/net/spi/DefaultProxySelector$1
+sun/net/NetProperties
+sun/net/NetProperties$1
+sun/net/spi/DefaultProxySelector$NonProxyInfo
+java/net/Inet6Address
+java/net/URI
+java/net/URI$Parser
+java/net/Proxy
+java/net/Proxy$Type
+java/net/ConnectException
+javax/swing/JMenu
+javax/swing/MenuElement
+javax/swing/JMenuItem
+javax/swing/AbstractButton
+java/awt/ItemSelectable
+javax/swing/event/MenuListener
+javax/swing/JCheckBoxMenuItem
+javax/swing/Icon
+javax/swing/JButton
+java/awt/event/WindowListener
+java/net/URLClassLoader$2
+javax/swing/ImageIcon
+javax/swing/ImageIcon$1
+java/awt/MediaTracker
+sun/misc/SoftCache$ValueCell
+sun/awt/image/URLImageSource
+sun/awt/image/InputStreamImageSource
+sun/awt/image/ImageFetchable
+sun/awt/image/ToolkitImage
+java/awt/Image$1
+sun/awt/image/SurfaceManager$ImageAccessor
+sun/awt/image/SurfaceManager
+sun/awt/image/NativeLibLoader
+java/awt/ImageMediaEntry
+java/awt/MediaEntry
+sun/awt/image/ImageRepresentation
+java/awt/image/ImageConsumer
+sun/awt/image/ImageWatched
+sun/awt/image/ImageWatched$Link
+sun/awt/image/ImageWatched$WeakLink
+sun/awt/image/ImageConsumerQueue
+sun/awt/image/ImageFetcher
+sun/awt/image/FetcherInfo
+sun/awt/image/ImageFetcher$1
+sun/awt/image/GifImageDecoder
+sun/awt/image/ImageDecoder
+sun/awt/image/GifFrame
+java/awt/image/Raster
+java/awt/image/DataBufferByte
+java/awt/image/DataBuffer
+java/awt/image/PixelInterleavedSampleModel
+java/awt/image/ComponentSampleModel
+java/awt/image/SampleModel
+sun/awt/image/ByteInterleavedRaster
+sun/awt/image/ByteComponentRaster
+sun/awt/image/SunWritableRaster
+java/awt/image/WritableRaster
+java/awt/image/BufferedImage
+java/awt/image/WritableRenderedImage
+java/awt/image/RenderedImage
+sun/awt/image/IntegerComponentRaster
+sun/awt/image/BytePackedRaster
+java/awt/Canvas
+sun/font/FontDesignMetrics
+sun/font/FontStrikeDesc
+sun/font/CompositeStrike
+sun/font/FontStrikeDisposer
+sun/font/StrikeCache$SoftDisposerRef
+sun/font/StrikeCache$DisposableStrike
+sun/font/TrueTypeFont$TTDisposerRecord
+sun/font/TrueTypeFont$1
+java/io/RandomAccessFile
+java/nio/ByteBufferAsIntBufferB
+java/nio/IntBuffer
+sun/font/TrueTypeFont$DirectoryEntry
+java/nio/ByteBufferAsShortBufferB
+java/nio/ShortBuffer
+sun/nio/cs/UTF_16
+sun/nio/cs/UTF_16$Decoder
+sun/nio/cs/UnicodeDecoder
+sun/font/FileFontStrike
+sun/font/TrueTypeGlyphMapper
+sun/font/CMap
+sun/font/CMap$NullCMapClass
+sun/font/CMap$CMapFormat4
+java/nio/ByteBufferAsCharBufferB
+sun/font/FontDesignMetrics$KeyReference
+sun/awt/image/PNGImageDecoder
+sun/awt/image/PNGFilterInputStream
+java/util/zip/InflaterInputStream
+java/util/zip/Inflater
+sun/awt/EventQueueItem
+sun/awt/SunToolkit$3
+sun/awt/X11/XExposeEvent
+sun/reflect/UnsafeBooleanFieldAccessorImpl
+sun/awt/event/IgnorePaintEvent
+java/awt/image/DataBufferInt
+java/awt/image/SinglePixelPackedSampleModel
+sun/awt/image/IntegerInterleavedRaster
+sun/awt/image/OffScreenImage
+sun/awt/image/BufImgSurfaceData
+sun/java2d/opengl/GLXGraphicsConfig
+sun/java2d/opengl/OGLGraphicsConfig
+sun/java2d/x11/X11SurfaceData$X11PixmapSurfaceData
+sun/awt/image/WritableRasterNative
+sun/awt/image/DataBufferNative
+sun/java2d/SurfaceManagerFactory
+sun/java2d/opengl/GLXSurfaceData
+sun/java2d/opengl/OGLSurfaceData
+sun/font/CompositeGlyphMapper
+sun/java2d/loops/FontInfo
+java/util/Date
+sun/util/calendar/CalendarSystem
+sun/util/calendar/Gregorian
+sun/util/calendar/BaseCalendar
+sun/util/calendar/AbstractCalendar
+java/util/TimeZone
+java/lang/InheritableThreadLocal
+sun/util/calendar/ZoneInfo
+sun/util/calendar/ZoneInfoFile
+sun/util/calendar/ZoneInfoFile$1
+java/util/TimeZone$1
+sun/util/calendar/Gregorian$Date
+sun/util/calendar/BaseCalendar$Date
+sun/util/calendar/CalendarDate
+sun/util/calendar/CalendarUtils
+java/util/TimeZone$DisplayNames
+sun/util/TimeZoneNameUtility
+sun/util/resources/TimeZoneNames
+sun/util/resources/TimeZoneNamesBundle
+sun/util/resources/TimeZoneNames_en
+java/util/spi/TimeZoneNameProvider
+java/lang/ProcessBuilder
+java/lang/ProcessImpl
+java/lang/UNIXProcess
+java/lang/Process
+java/lang/UNIXProcess$1
+java/net/ServerSocket
+java/util/Random
+java/util/concurrent/atomic/AtomicLong
+java/lang/InternalError
+java/io/StringReader
+java/lang/SecurityException
+java/io/FilterReader
+java/lang/reflect/Proxy
+java/lang/reflect/InvocationHandler
+java/lang/NoSuchFieldException
+java/lang/InstantiationException
+java/lang/ArrayIndexOutOfBoundsException
+java/lang/IndexOutOfBoundsException
+javax/swing/JDialog
+sun/awt/X11/XClipboard
+sun/awt/datatransfer/SunClipboard
+java/awt/datatransfer/Clipboard
+java/awt/datatransfer/SystemFlavorMap
+java/awt/datatransfer/FlavorMap
+java/awt/datatransfer/FlavorTable
+java/awt/datatransfer/SystemFlavorMap$1
+sun/net/ProgressMonitor
+sun/net/DefaultProgressMeteringPolicy
+sun/net/ProgressMeteringPolicy
+java/awt/datatransfer/SystemFlavorMap$2
+java/awt/datatransfer/MimeType
+java/io/Externalizable
+java/awt/datatransfer/MimeTypeParameterList
+sun/awt/datatransfer/DataTransferer
+java/util/Collections$SynchronizedSet
+java/util/Collections$SynchronizedCollection
+java/awt/datatransfer/DataFlavor
+java/awt/datatransfer/DataFlavor$1
+sun/awt/datatransfer/DataTransferer$CharsetComparator
+sun/awt/datatransfer/DataTransferer$IndexedComparator
+sun/nio/cs/UTF_16LE
+sun/nio/cs/UTF_16BE
+sun/awt/datatransfer/DataTransferer$DataFlavorComparator
+java/rmi/Remote
+sun/awt/datatransfer/DataTransferer$1
+sun/awt/X11/XDataTransferer
+sun/awt/datatransfer/ToolkitThreadBlockedHandler
+javax/imageio/ImageTypeSpecifier
+sun/awt/X11/XSelection
+sun/security/action/GetIntegerAction
+sun/awt/X11/XSelection$IncrementalTransferHandler
+sun/awt/X11/XSelection$SelectionEventHandler
+java/awt/datatransfer/Transferable
+java/io/EOFException
+java/util/Vector$1
+java/util/zip/ZipFile$1
+java/util/zip/ZipFile$2
+java/util/jar/JarFile$1
+java/util/PropertyResourceBundle
+java/util/ResourceBundle$Control$1
+java/util/Hashtable$EntrySet
+java/lang/IllegalAccessError
+java/text/MessageFormat
+java/text/MessageFormat$Field
+java/text/Format$Field
+java/lang/CloneNotSupportedException
+sun/reflect/MethodAccessorGenerator
+sun/reflect/AccessorGenerator
+sun/reflect/ClassFileConstants
+java/lang/Void
+sun/reflect/ByteVectorFactory
+sun/reflect/ByteVectorImpl
+sun/reflect/ByteVector
+sun/reflect/ClassFileAssembler
+sun/reflect/UTF8
+sun/reflect/Label
+sun/reflect/Label$PatchInfo
+sun/reflect/MethodAccessorGenerator$1
+sun/reflect/ClassDefiner
+sun/reflect/ClassDefiner$1
+sun/reflect/BootstrapConstructorAccessorImpl
+java/awt/event/ActionListener
+javax/swing/Timer
+javax/swing/Timer$DoPostEvent
+javax/swing/TimerQueue
+javax/swing/TimerQueue$1
+javax/swing/ToolTipManager
+java/awt/event/MouseAdapter
+javax/swing/ToolTipManager$insideTimerAction
+javax/swing/ToolTipManager$outsideTimerAction
+javax/swing/ToolTipManager$stillInsideTimerAction
+sun/swing/UIAction
+javax/swing/Action
+javax/swing/ToolTipManager$MoveBeforeEnterListener
+java/awt/event/MouseMotionAdapter
+java/util/Hashtable$ValueCollection
+javax/swing/event/CaretListener
+javax/swing/JToolBar
+javax/swing/JSplitPane
+javax/swing/border/Border
+javax/swing/JToggleButton
+javax/swing/border/EmptyBorder
+javax/swing/border/AbstractBorder
+javax/swing/DefaultButtonModel
+javax/swing/ButtonModel
+javax/swing/AbstractButton$Handler
+javax/swing/event/ChangeListener
+java/awt/event/ItemListener
+javax/swing/plaf/metal/MetalButtonUI
+javax/swing/plaf/basic/BasicButtonUI
+javax/swing/plaf/ButtonUI
+javax/swing/plaf/metal/MetalBorders
+javax/swing/plaf/BorderUIResource$CompoundBorderUIResource
+javax/swing/border/CompoundBorder
+javax/swing/plaf/metal/MetalBorders$ButtonBorder
+javax/swing/plaf/basic/BasicBorders$MarginBorder
+javax/swing/plaf/basic/BasicButtonListener
+java/awt/AWTEventMulticaster
+java/awt/event/WindowFocusListener
+java/awt/event/WindowStateListener
+java/awt/event/AdjustmentListener
+java/awt/event/TextListener
+javax/swing/event/AncestorListener
+java/beans/VetoableChangeListener
+javax/swing/ButtonGroup
+javax/swing/JToggleButton$ToggleButtonModel
+javax/swing/plaf/metal/MetalToggleButtonUI
+javax/swing/plaf/basic/BasicToggleButtonUI
+javax/swing/plaf/metal/MetalBorders$ToggleButtonBorder
+java/awt/CardLayout
+javax/swing/Box
+javax/swing/plaf/metal/MetalBorders$TextFieldBorder
+javax/swing/plaf/metal/MetalBorders$Flush3DBorder
+javax/swing/BoxLayout
+javax/swing/JMenuBar
+javax/swing/DefaultSingleSelectionModel
+javax/swing/SingleSelectionModel
+javax/swing/plaf/basic/BasicMenuBarUI
+javax/swing/plaf/MenuBarUI
+javax/swing/plaf/basic/DefaultMenuLayout
+javax/swing/plaf/metal/MetalBorders$MenuBarBorder
+javax/swing/plaf/basic/BasicMenuBarUI$Handler
+javax/swing/KeyboardManager
+javax/swing/event/MenuEvent
+javax/swing/JMenu$MenuChangeListener
+javax/swing/JMenuItem$MenuItemFocusListener
+javax/swing/plaf/basic/BasicMenuUI
+javax/swing/plaf/basic/BasicMenuItemUI
+javax/swing/plaf/MenuItemUI
+javax/swing/plaf/metal/MetalBorders$MenuItemBorder
+javax/swing/plaf/metal/MetalIconFactory
+javax/swing/plaf/metal/MetalIconFactory$MenuArrowIcon
+javax/swing/plaf/basic/BasicMenuUI$Handler
+javax/swing/event/MenuKeyListener
+javax/swing/plaf/basic/BasicMenuItemUI$Handler
+javax/swing/event/MenuDragMouseListener
+javax/swing/event/MouseInputListener
+javax/swing/event/ChangeEvent
+java/awt/event/ContainerEvent
+javax/swing/plaf/metal/MetalIconFactory$MenuItemArrowIcon
+javax/swing/JPopupMenu
+javax/swing/plaf/basic/BasicPopupMenuUI
+javax/swing/plaf/PopupMenuUI
+javax/swing/plaf/basic/BasicLookAndFeel$AWTEventHelper
+java/awt/event/AWTEventListenerProxy
+java/awt/Toolkit$SelectiveAWTEventListener
+java/awt/Toolkit$ToolkitEventMulticaster
+javax/swing/plaf/basic/BasicLookAndFeel$1
+javax/swing/plaf/metal/MetalBorders$PopupMenuBorder
+javax/swing/plaf/basic/BasicPopupMenuUI$BasicPopupMenuListener
+javax/swing/event/PopupMenuListener
+javax/swing/plaf/basic/BasicPopupMenuUI$BasicMenuKeyListener
+javax/swing/plaf/basic/BasicPopupMenuUI$MouseGrabber
+javax/swing/MenuSelectionManager
+javax/swing/plaf/basic/BasicPopupMenuUI$MenuKeyboardHelper
+javax/swing/plaf/basic/BasicPopupMenuUI$MenuKeyboardHelper$1
+java/awt/event/FocusAdapter
+javax/swing/JMenu$WinListener
+java/awt/event/WindowAdapter
+javax/swing/JPopupMenu$Separator
+javax/swing/JSeparator
+javax/swing/plaf/metal/MetalPopupMenuSeparatorUI
+javax/swing/plaf/metal/MetalSeparatorUI
+javax/swing/plaf/basic/BasicSeparatorUI
+javax/swing/plaf/SeparatorUI
+javax/swing/JComboBox
+javax/swing/event/ListDataListener
+javax/swing/event/CaretEvent
+javax/swing/text/TabExpander
+javax/swing/JScrollBar
+java/awt/Adjustable
+javax/swing/event/MouseInputAdapter
+javax/swing/JScrollBar$ModelListener
+javax/swing/DefaultBoundedRangeModel
+javax/swing/BoundedRangeModel
+javax/swing/plaf/metal/MetalScrollBarUI
+javax/swing/plaf/basic/BasicScrollBarUI
+javax/swing/plaf/ScrollBarUI
+javax/swing/plaf/metal/MetalBumps
+javax/swing/plaf/metal/MetalScrollButton
+javax/swing/plaf/basic/BasicArrowButton
+javax/swing/plaf/basic/BasicScrollBarUI$TrackListener
+javax/swing/plaf/basic/BasicScrollBarUI$ArrowButtonListener
+javax/swing/plaf/basic/BasicScrollBarUI$ModelListener
+javax/swing/plaf/metal/MetalScrollBarUI$ScrollBarListener
+javax/swing/plaf/basic/BasicScrollBarUI$PropertyChangeHandler
+javax/swing/plaf/basic/BasicScrollBarUI$Handler
+javax/swing/plaf/basic/BasicScrollBarUI$ScrollListener
+javax/swing/CellRendererPane
+java/util/HashMap$EntryIterator
+javax/swing/border/MatteBorder
+sun/font/StandardGlyphVector
+java/awt/font/GlyphVector
+sun/font/StandardGlyphVector$GlyphStrike
+sun/font/CoreMetrics
+sun/font/FontLineMetrics
+java/awt/font/LineMetrics
+javax/swing/ComboBoxModel
+javax/swing/ListModel
+javax/swing/ListCellRenderer
+javax/swing/DefaultComboBoxModel
+javax/swing/MutableComboBoxModel
+javax/swing/AbstractListModel
+javax/swing/JComboBox$1
+javax/swing/AncestorNotifier
+javax/swing/plaf/metal/MetalComboBoxUI
+javax/swing/plaf/basic/BasicComboBoxUI
+javax/swing/plaf/ComboBoxUI
+javax/swing/plaf/metal/MetalComboBoxUI$MetalComboBoxLayoutManager
+javax/swing/plaf/basic/BasicComboBoxUI$ComboBoxLayoutManager
+javax/swing/plaf/basic/BasicComboPopup
+javax/swing/plaf/basic/ComboPopup
+javax/swing/plaf/basic/BasicComboPopup$EmptyListModelClass
+javax/swing/border/LineBorder
+javax/swing/plaf/basic/BasicComboPopup$1
+javax/swing/JList
+javax/swing/DropMode
+javax/swing/DefaultListSelectionModel
+javax/swing/ListSelectionModel
+javax/swing/plaf/basic/BasicListUI
+javax/swing/plaf/ListUI
+javax/swing/plaf/basic/BasicListUI$ListTransferHandler
+javax/swing/TransferHandler
+javax/swing/TransferHandler$TransferAction
+javax/swing/DefaultListCellRenderer$UIResource
+javax/swing/DefaultListCellRenderer
+javax/swing/TransferHandler$SwingDropTarget
+java/awt/dnd/DropTargetContext
+javax/swing/TransferHandler$DropHandler
+javax/swing/TransferHandler$TransferSupport
+javax/swing/plaf/basic/BasicListUI$Handler
+javax/swing/event/ListSelectionListener
+javax/swing/plaf/basic/DragRecognitionSupport$BeforeDrag
+javax/swing/plaf/basic/BasicComboPopup$Handler
+javax/swing/JScrollPane
+javax/swing/ScrollPaneConstants
+javax/swing/ScrollPaneLayout$UIResource
+javax/swing/ScrollPaneLayout
+javax/swing/JViewport
+javax/swing/ViewportLayout
+javax/swing/plaf/basic/BasicViewportUI
+javax/swing/plaf/ViewportUI
+javax/swing/JScrollPane$ScrollBar
+javax/swing/JViewport$ViewListener
+java/awt/event/ComponentAdapter
+javax/swing/plaf/metal/MetalScrollPaneUI
+javax/swing/plaf/basic/BasicScrollPaneUI
+javax/swing/plaf/ScrollPaneUI
+javax/swing/plaf/metal/MetalBorders$ScrollPaneBorder
+javax/swing/plaf/basic/BasicScrollPaneUI$Handler
+javax/swing/plaf/metal/MetalScrollPaneUI$1
+javax/swing/plaf/basic/BasicComboBoxRenderer$UIResource
+javax/swing/plaf/basic/BasicComboBoxRenderer
+javax/swing/plaf/metal/MetalComboBoxEditor$UIResource
+javax/swing/plaf/metal/MetalComboBoxEditor
+javax/swing/plaf/basic/BasicComboBoxEditor
+javax/swing/ComboBoxEditor
+javax/swing/plaf/basic/BasicComboBoxEditor$BorderlessTextField
+javax/swing/JTextField$NotifyAction
+javax/swing/text/TextAction
+javax/swing/AbstractAction
+javax/swing/text/JTextComponent$MutableCaretEvent
+javax/swing/plaf/metal/MetalTextFieldUI
+javax/swing/plaf/basic/BasicTextFieldUI
+javax/swing/plaf/basic/BasicTextUI
+javax/swing/text/ViewFactory
+javax/swing/plaf/TextUI
+javax/swing/plaf/basic/BasicTextUI$BasicCursor
+javax/swing/text/DefaultEditorKit
+javax/swing/text/EditorKit
+javax/swing/text/DefaultEditorKit$InsertContentAction
+javax/swing/text/DefaultEditorKit$DeletePrevCharAction
+javax/swing/text/DefaultEditorKit$DeleteNextCharAction
+javax/swing/text/DefaultEditorKit$ReadOnlyAction
+javax/swing/text/DefaultEditorKit$DeleteWordAction
+javax/swing/text/DefaultEditorKit$WritableAction
+javax/swing/text/DefaultEditorKit$CutAction
+javax/swing/text/DefaultEditorKit$CopyAction
+javax/swing/text/DefaultEditorKit$PasteAction
+javax/swing/text/DefaultEditorKit$VerticalPageAction
+javax/swing/text/DefaultEditorKit$PageAction
+javax/swing/text/DefaultEditorKit$InsertBreakAction
+javax/swing/text/DefaultEditorKit$BeepAction
+javax/swing/text/DefaultEditorKit$NextVisualPositionAction
+javax/swing/text/DefaultEditorKit$BeginWordAction
+javax/swing/text/DefaultEditorKit$EndWordAction
+javax/swing/text/DefaultEditorKit$PreviousWordAction
+javax/swing/text/DefaultEditorKit$NextWordAction
+javax/swing/text/DefaultEditorKit$BeginLineAction
+javax/swing/text/DefaultEditorKit$EndLineAction
+javax/swing/text/DefaultEditorKit$BeginParagraphAction
+javax/swing/text/DefaultEditorKit$EndParagraphAction
+javax/swing/text/DefaultEditorKit$BeginAction
+javax/swing/text/DefaultEditorKit$EndAction
+javax/swing/text/DefaultEditorKit$DefaultKeyTypedAction
+javax/swing/text/DefaultEditorKit$InsertTabAction
+javax/swing/text/DefaultEditorKit$SelectWordAction
+javax/swing/text/DefaultEditorKit$SelectLineAction
+javax/swing/text/DefaultEditorKit$SelectParagraphAction
+javax/swing/text/DefaultEditorKit$SelectAllAction
+javax/swing/text/DefaultEditorKit$UnselectAction
+javax/swing/text/DefaultEditorKit$ToggleComponentOrientationAction
+javax/swing/text/DefaultEditorKit$DumpModelAction
+javax/swing/plaf/basic/BasicTextUI$TextTransferHandler
+javax/swing/text/Position$Bias
+javax/swing/plaf/basic/BasicTextUI$RootView
+javax/swing/text/View
+javax/swing/plaf/basic/BasicTextUI$UpdateHandler
+javax/swing/event/DocumentListener
+javax/swing/plaf/basic/BasicTextUI$DragListener
+javax/swing/plaf/basic/BasicComboBoxEditor$UIResource
+javax/swing/plaf/basic/BasicTextUI$BasicCaret
+javax/swing/text/DefaultCaret
+javax/swing/text/Caret
+javax/swing/text/DefaultCaret$Handler
+java/awt/datatransfer/ClipboardOwner
+javax/swing/plaf/basic/BasicTextUI$BasicHighlighter
+javax/swing/text/DefaultHighlighter
+javax/swing/text/LayeredHighlighter
+javax/swing/text/Highlighter
+javax/swing/text/Highlighter$Highlight
+javax/swing/text/DefaultHighlighter$DefaultHighlightPainter
+javax/swing/text/LayeredHighlighter$LayerPainter
+javax/swing/text/Highlighter$HighlightPainter
+javax/swing/text/DefaultHighlighter$SafeDamager
+javax/swing/text/FieldView
+javax/swing/text/PlainView
+javax/swing/text/JTextComponent$DefaultKeymap
+javax/swing/text/Keymap
+javax/swing/text/JTextComponent$KeymapWrapper
+javax/swing/text/JTextComponent$KeymapActionMap
+javax/swing/plaf/basic/BasicTextUI$FocusAction
+javax/swing/plaf/basic/BasicTextUI$TextActionWrapper
+javax/swing/JTextArea
+javax/swing/JEditorPane
+javax/swing/JTextField$ScrollRepainter
+javax/swing/plaf/metal/MetalComboBoxEditor$1
+javax/swing/plaf/metal/MetalComboBoxEditor$EditorBorder
+javax/swing/plaf/metal/MetalComboBoxUI$MetalPropertyChangeListener
+javax/swing/plaf/basic/BasicComboBoxUI$PropertyChangeHandler
+javax/swing/plaf/basic/BasicComboBoxUI$Handler
+javax/swing/plaf/metal/MetalComboBoxButton
+javax/swing/plaf/metal/MetalComboBoxIcon
+javax/swing/plaf/metal/MetalComboBoxButton$1
+javax/swing/plaf/basic/BasicComboBoxUI$DefaultKeySelectionManager
+javax/swing/JComboBox$KeySelectionManager
+javax/swing/JToolBar$DefaultToolBarLayout
+javax/swing/plaf/metal/MetalToolBarUI
+javax/swing/plaf/basic/BasicToolBarUI
+javax/swing/plaf/ToolBarUI
+javax/swing/plaf/metal/MetalBorders$ToolBarBorder
+javax/swing/plaf/metal/MetalLookAndFeel$MetalLazyValue$1
+javax/swing/plaf/metal/MetalBorders$RolloverButtonBorder
+javax/swing/plaf/metal/MetalBorders$RolloverMarginBorder
+javax/swing/plaf/basic/BasicBorders$RadioButtonBorder
+javax/swing/plaf/basic/BasicBorders$ButtonBorder
+javax/swing/plaf/basic/BasicBorders$RolloverMarginBorder
+javax/swing/plaf/metal/MetalToolBarUI$MetalDockingListener
+javax/swing/plaf/basic/BasicToolBarUI$DockingListener
+javax/swing/plaf/basic/BasicToolBarUI$Handler
+javax/swing/border/EtchedBorder
+javax/swing/JToolBar$Separator
+javax/swing/plaf/basic/BasicToolBarSeparatorUI
+java/applet/Applet
+java/awt/Panel
+com/sun/awt/AWTUtilities
+javax/swing/KeyboardManager$ComponentKeyStrokePair
+sun/awt/EmbeddedFrame
+sun/awt/im/InputMethodContext
+java/awt/im/spi/InputMethodContext
+sun/awt/im/InputContext
+sun/awt/im/InputMethodManager
+sun/awt/im/ExecutableInputMethodManager
+sun/awt/X11/XInputMethodDescriptor
+sun/awt/X11InputMethodDescriptor
+java/awt/im/spi/InputMethodDescriptor
+sun/awt/im/InputMethodLocator
+sun/awt/im/ExecutableInputMethodManager$2
+sun/misc/Service
+sun/misc/Service$LazyIterator
+java/util/TreeSet
+java/util/NavigableSet
+java/util/SortedSet
+javax/swing/SizeRequirements
+javax/swing/plaf/basic/BasicGraphicsUtils
+java/awt/event/AdjustmentEvent
+java/awt/MenuBar
+sun/awt/X11/XComponentPeer$2
+java/awt/SequencedEvent
+java/beans/PropertyVetoException
+java/awt/DefaultKeyboardFocusManager$TypeAheadMarker
+java/awt/KeyboardFocusManager$HeavyweightFocusRequest
+java/awt/KeyboardFocusManager$LightweightFocusRequest
+sun/awt/KeyboardFocusManagerPeerImpl
+sun/awt/SunToolkit$7
+java/awt/Window$1DisposeAction
+java/awt/LightweightDispatcher$2
+sun/awt/X11/XReparentEvent
+sun/awt/X11/XWindowAttributes
+sun/awt/X11/XFocusChangeEvent
+sun/awt/X11/XComponentPeer$1
+sun/awt/X11/XUnmapEvent
+java/io/StringWriter
+javax/swing/JWindow
+java/io/UnsupportedEncodingException
+java/net/UnknownHostException
+java/nio/channels/SocketChannel
+java/nio/channels/spi/AbstractSelectableChannel
+java/nio/channels/SelectableChannel
+java/net/SocketImplFactory
+javax/swing/UnsupportedLookAndFeelException
+java/lang/UnsatisfiedLinkError
+javax/swing/Box$Filler
+javax/swing/JComponent$2
+sun/net/www/MimeTable
+java/net/FileNameMap
+sun/net/www/MimeTable$1
+sun/net/www/MimeEntry
+java/net/URLConnection$1
+java/text/SimpleDateFormat
+java/text/DateFormat
+java/text/DateFormat$Field
+java/util/Calendar
+java/util/GregorianCalendar
+sun/util/resources/CalendarData
+sun/util/resources/CalendarData_en
+java/text/DateFormatSymbols
+java/text/spi/DateFormatSymbolsProvider
+java/text/DontCareFieldPosition
+java/text/DontCareFieldPosition$1
+java/text/Format$FieldDelegate
+javax/swing/plaf/BorderUIResource
+javax/swing/BorderFactory
+javax/swing/border/BevelBorder
+javax/swing/plaf/metal/MetalIconFactory$TreeFolderIcon
+javax/swing/plaf/metal/MetalIconFactory$FolderIcon16
+java/util/zip/ZipInputStream
+java/io/PushbackInputStream
+java/util/zip/CRC32
+java/util/zip/Checksum
+java/lang/Thread$State
+javax/swing/SwingUtilities$SharedOwnerFrame
+javax/swing/JTable
+javax/swing/event/TableModelListener
+javax/swing/event/TableColumnModelListener
+javax/swing/event/CellEditorListener
+javax/swing/event/RowSorterListener
+javax/swing/BufferStrategyPaintManager$BufferInfo
+java/awt/Component$BltSubRegionBufferStrategy
+sun/awt/SubRegionShowable
+java/awt/Component$BltBufferStrategy
+sun/awt/image/SunVolatileImage
+sun/awt/image/BufferedImageGraphicsConfig
+sun/print/PrinterGraphicsConfig
+sun/java2d/x11/X11VolatileSurfaceManager
+sun/awt/image/VolatileSurfaceManager
+java/awt/print/PrinterGraphics
+java/awt/PrintGraphics
+java/awt/GraphicsCallback$PaintCallback
+java/awt/GraphicsCallback
+sun/awt/SunGraphicsCallback
+javax/swing/JRadioButton
+java/lang/ClassFormatError
+javax/swing/JTabbedPane
+javax/swing/JTabbedPane$ModelListener
+javax/swing/plaf/metal/MetalTabbedPaneUI
+javax/swing/plaf/basic/BasicTabbedPaneUI
+javax/swing/plaf/TabbedPaneUI
+javax/swing/plaf/metal/MetalTabbedPaneUI$TabbedPaneLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$TabbedPaneLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$TabbedPaneScrollLayout
+javax/swing/plaf/basic/BasicTabbedPaneUI$Handler
+sun/swing/ImageIconUIResource
+javax/swing/GrayFilter
+java/awt/image/RGBImageFilter
+java/awt/image/ImageFilter
+java/awt/image/FilteredImageSource
+org/w3c/dom/Node
+org/xml/sax/SAXException
+javax/xml/parsers/ParserConfigurationException
+org/xml/sax/EntityResolver
+java/security/NoSuchAlgorithmException
+java/security/GeneralSecurityException
+java/util/zip/GZIPInputStream
+java/util/zip/DeflaterOutputStream
+org/xml/sax/InputSource
+javax/xml/parsers/DocumentBuilderFactory
+javax/xml/parsers/FactoryFinder
+javax/xml/parsers/SecuritySupport
+javax/xml/parsers/SecuritySupport$2
+javax/xml/parsers/SecuritySupport$5
+javax/xml/parsers/SecuritySupport$1
+javax/xml/parsers/SecuritySupport$4
+javax/xml/parsers/DocumentBuilder
+org/w3c/dom/Document
+org/xml/sax/helpers/DefaultHandler
+org/xml/sax/DTDHandler
+org/xml/sax/ContentHandler
+org/xml/sax/ErrorHandler
+org/xml/sax/SAXNotSupportedException
+org/xml/sax/Locator
+org/xml/sax/SAXNotRecognizedException
+org/xml/sax/SAXParseException
+org/w3c/dom/NodeList
+org/w3c/dom/events/EventTarget
+org/w3c/dom/traversal/DocumentTraversal
+org/w3c/dom/events/DocumentEvent
+org/w3c/dom/ranges/DocumentRange
+org/w3c/dom/Entity
+org/w3c/dom/Element
+org/w3c/dom/CharacterData
+org/w3c/dom/CDATASection
+org/w3c/dom/Text
+org/xml/sax/AttributeList
+org/w3c/dom/DOMException
+org/w3c/dom/Notation
+org/w3c/dom/DocumentType
+org/w3c/dom/Attr
+org/w3c/dom/EntityReference
+org/w3c/dom/ProcessingInstruction
+org/w3c/dom/Comment
+org/w3c/dom/DocumentFragment
+org/w3c/dom/events/Event
+org/w3c/dom/events/MutationEvent
+org/w3c/dom/traversal/TreeWalker
+org/w3c/dom/ranges/Range
+org/w3c/dom/traversal/NodeIterator
+org/w3c/dom/events/EventException
+org/w3c/dom/NamedNodeMap
+java/lang/StringIndexOutOfBoundsException
+java/awt/GridLayout
+javax/swing/plaf/metal/MetalRadioButtonUI
+javax/swing/plaf/basic/BasicRadioButtonUI
+javax/swing/plaf/basic/BasicBorders
+javax/swing/plaf/metal/MetalIconFactory$RadioButtonIcon
+java/awt/event/ItemEvent
+java/awt/CardLayout$Card
+javax/swing/JCheckBox
+javax/swing/event/ListSelectionEvent
+javax/swing/plaf/metal/MetalCheckBoxUI
+javax/swing/plaf/metal/MetalIconFactory$CheckBoxIcon
+java/lang/ExceptionInInitializerError
+com/sun/java/swing/plaf/windows/WindowsTabbedPaneUI
+javax/swing/JProgressBar
+javax/swing/JProgressBar$ModelListener
+javax/swing/plaf/metal/MetalProgressBarUI
+javax/swing/plaf/basic/BasicProgressBarUI
+javax/swing/plaf/ProgressBarUI
+javax/swing/plaf/BorderUIResource$LineBorderUIResource
+javax/swing/plaf/basic/BasicProgressBarUI$Handler
+javax/swing/tree/TreeModel
+javax/swing/table/TableCellRenderer
+javax/swing/table/JTableHeader
+javax/swing/event/TreeExpansionListener
+javax/swing/table/AbstractTableModel
+javax/swing/table/TableModel
+javax/swing/table/DefaultTableCellRenderer
+javax/swing/JTree
+javax/swing/tree/TreeSelectionModel
+javax/swing/tree/DefaultTreeCellRenderer
+javax/swing/tree/TreeCellRenderer
+javax/swing/table/TableCellEditor
+javax/swing/CellEditor
+javax/swing/JToolTip
+javax/swing/table/TableColumn
+javax/swing/table/DefaultTableColumnModel
+javax/swing/table/TableColumnModel
+javax/swing/table/DefaultTableModel
+javax/swing/event/TableModelEvent
+sun/swing/table/DefaultTableCellHeaderRenderer
+javax/swing/plaf/basic/BasicTableHeaderUI
+javax/swing/plaf/TableHeaderUI
+javax/swing/plaf/basic/BasicTableHeaderUI$1
+javax/swing/plaf/basic/BasicTableHeaderUI$MouseInputHandler
+javax/swing/DefaultCellEditor
+javax/swing/tree/TreeCellEditor
+javax/swing/AbstractCellEditor
+javax/swing/plaf/basic/BasicTableUI
+javax/swing/plaf/TableUI
+javax/swing/plaf/basic/BasicTableUI$TableTransferHandler
+javax/swing/plaf/basic/BasicTableUI$Handler
+javax/swing/tree/DefaultTreeSelectionModel
+javax/swing/tree/TreePath
+javax/swing/plaf/metal/MetalTreeUI
+javax/swing/plaf/basic/BasicTreeUI
+javax/swing/plaf/TreeUI
+javax/swing/plaf/basic/BasicTreeUI$Actions
+javax/swing/plaf/basic/BasicTreeUI$TreeTransferHandler
+javax/swing/plaf/metal/MetalTreeUI$LineListener
+javax/swing/plaf/basic/BasicTreeUI$Handler
+javax/swing/event/TreeModelListener
+javax/swing/event/TreeSelectionListener
+javax/swing/event/SwingPropertyChangeSupport
+javax/swing/tree/VariableHeightLayoutCache
+javax/swing/tree/AbstractLayoutCache
+javax/swing/tree/RowMapper
+javax/swing/plaf/basic/BasicTreeUI$NodeDimensionsHandler
+javax/swing/tree/AbstractLayoutCache$NodeDimensions
+javax/swing/JTree$TreeModelHandler
+javax/swing/tree/VariableHeightLayoutCache$TreeStateNode
+javax/swing/tree/DefaultMutableTreeNode
+javax/swing/tree/MutableTreeNode
+javax/swing/tree/DefaultMutableTreeNode$PreorderEnumeration
+javax/swing/event/TableColumnModelEvent
+java/text/ParseException
+java/text/NumberFormat$Field
+javax/swing/event/UndoableEditListener
+javax/swing/filechooser/FileFilter
+javax/swing/tree/DefaultTreeModel
+javax/swing/tree/DefaultTreeCellEditor
+javax/swing/tree/DefaultTreeCellEditor$1
+javax/swing/tree/DefaultTreeCellEditor$DefaultTextField
+javax/swing/DefaultCellEditor$1
+javax/swing/DefaultCellEditor$EditorDelegate
+javax/swing/tree/DefaultTreeCellEditor$EditorContainer
+javax/swing/JTree$TreeSelectionRedirector
+javax/swing/event/TreeModelEvent
+javax/swing/plaf/metal/MetalSplitPaneUI
+javax/swing/plaf/basic/BasicSplitPaneUI
+javax/swing/plaf/SplitPaneUI
+javax/swing/plaf/basic/BasicSplitPaneDivider
+javax/swing/plaf/basic/BasicBorders$SplitPaneBorder
+javax/swing/plaf/metal/MetalSplitPaneDivider
+javax/swing/plaf/basic/BasicSplitPaneDivider$DividerLayout
+javax/swing/plaf/basic/BasicSplitPaneDivider$MouseHandler
+javax/swing/plaf/basic/BasicBorders$SplitPaneDividerBorder
+javax/swing/plaf/basic/BasicSplitPaneUI$BasicHorizontalLayoutManager
+javax/swing/plaf/basic/BasicSplitPaneUI$1
+javax/swing/plaf/basic/BasicSplitPaneUI$Handler
+javax/swing/plaf/metal/MetalSplitPaneDivider$1
+javax/swing/plaf/basic/BasicSplitPaneDivider$OneTouchActionHandler
+javax/swing/plaf/metal/MetalSplitPaneDivider$2
+javax/swing/border/TitledBorder
+javax/swing/plaf/basic/BasicTextAreaUI
+java/util/Collections$UnmodifiableCollection$1
+java/io/InterruptedIOException
+java/net/NoRouteToHostException
+java/net/BindException
+javax/swing/tree/PathPlaceHolder
+javax/swing/event/TreeSelectionEvent
+javax/swing/JList$3
+javax/swing/JList$ListSelectionHandler
+javax/swing/JSlider
+javax/swing/JSlider$ModelListener
+javax/swing/plaf/metal/MetalSliderUI
+javax/swing/plaf/basic/BasicSliderUI
+javax/swing/plaf/SliderUI
+javax/swing/plaf/basic/BasicSliderUI$Actions
+javax/swing/plaf/metal/MetalIconFactory$HorizontalSliderThumbIcon
+javax/swing/plaf/metal/MetalIconFactory$VerticalSliderThumbIcon
+javax/swing/plaf/basic/BasicSliderUI$TrackListener
+javax/swing/plaf/basic/BasicSliderUI$Handler
+javax/swing/plaf/basic/BasicSliderUI$ScrollListener
+javax/swing/plaf/metal/MetalSliderUI$MetalPropertyListener
+javax/swing/plaf/basic/BasicSliderUI$PropertyChangeHandler
+sun/java2d/HeadlessGraphicsEnvironment
+java/util/Hashtable$KeySet
+java/awt/FontFormatException
+sun/font/Type1Font$1
+java/nio/channels/FileChannel$MapMode
+sun/nio/ch/FileChannelImpl$Unmapper
+sun/nio/ch/Util$3
+java/nio/DirectByteBufferR
+java/nio/charset/Charset$3
+sun/nio/cs/AbstractCharsetProvider
+sun/nio/cs/SingleByteDecoder
+java/lang/CharacterData00
+javax/swing/DefaultListModel
+javax/swing/event/ListDataEvent
+javax/sound/sampled/DataLine
+javax/sound/sampled/Line
+javax/sound/sampled/Line$Info
+javax/sound/sampled/DataLine$Info
+javax/sound/sampled/Control$Type
+javax/sound/sampled/FloatControl$Type
+javax/sound/sampled/LineUnavailableException
+javax/sound/sampled/UnsupportedAudioFileException
+javax/swing/JRadioButtonMenuItem
+javax/swing/JMenuItem$AccessibleJMenuItem
+javax/swing/AbstractButton$AccessibleAbstractButton
+javax/accessibility/AccessibleAction
+javax/accessibility/AccessibleValue
+javax/accessibility/AccessibleText
+javax/accessibility/AccessibleExtendedComponent
+javax/accessibility/AccessibleComponent
+javax/swing/JComponent$AccessibleJComponent
+java/awt/Container$AccessibleAWTContainer
+java/awt/Component$AccessibleAWTComponent
+javax/accessibility/AccessibleRelationSet
+javax/accessibility/AccessibleState
+javax/accessibility/AccessibleBundle
+javax/swing/plaf/basic/BasicCheckBoxMenuItemUI
+javax/swing/plaf/metal/MetalIconFactory$CheckBoxMenuItemIcon
+javax/swing/JCheckBoxMenuItem$AccessibleJCheckBoxMenuItem
+javax/swing/plaf/basic/BasicRadioButtonMenuItemUI
+javax/swing/plaf/metal/MetalIconFactory$RadioButtonMenuItemIcon
+sun/awt/image/ImageDecoder$1
+javax/swing/JTabbedPane$Page
+java/net/DatagramSocket
+java/net/MulticastSocket
+java/net/DatagramPacket
+sun/net/InetAddressCachePolicy
+sun/net/InetAddressCachePolicy$1
+sun/net/InetAddressCachePolicy$2
+java/net/InetAddress$CacheEntry
+java/net/PlainDatagramSocketImpl
+java/net/DatagramSocketImpl
+java/net/NetworkInterface
+java/net/InterfaceAddress
+java/text/Collator
+java/text/spi/CollatorProvider
+sun/text/resources/CollationData
+sun/text/resources/CollationData_en
+sun/util/EmptyListResourceBundle
+java/text/RuleBasedCollator
+java/text/CollationRules
+java/text/RBCollationTables
+java/text/RBTableBuilder
+java/text/RBCollationTables$BuildAPI
+sun/text/IntHashtable
+sun/text/UCompactIntArray
+sun/text/normalizer/NormalizerImpl
+sun/text/normalizer/ICUData
+sun/text/normalizer/NormalizerDataReader
+sun/text/normalizer/ICUBinary$Authenticate
+sun/text/normalizer/ICUBinary
+sun/text/normalizer/NormalizerImpl$FCDTrieImpl
+sun/text/normalizer/Trie$DataManipulate
+sun/text/normalizer/NormalizerImpl$NormTrieImpl
+sun/text/normalizer/NormalizerImpl$AuxTrieImpl
+sun/text/normalizer/IntTrie
+sun/text/normalizer/Trie
+sun/text/normalizer/CharTrie
+sun/text/normalizer/CharTrie$FriendAgent
+sun/text/normalizer/UnicodeSet
+sun/text/normalizer/UnicodeMatcher
+sun/text/normalizer/NormalizerImpl$DecomposeArgs
+java/text/MergeCollation
+java/text/PatternEntry$Parser
+java/text/PatternEntry
+java/text/EntryPair
+sun/text/ComposedCharIter
+sun/text/normalizer/UTF16
+sun/net/www/protocol/http/Handler
+java/io/ObjectInputStream$BlockDataInputStream
+java/io/ObjectInputStream$PeekInputStream
+java/io/ObjectInputStream$HandleTable
+java/io/ObjectInputStream$ValidationList
+java/io/Bits
+java/io/ObjectStreamClass$Caches
+java/io/ObjectStreamClass$WeakClassKey
+java/io/ObjectStreamClass$EntryFuture
+java/io/ObjectStreamClass$2
+sun/reflect/SerializationConstructorAccessorImpl
+java/io/ObjectStreamClass$FieldReflectorKey
+java/io/ObjectStreamClass$FieldReflector
+java/io/ObjectStreamClass$1
+java/io/DataOutputStream
+java/io/ObjectStreamClass$MemberSignature
+java/io/ObjectStreamClass$3
+java/io/ObjectStreamClass$4
+java/io/ObjectStreamClass$5
+java/security/MessageDigest
+java/security/MessageDigestSpi
+sun/security/jca/GetInstance
+sun/security/jca/Providers
+sun/security/jca/ProviderList
+sun/security/jca/ProviderConfig
+sun/security/jca/ProviderList$3
+sun/security/jca/ProviderList$1
+sun/security/jca/ProviderList$2
+sun/security/jca/ProviderConfig$1
+sun/security/jca/ProviderConfig$3
+java/security/Provider$Service
+java/security/Provider$UString
+sun/security/provider/SHA
+sun/security/provider/DigestBase
+sun/security/jca/GetInstance$Instance
+java/security/MessageDigest$Delegate
+sun/security/provider/ByteArrayAccess
+java/io/ObjectStreamClass$ClassDataSlot
+sun/reflect/UnsafeQualifiedStaticLongFieldAccessorImpl
+java/security/SignatureException
+java/security/InvalidKeyException
+java/security/KeyException
+java/security/Signature
+java/security/SignatureSpi
+java/io/ObjectOutputStream$BlockDataOutputStream
+sun/security/provider/DSAPublicKey
+java/security/interfaces/DSAPublicKey
+java/security/interfaces/DSAKey
+java/security/PublicKey
+java/security/Key
+sun/security/x509/X509Key
+java/io/ObjectOutputStream$HandleTable
+java/io/ObjectOutputStream$ReplaceTable
+sun/security/x509/AlgorithmId
+sun/security/util/DerEncoder
+sun/security/util/BitArray
+sun/security/util/DerOutputStream
+sun/security/util/DerValue
+java/math/BigInteger
+java/security/interfaces/DSAParams
+sun/security/util/DerInputStream
+sun/security/util/DerInputBuffer
+sun/security/util/ObjectIdentifier
+java/security/AlgorithmParameters
+java/security/AlgorithmParametersSpi
+sun/security/provider/DSAParameters
+sun/security/util/ByteArrayLexOrder
+sun/security/util/ByteArrayTagOrder
+sun/security/util/DerIndefLenConverter
+java/io/InvalidClassException
+java/io/ObjectStreamException
+java/io/ObjectInputStream$GetFieldImpl
+java/io/ObjectInputStream$GetField
+sun/security/jca/ServiceId
+sun/security/jca/ProviderList$ServiceList
+sun/security/jca/ProviderList$ServiceList$1
+java/security/Signature$Delegate
+java/security/interfaces/DSAPrivateKey
+java/security/PrivateKey
+sun/security/provider/DSA$SHA1withDSA
+sun/security/provider/DSA
+java/security/spec/DSAParameterSpec
+java/security/spec/AlgorithmParameterSpec
+java/math/MutableBigInteger
+java/math/SignedMutableBigInteger
+java/awt/EventQueue$1AWTInvocationLock
+java/awt/Component$FlipBufferStrategy
+java/awt/SentEvent
+sun/awt/X11/XDestroyWindowEvent
+sun/awt/X11/XDropTargetRegistry
+sun/awt/X11/XEmbeddedFramePeer
+sun/awt/X11/XDragAndDropProtocols
+sun/awt/X11/XDropTargetContextPeer
+sun/awt/dnd/SunDropTargetContextPeer
+java/awt/dnd/peer/DropTargetContextPeer
+sun/awt/X11/XDropTargetContextPeer$XDropTargetProtocolListenerImpl
+sun/awt/X11/XDropTargetProtocolListener
+sun/awt/X11/XDnDDragSourceProtocol
+sun/awt/X11/XDragSourceProtocol
+sun/awt/X11/MotifDnDDragSourceProtocol
+sun/awt/X11/XDnDDropTargetProtocol
+sun/awt/X11/XDropTargetProtocol
+sun/awt/X11/MotifDnDDropTargetProtocol
+sun/awt/X11/XDnDConstants
+sun/awt/X11/MotifDnDConstants
+javax/swing/JTable$2
+javax/swing/JTable$Resizable3
+javax/swing/JTable$Resizable2
+javax/swing/JTable$5
+javax/swing/event/AncestorEvent
+sun/font/FontDesignMetrics$MetricsKey
+java/awt/geom/Line2D$Float
+java/awt/geom/Line2D
+com/sun/java/swing/plaf/gtk/GTKLookAndFeel
+javax/swing/plaf/synth/SynthLookAndFeel
+javax/swing/plaf/synth/DefaultSynthStyleFactory
+javax/swing/plaf/synth/SynthStyleFactory
+sun/swing/BakedArrayList
+javax/swing/plaf/synth/SynthLookAndFeel$Handler
+javax/swing/plaf/synth/SynthDefaultLookup
+com/sun/java/swing/plaf/gtk/GTKEngine
+com/sun/java/swing/plaf/gtk/GTKEngine$Settings
+com/sun/java/swing/plaf/gtk/GTKStyleFactory
+com/sun/java/swing/plaf/gtk/PangoFonts
+com/sun/java/swing/plaf/gtk/GTKLookAndFeel$WeakPCL
+javax/swing/plaf/synth/Region
+javax/swing/plaf/synth/SynthLookAndFeel$AATextListener
+com/sun/java/swing/plaf/gtk/GTKRegion
+com/sun/java/swing/plaf/gtk/GTKStyle
+com/sun/java/swing/plaf/gtk/GTKConstants
+javax/swing/plaf/synth/SynthStyle
+javax/swing/plaf/synth/SynthGraphicsUtils
+com/sun/java/swing/plaf/gtk/GTKGraphicsUtils
+com/sun/java/swing/plaf/gtk/GTKStyle$GTKStockIcon
+sun/swing/plaf/synth/SynthIcon
+com/sun/java/swing/plaf/gtk/GTKColorType
+javax/swing/plaf/synth/ColorType
+com/sun/java/swing/plaf/gtk/resources/gtk
+com/sun/swing/internal/plaf/synth/resources/synth
+com/sun/java/swing/plaf/gtk/GTKStyle$GTKLazyValue
+com/sun/java/swing/plaf/gtk/GTKLookAndFeel$1FontLazyValue
+com/sun/java/swing/plaf/gtk/GTKLookAndFeel$2
+com/sun/java/swing/plaf/gtk/GTKLookAndFeel$3
+javax/swing/plaf/synth/SynthPanelUI
+javax/swing/plaf/synth/SynthConstants
+javax/swing/plaf/synth/SynthContext
+javax/swing/plaf/synth/SynthBorder
+javax/swing/plaf/synth/SynthRootPaneUI
+javax/swing/plaf/synth/SynthLabelUI
+javax/swing/plaf/synth/SynthButtonUI
+javax/swing/plaf/synth/SynthToggleButtonUI
+javax/swing/plaf/basic/BasicBorders$FieldBorder
+javax/swing/plaf/synth/SynthMenuBarUI
+javax/swing/plaf/synth/SynthMenuUI
+javax/swing/plaf/synth/SynthUI
+com/sun/java/swing/plaf/gtk/GTKIconFactory
+com/sun/java/swing/plaf/gtk/GTKIconFactory$MenuArrowIcon
+com/sun/java/swing/plaf/gtk/GTKIconFactory$DelegatingIcon
+com/sun/java/swing/plaf/gtk/GTKConstants$ArrowType
+javax/swing/plaf/basic/BasicIconFactory
+javax/swing/plaf/basic/BasicIconFactory$MenuItemCheckIcon
+javax/swing/plaf/synth/SynthMenuItemUI
+javax/swing/plaf/synth/SynthPopupMenuUI
+javax/swing/plaf/synth/SynthSeparatorUI
+javax/swing/plaf/synth/SynthScrollBarUI
+javax/swing/plaf/synth/SynthArrowButton
+javax/swing/plaf/synth/SynthArrowButton$SynthArrowButtonUI
+javax/swing/plaf/synth/SynthComboBoxUI
+javax/swing/plaf/synth/SynthComboPopup
+javax/swing/plaf/synth/SynthListUI
+javax/swing/plaf/synth/SynthListUI$SynthListCellRenderer
+javax/swing/plaf/synth/SynthViewportUI
+javax/swing/plaf/synth/SynthScrollPaneUI
+javax/swing/plaf/synth/SynthScrollPaneUI$ViewportBorder
+javax/swing/plaf/synth/SynthComboBoxUI$SynthComboBoxRenderer
+javax/swing/plaf/synth/SynthComboBoxUI$SynthComboBoxEditor
+javax/swing/plaf/synth/SynthTextFieldUI
+javax/swing/plaf/synth/SynthToolBarUI
+javax/swing/plaf/synth/SynthToolBarUI$SynthToolBarLayoutManager
+com/sun/java/swing/plaf/gtk/GTKIconFactory$ToolBarHandleIcon
+com/sun/java/swing/plaf/gtk/GTKConstants$Orientation
+sun/awt/X11/XTranslateCoordinates
+com/sun/java/swing/plaf/gtk/GTKPainter
+javax/swing/plaf/synth/SynthPainter
+javax/swing/plaf/synth/SynthPainter$1
+com/sun/java/swing/plaf/gtk/GTKConstants$PositionType
+com/sun/java/swing/plaf/gtk/GTKConstants$ShadowType
+java/io/ObjectInputStream$HandleTable$HandleList
+sun/java2d/pipe/ShapeSpanIterator
+sun/java2d/pipe/SpanIterator
+sun/dc/path/PathConsumer
+sun/dc/pr/PathStroker
+sun/dc/pr/PathDasher
+java/awt/geom/LineIterator
+java/awt/geom/PathIterator
+sun/applet/Main
+sun/applet/AppletMessageHandler
+sun/applet/resources/MsgAppletViewer
+sun/applet/AppletSecurity
+sun/awt/AWTSecurityManager
+java/lang/SecurityManager
+java/security/DomainCombiner
+sun/applet/AppletSecurity$1
+java/lang/SecurityManager$1
+java/security/SecurityPermission
+java/util/PropertyPermission
+sun/applet/AppletViewer
+java/applet/AppletContext
+java/awt/print/Printable
+sun/security/util/SecurityConstants
+java/awt/AWTPermission
+java/net/NetPermission
+java/net/SocketPermission
+javax/security/auth/AuthPermission
+java/lang/Thread$1
+java/util/logging/LogManager$5
+sun/applet/StdAppletViewerFactory
+sun/applet/AppletViewerFactory
+sun/applet/AppletViewer$UserActionListener
+sun/applet/AppletViewerPanel
+sun/applet/AppletPanel
+java/applet/AppletStub
+sun/misc/MessageUtils
+sun/applet/AppletPanel$10
+java/security/Policy$1
+sun/security/provider/PolicyFile$1
+sun/security/provider/PolicyFile$3
+sun/security/util/PropertyExpander
+sun/security/provider/PolicyParser
+sun/security/util/PolicyUtil
+sun/security/provider/PolicyParser$GrantEntry
+sun/security/provider/PolicyParser$PermissionEntry
+sun/security/provider/PolicyFile$PolicyEntry
+sun/security/provider/PolicyFile$6
+sun/security/provider/PolicyFile$7
+java/net/SocketPermissionCollection
+java/util/PropertyPermissionCollection
+sun/applet/AppletPanel$9
+sun/applet/AppletClassLoader
+sun/applet/AppletThreadGroup
+sun/applet/AppContextCreator
+sun/applet/AppletPanel$1
+sun/awt/X11/XMenuBarPeer
+java/awt/peer/MenuBarPeer
+java/awt/peer/MenuComponentPeer
+sun/awt/X11/XBaseMenuWindow
+sun/awt/X11/XMenuPeer
+java/awt/peer/MenuPeer
+java/awt/peer/MenuItemPeer
+sun/awt/X11/XMenuItemPeer
+java/awt/MenuShortcut
+sun/awt/X11/XMenuWindow
+sun/awt/X11/XMenuItemPeer$TextMetrics
+sun/awt/AppContext$3
+sun/awt/X11/XMenuBarPeer$MappingData
+sun/awt/X11/XBaseMenuWindow$MappingData
+sun/applet/AppletViewer$1
+sun/applet/AppletViewer$1AppletEventListener
+sun/applet/AppletListener
+sun/applet/AppletEventMulticaster
+sun/misc/Queue
+sun/misc/QueueElement
+sun/applet/AppletEvent
+sun/applet/AppletClassLoader$1
+sun/awt/X11/XBaseMenuWindow$3
+java/awt/DefaultKeyboardFocusManager$DefaultKeyboardFocusManagerSentEvent
+sun/awt/CausedFocusEvent
+sun/awt/X11/XWindow$1
+java/net/URLClassLoader$4
+sun/applet/AppletClassLoader$2
+javax/swing/JApplet
+java/lang/ClassLoader$1
+sun/security/provider/PolicyFile$5
+java/security/PermissionsEnumerator
+java/util/Collections$1
+sun/applet/AppletPanel$11
+sun/applet/AppletPanel$8
+sun/applet/AppletPanel$2
+sun/applet/AppletPanel$3
+sun/applet/AppletPanel$6
+javax/swing/BufferStrategyPaintManager$1
+# f3ac8b467e7f8c49
--- jdk/src/bsd/doc/man/appletviewer.1	2012-08-10 10:22:48.000000000 -0700
+++ jdk/src/bsd/doc/man/appletviewer.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH appletviewer 1 "10 May 2011"
+.TH appletviewer 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -36,11 +36,14 @@
 .SH "DESCRIPTION"
 .LP
 .LP
-The \f3appletviewer\fP command connects to the documents or resources designated by \f2urls\fP and displays each applet referenced by the documents in its own window. Note: if the documents referred to by \f2urls\fP do not reference any applets with the \f2OBJECT\fP, \f2EMBED\fP, or \f2APPLET\fP tag, then \f3appletviewer\fP does nothing. For details on the HTML tags that \f3appletviewer\fP supports, see
+The \f3appletviewer\fP command connects to the documents or resources designated by \f2urls\fP and displays each applet referenced by the documents in its own window. Note: if the documents referred to by \f2urls\fP do not reference any applets with the \f2OBJECT\fP, \f2EMBED\fP, or \f2APPLET\fP tag, then \f3appletviewer\fP does nothing. For details on the HTML tags that \f3appletviewer\fP supports, see 
 .na
 \f2AppletViewer Tags\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/appletviewertags.html.
+http://docs.oracle.com/javase/7/docs/technotes/tools/appletviewertags.html.
+.LP
+.LP
+\f3Note:\fP The \f3appletviewer\fP is intended for development purposes only. See About Sample / Test Applications and Code for more information.
 .LP
 .LP
 \f3Note:\fP The \f3appletviewer\fP requires encoded URLs according to the escaping mechanism defined in RFC2396. Only encoded URLs are supported. However, file names must be unencoded, as specified in RFC2396.
@@ -49,18 +52,18 @@
 .LP
 .RS 3
 .TP 3
-\-debug
-Starts the applet viewer in the Java debugger, jdb(1), thus allowing you to debug the applets in the document.
+\-debug 
+Starts the applet viewer in the Java debugger, jdb(1), thus allowing you to debug the applets in the document. 
 .TP 3
-\-encoding \  \ encoding name
-Specify the input HTML file encoding name.
+\-encoding \  \ encoding name 
+Specify the input HTML file encoding name. 
 .TP 3
-\-Jjavaoption
-Passes through the string \f2javaoption\fP as a single argument to the Java interpreter which runs the appletviewer. The argument should not contain spaces. Multiple argument words must all begin with the prefix \f3\-J\fP, which is stripped. This is useful for adjusting the compiler's execution environment or memory usage.
+\-Jjavaoption 
+Passes through the string \f2javaoption\fP as a single argument to the Java interpreter which runs the appletviewer. The argument should not contain spaces. Multiple argument words must all begin with the prefix \f3\-J\fP, which is stripped. This is useful for adjusting the compiler's execution environment or memory usage. 
 .RE
 
 .LP
 .LP
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/apt.1	2012-08-10 10:22:48.000000000 -0700
+++ jdk/src/bsd/doc/man/apt.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH apt 1 "10 May 2011"
+.TH apt 1 "16 Mar 2012"
 
 .LP
 .SH "NAME"
@@ -39,11 +39,11 @@
 .LP
 .RS 3
 .TP 3
-sourcefiles
-Zero or more source files to be processed.
+sourcefiles 
+Zero or more source files to be processed. 
 .TP 3
-@files
-One or more files that list source files or other options
+@files 
+One or more files that list source files or other options 
 .RE
 
 .LP
@@ -56,80 +56,80 @@
 The tool \f2apt\fP, annotation processing tool, includes reflective APIs and supporting infrastructure to process program annotations. The \f2apt\fP reflective APIs provide a build\-time, source\-based, read\-only view of program structure. These reflective APIs are designed to cleanly model the Java(TM) programming language's type system after the addition of generics. First, \f2apt\fP runs annotation processors that can produce new source code and other files. Next, \f2apt\fP can cause compilation of both original and generated source files, easing development. The reflective APIs and other APIs used to interact with the tool are subpackages of \f2com.sun.mirror\fP.
 .LP
 .LP
-A fuller discussion of how the tool operates as well as instructions for developing with \f2apt\fP are in
+A fuller discussion of how the tool operates as well as instructions for developing with \f2apt\fP are in 
 .na
 \f4Getting Started with \fP\f4apt\fP. @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html
 .LP
 .SH "OPTIONS"
 .LP
-.SS
+.SS 
 apt specific options
 .LP
 .RS 3
 .TP 3
-\-s dir
-Specify the directory root under which processor\-generated source files will be placed; files are placed in subdirectories based on package namespace.
+\-s dir 
+Specify the directory root under which processor\-generated source files will be placed; files are placed in subdirectories based on package namespace. 
 .TP 3
-\-nocompile
-Do not compile source files to class files.
+\-nocompile 
+Do not compile source files to class files. 
 .TP 3
-\-print
-Print out textual representation of specified types; perform no annotation processing or compilation.
+\-print 
+Print out textual representation of specified types; perform no annotation processing or compilation. 
 .TP 3
-\-A[key[=val]]
-Options to pass to annotation processors \-\- these are not interpreted by \f2apt\fP directly, but are made available for use by individual processors
+\-A[key[=val]] 
+Options to pass to annotation processors \-\- these are not interpreted by \f2apt\fP directly, but are made available for use by individual processors 
 .TP 3
-\-factorypath path
-Specify where to find annotation processor factories; if this option is used, the classpath is \f2not\fP searched for factories.
+\-factorypath path 
+Specify where to find annotation processor factories; if this option is used, the classpath is \f2not\fP searched for factories. 
 .TP 3
-\-factory classname
-Name of annotation processor factory to use; bypasses default discovery process
+\-factory classname 
+Name of annotation processor factory to use; bypasses default discovery process 
 .TP 3
-\-version
-Print version information.
+\-version 
+Print version information. 
 .TP 3
-\-X
-Display information about non\-standard options.
+\-X 
+Display information about non\-standard options. 
 .RE
 
 .LP
-.SS
+.SS 
 Options shared with javac
 .LP
 .RS 3
 .TP 3
-\-d dir
-Specify where to place processor and javac generated class files
+\-d dir 
+Specify where to place processor and javac generated class files 
 .TP 3
-\-cp path or \-classpath path
-Specify where to find user class files and annotation processor factories. If \f2\-factorypath\fP is given, the classpath is not searched for factories.
+\-cp path or \-classpath path 
+Specify where to find user class files and annotation processor factories. If \f2\-factorypath\fP is given, the classpath is not searched for factories. 
 .RE
 
 .LP
 .LP
 Consult the javac(1) man page for information on \f2javac\fP options.
 .LP
-.SS
+.SS 
 Non\-Standard Options
 .LP
 .RS 3
 .TP 3
-\-XListAnnotationTypes
-List found annotation types.
+\-XListAnnotationTypes 
+List found annotation types. 
 .TP 3
-\-XListDeclarations
-List specified and included declarations.
+\-XListDeclarations 
+List specified and included declarations. 
 .TP 3
-\-XPrintAptRounds
-Print information about initial and recursive \f2apt\fP rounds.
+\-XPrintAptRounds 
+Print information about initial and recursive \f2apt\fP rounds. 
 .TP 3
-\-XPrintFactoryInfo
-Print information about which annotations a factory is asked to process.
+\-XPrintFactoryInfo 
+Print information about which annotations a factory is asked to process. 
 .TP 3
-\-XclassesAsDecls
-Treat both class and source files as declarations to process.
+\-XclassesAsDecls 
+Treat both class and source files as declarations to process. 
 .RE
 
 .LP
@@ -146,8 +146,8 @@
 .RS 3
 .TP 2
 o
-javac(1), java(1)
+javac(1), java(1) 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/extcheck.1	2012-08-10 10:22:48.000000000 -0700
+++ jdk/src/bsd/doc/man/extcheck.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH extcheck 1 "10 May 2011"
+.TH extcheck 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -57,11 +57,11 @@
 .LP
 .RS 3
 .TP 3
-\-verbose
-Lists Jar files in the extension directory as they are checked. Additionally, manifest attributes of the target jar file and any conflicting jar files are also reported.
+\-verbose 
+Lists Jar files in the extension directory as they are checked. Additionally, manifest attributes of the target jar file and any conflicting jar files are also reported. 
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. 
 .RE
 
 .LP
@@ -70,4 +70,4 @@
 .LP
 jar(1)
 .LP
-
+ 
--- jdk/src/bsd/doc/man/idlj.1	2012-08-10 10:22:48.000000000 -0700
+++ jdk/src/bsd/doc/man/idlj.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,13 +19,13 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH idlj 1 "10 May 2011"
+.TH idlj 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
 idlj \- The IDL\-to\-Java Compiler
 .LP
-\f3idlj\fP generates Java bindings from a given IDL file.
+\f3idlj\fP generates Java bindings from a given IDL file. 
 .SH "Synopsis"
 .LP
 .nf
@@ -43,13 +43,13 @@
 .SH "Description"
 .LP
 .LP
-The IDL\-to\-Java Compiler generates the Java bindings for a given IDL file.\  For binding details, see the
+The IDL\-to\-Java Compiler generates the Java bindings for a given IDL file.\  For binding details, see the 
 .na
 \f2OMG IDL to Java Language Language Mapping Specification\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/mapping/jidlMapping.html. Some previous releases of the IDL\-to\-Java compiler were named \f2idltojava\fP.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/mapping/jidlMapping.html. Some previous releases of the IDL\-to\-Java compiler were named \f2idltojava\fP.
 .LP
-.SS
+.SS 
 Emitting Client and Server Bindings
 .LP
 .LP
@@ -106,18 +106,18 @@
 The default server\-side model is the \f2Portable Servant Inheritance Model\fP. Given an interface \f2My\fP defined in \f2My.idl\fP, the file \f2MyPOA.java\fP is generated. You must provide the implementation for \f2My\fP and it must inherit from \f2MyPOA\fP.
 .LP
 .LP
-\f2MyPOA.java\fP is a stream\-based skeleton that extends
+\f2MyPOA.java\fP is a stream\-based skeleton that extends 
 .na
 \f2org.omg.PortableServer.Servant\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/org/omg/PortableServer/Servant.html and implements the \f2InvokeHandler\fP interface and the operations interface associated with the IDL interface the skeleton implements.
+http://docs.oracle.com/javase/7/docs/api/org/omg/PortableServer/Servant.html and implements the \f2InvokeHandler\fP interface and the operations interface associated with the IDL interface the skeleton implements.
 .LP
 .LP
-The \f2PortableServer\fP module for the
+The \f2PortableServer\fP module for the 
 .na
 \f2Portable Object Adapter (POA)\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/POA.html defines the native \f2Servant\fP type. In the Java programming language, the \f2Servant\fP type is mapped to the Java \f2org.omg.PortableServer.Servant\fP class. It serves as the base class for all POA servant implementations and provides a number of methods that may be invoked by the application programmer, as well as methods which are invoked by the POA itself and may be overridden by the user to control aspects of servant behavior.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/POA.html defines the native \f2Servant\fP type. In the Java programming language, the \f2Servant\fP type is mapped to the Java \f2org.omg.PortableServer.Servant\fP class. It serves as the base class for all POA servant implementations and provides a number of methods that may be invoked by the application programmer, as well as methods which are invoked by the POA itself and may be overridden by the user to control aspects of servant behavior.
 .LP
 .LP
 Another option for the Inheritance Model is to use the \f2\-oldImplBase\fP flag in order to generate server\-side bindings that are compatible with versions of the Java programming language prior to J2SE 1.4. Note that using the \f2\-oldImplBase\fP flag is non\-standard: these APIs are being deprecated. You would use this flag ONLY for compatibility with existing servers written in J2SE 1.3. In that case, you would need to modify an existing MAKEFILE to add the \f2\-oldImplBase\fP flag to the \f2idlj\fP compiler, otherwise POA\-based server\-side mappings will be generated. To generate server\-side bindings that are backwards compatible:
@@ -170,7 +170,7 @@
 .fl
     MyServant myDelegate = new MyServant();
 .fl
-    myDelegate.setORB(orb);
+    myDelegate.setORB(orb); 
 .fl
 
 .fl
@@ -218,7 +218,7 @@
 .fl
     MyServant myDelegate = new MyServant();
 .fl
-    myDelegate.setORB(orb);
+    myDelegate.setORB(orb); 
 .fl
 
 .fl
@@ -236,7 +236,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Specifying Alternate Locations for Emitted Files
 .LP
 .LP
@@ -253,7 +253,7 @@
 .LP
 For the interface \f2My\fP, the bindings will be emitted to \f2/altdir/My.java\fP, etc., instead of \f2./My.java\fP.
 .LP
-.SS
+.SS 
 Specifying Alternate Locations for Include Files
 .LP
 .LP
@@ -291,13 +291,13 @@
 
 .LP
 .LP
-The compiler will find this file and read in the includes list. Note that in this example the separator character between the two directories is a semicolon (;). This separator character is platform dependent. On the Windows platform, use a semicolon, on the Unix platform, use a colon, etc. For more information on \f2includes\fP, see the
+The compiler will find this file and read in the includes list. Note that in this example the separator character between the two directories is a semicolon (;). This separator character is platform dependent. On the Windows platform, use a semicolon, on the Unix platform, use a colon, etc. For more information on \f2includes\fP, see the 
 .na
 \f2Setting the Classpath\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#general.
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#general.
 .LP
-.SS
+.SS 
 Emitting Bindings for Include Files
 .LP
 .LP
@@ -469,7 +469,7 @@
 .LP
 If the \f2\-emitAll\fP flag had been used in the previous example, then all types in all included files would be emitted.
 .LP
-.SS
+.SS 
 Inserting Package Prefixes
 .LP
 .LP
@@ -525,7 +525,7 @@
 .fi
 
 .LP
-So the line for the above example would be:
+So the line for the above example would be: 
 .nf
 \f3
 .fl
@@ -538,7 +538,7 @@
 .LP
 The use of this option does not affect the Repository ID.
 .LP
-.SS
+.SS 
 Defining Symbols Before Compilation
 .LP
 .LP
@@ -555,7 +555,7 @@
 .LP
 is the equivalent of putting the line \f2#define MYDEF\fP inside \f2My.idl\fP.
 .LP
-.SS
+.SS 
 Preserving Pre\-Existing Bindings
 .LP
 .LP
@@ -572,7 +572,7 @@
 .LP
 emits all client\-side bindings that do not already exist.
 .LP
-.SS
+.SS 
 Viewing Progress of Compilation
 .LP
 .LP
@@ -589,7 +589,7 @@
 .LP
 By default the compiler does not operate in verbose mode.
 .LP
-.SS
+.SS 
 Displaying Version Information
 .LP
 .LP
@@ -611,8 +611,8 @@
 .LP
 .RS 3
 .TP 3
-\-d symbol
-This is equivalent to the following line in an IDL file:
+\-d symbol 
+This is equivalent to the following line in an IDL file: 
 .nf
 \f3
 .fl
@@ -621,32 +621,32 @@
 \fP
 .fi
 .TP 3
-\-emitAll
-Emit all types, including those found in \f2#include\fP files.
+\-emitAll 
+Emit all types, including those found in \f2#include\fP files. 
 .TP 3
-\-fside
-Defines what bindings to emit. \f2side\fP is one of \f2client\fP, \f2server\fP, \f2serverTIE\fP, \f2all\fP, or \f2allTIE\fP. The \f2\-fserverTIE\fP and \f2\-fallTIE\fP options cause delegate model skeletons to be emitted. Assumes \f2\-fclient\fP if the flag is not specified.
+\-fside 
+Defines what bindings to emit. \f2side\fP is one of \f2client\fP, \f2server\fP, \f2serverTIE\fP, \f2all\fP, or \f2allTIE\fP. The \f2\-fserverTIE\fP and \f2\-fallTIE\fP options cause delegate model skeletons to be emitted. Assumes \f2\-fclient\fP if the flag is not specified. 
 .TP 3
-\-i include\-path
-By default, the current directory is scanned for included files. This option adds another directory.
+\-i include\-path 
+By default, the current directory is scanned for included files. This option adds another directory. 
 .TP 3
-\-keep
-If a file to be generated already exists, do not overwrite it. By default it is overwritten.
+\-keep 
+If a file to be generated already exists, do not overwrite it. By default it is overwritten. 
 .TP 3
-\-noWarn
-Suppresses warning messages.
+\-noWarn 
+Suppresses warning messages. 
 .TP 3
-\-oldImplBase
-Generates skeletons compatible with pre\-1.4 JDK ORBs. By default, the POA Inheritance Model server\-side bindings are generated. This option provides backward\-compatibility with older versions of the Java programming language by generating server\-side bindings that are \f2ImplBase\fP Inheritance Model classes.
+\-oldImplBase 
+Generates skeletons compatible with pre\-1.4 JDK ORBs. By default, the POA Inheritance Model server\-side bindings are generated. This option provides backward\-compatibility with older versions of the Java programming language by generating server\-side bindings that are \f2ImplBase\fP Inheritance Model classes. 
 .TP 3
-\-pkgPrefix type prefix
-Wherever \f2type\fP is encountered at file scope, prefix the generated Java package name with \f2prefix\fP for all files generated for that type. The \f2type\fP is the simple name of either a top\-level module, or an IDL type defined outside of any module.
+\-pkgPrefix type prefix 
+Wherever \f2type\fP is encountered at file scope, prefix the generated Java package name with \f2prefix\fP for all files generated for that type. The \f2type\fP is the simple name of either a top\-level module, or an IDL type defined outside of any module. 
 .TP 3
-\-pkgTranslate type package
+\-pkgTranslate type package 
 Whenever the module name \f2type\fP is encountered in an identifier, replace it in the identifier with \f2package\fP for all files in the generated Java package. Note that \f2pkgPrefix\fP changes are made first. \f2type\fP is the simple name of either a top\-level module, or an IDL type defined outside of any module, and must match the full package name exactly.
 .br
 .br
-If more than one translation matches an identifier, the longest match is chosen. For example, if the arguments include:
+If more than one translation matches an identifier, the longest match is chosen. For example, if the arguments include: 
 .nf
 \f3
 .fl
@@ -654,7 +654,7 @@
 .fl
 \fP
 .fi
-The following translations would occur:
+The following translations would occur: 
 .nf
 \f3
 .fl
@@ -668,47 +668,47 @@
 .fl
 \fP
 .fi
-The following package names cannot be translated:
+The following package names cannot be translated: 
 .RS 3
 .TP 2
 o
-\f2org\fP
+\f2org\fP 
 .TP 2
 o
-\f2org.omg\fP or any subpackages of \f2org.omg\fP
+\f2org.omg\fP or any subpackages of \f2org.omg\fP 
 .RE
-Any attempt to translate these packages will result in uncompilable code, and the use of these packages as the first argument after \f2\-pkgTranslate\fP will be treated as an error.
+Any attempt to translate these packages will result in uncompilable code, and the use of these packages as the first argument after \f2\-pkgTranslate\fP will be treated as an error. 
 .TP 3
-\-skeletonName xxx%yyy
-Use \f2xxx%yyy\fP as the pattern for naming the skeleton. The defaults are:
+\-skeletonName xxx%yyy 
+Use \f2xxx%yyy\fP as the pattern for naming the skeleton. The defaults are: 
 .RS 3
 .TP 2
 o
-%POA for the \f2POA\fP base class (\f2\-fserver\fP or \f2\-fall\fP)
+%POA for the \f2POA\fP base class (\f2\-fserver\fP or \f2\-fall\fP) 
 .TP 2
 o
-_%ImplBase for the \f2oldImplBase\fP class (\f2\-oldImplBase\fP and (\f2\-fserver\fP or \f2\-fall\fP))
+_%ImplBase for the \f2oldImplBase\fP class (\f2\-oldImplBase\fP and (\f2\-fserver\fP or \f2\-fall\fP)) 
 .RE
 .TP 3
-\-td dir
-Use \f2dir\fP for the output directory instead of the current directory.
+\-td dir 
+Use \f2dir\fP for the output directory instead of the current directory. 
 .TP 3
-\-tieName xxx%yyy
-Name the tie according to the pattern. The defaults are:
+\-tieName xxx%yyy 
+Name the tie according to the pattern. The defaults are: 
 .RS 3
 .TP 2
 o
-%POATie for the \f2POA\fP tie base class (\f2\-fserverTie\fP or \f2\-fallTie\fP)
+%POATie for the \f2POA\fP tie base class (\f2\-fserverTie\fP or \f2\-fallTie\fP) 
 .TP 2
 o
-%_Tie for the \f2oldImplBase\fP tie class (\f2\-oldImplBase\fP and (\f2\-fserverTie\fP or \f2\-fallTie\fP))
+%_Tie for the \f2oldImplBase\fP tie class (\f2\-oldImplBase\fP and (\f2\-fserverTie\fP or \f2\-fallTie\fP)) 
 .RE
 .TP 3
-\-nowarn, \-verbose
-Verbose mode.
+\-nowarn, \-verbose 
+Verbose mode. 
 .TP 3
-\-version
-Display version information and terminate.
+\-version 
+Display version information and terminate. 
 .RE
 
 .LP
@@ -720,10 +720,10 @@
 .RS 3
 .TP 2
 o
-Escaped identifiers in the global scope may not have the same spelling as IDL primitive types, \f2Object\fP, or \f2ValueBase\fP. This is because the symbol table is pre\-loaded with these identifiers; allowing them to be redefined would overwrite their original definitions. (Possible permanent restriction).
+Escaped identifiers in the global scope may not have the same spelling as IDL primitive types, \f2Object\fP, or \f2ValueBase\fP. This is because the symbol table is pre\-loaded with these identifiers; allowing them to be redefined would overwrite their original definitions. (Possible permanent restriction). 
 .TP 2
 o
-The \f2fixed\fP IDL type is not supported.
+The \f2fixed\fP IDL type is not supported. 
 .RE
 
 .LP
@@ -732,8 +732,8 @@
 .RS 3
 .TP 2
 o
-No import generated for global identifiers. If you invoke on an unexported local impl, you do get an exception, but it seems to be due to a \f2NullPointerException\fP in the \f2ServerDelegate\fP DSI code.
+No import generated for global identifiers. If you invoke on an unexported local impl, you do get an exception, but it seems to be due to a \f2NullPointerException\fP in the \f2ServerDelegate\fP DSI code. 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jar.1	2012-08-10 10:22:50.000000000 -0700
+++ jdk/src/bsd/doc/man/jar.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,31 +19,31 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jar 1 "10 May 2011"
+.TH jar 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
 jar\-The Java Archive Tool
 .LP
-\f3jar\fP combines multiple files into a single JAR archive file.
+\f3jar\fP combines multiple files into a single JAR archive file.  
 .SH "SYNOPSIS"
 .LP
 .RS 3
 .TP 3
-Create jar file
-\f4jar c\fP\f2[v0Mmfe] [\fP\f2manifest\fP\f2] [\fP\f2jarfile\fP\f2] [\fP\f2entrypoint\fP\f2] [\-C\fP \f2dir\fP\f2]\fP \f2inputfiles\fP \f2[\-J\fP\f2option\fP\f2]\fP
+Create jar file 
+\f4jar c\fP\f2[v0Mmfe] [\fP\f2manifest\fP\f2] [\fP\f2jarfile\fP\f2] [\fP\f2entrypoint\fP\f2] [\-C\fP \f2dir\fP\f2]\fP \f2inputfiles\fP \f2[\-J\fP\f2option\fP\f2]\fP 
 .TP 3
-Update jar file
-\f4jar u\fP\f2[v0Mmfe] [\fP\f2manifest\fP\f2] [\fP\f2jarfile\fP\f2] [\fP\f2entrypoint\fP\f2] [\-C\fP \f2dir\fP\f2]\fP \f2inputfiles\fP \f2[\-J\fP\f2option\fP\f2]\fP
+Update jar file 
+\f4jar u\fP\f2[v0Mmfe] [\fP\f2manifest\fP\f2] [\fP\f2jarfile\fP\f2] [\fP\f2entrypoint\fP\f2] [\-C\fP \f2dir\fP\f2]\fP \f2inputfiles\fP \f2[\-J\fP\f2option\fP\f2]\fP 
 .TP 3
-Extract jar file
-\f4jar x\fP\f2[vf] [\fP\f2jarfile\fP\f2] [\fP\f2inputfiles\fP\f2] [\-J\fP\f2option\fP\f2]\fP
+Extract jar file 
+\f4jar x\fP\f2[vf] [\fP\f2jarfile\fP\f2] [\fP\f2inputfiles\fP\f2] [\-J\fP\f2option\fP\f2]\fP 
 .TP 3
-List table of contents of jar file
-\f4jar t\fP\f2[vf] [\fP\f2jarfile\fP\f2] [\fP\f2inputfiles\fP\f2] [\-J\fP\f2option\fP\f2]\fP
+List table of contents of jar file 
+\f4jar t\fP\f2[vf] [\fP\f2jarfile\fP\f2] [\fP\f2inputfiles\fP\f2] [\-J\fP\f2option\fP\f2]\fP 
 .TP 3
-Add index to jar file
-\f4jar i\fP \f2jarfile\fP \f2[\-J\fP\f2option\fP\f2]\fP
+Add index to jar file 
+\f4jar i\fP \f2jarfile\fP \f2[\-J\fP\f2option\fP\f2]\fP 
 .RE
 
 .LP
@@ -52,36 +52,36 @@
 .LP
 .RS 3
 .TP 3
-cuxtiv0Mmfe
-Options that control the \f2jar\fP command.
+cuxtiv0Mmfe 
+Options that control the \f2jar\fP command. 
 .TP 3
-jarfile
-Jar file to be created (\f2c\fP), updated (\f2u\fP), extracted (\f2x\fP), or have its table of contents viewed (\f2t\fP). The \f2\-f\fP option and filename \f2jarfile\fP are a pair \-\- if either is present, they must both appear. Note that omitting \f2f\fP and \f2jarfile\fP accepts a "jar file" from standard input (for x and t) or sends the "jar file" to standard output (for c and u).
+jarfile 
+Jar file to be created (\f2c\fP), updated (\f2u\fP), extracted (\f2x\fP), or have its table of contents viewed (\f2t\fP). The \f2\-f\fP option and filename \f2jarfile\fP are a pair \-\- if either is present, they must both appear. Note that omitting \f2f\fP and \f2jarfile\fP accepts a "jar file" from standard input (for x and t) or sends the "jar file" to standard output (for c and u). 
 .TP 3
-inputfiles
-Files or directories, separated by spaces, to be combined into \f2jarfile\fP (for c and u), or to be extracted (for x) or listed (for t) from \f2jarfile\fP. All directories are processed recursively. The files are compressed unless option \f20\fP (zero) is used.
+inputfiles 
+Files or directories, separated by spaces, to be combined into \f2jarfile\fP (for c and u), or to be extracted (for x) or listed (for t) from \f2jarfile\fP. All directories are processed recursively. The files are compressed unless option \f20\fP (zero) is used. 
 .TP 3
-manifest
-Pre\-existing manifest file whose \f2name\fP\f2:\fP \f2value\fP pairs are to be included in MANIFEST.MF in the jar file. The \f2\-m\fP option and filename \f2manifest\fP are a pair \-\- if either is present, they must both appear. The letters \f3m\fP, \f3f\fP and \f3e\fP must appear in the same order that \f2manifest\fP, \f2jarfile\fP, \f2entrypoint\fP appear.
+manifest 
+Pre\-existing manifest file whose \f2name\fP\f2:\fP \f2value\fP pairs are to be included in MANIFEST.MF in the jar file. The \f2\-m\fP option and filename \f2manifest\fP are a pair \-\- if either is present, they must both appear. The letters \f3m\fP, \f3f\fP and \f3e\fP must appear in the same order that \f2manifest\fP, \f2jarfile\fP, \f2entrypoint\fP appear. 
 .TP 3
-entrypoint
-The name of the class that set as the application entry point for stand\-alone applications bundled into executable jar file. The \f2\-e\fP option and entrypoint are a pair \-\- if either is present, they must both appear. The letters \f3m\fP, \f3f\fP and \f3e\fP must appear in the same order that \f2manifest\fP, \f2jarfile\fP, \f2entrypoint\fP appear.
+entrypoint 
+The name of the class that set as the application entry point for stand\-alone applications bundled into executable jar file. The \f2\-e\fP option and entrypoint are a pair \-\- if either is present, they must both appear. The letters \f3m\fP, \f3f\fP and \f3e\fP must appear in the same order that \f2manifest\fP, \f2jarfile\fP, \f2entrypoint\fP appear. 
 .TP 3
-\-C\ dir
-Temporarily changes directories to \f2dir\fP while processing the following \f2inputfiles\fP argument. Multiple \f2\-C\ \fP\f2dir\fP \f2inputfiles\fP sets are allowed.
+\-C\ dir 
+Temporarily changes directories to \f2dir\fP while processing the following \f2inputfiles\fP argument. Multiple \f2\-C\ \fP\f2dir\fP \f2inputfiles\fP sets are allowed. 
 .TP 3
-\-Joption
-Option to be passed into the Java runtime environment. (There must be no space between \f2\-J\fP and \f2option\fP).
+\-Joption 
+Option to be passed into the Java runtime environment. (There must be no space between \f2\-J\fP and \f2option\fP). 
 .RE
 
 .LP
 .SH "DESCRIPTION"
 .LP
-The \f3jar\fP tool combines multiple files into a single JAR archive file. \f3jar\fP is a general\-purpose archiving and compression tool, based on ZIP and the
+The \f3jar\fP tool combines multiple files into a single JAR archive file. \f3jar\fP is a general\-purpose archiving and compression tool, based on ZIP and the 
 .na
 \f2ZLIB\fP @
 .fi
-http://www.gzip.org/zlib/ compression format. However, \f3jar\fP was designed mainly package java applets or applications into a single archive. When the components of an applet or application (files, images and sounds) are combined into a single archive, they can be downloaded by a java agent (like a browser) in a single HTTP transaction, rather than requiring a new connection for each piece. This dramatically improves download times. \f3jar\fP also compresses files and so further improves download time. In addition, it allows individual entries in a file to be signed by the applet author so that their origin can be authenticated. The syntax for the jar tool is almost identical to the syntax for the \f2tar\fP command. A \f3jar\fP archive can be used as a class path entry, whether or not it is compressed.
+http://www.gzip.org/zlib/ compression format. However, \f3jar\fP was designed mainly package java applets or applications into a single archive. When the components of an applet or application (files, images and sounds) are combined into a single archive, they can be downloaded by a java agent (like a browser) in a single HTTP transaction, rather than requiring a new connection for each piece. This dramatically improves download times. \f3jar\fP also compresses files and so further improves download time. In addition, it allows individual entries in a file to be signed by the applet author so that their origin can be authenticated. The syntax for the jar tool is almost identical to the syntax for the \f2tar\fP command. A \f3jar\fP archive can be used as a class path entry, whether or not it is compressed. 
 .LP
 Typical usage to combine files into a jar file is:
 .LP
@@ -94,11 +94,11 @@
 .fi
 
 .LP
-In this example, all the class files in the current directory are placed into the file named \f2myFile.jar\fP. The jar tool automatically generates a manifest file entry named \f2META\-INF/MANIFEST.MF\fP. It is always the first entry in the jar file. The manifest file declares meta\-information about the archive, and stores that data as \f2name\ :\ value\fP pairs. Refer to the
+In this example, all the class files in the current directory are placed into the file named \f2myFile.jar\fP. The jar tool automatically generates a manifest file entry named \f2META\-INF/MANIFEST.MF\fP. It is always the first entry in the jar file. The manifest file declares meta\-information about the archive, and stores that data as \f2name\ :\ value\fP pairs. Refer to the 
 .na
 \f2JAR file specification\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR%20Manifest for details explaining how the jar tool stores meta\-information in the manifest file.
+http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR%20Manifest for details explaining how the jar tool stores meta\-information in the manifest file. 
 .LP
 If a jar file should include \f2name\ :\ value\fP pairs contained in an existing manifest file, specify that file using the \f2\-m\fP option:
 .LP
@@ -118,7 +118,7 @@
 .br
 
 .LP
-\f3Note:\ \fP A jar command that specifies \f2cfm\fP on the command line instead of \f2cmf\fP (the order of the m and \-f options are reversed), the \f3jar\fP command line must specify the name of the jar archive first, followed by the name of the manifest file:
+\f3Note:\ \fP A jar command that specifies \f2cfm\fP on the command line instead of \f2cmf\fP (the order of the m and \-f options are reversed), the \f3jar\fP command line must specify the name of the jar archive first, followed by the name of the manifest file: 
 .nf
 \f3
 .fl
@@ -128,7 +128,7 @@
 .fi
 
 .LP
-The manifest is in a text format inspired by RFC822 ASCII format, so it is easy to view and process manifest\-file contents.
+The manifest is in a text format inspired by RFC822 ASCII format, so it is easy to view and process manifest\-file contents. 
 .LP
 To extract the files from a jar file, use \f2x\fP:
 .LP
@@ -154,11 +154,11 @@
 
 .LP
 .LP
-Beginning with version 1.3 of the JDK, the \f2jar\fP utility supports
+Beginning with version 1.3 of the JDK, the \f2jar\fP utility supports 
 .na
 \f2JarIndex\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Index, which allows application class loaders to load classes more efficiently from jar files. If an application or applet is bundled into multiple jar files,\  only the necessary jar files will be downloaded and opened to load classes. This performance optimization is enabled by running \f2jar\fP with the \f2\-i\fPoption. It will generate package location information for the specified main jar file and all the jar files it depends on, which need to be specified in the \f2Class\-Path\fP attribute of the main jar file's manifest.
+http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Index, which allows application class loaders to load classes more efficiently from jar files. If an application or applet is bundled into multiple jar files,\  only the necessary jar files will be downloaded and opened to load classes. This performance optimization is enabled by running \f2jar\fP with the \f2\-i\fPoption. It will generate package location information for the specified main jar file and all the jar files it depends on, which need to be specified in the \f2Class\-Path\fP attribute of the main jar file's manifest.
 .LP
 .nf
 \f3
@@ -188,21 +188,21 @@
 
 .LP
 .LP
-To review command samples which use \f2jar\fP to opeate on jar files and jar file manifests, see Examples, below. Also refer to the jar trail of the
+To review command samples which use \f2jar\fP to opeate on jar files and jar file manifests, see Examples, below. Also refer to the jar trail of the 
 .na
 \f2Java Tutorial\fP @
 .fi
-http://download.oracle.com/javase/tutorial/deployment/jar.
+http://docs.oracle.com/javase/tutorial/deployment/jar.
 .LP
 .SH "OPTIONS"
 .LP
 .RS 3
 .TP 3
-c
-Creates a new archive file named \f2jarfile\fP (if \f2f\fP is specified) or to standard output (if \f2f\fP and \f2jarfile\fP are omitted). Add to it the files and directories specified by \f2inputfiles\fP.
+c 
+Creates a new archive file named \f2jarfile\fP (if \f2f\fP is specified) or to standard output (if \f2f\fP and \f2jarfile\fP are omitted). Add to it the files and directories specified by \f2inputfiles\fP. 
 .TP 3
-u
-Updates an existing file \f2jarfile\fP (when \f2f\fP is specified) by adding to it files and directories specified by \f2inputfiles\fP. For example:
+u 
+Updates an existing file \f2jarfile\fP (when \f2f\fP is specified) by adding to it files and directories specified by \f2inputfiles\fP. For example: 
 .nf
 \f3
 .fl
@@ -210,7 +210,7 @@
 .fl
 \fP
 .fi
-would add the file \f2foo.class\fP to the existing jar file \f2foo.jar\fP. The \f2\-u\fP option can also update the manifest entry, as given by this example:
+would add the file \f2foo.class\fP to the existing jar file \f2foo.jar\fP. The \f2\-u\fP option can also update the manifest entry, as given by this example: 
 .nf
 \f3
 .fl
@@ -218,16 +218,16 @@
 .fl
 \fP
 .fi
-updates the \f2foo.jar\fP manifest with the \f2name : value\fP pairs in \f2manifest\fP.
+updates the \f2foo.jar\fP manifest with the \f2name : value\fP pairs in \f2manifest\fP. 
 .TP 3
-x
-Extracts files and directories from \f2jarfile\fP (if \f2f\fP is specified) or standard input (if \f2f\fP and \f2jarfile\fP are omitted). If \f2inputfiles\fP is specified, only those specified files and directories are extracted. Otherwise, all files and directories are extracted. The time and date of the extracted files are those given in the archive.
+x 
+Extracts files and directories from \f2jarfile\fP (if \f2f\fP is specified) or standard input (if \f2f\fP and \f2jarfile\fP are omitted). If \f2inputfiles\fP is specified, only those specified files and directories are extracted. Otherwise, all files and directories are extracted. The time and date of the extracted files are those given in the archive. 
 .TP 3
-t
-Lists the table of contents from \f2jarfile\fP (if \f2f\fP is specified) or standard input (if \f2f\fP and \f2jarfile\fP are omitted). If \f2inputfiles\fP is specified, only those specified files and directories are listed. Otherwise, all files and directories are listed.
+t 
+Lists the table of contents from \f2jarfile\fP (if \f2f\fP is specified) or standard input (if \f2f\fP and \f2jarfile\fP are omitted). If \f2inputfiles\fP is specified, only those specified files and directories are listed. Otherwise, all files and directories are listed. 
 .TP 3
-i
-Generate index information for the specified \f2jarfile\fP and its dependent jar files. For example:
+i 
+Generate index information for the specified \f2jarfile\fP and its dependent jar files. For example: 
 .nf
 \f3
 .fl
@@ -236,25 +236,25 @@
 \fP
 .fi
 .LP
-would generate an \f2INDEX.LIST\fP file in \f2foo.jar\fP which contains location information for each package in \f2foo.jar\fP and all the jar files specified in the \f2Class\-Path\fP attribute of \f2foo.jar\fP. See the index example.
+would generate an \f2INDEX.LIST\fP file in \f2foo.jar\fP which contains location information for each package in \f2foo.jar\fP and all the jar files specified in the \f2Class\-Path\fP attribute of \f2foo.jar\fP. See the index example.  
 .TP 3
-f
-Specifies the file \f2jarfile\fP to be created (\f2c\fP), updated (\f2u\fP), extracted (\f2x\fP), indexed (\f2i\fP), or viewed (\f2t\fP). The \f2\-f\fP option and filename \f2jarfile\fP are a pair \-\- if present, they must both appear. Omitting \f2f\fP and \f2jarfile\fP accepts a jar file name from \f2stdin\fP(for x and t) or sends jar file to \f2stdout\fP (for c and u).
+f 
+Specifies the file \f2jarfile\fP to be created (\f2c\fP), updated (\f2u\fP), extracted (\f2x\fP), indexed (\f2i\fP), or viewed (\f2t\fP). The \f2\-f\fP option and filename \f2jarfile\fP are a pair \-\- if present, they must both appear. Omitting \f2f\fP and \f2jarfile\fP accepts a jar file name from \f2stdin\fP(for x and t) or sends jar file to \f2stdout\fP (for c and u). 
 .TP 3
-v
-Generates verbose output to standard output. Examples shown below.
+v 
+Generates verbose output to standard output. Examples shown below. 
 .TP 3
-0
-(zero) Store without using ZIP compression.
+0 
+(zero) Store without using ZIP compression. 
 .TP 3
-M
-Do not create a manifest file entry (for c and u), or delete a manifest file entry if one exists (for u).
+M 
+Do not create a manifest file entry (for c and u), or delete a manifest file entry if one exists (for u). 
 .TP 3
-m
+m 
 Includes \f2name : value\fP attribute pairs from the specified manifest file \f2manifest\fP in the file at \f2META\-INF/MANIFEST.MF\fP. \f2jar\fP adds a \f2name\ :\ value\fP pair unless an entry already exists with the same name, in which case \f2jar\fP updates its value.
 .br
 .br
-On the command line, the letters \f3m\fP and \f3f\fP must appear in the same order that \f2manifest\fP and \f2jarfile\fP appear. Example use:
+On the command line, the letters \f3m\fP and \f3f\fP must appear in the same order that \f2manifest\fP and \f2jarfile\fP appear. Example use: 
 .nf
 \f3
 .fl
@@ -262,18 +262,18 @@
 .fl
 \fP
 .fi
-You can add special\-purpose \f2name\ :\ value\fP attribute pairs to the manifest that aren't contained in the default manifest. For example, you can add attributes specifying vendor information, version information, package sealing, or to make JAR\-bundled applications executable. See the
+You can add special\-purpose \f2name\ :\ value\fP attribute pairs to the manifest that aren't contained in the default manifest. For example, you can add attributes specifying vendor information, version information, package sealing, or to make JAR\-bundled applications executable. See the 
 .na
 \f2JAR Files\fP @
 .fi
-http://download.oracle.com/javase/tutorial/deployment/jar/ trail in the Java Tutorial  for examples of using the \f4\-m\fP option.
+http://docs.oracle.com/javase/tutorial/deployment/jar/ trail in the Java Tutorial  for examples of using the \f4\-m\fP option. 
 .TP 3
-e
+e 
 Sets \f2entrypoint\fP as the application entry point for stand\-alone applications bundled into executable jar file. The use of this option creates or overrides the \f2Main\-Class\fP attribute value in the manifest file. This option can be used during creation of jar file or while updating the jar file. This option specifies the application entry point without editing or creating the manifest file.
 .br
 .br
 .br
-For example, this command creates \f2Main.jar\fP where the \f2Main\-Class\fP attribute value in the manifest is set to \f2Main\fP:
+For example, this command creates \f2Main.jar\fP where the \f2Main\-Class\fP attribute value in the manifest is set to \f2Main\fP: 
 .nf
 \f3
 .fl
@@ -281,7 +281,7 @@
 .fl
 \fP
 .fi
-The java runtime can directly invoke this application by running the following command:
+The java runtime can directly invoke this application by running the following command: 
 .nf
 \f3
 .fl
@@ -289,7 +289,7 @@
 .fl
 \fP
 .fi
-If the entrypoint class name is in a package it may use either a dot (".") or slash ("/") character as the delimiter. For example, if \f2Main.class\fP is in a package called \f2foo\fP the entry point can be specified in the following ways:
+If the entrypoint class name is in a package it may use either a dot (".") or slash ("/") character as the delimiter. For example, if \f2Main.class\fP is in a package called \f2foo\fP the entry point can be specified in the following ways: 
 .nf
 \f3
 .fl
@@ -297,7 +297,7 @@
 .fl
 \fP
 .fi
-or
+or 
 .nf
 \f3
 .fl
@@ -305,13 +305,13 @@
 .fl
 \fP
 .fi
-\f3Note:\ \fP specifying both \f2\-m\fP and \f2\-e\fP options together when the given manifest also contains the \f2Main\-Class\fP attribute results in an ambigous \f2Main.class\fP specification, leading to an error and the jar creation or update operation is aborted.
+\f3Note:\ \fP specifying both \f2\-m\fP and \f2\-e\fP options together when the given manifest also contains the \f2Main\-Class\fP attribute results in an ambigous \f2Main.class\fP specification, leading to an error and the jar creation or update operation is aborted.  
 .TP 3
-\-C\ dir
+\-C\ dir 
 Temporarily changes directories (\f2cd\fP\ \f2dir\fP) during execution of the \f2jar\fP command while processing the following \f2inputfiles\fP argument. Its operation is intended to be similar to the \f2\-C\fP option of the UNIX \f2tar\fP utility.
 .br
 .br
-For example, this command changes to the \f2classes\fP directory and adds the \f2bar.class\fP from that directory to \f2foo.jar\fP:
+For example, this command changes to the \f2classes\fP directory and adds the \f2bar.class\fP from that directory to \f2foo.jar\fP: 
 .nf
 \f3
 .fl
@@ -319,7 +319,7 @@
 .fl
 \fP
 .fi
-This command changes to the \f2classes\fP directory and adds to \f2foo.jar\fP all files within the \f2classes\fP directory (without creating a classes directory in the jar file), then changes back to the original directory before changing to the \f2bin\fP directory to add \f2xyz.class\fP to \f2foo.jar\fP.
+This command changes to the \f2classes\fP directory and adds to \f2foo.jar\fP all files within the \f2classes\fP directory (without creating a classes directory in the jar file), then changes back to the original directory before changing to the \f2bin\fP directory to add \f2xyz.class\fP to \f2foo.jar\fP. 
 .nf
 \f3
 .fl
@@ -327,7 +327,7 @@
 .fl
 \fP
 .fi
-If \f2classes\fP holds files \f2bar1\fP and \f2bar2\fP, then here's what the jar file will contain using \f2jar tf foo.jar\fP:
+If \f2classes\fP holds files \f2bar1\fP and \f2bar2\fP, then here's what the jar file will contain using \f2jar tf foo.jar\fP: 
 .nf
 \f3
 .fl
@@ -345,14 +345,14 @@
 .fi
 .LP
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java runtime environment, where \f2option\fP is one of the options described on the reference page for the java application launcher. For example, \f4\-J\-Xmx48M\fP sets the maximum memory to 48 megabytes. It is a common convention for \f2\-J\fP to pass options to the underlying runtime environment.
+\-Joption 
+Pass \f2option\fP to the Java runtime environment, where \f2option\fP is one of the options described on the reference page for the java application launcher. For example, \f4\-J\-Xmx48M\fP sets the maximum memory to 48 megabytes. It is a common convention for \f2\-J\fP to pass options to the underlying runtime environment. 
 .RE
 
 .LP
 .SH "COMMAND LINE ARGUMENT FILES"
 .LP
-To shorten or simplify the jar command line, you can specify one or more files that themselves contain arguments to the \f2jar\fP command (except \f2\-J\fP options). This enables you to create jar commands of any length, overcoming command line limits imposed by the operating system.
+To shorten or simplify the jar command line, you can specify one or more files that themselves contain arguments to the \f2jar\fP command (except \f2\-J\fP options). This enables you to create jar commands of any length, overcoming command line limits imposed by the operating system. 
 .LP
 An argument file can include options and filenames. The arguments within a file can be space\-separated or newline\-separated. Filenames within an argument file are relative to the current directory, not relative to the location of the argument file. Wildcards (*) that might otherwise be expanded by the operating system shell are not expanded. Use of the \f2@\fP character to recursively interpret files is not supported. The \f2\-J\fP options are not supported because they are passed to the launcher, which does not support argument files.
 .LP
@@ -360,7 +360,7 @@
 When executing \f2jar\fP, pass in the path and name of each argument file with the \f2@\fP leading character. When \f2jar\fP encounters an argument beginning with the character \f2@\fP, it expands the contents of that file into the argument list.
 .br
 .br
-The example below, \f2classes.list\fP holds the names of files output by a \f2find\fP command:
+The example below, \f2classes.list\fP holds the names of files output by a \f2find\fP command: 
 .LP
 .nf
 \f3
@@ -382,7 +382,7 @@
 .fi
 
 .LP
-An argument file can specify a path, but any filenames inside the argument file that have relative paths are relative to the current working directory, not to the path passed in. Here is an example:
+An argument file can specify a path, but any filenames inside the argument file that have relative paths are relative to the current working directory, not to the path passed in. Here is an example: 
 .nf
 \f3
 .fl
@@ -397,7 +397,7 @@
 .LP
 .SH "EXAMPLES"
 .LP
-To add all the files in a particular directory to an archive (overwriting contents if the archive already exists). Enumerating verbosely (with the \f2\-v\fP option) will tell you more information about the files in the archive, such as their size and last modified date.
+To add all the files in a particular directory to an archive (overwriting contents if the archive already exists). Enumerating verbosely (with the \f2\-v\fP option) will tell you more information about the files in the archive, such as their size and last modified date. 
 .nf
 \f3
 .fl
@@ -435,7 +435,7 @@
 .fi
 
 .LP
-If you already have separate subdirectories for images, audio files and classes, you can combine them into a single jar file:
+If you already have separate subdirectories for images, audio files and classes, you can combine them into a single jar file: 
 .nf
 \f3
 .fl
@@ -481,7 +481,7 @@
 .fi
 
 .LP
-To see the entry names in the jarfile, use the \f2t\fP option:
+To see the entry names in the jarfile, use the \f2t\fP option: 
 .nf
 \f3
 .fl
@@ -526,7 +526,7 @@
 .br
 
 .LP
-If you specify the \f2Class\-path\fP attribute in the \f2main.jar\fP manifest as:
+If you specify the \f2Class\-path\fP attribute in the \f2main.jar\fP manifest as: 
 .nf
 \f3
 .fl
@@ -536,7 +536,7 @@
 .fi
 
 .LP
-then you can use the \f2\-i\fP option to speed up the class loading time for your application:
+then you can use the \f2\-i\fP option to speed up the class loading time for your application: 
 .nf
 \f3
 .fl
@@ -546,34 +546,34 @@
 .fi
 
 .LP
-An \f2INDEX.LIST\fP file is inserted to the \f2META\-INF\fP directory. This enables the application class loader to download the specified jar files when it is searching for classes or resources.
+An \f2INDEX.LIST\fP file is inserted to the \f2META\-INF\fP directory. This enables the application class loader to download the specified jar files when it is searching for classes or resources.  
 .SH "SEE ALSO"
 .LP
 .LP
 .na
 \f2The Jar Overview\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jar/jarGuide.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jarGuide.html
 .LP
 .LP
 .na
 \f2The Jar File Specification\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jar/jar.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html
 .LP
 .LP
 .na
 \f2The JarIndex Spec\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Index
+http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Index
 .LP
 .LP
 .na
 \f2Jar Tutorial\fP @
 .fi
-http://download.oracle.com/javase/tutorial/deployment/jar/index.html
+http://docs.oracle.com/javase/tutorial/deployment/jar/index.html
 .LP
 .LP
 pack200(1)
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jarsigner.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jarsigner.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jarsigner 1 "10 May 2011"
+.TH jarsigner 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -51,10 +51,10 @@
 .RS 3
 .TP 3
 1.
-to sign Java ARchive (JAR) files, and
+to sign Java ARchive (JAR) files, and 
 .TP 3
 2.
-to verify the signatures and integrity of signed JAR files.
+to verify the signatures and integrity of signed JAR files. 
 .RE
 
 .LP
@@ -67,16 +67,16 @@
 .RS 3
 .TP 2
 o
-Its authenticity can be verified, via a computation that uses the public key corresponding to the private key used to generate the signature.
+Its authenticity can be verified, via a computation that uses the public key corresponding to the private key used to generate the signature. 
 .TP 2
 o
-It cannot be forged, assuming the private key is kept secret.
+It cannot be forged, assuming the private key is kept secret. 
 .TP 2
 o
-It is a function of the data signed and thus can't be claimed to be the signature for other data as well.
+It is a function of the data signed and thus can't be claimed to be the signature for other data as well. 
 .TP 2
 o
-The signed data cannot be changed; if it is, the signature will no longer verify as being authentic.
+The signed data cannot be changed; if it is, the signature will no longer verify as being authentic. 
 .RE
 
 .LP
@@ -98,7 +98,7 @@
 .LP
 The default \f3jarsigner\fP behavior is to \f2sign\fP a JAR (or zip) file. Use the \f2\-verify\fP option to instead have it \f2verify\fP a signed JAR file.
 .LP
-.SS
+.SS 
 Keystore Aliases
 .LP
 .LP
@@ -121,7 +121,7 @@
 .LP
 Keystores are protected with a password, so the store password must be specified. You will be prompted for it if you don't specify it on the command line. Similarly, private keys are protected in a keystore with a password, so the private key's password must be specified, and you will be prompted for it if you don't specify it on the command line and it isn't the same as the store password.
 .LP
-.SS
+.SS 
 Keystore Location
 .LP
 .LP
@@ -130,7 +130,7 @@
 .LP
 Note that the input stream from the \f2\-keystore\fP option is passed to the \f2KeyStore.load\fP method. If \f2NONE\fP is specified as the URL, then a null stream is passed to the \f2KeyStore.load\fP method. \f2NONE\fP should be specified if the \f2KeyStore\fP is not file\-based, for example, if it resides on a hardware token device.
 .LP
-.SS
+.SS 
 Keystore Implementation
 .LP
 .LP
@@ -143,11 +143,11 @@
 There is a built\-in default implementation, provided by Sun Microsystems. It implements the keystore as a file, utilizing a proprietary keystore type (format) named "JKS". It protects each private key with its individual password, and also protects the integrity of the entire keystore with a (possibly different) password.
 .LP
 .LP
-Keystore implementations are provider\-based. More specifically, the application interfaces supplied by \f2KeyStore\fP are implemented in terms of a "Service Provider Interface" (SPI). That is, there is a corresponding abstract \f2KeystoreSpi\fP class, also in the \f2java.security\fP package, which defines the Service Provider Interface methods that "providers" must implement. (The term "provider" refers to a package or a set of packages that supply a concrete implementation of a subset of services that can be accessed by the Java Security API.) Thus, to provide a keystore implementation, clients must implement a provider and supply a KeystoreSpi subclass implementation, as described in
+Keystore implementations are provider\-based. More specifically, the application interfaces supplied by \f2KeyStore\fP are implemented in terms of a "Service Provider Interface" (SPI). That is, there is a corresponding abstract \f2KeystoreSpi\fP class, also in the \f2java.security\fP package, which defines the Service Provider Interface methods that "providers" must implement. (The term "provider" refers to a package or a set of packages that supply a concrete implementation of a subset of services that can be accessed by the Java Security API.) Thus, to provide a keystore implementation, clients must implement a provider and supply a KeystoreSpi subclass implementation, as described in 
 .na
 \f2How to Implement a Provider for the Java Cryptography Architecture\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html.
 .LP
 .LP
 Applications can choose different \f2types\fP of keystore implementations from different providers, using the "getInstance" factory method supplied in the \f2KeyStore\fP class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible.
@@ -204,13 +204,13 @@
 
 .LP
 .LP
-Note that if you us the PKCS#11 provider package, you should refer to the
+Note that if you us the PKCS#11 provider package, you should refer to the 
 .na
 \f2KeyTool and JarSigner\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html#KeyToolJarSigner section of the Java PKCS#11 Reference Guide for details.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html#KeyToolJarSigner section of the Java PKCS#11 Reference Guide for details.
 .LP
-.SS
+.SS 
 Supported Algorithms
 .LP
 .LP
@@ -219,13 +219,13 @@
 .RS 3
 .TP 2
 o
-DSA (Digital Signature Algorithm) with the SHA1 digest algorithm
+DSA (Digital Signature Algorithm) with the SHA1 digest algorithm 
 .TP 2
 o
-RSA algorithm with the SHA256 digest algorithm.
+RSA algorithm with the SHA256 digest algorithm. 
 .TP 2
 o
-EC (Elliptic Curve) cryptography algorithm with the SHA256 with ECDSA (Elliptic Curve Digital Signature Algorithm).
+EC (Elliptic Curve) cryptography algorithm with the SHA256 with ECDSA (Elliptic Curve Digital Signature Algorithm). 
 .RE
 
 .LP
@@ -235,7 +235,7 @@
 .LP
 These default signature algorithms can be overridden using the \f2\-sigalg\fP option.
 .LP
-.SS
+.SS 
 The Signed JAR File
 .LP
 .LP
@@ -244,10 +244,10 @@
 .RS 3
 .TP 2
 o
-a signature file, with a .SF extension, and
+a signature file, with a .SF extension, and 
 .TP 2
 o
-a signature block file, with a .DSA, .RSA, or .EC extension.
+a signature block file, with a .DSA, .RSA, or .EC extension. 
 .RE
 
 .LP
@@ -277,13 +277,13 @@
 .RS 3
 .TP 2
 o
-the file name,
+the file name, 
 .TP 2
 o
-the name of the digest algorithm used (SHA), and
+the name of the digest algorithm used (SHA), and 
 .TP 2
 o
-a SHA digest value.
+a SHA digest value. 
 .RE
 
 .LP
@@ -295,8 +295,8 @@
 .LP
 \f3The Signature Block File\fP
 .LP
-The .SF file is signed and the signature is placed in the signature block file. This file also contains, encoded inside it, the certificate or certificate chain from the keystore which authenticates the public key corresponding to the private key used for signing. The file has the extension .DSA, .RSA, or .EC depending on the digest algorithm used.
-.SS
+The .SF file is signed and the signature is placed in the signature block file. This file also contains, encoded inside it, the certificate or certificate chain from the keystore which authenticates the public key corresponding to the private key used for signing. The file has the extension .DSA, .RSA, or .EC depending on the digest algorithm used. 
+.SS 
 Signature Timestamp
 .LP
 .LP
@@ -305,23 +305,23 @@
 .RS 3
 .TP 2
 o
-\f2\-tsa url\fP
+\f2\-tsa url\fP 
 .TP 2
 o
-\f2\-tsacert alias\fP
+\f2\-tsacert alias\fP 
 .TP 2
 o
-\f2\-altsigner class\fP
+\f2\-altsigner class\fP 
 .TP 2
 o
-\f2\-altsignerpath classpathlist\fP
+\f2\-altsignerpath classpathlist\fP 
 .RE
 
 .LP
 .LP
 Each of these options is detailed in the Options section below.
 .LP
-.SS
+.SS 
 JAR File Verification
 .LP
 .LP
@@ -333,7 +333,7 @@
 Verify the signature of the .SF file itself.
 .br
 .br
-That is, the verification ensures that the signature stored in each signature block (.DSA) file was in fact generated using the private key corresponding to the public key whose certificate (or certificate chain) also appears in the .DSA file. It also ensures that the signature is a valid signature of the corresponding signature (.SF) file, and thus the .SF file has not been tampered with.
+That is, the verification ensures that the signature stored in each signature block (.DSA) file was in fact generated using the private key corresponding to the public key whose certificate (or certificate chain) also appears in the .DSA file. It also ensures that the signature is a valid signature of the corresponding signature (.SF) file, and thus the .SF file has not been tampered with. 
 .TP 3
 2.
 Verify the digest listed in each entry in the .SF file with each corresponding section in the manifest.
@@ -345,17 +345,17 @@
 If that is not the case, a less optimized verification is required to ensure that the hash in each source file information section in the .SF file equals the hash of its corresponding section in the manifest file (see The Signature (.SF) File).
 .br
 .br
-One reason the hash of the manifest file that is stored in the .SF file header may not equal the hash of the current manifest file would be because one or more files were added to the JAR file (using the \f2jar\fP tool) after the signature (and thus the .SF file) was generated. When the \f2jar\fP tool is used to add files, the manifest file is changed (sections are added to it for the new files), but the .SF file is not. A verification is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the hashes in the non\-header sections of the .SF file equal the hashes of the corresponding sections in the manifest file.
+One reason the hash of the manifest file that is stored in the .SF file header may not equal the hash of the current manifest file would be because one or more files were added to the JAR file (using the \f2jar\fP tool) after the signature (and thus the .SF file) was generated. When the \f2jar\fP tool is used to add files, the manifest file is changed (sections are added to it for the new files), but the .SF file is not. A verification is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the hashes in the non\-header sections of the .SF file equal the hashes of the corresponding sections in the manifest file. 
 .TP 3
 3.
-Read each file in the JAR file that has an entry in the .SF file. While reading, compute the file's digest, and then compare the result with the digest for this file in the manifest section. The digests should be the same, or verification fails.
+Read each file in the JAR file that has an entry in the .SF file. While reading, compute the file's digest, and then compare the result with the digest for this file in the manifest section. The digests should be the same, or verification fails. 
 .RE
 
 .LP
 .LP
 If any serious verification failures occur during the verification process, the process is stopped and a security exception is thrown. It is caught and displayed by \f3jarsigner\fP.
 .LP
-.SS
+.SS 
 Multiple Signatures for a JAR File
 .LP
 .LP
@@ -401,22 +401,22 @@
 .RS 3
 .TP 2
 o
-All option names are preceded by a minus sign (\-).
+All option names are preceded by a minus sign (\-). 
 .TP 2
 o
-The options may be provided in any order.
+The options may be provided in any order. 
 .TP 2
 o
-Items in italics (option values) represent the actual values that must be supplied.
+Items in italics (option values) represent the actual values that must be supplied. 
 .TP 2
 o
-The \f2\-keystore\fP, \f2\-storepass\fP, \f2\-keypass\fP, \f2\-sigfile\fP, \f2\-sigalg\fP, \f2\-digestalg\fP, and \f2\-signedjar\fP options are only relevant when signing a JAR file, not when verifying a signed JAR file. Similarly, an alias is only specified on the command line when signing a JAR file.
+The \f2\-keystore\fP, \f2\-storepass\fP, \f2\-keypass\fP, \f2\-sigfile\fP, \f2\-sigalg\fP, \f2\-digestalg\fP, and \f2\-signedjar\fP options are only relevant when signing a JAR file, not when verifying a signed JAR file. Similarly, an alias is only specified on the command line when signing a JAR file. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-\-keystore url
+\-keystore url 
 Specifies the URL that tells the keystore location. This defaults to the file \f2.keystore\fP in the user's home directory, as determined by the "user.home" system property.
 .br
 .br
@@ -426,7 +426,7 @@
 A keystore is \f2not\fP required when verifying, but if one is specified, or the default exists, and the \f2\-verbose\fP option was also specified, additional information is output regarding whether or not any of the certificates used to verify the JAR file are contained in that keystore.
 .br
 .br
-Note: the \f2\-keystore\fP argument can actually be a file name (and path) specification rather than a URL, in which case it will be treated the same as a "file:" URL. That is,
+Note: the \f2\-keystore\fP argument can actually be a file name (and path) specification rather than a URL, in which case it will be treated the same as a "file:" URL. That is, 
 .nf
 \f3
 .fl
@@ -434,7 +434,7 @@
 .fl
 \fP
 .fi
-is treated as equivalent to
+is treated as equivalent to 
 .nf
 \f3
 .fl
@@ -442,16 +442,16 @@
 .fl
 \fP
 .fi
-If the Sun PKCS#11 provider has been configured in the \f2java.security\fP security properties file (located in the JRE's \f2$JAVA_HOME/lib/security\fP directory), then keytool and jarsigner can operate on the PKCS#11 token by specifying these options:
+If the Sun PKCS#11 provider has been configured in the \f2java.security\fP security properties file (located in the JRE's \f2$JAVA_HOME/lib/security\fP directory), then keytool and jarsigner can operate on the PKCS#11 token by specifying these options: 
 .RS 3
 .TP 2
 o
-\f2\-keystore NONE\fP
+\f2\-keystore NONE\fP 
 .TP 2
 o
-\f2\-storetype PKCS11\fP
+\f2\-storetype PKCS11\fP 
 .RE
-For example, this command lists the contents of the configured PKCS#11 token:
+For example, this command lists the contents of the configured PKCS#11 token: 
 .nf
 \f3
 .fl
@@ -460,113 +460,113 @@
 \fP
 .fi
 .TP 3
-\-storetype storetype
+\-storetype storetype 
 Specifies the type of keystore to be instantiated. The default keystore type is the one that is specified as the value of the "keystore.type" property in the security properties file, which is returned by the static \f2getDefaultType\fP method in \f2java.security.KeyStore\fP.
 .br
 .br
-The PIN for a PCKS#11 token can also be specified using the \f2\-storepass\fP option. If none has been specified, keytool and jarsigner will prompt for the token PIN. If the token has a protected authentication path (such as a dedicated PIN\-pad or a biometric reader), then the \f2\-protected\fP option must be specified and no password options can be specified.
+The PIN for a PCKS#11 token can also be specified using the \f2\-storepass\fP option. If none has been specified, keytool and jarsigner will prompt for the token PIN. If the token has a protected authentication path (such as a dedicated PIN\-pad or a biometric reader), then the \f2\-protected\fP option must be specified and no password options can be specified. 
 .TP 3
-\-storepass[:env | :file] argument
+\-storepass[:env | :file] argument 
 Specifies the password which is required to access the keystore. This is only needed when signing (not verifying) a JAR file. In that case, if a \f2\-storepass\fP option is not provided at the command line, the user is prompted for the password.
 .br
 .br
-If the modifier \f2env\fP or \f2file\fP is not specified, then the password has the value \f2argument\fP. Otherwise, the password is retrieved as follows:
+If the modifier \f2env\fP or \f2file\fP is not specified, then the password has the value \f2argument\fP. Otherwise, the password is retrieved as follows: 
 .RS 3
 .TP 2
 o
-\f2env\fP: Retrieve the password from the environment variable named \f2argument\fP
+\f2env\fP: Retrieve the password from the environment variable named \f2argument\fP 
 .TP 2
 o
-\f2file\fP: Retrieve the password from the file named \f2argument\fP
+\f2file\fP: Retrieve the password from the file named \f2argument\fP 
 .RE
-Note: The password shouldn't be specified on the command line or in a script unless it is for testing purposes, or you are on a secure system.
+Note: The password shouldn't be specified on the command line or in a script unless it is for testing purposes, or you are on a secure system. 
 .TP 3
-\-keypass[:env | :file] argument
+\-keypass[:env | :file] argument 
 Specifies the password used to protect the private key of the keystore entry addressed by the alias specified on the command line. The password is required when using \f3jarsigner\fP to sign a JAR file. If no password is provided on the command line, and the required password is different from the store password, the user is prompted for it.
 .br
 .br
-If the modifier \f2env\fP or \f2file\fP is not specified, then the password has the value \f2argument\fP. Otherwise, the password is retrieved as follows:
+If the modifier \f2env\fP or \f2file\fP is not specified, then the password has the value \f2argument\fP. Otherwise, the password is retrieved as follows: 
 .RS 3
 .TP 2
 o
-\f2env\fP: Retrieve the password from the environment variable named \f2argument\fP
+\f2env\fP: Retrieve the password from the environment variable named \f2argument\fP 
 .TP 2
 o
-\f2file\fP: Retrieve the password from the file named \f2argument\fP
+\f2file\fP: Retrieve the password from the file named \f2argument\fP 
 .RE
-Note: The password shouldn't be specified on the command line or in a script unless it is for testing purposes, or you are on a secure system.
+Note: The password shouldn't be specified on the command line or in a script unless it is for testing purposes, or you are on a secure system. 
 .TP 3
-\-sigfile file
+\-sigfile file 
 Specifies the base file name to be used for the generated .SF and .DSA files. For example, if \f2file\fP is "DUKESIGN", the generated .SF and .DSA files will be named "DUKESIGN.SF" and "DUKESIGN.DSA", and will be placed in the "META\-INF" directory of the signed JAR file.
 .br
 .br
 The characters in \f2file\fP must come from the set "a\-zA\-Z0\-9_\-". That is, only letters, numbers, underscore, and hyphen characters are allowed. Note: All lowercase characters will be converted to uppercase for the .SF and .DSA file names.
 .br
 .br
-If no \f2\-sigfile\fP option appears on the command line, the base file name for the .SF and .DSA files will be the first 8 characters of the alias name specified on the command line, all converted to upper case. If the alias name has fewer than 8 characters, the full alias name is used. If the alias name contains any characters that are not legal in a signature file name, each such character is converted to an underscore ("_") character in forming the file name.
+If no \f2\-sigfile\fP option appears on the command line, the base file name for the .SF and .DSA files will be the first 8 characters of the alias name specified on the command line, all converted to upper case. If the alias name has fewer than 8 characters, the full alias name is used. If the alias name contains any characters that are not legal in a signature file name, each such character is converted to an underscore ("_") character in forming the file name. 
 .TP 3
-\-sigalg algorithm
+\-sigalg algorithm 
 Specifies the name of the signature algorithm to use to sign the JAR file.
 .br
 .br
-See
+See 
 .na
 \f2Appendix A\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA of the Java Cryptography Architecture for a list of standard signature algorithm names. This algorithm must be compatible with the private key used to sign the JAR file. If this option is not specified, SHA1withDSA, SHA256withRSA, or SHA256withECDSA will be used depending on the type of private key. There must either be a statically installed provider supplying an implementation of the specified algorithm or the user must specify one with the \f2\-providerClass\fP option, otherwise the command will not succeed.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA of the Java Cryptography Architecture for a list of standard signature algorithm names. This algorithm must be compatible with the private key used to sign the JAR file. If this option is not specified, SHA1withDSA, SHA256withRSA, or SHA256withECDSA will be used depending on the type of private key. There must either be a statically installed provider supplying an implementation of the specified algorithm or the user must specify one with the \f2\-providerClass\fP option, otherwise the command will not succeed. 
 .TP 3
-\-digestalg algorithm
+\-digestalg algorithm 
 Specifies the name of the message digest algorithm to use when digesting the entries of a jar file.
 .br
 .br
-See
+See 
 .na
 \f2Appendix A\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA of the Java Cryptography Architecture for a list of standard message digest algorithm names. If this option is not specified, SHA256 will be used. There must either be a statically installed provider supplying an implementation of the specified algorithm or the user must specify one with the \f2\-providerClass\fP option, otherwise the command will not succeed.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA of the Java Cryptography Architecture for a list of standard message digest algorithm names. If this option is not specified, SHA256 will be used. There must either be a statically installed provider supplying an implementation of the specified algorithm or the user must specify one with the \f2\-providerClass\fP option, otherwise the command will not succeed. 
 .TP 3
-\-signedjar file
+\-signedjar file 
 Specifies the name to be used for the signed JAR file.
 .br
 .br
-If no name is specified on the command line, the name used is the same as the input JAR file name (the name of the JAR file to be signed); in other words, that file is overwritten with the signed JAR file.
+If no name is specified on the command line, the name used is the same as the input JAR file name (the name of the JAR file to be signed); in other words, that file is overwritten with the signed JAR file. 
 .TP 3
-\-verify
+\-verify 
 If this appears on the command line, the specified JAR file will be verified, not signed. If the verification is successful, "jar verified" will be displayed. If you try to verify an unsigned JAR file, or a JAR file signed with an unsupported algorithm (e.g., RSA when you don't have an RSA provider installed), the following is displayed: "jar is unsigned. (signatures missing or not parsable)"
 .br
 .br
 It is possible to verify JAR files signed using either \f3jarsigner\fP or the JDK 1.1 \f3javakey\fP tool, or both.
 .br
 .br
-For further information on verification, see JAR File Verification.
+For further information on verification, see JAR File Verification. 
 .TP 3
-\-certs
-If this appears on the command line, along with the \f2\-verify\fP and \f2\-verbose\fP options, the output includes certificate information for each signer of the JAR file. This information includes
+\-certs 
+If this appears on the command line, along with the \f2\-verify\fP and \f2\-verbose\fP options, the output includes certificate information for each signer of the JAR file. This information includes 
 .RS 3
 .TP 2
 o
-the name of the type of certificate (stored in the .DSA file) that certifies the signer's public key
+the name of the type of certificate (stored in the .DSA file) that certifies the signer's public key 
 .TP 2
 o
-if the certificate is an X.509 certificate (more specifically, an instance of \f2java.security.cert.X509Certificate\fP): the distinguished name of the signer
+if the certificate is an X.509 certificate (more specifically, an instance of \f2java.security.cert.X509Certificate\fP): the distinguished name of the signer 
 .RE
-The keystore is also examined. If no keystore value is specified on the command line, the default keystore file (if any) will be checked. If the public key certificate for a signer matches an entry in the keystore, then the following information will also be displayed:
+The keystore is also examined. If no keystore value is specified on the command line, the default keystore file (if any) will be checked. If the public key certificate for a signer matches an entry in the keystore, then the following information will also be displayed: 
 .RS 3
 .TP 2
 o
-in parentheses, the alias name for the keystore entry for that signer. If the signer actually comes from a JDK 1.1 identity database instead of from a keystore, the alias name will appear in brackets instead of parentheses.
+in parentheses, the alias name for the keystore entry for that signer. If the signer actually comes from a JDK 1.1 identity database instead of from a keystore, the alias name will appear in brackets instead of parentheses. 
 .RE
 .TP 3
-\-certchain file
-Specifies the certificate chain to be used, if the certificate chain associated with the private key of the keystore entry, addressed by the alias specified on the command line, is not complete. This may happen if the keystore is located on a hardware token where there is not enough capacity to hold a complete certificate chain. The file can be a sequence of X.509 certificates concatenated together, or a single PKCS#7 formatted data block, either in binary encoding format or in printable encoding format (also known as BASE64 encoding) as defined by the Internet RFC 1421 standard.
+\-certchain file 
+Specifies the certificate chain to be used, if the certificate chain associated with the private key of the keystore entry, addressed by the alias specified on the command line, is not complete. This may happen if the keystore is located on a hardware token where there is not enough capacity to hold a complete certificate chain. The file can be a sequence of X.509 certificates concatenated together, or a single PKCS#7 formatted data block, either in binary encoding format or in printable encoding format (also known as BASE64 encoding) as defined by the Internet RFC 1421 standard. 
 .TP 3
-\-verbose
-If this appears on the command line, it indicates "verbose" mode, which causes \f3jarsigner\fP to output extra information as to the progress of the JAR signing or verification.
+\-verbose 
+If this appears on the command line, it indicates "verbose" mode, which causes \f3jarsigner\fP to output extra information as to the progress of the JAR signing or verification. 
 .TP 3
-\-internalsf
-In the past, the .DSA (signature block) file generated when a JAR file was signed used to include a complete encoded copy of the .SF file (signature file) also generated. This behavior has been changed. To reduce the overall size of the output JAR file, the .DSA file by default doesn't contain a copy of the .SF file anymore. But if \f2\-internalsf\fP appears on the command line, the old behavior is utilized. \f3This option is mainly useful for testing; in practice, it should not be used, since doing so eliminates a useful optimization.\fP
+\-internalsf 
+In the past, the .DSA (signature block) file generated when a JAR file was signed used to include a complete encoded copy of the .SF file (signature file) also generated. This behavior has been changed. To reduce the overall size of the output JAR file, the .DSA file by default doesn't contain a copy of the .SF file anymore. But if \f2\-internalsf\fP appears on the command line, the old behavior is utilized. \f3This option is mainly useful for testing; in practice, it should not be used, since doing so eliminates a useful optimization.\fP 
 .TP 3
-\-sectionsonly
+\-sectionsonly 
 If this appears on the command line, the .SF file (signature file) generated when a JAR file is signed does \f2not\fP include a header containing a hash of the whole manifest file. It just contains information and hashes related to each individual source file included in the JAR file, as described in The Signature (.SF) File .
 .br
 .br
@@ -576,84 +576,84 @@
 For further information, see JAR File Verification.
 .br
 .br
-\f3This option is mainly useful for testing; in practice, it should not be used, since doing so eliminates a useful optimization.\fP
+\f3This option is mainly useful for testing; in practice, it should not be used, since doing so eliminates a useful optimization.\fP 
 .TP 3
-\-protected
-Either \f2true\fP or \f2false\fP. This value should be specified as \f2true\fP if a password must be given via a protected authentication path such as a dedicated PIN reader.
+\-protected 
+Either \f2true\fP or \f2false\fP. This value should be specified as \f2true\fP if a password must be given via a protected authentication path such as a dedicated PIN reader. 
 .TP 3
-\-providerClass provider\-class\-name
+\-providerClass provider\-class\-name 
 Used to specify the name of cryptographic service provider's master class file when the service provider is not listed in the security properties file, \f2java.security\fP.
 .br
 .br
-Used in conjunction with the \f2\-providerArg\fP \f2ConfigFilePath\fP option, keytool and jarsigner will install the provider dynamically (where \f2ConfigFilePath\fP is the path to the token configuration file). Here's an example of a command to list a PKCS#11 keystore when the Sun PKCS#11 provider has not been configured in the security properties file.
+Used in conjunction with the \f2\-providerArg\fP \f2ConfigFilePath\fP option, keytool and jarsigner will install the provider dynamically (where \f2ConfigFilePath\fP is the path to the token configuration file). Here's an example of a command to list a PKCS#11 keystore when the Sun PKCS#11 provider has not been configured in the security properties file. 
 .nf
 \f3
 .fl
-jarsigner \-keystore NONE \-storetype PKCS11 \\
+jarsigner \-keystore NONE \-storetype PKCS11 \\ 
 .fl
-          \-providerClass sun.security.pkcs11.SunPKCS11 \\
+          \-providerClass sun.security.pkcs11.SunPKCS11 \\ 
 .fl
-          \-providerArg /foo/bar/token.config \\
+          \-providerArg /foo/bar/token.config \\ 
 .fl
           \-list
 .fl
 \fP
 .fi
 .TP 3
-\-providerName providerName
+\-providerName providerName 
 If more than one provider has been configured in the \f2java.security\fP security properties file, you can use the \f2\-providerName\fP option to target a specific provider instance. The argument to this option is the name of the provider.
 .br
 .br
-For the Sun PKCS#11 provider, \f2providerName\fP is of the form \f2SunPKCS11\-\fP\f2TokenName\fP, where \f2TokenName\fP is the name suffix that the provider instance has been configured with, as detailed in the
+For the Sun PKCS#11 provider, \f2providerName\fP is of the form \f2SunPKCS11\-\fP\f2TokenName\fP, where \f2TokenName\fP is the name suffix that the provider instance has been configured with, as detailed in the 
 .na
 \f2configuration attributes table\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html#ATTRS. For example, the following command lists the contents of the PKCS#11 keystore provider instance with name suffix \f2SmartCard\fP:
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html#ATTRS. For example, the following command lists the contents of the PKCS#11 keystore provider instance with name suffix \f2SmartCard\fP: 
 .nf
 \f3
 .fl
-jarsigner \-keystore NONE \-storetype PKCS11 \\
+jarsigner \-keystore NONE \-storetype PKCS11 \\ 
 .fl
-        \-providerName SunPKCS11\-SmartCard \\
+        \-providerName SunPKCS11\-SmartCard \\ 
 .fl
         \-list
 .fl
 \fP
 .fi
 .TP 3
-\-Jjavaoption
-Passes through the specified \f2javaoption\fP string directly to the Java interpreter. (\f3jarsigner\fP is actually a "wrapper" around the interpreter.) This option should not contain any spaces. It is useful for adjusting the execution environment or memory usage. For a list of possible interpreter options, type \f2java \-h\fP or \f2java \-X\fP at the command line.
+\-Jjavaoption 
+Passes through the specified \f2javaoption\fP string directly to the Java interpreter. (\f3jarsigner\fP is actually a "wrapper" around the interpreter.) This option should not contain any spaces. It is useful for adjusting the execution environment or memory usage. For a list of possible interpreter options, type \f2java \-h\fP or \f2java \-X\fP at the command line.  
 .TP 3
-\-tsa url
+\-tsa url 
 If \f2"\-tsa http://example.tsa.url"\fP appears on the command line when signing a JAR file then a timestamp is generated for the signature. The URL, \f2http://example.tsa.url\fP, identifies the location of the Time Stamping Authority (TSA). It overrides any URL found via the \f2\-tsacert\fP option. The \f2\-tsa\fP option does not require the TSA's public key certificate to be present in the keystore.
 .br
 .br
-To generate the timestamp, \f2jarsigner\fP communicates with the TSA using the Time\-Stamp Protocol (TSP) defined in
+To generate the timestamp, \f2jarsigner\fP communicates with the TSA using the Time\-Stamp Protocol (TSP) defined in 
 .na
 \f2RFC 3161\fP @
 .fi
-http://www.ietf.org/rfc/rfc3161.txt. If successful, the timestamp token returned by the TSA is stored along with the signature in the signature block file.
+http://www.ietf.org/rfc/rfc3161.txt. If successful, the timestamp token returned by the TSA is stored along with the signature in the signature block file.  
 .TP 3
-\-tsacert alias
+\-tsacert alias 
 If \f2"\-tsacert alias"\fP appears on the command line when signing a JAR file then a timestamp is generated for the signature. The \f2alias\fP identifies the TSA's public key certificate in the keystore that is currently in effect. The entry's certificate is examined for a Subject Information Access extension that contains a URL identifying the location of the TSA.
 .br
 .br
-The TSA's public key certificate must be present in the keystore when using \f2\-tsacert\fP.
+The TSA's public key certificate must be present in the keystore when using \f2\-tsacert\fP.  
 .TP 3
-\-altsigner class
+\-altsigner class 
 Specifies that an alternative signing mechanism be used. The fully\-qualified class name identifies a class file that extends the \f2com.sun.jarsigner.ContentSigner abstract class\fP. The path to this class file is defined by the \f2\-altsignerpath\fP option. If the \f2\-altsigner\fP option is used, \f2jarsigner\fP uses the signing mechanism provided by the specified class. Otherwise, \f2jarsigner\fP uses its default signing mechanism.
 .br
 .br
-For example, to use the signing mechanism provided by a class named \f2com.sun.sun.jarsigner.AuthSigner\fP, use the \f2jarsigner\fP option \f2"\-altsigner com.sun.jarsigner.AuthSigner"\fP
+For example, to use the signing mechanism provided by a class named \f2com.sun.sun.jarsigner.AuthSigner\fP, use the \f2jarsigner\fP option \f2"\-altsigner com.sun.jarsigner.AuthSigner"\fP  
 .TP 3
-\-altsignerpath classpathlist
+\-altsignerpath classpathlist 
 Specifies the path to the class file (the class file name is specified with the \f2\-altsigner\fP option described above) and any JAR files it depends on. If the class file is in a JAR file, then this specifies the path to that JAR file, as shown in the example below.
 .br
 .br
 An absolute path or a path relative to the current directory may be specified. If \f2classpathlist\fP contains multiple paths or JAR files, they should be separated with a colon (\f2:\fP) on Solaris and a semi\-colon (\f2;\fP) on Windows. This option is not necessary if the class is already in the search path.
 .br
 .br
-Example of specifying the path to a jar file that contains the class file:
+Example of specifying the path to a jar file that contains the class file: 
 .nf
 \f3
 .fl
@@ -664,7 +664,7 @@
 Note that the JAR file name is included.
 .br
 .br
-Example of specifying the path to the jar file that contains the class file:
+Example of specifying the path to the jar file that contains the class file: 
 .nf
 \f3
 .fl
@@ -672,19 +672,19 @@
 .fl
 \fP
 .fi
-Note that the JAR file name is omitted.
+Note that the JAR file name is omitted. 
 .TP 3
-\-strict
-During the signing or verifying process, some warning messages may be shown. If this option appears on the command line, the exit code of the tool will reflect the warning messages that are found. Read the "WARNINGS" section for details.
+\-strict 
+During the signing or verifying process, some warning messages may be shown. If this option appears on the command line, the exit code of the tool will reflect the warning messages that are found. Read the "WARNINGS" section for details. 
 .TP 3
-\-verbose:sub\-options
-For the verifying process, the \f2\-verbose\fP option takes sub\-options to determine how much information will be shown. If \f2\-certs\fP is also specified, the default mode (or sub\-option all) displays each entry as it is being processed and following that, the certificate information for each signer of the JAR file. If \f2\-certs\fP and the \f2\-verbose:grouped\fP sub\-option are specified, entries with the same signer info are grouped and displayed together along with their certificate information. If \f2\-certs\fP and the \f2\-verbose:summary\fP sub\-option are specified, then entries with the same signer info are grouped and displayed together along with their certificate information but details about each entry are summarized and displayed as "one entry (and more)". See the examples section for more information.
+\-verbose:sub\-options 
+For the verifying process, the \f2\-verbose\fP option takes sub\-options to determine how much information will be shown. If \f2\-certs\fP is also specified, the default mode (or sub\-option all) displays each entry as it is being processed and following that, the certificate information for each signer of the JAR file. If \f2\-certs\fP and the \f2\-verbose:grouped\fP sub\-option are specified, entries with the same signer info are grouped and displayed together along with their certificate information. If \f2\-certs\fP and the \f2\-verbose:summary\fP sub\-option are specified, then entries with the same signer info are grouped and displayed together along with their certificate information but details about each entry are summarized and displayed as "one entry (and more)". See the examples section for more information. 
 .RE
 
 .LP
 .SH "EXAMPLES"
 .LP
-.SS
+.SS 
 Signing a JAR File
 .LP
 .LP
@@ -742,7 +742,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Verifying a Signed JAR File
 .LP
 .LP
@@ -808,7 +808,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Verification with Certificate Information
 .LP
 .LP
@@ -867,7 +867,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Verification of a JAR File that Includes Identity Database Signers
 .LP
 .LP
@@ -924,7 +924,7 @@
 .LP
 .SH "WARNINGS"
 .LP
-During the signing/verifying process, jarsigner may display various warnings. These warning codes are defined as follows:
+During the signing/verifying process, jarsigner may display various warnings. These warning codes are defined as follows: 
 .nf
 \f3
 .fl
@@ -1011,7 +1011,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Compatibility with JDK 1.1
 .LP
 .LP
@@ -1023,13 +1023,13 @@
 .RS 3
 .TP 2
 o
-It is possible to import the information from an identity database into a keystore, via the \f3keytool\fP \f2\-identitydb\fP command.
+It is possible to import the information from an identity database into a keystore, via the \f3keytool\fP \f2\-identitydb\fP command. 
 .TP 2
 o
-\f3jarsigner\fP can sign JAR files also previously signed using \f3javakey\fP.
+\f3jarsigner\fP can sign JAR files also previously signed using \f3javakey\fP. 
 .TP 2
 o
-\f3jarsigner\fP can verify JAR files signed using \f3javakey\fP. Thus, it recognizes and can work with signer aliases that are from a JDK 1.1 identity database rather than a Java 2 SDK keystore.
+\f3jarsigner\fP can verify JAR files signed using \f3javakey\fP. Thus, it recognizes and can work with signer aliases that are from a JDK 1.1 identity database rather than a Java 2 SDK keystore. 
 .RE
 
 .LP
@@ -1037,6 +1037,7 @@
 The following table explains how JAR files that were signed in JDK 1.1.x are treated in the Java 2 platform.
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -1361,7 +1362,7 @@
 .ne \n(b|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3JAR File Type\fP\h'|\n(41u'\f3Identity in 1.1 database\fP\h'|\n(42u'\h'|\n(43u'\h'|\n(44u'\f3Privileges Granted\fP
@@ -1384,7 +1385,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'NO\h'|\n(42u'NO\h'|\n(43u'NO\h'|\n(44u'
@@ -1400,7 +1401,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Unsigned JAR\h'|\n(41u'NO\h'|\n(42u'NO\h'|\n(43u'NO\h'|\n(44u'
@@ -1416,7 +1417,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'NO\h'|\n(42u'YES\h'|\n(43u'NO\h'|\n(44u'
@@ -1432,7 +1433,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'YES/Untrusted\h'|\n(42u'NO\h'|\n(43u'NO\h'|\n(44u'
@@ -1448,7 +1449,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'YES/Untrusted\h'|\n(42u'NO\h'|\n(43u'YES\h'|\n(44u'
@@ -1464,7 +1465,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'NO\h'|\n(42u'YES\h'|\n(43u'YES\h'|\n(44u'
@@ -1480,7 +1481,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'YES/Trusted\h'|\n(42u'YES\h'|\n(43u'YES\h'|\n(44u'
@@ -1494,15 +1495,15 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'YES/Trusted\h'|\n(42u'NO\h'|\n(43u'NO\h'|\n(44u'All privileges
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'YES/Trusted\h'|\n(42u'YES\h'|\n(43u'NO\h'|\n(44u'All privileges (1)
-.ta \n(80u \n(81u \n(82u \n(83u \n(84u
+.ta \n(80u \n(81u \n(82u \n(83u \n(84u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Signed JAR\h'|\n(41u'YES/Trusted\h'|\n(42u'NO\h'|\n(43u'YES\h'|\n(44u'All privileges (1)
@@ -1519,6 +1520,7 @@
 .rm g+
 .rm h+
 .rm i+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-42
 
 .LP
@@ -1528,16 +1530,16 @@
 .RS 3
 .TP 3
 1.
-If an identity/alias is mentioned in the policy file, it must be imported into the keystore for the policy file to have any effect on privileges granted.
+If an identity/alias is mentioned in the policy file, it must be imported into the keystore for the policy file to have any effect on privileges granted. 
 .TP 3
 2.
-The policy file/keystore combination has precedence over a trusted identity in the identity database.
+The policy file/keystore combination has precedence over a trusted identity in the identity database. 
 .TP 3
 3.
-Untrusted identities are ignored in the Java 2 platform.
+Untrusted identities are ignored in the Java 2 platform. 
 .TP 3
 4.
-Only trusted identities can be imported into Java 2 SDK keystores.
+Only trusted identities can be imported into Java 2 SDK keystores. 
 .RE
 
 .LP
@@ -1546,22 +1548,22 @@
 .RS 3
 .TP 2
 o
-jar(1) tool documentation
+jar(1) tool documentation 
 .TP 2
 o
-keytool(1) tool documentation
+keytool(1) tool documentation 
 .TP 2
 o
-the
+the 
 .na
 \f4Security\fP @
 .fi
-http://download.oracle.com/javase/tutorial/security/index.html trail of the
+http://docs.oracle.com/javase/tutorial/security/index.html trail of the 
 .na
 \f4Java Tutorial\fP @
 .fi
-http://download.oracle.com/javase/tutorial/index.html for examples of the use of the \f3jarsigner\fP tool
+http://docs.oracle.com/javase/tutorial/index.html for examples of the use of the \f3jarsigner\fP tool 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/java.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/java.1	2013-05-05 09:38:28.000000000 -0700
@@ -1,4 +1,4 @@
-." Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.
+." Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.
 ." DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 ."
 ." This code is free software; you can redistribute it and/or modify it
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH java 1 "10 May 2011"
+.TH java 1 "20 Mar 2012"
 
 .LP
 .SH "Name"
@@ -39,17 +39,17 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options.
+options 
+Command\-line options. 
 .TP 3
-class
-Name of the class to be invoked.
+class 
+Name of the class to be invoked. 
 .TP 3
-file.jar
-Name of the jar file to be invoked. Used only with \f2\-jar\fP.
+file.jar 
+Name of the jar file to be invoked. Used only with \f2\-jar\fP. 
 .TP 3
-argument
-Argument passed to the \f3main\fP function.
+argument 
+Argument passed to the \f3main\fP function. 
 .RE
 
 .LP
@@ -88,27 +88,27 @@
 .LP
 .RS 3
 .TP 3
-\-client
+\-client 
 Select the Java HotSpot Client VM. A 64\-bit capable jdk currently ignores this option and instead uses the Java Hotspot Server VM.
 .br
 .br
-For default VM selection, see
+For default VM selection, see 
 .na
 \f2Server\-Class Machine Detection\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/vm/server\-class.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server\-class.html 
 .TP 3
-\-server
+\-server 
 Select the Java HotSpot Server VM. On a 64\-bit capable jdk only the Java Hotspot Server VM is supported so the \-server option is implicit.
 .br
 .br
-For default VM selection, see
+For default VM selection, see 
 .na
 \f2Server\-Class Machine Detection\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/vm/server\-class.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server\-class.html 
 .TP 3
-\-agentlib:libname[=options]
+\-agentlib:libname[=options] 
 Load native agent library \f2libname\fP, e.g.
 .br
 .br
@@ -121,151 +121,160 @@
 \-agentlib:hprof=help
 .br
 .br
-For more information, see
+For more information, see 
 .na
 \f2JVMTI Agent Command Line Options\fP @
 .fi
-http://download.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#starting.
+http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#starting. 
 .TP 3
-\-agentpath:pathname[=options]
-Load a native agent library by full pathname. For more information, see
+\-agentpath:pathname[=options] 
+Load a native agent library by full pathname. For more information, see 
 .na
 \f2JVMTI Agent Command Line Options\fP @
 .fi
-http://download.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#starting.
+http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#starting. 
 .TP 3
-\-classpath classpath
+\-classpath classpath 
 .TP 3
-\-cp classpath
+\-cp classpath 
 Specify a list of directories, JAR archives, and ZIP archives to search for class files. Class path entries are separated by colons (\f3:\fP). Specifying \f3\-classpath\fP or \f3\-cp\fP overrides any setting of the \f3CLASSPATH\fP environment variable.
 .br
 .br
-If \f3\-classpath\fP and \f3\-cp\fP are not used and \f3CLASSPATH\fP is not set, the user class path consists of the current directory (\f4.\fP).
+If \f3\-classpath\fP and \f3\-cp\fP are not used and \f3CLASSPATH\fP is not set, the user class path consists of the current directory (\f4.\fP).  
 .br
 .br
 As a special convenience, a class path element containing a basename of \f2*\fP is considered equivalent to specifying a list of all the files in the directory with the extension \f2.jar\fP or \f2.JAR\fP (a java program cannot tell the difference between the two invocations).
 .br
 .br
-For example, if directory \f2foo\fP contains \f2a.jar\fP and \f2b.JAR\fP, then the class path element \f2foo/*\fP is expanded to a \f2A.jar:b.JAR\fP, except that the order of jar files is unspecified. All jar files in the specified directory, even hidden ones, are included in the list. A classpath entry consisting simply of \f2*\fP expands to a list of all the jar files in the current directory. The \f2CLASSPATH\fP environment variable, where defined, will be similarly expanded. Any classpath wildcard expansion occurs before the Java virtual machine is started \-\- no Java program will ever see unexpanded wildcards except by querying the environment. For example; by invoking \f2System.getenv("CLASSPATH")\fP.
+For example, if directory \f2foo\fP contains \f2a.jar\fP and \f2b.JAR\fP, then the class path element \f2foo/*\fP is expanded to a \f2A.jar:b.JAR\fP, except that the order of jar files is unspecified. All jar files in the specified directory, even hidden ones, are included in the list. A classpath entry consisting simply of \f2*\fP expands to a list of all the jar files in the current directory. The \f2CLASSPATH\fP environment variable, where defined, will be similarly expanded. Any classpath wildcard expansion occurs before the Java virtual machine is started \-\- no Java program will ever see unexpanded wildcards except by querying the environment. For example; by invoking \f2System.getenv("CLASSPATH")\fP.  
 .br
 .br
-For more information on class paths, see
+For more information on class paths, see 
 .na
 \f2Setting the Class Path\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#classpath.
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#classpath. 
 .TP 3
-\-Dproperty=value
-Set a system property value.
+\-Dproperty=value 
+Set a system property value. 
 .TP 3
-\-d32
+\-d32 
 .TP 3
-\-d64
+\-d64 
 Request that the program to be run in a 32\-bit or 64\-bit environment, respectively. If the requested environment is not installed or is not supported, an error is reported.
 .br
 .br
 Currently only the Java HotSpot Server VM supports 64\-bit operation, and the "\-server" option is implicit with the use of \-d64. And the "\-client" option is ignored with the use of \-d64. This is subject to change in a future release.
 .br
 .br
-If neither \f3\-d32\fP nor \f3\-d64\fP is specified, the default is to run in a 32\-bit environment, except for 64\-bit only systems. This is subject to change in a future release.
+If neither \f3\-d32\fP nor \f3\-d64\fP is specified, the default is to run in a 32\-bit environment, except for 64\-bit only systems. This is subject to change in a future release. 
 .TP 3
-\-enableassertions[:<package name>"..." | :<class name> ]
+\-enableassertions[:<package name>"..." | :<class name> ] 
 .TP 3
-\-ea[:<package name>"..." | :<class name> ]
-Enable assertions. Assertions are disabled by default.
+\-ea[:<package name>"..." | :<class name> ] 
+.TP 3
+\-disableassertions[:<package name>"..." | :<class name> ] 
+.TP 3
+\-da[:<package name>"..." | :<class name> ] 
+Disable assertions. This is the default.
 .br
 .br
-With no arguments, \f3enableassertions\fP or \f3\-ea\fP enables assertions. With one argument ending in \f2"..."\fP, the switch enables assertions in the specified package and any subpackages. If the argument is simply \f2"..."\fP, the switch enables assertions in the unnamed package in the current working directory. With one argument not ending in \f2"..."\fP, the switch enables assertions in the specified class.
+With no arguments, \f3disableassertions\fP or \f3\-da\fP disables assertions. With one argument ending in \f2"..."\fP, the switch disables assertions in the specified package and any subpackages. If the argument is simply \f2"..."\fP, the switch disables assertions in the unnamed package in the current working directory. With one argument not ending in \f2"..."\fP, the switch disables assertions in the specified class.
 .br
 .br
-If a single command line contains multiple instances of these switches, they are processed in order before loading any classes. So, for example, to run a program with assertions enabled only in package \f2com.wombat.fruitbat\fP (and any subpackages), the following command could be used:
+To run a program with assertions enabled in package \f2com.wombat.fruitbat\fP but disabled in class \f2com.wombat.fruitbat.Brickbat\fP, the following command could be used: 
 .nf
 \f3
 .fl
-java \-ea:com.wombat.fruitbat... <Main Class>
+java \-ea:com.wombat.fruitbat... \-da:com.wombat.fruitbat.Brickbat \fP\f4<Main Class>\fP\f3
 .fl
 \fP
 .fi
-The \f3\-enableassertions\fP and \f3\-ea\fP switches apply to \f2all\fP class loaders and to system classes (which do not have a class loader). There is one exception to this rule: in their no\-argument form, the switches do \f2not\fP apply to system. This makes it easy to turn on asserts in all classes except for system classes. A separate switch is provided to enable asserts in all system classes; see \f3\-enablesystemassertions\fP below.
-.TP 3
-\-disableassertions[:<package name>"..." | :<class name> ]
-.TP 3
-\-da[:<package name>"..." | :<class name> ]
-Disable assertions. This is the default.
+The \f3\-disableassertions\fP and \f3\-da\fP switches apply to \f2all\fP class loaders and to system classes (which do not have a class loader). There is one exception to this rule: in their no\-argument form, the switches do \f2not\fP apply to system. This makes it easy to turn on asserts in all classes except for system classes. A separate switch is provided to enable asserts in all system classes; see \f3\-disablesystemassertions\fP below. 
+Enable assertions. Assertions are disabled by default.
 .br
 .br
-With no arguments, \f3disableassertions\fP or \f3\-da\fP disables assertions. With one argument ending in \f2"..."\fP, the switch disables assertions in the specified package and any subpackages. If the argument is simply \f2"..."\fP, the switch disables assertions in the unnamed package in the current working directory. With one argument not ending in \f2"..."\fP, the switch disables assertions in the specified class.
+With no arguments, \f3enableassertions\fP or \f3\-ea\fP enables assertions. With one argument ending in \f2"..."\fP, the switch enables assertions in the specified package and any subpackages. If the argument is simply \f2"..."\fP, the switch enables assertions in the unnamed package in the current working directory. With one argument not ending in \f2"..."\fP, the switch enables assertions in the specified class.
 .br
 .br
-To run a program with assertions enabled in package \f2com.wombat.fruitbat\fP but disabled in class \f2com.wombat.fruitbat.Brickbat\fP, the following command could be used:
+If a single command line contains multiple instances of these switches, they are processed in order before loading any classes. So, for example, to run a program with assertions enabled only in package \f2com.wombat.fruitbat\fP (and any subpackages), the following command could be used: 
 .nf
 \f3
 .fl
-java \-ea:com.wombat.fruitbat... \-da:com.wombat.fruitbat.Brickbat \fP\f4<Main Class>\fP\f3
+java \-ea:com.wombat.fruitbat... <Main Class>
 .fl
 \fP
 .fi
-The \f3\-disableassertions\fP and \f3\-da\fP switches apply to \f2all\fP class loaders and to system classes (which do not have a class loader). There is one exception to this rule: in their no\-argument form, the switches do \f2not\fP apply to system. This makes it easy to turn on asserts in all classes except for system classes. A separate switch is provided to enable asserts in all system classes; see \f3\-disablesystemassertions\fP below.
+The \f3\-enableassertions\fP and \f3\-ea\fP switches apply to \f2all\fP class loaders and to system classes (which do not have a class loader). There is one exception to this rule: in their no\-argument form, the switches do \f2not\fP apply to system. This makes it easy to turn on asserts in all classes except for system classes. A separate switch is provided to enable asserts in all system classes; see \f3\-enablesystemassertions\fP below. 
 .TP 3
-\-enablesystemassertions
+\-enablesystemassertions 
 .TP 3
-\-esa
-Enable asserts in all system classes (sets the \f2default assertion status\fP for system classes to \f2true\fP).
+\-esa 
+Enable asserts in all system classes (sets the \f2default assertion status\fP for system classes to \f2true\fP). 
 .TP 3
-\-disablesystemassertions
+\-disablesystemassertions 
 .TP 3
-\-dsa
-Disables asserts in all system classes.
+\-dsa 
+Disables asserts in all system classes. 
 .TP 3
-\-jar
-Execute a program encapsulated in a JAR file. The first argument is the name of a JAR file instead of a startup class name. In order for this option to work, the manifest of the JAR file must contain a line of the form \f3Main\-Class: \fP\f4classname\fP. Here, \f2classname\fP identifies the class having the \f2public\ static\ void\ main(String[]\ args)\fP method that serves as your application's starting point. See the jar(1) and the Jar trail of the
+\-help or \-? 
+Display usage information and exit. 
+.TP 3
+\-jar 
+Execute a program encapsulated in a JAR file. The first argument is the name of a JAR file instead of a startup class name. In order for this option to work, the manifest of the JAR file must contain a line of the form \f3Main\-Class: \fP\f4classname\fP. Here, \f2classname\fP identifies the class having the \f2public\ static\ void\ main(String[]\ args)\fP method that serves as your application's starting point. See the jar(1) and the Jar trail of the 
 .na
 \f2Java Tutorial\fP @
 .fi
-http://download.oracle.com/javase/tutorial/deployment/jar for information about working with Jar files and Jar\-file manifests.
+http://docs.oracle.com/javase/tutorial/deployment/jar for information about working with Jar files and Jar\-file manifests.\ 
 .br
 .br
 When you use this option, the JAR file is the source of all user classes, and other user class path settings are ignored.
 .br
 .br
-Note that JAR files that can be run with the "java \-jar" option can have their execute permissions set so they can be run without using "java \-jar". Refer to
+Note that JAR files that can be run with the "java \-jar" option can have their execute permissions set so they can be run without using "java \-jar". Refer to 
 .na
 \f2Java Archive (JAR) Files\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jar/index.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/jar/index.html. 
 .TP 3
-\-javaagent:jarpath[=options]
-Load a Java programming language agent, see
+\-javaagent:jarpath[=options] 
+Load a Java programming language agent, see 
 .na
 \f2java.lang.instrument\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/lang/instrument/package\-summary.html.
+http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package\-summary.html. 
+.TP 3
+\-jre\-restrict\-search 
+Include user\-private JREs in the version search. 
+.TP 3
+\-no\-jre\-restrict\-search 
+Exclude user\-private JREs in the version search. 
 .TP 3
-\-jre\-restrict\-search
-Include user\-private JREs in the version search.
+\-showversion 
+Display version information and continue. (See also \f3\-version\fP.) 
 .TP 3
-\-no\-jre\-restrict\-search
-Exclude user\-private JREs in the version search.
+\-splash:imagepath 
+Show splash screen with image specified by \f2imagepath\fP. 
 .TP 3
-\-verbose
+\-verbose 
 .TP 3
-\-verbose:class
-Display information about each class loaded.
+\-verbose:class 
+Display information about each class loaded. 
 .TP 3
-\-verbose:gc
-Report on each garbage collection event.
+\-verbose:gc 
+Report on each garbage collection event. 
 .TP 3
-\-verbose:jni
-Report information about use of native methods and other Java Native Interface activity.
+\-verbose:jni 
+Report information about use of native methods and other Java Native Interface activity. 
 .TP 3
-\-version
-Display version information and exit.
+\-version 
+Display version information and exit. (See also \f3\-showversion\fP.) 
 .TP 3
-\-version:release
+\-version:release 
 Specifies that the version specified by \f2release\fP is required by the class or jar file specified on the command line. If the version of the java command invoked does not meet this specification and an appropriate implementation is found on the system, the appropriate implementation will be used.
 .br
 .br
-\f2release\fP not only can specify an exact version, but can also specify a list of versions called a version string. A version string is an ordered list of version ranges separated by spaces. A version range is either a version\-id, a version\-id followed by a star (*), a version\-id followed by a plus sign (+) , or two version\-ranges combined using an ampersand (&). The star means prefix match, the plus sign means this version or greater, and the ampersand means the logical anding of the two version\-ranges. For example:
+\f2release\fP not only can specify an exact version, but can also specify a list of versions called a version string. A version string is an ordered list of version ranges separated by spaces. A version range is either a version\-id, a version\-id followed by a star (*), a version\-id followed by a plus sign (+) , or two version\-ranges combined using an ampersand (&). The star means prefix match, the plus sign means this version or greater, and the ampersand means the logical anding of the two version\-ranges. For example: 
 .nf
 \f3
 .fl
@@ -279,71 +288,63 @@
 For jar files, the usual preference is to specify version requirements in the jar file manifest rather than on the command line.
 .br
 .br
-See the following NOTES section for important policy information on the use of this option.
-.TP 3
-\-showversion
-Display version information and continue.
-.TP 3
-\-?
-.TP 3
-\-help
-Display usage information and exit.
-.TP 3
-\-splash:imagepath
-Show splash screen with image specified by \f2imagepath\fP.
-.TP 3
-\-X
-Display information about non\-standard options and exit.
+See the following NOTES section for important policy information on the use of this option. 
 .RE
 
 .LP
-.SS
+.SS 
 Non\-Standard Options
 .LP
 .RS 3
 .TP 3
-\-Xint
-Operate in interpreted\-only mode. Compilation to native code is disabled, and all bytecodes are executed by the interpreter. The performance benefits offered by the Java HotSpot VMs' adaptive compiler will not be present in this mode.
+\-X 
+Display information about non\-standard options and exit. 
 .TP 3
-\-Xbatch
-Disable background compilation. Normally the VM will compile the method as a background task, running the method in interpreter mode until the background compilation is finished. The \f2\-Xbatch\fP flag disables background compilation so that compilation of all methods proceeds as a foreground task until completed.
+\-Xint 
+Operate in interpreted\-only mode. Compilation to native code is disabled, and all bytecodes are executed by the interpreter. The performance benefits offered by the Java HotSpot VMs' adaptive compiler will not be present in this mode. 
 .TP 3
-\-Xbootclasspath:bootclasspath
-Specify a colon\-separated list of directories, JAR archives, and ZIP archives to search for boot class files. These are used in place of the boot class files included in the Java platform JDK. \f2Note: Applications that use this option for the purpose of overriding a class in rt.jar should not be deployed as doing so would contravene the Java Runtime Environment binary code license.\fP
+\-Xbatch 
+Disable background compilation. Normally the VM will compile the method as a background task, running the method in interpreter mode until the background compilation is finished. The \f2\-Xbatch\fP flag disables background compilation so that compilation of all methods proceeds as a foreground task until completed. 
 .TP 3
-\-Xbootclasspath/a:path
-Specify a colon\-separated path of directires, JAR archives, and ZIP archives to append to the default bootstrap class path.
+\-Xbootclasspath:bootclasspath 
+Specify a colon\-separated list of directories, JAR archives, and ZIP archives to search for boot class files. These are used in place of the boot class files included in the Java platform JDK. \f2Note: Applications that use this option for the purpose of overriding a class in rt.jar should not be deployed as doing so would contravene the Java Runtime Environment binary code license.\fP 
 .TP 3
-\-Xbootclasspath/p:path
-Specify a colon\-separated path of directires, JAR archives, and ZIP archives to prepend in front of the default bootstrap class path. \f2Note: Applications that use this option for the purpose of overriding a class in rt.jar should not be deployed as doing so would contravene the Java Runtime Environment binary code license.\fP
+\-Xbootclasspath/a:path 
+Specify a colon\-separated path of directires, JAR archives, and ZIP archives to append to the default bootstrap class path. 
 .TP 3
-\-Xcheck:jni
-Perform additional checks for Java Native Interface (JNI) functions. Specifically, the Java Virtual Machine validates the parameters passed to the JNI function as well as the runtime environment data before processing the JNI request. Any invalid data encountered indicates a problem in the native code, and the Java Virtual Machine will terminate with a fatal error in such cases. Expect a performance degradation when this option is used.
+\-Xbootclasspath/p:path 
+Specify a colon\-separated path of directires, JAR archives, and ZIP archives to prepend in front of the default bootstrap class path. \f2Note: Applications that use this option for the purpose of overriding a class in rt.jar should not be deployed as doing so would contravene the Java Runtime Environment binary code license.\fP 
 .TP 3
-\-Xfuture
-Perform strict class\-file format checks. For purposes of backwards compatibility, the default format checks performed by the JDK's virtual machine are no stricter than the checks performed by 1.1.x versions of the JDK software. The \f3\-Xfuture\fP flag turns on stricter class\-file format checks that enforce closer conformance to the class\-file format specification. Developers are encouraged to use this flag when developing new code because the stricter checks will become the default in future releases of the Java application launcher.
+\-Xcheck:jni 
+Perform additional checks for Java Native Interface (JNI) functions. Specifically, the Java Virtual Machine validates the parameters passed to the JNI function as well as the runtime environment data before processing the JNI request. Any invalid data encountered indicates a problem in the native code, and the Java Virtual Machine will terminate with a fatal error in such cases. Expect a performance degradation when this option is used. 
 .TP 3
-\-Xnoclassgc
-Disable class garbage collection. Use of this option will prevent memory recovery from loaded classes thus increasing overall memory usage. This could cause OutOfMemoryError to be thrown in some applications.
+\-Xfuture 
+Perform strict class\-file format checks. For purposes of backwards compatibility, the default format checks performed by the JDK's virtual machine are no stricter than the checks performed by 1.1.x versions of the JDK software. The \f3\-Xfuture\fP flag turns on stricter class\-file format checks that enforce closer conformance to the class\-file format specification. Developers are encouraged to use this flag when developing new code because the stricter checks will become the default in future releases of the Java application launcher. 
 .TP 3
-\-Xincgc
-Enable the incremental garbage collector. The incremental garbage collector, which is off by default, will reduce the occasional long garbage\-collection pauses during program execution. The incremental garbage collector will at times execute concurrently with the program and during such times will reduce the processor capacity available to the program.
+\-Xnoclassgc 
+Disable class garbage collection. Use of this option will prevent memory recovery from loaded classes thus increasing overall memory usage. This could cause OutOfMemoryError to be thrown in some applications. 
 .TP 3
-\-Xloggc:file
+\-Xincgc 
+Enable the incremental garbage collector. The incremental garbage collector, which is off by default, will reduce the occasional long garbage\-collection pauses during program execution. The incremental garbage collector will at times execute concurrently with the program and during such times will reduce the processor capacity available to the program. 
+.TP 3
+\-Xloggc:file 
 Report on each garbage collection event, as with \-verbose:gc, but log this data to \f2file\fP. In addition to the information \f2\-verbose:gc\fP gives, each reported event will be preceeded by the time (in seconds) since the first garbage\-collection event.
 .br
 .br
-Always use a local file system for storage of this file to avoid stalling the JVM due to network latency. The file may be truncated in the case of a full file system and logging will continue on the truncated file. This option overrides \f2\-verbose:gc\fP if both are given on the command line.
+Always use a local file system for storage of this file to avoid stalling the JVM due to network latency. The file may be truncated in the case of a full file system and logging will continue on the truncated file. This option overrides \f2\-verbose:gc\fP if both are given on the command line. 
+.TP 3
+\-Xmnsize or \-XX:NewSize 
+Sets the size of the young generation (nursery). 
 .TP 3
-\-Xmsn
-Specify the initial size, in bytes, of the memory allocation pool. This value must be a multiple of 1024 greater than 1MB. Append the letter \f2k\fP or \f2K\fP to indicate kilobytes, or \f2m\fP or \f2M\fP to indicate megabytes. The default value is chosen at runtime based on system configuration. For more information, see
+\-Xmsn 
+Specify the initial size, in bytes, of the memory allocation pool. This value must be a multiple of 1024 greater than 1MB. Append the letter \f2k\fP or \f2K\fP to indicate kilobytes, or \f2m\fP or \f2M\fP to indicate megabytes. The default value is chosen at runtime based on system configuration. For more information, see 
 .na
 \f2HotSpot Ergonomics\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/vm/gc\-ergonomics.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/vm/gc\-ergonomics.html
 .br
 .br
-Examples:
+Examples: 
 .nf
 \f3
 .fl
@@ -358,15 +359,15 @@
 \fP
 .fi
 .TP 3
-\-Xmxn
-Specify the maximum size, in bytes, of the memory allocation pool. This value must a multiple of 1024 greater than 2MB. Append the letter \f2k\fP or \f2K\fP to indicate kilobytes, or \f2m\fP or \f2M\fP to indicate megabytes. The default value is chosen at runtime based on system configuration. For more information, see
+\-Xmxn 
+Specify the maximum size, in bytes, of the memory allocation pool. This value must a multiple of 1024 greater than 2MB. Append the letter \f2k\fP or \f2K\fP to indicate kilobytes, or \f2m\fP or \f2M\fP to indicate megabytes. The default value is chosen at runtime based on system configuration. For more information, see 
 .na
 \f2HotSpot Ergonomics\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/vm/gc\-ergonomics.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/vm/gc\-ergonomics.html
 .br
 .br
-Examples:
+Examples: 
 .nf
 \f3
 .fl
@@ -380,12 +381,12 @@
 .fl
 \fP
 .fi
-On Solaris 7 and Solaris 8 SPARC platforms, the upper limit for this value is approximately 4000m minus overhead amounts. On Solaris 2.6 and x86 platforms, the upper limit is approximately 2000m minus overhead amounts. On Bsd platforms, the upper limit is approximately 2000m minus overhead amounts.
+On Solaris 7 and Solaris 8 SPARC platforms, the upper limit for this value is approximately 4000m minus overhead amounts. On Solaris 2.6 and x86 platforms, the upper limit is approximately 2000m minus overhead amounts. On Linux and BSD platforms, the upper limit is approximately 2000m minus overhead amounts. 
 .TP 3
-\-Xprof
-Profiles the running program, and sends profiling data to standard output. This option is provided as a utility that is useful in program development and is not intended to be used in production systems.
+\-Xprof 
+Profiles the running program, and sends profiling data to standard output. This option is provided as a utility that is useful in program development and is not intended to be used in production systems.  
 .TP 3
-\-Xrs
+\-Xrs 
 Reduces use of operating\-system signals by the Java virtual machine (JVM).
 .br
 .br
@@ -401,36 +402,109 @@
 Applications embedding the JVM frequently need to trap signals like SIGINT or SIGTERM, which can lead to interference with the JVM's own signal handlers. The \f3\-Xrs\fP command\-line option is available to address this issue. When \f3\-Xrs\fP is used on Sun's JVM, the signal masks for SIGINT, SIGTERM, SIGHUP, and SIGQUIT are not changed by the JVM, and signal handlers for these signals are not installed.
 .br
 .br
-There are two consequences of specifying \f3\-Xrs\fP:
+There are two consequences of specifying \f3\-Xrs\fP: 
 .RS 3
 .TP 2
 o
-SIGQUIT thread dumps are not available.
+SIGQUIT thread dumps are not available. 
 .TP 2
 o
-User code is responsible for causing shutdown hooks to run, for example by calling System.exit() when the JVM is to be terminated.
+User code is responsible for causing shutdown hooks to run, for example by calling System.exit() when the JVM is to be terminated. 
 .RE
 .TP 3
-\-Xssn
-Set thread stack size.
+\-Xssn 
+Set thread stack size. 
 .TP 3
-\-XX:+UseAltSigs
-The VM uses \f2SIGUSR1\fP and \f2SIGUSR2\fP by default, which can sometimes conflict with applications that signal\-chain \f2SIGUSR1\fP and \f2SIGUSR2\fP. The \f2\-XX:+UseAltSigs\fP option will cause the VM to use signals other than \f2SIGUSR1\fP and \f2SIGUSR2\fP as the default.
-.RE
-
-.LP
-.SH "NOTES"
-.LP
-.LP
-The \f3\-version:\fP\f2release\fP command line option places no restrictions on the complexity of the release specification. However, only a restricted subset of the possible release specifications represent sound policy and only these are fully supported. These policies are:
+\-XX:AllocationPrefetchStyle=n 
+Sets the style of prefetch used during allocation. default=2.
+.br
+.TP 3
+\-XX:+AggressiveOpts 
+Enables aggressive optimization.
+.br
+.TP 3
+\-XX:+|\-DisableAttachMechanism 
+This option specifies whether tools (such as \f2jmap\fP and \f2jconsole\fP) are allowed to attach to the JVM. By default, this feature is disabled. That is, attaching is enabled. Example usage: 
+.nf
+\f3
+.fl
+      java \-XX:+DisableAttachMechanism
+.fl
+\fP
+.fi
+.TP 3
+\-XXLargePageSizeInBytes=n 
+This option specifies the maximum size for large pages. 
+.TP 3
+\-XX:MaxGCPauseMillis=n 
+Sets a target for the maximum GC pause time.
+.br
+This is a soft goal, and the JVM will make its best effort to achieve it. 
+.TP 3
+\-XX:NewSize 
+Sets the size of the young generation (nursery). Sames as \f3\-Xmn\fP\f4size\fP. 
+.TP 3
+\-XX:ParallelGCThreads=n 
+Sets the number of GC threads in the parallel collectors.
+.br
+.TP 3
+\-XX:PredictedClassLoadCount=n 
+This option requires that the \f3UnlockExperimentalVMOptions\fP flag be set first. Use the \f3PredictedClassLoadCount\fP flag if your application loads a lot of classes, and especially if \f3class.forName()\fP is used heavily. The recommended value is the number of classes loaded as shown in the output from \f3\-verbose:class\fP.
+.br
+Example usage: 
+.nf
+\f3
+.fl
+      java \-XX:+UnlockExperimentalVMOptions \-XX:PredictedClassLoadCount=60013
+.fl
+\fP
+.fi
+.TP 3
+\-XX:+PrintCompilation 
+Prints verbose output from the HotSpot dynamic runtime compiler.
+.br
+.TP 3
+\-XX:+PrintGCDetails \-XX:+PrintGCTimeStamps 
+Prints garbage collection output along with time stamps.
+.br
+.TP 3
+\-XX:SoftRefLRUPolicyMSPerMB=0 
+This flag enables aggressive processing of software references. Use this flag if HotSpot GC is impacted by the software reference count. 
+.TP 3
+\-XX:TLABSize=n 
+Thread local allocation buffers (TLAB) are enabled by default in HotSpot. HotSpot automatically sizes TLABs based on allocation patterns. The \f3\-XX:TLABSize\fP option allows fine\-tuning the size of TLABs.
+.br
+.TP 3
+\-XX:+UseAltSigs 
+The VM uses \f2SIGUSR1\fP and \f2SIGUSR2\fP by default, which can sometimes conflict with applications that signal\-chain \f2SIGUSR1\fP and \f2SIGUSR2\fP. The \f2\-XX:+UseAltSigs\fP option will cause the VM to use signals other than \f2SIGUSR1\fP and \f2SIGUSR2\fP as the default. 
+.TP 3
+\-XX:+|\-UseCompressedOops 
+Enables compressed references in 64\-bit JVMs.
+.br
+This option is true by default.
+.br
+.TP 3
+\-XX:+UseConcMarkSweepGC or \-XX:+UseG1GC 
+These flags enable either the Concurrent Mark Sweep (CMS) or the G1 garbage collectors.
+.br
+.TP 3
+\-XX:+|\-UseLargePages 
+Use this flag to enable large page support. Large pages are enabled by default on Solaris.
+.br
+.TP 3
+\-XX:+UseParallelOldGC 
+Enables the parallel garbage collectors, which are optimized for throughput and average response time.
+.br
+.SH "NOTES" 
 .LP
+The \f3\-version:\fP\f2release\fP command line option places no restrictions on the complexity of the release specification. However, only a restricted subset of the possible release specifications represent sound policy and only these are fully supported. These policies are: 
 .RS 3
 .TP 3
 1.
-Any version, represented by not using this option.
+Any version, represented by not using this option. 
 .TP 3
 2.
-Any version greater than an arbitrarily precise version\-id. For example:
+Any version greater than an arbitrarily precise version\-id. For example: 
 .nf
 \f3
 .fl
@@ -438,10 +512,10 @@
 .fl
 \fP
 .fi
-This would utilize any version greater than \f21.6.0_10\fP. This is useful for a case where an interface was introduced (or a bug fixed) in the release specified.
+This would utilize any version greater than \f21.6.0_10\fP. This is useful for a case where an interface was introduced (or a bug fixed) in the release specified. 
 .TP 3
 3.
-A version greater than an arbitrarily precise version\-id, bounded by the upper bound of that release family. For example:
+A version greater than an arbitrarily precise version\-id, bounded by the upper bound of that release family. For example: 
 .nf
 \f3
 .fl
@@ -451,7 +525,7 @@
 .fi
 .TP 3
 4.
-"Or" expressions of items 2. or 3. above. For example:
+"Or" expressions of items 2. or 3. above. For example: 
 .nf
 \f3
 .fl
@@ -459,59 +533,53 @@
 .fl
 \fP
 .fi
-Similar to item 2. this is useful when a change was introduced in a release (1.7) but also made available in updates to previous releases.
+Similar to item 2. this is useful when a change was introduced in a release (1.7) but also made available in updates to previous releases. 
 .RE
-
-.LP
-.SH "EXIT STATUS"
-.LP
-.LP
-The following exit values are generally returned by the launcher, typically when the launcher is called with the wrong arguments, serious errors, or exceptions thrown from the Java Virtual Machine. However, a Java application may choose to return any value using the API call \f2System.exit(exitValue)\fP.
+.SH "EXIT STATUS" 
 .LP
+The following exit values are generally returned by the launcher, typically when the launcher is called with the wrong arguments, serious errors, or exceptions thrown from the Java Virtual Machine. However, a Java application may choose to return any value using the API call \f2System.exit(exitValue)\fP. 
 .RS 3
 .TP 2
 o
-\f20\fP: Successful completion
+\f20\fP: Successful completion 
 .TP 2
 o
-\f2>0\fP: An error occurred
+\f2>0\fP: An error occurred 
 .RE
-
-.LP
-.SH "SEE ALSO"
-.LP
+.SH "SEE ALSO" 
 .RS 3
 .TP 2
 o
-javac(1)
+javac(1) 
 .TP 2
 o
-jdb(1)
+jdb(1) 
 .TP 2
 o
-javah(1)
+javah(1) 
 .TP 2
 o
-jar(1)
+jar(1) 
 .TP 2
 o
 .na
 \f2The Java Extensions Framework\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/extensions/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/index.html 
 .TP 2
 o
 .na
 \f2Security Features\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/index.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/index.html. 
 .TP 2
 o
 .na
 \f2HotSpot VM Specific Options\fP @
 .fi
-http://java.sun.com/docs/hotspot/VMOptions.html.
+http://java.sun.com/docs/hotspot/VMOptions.html. 
+.RE
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/javac.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/javac.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH javac 1 "10 May 2011"
+.TH javac 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -42,17 +42,17 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options.
+options 
+Command\-line options. 
 .TP 3
-sourcefiles
-One or more source files to be compiled (such as MyClass.java).
+sourcefiles 
+One or more source files to be compiled (such as MyClass.java). 
 .TP 3
-classes
-One or more classes to be processed for annotations (such as MyPackage.MyClass).
+classes 
+One or more classes to be processed for annotations (such as MyPackage.MyClass). 
 .TP 3
-@argfiles
-One or more files that lists options and source files. The \f2\-J\fP options are not allowed in these files.
+@argfiles 
+One or more files that lists options and source files. The \f2\-J\fP options are not allowed in these files. 
 .RE
 
 .LP
@@ -67,10 +67,10 @@
 .RS 3
 .TP 2
 o
-For a small number of source files, simply list the file names on the command line.
+For a small number of source files, simply list the file names on the command line. 
 .TP 2
 o
-For a large number of source files, list the file names in a file, separated by blanks or line breaks. Then use the list file name on the \f3javac\fP command line, preceded by an \f3@\fP character.
+For a large number of source files, list the file names in a file, separated by blanks or line breaks. Then use the list file name on the \f3javac\fP command line, preceded by an \f3@\fP character. 
 .RE
 
 .LP
@@ -91,150 +91,150 @@
 .LP
 The compiler has a set of standard options that are supported on the current development environment and will be supported in future releases. An additional set of non\-standard options are specific to the current virtual machine and compiler implementations and are subject to change in the future. Non\-standard options begin with \f3\-X\fP.
 .LP
-.SS
+.SS 
 Standard Options
 .LP
 .RS 3
 .TP 3
-\-Akey[=value]
-Options to pass to annotation processors. These are not interpreted by javac directly, but are made available for use by individual processors. \f2key\fP should be one or more identifiers separated by ".".
+\-Akey[=value] 
+Options to pass to annotation processors. These are not interpreted by javac directly, but are made available for use by individual processors. \f2key\fP should be one or more identifiers separated by ".". 
 .TP 3
-\-cp path or \-classpath path
+\-cp path or \-classpath path 
 Specify where to find user class files, and (optionally) annotation processors and source files. This class path overrides the user class path in the \f3CLASSPATH\fP environment variable. If neither \f3CLASSPATH\fP, \f3\-cp\fP nor \f3\-classpath\fP is specified, the user class path consists of the current directory. See Setting the Class Path for more details.
 .br
 .br
 >If the \f3\-sourcepath\fP option is not specified, the user class path is also searched for source files.
 .br
 .br
-If the \f3\-processorpath\fP option is not specified, the class path is also searched for annotation processors.
+If the \f3\-processorpath\fP option is not specified, the class path is also searched for annotation processors. 
 .TP 3
-\-Djava.ext.dirs=directories
-Override the location of installed extensions.
+\-Djava.ext.dirs=directories 
+Override the location of installed extensions. 
 .TP 3
-\-Djava.endorsed.dirs=directories
-Override the location of endorsed standards path.
+\-Djava.endorsed.dirs=directories 
+Override the location of endorsed standards path. 
 .TP 3
-\-d directory
+\-d directory 
 Set the destination directory for class files. The directory must already exist; \f3javac\fP will not create it. If a class is part of a package, \f3javac\fP puts the class file in a subdirectory reflecting the package name, creating directories as needed. For example, if you specify \f3\-d /home/myclasses\fP and the class is called \f2com.mypackage.MyClass\fP, then the class file is called \f2/home/myclasses/com/mypackage/MyClass.class\fP.
 .br
 .br
 If \f3\-d\fP is not specified, \f3javac\fP puts each class files in the same directory as the source file from which it was generated.
 .br
 .br
-\f3Note:\fP The directory specified by \f3\-d\fP is not automatically added to your user class path.
+\f3Note:\fP The directory specified by \f3\-d\fP is not automatically added to your user class path. 
 .TP 3
-\-deprecation
-Show a description of each use or override of a deprecated member or class. Without \f3\-deprecation\fP, \f3javac\fP shows a summary of the source files that use or override deprecated members or classes. \f3\-deprecation\fP is shorthand for \f3\-Xlint:deprecation\fP.
+\-deprecation 
+Show a description of each use or override of a deprecated member or class. Without \f3\-deprecation\fP, \f3javac\fP shows a summary of the source files that use or override deprecated members or classes. \f3\-deprecation\fP is shorthand for \f3\-Xlint:deprecation\fP. 
 .TP 3
-\-encoding encoding
-Set the source file encoding name, such as \f2EUC\-JP and UTF\-8\fP. If \f3\-encoding\fP is not specified, the platform default converter is used.
+\-encoding encoding 
+Set the source file encoding name, such as \f2EUC\-JP and UTF\-8\fP. If \f3\-encoding\fP is not specified, the platform default converter is used.  
 .TP 3
-\-endorseddirs directories
-Override the location of endorsed standards path.
+\-endorseddirs directories 
+Override the location of endorsed standards path. 
 .TP 3
-\-extdirs directories
+\-extdirs directories 
 Overrides the location of the \f2ext\fP directory. The \f2directories\fP variable is a colon\-separated list of directories. Each JAR archive in the specified directories is searched for class files. All JAR archives found are automatically part of the class path.
 .br
 .br
-If you are cross\-compiling (compiling classes against bootstrap and extension classes of a different Java platform implementation), this option specifies the directories that contain the extension classes. See Cross\-Compilation Options for more information.
+If you are cross\-compiling (compiling classes against bootstrap and extension classes of a different Java platform implementation), this option specifies the directories that contain the extension classes. See Cross\-Compilation Options for more information. 
 .TP 3
-\-g
-Generate all debugging information, including local variables. By default, only line number and source file information is generated.
+\-g 
+Generate all debugging information, including local variables. By default, only line number and source file information is generated. 
 .TP 3
-\-g:none
-Do not generate any debugging information.
+\-g:none 
+Do not generate any debugging information. 
 .TP 3
-\-g:{keyword list}
-Generate only some kinds of debugging information, specified by a comma separated list of keywords. Valid keywords are:
+\-g:{keyword list} 
+Generate only some kinds of debugging information, specified by a comma separated list of keywords. Valid keywords are: 
 .RS 3
 .TP 3
-source
-Source file debugging information
+source 
+Source file debugging information 
 .TP 3
-lines
-Line number debugging information
+lines 
+Line number debugging information 
 .TP 3
-vars
-Local variable debugging information
+vars 
+Local variable debugging information 
 .RE
 .TP 3
-\-help
-Print a synopsis of standard options.
+\-help 
+Print a synopsis of standard options. 
 .TP 3
-\-implicit:{class,none}
-Controls the generation of class files for implicitly loaded source files. To automatically generate class files, use \f3\-implicit:class\fP. To suppress class file generation, use \f3\-implicit:none\fP. If this option is not specified, the default is to automatically generate class files. In this case, the compiler will issue a warning if any such class files are generated when also doing annotation processing. The warning will not be issued if this option is set explicitly. See Searching For Types.
+\-implicit:{class,none} 
+Controls the generation of class files for implicitly loaded source files. To automatically generate class files, use \f3\-implicit:class\fP. To suppress class file generation, use \f3\-implicit:none\fP. If this option is not specified, the default is to automatically generate class files. In this case, the compiler will issue a warning if any such class files are generated when also doing annotation processing. The warning will not be issued if this option is set explicitly. See Searching For Types.  
 .TP 3
-\-Joption
+\-Joption 
 Pass \f2option\fP to the \f3java\fP launcher called by \f3javac\fP. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying VM executing applications written in Java.
 .br
 .br
-\f3Note:\fP \f3CLASSPATH\fP, \f3\-classpath\fP, \f3\-bootclasspath\fP, and \f3\-extdirs\fP do \f2not\fP specify the classes used to run \f3javac\fP. Fiddling with the implementation of the compiler in this way is usually pointless and always risky. If you do need to do this, use the \f3\-J\fP option to pass through options to the underlying \f3java\fP launcher.
+\f3Note:\fP \f3CLASSPATH\fP, \f3\-classpath\fP, \f3\-bootclasspath\fP, and \f3\-extdirs\fP do \f2not\fP specify the classes used to run \f3javac\fP. Fiddling with the implementation of the compiler in this way is usually pointless and always risky. If you do need to do this, use the \f3\-J\fP option to pass through options to the underlying \f3java\fP launcher. 
 .TP 3
-\-nowarn
-Disable warning messages. This has the same meaning as \f3\-Xlint:none\fP.
+\-nowarn 
+Disable warning messages. This has the same meaning as \f3\-Xlint:none\fP. 
 .TP 3
-\-proc: {none,only}
-Controls whether annotation processing and/or compilation is done. \f3\-proc:none\fP means that compilation takes place without annotation processing. \f3\-proc:only\fP means that only annotation processing is done, without any subsequent compilation.
+\-proc: {none,only} 
+Controls whether annotation processing and/or compilation is done. \f3\-proc:none\fP means that compilation takes place without annotation processing. \f3\-proc:only\fP means that only annotation processing is done, without any subsequent compilation. 
 .TP 3
-\-processor class1[,class2,class3...]
-Names of the annotation processors to run. This bypasses the default discovery process.
+\-processor class1[,class2,class3...] 
+Names of the annotation processors to run. This bypasses the default discovery process. 
 .TP 3
-\-processorpath path
-Specify where to find annotation processors; if this option is not used, the class path will be searched for processors.
+\-processorpath path 
+Specify where to find annotation processors; if this option is not used, the class path will be searched for processors. 
 .TP 3
-\-s dir
-Specify the directory where to place generated source files. The directory must already exist; \f3javac\fP will not create it. If a class is part of a package, the compiler puts the source file in a subdirectory reflecting the package name, creating directories as needed. For example, if you specify \f3\-s /home/mysrc\fP and the class is called \f2com.mypackage.MyClass\fP, then the source file will be placed in \f2/home/mysrc/com/mypackage/MyClass.java\fP.
+\-s dir 
+Specify the directory where to place generated source files. The directory must already exist; \f3javac\fP will not create it. If a class is part of a package, the compiler puts the source file in a subdirectory reflecting the package name, creating directories as needed. For example, if you specify \f3\-s /home/mysrc\fP and the class is called \f2com.mypackage.MyClass\fP, then the source file will be placed in \f2/home/mysrc/com/mypackage/MyClass.java\fP. 
 .TP 3
-\-source release
-Specifies the version of source code accepted. The following values for \f2release\fP are allowed:
+\-source release 
+Specifies the version of source code accepted. The following values for \f2release\fP are allowed: 
 .RS 3
 .TP 3
-1.3
-The compiler does \f2not\fP support assertions, generics, or other language features introduced after JDK 1.3.
+1.3 
+The compiler does \f2not\fP support assertions, generics, or other language features introduced after Java SE 1.3. 
 .TP 3
-1.4
-The compiler accepts code containing assertions, which were introduced in JDK 1.4.
+1.4 
+The compiler accepts code containing assertions, which were introduced in Java SE 1.4. 
 .TP 3
-1.5
-The compiler accepts code containing generics and other language features introduced in JDK 5.
+1.5 
+The compiler accepts code containing generics and other language features introduced in Java SE 5. 
 .TP 3
-5
-Synonym for 1.5.
+5 
+Synonym for 1.5. 
 .TP 3
-1.6
-This is the default value. No language changes were introduced in Java SE 6. However, encoding errors in source files are now reported as errors, instead of warnings, as previously.
+1.6 
+No language changes were introduced in Java SE 6. However, encoding errors in source files are now reported as errors instead of warnings as in previous releases of Java SE. 
 .TP 3
-6
-Synonym for 1.6.
+6 
+Synonym for 1.6. 
 .TP 3
-1.7
-The compiler accepts code with features introduced in JDK 7.
+1.7 
+This is the default value. The compiler accepts code with features introduced in Java SE 7. 
 .TP 3
-7
-Synonym for 1.7.
+7 
+Synonym for 1.7. 
 .RE
 .TP 3
-\-sourcepath sourcepath
+\-sourcepath sourcepath 
 Specify the source code path to search for class or interface definitions. As with the user class path, source path entries are separated by colons (\f3:\fP) and can be directories, JAR archives, or ZIP archives. If packages are used, the local path name within the directory or archive must reflect the package name.
 .br
 .br
-\f3Note:\fP Classes found through the class path may be subject to automatic recompilation if their sources are also found. See Searching For Types.
+\f3Note:\fP Classes found through the class path may be subject to automatic recompilation if their sources are also found. See Searching For Types. 
 .TP 3
-\-verbose
-Verbose output. This includes information about each class loaded and each source file compiled.
+\-verbose 
+Verbose output. This includes information about each class loaded and each source file compiled. 
 .TP 3
-\-version
-Print version information.
+\-version 
+Print version information.  
 .TP 3
-\-Werror
-Terminate compilation if warnings occur.
+\-Werror 
+Terminate compilation if warnings occur. 
 .TP 3
-\-X
-Display information about non\-standard options and exit.
+\-X 
+Display information about non\-standard options and exit. 
 .RE
 
 .LP
-.SS
+.SS 
 Cross\-Compilation Options
 .LP
 .LP
@@ -242,87 +242,92 @@
 .LP
 .RS 3
 .TP 3
-\-target version
-Generate class files that target a specified version of the VM. Class files will run on the specified target and on later versions, but not on earlier versions of the VM. Valid targets are \f31.1\fP \f31.2\fP \f31.3\fP \f31.4\fP \f31.5\fP (also \f35\fP) \f31.6\fP (also \f36\fP) and \f31.7\fP (also \f37\fP).
-.br
-.br
-The default for \f3\-target\fP depends on the value of \f3\-source\fP:
+\-target version 
+Generate class files that target a specified version of the VM. Class files will run on the specified target and on later versions, but not on earlier versions of the VM. Valid targets are \f31.1\fP, \f31.2\fP, \f31.3\fP, \f31.4\fP, \f31.5\fP (also \f35\fP), \f31.6\fP (also \f36\fP), and \f31.7\fP (also \f37\fP). 
+.LP
+The default for \f3\-target\fP depends on the value of \f3\-source\fP: 
 .RS 3
 .TP 2
 o
-If \-source is \f3not specified\fP, the value of \-target is \f31.7\fP
+If \-source is \f3not specified\fP, the value of \-target is \f31.7\fP 
+.TP 2
+o
+If \-source is \f31.2\fP, the value of \-target is \f31.4\fP 
 .TP 2
 o
-If \-source is \f31.2\fP, the value of \-target is \f31.4\fP
+If \-source is \f31.3\fP, the value of \-target is \f31.4\fP 
 .TP 2
 o
-If \-source is \f31.3\fP, the value of \-target is \f31.4\fP
+If \-source is \f31.5\fP, the value of \-target is \f31.7\fP 
 .TP 2
 o
-For \f3all other values\fP of \-source, the value of \f3\-target\fP is the value of \f3\-source\fP.
+If \-source is \f31.6\fP, the value of \-target is \f31.7\fP 
+.TP 2
+o
+For \f3all other values\fP of \-source, the value of \f3\-target\fP is the value of \f3\-source\fP. 
 .RE
 .TP 3
-\-bootclasspath bootclasspath
-Cross\-compile against the specified set of boot classes. As with the user class path, boot class path entries are separated by colons (\f3:\fP) and can be directories, JAR archives, or ZIP archives.
+\-bootclasspath bootclasspath 
+Cross\-compile against the specified set of boot classes. As with the user class path, boot class path entries are separated by colons (\f3:\fP) and can be directories, JAR archives, or ZIP archives. 
 .RE
 
 .LP
-.SS
+.SS 
 Non\-Standard Options
 .LP
 .RS 3
 .TP 3
-\-Xbootclasspath/p:path
-Prepend to the bootstrap class path.
+\-Xbootclasspath/p:path 
+Prepend to the bootstrap class path. 
 .TP 3
-\-Xbootclasspath/a:path
-Append to the bootstrap class path.
+\-Xbootclasspath/a:path 
+Append to the bootstrap class path. 
 .TP 3
-\-Xbootclasspath/:path
-Override location of bootstrap class files.
+\-Xbootclasspath/:path 
+Override location of bootstrap class files. 
 .TP 3
-\-Xlint
-Enable all recommended warnings. In this release, enabling all available warnings is recommended.
+\-Xlint 
+Enable all recommended warnings. In this release, enabling all available warnings is recommended. 
 .TP 3
-\-Xlint:all
-Enable all recommended warnings. In this release, enabling all available warnings is recommended.
+\-Xlint:all 
+Enable all recommended warnings. In this release, enabling all available warnings is recommended. 
 .TP 3
-\-Xlint:none
-Disable all warnings.
+\-Xlint:none 
+Disable all warnings. 
 .TP 3
-\-Xlint:name
-Enable warning \f2name\fP. See the section Warnings That Can Be Enabled or Disabled with \-Xlint Option for a list of warnings you can enable with this option.
+\-Xlint:name 
+Enable warning \f2name\fP. See the section Warnings That Can Be Enabled or Disabled with \-Xlint Option for a list of warnings you can enable with this option. 
 .TP 3
-\-Xlint:\-name
-Disable warning \f2name\fP. See the section Warnings That Can Be Enabled or Disabled with \-Xlint Option for a list of warnings you can disable with this option.
+\-Xlint:\-name 
+Disable warning \f2name\fP. See the section Warnings That Can Be Enabled or Disabled with \-Xlint Option for a list of warnings you can disable with this option. 
 .TP 3
-\-Xmaxerrs number
-Set the maximum number of errors to print.
+\-Xmaxerrs number 
+Set the maximum number of errors to print. 
 .TP 3
-\-Xmaxwarns number
-Set the maximum number of warnings to print.
+\-Xmaxwarns number 
+Set the maximum number of warnings to print. 
 .TP 3
-\-Xstdout filename
-Send compiler messages to the named file. By default, compiler messages go to \f2System.err\fP.
+\-Xstdout filename 
+Send compiler messages to the named file. By default, compiler messages go to \f2System.err\fP. 
 .TP 3
-\-Xprefer:{newer,source}
-Specify which file to read when both a source file and class file are found for a type. (See Searching For Types). If \f2\-Xprefer:newer\fP is used, it reads the newer of the source or class file for a type (default). If the \f2\-Xprefer:source\fP option is used, it reads source file. Use \f2\-Xprefer:source\fP when you want to be sure that any annotation processors can access annotations declared with a retention policy of \f2SOURCE\fP.
+\-Xprefer:{newer,source} 
+Specify which file to read when both a source file and class file are found for a type. (See Searching For Types). If \f2\-Xprefer:newer\fP is used, it reads the newer of the source or class file for a type (default). If the \f2\-Xprefer:source\fP option is used, it reads source file. Use \f2\-Xprefer:source\fP when you want to be sure that any annotation processors can access annotations declared with a retention policy of \f2SOURCE\fP.  
 .TP 3
-\-Xpkginfo:{always,legacy,nonempty}
-Specify handling of package\-info files
+\-Xpkginfo:{always,legacy,nonempty} 
+Specify handling of package\-info files 
 .TP 3
-\-Xprint
-Print out textual representation of specified types for debugging purposes; perform neither annotation processing nor compilation. The format of the output may change.
+\-Xprint 
+Print out textual representation of specified types for debugging purposes; perform neither annotation processing nor compilation. The format of the output may change. 
 .TP 3
-\-XprintProcessorInfo
-Print information about which annotations a processor is asked to process.
+\-XprintProcessorInfo 
+Print information about which annotations a processor is asked to process. 
 .TP 3
-\-XprintRounds
-Print information about initial and subsequent annotation processing rounds.
+\-XprintRounds 
+Print information about initial and subsequent annotation processing rounds. 
 .RE
 
 .LP
-.SS
+.SS 
 Warnings That Can Be Enabled or Disabled with \-Xlint Option
 .LP
 .LP
@@ -330,8 +335,8 @@
 .LP
 .RS 3
 .TP 3
-cast
-Warn about unnecessary and redundant casts. For example:
+cast 
+Warn about unnecessary and redundant casts. For example: 
 .nf
 \f3
 .fl
@@ -340,11 +345,11 @@
 \fP
 .fi
 .TP 3
-classfile
-Warn about issues related to classfile contents.
+classfile 
+Warn about issues related to classfile contents. 
 .TP 3
-deprecation
-Warn about use of deprecated items. For example:
+deprecation 
+Warn about use of deprecated items. For example: 
 .nf
 \f3
 .fl
@@ -354,10 +359,10 @@
 .fl
 \fP
 .fi
-The method \f2java.util.Date.getDay\fP has been deprecated since JDK 1.1.
+The method \f2java.util.Date.getDay\fP has been deprecated since JDK 1.1. 
 .TP 3
-dep\-ann
-Warn about items that are documented with an \f2@deprecated\fP Javadoc comment, but do not have a \f2@Deprecated\fP annotation. For example:
+dep\-ann 
+Warn about items that are documented with an \f2@deprecated\fP Javadoc comment, but do not have a \f2@Deprecated\fP annotation. For example: 
 .nf
 \f3
 .fl
@@ -378,8 +383,8 @@
 \fP
 .fi
 .TP 3
-divzero
-Warn about division by constant integer 0. For example:
+divzero 
+Warn about division by constant integer 0. For example: 
 .nf
 \f3
 .fl
@@ -388,8 +393,8 @@
 \fP
 .fi
 .TP 3
-empty
-Warn about empty statements after \f2if\fP statements. For example:
+empty 
+Warn about empty statements after \f2if\fP statements. For example: 
 .nf
 \f3
 .fl
@@ -406,8 +411,8 @@
 \fP
 .fi
 .TP 3
-fallthrough
-Check \f2switch\fP blocks for fall\-through cases and provide a warning message for any that are found. Fall\-through cases are cases in a \f2switch\fP block, other than the last case in the block, whose code does not include a \f2break\fP statement, allowing code execution to "fall through" from that case to the next case. For example, the code following the \f2case 1\fP label in this \f2switch\fP block does not end with a \f2break\fP statement:
+fallthrough 
+Check \f2switch\fP blocks for fall\-through cases and provide a warning message for any that are found. Fall\-through cases are cases in a \f2switch\fP block, other than the last case in the block, whose code does not include a \f2break\fP statement, allowing code execution to "fall through" from that case to the next case. For example, the code following the \f2case 1\fP label in this \f2switch\fP block does not end with a \f2break\fP statement: 
 .nf
 \f3
 .fl
@@ -427,10 +432,10 @@
 .fl
 \fP
 .fi
-If the \f2\-Xlint:fallthrough\fP flag were used when compiling this code, the compiler would emit a warning about "possible fall\-through into case," along with the line number of the case in question.
+If the \f2\-Xlint:fallthrough\fP flag were used when compiling this code, the compiler would emit a warning about "possible fall\-through into case," along with the line number of the case in question. 
 .TP 3
-finally
-Warn about \f2finally\fP clauses that cannot complete normally. For example:
+finally 
+Warn about \f2finally\fP clauses that cannot complete normally. For example: 
 .nf
 \f3
 .fl
@@ -456,13 +461,13 @@
 .fl
 \fP
 .fi
-The compiler generates a warning for \f2finally\fP block in this example. When this method is called, it returns a value of \f20\fP, not \f21\fP. A \f2finally\fP block always executes when the \f2try\fP block exits. In this example, if control is transferred to the \f2catch\fP, then the method exits. However, the \f2finally\fP block must be executed, so it is executed, even though control has already been transferred outside the method.
+The compiler generates a warning for \f2finally\fP block in this example. When this method is called, it returns a value of \f20\fP, not \f21\fP. A \f2finally\fP block always executes when the \f2try\fP block exits. In this example, if control is transferred to the \f2catch\fP, then the method exits. However, the \f2finally\fP block must be executed, so it is executed, even though control has already been transferred outside the method. 
 .TP 3
-options
-Warn about issues relating to the use of command line options. See Cross\-Compilation Example for an example of this kind of warning.
+options 
+Warn about issues relating to the use of command line options. See Cross\-Compilation Example for an example of this kind of warning. 
 .TP 3
-overrides
-Warn about issues regarding method overrides. For example, consider the following two classes:
+overrides 
+Warn about issues regarding method overrides. For example, consider the following two classes: 
 .nf
 \f3
 .fl
@@ -493,10 +498,10 @@
 \f2warning: [override] varargsMethod(String[]) in ClassWithOverridingMethod overrides varargsMethod(String...) in ClassWithVarargsMethod; overriding method is missing '...'\fP
 .br
 .br
-When the compiler encounters a varargs method, it translates the varargs formal parameter into an array. In the method \f2ClassWithVarargsMethod.varargsMethod\fP, the compiler translates the varargs formal parameter \f2String... s\fP to the formal parameter \f2String[] s\fP, an array, which matches the formal parameter of the method \f2ClassWithOverridingMethod.varargsMethod\fP. Consequently, this example compiles.
+When the compiler encounters a varargs method, it translates the varargs formal parameter into an array. In the method \f2ClassWithVarargsMethod.varargsMethod\fP, the compiler translates the varargs formal parameter \f2String... s\fP to the formal parameter \f2String[] s\fP, an array, which matches the formal parameter of the method \f2ClassWithOverridingMethod.varargsMethod\fP. Consequently, this example compiles. 
 .TP 3
-path
-Warn about invalid path elements and nonexistent path directories on the command line (with regards to the class path, the source path, and other paths). Such warnings cannot be suppressed with the \f2@SuppressWarnings\fP annotation. For example:
+path 
+Warn about invalid path elements and nonexistent path directories on the command line (with regards to the class path, the source path, and other paths). Such warnings cannot be suppressed with the \f2@SuppressWarnings\fP annotation. For example: 
 .nf
 \f3
 .fl
@@ -505,11 +510,11 @@
 \fP
 .fi
 .TP 3
-processing
+processing 
 Warn about issues regarding annotation processing. The compiler generates this warning if you have a class that has an annotation, and you use an annotation processor that cannot handle that type of exception. For example, the following is a simple annotation processor:
 .br
 .br
-\f3Source file \fP\f4AnnoProc.java\fP:
+\f3Source file \fP\f4AnnoProc.java\fP: 
 .nf
 \f3
 .fl
@@ -545,7 +550,7 @@
 .fl
 \fP
 .fi
-\f3Source file \fP\f4AnnosWithoutProcessors.java\fP\f3:\fP
+\f3Source file \fP\f4AnnosWithoutProcessors.java\fP\f3:\fP 
 .nf
 \f3
 .fl
@@ -559,15 +564,14 @@
 .fl
 \fP
 .fi
-The following commands compile the annotation processor \f2AnnoProc\fP, then run this annotation processor against the source file \f2AnnosWithoutProcessors.java\fP:
+The following commands compile the annotation processor \f2AnnoProc\fP, then run this annotation processor against the source file \f2AnnosWithoutProcessors.java\fP: 
 .nf
 \f3
 .fl
-% javac AnnoProc.java
+% \fP\f3javac AnnoProc.java\fP
 .fl
-% javac \-cp . \-Xlint:processing \-processor AnnoProc \-proc:only AnnosWithoutProcessors.java
+% \f3javac \-cp . \-Xlint:processing \-processor AnnoProc \-proc:only AnnosWithoutProcessors.java\fP
 .fl
-\fP
 .fi
 When the compiler runs the annotation processor against the source file \f2AnnosWithoutProcessors.java\fP, it generates the following warning:
 .br
@@ -575,10 +579,10 @@
 \f2warning: [processing] No processor claimed any of these annotations: Anno\fP
 .br
 .br
-To resolve this issue, you can rename the annotation defined and used in the class \f2AnnosWithoutProcessors\fP from \f2Anno\fP to \f2NotAnno\fP.
+To resolve this issue, you can rename the annotation defined and used in the class \f2AnnosWithoutProcessors\fP from \f2Anno\fP to \f2NotAnno\fP. 
 .TP 3
-rawtypes
-Warn about unchecked operations on raw types. The following statement generates a \f2rawtypes\fP warning:
+rawtypes 
+Warn about unchecked operations on raw types. The following statement generates a \f2rawtypes\fP warning: 
 .nf
 \f3
 .fl
@@ -586,7 +590,7 @@
 .fl
 \fP
 .fi
-The following does not generate a \f2rawtypes\fP warning:
+The following does not generate a \f2rawtypes\fP warning: 
 .nf
 \f3
 .fl
@@ -594,10 +598,10 @@
 .fl
 \fP
 .fi
-\f2List\fP is a raw type. However, \f2List<?>\fP is a unbounded wildcard parameterized type. Because \f2List\fP is a parameterized interface, you should always specify its type argument. In this example, the \f2List\fP formal argument is specified with a unbounded wildcard (\f2?\fP) as its formal type parameter, which means that the \f2countElements\fP method can accept any instantiation of the \f2List\fP interface.
+\f2List\fP is a raw type. However, \f2List<?>\fP is a unbounded wildcard parameterized type. Because \f2List\fP is a parameterized interface, you should always specify its type argument. In this example, the \f2List\fP formal argument is specified with a unbounded wildcard (\f2?\fP) as its formal type parameter, which means that the \f2countElements\fP method can accept any instantiation of the \f2List\fP interface. 
 .TP 3
-serial
-Warn about missing \f2serialVersionUID\fP definitions on serializable classes. For example:
+serial 
+Warn about missing \f2serialVersionUID\fP definitions on serializable classes. For example: 
 .nf
 \f3
 .fl
@@ -633,10 +637,10 @@
 \f2warning: [serial] serializable class PersistentTime has no definition of serialVersionUID\fP
 .br
 .br
-If a serializable class does not explicitly declare a field named \f2serialVersionUID\fP, then the serialization runtime will calculate a default \f2serialVersionUID\fP value for that class based on various aspects of the class, as described in the Java Object Serialization Specification. However, it is strongly recommended that all serializable classes explicitly declare \f2serialVersionUID\fP values because the default process of computing \f2serialVersionUID\fP vales is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected \f2InvalidClassExceptions\fP during deserialization. Therefore, to guarantee a consistent \f2serialVersionUID\fP value across different Java compiler implementations, a serializable class must declare an explicit \f2serialVersionUID\fP value.
+If a serializable class does not explicitly declare a field named \f2serialVersionUID\fP, then the serialization runtime will calculate a default \f2serialVersionUID\fP value for that class based on various aspects of the class, as described in the Java Object Serialization Specification. However, it is strongly recommended that all serializable classes explicitly declare \f2serialVersionUID\fP values because the default process of computing \f2serialVersionUID\fP vales is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected \f2InvalidClassExceptions\fP during deserialization. Therefore, to guarantee a consistent \f2serialVersionUID\fP value across different Java compiler implementations, a serializable class must declare an explicit \f2serialVersionUID\fP value. 
 .TP 3
-static
-Warn about issues relating to use of statics. For example:
+static 
+Warn about issues relating to use of statics. For example: 
 .nf
 \f3
 .fl
@@ -650,7 +654,7 @@
 .fl
 \fP
 .fi
-The compiler generates the following warning:
+The compiler generates the following warning: 
 .nf
 \f3
 .fl
@@ -658,7 +662,7 @@
 .fl
 \fP
 .fi
-To resolve this issue, you can call the static method \f2m1\fP as follows:
+To resolve this issue, you can call the static method \f2m1\fP as follows: 
 .nf
 \f3
 .fl
@@ -666,10 +670,10 @@
 .fl
 \fP
 .fi
-Alternatively, you can remove the \f2static\fP keyword from the declaration of the method \f2m1\fP.
+Alternatively, you can remove the \f2static\fP keyword from the declaration of the method \f2m1\fP. 
 .TP 3
-try
-Warn about issues relating to use of \f2try\fP blocks, including try\-with\-resources statements. For example, a warning is generated for the following statement because the resource \f2ac\fP declared in the \f2try\fP statement is not used:
+try 
+Warn about issues relating to use of \f2try\fP blocks, including try\-with\-resources statements. For example, a warning is generated for the following statement because the resource \f2ac\fP declared in the \f2try\fP statement is not used: 
 .nf
 \f3
 .fl
@@ -682,8 +686,8 @@
 \fP
 .fi
 .TP 3
-unchecked
-Give more detail for unchecked conversion warnings that are mandated by the Java Language Specification. For example:
+unchecked 
+Give more detail for unchecked conversion warnings that are mandated by the Java Language Specification. For example: 
 .nf
 \f3
 .fl
@@ -699,10 +703,10 @@
 The variable \f2ls\fP has the parameterized type \f2List<String>\fP. When the \f2List\fP referenced by \f2l\fP is assigned to \f2ls\fP, the compiler generates an unchecked warning; the compiler is unable to determine at compile time, and moreover knows that the JVM will not be able to determine at runtime, if \f2l\fP refers to a \f2List<String>\fP type; it does not. Consequently, heap pollution occurs.
 .br
 .br
-In detail, a heap pollution situation occurs when the \f2List\fP object \f2l\fP, whose static type is \f2List<Number>\fP, is assigned to another \f2List\fP object, \f2ls\fP, that has a different static type, \f2List<String>\fP. However, the compiler still allows this assignment. It must allow this assignment to preserve backwards compatibility with versions of Java SE that do not support generics. Because of type erasure, \f2List<Number>\fP and \f2List<String>\fP both become \f2List\fP. Consequently, the compiler allows the assignment of the object \f2l\fP, which has a raw type of \f2List\fP, to the object \f2ls\fP.
+In detail, a heap pollution situation occurs when the \f2List\fP object \f2l\fP, whose static type is \f2List<Number>\fP, is assigned to another \f2List\fP object, \f2ls\fP, that has a different static type, \f2List<String>\fP. However, the compiler still allows this assignment. It must allow this assignment to preserve backwards compatibility with versions of Java SE that do not support generics. Because of type erasure, \f2List<Number>\fP and \f2List<String>\fP both become \f2List\fP. Consequently, the compiler allows the assignment of the object \f2l\fP, which has a raw type of \f2List\fP, to the object \f2ls\fP. 
 .TP 3
-varargs
-Warn about unsafe usages of variable arguments (varargs) methods, in particular, those that contain non\-reifiable arguments. For example:
+varargs 
+Warn about unsafe usages of variable arguments (varargs) methods, in particular, those that contain non\-reifiable arguments. For example: 
 .nf
 \f3
 .fl
@@ -722,7 +726,7 @@
 .fl
 \fP
 .fi
-The compiler generates the following warning for the definition of the method \f2ArrayBuilder.addToList\fP:
+The compiler generates the following warning for the definition of the method \f2ArrayBuilder.addToList\fP: 
 .nf
 \f3
 .fl
@@ -730,7 +734,7 @@
 .fl
 \fP
 .fi
-When the compiler encounters a varargs method, it translates the varargs formal parameter into an array. However, the Java programming language does not permit the creation of arrays of parameterized types. In the method \f2ArrayBuilder.addToList\fP, the compiler translates the varargs formal parameter \f2T... elements\fP to the formal parameter \f2T[] elements\fP, an array. However, because of type erasure, the compiler converts the varargs formal parameter to \f2Object[] elements\fP. Consequently, there is a possibility of heap pollution.
+When the compiler encounters a varargs method, it translates the varargs formal parameter into an array. However, the Java programming language does not permit the creation of arrays of parameterized types. In the method \f2ArrayBuilder.addToList\fP, the compiler translates the varargs formal parameter \f2T... elements\fP to the formal parameter \f2T[] elements\fP, an array. However, because of type erasure, the compiler converts the varargs formal parameter to \f2Object[] elements\fP. Consequently, there is a possibility of heap pollution. 
 .RE
 
 .LP
@@ -748,7 +752,7 @@
 .LP
 When executing javac, pass in the path and name of each argument file with the '\f2@\fP' leading character. When javac encounters an argument beginning with the character `\f2@\fP', it expands the contents of that file into the argument list.
 .LP
-.SS
+.SS 
 Example \- Single Arg File
 .LP
 .LP
@@ -765,7 +769,7 @@
 .LP
 This argument file could contain the contents of both files shown in the next example.
 .LP
-.SS
+.SS 
 Example \- Two Arg Files
 .LP
 .LP
@@ -820,7 +824,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Example \- Arg Files with Paths
 .LP
 .LP
@@ -842,7 +846,7 @@
 .LP
 The API for annotation processors is defined in the \f2javax.annotation.processing\fP and \f2javax.lang.model\fP packages and subpackages.
 .LP
-.SS
+.SS 
 Overview of annotation processing
 .LP
 .LP
@@ -857,7 +861,7 @@
 .LP
 After a round occurs where no new source files are generated, the annotation processors will be invoked one last time, to give them a chance to complete any work they may need to do. Finally, unless the \f3\-proc:only\fP option is used, the compiler will compile the original and all the generated source files.
 .LP
-.SS
+.SS 
 Implicitly loaded source files
 .LP
 .LP
@@ -894,7 +898,7 @@
 .LP
 \f3javac\fP supports the new Java Compiler API defined by the classes and interfaces in the \f2javax.tools\fP package.
 .LP
-.SS
+.SS 
 Example
 .LP
 .LP
@@ -917,7 +921,7 @@
 .LP
 You can use other methods on the \f2javax.tools.JavaCompiler\fP interface to handle diagnostics, control where files are read from and written to, and so on.
 .LP
-.SS
+.SS 
 Old Interface
 .LP
 .LP
@@ -951,7 +955,7 @@
 .LP
 .SH "EXAMPLES"
 .LP
-.SS
+.SS 
 Compiling a Simple Program
 .LP
 .LP
@@ -1005,7 +1009,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Compiling Multiple Source Files
 .LP
 .LP
@@ -1033,7 +1037,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Specifying a User Class Path
 .LP
 .LP
@@ -1068,7 +1072,7 @@
 .nf
 \f3
 .fl
-% \fP\f3javac \-classpath /examples:/lib/Banners.jar \\
+% \fP\f3javac \-classpath /examples:/lib/Banners.jar \\ 
 .fl
             /examples/greetings/Hi.java\fP
 .fl
@@ -1086,7 +1090,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Separating Source Files and Class Files
 .LP
 .LP
@@ -1113,7 +1117,7 @@
 .fl
 % \f3ls classes\fP
 .fl
-% \f3javac \-sourcepath src \-classpath classes:lib/Banners.jar \\
+% \f3javac \-sourcepath src \-classpath classes:lib/Banners.jar \\ 
 .fl
             src/farewells/GoodBye.java \-d classes\fP
 .fl
@@ -1131,16 +1135,16 @@
 .LP
 \f3Note:\fP The compiler compiled \f2src/farewells/Base.java\fP, even though we didn't specify it on the command line. To trace automatic compiles, use the \f3\-verbose\fP option.
 .LP
-.SS
+.SS 
 Cross\-Compilation Example
 .LP
 .LP
-Here we use \f3javac\fP to compile code that will run on a 1.6 VM.
+The following example uses \f3javac\fP to compile code that will run on a 1.6 VM.
 .LP
 .nf
 \f3
 .fl
-% \fP\f3javac \-source 1.6 \-target 1.6 \-bootclasspath jdk1.6.0/lib/rt.jar \\
+% \fP\f3javac \-source 1.6 \-target 1.6 \-bootclasspath jdk1.6.0/lib/rt.jar \\ 
 .fl
             \-extdirs "" OldCode.java\fP
 .fl
@@ -1174,32 +1178,32 @@
 .na
 \f2The javac Guide\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javac/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/javac/index.html 
 .TP 2
 o
-java(1) \- the Java Application Launcher
+java(1) \- the Java Application Launcher 
 .TP 2
 o
-jdb(1) \- Java Application Debugger
+jdb(1) \- Java Application Debugger 
 .TP 2
 o
-javah(1) \- C Header and Stub File Generator
+javah(1) \- C Header and Stub File Generator 
 .TP 2
 o
-javap(1) \- Class File Disassembler
+javap(1) \- Class File Disassembler 
 .TP 2
 o
-javadoc(1) \- API Documentation Generator
+javadoc(1) \- API Documentation Generator 
 .TP 2
 o
-jar(1) \- JAR Archive Tool
+jar(1) \- JAR Archive Tool 
 .TP 2
 o
 .na
 \f2The Java Extensions Framework\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/extensions/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/index.html 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/javadoc.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/javadoc.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH javadoc 1 "10 May 2011"
+.TH javadoc 1 "16 Mar 2012"
 .SH "Name"
 javadoc \- The Java API Documentation Generator
 .LP
@@ -31,68 +31,68 @@
 Arguments can be in any order. See processing of Source Files for details on how the Javadoc tool determines which "\f2.java\fP" files to process.
 .RS 3
 .TP 3
-options
-Command\-line options, as specified in this document. To see a typical use of javadoc options, see Real\-World Example.
+options 
+Command\-line options, as specified in this document. To see a typical use of javadoc options, see Real\-World Example. 
 .TP 3
-packagenames
-A series of names of packages, separated by spaces, such as \f2java.lang\ java.lang.reflect\ java.awt\fP. You must separately specify each package you want to document. Wildcards are not allowed; use \-subpackages for recursion. The Javadoc tool uses \f2\-sourcepath\fP to look for these package names. See Example \- Documenting One or More Packages
+packagenames 
+A series of names of packages, separated by spaces, such as \f2java.lang\ java.lang.reflect\ java.awt\fP. You must separately specify each package you want to document. Wildcards are not allowed; use \-subpackages for recursion. The Javadoc tool uses \f2\-sourcepath\fP to look for these package names. See Example \- Documenting One or More Packages 
 .TP 3
-sourcefilenames
-A series of source file names, separated by spaces, each of which can begin with a path and contain a wildcard such as asterisk (*). The Javadoc tool will process every file whose name ends with ".java", and whose name, when stripped of that suffix, is actually a legal class name (see the Java Language Specification). Therefore, you can name files with dashes (such as \f2X\-Buffer\fP), or other illegal characters, to prevent them from being documented. This is useful for test files and template files The path that precedes the source file name determines where javadoc will look for the file. (The Javadoc tool does \f2not\fP use \f2\-sourcepath\fP to look for these source file names.) Relative paths are relative to the current directory, so passing in \f2Button.java\fP is identical to \f2./Button.java\fP. A source file name with an absolute path and a wildcard, for example, is \f2/home/src/java/awt/Graphics*.java\fP. See Example\ \-\ Documenting One or More Classes. You can also mix packagenames and sourcefilenames, as in Example\ \-\ Documenting Both Packages and Classes
+sourcefilenames 
+A series of source file names, separated by spaces, each of which can begin with a path and contain a wildcard such as asterisk (*). The Javadoc tool will process every file whose name ends with ".java", and whose name, when stripped of that suffix, is actually a legal class name (see the Java Language Specification). Therefore, you can name files with dashes (such as \f2X\-Buffer\fP), or other illegal characters, to prevent them from being documented. This is useful for test files and template files The path that precedes the source file name determines where javadoc will look for the file. (The Javadoc tool does \f2not\fP use \f2\-sourcepath\fP to look for these source file names.) Relative paths are relative to the current directory, so passing in \f2Button.java\fP is identical to \f2./Button.java\fP. A source file name with an absolute path and a wildcard, for example, is \f2/home/src/java/awt/Graphics*.java\fP. See Example\ \-\ Documenting One or More Classes. You can also mix packagenames and sourcefilenames, as in Example\ \-\ Documenting Both Packages and Classes 
 .TP 3
-\-subpackages pkg1:pkg2:...
-Generates documentation from source files in the specified packages and recursively in their subpackages. An alternative to supplying packagenames or sourcefilenames.
+\-subpackages pkg1:pkg2:... 
+Generates documentation from source files in the specified packages and recursively in their subpackages. An alternative to supplying packagenames or sourcefilenames. 
 .TP 3
-@argfiles
-One or more files that contain a list of Javadoc options, packagenames and sourcefilenames in any order. Wildcards (*) and \f2\-J\fP options are not allowed in these files.
+@argfiles 
+One or more files that contain a list of Javadoc options, packagenames and sourcefilenames in any order. Wildcards (*) and \f2\-J\fP options are not allowed in these files.  
 .RE
 .SH "DESCRIPTION"
 .LP
 The \f3Javadoc\fP tool parses the declarations and documentation comments in a set of Java source files and produces a corresponding set of HTML pages describing (by default) the public and protected classes, nested classes (but not anonymous inner classes), interfaces, constructors, methods, and fields. You can use it to generate the API (Application Programming Interface) documentation or the implementation documentation for a set of source files.
 .LP
 You can run the Javadoc tool on entire packages, individual source files, or both. When documenting entire packages, you can either use \f2\-subpackages\fP for traversing recursively down from a top\-level directory, or pass in an explicit list of package names. When documenting individual source files, you pass in a list of source (\f2.java\fP) filenames. Examples are given at the end of this document. How Javadoc processes source files is covered next.
-.SS
+.SS 
 Processing of source files
 .LP
 The Javadoc tool processes files that end in "\f2.java\fP" plus other files described under Source Files. If you run the Javadoc tool by explicitly passing in individual source filenames, you can determine exactly which "\f2.java\fP" files are processed. However, that is not how most developers want to work, as it is simpler to pass in package names. The Javadoc tool can be run three ways without explicitly specifying the source filenames. You can (1) pass in package names, (2) use \f2\-subpackages\fP, and (3) use wildcards with source filenames (\f2*.java\fP). In these cases, the Javadoc tool processes a "\f2.java\fP" file only if it fulfills all of the following requirements:
 .RS 3
 .TP 2
 o
-Its name, after stripping off the "\f2.java\fP" suffix, is actually a legal class name (see the Java Language Specification for legal characters)
+Its name, after stripping off the "\f2.java\fP" suffix, is actually a legal class name (see the Java Language Specification for legal characters) 
 .TP 2
 o
-Its directory path relative to the root of the source tree is actually a legal package name (after converting its separators to dots)
+Its directory path relative to the root of the source tree is actually a legal package name (after converting its separators to dots) 
 .TP 2
 o
-Its package statement contains the legal package name (specified in the previous bullet)
+Its package statement contains the legal package name (specified in the previous bullet) 
 .RE
 .LP
 \f3Processing of links\fP \- During a run, the Javadoc tool automatically adds cross\-reference links to package, class and member names that are being documented as part of that run. Links appear in several places:
 .RS 3
 .TP 2
 o
-Declarations (return types, argument types, field types)
+Declarations (return types, argument types, field types) 
 .TP 2
 o
-"See Also" sections generated from \f2@see\fP tags
+"See Also" sections generated from \f2@see\fP tags 
 .TP 2
 o
-In\-line text generated from \f2{@link}\fP tags
+In\-line text generated from \f2{@link}\fP tags 
 .TP 2
 o
-Exception names generated from \f2@throws\fP tags
+Exception names generated from \f2@throws\fP tags 
 .TP 2
 o
-"Specified by" links to members in interfaces and "Overrides" links to members in classes
+"Specified by" links to members in interfaces and "Overrides" links to members in classes 
 .TP 2
 o
-Summary tables listing packages, classes and members
+Summary tables listing packages, classes and members 
 .TP 2
 o
-Package and class inheritance trees
+Package and class inheritance trees 
 .TP 2
 o
-The index
+The index 
 .RE
 .LP
 You can add hyperlinks to existing text for classes not included on the command line (but generated separately) by way of the \f2\-link\fP and \f2\-linkoffline\fP options.
@@ -107,12 +107,12 @@
 .LP
 In many cases, the Javadoc tool allows you to generate documentation for source files whose code is incomplete or erroneous. This is a benefit that enables you to generate documentation before all debugging and troubleshooting is done. For example, according to the \f2Java Language Specification\fP, a class that contains an abstract method should itself be declared abstract. The Javadoc tool does not check for this, and would proceed without a warning, whereas the javac compiler stops on this error. The Javadoc tool does do some primitive checking of doc comments. Use the DocCheck doclet to check the doc comments more thoroughly.
 .LP
-When the Javadoc tool builds its internal structure for the documentation, it loads all referenced classes. Because of this, the Javadoc tool must be able to find all referenced classes, whether bootstrap classes, extensions, or user classes. For more about this, see
+When the Javadoc tool builds its internal structure for the documentation, it loads all referenced classes. Because of this, the Javadoc tool must be able to find all referenced classes, whether bootstrap classes, extensions, or user classes. For more about this, see 
 .na
 \f2How Classes Are Found\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/findingclasses.html. Generally speaking, classes you create must either be loaded as an extension or in the Javadoc tool's class path.
-.SS
+http://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html. Generally speaking, classes you create must either be loaded as an extension or in the Javadoc tool's class path.
+.SS 
 Javadoc Doclets
 .LP
 You can customize the content and format of the Javadoc tool's output by using doclets. The Javadoc tool has a default "built\-in" doclet, called the standard doclet, that generates HTML\-formatted API documentation. You can modify or subclass the standard doclet, or write your own doclet to generate HTML, XML, MIF, RTF or whatever output format you'd like. Information about doclets and their use is at the following locations:
@@ -122,14 +122,14 @@
 .na
 \f2Javadoc Doclets\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html 
 .TP 2
 o
-The \f2\-doclet\fP command\-line option
+The \f2\-doclet\fP command\-line option 
 .RE
 .LP
 When a custom doclet is not specified with the \f2\-doclet\fP command line option, the Javadoc tool will use the default standard doclet. The javadoc tool has several command line options that are available regardless of which doclet is being used. The standard doclet adds a supplementary set of command line options. Both sets of options are described below in the options section.
-.SS
+.SS 
 Related Documentation and Doclets
 .RS 3
 .TP 2
@@ -137,89 +137,89 @@
 .na
 \f2Javadoc Enhancements\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html for details about improvements added in Javadoc.
+http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html for details about improvements added in Javadoc. 
 .TP 2
 o
 .na
 \f2Javadoc FAQ\fP @
 .fi
-http://java.sun.com/j2se/javadoc/faq/index.html for answers to common questions, information about Javadoc\-related tools, and workarounds for bugs.
+http://java.sun.com/j2se/javadoc/faq/index.html for answers to common questions, information about Javadoc\-related tools, and workarounds for bugs. 
 .TP 2
 o
 .na
 \f2How to Write Doc Comments for Javadoc\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html for more information about Sun conventions for writing documentation comments.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html for more information about Sun conventions for writing documentation comments. 
 .TP 2
 o
 .na
 \f2Requirements for Writing API Specifications\fP @
 .fi
-http://java.sun.com/j2se/javadoc/writingapispecs/index.html \- Standard requirements used when writing the Java SE Platform Specification. It can be useful whether you are writing API specifications in source file documentation comments or in other formats. It covers requirements for packages, classes, interfaces, fields and methods to satisfy testable assertions.
+http://java.sun.com/j2se/javadoc/writingapispecs/index.html \- Standard requirements used when writing the Java SE Platform Specification. It can be useful whether you are writing API specifications in source file documentation comments or in other formats. It covers requirements for packages, classes, interfaces, fields and methods to satisfy testable assertions. 
 .TP 2
 o
 .na
 \f2Documentation Comment Specification\fP @
 .fi
-http://java.sun.com/docs/books/jls/first_edition/html/18.doc.html \- The original specification on documentation comments, Chapter 18, Documentation Comments, in the \f2Java Language Specification\fP, First Edition, by James Gosling, Bill Joy, and Guy Steele. (This chapter was removed from the second edition.)
+http://java.sun.com/docs/books/jls/first_edition/html/18.doc.html \- The original specification on documentation comments, Chapter 18, Documentation Comments, in the \f2Java Language Specification\fP, First Edition, by James Gosling, Bill Joy, and Guy Steele. (This chapter was removed from the second edition.)  
 .TP 2
 o
 .na
 \f2DocCheck Doclet\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-141437.html \- Checks doc comments in source files and generates a report listing the errors and irregularities it finds. It is part of the Doc Check Utilities.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-141437.html \- Checks doc comments in source files and generates a report listing the errors and irregularities it finds. It is part of the Doc Check Utilities. 
 .TP 2
 o
 .na
 \f2MIF Doclet\fP @
 .fi
-http://java.sun.com/j2se/javadoc/mifdoclet/ \- Can automate the generation of API documentation in MIF, FrameMaker and PDF formats. MIF is Adobe FrameMaker's interchange format.
+http://java.sun.com/j2se/javadoc/mifdoclet/ \- Can automate the generation of API documentation in MIF, FrameMaker and PDF formats. MIF is Adobe FrameMaker's interchange format. 
 .RE
-.SS
+.SS 
 Terminology
 .LP
 The terms \f2documentation comment\fP, \f2doc comment\fP, \f2main description\fP, \f2tag\fP, \f2block tag\fP, and \f2in\-line tag\fP are described at Documentation Comments. These other terms have specific meanings within the context of the Javadoc tool:
 .RS 3
 .TP 3
-generated document
-The document generated by the javadoc tool from the doc comments in Java source code. The default generated document is in HTML and is created by the standard doclet.
+generated document 
+The document generated by the javadoc tool from the doc comments in Java source code. The default generated document is in HTML and is created by the standard doclet. 
 .LP
 .TP 3
-name
-A name of a program element written in the Java Language \-\- that is, the name of a package, class, interface, field, constructor or method. A name can be fully\-qualified, such as \f2java.lang.String.equals(java.lang.Object)\fP, or partially\-qualified, such as \f2equals(Object)\fP.
+name 
+A name of a program element written in the Java Language \-\- that is, the name of a package, class, interface, field, constructor or method. A name can be fully\-qualified, such as \f2java.lang.String.equals(java.lang.Object)\fP, or partially\-qualified, such as \f2equals(Object)\fP. 
 .LP
 .TP 3
-documented classes
-The classes and interfaces for which detailed documentation is generated during a javadoc run. To be documented, the source files must be available, their source filenames or package names must be passed into the javadoc command, and they must not be filtered out by their access modifier (public, protected, package\-private or private). We also refer to these as the classes included in the javadoc output, or the \f2included classes\fP.
+documented classes 
+The classes and interfaces for which detailed documentation is generated during a javadoc run. To be documented, the source files must be available, their source filenames or package names must be passed into the javadoc command, and they must not be filtered out by their access modifier (public, protected, package\-private or private). We also refer to these as the classes included in the javadoc output, or the \f2included classes\fP. 
 .LP
 .TP 3
-included classes
-Classes and interfaces whose details are documented during a run of the Javadoc tool. Same as \f2documented classes\fP.
+included classes 
+Classes and interfaces whose details are documented during a run of the Javadoc tool. Same as \f2documented classes\fP. 
 .LP
 .TP 3
-excluded classes
-Classes and interfaces whose details are \f2not\fP documented during a run of the Javadoc tool.
+excluded classes 
+Classes and interfaces whose details are \f2not\fP documented during a run of the Javadoc tool. 
 .LP
 .TP 3
-referenced classes
-The classes and interfaces that are explicitly referred to in the definition (implementation) or doc comments of the documented classes and interfaces. Examples of references include return type, parameter type, cast type, extended class, implemented interface, imported classes, classes used in method bodies, @see, {@link}, {@linkplain}, and {@inheritDoc} tags. (Notice this definition has changed since
+referenced classes 
+The classes and interfaces that are explicitly referred to in the definition (implementation) or doc comments of the documented classes and interfaces. Examples of references include return type, parameter type, cast type, extended class, implemented interface, imported classes, classes used in method bodies, @see, {@link}, {@linkplain}, and {@inheritDoc} tags. (Notice this definition has changed since 
 .na
 \f21.3\fP @
 .fi
-http://download.oracle.com/javase/1.3/docs/tooldocs/solaris/javadoc.html#referencedclasses.) When the Javadoc tool is run, it should load into memory all of the referenced classes in javadoc's bootclasspath and classpath. (The Javadoc tool prints a "Class not found" warning for referenced classes not found.) The Javadoc tool can derive enough information from the .class files to determine their existence and the fully\-qualified names of their members.
+http://docs.oracle.com/javase/1.3/docs/tooldocs/solaris/javadoc.html#referencedclasses.) When the Javadoc tool is run, it should load into memory all of the referenced classes in javadoc's bootclasspath and classpath. (The Javadoc tool prints a "Class not found" warning for referenced classes not found.) The Javadoc tool can derive enough information from the .class files to determine their existence and the fully\-qualified names of their members. 
 .LP
 .TP 3
-external referenced classes
-The referenced classes whose documentation is not being generated during a javadoc run. In other words, these classes are not passed into the Javadoc tool on the command line. Links in the generated documentation to those classes are said to be \f2external references\fP or \f2external links\fP. For example, if you run the Javadoc tool on only the \f2java.awt\fP package, then any class in \f2java.lang\fP, such as \f2Object\fP, is an external referenced class. External referenced classes can be linked to using the \f2\-link\fP and \f2\-linkoffline\fP options. An important property of an external referenced class is that its source comments are normally not available to the Javadoc run. In this case, these comments cannot be inherited.
+external referenced classes 
+The referenced classes whose documentation is not being generated during a javadoc run. In other words, these classes are not passed into the Javadoc tool on the command line. Links in the generated documentation to those classes are said to be \f2external references\fP or \f2external links\fP. For example, if you run the Javadoc tool on only the \f2java.awt\fP package, then any class in \f2java.lang\fP, such as \f2Object\fP, is an external referenced class. External referenced classes can be linked to using the \f2\-link\fP and \f2\-linkoffline\fP options. An important property of an external referenced class is that its source comments are normally not available to the Javadoc run. In this case, these comments cannot be inherited. 
 .RE
 .SH "SOURCE FILES"
 .LP
 The Javadoc tool will generate output originating from four different types of "source" files: Java language source files for classes (\f2.java\fP), package comment files, overview comment files, and miscellaneous unprocessed files. This section also covers test files and template files that can also be in the source tree, but which you want to be sure not to document.
-.SS
+.SS 
 Class Source Code Files
 .LP
 Each class or interface and its members can have their own documentation comments, contained in a \f2.java\fP file. For more details about these doc comments, see Documentation Comments.
-.SS
+.SS 
 Package Comment Files
 .LP
 Each package can have its own documentation comment, contained in its own "source" file, that the Javadoc tool will merge into the package summary page that it generates. You typically include in this comment any documentation that applies to the entire package.
@@ -228,10 +228,10 @@
 .RS 3
 .TP 2
 o
-\f2package\-info.java\fP \- Can contain a package declaration, package annotations, package comments and Javadoc tags. This file is generally preferred over package.html.
+\f2package\-info.java\fP \- Can contain a package declaration, package annotations, package comments and Javadoc tags. This file is generally preferred over package.html. 
 .TP 2
 o
-\f2package.html\fP \- Can contain only package comments and Javadoc tags, no package annotations.
+\f2package.html\fP \- Can contain only package comments and Javadoc tags, no package annotations. 
 .RE
 .LP
 A package may have a single \f2package.html\fP file or a single \f2package\-info.java\fP file but not both. Place either file in the package directory in the source tree along with your \f2.java\fP files.
@@ -244,9 +244,9 @@
 .fl
 /**
 .fl
- * Provides the classes necessary to create an
+ * Provides the classes necessary to create an  
 .fl
- * applet and the classes an applet uses
+ * applet and the classes an applet uses 
 .fl
  * to communicate with its applet context.
 .fl
@@ -260,7 +260,7 @@
 .fl
  * {@link java.awt.Panel} class) with a few extra
 .fl
- * methods that the applet context can use to
+ * methods that the applet context can use to 
 .fl
  * initialize, start, and stop the applet.
 .fl
@@ -289,7 +289,7 @@
 .fl
 <BODY>
 .fl
-Provides the classes necessary to create an applet and the
+Provides the classes necessary to create an applet and the 
 .fl
 classes an applet uses to communicate with its applet context.
 .fl
@@ -303,11 +303,11 @@
 .fl
 few extra methods that the applet context can use to
 .fl
-initialize, start, and stop the applet.
+initialize, start, and stop the applet. 
 .fl
 
 .fl
-@since 1.0
+@since 1.0 
 .fl
 @see java.awt
 .fl
@@ -318,7 +318,7 @@
 \fP
 .fi
 .LP
-Notice this is just a normal HTML file and does not include a package declaration. The content of the package comment file is written in HTML, like all other comments, with one exception: The documentation comment should not include the comment separators \f2/**\fP and \f2*/\fP or leading asterisks. When writing the comment, you should make the first sentence a summary about the package, and not put a title or any other text between \f2<body>\fP and the first sentence. You can include package tags; as with any documentation comment, all block tags must appear after the main description. If you add a \f2@see\fP tag in a package comment file, it must have a fully\-qualified name. For more details, see the
+Notice this is just a normal HTML file and does not include a package declaration. The content of the package comment file is written in HTML, like all other comments, with one exception: The documentation comment should not include the comment separators \f2/**\fP and \f2*/\fP or leading asterisks. When writing the comment, you should make the first sentence a summary about the package, and not put a title or any other text between \f2<body>\fP and the first sentence. You can include package tags; as with any documentation comment, all block tags must appear after the main description. If you add a \f2@see\fP tag in a package comment file, it must have a fully\-qualified name. For more details, see the 
 .na
 \f2example of \fP\f2package.html\fP @
 .fi
@@ -328,26 +328,26 @@
 .RS 3
 .TP 2
 o
-Copies the comment for processing. (For \f2package.html\fP, copies all content between \f2<body>\fP and \f2</body>\fP HTML tags. You can include a \f2<head>\fP section to put a \f2<title>\fP, source file copyright statement, or other information, but none of these will appear in the generated documentation.)
+Copies the comment for processing. (For \f2package.html\fP, copies all content between \f2<body>\fP and \f2</body>\fP HTML tags. You can include a \f2<head>\fP section to put a \f2<title>\fP, source file copyright statement, or other information, but none of these will appear in the generated documentation.) 
 .TP 2
 o
-Processes any package tags that are present.
+Processes any package tags that are present. 
 .TP 2
 o
-Inserts the processed text at the bottom of the package summary page it generates, as shown in
+Inserts the processed text at the bottom of the package summary page it generates, as shown in 
 .na
 \f2Package Summary\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/applet/package\-summary.html.
+http://docs.oracle.com/javase/7/docs/api/java/applet/package\-summary.html. 
 .TP 2
 o
-Copies the first sentence of the package comment to the top of the package summary page. It also adds the package name and this first sentence to the list of packages on the overview page, as shown in
+Copies the first sentence of the package comment to the top of the package summary page. It also adds the package name and this first sentence to the list of packages on the overview page, as shown in 
 .na
 \f2Overview Summary\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/overview\-summary.html. The end\-of\-sentence is determined by the same rules used for the end of the first sentence of class and member main descriptions.
+http://docs.oracle.com/javase/7/docs/api/overview\-summary.html. The end\-of\-sentence is determined by the same rules used for the end of the first sentence of class and member main descriptions. 
 .RE
-.SS
+.SS 
 Overview Comment File
 .LP
 Each application or set of packages that you are documenting can have its own overview documentation comment, kept in its own "source" file, that the Javadoc tool will merge into the overview page that it generates. You typically include in this comment any documentation that applies to the entire application or set of packages.
@@ -362,22 +362,22 @@
 .RS 3
 .TP 2
 o
-Copies all content between \f2<body>\fP and \f2</body>\fP tags for processing.
+Copies all content between \f2<body>\fP and \f2</body>\fP tags for processing. 
 .TP 2
 o
-Processes any overview tags that are present.
+Processes any overview tags that are present. 
 .TP 2
 o
-Inserts the processed text at the bottom of the overview page it generates, as shown in
+Inserts the processed text at the bottom of the overview page it generates, as shown in 
 .na
 \f2Overview Summary\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/overview\-summary.html.
+http://docs.oracle.com/javase/7/docs/api/overview\-summary.html. 
 .TP 2
 o
-Copies the first sentence of the overview comment to the top of the overview summary page.
+Copies the first sentence of the overview comment to the top of the overview summary page. 
 .RE
-.SS
+.SS 
 Miscellaneous Unprocessed Files
 .LP
 You can also include in your source any miscellaneous files that you want the Javadoc tool to copy to the destination directory. These typically includes graphic files, example Java source (.java) and class (.class) files, and self\-standing HTML files whose content would overwhelm the documentation comment of a normal Java source file.
@@ -390,7 +390,7 @@
 .fl
     /**
 .fl
-     * This button looks like this:
+     * This button looks like this: 
 .fl
      * <img src="doc\-files/Button.gif">
 .fl
@@ -398,7 +398,7 @@
 .fl
 \fP
 .fi
-.SS
+.SS 
 Test Files and Template Files
 .LP
 Some developers have indicated they want to store test files and templates files in the source tree near their corresponding source files. That is, they would like to put them in the same directory, or a subdirectory, of those source files.
@@ -429,60 +429,60 @@
 .RS 3
 .TP 2
 o
-One \f3class or interface page\fP (\f2classname\fP\f2.html\fP) for each class or interface it is documenting.
+One \f3class or interface page\fP (\f2classname\fP\f2.html\fP) for each class or interface it is documenting.  
 .TP 2
 o
-One \f3package page\fP (\f2package\-summary.html\fP) for each package it is documenting. The Javadoc tool will include any HTML text provided in a file named \f2package.html\fP or \f2package\-info.java\fP in the package directory of the source tree.
+One \f3package page\fP (\f2package\-summary.html\fP) for each package it is documenting. The Javadoc tool will include any HTML text provided in a file named \f2package.html\fP or \f2package\-info.java\fP in the package directory of the source tree.  
 .TP 2
 o
-One \f3overview page\fP (\f2overview\-summary.html\fP) for the entire set of packages. This is the front page of the generated document. The Javadoc tool will include any HTML text provided in a file specified with the \f2\-overview\fP option. Note that this file is created only if you pass into javadoc two or more package names. For further explanation, see HTML Frames.)
+One \f3overview page\fP (\f2overview\-summary.html\fP) for the entire set of packages. This is the front page of the generated document. The Javadoc tool will include any HTML text provided in a file specified with the \f2\-overview\fP option. Note that this file is created only if you pass into javadoc two or more package names. For further explanation, see HTML Frames.) 
 .RE
 .LP
 \f3Cross\-Reference Pages\fP
 .RS 3
 .TP 2
 o
-One \f3class hierarchy page for the entire set of packages\fP (\f2overview\-tree.html\fP). To view this, click on "Overview" in the navigation bar, then click on "Tree".
+One \f3class hierarchy page for the entire set of packages\fP (\f2overview\-tree.html\fP). To view this, click on "Overview" in the navigation bar, then click on "Tree".  
 .TP 2
 o
-One \f3class hierarchy page for each package\fP (\f2package\-tree.html\fP) To view this, go to a particular package, class or interface page; click "Tree" to display the hierarchy for that package.
+One \f3class hierarchy page for each package\fP (\f2package\-tree.html\fP) To view this, go to a particular package, class or interface page; click "Tree" to display the hierarchy for that package.  
 .TP 2
 o
-One \f3"use" page\fP for each package (\f2package\-use.html\fP) and a separate one for each class and interface (\f2class\-use/\fP\f2classname\fP\f2.html\fP). This page describes what packages, classes, methods, constructors and fields use any part of the given class, interface or package. Given a class or interface A, its "use" page includes subclasses of A, fields declared as A, methods that return A, and methods and constructors with parameters of type A. You can access this page by first going to the package, class or interface, then clicking on the "Use" link in the navigation bar.
+One \f3"use" page\fP for each package (\f2package\-use.html\fP) and a separate one for each class and interface (\f2class\-use/\fP\f2classname\fP\f2.html\fP). This page describes what packages, classes, methods, constructors and fields use any part of the given class, interface or package. Given a class or interface A, its "use" page includes subclasses of A, fields declared as A, methods that return A, and methods and constructors with parameters of type A. You can access this page by first going to the package, class or interface, then clicking on the "Use" link in the navigation bar.  
 .TP 2
 o
-A \f3deprecated API page\fP (\f2deprecated\-list.html\fP) listing all deprecated names. (A deprecated name is not recommended for use, generally due to improvements, and a replacement name is usually given. Deprecated APIs may be removed in future implementations.)
+A \f3deprecated API page\fP (\f2deprecated\-list.html\fP) listing all deprecated names. (A deprecated name is not recommended for use, generally due to improvements, and a replacement name is usually given. Deprecated APIs may be removed in future implementations.)  
 .TP 2
 o
-A \f3constant field values page\fP (\f2constant\-values.html\fP) for the values of static fields.
+A \f3constant field values page\fP (\f2constant\-values.html\fP) for the values of static fields.  
 .TP 2
 o
-A \f3serialized form page\fP (\f2serialized\-form.html\fP) for information about serializable and externalizable classes. Each such class has a description of its serialization fields and methods. This information is of interest to re\-implementors, not to developers using the API. While there is no link in the navigation bar, you can get to this information by going to any serialized class and clicking "Serialized Form" in the "See also" section of the class comment. The standard doclet automatically generates a serialized form page: any class (public or non\-public) that implements Serializable is included, along with \f2readObject\fP and \f2writeObject\fP methods, the fields that are serialized, and the doc comments from the \f2@serial\fP, \f2@serialField\fP, and \f2@serialData\fP tags. Public serializable classes can be excluded by marking them (or their package) with \f2@serial exclude\fP, and package\-private serializable classes can be included by marking them (or their package) with \f2@serial include\fP. As of 1.4, you can generate the complete serialized form for public and private classes by running javadoc \f2without\fP specifying the \f2\-private\fP option.
+A \f3serialized form page\fP (\f2serialized\-form.html\fP) for information about serializable and externalizable classes. Each such class has a description of its serialization fields and methods. This information is of interest to re\-implementors, not to developers using the API. While there is no link in the navigation bar, you can get to this information by going to any serialized class and clicking "Serialized Form" in the "See also" section of the class comment. The standard doclet automatically generates a serialized form page: any class (public or non\-public) that implements Serializable is included, along with \f2readObject\fP and \f2writeObject\fP methods, the fields that are serialized, and the doc comments from the \f2@serial\fP, \f2@serialField\fP, and \f2@serialData\fP tags. Public serializable classes can be excluded by marking them (or their package) with \f2@serial exclude\fP, and package\-private serializable classes can be included by marking them (or their package) with \f2@serial include\fP. As of 1.4, you can generate the complete serialized form for public and private classes by running javadoc \f2without\fP specifying the \f2\-private\fP option.  
 .TP 2
 o
-An \f3index\fP (\f2index\-*.html\fP) of all class, interface, constructor, field and method names, alphabetically arranged. This is internationalized for Unicode and can be generated as a single file or as a separate file for each starting character (such as A\-Z for English).
+An \f3index\fP (\f2index\-*.html\fP) of all class, interface, constructor, field and method names, alphabetically arranged. This is internationalized for Unicode and can be generated as a single file or as a separate file for each starting character (such as A\-Z for English). 
 .RE
 .LP
 \f3Support Files\fP
 .RS 3
 .TP 2
 o
-A \f3help page\fP (\f2help\-doc.html\fP) that describes the navigation bar and the above pages. You can provide your own custom help file to override the default using \f2\-helpfile\fP.
+A \f3help page\fP (\f2help\-doc.html\fP) that describes the navigation bar and the above pages. You can provide your own custom help file to override the default using \f2\-helpfile\fP. 
 .TP 2
 o
-One \f3index.html file\fP which creates the HTML frames for display. This is the file you load to display the front page with frames. This file itself contains no text content.
+One \f3index.html file\fP which creates the HTML frames for display. This is the file you load to display the front page with frames. This file itself contains no text content.  
 .TP 2
 o
-Several \f3frame files\fP (\f2*\-frame.html\fP) containing lists of packages, classes and interfaces, used when HTML frames are being displayed.
+Several \f3frame files\fP (\f2*\-frame.html\fP) containing lists of packages, classes and interfaces, used when HTML frames are being displayed.  
 .TP 2
 o
-A \f3package list\fP file (\f2package\-list\fP), used by the \f2\-link\fP and \f2\-linkoffline\fP options. This is a text file, not HTML, and is not reachable through any links.
+A \f3package list\fP file (\f2package\-list\fP), used by the \f2\-link\fP and \f2\-linkoffline\fP options. This is a text file, not HTML, and is not reachable through any links.  
 .TP 2
 o
-A \f3style sheet\fP file (\f2stylesheet.css\fP) that controls a limited amount of color, font family, font size, font style and positioning on the generated pages.
+A \f3style sheet\fP file (\f2stylesheet.css\fP) that controls a limited amount of color, font family, font size, font style and positioning on the generated pages.  
 .TP 2
 o
-A \f3doc\-files\fP directory that holds any image, example, source code or other files that you want copied to the destination directory. These files are not processed by the Javadoc tool in any manner \-\- that is, any javadoc tags in them will be ignored. This directory is not generated unless it exists in the source tree.
+A \f3doc\-files\fP directory that holds any image, example, source code or other files that you want copied to the destination directory. These files are not processed by the Javadoc tool in any manner \-\- that is, any javadoc tags in them will be ignored. This directory is not generated unless it exists in the source tree. 
 .RE
 .LP
 \f3HTML Frames\fP
@@ -495,10 +495,10 @@
 .RS 3
 .TP 2
 o
-\f2index.html\fP (for frames)
+\f2index.html\fP (for frames) 
 .TP 2
 o
-\f2overview\-summary.html\fP (for no frames)
+\f2overview\-summary.html\fP (for no frames) 
 .RE
 .LP
 \f3Generated File Structure\fP
@@ -590,7 +590,7 @@
                 AudioClip.html      Page for AudioClip source code
 .fl
 .fi
-.SS
+.SS 
 Generated API Declarations
 .LP
 The Javadoc tool generates a declaration at the start of each class, interface, field, constructor, and method description for that API item. For example, the declaration for the \f2Boolean\fP class is:
@@ -611,7 +611,7 @@
 .SH "DOCUMENTATION COMMENTS"
 .LP
 The original "Documentation Comment Specification" can be found under related documentation.
-.SS
+.SS 
 Commenting the Source Code
 .LP
 You can include \f2documentation comments\fP ("doc comments") in the source code, ahead of declarations for any class, interface, method, constructor, or field. You can also create doc comments for each package and another one for the overview, though their syntax is slightly different. Doc comments are also known informally as "Javadoc comments" (but this term violates its trademark usage). A doc comment consists of the characters between the characters \f2/**\fP that begin the comment and the characters \f2*/\fP that end it. Leading asterisks are allowed on each line and are described further below. The text in a comment can continue onto multiple lines.
@@ -718,13 +718,13 @@
 .nf
 \f3
 .fl
-/**
+/** 
 .fl
  * The horizontal and vertical distances of point (x,y)
 .fl
  */
 .fl
-public int x, y;      // Avoid this
+public int x, y;      // Avoid this  
 .fl
 \fP
 .fi
@@ -737,7 +737,7 @@
 .fl
 .fi
 .RS 3
-The horizontal and vertical distances of point (x,y)
+The horizontal and vertical distances of point (x,y) 
 .RE
 .nf
 \f3
@@ -746,25 +746,25 @@
 .fl
 .fi
 .RS 3
-The horizontal and vertical distances of point (x,y)
+The horizontal and vertical distances of point (x,y) 
 .RE
 .LP
 \f3Use header tags carefully\fP \- When writing documentation comments for members, it's best not to use HTML heading tags such as <H1> and <H2>, because the Javadoc tool creates an entire structured document and these structural tags might interfere with the formatting of the generated document. However, it is fine to use these headings in class and package comments to provide your own structure.
-.SS
+.SS 
 Automatic Copying of Method Comments
 .LP
 The Javadoc tool has the ability to copy or "inherit" method comments in classes and interfaces under the following two circumstances. Constructors, fields and nested classes do not inherit doc comments.
 .RS 3
 .TP 2
 o
-\f3Automatically inherit comment to fill in missing text\fP \- When a main description, or \f2@return\fP, \f2@param\fP or \f2@throws\fP  tag is missing from a method comment, the Javadoc tool copies the corresponding main description or tag comment from the method it overrides or implements (if any), according to the algorithm below.
+\f3Automatically inherit comment to fill in missing text\fP \- When a main description, or \f2@return\fP, \f2@param\fP or \f2@throws\fP  tag is missing from a method comment, the Javadoc tool copies the corresponding main description or tag comment from the method it overrides or implements (if any), according to the algorithm below. 
 .LP
-More specifically, when a \f2@param\fP tag for a particular parameter is missing, then the comment for that parameter is copied from the method further up the inheritance hierarchy. When a \f2@throws\fP tag for a particular exception is missing, the \f2@throws\fP tag is copied \f2only if that exception is declared\fP.
+More specifically, when a \f2@param\fP tag for a particular parameter is missing, then the comment for that parameter is copied from the method further up the inheritance hierarchy. When a \f2@throws\fP tag for a particular exception is missing, the \f2@throws\fP tag is copied \f2only if that exception is declared\fP. 
 .LP
-This behavior contrasts with version 1.3 and earlier, where the presence of any main description or tag would prevent all comments from being inherited.
+This behavior contrasts with version 1.3 and earlier, where the presence of any main description or tag would prevent all comments from being inherited.  
 .TP 2
 o
-\f3Explicitly inherit comment with {@inheritDoc} tag\fP \- Insert the inline tag \f2{@inheritDoc}\fP in a method main description or \f2@return\fP, \f2@param\fP or \f2@throws\fP tag comment \-\- the corresponding inherited main description or tag comment is copied into that spot.
+\f3Explicitly inherit comment with {@inheritDoc} tag\fP \- Insert the inline tag \f2{@inheritDoc}\fP in a method main description or \f2@return\fP, \f2@param\fP or \f2@throws\fP tag comment \-\- the corresponding inherited main description or tag comment is copied into that spot. 
 .RE
 .LP
 The source file for the inherited method need only be on the path specified by \-sourcepath for the doc comment to actually be available to copy. Neither the class nor its package needs to be passed in on the command line. This contrasts with 1.3.x and earlier releases, where the class had to be a documented class
@@ -773,13 +773,13 @@
 .RS 3
 .TP 2
 o
-When a method in a class overrides a method in a superclass
+When a method in a class overrides a method in a superclass 
 .TP 2
 o
-When a method in an interface overrides a method in a superinterface
+When a method in an interface overrides a method in a superinterface 
 .TP 2
 o
-When a method in a class implements a method in an interface
+When a method in a class implements a method in an interface 
 .RE
 .LP
 In the first two cases, for method overrides, the Javadoc tool generates a subheading "Overrides" in the documentation for the overriding method, with a link to the method it is overriding, whether or not the comment is inherited.
@@ -790,37 +790,37 @@
 .RS 3
 .TP 3
 1.
-Look in each directly implemented (or extended) interface in the order they appear following the word implements (or extends) in the method declaration. Use the first doc comment found for this method.
+Look in each directly implemented (or extended) interface in the order they appear following the word implements (or extends) in the method declaration. Use the first doc comment found for this method. 
 .TP 3
 2.
-If step 1 failed to find a doc comment, recursively apply this entire algorithm to each directly implemented (or extended) interface, in the same order they were examined in step 1.
+If step 1 failed to find a doc comment, recursively apply this entire algorithm to each directly implemented (or extended) interface, in the same order they were examined in step 1. 
 .TP 3
 3.
-If step 2 failed to find a doc comment and this is a class other than Object (not an interface):
+If step 2 failed to find a doc comment and this is a class other than Object (not an interface): 
 .RS 3
 .TP 3
 a.
-If the superclass has a doc comment for this method, use it.
+If the superclass has a doc comment for this method, use it. 
 .TP 3
 b.
-If step 3a failed to find a doc comment, recursively apply this entire algorithm to the superclass.
+If step 3a failed to find a doc comment, recursively apply this entire algorithm to the superclass. 
 .RE
 .RE
 .SH "JAVADOC TAGS"
 .LP
-The Javadoc tool parses special tags when they are embedded within a Java doc comment. These doc tags enable you to autogenerate a complete, well\-formatted API from your source code. The tags start with an "at" sign (\f2@\fP) and are case\-sensitive \-\- they must be typed with the uppercase and lowercase letters as shown. A tag must start at the beginning of a line (after any leading spaces and an optional asterisk) or it is treated as normal text. By convention, tags with the same name are grouped together. For example, put all \f2@see\fP tags together.
+The Javadoc tool parses special tags when they are embedded within a Java doc comment. These doc tags enable you to autogenerate a complete, well\-formatted API from your source code. The tags start with an "at" sign (\f2@\fP) and are case\-sensitive \-\- they must be typed with the uppercase and lowercase letters as shown. A tag must start at the beginning of a line (after any leading spaces and an optional asterisk) or it is treated as normal text. By convention, tags with the same name are grouped together. For example, put all \f2@see\fP tags together. 
 .LP
 Tags come in two types:
 .RS 3
 .TP 2
 o
-\f3Block tags\fP \- Can be placed only in the tag section that follows the main description. Block tags are of the form: \f2@tag\fP.
+\f3Block tags\fP \- Can be placed only in the tag section that follows the main description. Block tags are of the form: \f2@tag\fP. 
 .TP 2
 o
-\f3Inline tags\fP \- Can be placed anywhere in the main description or in the comments for block tags. Inline tags are denoted by curly braces: \f2{@tag}\fP.
+\f3Inline tags\fP \- Can be placed anywhere in the main description or in the comments for block tags. Inline tags are denoted by curly braces: \f2{@tag}\fP. 
 .RE
 .LP
-For information about tags we might introduce in future releases, see
+For information about tags we might introduce in future releases, see 
 .na
 \f2Proposed Tags\fP @
 .fi
@@ -828,6 +828,7 @@
 .LP
 The current tags are:
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -952,83 +953,83 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Tag\fP\h'|\n(41u'\f3Introduced in JDK/SDK\fP
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@author\fP\h'|\n(41u'1.0
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@code}\fP\h'|\n(41u'1.5
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@docRoot}\fP\h'|\n(41u'1.3
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@deprecated\fP\h'|\n(41u'1.0
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@exception\fP\h'|\n(41u'1.0
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@inheritDoc}\fP\h'|\n(41u'1.4
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@link}\fP\h'|\n(41u'1.2
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@linkplain}\fP\h'|\n(41u'1.4
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@literal}\fP\h'|\n(41u'1.5
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@param\fP\h'|\n(41u'1.0
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@return\fP\h'|\n(41u'1.0
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@see\fP\h'|\n(41u'1.0
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@serial\fP\h'|\n(41u'1.2
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@serialData\fP\h'|\n(41u'1.2
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@serialField\fP\h'|\n(41u'1.2
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@since\fP\h'|\n(41u'1.1
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@throws\fP\h'|\n(41u'1.2
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2{@value}\fP\h'|\n(41u'1.4
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f2@version\fP\h'|\n(41u'1.0
@@ -1036,16 +1037,17 @@
 .nr T. 1
 .T# 1
 .35
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-42
 .LP
 For custom tags, see the \-tag option.
 .RS 3
 .TP 3
-@author\  name\-text
-Adds an "Author" entry with the specified \f2name\-text\fP to the generated docs when the \-author option is used. A doc comment may contain multiple \f2@author\fP tags. You can specify one name per \f2@author\fP tag or multiple names per tag. In the former case, the Javadoc tool inserts a comma (\f2,\fP) and space between names. In the latter case, the entire text is simply copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than comma.
+@author\  name\-text 
+Adds an "Author" entry with the specified \f2name\-text\fP to the generated docs when the \-author option is used. A doc comment may contain multiple \f2@author\fP tags. You can specify one name per \f2@author\fP tag or multiple names per tag. In the former case, the Javadoc tool inserts a comma (\f2,\fP) and space between names. In the latter case, the entire text is simply copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than comma. 
 .RE
 .LP
-For more details, see Where Tags Can Be Used and
+For more details, see Where Tags Can Be Used and 
 .na
 \f2writing @author tags\fP @
 .fi
@@ -1053,14 +1055,14 @@
 .LP
 .RS 3
 .TP 3
-@deprecated\  deprecated\-text Note: You can deprecate a program element using the @Deprecated annotation.
+@deprecated\  deprecated\-text Note: You can deprecate a program element using the @Deprecated annotation.  
 .RE
 .LP
 Adds a comment indicating that this API should no longer be used (even though it may continue to work). The Javadoc tool moves the \f2deprecated\-text\fP ahead of the main description, placing it in italics and preceding it with a bold warning: "Deprecated". This tag is valid in all doc comments: overview, package, class, interface, constructor, method and field.
 .LP
 The first sentence of \f2deprecated\-text\fP should at least tell the user when the API was deprecated and what to use as a replacement. The Javadoc tool copies just the first sentence to the summary section and index. Subsequent sentences can also explain why it has been deprecated. You should include a \f2{@link}\fP tag (for Javadoc 1.2 or later) that points to the replacement API:
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing @deprecated tags\fP @
 .fi
@@ -1068,7 +1070,7 @@
 .RS 3
 .TP 2
 o
-For Javadoc 1.2 and later, use a \f2{@link}\fP tag. This creates the link in\-line, where you want it. For example:
+For Javadoc 1.2 and later, use a \f2{@link}\fP tag. This creates the link in\-line, where you want it. For example: 
 .nf
 \f3
 .fl
@@ -1078,75 +1080,75 @@
 .fl
  */
 .fl
-
+            
 .fl
 \fP
 .fi
 .TP 2
 o
-For Javadoc 1.1, the standard format is to create a \f2@see\fP tag (which cannot be in\-line) for each \f2@deprecated\fP tag.
+For Javadoc 1.1, the standard format is to create a \f2@see\fP tag (which cannot be in\-line) for each \f2@deprecated\fP tag. 
 .RE
 .LP
-For more about deprecation, see
+For more about deprecation, see 
 .na
 \f2The @deprecated tag\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javadoc/deprecation/index.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/deprecation/index.html.
 .LP
 .RS 3
 .TP 3
-{@code\  text}
-Equivalent to \f2<code>{@literal}</code>\fP.
+{@code\  text} 
+Equivalent to \f2<code>{@literal}</code>\fP. 
 .LP
-Displays \f2text\fP in \f2code\fP font without interpreting the text as HTML markup or nested javadoc tags. This enables you to use regular angle brackets (\f2<\fP and \f2>\fP) instead of the HTML entities (\f2<\fP and \f2>\fP) in doc comments, such as in parameter types (\f2<Object>\fP), inequalities (\f23 < 4\fP), or arrows (\f2<\-\fP). For example, the doc comment text:
+Displays \f2text\fP in \f2code\fP font without interpreting the text as HTML markup or nested javadoc tags. This enables you to use regular angle brackets (\f2<\fP and \f2>\fP) instead of the HTML entities (\f2<\fP and \f2>\fP) in doc comments, such as in parameter types (\f2<Object>\fP), inequalities (\f23 < 4\fP), or arrows (\f2<\-\fP). For example, the doc comment text: 
 .nf
 \f3
 .fl
      \fP\f4{@code A<B>C}\fP\f3
 .fl
-
+          
 .fl
 \fP
 .fi
 .LP
-displays in the generated HTML page unchanged, as:
+displays in the generated HTML page unchanged, as: 
 .nf
 \f3
 .fl
      \fP\f4A<B>C\fP\f3
 .fl
-
+          
 .fl
 \fP
 .fi
 .LP
-The noteworthy point is that the \f2<B>\fP is not interpreted as bold and is in code font.
+The noteworthy point is that the \f2<B>\fP is not interpreted as bold and is in code font. 
 .LP
-If you want the same functionality without the code font, use \f2{@literal}\fP.
+If you want the same functionality without the code font, use \f2{@literal}\fP. 
 .LP
 .TP 3
-{@docRoot}
-Represents the relative path to the generated document's (destination) root directory from any generated page. It is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common.
+{@docRoot} 
+Represents the relative path to the generated document's (destination) root directory from any generated page. It is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages. Linking to the copyright page from the bottom of each page is common. 
 .LP
-This \f2{@docRoot}\fP tag can be used both on the command line and in a doc comment: This tag is valid in all doc comments: overview, package, class, interface, constructor, method and field, including the text portion of any tag (such as @return, @param and @deprecated).
+This \f2{@docRoot}\fP tag can be used both on the command line and in a doc comment: This tag is valid in all doc comments: overview, package, class, interface, constructor, method and field, including the text portion of any tag (such as @return, @param and @deprecated). 
 .RS 3
 .TP 3
 1.
-On the command line, where the header/footer/bottom are defined:
+On the command line, where the header/footer/bottom are defined: 
 .nf
 \f3
 .fl
    javadoc \-bottom '<a href="{@docRoot}/copyright.html">Copyright</a>'
 .fl
-
+            
 .fl
 \fP
 .fi
 .LP
-NOTE \- When using \f2{@docRoot}\fP this way in a make file, some makefile programs require special escaping for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: \f2{{@docRoot}}\fP. It also requires double (rather than single) quotes to enclose arguments to options such as \f2\-bottom\fP (with the quotes around the \f2href\fP argument omitted).
+NOTE \- When using \f2{@docRoot}\fP this way in a make file, some makefile programs require special escaping for the brace {} characters. For example, the Inprise MAKE version 5.2 running on Windows requires double braces: \f2{{@docRoot}}\fP. It also requires double (rather than single) quotes to enclose arguments to options such as \f2\-bottom\fP (with the quotes around the \f2href\fP argument omitted).  
 .TP 3
 2.
-In a doc comment:
+In a doc comment: 
 .nf
 \f3
 .fl
@@ -1156,159 +1158,159 @@
 .fl
     */
 .fl
-
+            
 .fl
 \fP
 .fi
 .RE
 .LP
-The reason this tag is needed is because the generated docs are in hierarchical directories, as deep as the number of subpackages. This expression:
+The reason this tag is needed is because the generated docs are in hierarchical directories, as deep as the number of subpackages. This expression: 
 .nf
 \f3
 .fl
   <a href="{@docRoot}/copyright.html">
 .fl
-
+          
 .fl
 \fP
 .fi
 .LP
-would resolve to:
+would resolve to: 
 .nf
 \f3
 .fl
   <a href="../../copyright.html">      for java/lang/Object.java
 .fl
-
+          
 .fl
 \fP
 .fi
 .LP
-and
+and 
 .nf
 \f3
 .fl
   <a href="../../../copyright.html">   for java/lang/ref/Reference.java
 .fl
-
+          
 .fl
 \fP
 .fi
 .LP
 .TP 3
-@exception\  class\-name\  description
-The \f2@exception\fP tag is a synonym for \f2@throws\fP.
+@exception\  class\-name\  description 
+The \f2@exception\fP tag is a synonym for \f2@throws\fP. 
 .LP
 .TP 3
-{@inheritDoc}\
-Inherits (copies) documentation from the "nearest" inheritable class or implementable interface into the current doc comment at this tag's location. This allows you to write more general comments higher up the inheritance tree, and to write around the copied text.
+{@inheritDoc}\  
+Inherits (copies) documentation from the "nearest" inheritable class or implementable interface into the current doc comment at this tag's location. This allows you to write more general comments higher up the inheritance tree, and to write around the copied text. 
 .LP
-This tag is valid only in these places in a doc comment:
+This tag is valid only in these places in a doc comment: 
 .RS 3
 .TP 2
 o
-In the main description block of a method. In this case, the main description is copied from a class or interface up the hierarchy.
+In the main description block of a method. In this case, the main description is copied from a class or interface up the hierarchy. 
 .TP 2
 o
-In the text arguments of the @return, @param and @throws tags of a method. In this case, the tag text is copied from the corresponding tag up the hierarchy.
+In the text arguments of the @return, @param and @throws tags of a method. In this case, the tag text is copied from the corresponding tag up the hierarchy. 
 .RE
 .LP
-See Automatic Copying of Method Comments for a more precise description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, the comment is or is not automatically inherited according to rules described in that section.
+See Automatic Copying of Method Comments for a more precise description of how comments are found in the inheritance hierarchy. Note that if this tag is missing, the comment is or is not automatically inherited according to rules described in that section. 
 .LP
 .TP 3
-{@link\  package.class#member\  label}
-Inserts an in\-line link with visible text \f2label\fP that points to the documentation for the specified package, class or member name of a referenced class. This tag is valid in all doc comments: overview, package, class, interface, constructor, method and field, including the text portion of any tag (such as @return, @param and @deprecated).
+{@link\  package.class#member\  label} 
+Inserts an in\-line link with visible text \f2label\fP that points to the documentation for the specified package, class or member name of a referenced class. This tag is valid in all doc comments: overview, package, class, interface, constructor, method and field, including the text portion of any tag (such as @return, @param and @deprecated). 
 .LP
-This tag is very simliar to \f2@see\fP \-\- both require the same references and accept exactly the same syntax for \f2package.class\fP\f2#\fP\f2member\fP and \f2label\fP. The main difference is that \f2{@link}\fP generates an in\-line link rather than placing the link in the "See Also" section. Also, the \f2{@link}\fP tag begins and ends with curly braces to separate it from the rest of the in\-line text. If you need to use "}" inside the label, use the HTML entity notation &#125;
+This tag is very simliar to \f2@see\fP \-\- both require the same references and accept exactly the same syntax for \f2package.class\fP\f2#\fP\f2member\fP and \f2label\fP. The main difference is that \f2{@link}\fP generates an in\-line link rather than placing the link in the "See Also" section. Also, the \f2{@link}\fP tag begins and ends with curly braces to separate it from the rest of the in\-line text. If you need to use "}" inside the label, use the HTML entity notation &#125; 
 .LP
-There is no limit to the number of \f2{@link}\fP tags allowed in a sentence. You can use this tag in the main description part of any documentation comment or in the text portion of any tag (such as @deprecated, @return or @param).
+There is no limit to the number of \f2{@link}\fP tags allowed in a sentence. You can use this tag in the main description part of any documentation comment or in the text portion of any tag (such as @deprecated, @return or @param). 
 .LP
-For example, here is a comment that refers to the \f2getComponentAt(int, int)\fP method:
+For example, here is a comment that refers to the \f2getComponentAt(int, int)\fP method: 
 .nf
 \f3
 .fl
 Use the {@link #getComponentAt(int, int) getComponentAt} method.
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-From this, the standard doclet would generate the following HTML (assuming it refers to another class in the same package):
+From this, the standard doclet would generate the following HTML (assuming it refers to another class in the same package): 
 .nf
 \f3
 .fl
 Use the <a href="Component.html#getComponentAt(int, int)">getComponentAt</a> method.
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-Which appears on the web page as:
+Which appears on the web page as: 
 .nf
 \f3
 .fl
 Use the getComponentAt method.
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-You can extend \f2{@link}\fP to link to classes not being documented by using the \f2\-link\fP option.
+You can extend \f2{@link}\fP to link to classes not being documented by using the \f2\-link\fP option. 
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing {@link} tags\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#{@link}.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#{@link}. 
 .LP
 .TP 3
-{@linkplain\  package.class#member\  label}
-Identical to \f2{@link}\fP, except the link's label is displayed in plain text than code font. Useful when the label is plain text. Example:
+{@linkplain\  package.class#member\  label} 
+Identical to \f2{@link}\fP, except the link's label is displayed in plain text than code font. Useful when the label is plain text. Example: 
 .nf
 \f3
 .fl
      Refer to {@linkplain add() the overridden method}.
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-This would display as:
+This would display as: 
 .LP
-Refer to the overridden method.
+Refer to the overridden method. 
 .LP
 .TP 3
-{@literal\  text}
-Displays \f2text\fP without interpreting the text as HTML markup or nested javadoc tags. This enables you to use regular angle brackets (\f2<\fP and \f2>\fP) instead of the HTML entities (\f2<\fP and \f2>\fP) in doc comments, such as in parameter types (\f2<Object>\fP), inequalities (\f23 < 4\fP), or arrows (\f2<\-\fP). For example, the doc comment text:
+{@literal\  text} 
+Displays \f2text\fP without interpreting the text as HTML markup or nested javadoc tags. This enables you to use regular angle brackets (\f2<\fP and \f2>\fP) instead of the HTML entities (\f2<\fP and \f2>\fP) in doc comments, such as in parameter types (\f2<Object>\fP), inequalities (\f23 < 4\fP), or arrows (\f2<\-\fP). For example, the doc comment text: 
 .nf
 \f3
 .fl
      \fP\f4{@literal A<B>C}\fP\f3
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-displays unchanged in the generated HTML page in your browser, as:
+displays unchanged in the generated HTML page in your browser, as: 
 .LP
-\f2\ \ \ \ \ \fPA<B>C
+\f2\ \ \ \ \ \fPA<B>C  
 .LP
-The noteworthy point is that the \f2<B>\fP is not interpreted as bold (and it is not in code font).
+The noteworthy point is that the \f2<B>\fP is not interpreted as bold (and it is not in code font). 
 .LP
-If you want the same functionality but with the text in code font, use \f2{@code}\fP.
+If you want the same functionality but with the text in code font, use \f2{@code}\fP. 
 .LP
 .TP 3
-@param\  parameter\-name description
-Adds a parameter with the specified \f2parameter\-name\fP followed by the specified \f2description\fP to the "Parameters" section. When writing the doc comment, you may continue the \f2description\fP onto multiple lines. This tag is valid only in a doc comment for a method, constructor or class.
+@param\  parameter\-name description 
+Adds a parameter with the specified \f2parameter\-name\fP followed by the specified \f2description\fP to the "Parameters" section. When writing the doc comment, you may continue the \f2description\fP onto multiple lines. This tag is valid only in a doc comment for a method, constructor or class. 
 .LP
-The \f2parameter\-name\fP can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method or constructor. Use angle brackets around this parameter name to specify the use of a type parameter.
+The \f2parameter\-name\fP can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method or constructor. Use angle brackets around this parameter name to specify the use of a type parameter. 
 .LP
-Example of a type parameter of a class:
+Example of a type parameter of a class: 
 .nf
 \f3
 .fl
@@ -1322,12 +1324,12 @@
 .fl
      }
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-Example of a type parameter of a method:
+Example of a type parameter of a method: 
 .nf
 \f3
 .fl
@@ -1347,45 +1349,45 @@
 .fl
      }
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing @param tags\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@param.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@param. 
 .LP
 .TP 3
-@return\  description
-Adds a "Returns" section with the \f2description\fP text. This text should describe the return type and permissible range of values. This tag is valid only in a doc comment for a method.
+@return\  description 
+Adds a "Returns" section with the \f2description\fP text. This text should describe the return type and permissible range of values. This tag is valid only in a doc comment for a method. 
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing @return tags\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@return.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@return. 
 .LP
 .TP 3
-@see\  reference
-Adds a "See Also" heading with a link or text entry that points to \f2reference\fP. A doc comment may contain any number of \f2@see\fP tags, which are all grouped under the same heading. The \f2@see\fP tag has three variations; the third form below is the most common. This tag is valid in any doc comment: overview, package, class, interface, constructor, method or field. For inserting an in\-line link within a sentence to a package, class or member, see \f2{@link}\fP.
+@see\  reference 
+Adds a "See Also" heading with a link or text entry that points to \f2reference\fP. A doc comment may contain any number of \f2@see\fP tags, which are all grouped under the same heading. The \f2@see\fP tag has three variations; the third form below is the most common. This tag is valid in any doc comment: overview, package, class, interface, constructor, method or field. For inserting an in\-line link within a sentence to a package, class or member, see \f2{@link}\fP. 
 .RS 3
 .TP 3
-@see "string"
-Adds a text entry for \f2string\fP. No link is generated. The \f2string\fP is a book or other reference to information not available by URL. The Javadoc tool distinguishes this from the previous cases by looking for a double\-quote (\f2"\fP) as the first character. For example:
+@see "string" 
+Adds a text entry for \f2string\fP. No link is generated. The \f2string\fP is a book or other reference to information not available by URL. The Javadoc tool distinguishes this from the previous cases by looking for a double\-quote (\f2"\fP) as the first character. For example: 
 .nf
 \f3
 .fl
      @see "The Java Programming Language"
 .fl
-
+            
 .fl
 \fP
 .fi
 .LP
-This generates text such as:
+This generates text such as:  
 .RE
 .RE
 .RS 3
@@ -1393,13 +1395,13 @@
 .RS 3
 .RS 3
 .TP 3
-See Also:
-"The Java Programming Language"
+See Also: 
+"The Java Programming Language" 
 .RE
 .RE
 .TP 3
-@see <a href="URL#value">label</a>
-Adds a link as defined by \f2URL\fP#\f2value\fP. The \f2URL\fP#\f2value\fP is a relative or absolute URL. The Javadoc tool distinguishes this from other cases by looking for a less\-than symbol (\f2<\fP) as the first character. For example:
+@see <a href="URL#value">label</a> 
+Adds a link as defined by \f2URL\fP#\f2value\fP. The \f2URL\fP#\f2value\fP is a relative or absolute URL. The Javadoc tool distinguishes this from other cases by looking for a less\-than symbol (\f2<\fP) as the first character. For example: 
 .nf
 \f3
 .fl
@@ -1407,31 +1409,31 @@
 .fl
 \fP
 .fi
-This generates a link such as:
+This generates a link such as: 
 .RS 3
 .TP 3
-See Also:
-Java Spec
+See Also: 
+Java Spec 
 .RE
 .TP 3
-@see\  package.class#member\  label
-Adds a link, with visible text \f2label\fP, that points to the documentation for the specified name in the Java Language that is referenced. The \f2label\fP is optional; if omitted, the name appears instead as the visible text, suitably shortened \-\- see How a name is displayed. Use \-noqualifier to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto\-generated visible text.
+@see\  package.class#member\  label 
+Adds a link, with visible text \f2label\fP, that points to the documentation for the specified name in the Java Language that is referenced. The \f2label\fP is optional; if omitted, the name appears instead as the visible text, suitably shortened \-\- see How a name is displayed. Use \-noqualifier to globally remove the package name from this visible text. Use the label when you want the visible text to be different from the auto\-generated visible text. 
 .LP
-Only in version 1.2, just the name but not the label would automatically appear in <code> HTML tags, Starting with 1.2.2, the <code> is always included around the visible text, whether or not a label is used.
+Only in version 1.2, just the name but not the label would automatically appear in <code> HTML tags, Starting with 1.2.2, the <code> is always included around the visible text, whether or not a label is used. 
 .LP
 .RS 3
 .TP 2
 o
-\f4package.class\fP\f4#\fP\f4member\fP is any valid program element name that is referenced \-\- a package, class, interface, constructor, method or field name \-\- except that the character ahead of the member name should be a hash character (\f2#\fP). The \f2class\fP represents any top\-level or nested class or interface. The \f2member\fP represents any constructor, method or field (not a nested class or interface). If this name is in the documented classes, the Javadoc tool will automatically create a link to it. To create links to external referenced classes, use the \f2\-link\fP option. Use either of the other two \f2@see\fP forms for referring to documentation of a name that does not belong to a referenced class. This argument is described at greater length below under Specifying a Name.
+\f4package.class\fP\f4#\fP\f4member\fP is any valid program element name that is referenced \-\- a package, class, interface, constructor, method or field name \-\- except that the character ahead of the member name should be a hash character (\f2#\fP). The \f2class\fP represents any top\-level or nested class or interface. The \f2member\fP represents any constructor, method or field (not a nested class or interface). If this name is in the documented classes, the Javadoc tool will automatically create a link to it. To create links to external referenced classes, use the \f2\-link\fP option. Use either of the other two \f2@see\fP forms for referring to documentation of a name that does not belong to a referenced class. This argument is described at greater length below under Specifying a Name. 
 .TP 2
 o
-\f4label\fP is optional text that is visible as the link's label. The \f2label\fP can contain whitespace. If \f2label\fP is omitted, then \f2package.class.member\fP will appear, suitably shortened relative to the current class and package \-\- see How a name is displayed.
+\f4label\fP is optional text that is visible as the link's label. The \f2label\fP can contain whitespace. If \f2label\fP is omitted, then \f2package.class.member\fP will appear, suitably shortened relative to the current class and package \-\- see How a name is displayed. 
 .TP 2
 o
-A space is the delimiter between \f2package.class\fP\f2#\fP\f2member\fP and \f2label\fP. A space inside parentheses does not indicate the start of a label, so spaces may be used between parameters in a method.
+A space is the delimiter between \f2package.class\fP\f2#\fP\f2member\fP and \f2label\fP. A space inside parentheses does not indicate the start of a label, so spaces may be used between parameters in a method. 
 .RE
 .LP
-\f3Example\fP \- In this example, an \f2@see\fP tag (in the \f2Character\fP class) refers to the \f2equals\fP method in the \f2String\fP class. The tag includes both arguments: the name "\f2String#equals(Object)\fP" and the label "\f2equals\fP".
+\f3Example\fP \- In this example, an \f2@see\fP tag (in the \f2Character\fP class) refers to the \f2equals\fP method in the \f2String\fP class. The tag includes both arguments: the name "\f2String#equals(Object)\fP" and the label "\f2equals\fP". 
 .nf
 \f3
 .fl
@@ -1443,7 +1445,7 @@
 .fl
 \fP
 .fi
-The standard doclet produces HTML something like this:
+The standard doclet produces HTML something like this: 
 .nf
 \f3
 .fl
@@ -1457,18 +1459,19 @@
 .fl
 \fP
 .fi
-Which looks something like this in a browser, where the label is the visible link text:
+Which looks something like this in a browser, where the label is the visible link text: 
 .RS 3
 .TP 3
-See Also:
-equals
+See Also: 
+equals 
 .RE
 .LP
-\f3Specifying a name\fP \- This \f2package.class\fP\f2#\fP\f2member\fP name can be either fully\-qualified, such as \f2java.lang.String#toUpperCase()\fP or not, such as \f2String#toUpperCase()\fP or \f2#toUpperCase()\fP. If less than fully\-qualified, the Javadoc tool uses the normal Java compiler search order to find it, further described below in Search order for @see. The name can contain whitespace within parentheses, such as between method arguments.
+\f3Specifying a name\fP \- This \f2package.class\fP\f2#\fP\f2member\fP name can be either fully\-qualified, such as \f2java.lang.String#toUpperCase()\fP or not, such as \f2String#toUpperCase()\fP or \f2#toUpperCase()\fP. If less than fully\-qualified, the Javadoc tool uses the normal Java compiler search order to find it, further described below in Search order for @see. The name can contain whitespace within parentheses, such as between method arguments. 
 .LP
-Of course the advantage of providing shorter, "partially\-qualified" names is that they are shorter to type and there is less clutter in the source code. The following table shows the different forms of the name, where \f2Class\fP can be a class or interface, \f2Type\fP can be a class, interface, array, or primitive, and \f2method\fP can be a method or constructor.
+Of course the advantage of providing shorter, "partially\-qualified" names is that they are shorter to type and there is less clutter in the source code. The following table shows the different forms of the name, where \f2Class\fP can be a class or interface, \f2Type\fP can be a class, interface, array, or primitive, and \f2method\fP can be a method or constructor. 
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -1629,7 +1632,7 @@
 .ec
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u
+.ta \n(80u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'
@@ -1645,7 +1648,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u
+.ta \n(80u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'
@@ -1661,7 +1664,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u
+.ta \n(80u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'
@@ -1677,7 +1680,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u
+.ta \n(80u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'
@@ -1699,54 +1702,56 @@
 .rm b+
 .rm c+
 .rm d+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-58
 .LP
-The following notes apply to the above table:
+The following notes apply to the above table: 
 .RS 3
 .TP 2
 o
-The first set of forms (with no class or package) will cause the Javadoc tool to search only through the current class's hierarchy. It will find a member of the current class or interface, one of its superclasses or superinterfaces, or one of its enclosing classes or interfaces (search steps 1\-3). It will not search the rest of the current package or other packages (search steps 4\-5).
+The first set of forms (with no class or package) will cause the Javadoc tool to search only through the current class's hierarchy. It will find a member of the current class or interface, one of its superclasses or superinterfaces, or one of its enclosing classes or interfaces (search steps 1\-3). It will not search the rest of the current package or other packages (search steps 4\-5). 
 .TP 2
 o
-If any method or constructor is entered as a name with no parentheses, such as \f2getValue\fP, and if there is no field with the same name, the Javadoc tool will correctly create a link to it, but will print a warning message reminding you to add the parentheses and arguments. If this method is overloaded, the Javadoc tool will link to the first method its search encounters, which is unspecified.
+If any method or constructor is entered as a name with no parentheses, such as \f2getValue\fP, and if there is no field with the same name, the Javadoc tool will correctly create a link to it, but will print a warning message reminding you to add the parentheses and arguments. If this method is overloaded, the Javadoc tool will link to the first method its search encounters, which is unspecified. 
 .TP 2
 o
-Nested classes must be specified as \f2outer\fP\f2.\fP\f2inner\fP, not simply \f2inner\fP, for all forms.
+Nested classes must be specified as \f2outer\fP\f2.\fP\f2inner\fP, not simply \f2inner\fP, for all forms. 
 .TP 2
 o
-As stated, the hash character (\f2#\fP), rather than a dot (\f2.\fP) separates a member from its class. This enables the Javadoc tool to resolve ambiguities, since the dot also separates classes, nested classes, packages, and subpackages. However, the Javadoc tool is generally lenient and will properly parse a dot if you know there is no ambiguity, though it will print a warning.
+As stated, the hash character (\f2#\fP), rather than a dot (\f2.\fP) separates a member from its class. This enables the Javadoc tool to resolve ambiguities, since the dot also separates classes, nested classes, packages, and subpackages. However, the Javadoc tool is generally lenient and will properly parse a dot if you know there is no ambiguity, though it will print a warning. 
 .RE
 .LP
-\f3Search order for @see\fP \- the Javadoc tool will process a \f2@see\fP tag that appears in a source file (.java), package file (package.html or package\-info.java) or overview file (overview.html). In the latter two files, you must fully\-qualify the name you supply with \f2@see\fP. In a source file, you can specify a name that is fully\-qualified or partially\-qualified.
+\f3Search order for @see\fP \- the Javadoc tool will process a \f2@see\fP tag that appears in a source file (.java), package file (package.html or package\-info.java) or overview file (overview.html). In the latter two files, you must fully\-qualify the name you supply with \f2@see\fP. In a source file, you can specify a name that is fully\-qualified or partially\-qualified. 
 .LP
-When the Javadoc tool encounters a \f2@see\fP tag in a \f2.java\fP file that is \f2not\fP fully qualified, it searches for the specified name in the same order as the Java compiler would (except the Javadoc tool will not detect certain namespace ambiguities, since it assumes the source code is free of these errors). This search order is formally defined in the \f2Java Language Specification\fP. The Javadoc tool searches for that name through all related and imported classes and packages. In particular, it searches in this order:
+When the Javadoc tool encounters a \f2@see\fP tag in a \f2.java\fP file that is \f2not\fP fully qualified, it searches for the specified name in the same order as the Java compiler would (except the Javadoc tool will not detect certain namespace ambiguities, since it assumes the source code is free of these errors). This search order is formally defined in the \f2Java Language Specification\fP. The Javadoc tool searches for that name through all related and imported classes and packages. In particular, it searches in this order: 
 .RS 3
 .TP 3
 1.
-the current class or interface
+the current class or interface 
 .TP 3
 2.
-any enclosing classes and interfaces, searching closest first
+any enclosing classes and interfaces, searching closest first 
 .TP 3
 3.
-any superclasses and superinterfaces, searching closest first
+any superclasses and superinterfaces, searching closest first 
 .TP 3
 4.
-the current package
+the current package 
 .TP 3
 5.
-any imported packages, classes and interfaces, searching in the order of the import statement
+any imported packages, classes and interfaces, searching in the order of the import statement 
 .RE
 .LP
-The Javadoc tool continues to search recursively through steps 1\-3 for each class it encounters until it finds a match. That is, after it searches through the current class and its enclosing class E, it will search through E's superclasses before E's enclosing classes.  In steps 4 and 5, the Javadoc tool does not search classes or interfaces within a package in any specified order (that order depends on the particular compiler). In step 5, the Javadoc tool looks in java.lang, since that is automatically imported by all programs.
+The Javadoc tool continues to search recursively through steps 1\-3 for each class it encounters until it finds a match. That is, after it searches through the current class and its enclosing class E, it will search through E's superclasses before E's enclosing classes.  In steps 4 and 5, the Javadoc tool does not search classes or interfaces within a package in any specified order (that order depends on the particular compiler). In step 5, the Javadoc tool looks in java.lang, since that is automatically imported by all programs. 
 .LP
-The Javadoc tool does not necessarily look in subclasses, nor will it look in other packages even if their documentation is being generated in the same run. For example, if the \f2@see\fP tag is in the \f2java.awt.event.KeyEvent\fP class and refers to a name in the \f2java.awt\fP package, javadoc does not look in that package unless that class imports it.
+The Javadoc tool does not necessarily look in subclasses, nor will it look in other packages even if their documentation is being generated in the same run. For example, if the \f2@see\fP tag is in the \f2java.awt.event.KeyEvent\fP class and refers to a name in the \f2java.awt\fP package, javadoc does not look in that package unless that class imports it. 
 .LP
-\f3How a name is displayed\fP \- If \f2label\fP is omitted, then \f2package.class.member\fP appears. In general, it is suitably shortened relative to the current class and package. By "shortened", we mean the Javadoc tool displays only the minimum name necessary. For example, if the \f2String.toUpperCase()\fP method contains references to a member of the same class and to a member of a different class, the class name is displayed only in the latter case, as shown in the following table.
+\f3How a name is displayed\fP \- If \f2label\fP is omitted, then \f2package.class.member\fP appears. In general, it is suitably shortened relative to the current class and package. By "shortened", we mean the Javadoc tool displays only the minimum name necessary. For example, if the \f2String.toUpperCase()\fP method contains references to a member of the same class and to a member of a different class, the class name is displayed only in the latter case, as shown in the following table. 
 .LP
 Use \-noqualifier to globally remove the package names.
 .br
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -1973,7 +1978,7 @@
 .ec
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u
+.ta \n(80u \n(81u \n(82u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Type of Reference\fP\h'|\n(41u'\h'|\n(42u'\f3Displays As\fP
@@ -1991,7 +1996,7 @@
 .ne \n(c|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u
+.ta \n(80u \n(81u \n(82u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'\f2@see String#toLowerCase()\fP\h'|\n(42u'
@@ -2018,7 +2023,7 @@
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u
+.ta \n(80u \n(81u \n(82u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'\h'|\n(42u'
@@ -2052,7 +2057,7 @@
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u
+.ta \n(80u \n(81u \n(82u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'\h'|\n(42u'
@@ -2093,125 +2098,126 @@
 .rm g+
 .rm h+
 .rm i+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-28
 .LP
 \f3Examples of @see\fP
 .br
-The comment to the right shows how the name would be displayed if the \f2@see\fP tag is in a class in another package, such as \f2java.applet.Applet\fP.
+The comment to the right shows how the name would be displayed if the \f2@see\fP tag is in a class in another package, such as \f2java.applet.Applet\fP. 
 .nf
 \f3
 .fl
-                                           See also:
+                                           See also: 
 .fl
-@see java.lang.String                   //  String                          \fP\f3
+@see java.lang.String                   //  String                          \fP\f3 
 .fl
-@see java.lang.String The String class  //  The String class                \fP\f3
+@see java.lang.String The String class  //  The String class                \fP\f3 
 .fl
-@see String                             //  String                          \fP\f3
+@see String                             //  String                          \fP\f3 
 .fl
-@see String#equals(Object)              //  String.equals(Object)           \fP\f3
+@see String#equals(Object)              //  String.equals(Object)           \fP\f3 
 .fl
-@see String#equals                      //  String.equals(java.lang.Object) \fP\f3
+@see String#equals                      //  String.equals(java.lang.Object) \fP\f3  
 .fl
-@see java.lang.Object#wait(long)        //  java.lang.Object.wait(long)     \fP\f3
+@see java.lang.Object#wait(long)        //  java.lang.Object.wait(long)     \fP\f3 
 .fl
-@see Character#MAX_RADIX                //  Character.MAX_RADIX             \fP\f3
+@see Character#MAX_RADIX                //  Character.MAX_RADIX             \fP\f3 
 .fl
-@see <a href="spec.html">Java Spec</a>  //  Java Spec           \fP\f3
+@see <a href="spec.html">Java Spec</a>  //  Java Spec           \fP\f3 
 .fl
-@see "The Java Programming Language"    //  "The Java Programming Language"        \fP\f3
+@see "The Java Programming Language"    //  "The Java Programming Language"        \fP\f3 
 .fl
 \fP
 .fi
-You can extend \f2@see\fP to link to classes not being documented by using the \f2\-link\fP option.
+You can extend \f2@see\fP to link to classes not being documented by using the \f2\-link\fP option. 
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing @see tags\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@see.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@see.  
 .RE
 .RE
 .LP
 .RS 3
 .TP 3
-@serial\  field\-description | include | exclude
-Used in the doc comment for a default serializable field.
+@serial\  field\-description | include | exclude 
+Used in the doc comment for a default serializable field. 
 .LP
-An optional \f2field\-description\fP should explain the meaning of the field and list the acceptable values. If needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page.
+An optional \f2field\-description\fP should explain the meaning of the field and list the acceptable values. If needed, the description can span multiple lines. The standard doclet adds this information to the serialized form page. 
 .LP
-If a serializable field was added to a class some time after the class was made serializable, a statement should be added to its main description to identify at which version it was added.
+If a serializable field was added to a class some time after the class was made serializable, a statement should be added to its main description to identify at which version it was added. 
 .LP
-The \f2include\fP and \f2exclude\fP arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows:
+The \f2include\fP and \f2exclude\fP arguments identify whether a class or package should be included or excluded from the serialized form page. They work as follows: 
 .RS 3
 .TP 2
 o
-A public or protected class that implements \f2Serializable\fP is \f2included\fP unless that class (or its package) is marked \f2@serial exclude\fP.
+A public or protected class that implements \f2Serializable\fP is \f2included\fP unless that class (or its package) is marked \f2@serial exclude\fP. 
 .TP 2
 o
-A private or package\-private class that implements \f2Serializable\fP is \f2excluded\fP unless that class (or its package) is marked \f2@serial include\fP.
+A private or package\-private class that implements \f2Serializable\fP is \f2excluded\fP unless that class (or its package) is marked \f2@serial include\fP. 
 .RE
 .LP
-Examples: The \f2javax.swing\fP package is marked \f2@serial exclude\fP (in \f2package.html\fP or \f2package\-info.java\fP). The public class \f2java.security.BasicPermission\fP is marked \f2@serial exclude\fP. The package\-private class \f2java.util.PropertyPermissionCollection\fP is marked \f2@serial include\fP.
+Examples: The \f2javax.swing\fP package is marked \f2@serial exclude\fP (in \f2package.html\fP or \f2package\-info.java\fP). The public class \f2java.security.BasicPermission\fP is marked \f2@serial exclude\fP. The package\-private class \f2java.util.PropertyPermissionCollection\fP is marked \f2@serial include\fP. 
 .LP
-The tag @serial at a class level overrides @serial at a package level.
+The tag @serial at a class level overrides @serial at a package level. 
 .LP
 For more information about how to use these tags, along with an example, see "
 .na
 \f2Documenting Serializable Fields and Data for a Class\fP @
 .fi
-http://download.oracle.com/javase/7/docs/platform/serialization/spec/serial\-arch.html," Section 1.6 of the \f2Java Object Serialization Specification\fP. Also see the
+http://docs.oracle.com/javase/7/docs/platform/serialization/spec/serial\-arch.html," Section 1.6 of the \f2Java Object Serialization Specification\fP. Also see the 
 .na
 \f2Serialization FAQ\fP @
 .fi
-http://java.sun.com/javase/technologies/core/basic/serializationFAQ.jsp#javadoc_warn_missing, which covers common questions, such as "Why do I see javadoc warnings stating that I am missing @serial tags for private fields if I am not running javadoc with the \-private switch?". Also see
+http://java.sun.com/javase/technologies/core/basic/serializationFAQ.jsp#javadoc_warn_missing, which covers common questions, such as "Why do I see javadoc warnings stating that I am missing @serial tags for private fields if I am not running javadoc with the \-private switch?". Also see 
 .na
 \f2Sun's criteria\fP @
 .fi
-http://java.sun.com/j2se/javadoc/writingapispecs/serialized\-criteria.html for including classes in the serialized form specification.
+http://java.sun.com/j2se/javadoc/writingapispecs/serialized\-criteria.html for including classes in the serialized form specification. 
 .LP
 .TP 3
-@serialField\  field\-name\  field\-type\  field\-description
-Documents an \f2ObjectStreamField\fP component of a \f2Serializable\fP class's \f2serialPersistentFields\fP member. One \f2@serialField\fP tag should be used for each \f2ObjectStreamField\fP component.
+@serialField\  field\-name\  field\-type\  field\-description 
+Documents an \f2ObjectStreamField\fP component of a \f2Serializable\fP class's \f2serialPersistentFields\fP member. One \f2@serialField\fP tag should be used for each \f2ObjectStreamField\fP component. 
 .LP
 .TP 3
-@serialData\  data\-description
-The \f2data\-description\fP documents the types and order of data in the serialized form. Specifically, this data includes the optional data written by the \f2writeObject\fP method and all data (including base classes) written by the \f2Externalizable.writeExternal\fP method.
+@serialData\  data\-description 
+The \f2data\-description\fP documents the types and order of data in the serialized form. Specifically, this data includes the optional data written by the \f2writeObject\fP method and all data (including base classes) written by the \f2Externalizable.writeExternal\fP method. 
 .LP
-The \f2@serialData\fP tag can be used in the doc comment for the \f2writeObject\fP, \f2readObject\fP, \f2writeExternal\fP, \f2readExternal\fP, \f2writeReplace\fP, and \f2readResolve\fP methods.
+The \f2@serialData\fP tag can be used in the doc comment for the \f2writeObject\fP, \f2readObject\fP, \f2writeExternal\fP, \f2readExternal\fP, \f2writeReplace\fP, and \f2readResolve\fP methods. 
 .LP
 .TP 3
-@since\  since\-text
-Adds a "Since" heading with the specified \f2since\-text\fP to the generated documentation. The text has no special internal structure. This tag is valid in any doc comment: overview, package, class, interface, constructor, method or field. This tag means that this change or feature has existed since the software release specified by the \f2since\-text\fP. For example:
+@since\  since\-text 
+Adds a "Since" heading with the specified \f2since\-text\fP to the generated documentation. The text has no special internal structure. This tag is valid in any doc comment: overview, package, class, interface, constructor, method or field. This tag means that this change or feature has existed since the software release specified by the \f2since\-text\fP. For example: 
 .nf
 \f3
 .fl
     @since 1.5
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-For source code in the Java platform, this tag indicates the version of the Java platform API specification (not necessarily when it was added to the reference implementation). Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags if the prgram element is used by more than one API.
+For source code in the Java platform, this tag indicates the version of the Java platform API specification (not necessarily when it was added to the reference implementation). Multiple @since tags are allowed and are treated like multiple @author tags. You could use multiple tags if the prgram element is used by more than one API. 
 .LP
 .TP 3
-@throws\  class\-name\  description
-The \f2@throws\fP and \f2@exception\fP tags are synonyms. Adds a "Throws" subheading to the generated documentation, with the \f2class\-name\fP and \f2description\fP text. The \f2class\-name\fP is the name of the exception that may be thrown by the method. This tag is valid only in the doc comment for a method or constructor. If this class is not fully\-specified, the Javadoc tool uses the search order to look up this class. Multiple \f2@throws\fP tags can be used in a given doc comment for the same or different exceptions.
+@throws\  class\-name\  description 
+The \f2@throws\fP and \f2@exception\fP tags are synonyms. Adds a "Throws" subheading to the generated documentation, with the \f2class\-name\fP and \f2description\fP text. The \f2class\-name\fP is the name of the exception that may be thrown by the method. This tag is valid only in the doc comment for a method or constructor. If this class is not fully\-specified, the Javadoc tool uses the search order to look up this class. Multiple \f2@throws\fP tags can be used in a given doc comment for the same or different exceptions. 
 .LP
-To ensure that all checked exceptions are documented, if a \f2@throws\fP tag does not exist for an exception in the throws clause, the Javadoc tool automatically adds that exception to the HTML output (with no description) as if it were documented with @throws tag.
+To ensure that all checked exceptions are documented, if a \f2@throws\fP tag does not exist for an exception in the throws clause, the Javadoc tool automatically adds that exception to the HTML output (with no description) as if it were documented with @throws tag. 
 .LP
-The \f2@throws\fP documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use {@inheritDoc} to force @throws to inherit documentation.
+The \f2@throws\fP documentation is copied from an overridden method to a subclass only when the exception is explicitly declared in the overridden method. The same is true for copying from an interface method to an implementing method. You can use {@inheritDoc} to force @throws to inherit documentation. 
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing @throws tags\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@exception.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@exception. 
 .LP
 .TP 3
-{@value\  package.class#field}
-When \f2{@value}\fP is used (without any argument) in the doc comment of a static field, it displays the value of that constant:
+{@value\  package.class#field} 
+When \f2{@value}\fP is used (without any argument) in the doc comment of a static field, it displays the value of that constant: 
 .nf
 \f3
 .fl
@@ -2223,12 +2229,12 @@
 .fl
     public static final String SCRIPT_START = "<script>"
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-When used with argument \f2package.class#field\fP in any doc comment, it displays the value of the specified constant:
+When used with argument \f2package.class#field\fP in any doc comment, it displays the value of the specified constant: 
 .nf
 \f3
 .fl
@@ -2242,36 +2248,36 @@
 .fl
     }
 .fl
-
+        
 .fl
 \fP
 .fi
 .LP
-The argument \f2package.class#field\fP takes a form identical to that of the @see argument, except that the member must be a static field.
+The argument \f2package.class#field\fP takes a form identical to that of the @see argument, except that the member must be a static field. 
 .LP
-These values of these constants are also displayed on the
+These values of these constants are also displayed on the 
 .na
 \f2Constant Field Values\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/constant\-values.html page.
+http://docs.oracle.com/javase/7/docs/api/constant\-values.html page. 
 .LP
 .TP 3
-@version\  version\-text
-Adds a "Version" subheading with the specified \f2version\-text\fP to the generated docs when the \-version option is used. This tag is intended to hold the current version number of the software that this code is part of (as opposed to @since, which holds the version number where this code was introduced). The \f2version\-text\fP has no special internal structure. To see where the version tag can be used, see Where Tags Can Be Used.
+@version\  version\-text 
+Adds a "Version" subheading with the specified \f2version\-text\fP to the generated docs when the \-version option is used. This tag is intended to hold the current version number of the software that this code is part of (as opposed to @since, which holds the version number where this code was introduced). The \f2version\-text\fP has no special internal structure. To see where the version tag can be used, see Where Tags Can Be Used. 
 .LP
-A doc comment may contain multiple \f2@version\fP tags. If it makes sense, you can specify one version number per \f2@version\fP tag or multiple version numbers per tag. In the former case, the Javadoc tool inserts a comma (\f2,\fP) and space between names. In the latter case, the entire text is simply copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than comma.
+A doc comment may contain multiple \f2@version\fP tags. If it makes sense, you can specify one version number per \f2@version\fP tag or multiple version numbers per tag. In the former case, the Javadoc tool inserts a comma (\f2,\fP) and space between names. In the latter case, the entire text is simply copied to the generated document without being parsed. Therefore, you can use multiple names per line if you want a localized name separator other than comma. 
 .LP
-For more details, see
+For more details, see 
 .na
 \f2writing @version tags\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@version.
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#@version.  
 .RE
-.SS
+.SS 
 Where Tags Can Be Used
 .LP
 The following sections describe where the tags can be used. Note that these tags can be used in all doc comments: \f2@see\fP, \f2@since\fP, \f2@deprecated\fP, \f2{@link}\fP, \f2{@linkplain}\fP, and \f2{@docroot}\fP.
-.SS
+.SS 
 Overview Documentation Tags
 .LP
 Overview tags are tags that can appear in the documentation comment for the overview page (which resides in the source file typically named \f2overview.html\fP). Like in any other documentation comments, these tags must appear after the main description.
@@ -2282,27 +2288,27 @@
 .RS 3
 .TP 2
 o
-\f2@see\fP
+\f2@see\fP 
 .TP 2
 o
-\f2@since\fP
+\f2@since\fP 
 .TP 2
 o
-\f2@author\fP
+\f2@author\fP 
 .TP 2
 o
-\f2@version\fP
+\f2@version\fP 
 .TP 2
 o
-\f2{@link}\fP
+\f2{@link}\fP 
 .TP 2
 o
-\f2{@linkplain}\fP
+\f2{@linkplain}\fP 
 .TP 2
 o
-\f2{@docRoot}\fP
+\f2{@docRoot}\fP 
 .RE
-.SS
+.SS 
 Package Documentation Tags
 .LP
 Package tags are tags that can appear in the documentation comment for a package (which resides in the source file named \f2package.html\fP or \f2package\-info.java\fP). The \f2@serial\fP tag can only be used here with the \f2include\fP or \f2exclude\fP argument.
@@ -2311,30 +2317,30 @@
 .RS 3
 .TP 2
 o
-\f2@see\fP
+\f2@see\fP 
 .TP 2
 o
-\f2@since\fP
+\f2@since\fP 
 .TP 2
 o
-\f2@serial\fP
+\f2@serial\fP 
 .TP 2
 o
-\f2@author\fP
+\f2@author\fP 
 .TP 2
 o
-\f2@version\fP
+\f2@version\fP 
 .TP 2
 o
-\f2{@link}\fP
+\f2{@link}\fP 
 .TP 2
 o
-\f2{@linkplain}\fP
+\f2{@linkplain}\fP 
 .TP 2
 o
-\f2{@docRoot}\fP
+\f2{@docRoot}\fP 
 .RE
-.SS
+.SS 
 Class and Interface Documentation Tags
 .LP
 The following are tags that can appear in the documentation comment for a class or interface. The \f2@serial\fP tag can only be used here with the \f2include\fP or \f2exclude\fP argument.
@@ -2343,31 +2349,31 @@
 .RS 3
 .TP 2
 o
-\f2@see\fP
+\f2@see\fP 
 .TP 2
 o
-\f2@since\fP
+\f2@since\fP 
 .TP 2
 o
-\f2@deprecated\fP
+\f2@deprecated\fP 
 .TP 2
 o
-\f2@serial\fP
+\f2@serial\fP 
 .TP 2
 o
-\f2@author\fP
+\f2@author\fP 
 .TP 2
 o
-\f2@version\fP
+\f2@version\fP 
 .TP 2
 o
-\f2{@link}\fP
+\f2{@link}\fP 
 .TP 2
 o
-\f2{@linkplain}\fP
+\f2{@linkplain}\fP  
 .TP 2
 o
-\f2{@docRoot}\fP
+\f2{@docRoot}\fP 
 .RE
 \f3An example of a class comment:\fP
 .nf
@@ -2407,7 +2413,7 @@
 .fl
 \fP
 .fi
-.SS
+.SS 
 Field Documentation Tags
 .LP
 The following are the tags that can appear in
@@ -2416,31 +2422,31 @@
 .RS 3
 .TP 2
 o
-\f2@see\fP
+\f2@see\fP 
 .TP 2
 o
-\f2@since\fP
+\f2@since\fP 
 .TP 2
 o
-\f2@deprecated\fP
+\f2@deprecated\fP 
 .TP 2
 o
-\f2@serial\fP
+\f2@serial\fP 
 .TP 2
 o
-\f2@serialField\fP
+\f2@serialField\fP 
 .TP 2
 o
-\f2{@link}\fP
+\f2{@link}\fP 
 .TP 2
 o
-\f2{@linkplain}\fP
+\f2{@linkplain}\fP 
 .TP 2
 o
-\f2{@docRoot}\fP
+\f2{@docRoot}\fP 
 .TP 2
 o
-\f2{@value}\fP
+\f2{@value}\fP 
 .RE
 \f3An example of a field comment:\fP
 .nf
@@ -2460,7 +2466,7 @@
 .fl
 \fP
 .fi
-.SS
+.SS 
 Constructor and Method Documentation Tags
 .LP
 The following are the tags that can appear in the documentation comment for a constructor or method, except for \f2@return\fP, which cannot appear in a constructor, and \f2{@inheritDoc}\fP, which has certain restrictions. The \f2@serialData\fP tag can only be used in the doc comment for certain serialization methods.
@@ -2469,37 +2475,37 @@
 .RS 3
 .TP 2
 o
-\f2@see\fP
+\f2@see\fP 
 .TP 2
 o
-\f2@since\fP
+\f2@since\fP 
 .TP 2
 o
-\f2@deprecated\fP
+\f2@deprecated\fP 
 .TP 2
 o
-\f2@param\fP
+\f2@param\fP 
 .TP 2
 o
-\f2@return\fP
+\f2@return\fP 
 .TP 2
 o
-\f2@throws\fP and \f2@exception\fP
+\f2@throws\fP and \f2@exception\fP 
 .TP 2
 o
-\f2@serialData\fP
+\f2@serialData\fP 
 .TP 2
 o
-\f2{@link}\fP
+\f2{@link}\fP 
 .TP 2
 o
-\f2{@linkplain}\fP
+\f2{@linkplain}\fP 
 .TP 2
 o
-\f2{@inheritDoc}\fP
+\f2{@inheritDoc}\fP 
 .TP 2
 o
-\f2{@docRoot}\fP
+\f2{@docRoot}\fP 
 .RE
 \f3An example of a method doc comment:\fP
 .nf
@@ -2507,7 +2513,7 @@
 .fl
     /**
 .fl
-     * Returns the character at the specified index. An index
+     * Returns the character at the specified index. An index 
 .fl
      * ranges from <code>0</code> to <code>length() \- 1</code>.
 .fl
@@ -2517,9 +2523,9 @@
 .fl
      * @return    the desired character.
 .fl
-     * @exception StringIndexOutOfRangeException
+     * @exception StringIndexOutOfRangeException 
 .fl
-     *              if the index is not in the range <code>0</code>
+     *              if the index is not in the range <code>0</code> 
 .fl
      *              to <code>length()\-1</code>.
 .fl
@@ -2541,6 +2547,7 @@
 .LP
 The options are:
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -2774,7 +2781,7 @@
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u \n(82u
+.ta \n(80u \n(81u \n(82u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'\h'|\n(42u'
@@ -2809,14 +2816,15 @@
 .rm a+
 .rm b+
 .rm c+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-127
 .LP
 Options shown in \f2italic\fP are the Javadoc core options, which are provided by the front end of the Javadoc tool and are available to all doclets. The standard doclet itself provides the non\-italic options.
-.SS
+.SS 
 Javadoc Options
 .RS 3
 .TP 3
-\-overview \ path/filename
+\-overview \ path/filename 
 Specifies that javadoc should retrieve the text for the overview documentation from the "source" file specified by \f2path/filename\fP and place it on the Overview page (\f2overview\-summary.html\fP). The \f2path/filename\fP is relative to the current directory.
 .br
 .br
@@ -2829,28 +2837,28 @@
 Note that the overview page is created only if you pass into javadoc two or more package names. For further explanation, see HTML Frames.)
 .br
 .br
-The title on the overview page is set by \f2\-doctitle\fP.
+The title on the overview page is set by \f2\-doctitle\fP.  
 .TP 3
-\-public
-Shows only public classes and members.
+\-public 
+Shows only public classes and members.  
 .TP 3
-\-protected
-Shows only protected and public classes and members. This is the default.
+\-protected 
+Shows only protected and public classes and members. This is the default.  
 .TP 3
-\-package
-Shows only package, protected, and public classes and members.
+\-package 
+Shows only package, protected, and public classes and members.  
 .TP 3
-\-private
-Shows all classes and members.
+\-private 
+Shows all classes and members.  
 .TP 3
-\-help
-Displays the online help, which lists these javadoc and doclet command line options.
+\-help 
+Displays the online help, which lists these javadoc and doclet command line options.  
 .TP 3
-\-doclet\  class
+\-doclet\  class 
 Specifies the class file that starts the doclet used in generating the documentation. Use the fully\-qualified name. This doclet defines the content and formats the output. If the \f4\-doclet\fP option is not used, javadoc uses the standard doclet for generating the default HTML format. This class must contain the \f2start(Root)\fP method. The path to this starting class is defined by the \f2\-docletpath\fP option.
 .br
 .br
-For example, to call the MIF doclet, use:
+For example, to call the MIF doclet, use: 
 .nf
 \f3
 .fl
@@ -2858,17 +2866,17 @@
 .fl
 \fP
 .fi
-For full, working examples of running a particular doclet, see the
+For full, working examples of running a particular doclet, see the 
 .na
 \f2MIF Doclet documentation\fP @
 .fi
-http://java.sun.com/j2se/javadoc/mifdoclet/docs/mifdoclet.html.
+http://java.sun.com/j2se/javadoc/mifdoclet/docs/mifdoclet.html.  
 .TP 3
-\-docletpath\  classpathlist
+\-docletpath\  classpathlist 
 Specifies the path to the doclet starting class file (specified with the \f2\-doclet\fP option) and any jar files it depends on. If the starting class file is in a jar file, then this specifies the path to that jar file, as shown in the example below. You can specify an absolute path or a path relative to the current directory. If \f2classpathlist\fP contains multiple paths or jar files, they should be separated with a colon (:) on Solaris and a semi\-colon (;) on Windows. This option is not necessary if the doclet starting class is already in the search path.
 .br
 .br
-Example of path to jar file that contains the starting doclet class file. Notice the jar filename is included.
+Example of path to jar file that contains the starting doclet class file. Notice the jar filename is included. 
 .nf
 \f3
 .fl
@@ -2876,7 +2884,7 @@
 .fl
 \fP
 .fi
-Example of path to starting doclet class file. Notice the class filename is omitted.
+Example of path to starting doclet class file. Notice the class filename is omitted. 
 .nf
 \f3
 .fl
@@ -2884,38 +2892,38 @@
 .fl
 \fP
 .fi
-For full, working examples of running a particular doclet, see the
+For full, working examples of running a particular doclet, see the 
 .na
 \f2MIF Doclet documentation\fP @
 .fi
-http://java.sun.com/j2se/javadoc/mifdoclet/docs/mifdoclet.html.
+http://java.sun.com/j2se/javadoc/mifdoclet/docs/mifdoclet.html.  
 .TP 3
-\-1.1
-\f2This feature has been removed from Javadoc 1.4. There is no replacement for it. This option created documentation with the appearance and functionality of documentation generated by Javadoc 1.1 (it never supported nested classes). If you need this option, use Javadoc 1.2 or 1.3 instead.\fP
+\-1.1 
+\f2This feature has been removed from Javadoc 1.4. There is no replacement for it. This option created documentation with the appearance and functionality of documentation generated by Javadoc 1.1 (it never supported nested classes). If you need this option, use Javadoc 1.2 or 1.3 instead.\fP  
 .TP 3
-\-source release
-Specifies the version of source code accepted. The following values for \f2release\fP are allowed:
+\-source release 
+Specifies the version of source code accepted. The following values for \f2release\fP are allowed: 
 .RS 3
 .TP 2
 o
-\f31.5\fP \- javadoc accepts code containing generics and other language features introduced in JDK 1.5. The compiler defaults to the 1.5 behavior if the \f3\-source\fP flag is not used.
+\f31.5\fP \- javadoc accepts code containing generics and other language features introduced in JDK 1.5. The compiler defaults to the 1.5 behavior if the \f3\-source\fP flag is not used. 
 .TP 2
 o
-\f31.4\fP \- javadoc accepts code containing assertions, which were introduced in JDK 1.4.
+\f31.4\fP \- javadoc accepts code containing assertions, which were introduced in JDK 1.4. 
 .TP 2
 o
-\f31.3\fP \- javadoc does \f2not\fP support assertions, generics, or other language features introduced after JDK 1.3.
+\f31.3\fP \- javadoc does \f2not\fP support assertions, generics, or other language features introduced after JDK 1.3. 
 .RE
-Use the value of \f2release\fP corresponding to that used when compiling the code with javac.
+Use the value of \f2release\fP corresponding to that used when compiling the code with javac.  
 .TP 3
-\-sourcepath\  sourcepathlist
+\-sourcepath\  sourcepathlist 
 Specifies the search paths for finding source files (\f2.java\fP) when passing package names or \f2\-subpackages\fP into the \f2javadoc\fP command. The \f2sourcepathlist\fP can contain multiple paths by separating them with a colon (\f2:\fP). The Javadoc tool will search in all subdirectories of the specified paths. Note that this option is not only used to locate the source files being documented, but also to find source files that are not being documented but whose comments are inherited by the source files being documented.
 .br
 .br
 Note that you can use the \f2\-sourcepath\fP option only when passing package names into the javadoc command \-\- it will not locate \f2.java\fP files passed into the \f2javadoc\fP command. (To locate \f2.java\fP files, cd to that directory or include the path ahead of each file, as shown at Documenting One or More Classes.) If \f2\-sourcepath\fP is omitted, javadoc uses the class path to find the source files (see \-classpath). Therefore, the default \-sourcepath is the value of class path. If \-classpath is omitted and you are passing package names into javadoc, it looks in the current directory (and subdirectories) for the source files.
 .br
 .br
-Set \f2sourcepathlist\fP to the root directory of the source tree for the package you are documenting. For example, suppose you want to document a package called \f2com.mypackage\fP whose source files are located at:
+Set \f2sourcepathlist\fP to the root directory of the source tree for the package you are documenting. For example, suppose you want to document a package called \f2com.mypackage\fP whose source files are located at: 
 .nf
 \f3
 .fl
@@ -2923,7 +2931,7 @@
 .fl
 \fP
 .fi
-In this case you would specify the \f2sourcepath\fP to \f2/home/user/src\fP, the directory that contains \f2com/mypackage\fP, and then supply the package name \f2com.mypackage\fP:
+In this case you would specify the \f2sourcepath\fP to \f2/home/user/src\fP, the directory that contains \f2com/mypackage\fP, and then supply the package name \f2com.mypackage\fP: 
 .nf
 \f3
 .fl
@@ -2933,7 +2941,7 @@
 This is easy to remember by noticing that if you concatenate the value of sourcepath and the package name together and change the dot to a slash "/", you end up with the full path to the package: \f2/home/user/src/com/mypackage\fP.
 .br
 .br
-To point to two source paths:
+To point to two source paths: 
 .nf
 \f3
 .fl
@@ -2941,18 +2949,18 @@
 .fl
 .fi
 .TP 3
-\-classpath\  classpathlist
-Specifies the paths where javadoc will look for referenced classes (\f2.class\fP files) \-\- these are the documented classes plus any classes referenced by those classes. The \f2classpathlist\fP can contain multiple paths by separating them with a colon (\f2:\fP). The Javadoc tool will search in all subdirectories of the specified paths. Follow the instructions in
+\-classpath\  classpathlist 
+Specifies the paths where javadoc will look for referenced classes (\f2.class\fP files) \-\- these are the documented classes plus any classes referenced by those classes. The \f2classpathlist\fP can contain multiple paths by separating them with a colon (\f2:\fP). The Javadoc tool will search in all subdirectories of the specified paths. Follow the instructions in 
 .na
 \f2class path\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#general documentation for specifying \f2classpathlist\fP.
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#general documentation for specifying \f2classpathlist\fP.
 .br
 .br
 If \f2\-sourcepath\fP is omitted, the Javadoc tool uses \f2\-classpath\fP to find the source files as well as class files (for backward compatibility). Therefore, if you want to search for source and class files in separate paths, use both \f2\-sourcepath\fP and \f2\-classpath\fP.
 .br
 .br
-For example, if you want to document \f2com.mypackage\fP, whose source files reside in the directory \f2/home/user/src/com/mypackage\fP, and if this package relies on a library in \f2/home/user/lib\fP, you would specify:
+For example, if you want to document \f2com.mypackage\fP, whose source files reside in the directory \f2/home/user/src/com/mypackage\fP, and if this package relies on a library in \f2/home/user/lib\fP, you would specify: 
 .nf
 \f3
 .fl
@@ -2962,23 +2970,23 @@
 As with other tools, if you do not specify \f2\-classpath\fP, the Javadoc tool uses the CLASSPATH environment variable, if it is set. If both are not set, the Javadoc tool searches for classes from the current directory.
 .br
 .br
-For an in\-depth description of how the Javadoc tool uses \f2\-classpath\fP to find user classes as it relates to extension classes and bootstrap classes, see
+For an in\-depth description of how the Javadoc tool uses \f2\-classpath\fP to find user classes as it relates to extension classes and bootstrap classes, see 
 .na
 \f2How Classes Are Found\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/findingclasses.html.
+http://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html.  
 .br
 .br
 As a special convenience, a class path element containing a basename of \f2*\fP is considered equivalent to specifying a list of all the files in the directory with the extension \f2.jar\fP or \f2.JAR\fP (a Java program cannot tell the difference between the two invocations).
 .br
 .br
-For example, if directory \f2foo\fP contains \f2a.jar\fP and \f2b.JAR\fP, then the class path element \f2foo/*\fP is expanded to a \f2A.jar:b.JAR\fP, except that the order of jar files is unspecified. All jar files in the specified directory, even hidden ones, are included in the list. A classpath entry consisting simply of \f2*\fP expands to a list of all the jar files in the current directory. The \f2CLASSPATH\fP environment variable, where defined, will be similarly expanded. Any classpath wildcard expansion occurs before the Java virtual machine is started \-\- no Java program will ever see unexpanded wildcards except by querying the environment. For example; by invoking \f2System.getenv("CLASSPATH")\fP.
+For example, if directory \f2foo\fP contains \f2a.jar\fP and \f2b.JAR\fP, then the class path element \f2foo/*\fP is expanded to a \f2A.jar:b.JAR\fP, except that the order of jar files is unspecified. All jar files in the specified directory, even hidden ones, are included in the list. A classpath entry consisting simply of \f2*\fP expands to a list of all the jar files in the current directory. The \f2CLASSPATH\fP environment variable, where defined, will be similarly expanded. Any classpath wildcard expansion occurs before the Java virtual machine is started \-\- no Java program will ever see unexpanded wildcards except by querying the environment. For example; by invoking \f2System.getenv("CLASSPATH")\fP.   
 .TP 3
-\-subpackages\ \ package1:package2:...
+\-subpackages\ \ package1:package2:... 
 Generates documentation from source files in the specified packages and recursively in their subpackages. This option is useful when adding new subpackages to the source code, as they are automatically included. Each \f2package\fP argument is any top\-level subpackage (such as \f2java\fP) or fully qualified package (such as \f2javax.swing\fP) that does not need to contain source files. Arguments are separated by colons (on all operating systmes). Wildcards are not needed or allowed. Use \f2\-sourcepath\fP to specify where to find the packages. This option is smart about not processing source files that are in the source tree but do not belong to the packages, as described at processing of source files.
 .br
 .br
-For example:
+For example: 
 .nf
 \f3
 .fl
@@ -2988,77 +2996,77 @@
 This command generates documentation for packages named "java" and "javax.swing" and all their subpackages.
 .br
 .br
-You can use \f2\-subpackages\fP in conjunction with \f2\-exclude\fP to exclude specific packages.
+You can use \f2\-subpackages\fP in conjunction with \f2\-exclude\fP to exclude specific packages.  
 .TP 3
-\-exclude\ \ packagename1:packagename2:...
-Unconditionally excludes the specified packages and their subpackages from the list formed by \f2\-subpackages\fP. It excludes those packages even if they would otherwise be included by some previous or later \f2\-subpackages\fP option. For example:
+\-exclude\ \ packagename1:packagename2:... 
+Unconditionally excludes the specified packages and their subpackages from the list formed by \f2\-subpackages\fP. It excludes those packages even if they would otherwise be included by some previous or later \f2\-subpackages\fP option. For example: 
 .nf
 \f3
 .fl
   % \fP\f3javadoc \-sourcepath /home/user/src \-subpackages java \-exclude java.net:java.lang\fP
 .fl
 .fi
-would include \f2java.io\fP, \f2java.util\fP, and \f2java.math\fP (among others), but would exclude packages rooted at \f2java.net\fP and \f2java.lang\fP. Notice this excludes \f2java.lang.ref\fP, a subpackage of \f2java.lang\fP).
+would include \f2java.io\fP, \f2java.util\fP, and \f2java.math\fP (among others), but would exclude packages rooted at \f2java.net\fP and \f2java.lang\fP. Notice this excludes \f2java.lang.ref\fP, a subpackage of \f2java.lang\fP).  
 .TP 3
-\-bootclasspath\  classpathlist
-Specifies the paths where the boot classes reside. These are nominally the Java platform classes. The bootclasspath is part of the search path the Javadoc tool will use to look up source and class files. See
+\-bootclasspath\  classpathlist 
+Specifies the paths where the boot classes reside. These are nominally the Java platform classes. The bootclasspath is part of the search path the Javadoc tool will use to look up source and class files. See 
 .na
 \f2How Classes Are Found\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/findingclasses.html#srcfiles. for more details. Separate directories in \f2classpathlist\fP with colons (:).
+http://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html#srcfiles. for more details. Separate directories in \f2classpathlist\fP with colons (:).  
 .TP 3
-\-extdirs\  dirlist
-Specifies the directories where extension classes reside. These are any classes that use the Java Extension mechanism. The extdirs is part of the search path the Javadoc tool will use to look up source and class files. See \f2\-classpath\fP (above) for more details. Separate directories in \f2dirlist\fP with colons (:).
+\-extdirs\  dirlist 
+Specifies the directories where extension classes reside. These are any classes that use the Java Extension mechanism. The extdirs is part of the search path the Javadoc tool will use to look up source and class files. See \f2\-classpath\fP (above) for more details. Separate directories in \f2dirlist\fP with colons (:).  
 .TP 3
-\-verbose
-Provides more detailed messages while javadoc is running. Without the verbose option, messages appear for loading the source files, generating the documentation (one message per source file), and sorting. The verbose option causes the printing of additional messages specifying the number of milliseconds to parse each java source file.
+\-verbose 
+Provides more detailed messages while javadoc is running. Without the verbose option, messages appear for loading the source files, generating the documentation (one message per source file), and sorting. The verbose option causes the printing of additional messages specifying the number of milliseconds to parse each java source file.  
 .TP 3
-\-quiet
-Shuts off non\-error and non\-warning messages, leaving only the warnings and errors appear, making them easier to view. Also suppresses the version string.
+\-quiet 
+Shuts off non\-error and non\-warning messages, leaving only the warnings and errors appear, making them easier to view. Also suppresses the version string.  
 .TP 3
-\-breakiterator\
-Uses the internationalized sentence boundary of
+\-breakiterator\  
+Uses the internationalized sentence boundary of 
 .na
 \f2java.text.BreakIterator\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/text/BreakIterator.html to determine the end of the first sentence for English (all other locales already use \f2BreakIterator\fP), rather than an English language, locale\-specific algorithm. By \f2first sentence\fP, we mean the first sentence in the main description of a package, class or member. This sentence is copied to the package, class or member summary, and to the alphabetic index.
+http://docs.oracle.com/javase/7/docs/api/java/text/BreakIterator.html to determine the end of the first sentence for English (all other locales already use \f2BreakIterator\fP), rather than an English language, locale\-specific algorithm. By \f2first sentence\fP, we mean the first sentence in the main description of a package, class or member. This sentence is copied to the package, class or member summary, and to the alphabetic index.
 .br
 .br
-From JDK 1.2 forward, the BreakIterator class is already used to determine the end of sentence for all languages but English. Therefore, the \f2\-breakiterator\fP option has no effect except for English from 1.2 forward. English has its own default algorithm:
+From JDK 1.2 forward, the BreakIterator class is already used to determine the end of sentence for all languages but English. Therefore, the \f2\-breakiterator\fP option has no effect except for English from 1.2 forward. English has its own default algorithm: 
 .RS 3
 .TP 2
 o
-English default sentence\-break algorithm \- Stops at a period followed by a space or a HTML block tag, such as \f2<P>\fP.
+English default sentence\-break algorithm \- Stops at a period followed by a space or a HTML block tag, such as \f2<P>\fP. 
 .TP 2
 o
-Breakiterator sentence\-break algorithm \- In general, stops at a period, question mark or exclamation mark followed by a space if the next word starts with a capital letter. This is meant to handle most abbreviations (such as "The serial no. is valid", but won't handle "Mr. Smith"). Doesn't stop at HTML tags or sentences that begin with numbers or symbols. Stops at the last period in "../filename", even if embedded in an HTML tag.
+Breakiterator sentence\-break algorithm \- In general, stops at a period, question mark or exclamation mark followed by a space if the next word starts with a capital letter. This is meant to handle most abbreviations (such as "The serial no. is valid", but won't handle "Mr. Smith"). Doesn't stop at HTML tags or sentences that begin with numbers or symbols. Stops at the last period in "../filename", even if embedded in an HTML tag. 
 .RE
-NOTE: We have removed from 1.5.0 the breakiterator warning messages that were in 1.4.x and have left the default sentence\-break algorithm unchanged. That is, the \-breakiterator option is not the default in 1.5.0, nor do we expect it to become the default. This is a reversal from our former intention that the default would change in the "next major release" (1.5.0). This means if you have not modified your source code to eliminate the breakiterator warnings in 1.4.x, then you don't have to do anything, and the warnings go away starting with 1.5.0. The reason for this reversal is because any benefit to having breakiterator become the default would be outweighed by the incompatible source change it would require. We regret any extra work and confusion this has caused.
+NOTE: We have removed from 1.5.0 the breakiterator warning messages that were in 1.4.x and have left the default sentence\-break algorithm unchanged. That is, the \-breakiterator option is not the default in 1.5.0, nor do we expect it to become the default. This is a reversal from our former intention that the default would change in the "next major release" (1.5.0). This means if you have not modified your source code to eliminate the breakiterator warnings in 1.4.x, then you don't have to do anything, and the warnings go away starting with 1.5.0. The reason for this reversal is because any benefit to having breakiterator become the default would be outweighed by the incompatible source change it would require. We regret any extra work and confusion this has caused.  
 .TP 3
-\-locale\  language_country_variant
+\-locale\  language_country_variant 
 \f3Important\fP \- The \f2\-locale\fP option must be placed \f2ahead\fP (to the left) of any options provided by the standard doclet or any other doclet. Otherwise, the navigation bars will appear in English. This is the only command\-line option that is order\-dependent.
 .br
 .br
 Specifies the locale that javadoc uses when generating documentation. The argument is the name of the locale, as described in java.util.Locale documentation, such as \f2en_US\fP (English, United States) or \f2en_US_WIN\fP (Windows variant).
 .br
 .br
-Specifying a locale causes javadoc to choose the resource files of that locale for messages (strings in the navigation bar, headings for lists and tables, help file contents, comments in stylesheet.css, and so forth). It also specifies the sorting order for lists sorted alphabetically, and the sentence separator to determine the end of the first sentence. It does not determine the locale of the doc comment text specified in the source files of the documented classes.
+Specifying a locale causes javadoc to choose the resource files of that locale for messages (strings in the navigation bar, headings for lists and tables, help file contents, comments in stylesheet.css, and so forth). It also specifies the sorting order for lists sorted alphabetically, and the sentence separator to determine the end of the first sentence. It does not determine the locale of the doc comment text specified in the source files of the documented classes.  
 .TP 3
-\-encoding\  name
+\-encoding\  name 
 Specifies the encoding name of the source files, such as \f2EUCJIS/SJIS\fP. If this option is not specified, the platform default converter is used.
 .br
 .br
-Also see \-docencoding and \-charset.
+Also see \-docencoding and \-charset.  
 .TP 3
-\-Jflag
-Passes \f2flag\fP directly to the runtime system java that runs javadoc. Notice there must be no space between the \f2J\fP and the \f2flag\fP. For example, if you need to ensure that the system sets aside 32 megabytes of memory in which to process the generated documentation, then you would call the \f2\-Xmx\fP option of java as follows (\f2\-Xms\fP is optional, as it only sets the size of initial memory, which is useful if you know the minimum amount of memory required):
+\-Jflag 
+Passes \f2flag\fP directly to the runtime system java that runs javadoc. Notice there must be no space between the \f2J\fP and the \f2flag\fP. For example, if you need to ensure that the system sets aside 32 megabytes of memory in which to process the generated documentation, then you would call the \f2\-Xmx\fP option of java as follows (\f2\-Xms\fP is optional, as it only sets the size of initial memory, which is useful if you know the minimum amount of memory required): 
 .nf
 \f3
 .fl
    % \fP\f3javadoc \-J\-Xmx32m \-J\-Xms32m\fP \f3com.mypackage\fP
 .fl
 .fi
-To tell what version of javadoc you are using, call the "\f2\-version\fP" option of java:
+To tell what version of javadoc you are using, call the "\f2\-version\fP" option of java: 
 .nf
 \f3
 .fl
@@ -3069,17 +3077,17 @@
    Classic VM (build JDK\-1.2\-V, green threads, sunwjit)
 .fl
 .fi
-(The version number of the standard doclet appears in its output stream.)
+(The version number of the standard doclet appears in its output stream.) 
 .RE
-.SS
+.SS 
 Options Provided by the Standard Doclet
 .RS 3
 .TP 3
-\-d\  directory
+\-d\  directory 
 Specifies the destination directory where javadoc saves the generated HTML files. (The "d" means "destination.") Omitting this option causes the files to be saved to the current directory. The value \f2directory\fP can be absolute, or relative to the current working directory. As of 1.4, the destination directory is automatically created when javadoc is run.
 .br
 .br
-For example, the following generates the documentation for the package \f2com.mypackage\fP and saves the results in the \f2/home/user/doc/\fP directory:
+For example, the following generates the documentation for the package \f2com.mypackage\fP and saves the results in the \f2/home/user/doc/\fP directory: 
 .nf
 \f3
 .fl
@@ -3087,7 +3095,7 @@
 .fl
 .fi
 .TP 3
-\-use
+\-use 
 Includes one "Use" page for each documented class and package. The page describes what packages, classes, methods, constructors and fields use any API of the given class or package. Given class C, things that use class C would include subclasses of C, fields declared as C, methods that return C, and methods and constructors with parameters of type C.
 .br
 .br
@@ -3097,19 +3105,19 @@
 Note that this documents only uses of the API, not the implementation. If a method uses \f2String\fP in its implementation but does not take a string as an argument or return a string, that is not considered a "use" of \f2String\fP.
 .br
 .br
-You can access the generated "Use" page by first going to the class or package, then clicking on the "Use" link in the navigation bar.
+You can access the generated "Use" page by first going to the class or package, then clicking on the "Use" link in the navigation bar.  
 .TP 3
-\-version
-Includes the @version text in the generated docs. This text is omitted by default. To tell what version of the Javadoc tool you are using, use the \f2\-J\-version\fP option.
+\-version 
+Includes the @version text in the generated docs. This text is omitted by default. To tell what version of the Javadoc tool you are using, use the \f2\-J\-version\fP option.  
 .TP 3
-\-author
-Includes the @author text in the generated docs.
+\-author 
+Includes the @author text in the generated docs.  
 .TP 3
-\-splitindex
-Splits the index file into multiple files, alphabetically, one file per letter, plus a file for any index entries that start with non\-alphabetical characters.
+\-splitindex 
+Splits the index file into multiple files, alphabetically, one file per letter, plus a file for any index entries that start with non\-alphabetical characters.  
 .TP 3
-\-windowtitle\  title
-Specifies the title to be placed in the HTML <title> tag. This appears in the window title and in any browser bookmarks (favorite places) that someone creates for this page. This title should not contain any HTML tags, as the browser will not properly interpret them. Any internal quotation marks within \f2title\fP may have to be escaped. If \-windowtitle is omitted, the Javadoc tool uses the value of \-doctitle for this option.
+\-windowtitle\  title 
+Specifies the title to be placed in the HTML <title> tag. This appears in the window title and in any browser bookmarks (favorite places) that someone creates for this page. This title should not contain any HTML tags, as the browser will not properly interpret them. Any internal quotation marks within \f2title\fP may have to be escaped. If \-windowtitle is omitted, the Javadoc tool uses the value of \-doctitle for this option. 
 .nf
 \f3
 .fl
@@ -3117,8 +3125,8 @@
 .fl
 .fi
 .TP 3
-\-doctitle\  title
-Specifies the title to be placed near the top of the overview summary file. The title will be placed as a centered, level\-one heading directly beneath the upper navigation bar. The \f2title\fP may contain html tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2title\fP may have to be escaped.
+\-doctitle\  title 
+Specifies the title to be placed near the top of the overview summary file. The title will be placed as a centered, level\-one heading directly beneath the upper navigation bar. The \f2title\fP may contain html tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2title\fP may have to be escaped. 
 .nf
 \f3
 .fl
@@ -3126,11 +3134,11 @@
 .fl
 .fi
 .TP 3
-\-title\  title
-\f3This option no longer exists.\fP It existed only in Beta versions of Javadoc 1.2. It has been renamed to \f2\-doctitle\fP. This option is being renamed to make it clear that it defines the document title rather than the window title.
+\-title\  title 
+\f3This option no longer exists.\fP It existed only in Beta versions of Javadoc 1.2. It has been renamed to \f2\-doctitle\fP. This option is being renamed to make it clear that it defines the document title rather than the window title.  
 .TP 3
-\-header\  header
-Specifies the header text to be placed at the top of each output file. The header will be placed to the right of the upper navigation bar. \f2header\fP may contain HTML tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2header\fP may have to be escaped.
+\-header\  header 
+Specifies the header text to be placed at the top of each output file. The header will be placed to the right of the upper navigation bar. \f2header\fP may contain HTML tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2header\fP may have to be escaped. 
 .nf
 \f3
 .fl
@@ -3138,17 +3146,17 @@
 .fl
 .fi
 .TP 3
-\-footer\  footer
-Specifies the footer text to be placed at the bottom of each output file. The footer will be placed to the right of the lower navigation bar. \f2footer\fP may contain html tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2footer\fP may have to be escaped.
+\-footer\  footer 
+Specifies the footer text to be placed at the bottom of each output file. The footer will be placed to the right of the lower navigation bar. \f2footer\fP may contain html tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2footer\fP may have to be escaped. 
 .TP 3
-\-top
-Specifies the text to be placed at the top of each output file.
+\-top 
+Specifies the text to be placed at the top of each output file. 
 .TP 3
-\-bottom\  text
-Specifies the text to be placed at the bottom of each output file. The text will be placed at the bottom of the page, below the lower navigation bar. The \f2text\fP may contain HTML tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2text\fP may have to be escaped.
+\-bottom\  text 
+Specifies the text to be placed at the bottom of each output file. The text will be placed at the bottom of the page, below the lower navigation bar. The \f2text\fP may contain HTML tags and white space, though if it does, it must be enclosed in quotes. Any internal quotation marks within \f2text\fP may have to be escaped.  
 .TP 3
-\-link\  extdocURL
-Creates links to existing javadoc\-generated documentation of external referenced classes. It takes one argument:
+\-link\  extdocURL 
+Creates links to existing javadoc\-generated documentation of external referenced classes. It takes one argument:  
 .RS 3
 .TP 2
 o
@@ -3161,21 +3169,21 @@
 When specifying an absolute link you normally use an \f2http:\fP link. However, if you want to link to a file system that has no web server, you can use a \f2file:\fP link \-\- however, do this only if everyone wanting to access the generated documentation shares the same file system.
 .br
 .br
-In all cases, and on all operating systems, you should use a forward slash as the separator, whether the URL is absolute or relative, and "http:" or "file:" based (as specified in the
+In all cases, and on all operating systems, you should use a forward slash as the separator, whether the URL is absolute or relative, and "http:" or "file:" based (as specified in the 
 .na
 \f2URL Memo\fP @
 .fi
-http://www.ietf.org/rfc/rfc1738.txt).
+http://www.ietf.org/rfc/rfc1738.txt). 
 .RS 3
 .TP 3
-Absolute http: based link:
-\f2\-link http://<host>/<directory>/<directory>/.../<name>\fP
+Absolute http: based link: 
+\f2\-link http://<host>/<directory>/<directory>/.../<name>\fP 
 .TP 3
-Absolute file: based link:
-\f2\-link file://<host>/<directory>/<directory>/.../<name>\fP
+Absolute file: based link: 
+\f2\-link file://<host>/<directory>/<directory>/.../<name>\fP 
 .TP 3
-Relative link:
-\f2\-link <directory>/<directory>/.../<name>\fP
+Relative link: 
+\f2\-link <directory>/<directory>/.../<name>\fP 
 .RE
 .RE
 You can specify multiple \f2\-link\fP options in a given javadoc run to link to multiple documents.
@@ -3184,35 +3192,35 @@
 \f3Choosing between \-linkoffline and \-link\fP:
 .br
 .br
-Use \f2\-link\fP:
+Use \f2\-link\fP: 
 .RS 3
 .TP 2
 o
-when using a relative path to the external API document, or
+when using a relative path to the external API document, or 
 .TP 2
 o
-when using an absolute URL to the external API document, if your shell allows a program to open a connection to that URL for reading.
+when using an absolute URL to the external API document, if your shell allows a program to open a connection to that URL for reading. 
 .RE
-Use \f2\-linkoffline\fP:
+Use \f2\-linkoffline\fP: 
 .RS 3
 .TP 2
 o
-when using an absolute URL to the external API document, if your shell \f2does not allow\fP a program to open a connection to that URL for reading. This can occur if you are behind a firewall and the document you want to link to is on the other side.
+when using an absolute URL to the external API document, if your shell \f2does not allow\fP a program to open a connection to that URL for reading. This can occur if you are behind a firewall and the document you want to link to is on the other side. 
 .RE
 .br
 .br
-\f3Example using absolute links to the external docs\fP \- Let us say you want to link to the \f2java.lang\fP, \f2java.io\fP and other Java Platform packages at
+\f3Example using absolute links to the external docs\fP \- Let us say you want to link to the \f2java.lang\fP, \f2java.io\fP and other Java Platform packages at 
 .na
-\f2http://download.oracle.com/javase/7/docs/api/\fP @
+\f2http://docs.oracle.com/javase/7/docs/api/\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/. The following command generates documentation for the package \f2com.mypackage\fP with links to the Java SE Platform packages. The generated documentation will contain links to the \f2Object\fP class, for example, in the class trees. (Other options, such as \f2\-sourcepath\fP and \f2\-d\fP, are not shown.)
+http://docs.oracle.com/javase/7/docs/api/. The following command generates documentation for the package \f2com.mypackage\fP with links to the Java SE Platform packages. The generated documentation will contain links to the \f2Object\fP class, for example, in the class trees. (Other options, such as \f2\-sourcepath\fP and \f2\-d\fP, are not shown.) 
 .nf
 \f3
 .fl
-  % \fP\f3javadoc \-link http://download.oracle.com/javase/7/docs/api/ com.mypackage\fP
+  % \fP\f3javadoc \-link http://docs.oracle.com/javase/7/docs/api/ com.mypackage\fP
 .fl
 .fi
-\f3Example using relative links to the external docs\fP \- Let us say you have two packages whose docs are generated in different runs of the Javadoc tool, and those docs are separated by a relative path. In this example, the packages are \f2com.apipackage\fP, an API, and \f2com.spipackage\fP, an SPI (Service Provide Interface). You want the documentation to reside in \f2docs/api/com/apipackage\fP and \f2docs/spi/com/spipackage\fP. Assuming the API package documentation is already generated, and that \f2docs\fP is the current directory, you would document the SPI package with links to the API documentation by running:
+\f3Example using relative links to the external docs\fP \- Let us say you have two packages whose docs are generated in different runs of the Javadoc tool, and those docs are separated by a relative path. In this example, the packages are \f2com.apipackage\fP, an API, and \f2com.spipackage\fP, an SPI (Service Provide Interface). You want the documentation to reside in \f2docs/api/com/apipackage\fP and \f2docs/spi/com/spipackage\fP. Assuming the API package documentation is already generated, and that \f2docs\fP is the current directory, you would document the SPI package with links to the API documentation by running: 
 .nf
 \f3
 .fl
@@ -3234,7 +3242,7 @@
 Another use is for cross\-links between sets of packages: Execute javadoc on one set of packages, then run javadoc again on another set of packages, creating links both ways between both sets.
 .br
 .br
-\f3How a Class Must be Referenced\fP \- For a link to an external referenced class to actually appear (and not just its text label), the class must be referenced in the following way. It is not sufficient for it to be referenced in the body of a method. It must be referenced in either an \f2import\fP statement or in a declaration. Here are examples of how the class \f2java.io.File\fP can be referenced:
+\f3How a Class Must be Referenced\fP \- For a link to an external referenced class to actually appear (and not just its text label), the class must be referenced in the following way. It is not sufficient for it to be referenced in the body of a method. It must be referenced in either an \f2import\fP statement or in a declaration. Here are examples of how the class \f2java.io.File\fP can be referenced: 
 .RS 3
 .TP 2
 o
@@ -3242,30 +3250,30 @@
 .br
 \f2import java.io.*;\fP
 .br
-In 1.3.x and 1.2.x, only an explicit import by name works \-\- a wildcard import statement does not work, nor does the automatic import \f2java.lang.*\fP.
+In 1.3.x and 1.2.x, only an explicit import by name works \-\- a wildcard import statement does not work, nor does the automatic import \f2java.lang.*\fP. 
 .TP 2
 o
 In a declaration:
 .br
 \f2void foo(File f) {}\fP
 .br
-The reference and be in the return type or parameter type of a method, constructor, field, class or interface, or in an \f2implements\fP, \f2extends\fP or \f2throws\fP statement.
+The reference and be in the return type or parameter type of a method, constructor, field, class or interface, or in an \f2implements\fP, \f2extends\fP or \f2throws\fP statement. 
 .RE
-An important corollary is that when you use the \f2\-link\fP option, there may be many links that unintentionally do not appear due to this constraint. (The text would appear without a hypertext link.) You can detect these by the warnings they emit. The most innocuous way to properly reference a class and thereby add the link would be to import that class, as shown above.
+An important corollary is that when you use the \f2\-link\fP option, there may be many links that unintentionally do not appear due to this constraint. (The text would appear without a hypertext link.) You can detect these by the warnings they emit. The most innocuous way to properly reference a class and thereby add the link would be to import that class, as shown above.  
 .br
 .br
 \f3Package List\fP \- The \f2\-link\fP option requires that a file named \f2package\-list\fP, which is generated by the Javadoc tool, exist at the URL you specify with \f2\-link\fP. The \f2package\-list\fP file is a simple text file that lists the names of packages documented at that location. In the earlier example, the Javadoc tool looks for a file named \f2package\-list\fP at the given URL, reads in the package names and then links to those packages at that URL.
 .br
 .br
-For example, the package list for the Java SE 6 API is located at
+For example, the package list for the Java SE 6 API is located at 
 .na
-\f2http://download.oracle.com/javase/7/docs/api/package\-list\fP @
+\f2http://docs.oracle.com/javase/7/docs/api/package\-list\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/package\-list. and starts as follows:
+http://docs.oracle.com/javase/7/docs/api/package\-list. and starts as follows: 
 .nf
 \f3
 .fl
-  java.applet
+  java.applet  
 .fl
   java.awt
 .fl
@@ -3304,9 +3312,9 @@
 \f3Cross\-links\fP \- Note that "bootstrapping" may be required when cross\-linking two or more documents that have not previously been generated. In other words, if \f2package\-list\fP does not exist for either document, when you run the Javadoc tool on the first document, the \f2package\-list\fP will not yet exist for the second document. Therefore, to create the external links, you must re\-generate the first document after generating the second document.
 .br
 .br
-In this case, the purpose of first generating a document is to create its \f2package\-list\fP (or you can create it by hand it if you're certain of the package names). Then generate the second document with its external links. The Javadoc tool prints a warning if a needed external \f2package\-list\fP file does not exist.
+In this case, the purpose of first generating a document is to create its \f2package\-list\fP (or you can create it by hand it if you're certain of the package names). Then generate the second document with its external links. The Javadoc tool prints a warning if a needed external \f2package\-list\fP file does not exist.  
 .TP 3
-\-linkoffline\  extdocURL\  packagelistLoc
+\-linkoffline\  extdocURL\  packagelistLoc 
 This option is a variation of \f2\-link\fP; they both create links to javadoc\-generated documentation for external referenced classes. Use the \f2\-linkoffline\fP option when linking to a document on the web when the Javadoc tool itself is "offline" \-\- that is, it cannot access the document through a web connection.
 .br
 .br
@@ -3316,27 +3324,27 @@
 Another use is as a "hack" to update docs: After you have run javadoc on a full set of packages, then you can run javadoc again on onlya smaller set of changed packages, so that the updated files can be inserted back into the original set. Examples are given below.
 .br
 .br
-The \f2\-linkoffline\fP option takes two arguments \-\- the first for the string to be embedded in the \f2<a href>\fP links, the second telling it where to find \f2package\-list\fP:
+The \f2\-linkoffline\fP option takes two arguments \-\- the first for the string to be embedded in the \f2<a href>\fP links, the second telling it where to find \f2package\-list\fP: 
 .RS 3
 .TP 2
 o
-\f4extdocURL\fP is the absolute or relative URL of the directory containing the external javadoc\-generated documentation you want to link to. If relative, the value should be the relative path from the destination directory (specified with \f2\-d\fP) to the root of the packages being linked to. For more details, see \f2extdocURL\fP in the \f2\-link\fP option.
+\f4extdocURL\fP is the absolute or relative URL of the directory containing the external javadoc\-generated documentation you want to link to. If relative, the value should be the relative path from the destination directory (specified with \f2\-d\fP) to the root of the packages being linked to. For more details, see \f2extdocURL\fP in the \f2\-link\fP option. 
 .TP 2
 o
-\f4packagelistLoc\fP is the path or URL to the directory containing the \f2package\-list\fP file for the external documentation. This can be a URL (http: or file:) or file path, and can be absolute or relative. If relative, make it relative to the \f2current\fP directory from where javadoc was run. Do not include the \f2package\-list\fP filename.
+\f4packagelistLoc\fP is the path or URL to the directory containing the \f2package\-list\fP file for the external documentation. This can be a URL (http: or file:) or file path, and can be absolute or relative. If relative, make it relative to the \f2current\fP directory from where javadoc was run. Do not include the \f2package\-list\fP filename. 
 .RE
 You can specify multiple \f2\-linkoffline\fP options in a given javadoc run. (Prior to 1.2.2, it could be specified only once.)
 .br
 .br
-\f3Example using absolute links to the external docs\fP \- Let us say you want to link to the \f2java.lang\fP, \f2java.io\fP and other Java SE Platform packages at \f2http://download.oracle.com/javase/7/docs/api/\fP, but your shell does not have web access. You could open the \f2package\-list\fP file in a browser at
+\f3Example using absolute links to the external docs\fP \- Let us say you want to link to the \f2java.lang\fP, \f2java.io\fP and other Java SE Platform packages at \f2http://docs.oracle.com/javase/7/docs/api/\fP, but your shell does not have web access. You could open the \f2package\-list\fP file in a browser at 
 .na
-\f2http://download.oracle.com/javase/7/docs/api/package\-list\fP @
+\f2http://docs.oracle.com/javase/7/docs/api/package\-list\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/package\-list, save it to a local directory, and point to this local copy with the second argument, \f2packagelistLoc\fP. In this example, the package list file has been saved to the current directory "\f2.\fP" . The following command generates documentation for the package \f2com.mypackage\fP with links to the Java SE Platform packages. The generated documentation will contain links to the \f2Object\fP class, for example, in the class trees. (Other necessary options, such as \f2\-sourcepath\fP, are not shown.)
+http://docs.oracle.com/javase/7/docs/api/package\-list, save it to a local directory, and point to this local copy with the second argument, \f2packagelistLoc\fP. In this example, the package list file has been saved to the current directory "\f2.\fP" . The following command generates documentation for the package \f2com.mypackage\fP with links to the Java SE Platform packages. The generated documentation will contain links to the \f2Object\fP class, for example, in the class trees. (Other necessary options, such as \f2\-sourcepath\fP, are not shown.) 
 .nf
 \f3
 .fl
-% \fP\f3javadoc \-linkoffline http://download.oracle.com/javase/7/docs/api/ . com.mypackage\fP
+% \fP\f3javadoc \-linkoffline http://docs.oracle.com/javase/7/docs/api/ . com.mypackage\fP
 .fl
 .fi
 \f3Example using relative links to the external docs\fP \- It's not very common to use \f2\-linkoffline\fP with relative paths, for the simple reason that \f2\-link\fP usually suffices. When using \f2\-linkoffline\fP, the \f2package\-list\fP file is generally local, and when using relative links, the file you are linking to is also generally local. So it is usually unnecessary to give a different path for the two arguments to \f2\-linkoffline\fP. When the two arguments are identical, you can use \f2\-link\fP. See the \f2\-link\fP relative example.
@@ -3358,23 +3366,23 @@
 \f3Updating docs\fP \- Another use for \f2\-linkoffline\fP option is useful if your project has dozens or hundreds of packages, if you have already run javadoc on the entire tree, and now, in a separate run, you want to quickly make some small changes and re\-run javadoc on just a small portion of the source tree. This is somewhat of a hack in that it works properly only if your changes are only to doc comments and not to declarations. If you were to add, remove or change any declarations from the source code, then broken links could show up in the index, package tree, inherited member lists, use page, and other places.
 .br
 .br
-First, you create a new destination directory (call it \f2update\fP) for this new small run. Let us say the original destination directory was named \f2html\fP. In the simplest example, cd to the parent of \f2html\fP. Set the first argument of \f2\-linkoffline\fP to the current directory "." and set the second argument to the relative path to \f2html\fP, where it can find \f2package\-list\fP, and pass in only the package names of the packages you want to update:
+First, you create a new destination directory (call it \f2update\fP) for this new small run. Let us say the original destination directory was named \f2html\fP. In the simplest example, cd to the parent of \f2html\fP. Set the first argument of \f2\-linkoffline\fP to the current directory "." and set the second argument to the relative path to \f2html\fP, where it can find \f2package\-list\fP, and pass in only the package names of the packages you want to update: 
 .nf
 \f3
 .fl
   % \fP\f3javadoc \-d update \-linkoffline . html com.mypackage\fP
 .fl
 .fi
-When the Javadoc tool is done, copy these generated class pages in \f2update/com/package\fP (not the overview or index), over the original files in \f2html/com/package\fP.
+When the Javadoc tool is done, copy these generated class pages in \f2update/com/package\fP (not the overview or index), over the original files in \f2html/com/package\fP.  
 .TP 3
-\-linksource\
+\-linksource\  
 Creates an HTML version of each source file (with line numbers) and adds links to them from the standard HTML documentation. Links are created for classes, interfaces, constructors, methods and fields whose declarations are in a source file. Otherwise, links are not created, such as for default constructors and generated classes.
 .br
 .br
 \f3This option exposes \fP\f4all\fP\f3 private implementation details in the included source files, including private classes, private fields, and the bodies of private methods, \fP\f4regardless of the \fP\f4\-public\fP\f3, \fP\f4\-package\fP\f3, \fP\f4\-protected\fP\f3 and \fP\f4\-private\fP\f3 options.\fP Unless you also use the \f2\-private\fP option, not all private classes or interfaces will necessarily be accessible via links.
 .br
 .br
-Each link appears on the name of the identifier in its declaration. For example, the link to the source code of the \f2Button\fP class would be on the word "Button":
+Each link appears on the name of the identifier in its declaration. For example, the link to the source code of the \f2Button\fP class would be on the word "Button": 
 .nf
 \f3
 .fl
@@ -3386,7 +3394,7 @@
 .fl
 \fP
 .fi
-and the link to the source code of the \f2getLabel()\fP method in the Button class would be on the word "getLabel":
+and the link to the source code of the \f2getLabel()\fP method in the Button class would be on the word "getLabel": 
 .nf
 \f3
 .fl
@@ -3395,15 +3403,15 @@
 \fP
 .fi
 .TP 3
-\-group\  groupheading\  packagepattern:packagepattern:...
-Separates packages on the overview page into whatever groups you specify, one group per table. You specify each group with a different \f2\-group\fP option. The groups appear on the page in the order specified on the command line; packages are alphabetized within a group. For a given \f2\-group\fP option, the packages matching the list of \f2packagepattern\fP expressions appear in a table with the heading \f2groupheading\fP.
+\-group\  groupheading\  packagepattern:packagepattern:... 
+Separates packages on the overview page into whatever groups you specify, one group per table. You specify each group with a different \f2\-group\fP option. The groups appear on the page in the order specified on the command line; packages are alphabetized within a group. For a given \f2\-group\fP option, the packages matching the list of \f2packagepattern\fP expressions appear in a table with the heading \f2groupheading\fP. 
 .RS 3
 .TP 2
 o
-\f4groupheading\fP can be any text, and can include white space. This text is placed in the table heading for the group.
+\f4groupheading\fP can be any text, and can include white space. This text is placed in the table heading for the group. 
 .TP 2
 o
-\f4packagepattern\fP can be any package name, or can be the start of any package name followed by an asterisk (\f2*\fP). The asterisk is a wildcard meaning "match any characters". This is the only wildcard allowed. Multiple patterns can be included in a group by separating them with colons (\f2:\fP).
+\f4packagepattern\fP can be any package name, or can be the start of any package name followed by an asterisk (\f2*\fP). The asterisk is a wildcard meaning "match any characters". This is the only wildcard allowed. Multiple patterns can be included in a group by separating them with colons (\f2:\fP). 
 .RE
 \f3NOTE: If using an asterisk in a pattern or pattern list, the pattern list must be inside quotes, such as \fP\f4"java.lang*:java.util"\fP
 .br
@@ -3411,7 +3419,7 @@
 If you do not supply any \f2\-group\fP option, all packages are placed in one group with the heading "Packages". If the all groups do not include all documented packages, any leftover packages appear in a separate group with the heading "Other Packages".
 .br
 .br
-For example, the following option separates the four documented packages into core, extension and other packages. Notice the trailing "dot" does not appear in "java.lang*" \-\- including the dot, such as "java.lang.*" would omit the java.lang package.
+For example, the following option separates the four documented packages into core, extension and other packages. Notice the trailing "dot" does not appear in "java.lang*" \-\- including the dot, such as "java.lang.*" would omit the java.lang package. 
 .nf
 \f3
 .fl
@@ -3422,44 +3430,44 @@
             java.lang java.lang.reflect java.util javax.servlet java.new\fP
 .fl
 .fi
-This results in the groupings:
+This results in the groupings: 
 .RS 3
 .TP 3
-Core Packages
-\f2java.lang\fP
-\f2java.lang.reflect\fP
-\f2java.util\fP
+Core Packages 
+\f2java.lang\fP 
+\f2java.lang.reflect\fP 
+\f2java.util\fP 
 .TP 3
-Extension Packages
-\f2javax.servlet\fP
+Extension Packages 
+\f2javax.servlet\fP 
 .TP 3
-Other Packages
-\f2java.new\fP
+Other Packages 
+\f2java.new\fP 
 .RE
 .TP 3
-\-nodeprecated
-Prevents the generation of any deprecated API at all in the documentation. This does what \-nodeprecatedlist does, plus it does not generate any deprecated API throughout the rest of the documentation. This is useful when writing code and you don't want to be distracted by the deprecated code.
+\-nodeprecated 
+Prevents the generation of any deprecated API at all in the documentation. This does what \-nodeprecatedlist does, plus it does not generate any deprecated API throughout the rest of the documentation. This is useful when writing code and you don't want to be distracted by the deprecated code.  
 .TP 3
-\-nodeprecatedlist
-Prevents the generation of the file containing the list of deprecated APIs (deprecated\-list.html) and the link in the navigation bar to that page. (However, javadoc continues to generate the deprecated API throughout the rest of the document.) This is useful if your source code contains no deprecated API, and you want to make the navigation bar cleaner.
+\-nodeprecatedlist 
+Prevents the generation of the file containing the list of deprecated APIs (deprecated\-list.html) and the link in the navigation bar to that page. (However, javadoc continues to generate the deprecated API throughout the rest of the document.) This is useful if your source code contains no deprecated API, and you want to make the navigation bar cleaner.  
 .TP 3
-\-nosince
-Omits from the generated docs the "Since" sections associated with the @since tags.
+\-nosince 
+Omits from the generated docs the "Since" sections associated with the @since tags.  
 .TP 3
-\-notree
-Omits the class/interface hierarchy pages from the generated docs. These are the pages you reach using the "Tree" button in the navigation bar. The hierarchy is produced by default.
+\-notree 
+Omits the class/interface hierarchy pages from the generated docs. These are the pages you reach using the "Tree" button in the navigation bar. The hierarchy is produced by default.  
 .TP 3
-\-noindex
-Omits the index from the generated docs. The index is produced by default.
+\-noindex 
+Omits the index from the generated docs. The index is produced by default.  
 .TP 3
-\-nohelp
-Omits the HELP link in the navigation bars at the top and bottom of each page of output.
+\-nohelp 
+Omits the HELP link in the navigation bars at the top and bottom of each page of output.  
 .TP 3
-\-nonavbar
-Prevents the generation of the navigation bar, header and footer, otherwise found at the top and bottom of the generated pages. Has no affect on the "bottom" option. The \f2\-nonavbar\fP option is useful when you are interested only in the content and have no need for navigation, such as converting the files to PostScript or PDF for print only.
+\-nonavbar 
+Prevents the generation of the navigation bar, header and footer, otherwise found at the top and bottom of the generated pages. Has no affect on the "bottom" option. The \f2\-nonavbar\fP option is useful when you are interested only in the content and have no need for navigation, such as converting the files to PostScript or PDF for print only.  
 .TP 3
-\-helpfile\  path/filename
-Specifies the path of an alternate help file \f2path/filename\fP that the HELP link in the top and bottom navigation bars link to. Without this option, the Javadoc tool automatically creates a help file \f2help\-doc.html\fP that is hard\-coded in the Javadoc tool. This option enables you to override this default. The \f2filename\fP can be any name and is not restricted to \f2help\-doc.html\fP \-\- the Javadoc tool will adjust the links in the navigation bar accordingly. For example:
+\-helpfile\  path/filename 
+Specifies the path of an alternate help file \f2path/filename\fP that the HELP link in the top and bottom navigation bars link to. Without this option, the Javadoc tool automatically creates a help file \f2help\-doc.html\fP that is hard\-coded in the Javadoc tool. This option enables you to override this default. The \f2filename\fP can be any name and is not restricted to \f2help\-doc.html\fP \-\- the Javadoc tool will adjust the links in the navigation bar accordingly. For example: 
 .nf
 \f3
 .fl
@@ -3467,8 +3475,8 @@
 .fl
 .fi
 .TP 3
-\-stylesheetfile\  path/filename
-Specifies the path of an alternate HTML stylesheet file. Without this option, the Javadoc tool automatically creates a stylesheet file \f2stylesheet.css\fP that is hard\-coded in the Javadoc tool. This option enables you to override this default. The \f2filename\fP can be any name and is not restricted to \f2stylesheet.css\fP. For example:
+\-stylesheetfile\  path/filename 
+Specifies the path of an alternate HTML stylesheet file. Without this option, the Javadoc tool automatically creates a stylesheet file \f2stylesheet.css\fP that is hard\-coded in the Javadoc tool. This option enables you to override this default. The \f2filename\fP can be any name and is not restricted to \f2stylesheet.css\fP. For example: 
 .nf
 \f3
 .fl
@@ -3476,22 +3484,22 @@
 .fl
 .fi
 .TP 3
-\-serialwarn
-Generates compile\-time warnings for missing @serial tags. By default, Javadoc 1.2.2 (and later versions) generates no serial warnings. (This is a reversal from earlier versions.) Use this option to display the serial warnings, which helps to properly document default serializable fields and \f2writeExternal\fP methods.
+\-serialwarn 
+Generates compile\-time warnings for missing @serial tags. By default, Javadoc 1.2.2 (and later versions) generates no serial warnings. (This is a reversal from earlier versions.) Use this option to display the serial warnings, which helps to properly document default serializable fields and \f2writeExternal\fP methods.  
 .TP 3
-\-charset\  name
-Specifies the HTML character set for this document. The name should be a preferred MIME name as given in the
+\-charset\  name 
+Specifies the HTML character set for this document. The name should be a preferred MIME name as given in the 
 .na
 \f2IANA Registry\fP @
 .fi
-http://www.iana.org/assignments/character\-sets. For example:
+http://www.iana.org/assignments/character\-sets. For example: 
 .nf
 \f3
 .fl
   % \fP\f3javadoc \-charset "iso\-8859\-1" mypackage\fP
 .fl
 .fi
-would insert the following line in the head of every generated page:
+would insert the following line in the head of every generated page:  
 .nf
 \f3
 .fl
@@ -3499,34 +3507,34 @@
 .fl
 \fP
 .fi
-This META tag is described in the
+This META tag is described in the 
 .na
 \f2HTML standard\fP @
 .fi
 http://www.w3.org/TR/REC\-html40/charset.html#h\-5.2.2. (4197265 and 4137321)
 .br
 .br
-Also see \-encoding and \-docencoding.
+Also see \-encoding and \-docencoding. 
 .TP 3
-\-docencoding\  name
-Specifies the encoding of the generated HTML files. The name should be a preferred MIME name as given in the
+\-docencoding\  name 
+Specifies the encoding of the generated HTML files. The name should be a preferred MIME name as given in the 
 .na
 \f2IANA Registry\fP @
 .fi
-http://www.iana.org/assignments/character\-sets. If you omit this option but use \-encoding, then the encoding of the generated HTML files is determined by \-encoding. Example:
+http://www.iana.org/assignments/character\-sets. If you omit this option but use \-encoding, then the encoding of the generated HTML files is determined by \-encoding. Example: 
 .nf
 \f3
 .fl
   % \fP\f3javadoc \-docencoding "ISO\-8859\-1" mypackage\fP
 .fl
 .fi
-Also see \-encoding and \-charset.
+Also see \-encoding and \-charset.  
 .TP 3
-\-keywords
+\-keywords 
 Adds HTML meta keyword tags to the generated file for each class. These tags can help the page be found by search engines that look for meta tags. (Most search engines that search the entire Internet do not look at meta tags, because pages can misuse them; but search engines offered by companies that confine their search to their own website can benefit by looking at meta tags.)
 .br
 .br
-The meta tags include the fully qualified name of the class and the unqualified names of the fields and methods. Constructors are not included because they are identical to the class name. For example, the class String starts with these keywords:
+The meta tags include the fully qualified name of the class and the unqualified names of the fields and methods. Constructors are not included because they are identical to the class name. For example, the class String starts with these keywords: 
 .nf
 \f3
 .fl
@@ -3541,7 +3549,7 @@
 \fP
 .fi
 .TP 3
-\-tag\ \ tagname:Xaoptcmf:"taghead"
+\-tag\ \ tagname:Xaoptcmf:"taghead" 
 Enables the Javadoc tool to interpret a simple, one\-argument custom block tag \f2@\fP\f2tagname\fP in doc comments. So the Javadoc tool can "spell\-check" tag names, it is important to include a \f2\-tag\fP option for every custom tag that is present in the source code, disabling (with \f2X\fP) those that are not being output in the current run.
 .br
 .br
@@ -3568,10 +3576,10 @@
 .br
 \f4m\fP (methods)
 .br
-\f4f\fP (fields)
+\f4f\fP (fields) 
 .br
 .br
-\f3Examples of single tags\fP \- An example of a tag option for a tag that can be used anywhere in the source code is:
+\f3Examples of single tags\fP \- An example of a tag option for a tag that can be used anywhere in the source code is: 
 .nf
 \f3
 .fl
@@ -3579,7 +3587,7 @@
 .fl
 \fP
 .fi
-If you wanted @todo to be used only with constructors, methods and fields, you would use:
+If you wanted @todo to be used only with constructors, methods and fields, you would use: 
 .nf
 \f3
 .fl
@@ -3587,7 +3595,7 @@
 .fl
 \fP
 .fi
-Notice the last colon (\f2:\fP) above is not a parameter separator, but is part of the heading text (as shown below). You would use either tag option for source code that contains the tag \f2@todo\fP, such as:
+Notice the last colon (\f2:\fP) above is not a parameter separator, but is part of the heading text (as shown below). You would use either tag option for source code that contains the tag \f2@todo\fP, such as: 
 .nf
 \f3
 .fl
@@ -3595,7 +3603,7 @@
 .fl
 \fP
 .fi
-\f3Use of Colon in Tag Name\fP \- A colon can be used in a tag name if it is escaped with a backslash. For this doc comment:
+\f3Use of Colon in Tag Name\fP \- A colon can be used in a tag name if it is escaped with a backslash. For this doc comment: 
 .nf
 \f3
 .fl
@@ -3607,7 +3615,7 @@
 .fl
 \fP
 .fi
-use this tag option:
+use this tag option:  
 .nf
 \f3
 .fl
@@ -3618,7 +3626,7 @@
 \f3Spell\-checking tag names (Disabling tags)\fP \- Some developers put custom tags in the source code that they don't always want to output. In these cases, it is important to list all tags that are present in the source code, enabling the ones you want to output and disabling the ones you don't want to output. The presence of \f2X\fP disables the tag, while its absence enables the tag. This gives the Javadoc tool enough information to know if a tag it encounters is unknown, probably the results of a typo or a misspelling. It prints a warning in these cases.
 .br
 .br
-You can add \f2X\fP to the placement values already present, so that when you want to enable the tag, you can simply delete the \f2X\fP. For example, if @todo is a tag that you want to suppress on output, you would use:
+You can add \f2X\fP to the placement values already present, so that when you want to enable the tag, you can simply delete the \f2X\fP. For example, if @todo is a tag that you want to suppress on output, you would use: 
 .nf
 \f3
 .fl
@@ -3626,7 +3634,7 @@
 .fl
 \fP
 .fi
-or, if you'd rather keep it simple:
+or, if you'd rather keep it simple: 
 .nf
 \f3
 .fl
@@ -3643,7 +3651,7 @@
 If \f2\-tag\fP is missing, then the position of \f2\-taglet\fP determines its order. If they are both present, then whichever appears last on the command line determines its order. (This happens because the tags and taglets are processed in the order that they appear on the command line. For example, if \f2\-taglet\fP and \f2\-tag\fP both have the name "todo", the one that appears last on the command line will determine its order.
 .br
 .br
-\f3Example of a complete set of tags\fP \- This example inserts "To Do" after "Parameters" and before "Throws" in the output. By using "X", it also specifies that @example is a tag that might be encountered in the source code that should not be output during this run. Notice that if you use @argfile, you can put the tags on separate lines in an argument file like this (no line continuation characters needed):
+\f3Example of a complete set of tags\fP \- This example inserts "To Do" after "Parameters" and before "Throws" in the output. By using "X", it also specifies that @example is a tag that might be encountered in the source code that should not be output during this run. Notice that if you use @argfile, you can put the tags on separate lines in an argument file like this (no line continuation characters needed): 
 .nf
 \f3
 .fl
@@ -3670,24 +3678,24 @@
 \f3Avoiding Conflicts\fP \- If you want to slice out your own namespace, you can use a dot\-separated naming convention similar to that used for packages: \f2com.mycompany.todo\fP. Oracle will continue to create standard tags whose names do not contain dots. Any tag you create will override the behavior of a tag by the same name defined by Oracle. In other words, if you create a tag or taglet \f2@todo\fP, it will always have the same behavior you define, even if Oracle later creates a standard tag of the same name.
 .br
 .br
-\f3Annotations vs. Javadoc Tags\fP \- In general, if the markup you want to add is intended to affect or produce documentation, it should probably be a javadoc tag; otherwise, it should be an annotation. See
+\f3Annotations vs. Javadoc Tags\fP \- In general, if the markup you want to add is intended to affect or produce documentation, it should probably be a javadoc tag; otherwise, it should be an annotation. See 
 .na
 \f2Comparing Annotations and Javadoc Tags\fP @
 .fi
 http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html#annotations<
 .br
 .br
-You can also create more complex block tags, or custom inline tags with the \-taglet option.
+You can also create more complex block tags, or custom inline tags with the \-taglet option.  
 .TP 3
-\-taglet\ \ class
-Specifies the class file that starts the taglet used in generating the documentation for that tag. Use the fully\-qualified name for \f2class\fP. This taglet also defines the number of text arguments that the custom tag has. The taglet accepts those arguments, processes them, and generates the output. For extensive documentation with example taglets, see:
+\-taglet\ \ class 
+Specifies the class file that starts the taglet used in generating the documentation for that tag. Use the fully\-qualified name for \f2class\fP. This taglet also defines the number of text arguments that the custom tag has. The taglet accepts those arguments, processes them, and generates the output. For extensive documentation with example taglets, see: 
 .RS 3
 .TP 2
 o
 .na
 \f2Taglet Overview\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javadoc/taglet/overview.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/taglet/overview.html 
 .RE
 Taglets are useful for block or inline tags. They can have any number of arguments and implement custom behavior, such as making text bold, formatting bullets, writing out the text to a file, or starting other processes.
 .br
@@ -3695,13 +3703,13 @@
 Taglets can only determine where a tag should appear and in what form. All other decisions are made by the doclet. So a taglet cannot do things such as remove a class name from the list of included classes. However, it can execute side effects, such as printing the tag's text to a file or triggering another process.
 .br
 .br
-Use the \f2\-tagletpath\fP option to specify the path to the taglet. Here is an example that inserts the "To Do" taglet after "Parameters" and ahead of "Throws" in the generated pages:
+Use the \f2\-tagletpath\fP option to specify the path to the taglet. Here is an example that inserts the "To Do" taglet after "Parameters" and ahead of "Throws" in the generated pages: 
 .nf
 \f3
 .fl
     \-taglet com.sun.tools.doclets.ToDoTaglet
 .fl
-    \-tagletpath /home/taglets
+    \-tagletpath /home/taglets 
 .fl
     \-tag return
 .fl
@@ -3715,22 +3723,22 @@
 .fl
 \fP
 .fi
-Alternatively, you can use the \f2\-taglet\fP option in place of its \f2\-tag\fP option, but that may be harder to read.
+Alternatively, you can use the \f2\-taglet\fP option in place of its \f2\-tag\fP option, but that may be harder to read.  
 .TP 3
-\-tagletpath\ \ tagletpathlist
-Specifies the search paths for finding taglet class files (.class). The \f2tagletpathlist\fP can contain multiple paths by separating them with a colon (\f2:\fP). The Javadoc tool will search in all subdirectories of the specified paths.
+\-tagletpath\ \ tagletpathlist 
+Specifies the search paths for finding taglet class files (.class). The \f2tagletpathlist\fP can contain multiple paths by separating them with a colon (\f2:\fP). The Javadoc tool will search in all subdirectories of the specified paths.  
 .TP 3
-\-docfilessubdirs\
-Enables deep copying of "\f2doc\-files\fP" directories. In other words, subdirectories and all contents are recursively copied to the destination. For example, the directory \f2doc\-files/example/images\fP and all its contents would now be copied. There is also an option to exclude subdirectories.
+\-docfilessubdirs\  
+Enables deep copying of "\f2doc\-files\fP" directories. In other words, subdirectories and all contents are recursively copied to the destination. For example, the directory \f2doc\-files/example/images\fP and all its contents would now be copied. There is also an option to exclude subdirectories.  
 .TP 3
-\-excludedocfilessubdir\ \ name1:name2...
-Excludes any "\f2doc\-files\fP" subdirectories with the given names. This prevents the copying of SCCS and other source\-code\-control subdirectories.
+\-excludedocfilessubdir\ \ name1:name2... 
+Excludes any "\f2doc\-files\fP" subdirectories with the given names. This prevents the copying of SCCS and other source\-code\-control subdirectories.  
 .TP 3
-\-noqualifier\ \ all\  | \ packagename1:packagename2:...
+\-noqualifier\ \ all\  | \ packagename1:packagename2:... 
 Omits qualifying package name from ahead of class names in output. The argument to \f2\-noqualifier\fP is either "\f2all\fP" (all package qualifiers are omitted) or a colon\-separate list of packages, with wildcards, to be removed as qualifiers. The package name is removed from places where class or interface names appear.
 .br
 .br
-The following example omits all package qualifiers:
+The following example omits all package qualifiers: 
 .nf
 \f3
 .fl
@@ -3738,7 +3746,7 @@
 .fl
 \fP
 .fi
-The following example omits "java.lang" and "java.io" package qualifiers:
+The following example omits "java.lang" and "java.io" package qualifiers: 
 .nf
 \f3
 .fl
@@ -3746,7 +3754,7 @@
 .fl
 \fP
 .fi
-The following example omits package qualifiers starting with "java", and "com.sun" subpackages (but not "javax"):
+The following example omits package qualifiers starting with "java", and "com.sun" subpackages (but not "javax"): 
 .nf
 \f3
 .fl
@@ -3754,10 +3762,10 @@
 .fl
 \fP
 .fi
-Where a package qualifier would appear due to the above behavior, the name can be suitably shortened \-\- see How a name is displayed. This rule is in effect whether or not \f2\-noqualifier\fP is used.
+Where a package qualifier would appear due to the above behavior, the name can be suitably shortened \-\- see How a name is displayed. This rule is in effect whether or not \f2\-noqualifier\fP is used.  
 .TP 3
-\-notimestamp\
-Suppresses the timestamp, which is hidden in an HTML comment in the generated HTML near the top of each page. Useful when you want to run javadoc on two source bases and diff them, as it prevents timestamps from causing a diff (which would otherwise be a diff on every page). The timestamp includes the javadoc version number, and currently looks like this:
+\-notimestamp\  
+Suppresses the timestamp, which is hidden in an HTML comment in the generated HTML near the top of each page. Useful when you want to run javadoc on two source bases and diff them, as it prevents timestamps from causing a diff (which would otherwise be a diff on every page). The timestamp includes the javadoc version number, and currently looks like this: 
 .nf
 \f3
 .fl
@@ -3766,11 +3774,11 @@
 \fP
 .fi
 .TP 3
-\-nocomment\
-Suppress the entire comment body, including the main description and all tags, generating only declarations. This option enables re\-using source files originally intended for a different purpose, to produce skeleton HTML documentation at the early stages of a new project.
+\-nocomment\  
+Suppress the entire comment body, including the main description and all tags, generating only declarations. This option enables re\-using source files originally intended for a different purpose, to produce skeleton HTML documentation at the early stages of a new project. 
 .TP 3
-\-sourcetab tabLength
-Specify the number of spaces each tab takes up in the source.
+\-sourcetab tabLength 
+Specify the number of spaces each tab takes up in the source. 
 .RE
 .SH "COMMAND LINE ARGUMENT FILES"
 .LP
@@ -3781,7 +3789,7 @@
 Filenames within an argument file are relative to the current directory, not the location of the argument file. Wildcards (*) are not allowed in these lists (such as for specifying \f2*.java\fP). Use of the '\f2@\fP' character to recursively interpret files is not supported. The \f2\-J\fP options are not supported because they are passed to the launcher, which does not support argument files.
 .LP
 When executing javadoc, pass in the path and name of each argument file with the '\f2@\fP' leading character. When javadoc encounters an argument beginning with the character `\f2@\fP', it expands the contents of that file into the argument list.
-.SS
+.SS 
 Example \- Single Arg File
 .LP
 You could use a single argument file named "\f2argfile\fP" to hold all Javadoc arguments:
@@ -3793,7 +3801,7 @@
 .fi
 .LP
 This argument file could contain the contents of both files shown in the next example.
-.SS
+.SS 
 Example \- Two Arg Files
 .LP
 You can create two argument files \-\- one for the Javadoc options and the other for the package names or source filenames: (Notice the following lists have no line\-continuation characters.)
@@ -3802,9 +3810,9 @@
 .nf
 \f3
 .fl
-     \-d docs\-filelist
+     \-d docs\-filelist 
 .fl
-     \-use
+     \-use 
 .fl
      \-splitindex
 .fl
@@ -3845,7 +3853,7 @@
   % \fP\f3javadoc @options @packages\fP
 .fl
 .fi
-.SS
+.SS 
 Example \- Arg Files with Paths
 .LP
 The argument files can have paths, but any filenames inside the files are relative to the current working directory (not \f2path1\fP or \f2path2\fP):
@@ -3855,7 +3863,7 @@
   % \fP\f3javadoc @path1/options @path2/packages\fP
 .fl
 .fi
-.SS
+.SS 
 Example \- Option Arguments
 .LP
 Here's an example of saving just an argument to a javadoc option in an argument file. We'll use the \f2\-bottom\fP option, since it can have a lengthy argument. You could create a file named "\f2bottom\fP" containing its text argument:
@@ -3896,13 +3904,13 @@
 .LP
 \f3Version Numbers\fP \- The version number of javadoc can be determined using \f3javadoc \-J\-version\fP. The version number of the standard doclet appears in its output stream. It can be turned off with \f2\-quiet\fP.
 .LP
-\f3Public programmatic interface\fP \- To invoke the Javadoc tool from within programs written in the Java language. This interface is in \f2com.sun.tools.javadoc.Main\fP (and javadoc is re\-entrant). For more details, see
+\f3Public programmatic interface\fP \- To invoke the Javadoc tool from within programs written in the Java language. This interface is in \f2com.sun.tools.javadoc.Main\fP (and javadoc is re\-entrant). For more details, see 
 .na
 \f2Standard Doclet\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javadoc/standard\-doclet.html#runningprogrammatically.
+http://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/standard\-doclet.html#runningprogrammatically.
 .LP
-\f3Running Doclets\fP \- The instructions given below are for invoking the standard HTML doclet. To invoke a custom doclet, use the \-doclet and \-docletpath options. For full, working examples of running a particular doclet, see the
+\f3Running Doclets\fP \- The instructions given below are for invoking the standard HTML doclet. To invoke a custom doclet, use the \-doclet and \-docletpath options. For full, working examples of running a particular doclet, see the 
 .na
 \f2MIF Doclet documentation\fP @
 .fi
@@ -3910,7 +3918,7 @@
 .SH "SIMPLE EXAMPLES"
 .LP
 You can run javadoc on entire packages or individual source files. Each package name has a corresponding directory name. In the following examples, the source files are located at \f2/home/src/java/awt/*.java\fP. The destination directory is \f2/home/html\fP.
-.SS
+.SS 
 Documenting One or More Packages
 .LP
 To document a package, the source files (\f2*.java\fP) for that package must be located in a directory having the same name as the package. If a package name is made up of several identifiers (separated by dots, such as \f2java.awt.color\fP), each subsequent identifier must correspond to a deeper subdirectory (such as \f2java/awt/color\fP). You may split the source files for a single package among two such directory trees located at different places, as long as \f2\-sourcepath\fP points to them both \-\- for example \f2src1/java/awt/color\fP and \f2src2/java/awt/color\fP.
@@ -3919,7 +3927,7 @@
 .RS 3
 .TP 2
 o
-\f3Case 1 \- Run recursively starting from one or more packages\fP \- This example uses \-sourcepath so javadoc can be run from any directory and \-subpackages (a new 1.4 option) for recursion. It traverses the subpackages of the \f2java\fP directory excluding packages rooted at \f2java.net\fP and \f2java.lang\fP. Notice this excludes \f2java.lang.ref\fP, a subpackage of \f2java.lang\fP).
+\f3Case 1 \- Run recursively starting from one or more packages\fP \- This example uses \-sourcepath so javadoc can be run from any directory and \-subpackages (a new 1.4 option) for recursion. It traverses the subpackages of the \f2java\fP directory excluding packages rooted at \f2java.net\fP and \f2java.lang\fP. Notice this excludes \f2java.lang.ref\fP, a subpackage of \f2java.lang\fP). 
 .nf
 \f3
 .fl
@@ -3927,10 +3935,10 @@
 .fl
 .fi
 .LP
-To also traverse down other package trees, append their names to the \f2\-subpackages\fP argument, such as \f2java:javax:org.xml.sax\fP.
+To also traverse down other package trees, append their names to the \f2\-subpackages\fP argument, such as \f2java:javax:org.xml.sax\fP.  
 .TP 2
 o
-\f3Case 2 \- Run on explicit packages after changing to the "root" source directory\fP \- Change to the parent directory of the fully\-qualified package. Then run javadoc, supplying names of one or more packages you want to document:
+\f3Case 2 \- Run on explicit packages after changing to the "root" source directory\fP \- Change to the parent directory of the fully\-qualified package. Then run javadoc, supplying names of one or more packages you want to document: 
 .nf
 \f3
 .fl
@@ -3941,7 +3949,7 @@
 .fi
 .TP 2
 o
-\f3Case 3 \- Run from any directory on explicit packages in a single directory tree\fP \- In this case, it doesn't matter what the current directory is. Run javadoc supplying \f2\-sourcepath\fP with the parent directory of the top\-level package, and supplying names of one or more packages you want to document:
+\f3Case 3 \- Run from any directory on explicit packages in a single directory tree\fP \- In this case, it doesn't matter what the current directory is. Run javadoc supplying \f2\-sourcepath\fP with the parent directory of the top\-level package, and supplying names of one or more packages you want to document: 
 .nf
 \f3
 .fl
@@ -3950,7 +3958,7 @@
 .fi
 .TP 2
 o
-\f3Case 4 \- Run from any directory on explicit packages in multiple directory trees\fP \- This is the same as case 3, but for packages in separate directory trees. Run javadoc supplying \f2\-sourcepath\fP with the path to each tree's root (colon\-separated) and supply names of one or more packages you want to document. All source files for a given package do not need to be located under a single root directory \-\- they just need to be found somewhere along the sourcepath.
+\f3Case 4 \- Run from any directory on explicit packages in multiple directory trees\fP \- This is the same as case 3, but for packages in separate directory trees. Run javadoc supplying \f2\-sourcepath\fP with the path to each tree's root (colon\-separated) and supply names of one or more packages you want to document. All source files for a given package do not need to be located under a single root directory \-\- they just need to be found somewhere along the sourcepath. 
 .nf
 \f3
 .fl
@@ -3960,14 +3968,14 @@
 .RE
 .LP
 Result: All cases generate HTML\-formatted documentation for the public and protected classes and interfaces in packages \f2java.awt\fP and \f2java.awt.event\fP and save the HTML files in the specified destination directory (\f2/home/html\fP). Because two or more packages are being generated, the document has three HTML frames \-\- for the list of packages, the list of classes, and the main class pages.
-.SS
+.SS 
 Documenting One or More Classes
 .LP
 The second way to run the Javadoc tool is by passing in one or more source files (\f2.java\fP). You can run javadoc either of the following two ways \-\- by changing directories (with \f2cd\fP) or by fully\-specifying the path to the \f2.java\fP files. Relative paths are relative to the current directory. The \f2\-sourcepath\fP option is ignored when passing in source files. You can use command line wildcards, such as asterisk (*), to specify groups of classes.
 .RS 3
 .TP 2
 o
-\f3Case 1 \- Changing to the source directory\fP \- Change to the directory holding the \f2.java\fP files. Then run javadoc, supplying names of one or more source files you want to document.
+\f3Case 1 \- Changing to the source directory\fP \- Change to the directory holding the \f2.java\fP files. Then run javadoc, supplying names of one or more source files you want to document. 
 .nf
 \f3
 .fl
@@ -3976,10 +3984,10 @@
   % \f3javadoc \-d /home/html Button.java Canvas.java Graphics*.java\fP
 .fl
 .fi
-This example generates HTML\-formatted documentation for the classes \f2Button\fP, \f2Canvas\fP and classes beginning with \f2Graphics\fP. Because source files rather than package names were passed in as arguments to javadoc, the document has two frames \-\- for the list of classes and the main page.
+This example generates HTML\-formatted documentation for the classes \f2Button\fP, \f2Canvas\fP and classes beginning with \f2Graphics\fP. Because source files rather than package names were passed in as arguments to javadoc, the document has two frames \-\- for the list of classes and the main page. 
 .TP 2
 o
-\f3Case 2 \- Changing to the package root directory\fP \- This is useful for documenting individual source files from different subpackages off the same root. Change to the package root directory, and supply the source files with paths from the root.
+\f3Case 2 \- Changing to the package root directory\fP \- This is useful for documenting individual source files from different subpackages off the same root. Change to the package root directory, and supply the source files with paths from the root. 
 .nf
 \f3
 .fl
@@ -3988,19 +3996,19 @@
   % \f3javadoc \-d /home/html java/awt/Button.java java/applet/Applet.java\fP
 .fl
 .fi
-This example generates HTML\-formatted documentation for the classes \f2Button\fP and \f2Applet\fP.
+This example generates HTML\-formatted documentation for the classes \f2Button\fP and \f2Applet\fP. 
 .TP 2
 o
-\f3Case 3 \- From any directory\fP \- In this case, it doesn't matter what the current directory is. Run javadoc supplying the absolute path (or path relative to the current directory) to the \f2.java\fP files you want to document.
+\f3Case 3 \- From any directory\fP \- In this case, it doesn't matter what the current directory is. Run javadoc supplying the absolute path (or path relative to the current directory) to the \f2.java\fP files you want to document. 
 .nf
 \f3
 .fl
   % \fP\f3javadoc \-d /home/html /home/src/java/awt/Button.java /home/src/java/awt/Graphics*.java\fP
 .fl
 .fi
-This example generates HTML\-formatted documentation for the class \f2Button\fP and classes beginning with \f2Graphics\fP.
+This example generates HTML\-formatted documentation for the class \f2Button\fP and classes beginning with \f2Graphics\fP. 
 .RE
-.SS
+.SS 
 Documenting Both Packages and Classes
 .LP
 You can document entire packages and individual classes at the same time. Here's an example that mixes two of the previous examples. You can use \f2\-sourcepath\fP for the path to the packages but not for the path to the individual classes.
@@ -4017,28 +4025,28 @@
 The Javadoc tool has many useful options, some of which are more commonly used than others. Here is effectively the command we use to run the Javadoc tool on the Java platform API. We use 180MB of memory to generate the documentation for the 1500 (approx.) public and protected classes in the Java SE Platform, Standard Edition, v1.2.
 .LP
 The same example is shown twice \-\- first as executed on the command line, then as executed from a makefile. It uses absolute paths in the option arguments, which enables the same \f2javadoc\fP command to be run from any directory.
-.SS
+.SS 
 Command Line Example
 .LP
 The following example may be too long for some shells such as DOS. You can use a command line argument file (or write a shell script) to workaround this limitation.
 .nf
 \f3
 .fl
-% javadoc \-sourcepath /java/jdk/src/share/classes \\
+% javadoc \-sourcepath /java/jdk/src/share/classes \\ 
 .fl
-    \-overview /java/jdk/src/share/classes/overview.html \\
+    \-overview /java/jdk/src/share/classes/overview.html \\ 
 .fl
-    \-d /java/jdk/build/api \\
+    \-d /java/jdk/build/api \\ 
 .fl
-    \-use \\
+    \-use \\ 
 .fl
-    \-splitIndex \\
+    \-splitIndex \\ 
 .fl
-    \-windowtitle 'Java Platform, Standard Edition 7 API Specification' \\
+    \-windowtitle 'Java Platform, Standard Edition 7 API Specification' \\ 
 .fl
-    \-doctitle 'Java Platform, Standard Edition 7 API Specification' \\
+    \-doctitle 'Java Platform, Standard Edition 7 API Specification' \\ 
 .fl
-    \-header '<b>Java(TM) SE 7</b>' \\
+    \-header '<b>Java(TM) SE 7</b>' \\ 
 .fl
     \-bottom '<font size="\-1">
 .fl
@@ -4048,13 +4056,13 @@
 .fl
       Oracle is a registered trademark of Oracle Corporation and/or its affiliates.
 .fl
-      Other names may be trademarks of their respective owners.</font>' \\
+      Other names may be trademarks of their respective owners.</font>' \\ 
 .fl
-    \-group "Core Packages" "java.*:com.sun.java.*:org.omg.*" \\
+    \-group "Core Packages" "java.*:com.sun.java.*:org.omg.*" \\ 
 .fl
-    \-group "Extension Packages" "javax.*" \\
+    \-group "Extension Packages" "javax.*" \\ 
 .fl
-    \-J\-Xmx180m \\
+    \-J\-Xmx180m \\  
 .fl
     @packages
 .fl
@@ -4062,10 +4070,10 @@
 .fi
 .LP
 where \f2packages\fP is the name of a file containing the packages to process, such as \f2java.applet java.lang\fP. None of the options should contain any newline characters between the single quotes. (For example, if you copy and paste this example, delete the newline characters from the \f2\-bottom\fP option.) See the other notes listed below.
-.SS
+.SS 
 Makefile Example
 .LP
-This is an example of a GNU makefile. For an example of a Windows makefile, see
+This is an example of a GNU makefile. For an example of a Windows makefile, see 
 .na
 \f2creating a makefile for Windows\fP @
 .fi
@@ -4099,11 +4107,11 @@
 .fl
         java.lang java.lang.reflect        \\   /* Sets packages to document      */
 .fl
-        java.util java.io java.net         \\
+        java.util java.io java.net         \\ 
 .fl
         java.applet
 .fl
-
+        
 .fl
 WINDOWTITLE = 'Java(TM) SE 7 API Specification'
 .fl
@@ -4136,91 +4144,91 @@
 .RS 3
 .TP 2
 o
-If you omit the \f2\-windowtitle\fP option, the Javadoc tool copies the doc title to the window title. The \f2\-windowtitle\fP text is basically the same as the \f2\-doctitle\fP but without HTML tags, to prevent those tags from appearing as raw text in the window title.
+If you omit the \f2\-windowtitle\fP option, the Javadoc tool copies the doc title to the window title. The \f2\-windowtitle\fP text is basically the same as the \f2\-doctitle\fP but without HTML tags, to prevent those tags from appearing as raw text in the window title. 
 .TP 2
 o
-If you omit the \f2\-footer\fP option, as done here, the Javadoc tool copies the header text to the footer.
+If you omit the \f2\-footer\fP option, as done here, the Javadoc tool copies the header text to the footer. 
 .TP 2
 o
-Other important options you might want to use but not needed in this example are \-\f2classpath\fP and \-\f2link\fP.
+Other important options you might want to use but not needed in this example are \-\f2classpath\fP and \-\f2link\fP. 
 .RE
 .SH "TROUBLESHOOTING"
-.SS
+.SS 
 General Troubleshooting
 .RS 3
 .TP 2
 o
-\f3Javadoc FAQ\fP \- Commonly\-encountered bugs and troubleshooting tips can be found on the
+\f3Javadoc FAQ\fP \- Commonly\-encountered bugs and troubleshooting tips can be found on the 
 .na
 \f2Javadoc FAQ\fP @
 .fi
-http://java.sun.com/j2se/javadoc/faq/index.html#B
+http://java.sun.com/j2se/javadoc/faq/index.html#B 
 .TP 2
 o
-\f3Bugs and Limitations\fP \- You can also see some bugs listed at Important Bug Fixes and Changes.
+\f3Bugs and Limitations\fP \- You can also see some bugs listed at Important Bug Fixes and Changes. 
 .TP 2
 o
-\f3Version number\fP \- See version numbers.
+\f3Version number\fP \- See version numbers. 
 .TP 2
 o
-\f3Documents only legal classes\fP \- When documenting a package, javadoc only reads files whose names are composed of legal class names. You can prevent javadoc from parsing a file by including, for example, a hyphen "\-" in its filename.
+\f3Documents only legal classes\fP \- When documenting a package, javadoc only reads files whose names are composed of legal class names. You can prevent javadoc from parsing a file by including, for example, a hyphen "\-" in its filename. 
 .RE
-.SS
+.SS 
 Errors and Warnings
 .LP
 Error and warning messages contain the filename and line number to the declaration line rather than to the particular line in the doc comment.
 .RS 3
 .TP 2
 o
-\f2"error: cannot read: Class1.java"\fP the Javadoc tool is trying to load the class Class1.java in the current directory. The class name is shown with its path (absolute or relative), which in this case is the same as \f2./Class1.java\fP.
+\f2"error: cannot read: Class1.java"\fP the Javadoc tool is trying to load the class Class1.java in the current directory. The class name is shown with its path (absolute or relative), which in this case is the same as \f2./Class1.java\fP. 
 .RE
 .SH "ENVIRONMENT"
 .RS 3
 .TP 3
-CLASSPATH
-Environment variable that provides the path which javadoc uses to find user class files. This environment variable is overridden by the \f2\-classpath\fP option. Separate directories with a colon, for example:
-.:/home/classes:/usr/local/java/classes
+CLASSPATH 
+Environment variable that provides the path which javadoc uses to find user class files. This environment variable is overridden by the \f2\-classpath\fP option. Separate directories with a colon, for example: 
+.:/home/classes:/usr/local/java/classes 
 .RE
 .SH "SEE ALSO"
 .RS 3
 .TP 2
 o
-javac(1)
+javac(1) 
 .TP 2
 o
-java(1)
+java(1) 
 .TP 2
 o
-jdb(1)
+jdb(1) 
 .TP 2
 o
-javah(1)
+javah(1) 
 .TP 2
 o
-javap(1)
+javap(1) 
 .TP 2
 o
 .na
 \f2Javadoc Home Page\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-jsp\-135444.html
+http://www.oracle.com/technetwork/java/javase/documentation/index\-jsp\-135444.html 
 .TP 2
 o
 .na
 \f2How to Write Doc Comments for Javadoc\fP @
 .fi
-http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html
+http://www.oracle.com/technetwork/java/javase/documentation/index\-137868.html 
 .TP 2
 o
 .na
 \f2Setting the Class Path\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#general
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#general 
 .TP 2
 o
 .na
 \f2How Javac and Javadoc Find Classes\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/findingclasses.html#srcfiles (tools.jar)
+http://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html#srcfiles (tools.jar) 
 .RE
-
+ 
--- jdk/src/bsd/doc/man/javah.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/javah.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH javah 1 "10 May 2011"
+.TH javah 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -57,29 +57,29 @@
 .LP
 .RS 3
 .TP 3
-\-o outputfile
-Concatenates the resulting header or source files for all the classes listed on the command line into \f2outputfile\fP. Only one of \f3\-o\fP or \f3\-d\fP may be used.
+\-o outputfile 
+Concatenates the resulting header or source files for all the classes listed on the command line into \f2outputfile\fP. Only one of \f3\-o\fP or \f3\-d\fP may be used. 
 .TP 3
-\-d directory
-Sets the directory where \f3javah\fP saves the header files or the stub files. Only one of \f3\-d\fP or \f3\-o\fP may be used.
+\-d directory 
+Sets the directory where \f3javah\fP saves the header files or the stub files. Only one of \f3\-d\fP or \f3\-o\fP may be used. 
 .TP 3
-\-stubs
-Causes \f3javah\fP to generate C declarations from the Java object file.
+\-stubs 
+Causes \f3javah\fP to generate C declarations from the Java object file. 
 .TP 3
-\-verbose
-Indicates verbose output and causes \f3javah\fP to print a message to stdout concerning the status of the generated files.
+\-verbose 
+Indicates verbose output and causes \f3javah\fP to print a message to stdout concerning the status of the generated files. 
 .TP 3
-\-help
-Print help message for \f3javah\fP usage.
+\-help 
+Print help message for \f3javah\fP usage. 
 .TP 3
-\-version
-Print out \f3javah\fP version information.
+\-version 
+Print out \f3javah\fP version information. 
 .TP 3
-\-jni
-Causes \f3javah\fP to create an output file containing JNI\-style native method function prototypes. This is the default output, so use of \f3\-jni\fP is optional.
+\-jni 
+Causes \f3javah\fP to create an output file containing JNI\-style native method function prototypes. This is the default output, so use of \f3\-jni\fP is optional. 
 .TP 3
-\-classpath path
-Specifies the path \f3javah\fP uses to look up classes. Overrides the default or the CLASSPATH environment variable if it is set. Directories are separated by colons. Thus the general format for \f2path\fP is:
+\-classpath path 
+Specifies the path \f3javah\fP uses to look up classes. Overrides the default or the CLASSPATH environment variable if it is set. Directories are separated by colons. Thus the general format for \f2path\fP is: 
 .nf
 \f3
 .fl
@@ -87,7 +87,7 @@
 .fl
 \fP
 .fi
-For example:
+For example: 
 .nf
 \f3
 .fl
@@ -98,19 +98,19 @@
 As a special convenience, a class path element containing a basename of \f2*\fP is considered equivalent to specifying a list of all the files in the directory with the extension \f2.jar\fP or \f2.JAR\fP (a java program cannot tell the difference between the two invocations).
 .br
 .br
-For example, if directory \f2foo\fP contains \f2a.jar\fP and \f2b.JAR\fP, then the class path element \f2foo/*\fP is expanded to a \f2A.jar:b.JAR\fP, except that the order of jar files is unspecified. All jar files in the specified directory, even hidden ones, are included in the list. A classpath entry consisting simply of \f2*\fP expands to a list of all the jar files in the current directory. The \f2CLASSPATH\fP environment variable, where defined, will be similarly expanded. Any classpath wildcard expansion occurs before the Java virtual machine is started \-\- no Java program will ever see unexpanded wildcards except by querying the environment. For example; by invoking \f2System.getenv("CLASSPATH")\fP.
+For example, if directory \f2foo\fP contains \f2a.jar\fP and \f2b.JAR\fP, then the class path element \f2foo/*\fP is expanded to a \f2A.jar:b.JAR\fP, except that the order of jar files is unspecified. All jar files in the specified directory, even hidden ones, are included in the list. A classpath entry consisting simply of \f2*\fP expands to a list of all the jar files in the current directory. The \f2CLASSPATH\fP environment variable, where defined, will be similarly expanded. Any classpath wildcard expansion occurs before the Java virtual machine is started \-\- no Java program will ever see unexpanded wildcards except by querying the environment. For example; by invoking \f2System.getenv("CLASSPATH")\fP.  
 .TP 3
-\-bootclasspath path
-Specifies path from which to load bootstrap classes. By default, the bootstrap classes are the classes implementing the core Java 2 platform located in \f2jre/lib/rt.jar\fP and several other jar files.
+\-bootclasspath path 
+Specifies path from which to load bootstrap classes. By default, the bootstrap classes are the classes implementing the core Java 2 platform located in \f2jre/lib/rt.jar\fP and several other jar files. 
 .TP 3
-\-old
-Specifies that old JDK1.0\-style header files should be generated.
+\-old 
+Specifies that old JDK1.0\-style header files should be generated. 
 .TP 3
-\-force
-Specifies that output files should always be written.
+\-force 
+Specifies that output files should always be written. 
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. 
 .RE
 
 .LP
@@ -118,8 +118,8 @@
 .LP
 .RS 3
 .TP 3
-CLASSPATH
-Used to provide the system a path to user\-defined classes. Directories are separated by colons, for example,
+CLASSPATH 
+Used to provide the system a path to user\-defined classes. Directories are separated by colons, for example, 
 .nf
 \f3
 .fl
@@ -135,4 +135,4 @@
 .LP
 javac(1), java(1), jdb(1), javap(1), javadoc(1)
 .LP
-
+ 
--- jdk/src/bsd/doc/man/javap.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/javap.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH javap 1 "10 May 2011"
+.TH javap 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -46,11 +46,11 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options.
+options 
+Command\-line options. 
 .TP 3
-classes
-List of one or more classes (separated by spaces) to be processed for annotations (such as \f2DocFooter.class\fP). You may specify a class that can be found in the class path, by its file name (for example, \f2/home/user/myproject/src/DocFooter.class\fP), or with a URL (for example, \f2file:///home/user/myproject/src/DocFooter.class\fP).
+classes 
+List of one or more classes (separated by spaces) to be processed for annotations (such as \f2DocFooter.class\fP). You may specify a class that can be found in the class path, by its file name (for example, \f2/home/user/myproject/src/DocFooter.class\fP), or with a URL (for example, \f2file:///home/user/myproject/src/DocFooter.class\fP). 
 .RE
 
 .LP
@@ -148,11 +148,11 @@
 .fl
     Code:
 .fl
-       0: aload_0
+       0: aload_0       
 .fl
        1: invokespecial #1                  // Method java/applet/Applet."<init>":()V
 .fl
-       4: return
+       4: return        
 .fl
 
 .fl
@@ -160,7 +160,7 @@
 .fl
     Code:
 .fl
-       0: aload_0
+       0: aload_0       
 .fl
        1: sipush        500
 .fl
@@ -168,9 +168,9 @@
 .fl
        6: invokevirtual #2                  // Method resize:(II)V
 .fl
-       9: aload_0
+       9: aload_0       
 .fl
-      10: aload_0
+      10: aload_0       
 .fl
       11: ldc           #3                  // String LAST_UPDATED
 .fl
@@ -178,9 +178,9 @@
 .fl
       16: putfield      #5                  // Field date:Ljava/lang/String;
 .fl
-      19: aload_0
+      19: aload_0       
 .fl
-      20: aload_0
+      20: aload_0       
 .fl
       21: ldc           #6                  // String EMAIL
 .fl
@@ -188,7 +188,7 @@
 .fl
       26: putfield      #7                  // Field email:Ljava/lang/String;
 .fl
-      29: return
+      29: return        
 .fl
 
 .fl
@@ -196,21 +196,21 @@
 .fl
     Code:
 .fl
-       0: aload_1
+       0: aload_1       
 .fl
        1: new           #8                  // class java/lang/StringBuilder
 .fl
-       4: dup
+       4: dup           
 .fl
        5: invokespecial #9                  // Method java/lang/StringBuilder."<init>":()V
 .fl
-       8: aload_0
+       8: aload_0       
 .fl
        9: getfield      #5                  // Field date:Ljava/lang/String;
 .fl
       12: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
 .fl
-      15: ldc           #11                 // String  by
+      15: ldc           #11                 // String  by 
 .fl
       17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
 .fl
@@ -222,9 +222,9 @@
 .fl
       27: invokevirtual #13                 // Method java/awt/Graphics.drawString:(Ljava/lang/String;II)V
 .fl
-      30: aload_1
+      30: aload_1       
 .fl
-      31: aload_0
+      31: aload_0       
 .fl
       32: getfield      #7                  // Field email:Ljava/lang/String;
 .fl
@@ -234,7 +234,7 @@
 .fl
       40: invokevirtual #13                 // Method java/awt/Graphics.drawString:(Ljava/lang/String;II)V
 .fl
-      43: return
+      43: return        
 .fl
 }
 .fl
@@ -246,29 +246,29 @@
 .LP
 .RS 3
 .TP 3
-\-help \-\-help \-?
-Prints out help message for \f3javap\fP.
+\-help \-\-help \-? 
+Prints out help message for \f3javap\fP. 
 .TP 3
-\-version
-Prints out version information.
+\-version 
+Prints out version information. 
 .TP 3
-\-l
-Prints out line and local variable tables.
+\-l 
+Prints out line and local variable tables. 
 .TP 3
-\-public
-Shows only public classes and members.
+\-public 
+Shows only public classes and members. 
 .TP 3
-\-protected
-Shows only protected and public classes and members.
+\-protected 
+Shows only protected and public classes and members. 
 .TP 3
-\-package
-Shows only package, protected, and public classes and members. This is the default.
+\-package 
+Shows only package, protected, and public classes and members. This is the default. 
 .TP 3
-\-private \-p
-Shows all classes and members.
+\-private \-p 
+Shows all classes and members. 
 .TP 3
-\-Jflag
-Pass \f2flag\fP directly to the runtime system. Some examples:
+\-Jflag 
+Pass \f2flag\fP directly to the runtime system. Some examples: 
 .nf
 \f3
 .fl
@@ -279,33 +279,33 @@
 \fP
 .fi
 .TP 3
-\-s
-Prints internal type signatures.
+\-s 
+Prints internal type signatures. 
 .TP 3
-\-sysinfo
-Shows system information (path, size, date, MD5 hash) of the class being processed.
+\-sysinfo 
+Shows system information (path, size, date, MD5 hash) of the class being processed. 
 .TP 3
-\-constants
-Shows static final constants.
+\-constants 
+Shows static final constants. 
 .TP 3
-\-c
-Prints out disassembled code, i.e., the instructions that comprise the Java bytecodes, for each of the methods in the class. These are documented in the
+\-c 
+Prints out disassembled code, i.e., the instructions that comprise the Java bytecodes, for each of the methods in the class. These are documented in the 
 .na
 \f2Java Virtual Machine Specification\fP @
 .fi
-http://java.sun.com/docs/books/vmspec/.
+http://java.sun.com/docs/books/vmspec/. 
 .TP 3
-\-verbose
-Prints stack size, number of \f2locals\fP and \f2args\fP for methods.
+\-verbose 
+Prints stack size, number of \f2locals\fP and \f2args\fP for methods. 
 .TP 3
-\-classpath path
-Specifies the path \f3javap\fP uses to look up classes. Overrides the default or the CLASSPATH environment variable if it is set.
+\-classpath path 
+Specifies the path \f3javap\fP uses to look up classes. Overrides the default or the CLASSPATH environment variable if it is set. 
 .TP 3
-\-bootclasspath path
-Specifies path from which to load bootstrap classes. By default, the bootstrap classes are the classes implementing the core Java platform located in \f2jre/lib/rt.jar\fP and several other jar files.
+\-bootclasspath path 
+Specifies path from which to load bootstrap classes. By default, the bootstrap classes are the classes implementing the core Java platform located in \f2jre/lib/rt.jar\fP and several other jar files. 
 .TP 3
-\-extdirs dirs
-Overrides location at which installed extensions are searched for. The default location for extensions is the value of \f2java.ext.dirs\fP.
+\-extdirs dirs 
+Overrides location at which installed extensions are searched for. The default location for extensions is the value of \f2java.ext.dirs\fP. 
 .RE
 
 .LP
@@ -314,4 +314,4 @@
 .LP
 javac(1), java(1), jdb(1), javah(1), javadoc(1)
 .LP
-
+ 
--- jdk/src/bsd/doc/man/javaws.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/javaws.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH javaws 1 "10 May 2011"
+.TH javaws 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -204,19 +204,19 @@
 .SH "FILES"
 .LP
 .LP
-For information about the user and system cache and deployment.properties files, see
+For information about the user and system cache and deployment.properties files, see 
 .na
 \f2System\- and User\-Level Properties\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/deployment/deployment\-guide/properties.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/deployment/deployment\-guide/properties.html.
 .LP
 .SH "MORE INFORMATION"
 .LP
 .LP
-For more information about Java Web Start, see
+For more information about Java Web Start, see 
 .na
 \f2Java Web Start\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/javaws/index.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/index.html.
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jcmd.1	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/bsd/doc/man/jcmd.1	2013-05-05 09:38:28.000000000 -0700
@@ -0,0 +1,118 @@
+." Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.
+." DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+."
+." This code is free software; you can redistribute it and/or modify it
+." under the terms of the GNU General Public License version 2 only, as
+." published by the Free Software Foundation.
+."
+." This code is distributed in the hope that it will be useful, but WITHOUT
+." ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+." FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+." version 2 for more details (a copy is included in the LICENSE file that
+." accompanied this code).
+."
+." You should have received a copy of the GNU General Public License version
+." 2 along with this work; if not, write to the Free Software Foundation,
+." Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+."
+." Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+." or visit www.oracle.com if you need additional information or have any
+." questions.
+."
+.TH jcmd 1 "10 Jul 2012"
+
+.LP
+.SH "Name"
+jcmd \- Diagnostic Command
+.LP
+.LP
+\f3jcmd\fP is a utility to send diagnostic command requests to a running Java Virtual Machine.
+.LP
+.SH "SYNOPSIS"
+.LP
+.nf
+\f3
+.fl
+    \fP\f3jcmd\fP [ option ] 
+.fl
+    \f3jcmd\fP <\f2pid\fP | \f2main class\fP> PerfCounter.print
+.fl
+    \f3jcmd\fP <\f2pid\fP | \f2main class\fP> \f2command\fP [\f2arguments\fP]
+.fl
+    \f3jcmd\fP <\f2pid\fP | \f2main class\fP> \-f \f2file\fP
+.fl
+.fi
+
+.LP
+.SH "DESCRIPTION"
+.LP
+.LP
+\f3jcmd\fP is a utility to send diagnostic command requests to a Java Virtual Machine supporting this feature.
+.LP
+.LP
+Used without arguments or with the \-l option, jcmd prints the list of running Java processes with their process id, their main class and their command line arguments.
+.LP
+.LP
+When a process id is specified on the command line, jcmd sends the diagnostic command request to the process with this id.
+.LP
+.LP
+When a main class is specified on the command line, jcmd sends the diagnostic command request to all Java processes for which the command line argument is a substring of the Java process' main class.
+.LP
+.LP
+With the PerfCounter.print argument, jcmd prints the performance counters available on the targeted Java process(es).
+.LP
+.LP
+With the \-f option, jcmd sends to the targeted Java process(es) the diagnostic commands stored in the file \f2file\fP.
+.LP
+.SH "OPTIONS"
+.LP
+.LP
+Options are mutually exclusive. Options, if used, should follow immediately after the command name.
+.LP
+.RS 3
+.TP 3
+\-l 
+Prints the list of running Java processes with their process id, their main class and their command line arguments. 
+.TP 3
+\-h 
+Prints a help message. 
+.TP 3
+\-help 
+Prints a help message. 
+.RE
+
+.LP
+.SH "PARAMETERS"
+.LP
+.RS 3
+.TP 3
+pid 
+Identifies the process that receives the diagnostic command requests. The process must be a Java process. To get a list of Java processes running on a machine, use jps(1) or jcmd(1). 
+.TP 3
+main class 
+Main class of the process that receives the diagnostic command requests. When matching processes, any process whose main class name contains the specified string as a substring will be matched. If several running Java processes share this main class, the diagnostic command request is sent to all these processes. To get a list of Java processes running on a machine, use jps(1) or jcmd(1). 
+.TP 3
+command [arguments] 
+Invoke the diagnostic command called \f2command\fP on the targeted Java process(es). The list of available diagnostic commands for a given process can be obtained by invoking the \f3help\fP command on this process. Each diagnostic command has its own set of \f2arguments\fP, which can be obtained by invoking the the command name followed by \f3help\fP. 
+.TP 3
+PerfCounter.print 
+Print the performance counters available on the targeted Java process(es). The list of performance counters may vary with the Java process. 
+.TP 3
+\-f file 
+Read commands from \f2file\fP and invoke them on the targeted Java process(es). In \f2file\fP, each command must be written on a single line. Lines starting with # are ignored. Processing of \f2file\fP ends when all lines have been invoked or when a line containing the \f3stop\fP keyword is read. 
+.RE
+
+.LP
+.SH "SEE ALSO"
+.LP
+.RS 3
+.TP 2
+o
+jps(1) 
+.RE
+
+.LP
+.LP
+jps(1)
+.LP
+ 
--- jdk/src/bsd/doc/man/jconsole.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jconsole.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jconsole 1 "10 May 2011"
+.TH jconsole 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -41,32 +41,32 @@
 .LP
 .RS 3
 .TP 3
-options
-Options, if used, should follow immediately after the command name.
+options 
+Options, if used, should follow immediately after the command name. 
 .TP 3
-connection = pid | host:port | jmxUrl
+connection = pid | host:port | jmxUrl 
 .RS 3
 .TP 2
 o
-\f2pid\fP Process ID of a local Java VM. The Java VM must be running with the same user ID as the user ID running jconsole. See
+\f2pid\fP Process ID of a local Java VM. The Java VM must be running with the same user ID as the user ID running jconsole. See 
 .na
 \f2JMX Monitoring and Management\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/management/agent.html for details.
+http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html for details. 
 .TP 2
 o
-\f2host\fP:\f2port\fP Name of the host system on which the Java VM is running and the port number specified by the system property \f2com.sun.management.jmxremote.port\fP when the Java VM was started. See
+\f2host\fP:\f2port\fP Name of the host system on which the Java VM is running and the port number specified by the system property \f2com.sun.management.jmxremote.port\fP when the Java VM was started. See 
 .na
 \f2JMX Monitoring and Management\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/management/agent.html for details.
+http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html for details. 
 .TP 2
 o
-\f2jmxUrl\fP Address of the JMX agent to be connected to as described in
+\f2jmxUrl\fP Address of the JMX agent to be connected to as described in 
 .na
 \f2JMXServiceURL\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/javax/management/remote/JMXServiceURL.html.
+http://docs.oracle.com/javase/7/docs/api/javax/management/remote/JMXServiceURL.html. 
 .RE
 .RE
 
@@ -83,13 +83,13 @@
 .LP
 .RS 3
 .TP 3
-\-interval=n
-Set the update interval to \f2n\fP seconds (default is 4 seconds).
+\-interval=n 
+Set the update interval to \f2n\fP seconds (default is 4 seconds). 
 .TP 3
-\-notile
-Do not tile windows initially (for two or more connections).
+\-notile 
+Do not tile windows initially (for two or more connections). 
 .TP 3
-\-pluginpath plugins
+\-pluginpath plugins 
 Specify a list of directories or JAR files which are searched for JConsole plugins. The \f2plugins\fP path should contain a provider\-configuration file named:
 .br
 .nf
@@ -99,20 +99,20 @@
 .fl
 \fP
 .fi
-containing one line for each plugin specifying the fully qualified class name of the class implementing the
+containing one line for each plugin specifying the fully qualified class name of the class implementing the 
 .na
 \f2com.sun.tools.jconsole.JConsolePlugin\fP @
 .fi
-http://download.oracle.com/javase/7/docs/jdk/api/jconsole/spec/com/sun/tools/jconsole/JConsolePlugin.html class.
+http://docs.oracle.com/javase/7/docs/jdk/api/jconsole/spec/com/sun/tools/jconsole/JConsolePlugin.html class. 
 .TP 3
-\-version
-Output version information and exit.
+\-version 
+Output version information and exit. 
 .TP 3
-\-help
-Output help message and exit.
+\-help 
+Output help message and exit. 
 .TP 3
-\-J<flag>
-Pass <flag> to the Java virtual machine on which jconsole is run.
+\-J<flag> 
+Pass <flag> to the Java virtual machine on which jconsole is run. 
 .RE
 
 .LP
@@ -124,14 +124,14 @@
 .na
 \f2Using JConsole\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html 
 .TP 2
 o
 .na
 \f2Monitoring and Management for Java Platform\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/management/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/management/index.html 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jdb.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jdb.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jdb 1 "10 May 2011"
+.TH jdb 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -33,34 +33,34 @@
 .nf
 \f3
 .fl
-\fP\f3jdb\fP [ options ] [ class ] [ arguments ]
+\fP\f3jdb\fP [ options ] [ class ] [ arguments ] 
 .fl
 .fi
 
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options, as specified below.
+options 
+Command\-line options, as specified below. 
 .TP 3
-class
-Name of the class to begin debugging.
+class 
+Name of the class to begin debugging. 
 .TP 3
-arguments
-Arguments passed to the \f2main()\fP method of \f2class\fP.
+arguments 
+Arguments passed to the \f2main()\fP method of \f2class\fP. 
 .RE
 
 .LP
 .SH "DESCRIPTION"
 .LP
 .LP
-The Java Debugger, \f3jdb\fP, is a simple command\-line debugger for Java classes. It is a demonstration of the
+The Java Debugger, \f3jdb\fP, is a simple command\-line debugger for Java classes. It is a demonstration of the 
 .na
 \f2Java Platform Debugger Architecture\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jpda/index.html that provides inspection and debugging of a local or remote Java Virtual Machine.
+http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/index.html that provides inspection and debugging of a local or remote Java Virtual Machine.
 .LP
-.SS
+.SS 
 Starting a jdb Session
 .LP
 .LP
@@ -69,7 +69,7 @@
 .nf
 \f3
 .fl
- % jdb MyClass
+ % jdb MyClass 
 .fl
 \fP
 .fi
@@ -108,7 +108,7 @@
 .nf
 \f3
 .fl
- % jdb \-attach 8000
+ % jdb \-attach 8000 
 .fl
 \fP
 .fi
@@ -118,17 +118,17 @@
 Note that "MyClass" is not specified in the \f3jdb\fP command line in this case because \f3jdb\fP is connecting to an existing VM instead of launching a new one.
 .LP
 .LP
-There are many other ways to connect the debugger to a VM, and all of them are supported by \f3jdb\fP. The Java Platform Debugger Architecture has additional
+There are many other ways to connect the debugger to a VM, and all of them are supported by \f3jdb\fP. The Java Platform Debugger Architecture has additional 
 .na
 \f2documentation\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html on these connection options. For information on starting a J2SE 1.4.2 or early VM for use with \f3jdb\fP see the
+http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html on these connection options. For information on starting a J2SE 1.4.2 or early VM for use with \f3jdb\fP see the 
 .na
 \f21.4.2 documentation\fP @
 .fi
 http://java.sun.com/j2se/1.4.2/docs/guide/jpda/conninv.html
 .LP
-.SS
+.SS 
 Basic jdb Commands
 .LP
 .LP
@@ -136,49 +136,49 @@
 .LP
 .RS 3
 .TP 3
-help, or ?
-The most important \f3jdb\fP command, \f2help\fP displays the list of recognized commands with a brief description.
+help, or ? 
+The most important \f3jdb\fP command, \f2help\fP displays the list of recognized commands with a brief description. 
 .TP 3
-run
-After starting \f3jdb\fP, and setting any necessary breakpoints, you can use this command to start the execution the debugged application. This command is available only when \f3jdb\fP launches the debugged application (as opposed to attaching to an existing VM).
+run 
+After starting \f3jdb\fP, and setting any necessary breakpoints, you can use this command to start the execution the debugged application. This command is available only when \f3jdb\fP launches the debugged application (as opposed to attaching to an existing VM). 
 .TP 3
-cont
-Continues execution of the debugged application after a breakpoint, exception, or step.
+cont 
+Continues execution of the debugged application after a breakpoint, exception, or step. 
 .TP 3
-print
+print 
 Displays Java objects and primitive values. For variables or fields of primitive types, the actual value is printed. For objects, a short description is printed. See the \f2dump\fP command below for getting more information about an object.
 .br
 .br
 \f2NOTE: To display local variables, the containing class must have been compiled with the \fP\f2javac(1)\fP\f2 \fP\f2\-g\fP option.
 .br
 .br
-\f2print\fP supports many simple Java expressions including those with method invocations, for example:
+\f2print\fP supports many simple Java expressions including those with method invocations, for example: 
 .RS 3
 .TP 2
 o
-\f2print MyClass.myStaticField\fP
+\f2print MyClass.myStaticField\fP 
 .TP 2
 o
-\f2print myObj.myInstanceField\fP
+\f2print myObj.myInstanceField\fP 
 .TP 2
 o
-\f2print i + j + k\fP \f2(i, j, k are primities and either fields or local variables)\fP
+\f2print i + j + k\fP \f2(i, j, k are primities and either fields or local variables)\fP 
 .TP 2
 o
-\f2print myObj.myMethod()\fP \f2(if myMethod returns a non\-null)\fP
+\f2print myObj.myMethod()\fP \f2(if myMethod returns a non\-null)\fP 
 .TP 2
 o
-\f2print new java.lang.String("Hello").length()\fP
+\f2print new java.lang.String("Hello").length()\fP 
 .RE
 .TP 3
-dump
+dump 
 For primitive values, this command is identical to \f2print\fP. For objects, it prints the current value of each field defined in the object. Static and instance fields are included.
 .br
 .br
-The \f2dump\fP command supports the same set of expressions as the \f2print\fP command.
+The \f2dump\fP command supports the same set of expressions as the \f2print\fP command. 
 .TP 3
-threads
-List the threads that are currently running. For each thread, its name and current status are printed, as well as an index that can be used for other commands, for example:
+threads 
+List the threads that are currently running. For each thread, its name and current status are printed, as well as an index that can be used for other commands, for example: 
 .nf
 \f3
 .fl
@@ -186,20 +186,20 @@
 .fl
 \fP
 .fi
-In this example, the thread index is 4, the thread is an instance of java.lang.Thread, the thread name is "main", and it is currently running,
+In this example, the thread index is 4, the thread is an instance of java.lang.Thread, the thread name is "main", and it is currently running, 
 .TP 3
-thread
-Select a thread to be the current thread. Many \f3jdb\fP commands are based on the setting of the current thread. The thread is specified with the thread index described in the \f2threads\fP command above.
+thread 
+Select a thread to be the current thread. Many \f3jdb\fP commands are based on the setting of the current thread. The thread is specified with the thread index described in the \f2threads\fP command above. 
 .TP 3
-where
+where 
 \f2where\fP with no arguments dumps the stack of the current thread. \f2where all\fP dumps the stack of all threads in the current thread group. \f2where\fP \f2threadindex\fP dumps the stack of the specified thread.
 .br
 .br
-If the current thread is suspended (either through an event such as a breakpoint or through the \f2suspend\fP command), local variables and fields can be displayed with the \f2print\fP and \f2dump\fP commands. The \f2up\fP and \f2down\fP commands select which stack frame is current.
+If the current thread is suspended (either through an event such as a breakpoint or through the \f2suspend\fP command), local variables and fields can be displayed with the \f2print\fP and \f2dump\fP commands. The \f2up\fP and \f2down\fP commands select which stack frame is current. 
 .RE
 
 .LP
-.SS
+.SS 
 Breakpoints
 .LP
 .LP
@@ -208,16 +208,16 @@
 .RS 3
 .TP 2
 o
-\f2stop at MyClass:22\fP \f2(sets a breakpoint at the first instruction for line 22 of the source file containing MyClass)\fP
+\f2stop at MyClass:22\fP \f2(sets a breakpoint at the first instruction for line 22 of the source file containing MyClass)\fP 
 .TP 2
 o
-\f2stop in java.lang.String.length\fP \f2(sets a breakpoint at the beginnig of the method \fP\f2java.lang.String.length\fP)
+\f2stop in java.lang.String.length\fP \f2(sets a breakpoint at the beginnig of the method \fP\f2java.lang.String.length\fP) 
 .TP 2
 o
-\f2stop in MyClass.<init>\fP \f2(<init> identifies the MyClass constructor)\fP
+\f2stop in MyClass.<init>\fP \f2(<init> identifies the MyClass constructor)\fP 
 .TP 2
 o
-\f2stop in MyClass.<clinit>\fP \f2(<clinit> identifies the static initialization code for MyClass)\fP
+\f2stop in MyClass.<clinit>\fP \f2(<clinit> identifies the static initialization code for MyClass)\fP 
 .RE
 
 .LP
@@ -227,13 +227,13 @@
 .LP
 The \f2clear\fP command removes breakpoints using a syntax as in "\f2clear\ MyClass:45\fP". Using the \f2clear\fP or command with no argument displays a list of all breakpoints currently set. The \f2cont\fP command continues execution.
 .LP
-.SS
+.SS 
 Stepping
 .LP
 .LP
 The \f2step\fP commands advances execution to the next line whether it is in the current stack frame or a called method. The \f2next\fP command advances execution to the next line in the current stack frame.
 .LP
-.SS
+.SS 
 Exceptions
 .LP
 .LP
@@ -258,67 +258,67 @@
 .LP
 .RS 3
 .TP 3
-\-help
-Displays a help message.
+\-help 
+Displays a help message. 
 .TP 3
-\-sourcepath <dir1:dir2:...>
-Uses the given path in searching for source files in the specified path. If this option is not specified, the default path of "." is used.
+\-sourcepath <dir1:dir2:...> 
+Uses the given path in searching for source files in the specified path. If this option is not specified, the default path of "." is used. 
 .TP 3
-\-attach <address>
-Attaches the debugger to previously running VM using the default connection mechanism.
+\-attach <address> 
+Attaches the debugger to previously running VM using the default connection mechanism. 
 .TP 3
-\-listen <address>
-Waits for a running VM to connect at the specified address using standard connector.
+\-listen <address> 
+Waits for a running VM to connect at the specified address using standard connector. 
 .TP 3
-\-listenany
-Waits for a running VM to connect at any available address using standard connector.
+\-listenany 
+Waits for a running VM to connect at any available address using standard connector. 
 .TP 3
-\-launch
-Launches the debugged application immediately upon startup of jdb. This option removes the need for using the \f2run\fP command. The debuged application is launched and then stopped just before the initial application class is loaded. At that point you can set any necessary breakpoints and use the \f2cont\fP to continue execution.
+\-launch 
+Launches the debugged application immediately upon startup of jdb. This option removes the need for using the \f2run\fP command. The debuged application is launched and then stopped just before the initial application class is loaded. At that point you can set any necessary breakpoints and use the \f2cont\fP to continue execution. 
 .TP 3
-\-listconnectors
-List the connectors available in this VM
+\-listconnectors 
+List the connectors available in this VM 
 .TP 3
-\-connect <connector\-name>:<name1>=<value1>,...
-Connects to target VM using named connector with listed argument values.
+\-connect <connector\-name>:<name1>=<value1>,... 
+Connects to target VM using named connector with listed argument values. 
 .TP 3
-\-dbgtrace [flags]
-Prints info for debugging jdb.
+\-dbgtrace [flags] 
+Prints info for debugging jdb. 
 .TP 3
-\-tclient
-Runs the application in the Java HotSpot(tm) VM (Client).
+\-tclient 
+Runs the application in the Java HotSpot(tm) VM (Client). 
 .TP 3
-\-tserver
-Runs the application in the Java HotSpot(tm) VM (Server).
+\-tserver 
+Runs the application in the Java HotSpot(tm) VM (Server). 
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine used to run jdb. (Options for the application Java virtual machine are passed to the \f3run\fP command.) For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine used to run jdb. (Options for the application Java virtual machine are passed to the \f3run\fP command.) For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. 
 .RE
 
 .LP
 .LP
-Other options are supported for alternate mechanisms for connecting the debugger and the VM it is to debug. The Java Platform Debugger Architecture has additional
+Other options are supported for alternate mechanisms for connecting the debugger and the VM it is to debug. The Java Platform Debugger Architecture has additional 
 .na
 \f2documentation\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html on these connection alternatives.
+http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html on these connection alternatives.
 .LP
-.SS
+.SS 
 Options Forwarded to Debuggee Process
 .LP
 .RS 3
 .TP 3
-\-v \-verbose[:class|gc|jni]
-Turns on verbose mode.
+\-v \-verbose[:class|gc|jni] 
+Turns on verbose mode. 
 .TP 3
-\-D<name>=<value>
-Sets a system property.
+\-D<name>=<value> 
+Sets a system property. 
 .TP 3
-\-classpath <directories separated by ":">
-Lists directories in which to look for classes.
+\-classpath <directories separated by ":"> 
+Lists directories in which to look for classes. 
 .TP 3
-\-X<option>
-Non\-standard target VM option
+\-X<option> 
+Non\-standard target VM option 
 .RE
 
 .LP
@@ -327,4 +327,4 @@
 .LP
 javac(1), java(1), javah(1), javap(1), javadoc(1).
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jhat.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jhat.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jhat 1 "10 May 2011"
+.TH jhat 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -41,11 +41,11 @@
 .LP
 .RS 3
 .TP 3
-options
-Options, if used, should follow immediately after the command name.
+options 
+Options, if used, should follow immediately after the command name. 
 .TP 3
-heap\-dump\-file
-Java binary heap dump file to be browsed. For a dump file that contains multiple heap dumps, you may specify which dump in the file by appending "#<number> to the file name, i.e. "foo.hprof#3".
+heap\-dump\-file 
+Java binary heap dump file to be browsed. For a dump file that contains multiple heap dumps, you may specify which dump in the file by appending "#<number> to the file name, i.e. "foo.hprof#3". 
 .RE
 
 .LP
@@ -60,24 +60,24 @@
 .RS 3
 .TP 2
 o
-Use jmap(1) \-dump option to obtain a heap dump at runtime;
+Use jmap(1) \-dump option to obtain a heap dump at runtime; 
 .TP 2
 o
-Use jconsole(1) option to obtain a heap dump via
+Use jconsole(1) option to obtain a heap dump via 
 .na
 \f2HotSpotDiagnosticMXBean\fP @
 .fi
-http://download.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/HotSpotDiagnosticMXBean.html at runtime;
+http://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/HotSpotDiagnosticMXBean.html at runtime; 
 .TP 2
 o
-Heap dump will be generated when OutOfMemoryError is thrown by specifying \-XX:+HeapDumpOnOutOfMemoryError VM option;
+Heap dump will be generated when OutOfMemoryError is thrown by specifying \-XX:+HeapDumpOnOutOfMemoryError VM option; 
 .TP 2
 o
-Use
+Use 
 .na
 \f2hprof\fP @
 .fi
-http://java.sun.com/developer/technicalArticles/Programming/HPROF.html.
+http://java.sun.com/developer/technicalArticles/Programming/HPROF.html. 
 .RE
 
 .LP
@@ -88,35 +88,35 @@
 .LP
 .RS 3
 .TP 3
-\-stack false/true
-Turn off tracking object allocation call stack. Note that if allocation site information is not available in the heap dump, you have to set this flag to false. Default is true.
+\-stack false/true 
+Turn off tracking object allocation call stack. Note that if allocation site information is not available in the heap dump, you have to set this flag to false. Default is true. 
 .TP 3
-\-refs false/true
-Turn off tracking of references to objects. Default is true. By default, back pointers (objects pointing to a given object a.k.a referrers or in\-coming references) are calculated for all objects in the heap.
+\-refs false/true 
+Turn off tracking of references to objects. Default is true. By default, back pointers (objects pointing to a given object a.k.a referrers or in\-coming references) are calculated for all objects in the heap. 
 .TP 3
-\-port port\-number
-Set the port for the jhat's HTTP server. Default is 7000.
+\-port port\-number 
+Set the port for the jhat's HTTP server. Default is 7000. 
 .TP 3
-\-exclude exclude\-file
-Specify a file that lists data members that should be excluded from the "reachable objects" query. For example, if the file lists \f2java.lang.String.value\fP, then, whenever list of objects reachable from a specific object "o" are calculated, reference paths involving \f2java.lang.String.value\fP field will not considered.
+\-exclude exclude\-file 
+Specify a file that lists data members that should be excluded from the "reachable objects" query. For example, if the file lists \f2java.lang.String.value\fP, then, whenever list of objects reachable from a specific object "o" are calculated, reference paths involving \f2java.lang.String.value\fP field will not considered. 
 .TP 3
-\-baseline baseline\-dump\-file
-Specify a baseline heap dump. Objects in both heap dumps with the same object ID will be marked as not being "new". Other objects will be marked as "new". This is useful while comparing two different heap dumps.
+\-baseline baseline\-dump\-file 
+Specify a baseline heap dump. Objects in both heap dumps with the same object ID will be marked as not being "new". Other objects will be marked as "new". This is useful while comparing two different heap dumps. 
 .TP 3
-\-debug int
-Set debug level for this tool. 0 means no debug output. Set higher values for more verbose modes.
+\-debug int 
+Set debug level for this tool. 0 means no debug output. Set higher values for more verbose modes. 
 .TP 3
-\-version
-Report version number and exit.
+\-version 
+Report version number and exit. 
 .TP 3
-\-h
-Output help message and exit.
+\-h 
+Output help message and exit. 
 .TP 3
-\-help
-Output help message and exit.
+\-help 
+Output help message and exit. 
 .TP 3
-\-J<flag>
-Pass <flag> to the Java virtual machine on which jhat is run. For example, \-J\-Xmx512m to use a maximum heap size of 512MB.
+\-J<flag> 
+Pass <flag> to the Java virtual machine on which jhat is run. For example, \-J\-Xmx512m to use a maximum heap size of 512MB. 
 .RE
 
 .LP
@@ -125,17 +125,17 @@
 .RS 3
 .TP 2
 o
-jmap(1)
+jmap(1) 
 .TP 2
 o
-jconsole(1)
+jconsole(1) 
 .TP 2
 o
 .na
 \f2hprof \- Heap and CPU profiling tool\fP @
 .fi
-http://java.sun.com/developer/technicalArticles/Programming/HPROF.html
+http://java.sun.com/developer/technicalArticles/Programming/HPROF.html 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jinfo.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jinfo.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jinfo 1 "10 May 2011"
+.TH jinfo 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -34,7 +34,7 @@
 .fl
 \f3jinfo\fP [ option ] executable core
 .fl
-\f3jinfo\fP [ option ] [server\-id@]remote\-hostname\-or\-IP
+\f3jinfo\fP [ option ] [server\-id@]remote\-hostname\-or\-IP 
 .fl
 .fi
 
@@ -43,43 +43,43 @@
 .LP
 .RS 3
 .TP 3
-option
-Options are mutually exclusive. Option, if used, should follow immediately after the command name.
+option 
+Options are mutually exclusive. Option, if used, should follow immediately after the command name. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-pid
-process id for which the configuration info is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used.
+pid 
+process id for which the configuration info is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-executable
-Java executable from which the core dump was produced.
+executable 
+Java executable from which the core dump was produced. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-core
-core file for which the configuration info is to be printed.
+core 
+core file for which the configuration info is to be printed. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-remote\-hostname\-or\-IP
-remote debug server's (see jsadebugd(1)) hostname or IP address.
+remote\-hostname\-or\-IP 
+remote debug server's (see jsadebugd(1)) hostname or IP address. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-server\-id
-optional unique id, if multiple debug servers are running on the same remote host.
+server\-id 
+optional unique id, if multiple debug servers are running on the same remote host. 
 .RE
 
 .LP
@@ -100,35 +100,35 @@
 .LP
 .RS 3
 .TP 3
-<no option>
+<no option> 
 prints both command line flags as well as System properties name, value pairs.
 .br
 .TP 3
-\-flag name
+\-flag name 
 prints the name and value of the given command line flag.
 .br
 .TP 3
-\-flag [+|\-]name
+\-flag [+|\-]name 
 enables or disables the given boolean command line flag.
 .br
 .TP 3
-\-flag name=value
+\-flag name=value 
 sets the given command line flag to the specified value.
 .br
 .TP 3
-\-flags
+\-flags 
 prints command line flags passed to the JVM. pairs.
 .br
 .TP 3
-\-sysprops
+\-sysprops 
 prints Java System properties as name, value pairs.
 .br
 .TP 3
-\-h
-prints a help message
+\-h 
+prints a help message 
 .TP 3
-\-help
-prints a help message
+\-help 
+prints a help message 
 .RE
 
 .LP
@@ -137,11 +137,11 @@
 .RS 3
 .TP 2
 o
-jps(1)
+jps(1) 
 .TP 2
 o
-jsadebugd(1)
+jsadebugd(1) 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jmap.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jmap.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jmap 1 "10 May 2011"
+.TH jmap 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -43,26 +43,26 @@
 .LP
 .RS 3
 .TP 3
-option
-Options are mutually exclusive. Option, if used, should follow immediately after the command name.
+option 
+Options are mutually exclusive. Option, if used, should follow immediately after the command name. 
 .TP 3
-pid
-process id for which the memory map is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used.
+pid 
+process id for which the memory map is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used. 
 .br
 .TP 3
-executable
-Java executable from which the core dump was produced.
+executable 
+Java executable from which the core dump was produced. 
 .br
 .TP 3
-core
-core file for which the memory map is to be printed.
+core 
+core file for which the memory map is to be printed. 
 .br
 .TP 3
-remote\-hostname\-or\-IP
-remote debug server's (see jsadebugd(1)) hostname or IP address.
+remote\-hostname\-or\-IP 
+remote debug server's (see jsadebugd(1)) hostname or IP address. 
 .br
 .TP 3
-server\-id
+server\-id 
 optional unique id, if multiple debug servers are running on the same remote host.
 .br
 .RE
@@ -95,46 +95,46 @@
 .LP
 .RS 3
 .TP 3
-<no option>
-When no option is used jmap prints shared object mappings. For each shared object loaded in the target VM, start address, the size of the mapping, and the full path of the shared object file are printed. This is similar to the Solaris \f3pmap\fP utility.
+<no option> 
+When no option is used jmap prints shared object mappings. For each shared object loaded in the target VM, start address, the size of the mapping, and the full path of the shared object file are printed. This is similar to the Solaris \f3pmap\fP utility. 
 .br
 .TP 3
-\-dump:[live,]format=b,file=<filename>
-Dumps the Java heap in hprof binary format to filename. The \f2live\fP suboption is optional. If specified, only the live objects in the heap are dumped. To browse the heap dump, you can use jhat(1) (Java Heap Analysis Tool) to read the generated file.
+\-dump:[live,]format=b,file=<filename> 
+Dumps the Java heap in hprof binary format to filename. The \f2live\fP suboption is optional. If specified, only the live objects in the heap are dumped. To browse the heap dump, you can use jhat(1) (Java Heap Analysis Tool) to read the generated file. 
 .br
 .TP 3
-\-finalizerinfo
-Prints information on objects awaiting finalization.
+\-finalizerinfo 
+Prints information on objects awaiting finalization. 
 .br
 .TP 3
-\-heap
-Prints a heap summary. GC algorithm used, heap configuration and generation wise heap usage are printed.
+\-heap 
+Prints a heap summary. GC algorithm used, heap configuration and generation wise heap usage are printed. 
 .br
 .TP 3
-\-histo[:live]
-Prints a histogram of the heap. For each Java class, number of objects, memory size in bytes, and fully qualified class names are printed. VM internal class names are printed with '*' prefix. If the \f2live\fP suboption is specified, only live objects are counted.
+\-histo[:live] 
+Prints a histogram of the heap. For each Java class, number of objects, memory size in bytes, and fully qualified class names are printed. VM internal class names are printed with '*' prefix. If the \f2live\fP suboption is specified, only live objects are counted. 
 .br
 .TP 3
-\-permstat
-Prints class loader wise statistics of permanent generation of Java heap. For each class loader, its name, liveness, address, parent class loader, and the number and size of classes it has loaded are printed. In addition, the number and size of interned Strings are printed.
+\-permstat 
+Prints class loader wise statistics of permanent generation of Java heap. For each class loader, its name, liveness, address, parent class loader, and the number and size of classes it has loaded are printed. In addition, the number and size of interned Strings are printed. 
 .br
 .TP 3
-\-F
-Force. Use with jmap \-dump or jmap \-histo option if the pid does not respond. The \f2live\fP suboption is not supported in this mode.
+\-F 
+Force. Use with jmap \-dump or jmap \-histo option if the pid does not respond. The \f2live\fP suboption is not supported in this mode. 
 .br
 .TP 3
-\-h
+\-h 
 Prints a help message.
 .br
 .br
 .TP 3
-\-help
+\-help 
 Prints a help message.
 .br
 .br
 .TP 3
-\-J<flag>
-Passes <flag> to the Java virtual machine on which jmap is run.
+\-J<flag> 
+Passes <flag> to the Java virtual machine on which jmap is run. 
 .br
 .RE
 
@@ -144,17 +144,17 @@
 .RS 3
 .TP 2
 o
-pmap(1)
+pmap(1) 
 .TP 2
 o
-jhat(1)
+jhat(1) 
 .TP 2
 o
-jps(1)
+jps(1) 
 .TP 2
 o
-jsadebugd(1)
+jsadebugd(1) 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jps.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jps.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jps 1 "10 May 2011"
+.TH jps 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -41,11 +41,11 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options.
+options 
+Command\-line options. 
 .TP 3
-hostid
-The host identifier of the host for which the process report should be generated. The \f2hostid\fP may include optional components that indicate the communications protocol, port number, and other implementation specific data.
+hostid 
+The host identifier of the host for which the process report should be generated. The \f2hostid\fP may include optional components that indicate the communications protocol, port number, and other implementation specific data. 
 .RE
 
 .LP
@@ -76,27 +76,27 @@
 .LP
 .RS 3
 .TP 3
-\-q
-Suppress the output of the class name, JAR file name, and arguments passed to the \f2main\fP method, producing only a list of local VM identifiers.
+\-q 
+Suppress the output of the class name, JAR file name, and arguments passed to the \f2main\fP method, producing only a list of local VM identifiers. 
 .TP 3
-\-m
-Output the arguments passed to the main method. The output may be null for embedded JVMs.
+\-m 
+Output the arguments passed to the main method. The output may be null for embedded JVMs.  
 .TP 3
-\-l
-Output the full package name for the application's main class or the full path name to the application's JAR file.
+\-l 
+Output the full package name for the application's main class or the full path name to the application's JAR file. 
 .TP 3
-\-v
-Output the arguments passed to the JVM.
+\-v 
+Output the arguments passed to the JVM. 
 .TP 3
-\-V
-Output the arguments passed to the JVM through the flags file (the .hotspotrc file or the file specified by the \-XX:Flags=<\f2filename\fP> argument).
+\-V 
+Output the arguments passed to the JVM through the flags file (the .hotspotrc file or the file specified by the \-XX:Flags=<\f2filename\fP> argument). 
 .TP 3
-\-Joption
-Pass \f2option\fP to the \f3java\fP launcher called by \f3jps\fP. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying VM executing applications written in Java.
+\-Joption 
+Pass \f2option\fP to the \f3java\fP launcher called by \f3jps\fP. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying VM executing applications written in Java. 
 .RE
 
 .LP
-.SS
+.SS 
 HOST IDENTIFIER
 .LP
 .LP
@@ -115,17 +115,17 @@
 .LP
 .RS 3
 .TP 3
-protocol
-The communications protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is not specified, the default protocol is a platform specific, optimized, local protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is specified, then the default protocol is \f3rmi\fP.
+protocol 
+The communications protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is not specified, the default protocol is a platform specific, optimized, local protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is specified, then the default protocol is \f3rmi\fP. 
 .TP 3
-hostname
-A hostname or IP address indicating the target host. If \f2hostname\fP is omitted, then the target host is the local host.
+hostname 
+A hostname or IP address indicating the target host. If \f2hostname\fP is omitted, then the target host is the local host. 
 .TP 3
-port
-The default port for communicating with the remote server. If the \f2hostname\fP is omitted or the \f2protocol\fP specifies an optimized, local protocol, then \f2port\fP is ignored. Otherwise, treatment of the \f2port\fP parameter is implementation specific. For the default \f3rmi\fP protocol the \f2port\fP indicates the port number for the rmiregistry on the remote host. If \f2port\fP is omitted, and \f2protocol\fP indicates \f3rmi\fP, then the default rmiregistry port (1099) is used.
+port 
+The default port for communicating with the remote server. If the \f2hostname\fP is omitted or the \f2protocol\fP specifies an optimized, local protocol, then \f2port\fP is ignored. Otherwise, treatment of the \f2port\fP parameter is implementation specific. For the default \f3rmi\fP protocol the \f2port\fP indicates the port number for the rmiregistry on the remote host. If \f2port\fP is omitted, and \f2protocol\fP indicates \f3rmi\fP, then the default rmiregistry port (1099) is used. 
 .TP 3
-servername
-The treatment of this parameter depends on the implementation. For the optimized, local protocol, this field is ignored. For the \f3rmi\fP protocol, this parameter is a string representing the name of the RMI remote object on the remote host. See the \f3\-n\fP option for the jstatd(1) command.
+servername 
+The treatment of this parameter depends on the implementation. For the optimized, local protocol, this field is ignored. For the \f3rmi\fP protocol, this parameter is a string representing the name of the RMI remote object on the remote host. See the \f3\-n\fP option for the jstatd(1) command. 
 .RE
 
 .LP
@@ -234,17 +234,17 @@
 .RS 3
 .TP 2
 o
-java(1) \- the Java Application Launcher
+java(1) \- the Java Application Launcher 
 .TP 2
 o
-jstat(1) \- the Java virtual machine Statistics Monitoring Tool
+jstat(1) \- the Java virtual machine Statistics Monitoring Tool 
 .TP 2
 o
-jstatd(1) \- the jstat daemon
+jstatd(1) \- the jstat daemon 
 .TP 2
 o
-rmiregistry(1) \- the Java Remote Object Registry
+rmiregistry(1) \- the Java Remote Object Registry 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jrunscript.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jrunscript.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jrunscript 1 "10 May 2011"
+.TH jrunscript 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -39,11 +39,11 @@
 .LP
 .RS 3
 .TP 3
-options
-Options, if used, should follow immediately after the command name.
+options 
+Options, if used, should follow immediately after the command name. 
 .TP 3
-arguments
-Arguments, if used, should follow immediately after options or command name.
+arguments 
+Arguments, if used, should follow immediately after options or command name. 
 .RE
 
 .LP
@@ -59,41 +59,41 @@
 .LP
 .RS 3
 .TP 3
-\-classpath path
-Specify where to find the user's .class files that are accessed by the script.
+\-classpath path 
+Specify where to find the user's .class files that are accessed by the script. 
 .TP 3
-\-cp path
-This is a synonym for \-classpath \f2path\fP
+\-cp path 
+This is a synonym for \-classpath \f2path\fP 
 .TP 3
-\-Dname=value
-Set a Java system property.
+\-Dname=value 
+Set a Java system property. 
 .TP 3
-\-J<flag>
-Pass <flag> directly to the Java virtual machine on which jrunscript is run.
+\-J<flag> 
+Pass <flag> directly to the Java virtual machine on which jrunscript is run. 
 .TP 3
-\-l language
-Use the specified scripting language. By default, JavaScript is used. Note that to use other scripting languages, you also need to specify the corresponding script engine's jar file using \-cp or \-classpath option.
+\-l language 
+Use the specified scripting language. By default, JavaScript is used. Note that to use other scripting languages, you also need to specify the corresponding script engine's jar file using \-cp or \-classpath option. 
 .TP 3
-\-e script
-Evaluate the given script. This option can be used to run "one liner" scripts specified completely on the command line.
+\-e script 
+Evaluate the given script. This option can be used to run "one liner" scripts specified completely on the command line. 
 .TP 3
-\-encoding encoding
-Specify the character encoding used while reading script files.
+\-encoding encoding 
+Specify the character encoding used while reading script files. 
 .TP 3
-\-f script\-file
-Evaluate the given script file (batch mode).
+\-f script\-file 
+Evaluate the given script file (batch mode). 
 .TP 3
-\-f \-
-Read and evaluate a script from standard input (interactive mode).
+\-f \- 
+Read and evaluate a script from standard input (interactive mode). 
 .TP 3
-\-help\
-Output help message and exit.
+\-help\  
+Output help message and exit. 
 .TP 3
-\-?\
-Output help message and exit.
+\-?\  
+Output help message and exit. 
 .TP 3
-\-q\
-List all script engines available and exit.
+\-q\  
+List all script engines available and exit. 
 .RE
 
 .LP
@@ -104,7 +104,7 @@
 .LP
 .SH "EXAMPLES"
 .LP
-.SS
+.SS 
 Executing inline scripts
 .LP
 .nf
@@ -118,7 +118,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Use specified language and evaluate given script file
 .LP
 .nf
@@ -130,7 +130,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Interactive mode
 .LP
 .nf
@@ -162,7 +162,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Run script file with script arguments
 .LP
 .nf
@@ -174,14 +174,14 @@
 .fi
 
 .LP
-test.js is script file to execute and arg1, arg2 and arg3 are passed to script as script arguments. Script can access these using "arguments" array.
+test.js is script file to execute and arg1, arg2 and arg3 are passed to script as script arguments. Script can access these using "arguments" array.  
 .SH "SEE ALSO"
 .LP
 .LP
-If JavaScript is used, then before evaluating any user defined script, jrunscript initializes certain built\-in functions and objects. These JavaScript built\-ins are documented in
+If JavaScript is used, then before evaluating any user defined script, jrunscript initializes certain built\-in functions and objects. These JavaScript built\-ins are documented in 
 .na
 \f2jsdocs\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/share/jsdocs/allclasses\-noframe.html.
+http://docs.oracle.com/javase/7/docs/technotes/tools/share/jsdocs/allclasses\-noframe.html.
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jsadebugd.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jsadebugd.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jsadebugd 1 "10 May 2011"
+.TH jsadebugd 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -41,28 +41,28 @@
 .LP
 .RS 3
 .TP 3
-pid
-process id of the process to which the debug server should attach. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used. At most one instance of the debug server may be attached to a single process.
+pid 
+process id of the process to which the debug server should attach. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used. At most one instance of the debug server may be attached to a single process. 
 .TP 3
-executable
-Java executable from which the core dump was produced
+executable 
+Java executable from which the core dump was produced 
 .TP 3
-core
-Core file to which the debug server should attach.
+core 
+Core file to which the debug server should attach. 
 .TP 3
-server\-id
-Optional unique id, needed if multiple debug servers are started on the same machine. This ID must be used by remote clients to identify the particular debug server to attach. Within a single machine, this ID must be unique.
+server\-id 
+Optional unique id, needed if multiple debug servers are started on the same machine. This ID must be used by remote clients to identify the particular debug server to attach. Within a single machine, this ID must be unique. 
 .RE
 
 .LP
 .SH "DESCRIPTION"
 .LP
 .LP
-\f3jsadebugd\fP attaches to a Java process or core file and acts as a debug server. Remote clients such as jstack(1), jmap(1), and jinfo(1) can attach to the server using Java Remote Method Invocation (RMI). Before starting \f2jsadebugd\fP,
+\f3jsadebugd\fP attaches to a Java process or core file and acts as a debug server. Remote clients such as jstack(1), jmap(1), and jinfo(1) can attach to the server using Java Remote Method Invocation (RMI). Before starting \f2jsadebugd\fP, 
 .na
 \f2rmiregistry\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#rmi must be started with:
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#rmi must be started with:
 .LP
 .nf
 \f3
@@ -87,23 +87,23 @@
 .RS 3
 .TP 2
 o
-jinfo(1)
+jinfo(1) 
 .TP 2
 o
-jmap(1)
+jmap(1) 
 .TP 2
 o
-jps(1)
+jps(1) 
 .TP 2
 o
-jstack(1)
+jstack(1) 
 .TP 2
 o
 .na
 \f2rmiregistry\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#rmi
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#rmi 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jstack.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jstack.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jstack 1 "10 May 2011"
+.TH jstack 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -48,27 +48,27 @@
 .LP
 .RS 3
 .TP 3
-pid
-process id for which the stack trace is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used.
+pid 
+process id for which the stack trace is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, jps(1) may be used. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-executable
-Java executable from which the core dump was produced.
+executable 
+Java executable from which the core dump was produced. 
 .br
 .TP 3
-core
-core file for which the stack trace is to be printed.
+core 
+core file for which the stack trace is to be printed. 
 .br
 .TP 3
-remote\-hostname\-or\-IP
-remote debug server's (see jsadebugd(1)) hostname or IP address.
+remote\-hostname\-or\-IP 
+remote debug server's (see jsadebugd(1)) hostname or IP address. 
 .br
 .TP 3
-server\-id
-optional unique id, if multiple debug servers are running on the same remote host.
+server\-id 
+optional unique id, if multiple debug servers are running on the same remote host. 
 .RE
 
 .LP
@@ -98,25 +98,25 @@
 .LP
 .RS 3
 .TP 3
-\-F
-Force a stack dump when 'jstack [\-l] pid' does not respond.
+\-F 
+Force a stack dump when 'jstack [\-l] pid' does not respond. 
 .TP 3
-\-l
-Long listing. Prints additional information about locks such as list of owned java.util.concurrent
+\-l 
+Long listing. Prints additional information about locks such as list of owned java.util.concurrent 
 .na
 \f2ownable synchronizers\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html.
+http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html. 
 .TP 3
-\-m
-prints mixed mode (both Java and native C/C++ frames) stack trace.
+\-m 
+prints mixed mode (both Java and native C/C++ frames) stack trace. 
 .TP 3
-\-h
+\-h 
 prints a help message.
 .br
 .br
 .TP 3
-\-help
+\-help 
 prints a help message
 .br
 .RE
@@ -127,16 +127,16 @@
 .RS 3
 .TP 2
 o
-pstack(1)
+pstack(1) 
 .TP 2
 o
-c++filt(1)
+c++filt(1) 
 .TP 2
 o
-jps(1)
+jps(1) 
 .TP 2
 o
-jsadebugd(1)
+jsadebugd(1) 
 .RE
 
 .LP
@@ -145,4 +145,4 @@
 .LP
 Mixed mode stack trace, the \-m option, does not work with the remote debug server.
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jstat.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jstat.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jstat 1 "10 May 2011"
+.TH jstat 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -39,27 +39,27 @@
 .LP
 .RS 3
 .TP 3
-generalOption
-A single general command\-line option (\-help, \-options, or \-version)
+generalOption 
+A single general command\-line option (\-help, \-options, or \-version) 
 .TP 3
-outputOptions
-One or more output options, consisting of a single \f2statOption\fP, plus any of the \-t, \-h, and \-J options.
+outputOptions 
+One or more output options, consisting of a single \f2statOption\fP, plus any of the \-t, \-h, and \-J options. 
 .TP 3
-vmid
-Virtual machine identifier, a string indicating the target Java virtual machine (JVM). The general syntax is
+vmid 
+Virtual machine identifier, a string indicating the target Java virtual machine (JVM). The general syntax is 
 .nf
 \f3
 .fl
 [\fP\f4protocol\fP\f3:][//]\fP\f4lvmid\fP[@\f2hostname\fP[:\f2port\fP]/\f2servername\fP]
 .fl
 .fi
-The syntax of the vmid string largely corresponds to the syntax of a URI. The \f2vmid\fP can vary from a simple integer representing a local JVM to a more complex construction specifying a communications protocol, port number, and other implementation\-specific values. See Virtual Machine Identifier for details.
+The syntax of the vmid string largely corresponds to the syntax of a URI. The \f2vmid\fP can vary from a simple integer representing a local JVM to a more complex construction specifying a communications protocol, port number, and other implementation\-specific values. See Virtual Machine Identifier for details. 
 .TP 3
-interval[s|ms]
-Sampling interval in the specified units, seconds (s) or milliseconds (ms). Default units are milliseconds. Must be a positive integer. If specified, \f3jstat\fP will produce its output at each interval.
+interval[s|ms] 
+Sampling interval in the specified units, seconds (s) or milliseconds (ms). Default units are milliseconds. Must be a positive integer. If specified, \f3jstat\fP will produce its output at each interval. 
 .TP 3
-count
-Number of samples to display. Default value is infinity; that is, \f3jstat\fP displays statistics until the target JVM terminates or the \f3jstat\fP command is terminated. Must be a positive integer.
+count 
+Number of samples to display. Default value is infinity; that is, \f3jstat\fP displays statistics until the target JVM terminates or the \f3jstat\fP command is terminated. Must be a positive integer. 
 .RE
 
 .LP
@@ -73,7 +73,7 @@
 .br
 
 .LP
-.SS
+.SS 
 VIRTUAL MACHINE IDENTIFIER
 .LP
 .LP
@@ -89,20 +89,20 @@
 .LP
 .RS 3
 .TP 3
-protocol
-The communications protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is not specified, the default protocol is a platform specific optimized local protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is specified, then the default protocol is \f3rmi\fP.
+protocol 
+The communications protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is not specified, the default protocol is a platform specific optimized local protocol. If the \f2protocol\fP is omitted and a \f2hostname\fP is specified, then the default protocol is \f3rmi\fP. 
 .TP 3
-lvmid
-The local virtual machine identifier for the target JVM. The \f2lvmid\fP is a platform\-specific value that uniquely identifies a JVM on a system. The \f2lvmid\fP is the only required component of a virtual machine identifier. The \f2lvmid\fP is typically, but not necessarily, the operating system's process identifier for the target JVM process. You can use the jps(1) command to determine the \f2lvmid\fP. Also, you can determine \f2lvmid\fP on Unix platforms with the \f3ps\fP command, and on Windows with the Windows Task Manager.
+lvmid 
+The local virtual machine identifier for the target JVM. The \f2lvmid\fP is a platform\-specific value that uniquely identifies a JVM on a system. The \f2lvmid\fP is the only required component of a virtual machine identifier. The \f2lvmid\fP is typically, but not necessarily, the operating system's process identifier for the target JVM process. You can use the jps(1) command to determine the \f2lvmid\fP. Also, you can determine \f2lvmid\fP on Unix platforms with the \f3ps\fP command, and on Windows with the Windows Task Manager. 
 .TP 3
-hostname
-A hostname or IP address indicating the target host. If \f2hostname\fP is omitted, then the target host is the local host.
+hostname 
+A hostname or IP address indicating the target host. If \f2hostname\fP is omitted, then the target host is the local host. 
 .TP 3
-port
-The default port for communicating with the remote server. If the \f2hostname\fP is omitted or the \f2protocol\fP specifies an optimized, local protocol, then \f2port\fP is ignored. Otherwise, treatment of the \f2port\fP parameter is implementation specific. For the default \f3rmi\fP protocol, the \f2port\fP indicates the port number for the rmiregistry on the remote host. If \f2port\fP is omitted, and \f2protocol\fP indicates \f3rmi\fP, then the default rmiregistry port (1099) is used.
+port 
+The default port for communicating with the remote server. If the \f2hostname\fP is omitted or the \f2protocol\fP specifies an optimized, local protocol, then \f2port\fP is ignored. Otherwise, treatment of the \f2port\fP parameter is implementation specific. For the default \f3rmi\fP protocol, the \f2port\fP indicates the port number for the rmiregistry on the remote host. If \f2port\fP is omitted, and \f2protocol\fP indicates \f3rmi\fP, then the default rmiregistry port (1099) is used. 
 .TP 3
-servername
-The treatment of this parameter depends on implementation. For the optimized local protocol, this field is ignored. For the \f3rmi\fP protocol, it represents the name of the RMI remote object on the remote host.
+servername 
+The treatment of this parameter depends on implementation. For the optimized local protocol, this field is ignored. For the \f3rmi\fP protocol, it represents the name of the RMI remote object on the remote host. 
 .RE
 
 .LP
@@ -116,7 +116,7 @@
 .LP
 \f3NOTE\fP: All options, and their functionality are subject to change or removal in future releases.
 .LP
-.SS
+.SS 
 GENERAL OPTIONS
 .LP
 .LP
@@ -124,18 +124,18 @@
 .LP
 .RS 3
 .TP 3
-\-help
-Display help message.
+\-help 
+Display help message. 
 .TP 3
-\-version
-Display version information.
+\-version 
+Display version information. 
 .TP 3
-\-options
-Display list of statistics options. See the Output Options section below.
+\-options 
+Display list of statistics options. See the Output Options section below. 
 .RE
 
 .LP
-.SS
+.SS 
 OUTPUT OPTIONS
 .LP
 .LP
@@ -155,11 +155,12 @@
 .LP
 .RS 3
 .TP 3
-\-statOption
+\-statOption 
 Determines the statistics information that \f3jstat\fP displays. The following table lists the available options. Use the \f3\-options\fP general option to display the list of options for a particular platform installation.
 .br
 .br
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -455,13 +456,13 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Option\fP\h'|\n(41u'\f3Displays...\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'class\h'|\n(41u'
@@ -477,7 +478,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'compiler\h'|\n(41u'
@@ -493,7 +494,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gc\h'|\n(41u'
@@ -509,7 +510,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gccapacity\h'|\n(41u'
@@ -525,7 +526,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gccause\h'|\n(41u'
@@ -541,7 +542,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gcnew\h'|\n(41u'
@@ -557,7 +558,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gcnewcapacity\h'|\n(41u'
@@ -573,7 +574,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gcold\h'|\n(41u'
@@ -589,7 +590,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gcoldcapacity\h'|\n(41u'
@@ -605,7 +606,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gcpermcapacity\h'|\n(41u'
@@ -621,7 +622,7 @@
 .sp |\n(31u
 .ne \n(k|u+\n(.Vu
 .if (\n(k|+\n(#^-1v)>\n(#- .nr #- +(\n(k|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'gcutil\h'|\n(41u'
@@ -637,7 +638,7 @@
 .sp |\n(31u
 .ne \n(l|u+\n(.Vu
 .if (\n(l|+\n(#^-1v)>\n(#- .nr #- +(\n(l|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'printcompilation\h'|\n(41u'
@@ -667,20 +668,21 @@
 .rm j+
 .rm k+
 .rm l+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-52
 .TP 3
-\-h n
-Display a column header every \f2n\fP samples (output rows), where \f2n\fP is a positive integer. Default value is 0, which displays the column header above the first row of data.
+\-h n 
+Display a column header every \f2n\fP samples (output rows), where \f2n\fP is a positive integer. Default value is 0, which displays the column header above the first row of data. 
 .TP 3
-\-t n
-Display a timestamp column as the first column of output. The timestamp is the time since the start time of the target JVM.
+\-t n 
+Display a timestamp column as the first column of output. The timestamp is the time since the start time of the target JVM. 
 .TP 3
-\-JjavaOption
-Pass \f2javaOption\fP to the \f3java\fP application launcher. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. For a complete list of options, see java(1)
+\-JjavaOption 
+Pass \f2javaOption\fP to the \f3java\fP application launcher. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. For a complete list of options, see java(1) 
 .RE
 
 .LP
-.SS
+.SS 
 STATOPTIONS AND OUTPUT
 .LP
 .LP
@@ -688,10 +690,11 @@
 .br
 
 .LP
-.SS
+.SS 
 \-class Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -817,25 +820,25 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Class Loader Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Loaded\h'|\n(41u'Number of classes loaded.
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Bytes\h'|\n(41u'Number of Kbytes loaded.
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Unloaded\h'|\n(41u'
@@ -851,7 +854,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Bytes\h'|\n(41u'
@@ -867,7 +870,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Time\h'|\n(41u'
@@ -888,13 +891,15 @@
 .rm a+
 .rm b+
 .rm c+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-21
 
 .LP
-.SS
+.SS 
 \-compiler Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -1072,17 +1077,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'HotSpot Just\-In\-Time Compiler Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Compiled\h'|\n(41u'
@@ -1098,7 +1103,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Failed\h'|\n(41u'
@@ -1114,7 +1119,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Invalid\h'|\n(41u'
@@ -1130,7 +1135,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Time\h'|\n(41u'
@@ -1146,7 +1151,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FailedType\h'|\n(41u'
@@ -1162,7 +1167,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FailedMethod\h'|\n(41u'
@@ -1186,13 +1191,15 @@
 .rm d+
 .rm e+
 .rm f+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-29
 
 .LP
-.SS
+.SS 
 \-gc Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -1534,17 +1541,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Garbage\-collected heap statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0C\h'|\n(41u'
@@ -1560,7 +1567,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1C\h'|\n(41u'
@@ -1576,7 +1583,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0U\h'|\n(41u'
@@ -1592,7 +1599,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1U\h'|\n(41u'
@@ -1608,7 +1615,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EC\h'|\n(41u'
@@ -1624,7 +1631,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EU\h'|\n(41u'
@@ -1640,7 +1647,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OC\h'|\n(41u'
@@ -1656,7 +1663,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OU\h'|\n(41u'
@@ -1672,7 +1679,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PC\h'|\n(41u'
@@ -1688,7 +1695,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PU\h'|\n(41u'
@@ -1704,7 +1711,7 @@
 .sp |\n(31u
 .ne \n(k|u+\n(.Vu
 .if (\n(k|+\n(#^-1v)>\n(#- .nr #- +(\n(k|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -1720,7 +1727,7 @@
 .sp |\n(31u
 .ne \n(l|u+\n(.Vu
 .if (\n(l|+\n(#^-1v)>\n(#- .nr #- +(\n(l|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGCT\h'|\n(41u'
@@ -1734,13 +1741,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of full GC events.
 .ne \n(m|u+\n(.Vu
 .if (\n(m|+\n(#^-1v)>\n(#- .nr #- +(\n(m|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGCT\h'|\n(41u'
@@ -1756,7 +1763,7 @@
 .sp |\n(31u
 .ne \n(n|u+\n(.Vu
 .if (\n(n|+\n(#^-1v)>\n(#- .nr #- +(\n(n|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'GCT\h'|\n(41u'
@@ -1788,13 +1795,15 @@
 .rm l+
 .rm m+
 .rm n+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-63
 
 .LP
-.SS
+.SS 
 \-gccapacity Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -2156,17 +2165,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Memory Pool Generation and Space Capacities\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'NGCMN\h'|\n(41u'
@@ -2182,7 +2191,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'NGCMX\h'|\n(41u'
@@ -2198,7 +2207,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'NGC\h'|\n(41u'
@@ -2214,7 +2223,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0C\h'|\n(41u'
@@ -2230,7 +2239,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1C\h'|\n(41u'
@@ -2246,7 +2255,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EC\h'|\n(41u'
@@ -2262,7 +2271,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OGCMN\h'|\n(41u'
@@ -2278,7 +2287,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OGCMX\h'|\n(41u'
@@ -2294,7 +2303,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OGC\h'|\n(41u'
@@ -2310,7 +2319,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OC\h'|\n(41u'
@@ -2326,7 +2335,7 @@
 .sp |\n(31u
 .ne \n(k|u+\n(.Vu
 .if (\n(k|+\n(#^-1v)>\n(#- .nr #- +(\n(k|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PGCMN\h'|\n(41u'
@@ -2342,7 +2351,7 @@
 .sp |\n(31u
 .ne \n(l|u+\n(.Vu
 .if (\n(l|+\n(#^-1v)>\n(#- .nr #- +(\n(l|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PGCMX\h'|\n(41u'
@@ -2358,7 +2367,7 @@
 .sp |\n(31u
 .ne \n(m|u+\n(.Vu
 .if (\n(m|+\n(#^-1v)>\n(#- .nr #- +(\n(m|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PGC\h'|\n(41u'
@@ -2374,7 +2383,7 @@
 .sp |\n(31u
 .ne \n(n|u+\n(.Vu
 .if (\n(n|+\n(#^-1v)>\n(#- .nr #- +(\n(n|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PC\h'|\n(41u'
@@ -2390,7 +2399,7 @@
 .sp |\n(31u
 .ne \n(o|u+\n(.Vu
 .if (\n(o|+\n(#^-1v)>\n(#- .nr #- +(\n(o|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -2404,7 +2413,7 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of Full GC Events.
@@ -2427,16 +2436,18 @@
 .rm m+
 .rm n+
 .rm o+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-67
 
 .LP
-.SS
+.SS 
 \-gccause Option
 .LP
 .LP
 This option displays the same summary of garbage collection statistics as the \f3\-gcutil\fP option, but includes the causes of the last garbage collection event and (if applicable) the current garbage collection event. In addition to the columns listed for \f3\-gcutil\fP, this option adds the following columns:
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -2534,17 +2545,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Garbage Collection Statistics, Including GC Events\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'LGCC\h'|\n(41u'
@@ -2560,7 +2571,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'GCC\h'|\n(41u'
@@ -2580,13 +2591,15 @@
 .35
 .rm a+
 .rm b+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-13
 
 .LP
-.SS
+.SS 
 \-gcnew Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -2848,17 +2861,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'New Generation Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0C\h'|\n(41u'
@@ -2874,7 +2887,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1C\h'|\n(41u'
@@ -2890,7 +2903,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0U\h'|\n(41u'
@@ -2906,7 +2919,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1U\h'|\n(41u'
@@ -2920,13 +2933,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'TT\h'|\n(41u'Tenuring threshold.
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'MTT\h'|\n(41u'
@@ -2942,7 +2955,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'DSS\h'|\n(41u'
@@ -2958,7 +2971,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EC\h'|\n(41u'
@@ -2974,7 +2987,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EU\h'|\n(41u'
@@ -2990,7 +3003,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -3006,7 +3019,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGCT\h'|\n(41u'
@@ -3034,13 +3047,15 @@
 .rm h+
 .rm i+
 .rm j+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-47
 
 .LP
-.SS
+.SS 
 \-gcnewcapacity Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -3302,17 +3317,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'New Generation Space Size Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'NGCMN\h'|\n(41u'
@@ -3328,7 +3343,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'NGCMX\h'|\n(41u'
@@ -3344,7 +3359,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'NGC\h'|\n(41u'
@@ -3360,7 +3375,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0CMX\h'|\n(41u'
@@ -3376,7 +3391,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0C\h'|\n(41u'
@@ -3392,7 +3407,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1CMX\h'|\n(41u'
@@ -3408,7 +3423,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1C\h'|\n(41u'
@@ -3424,7 +3439,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'ECMX\h'|\n(41u'
@@ -3440,7 +3455,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EC\h'|\n(41u'
@@ -3456,7 +3471,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -3470,7 +3485,7 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of Full GC Events.
@@ -3488,13 +3503,15 @@
 .rm h+
 .rm i+
 .rm j+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-47
 
 .LP
-.SS
+.SS 
 \-gcold Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -3696,17 +3713,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Old and Permanent Generation Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PC\h'|\n(41u'
@@ -3722,7 +3739,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PU\h'|\n(41u'
@@ -3738,7 +3755,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OC\h'|\n(41u'
@@ -3754,7 +3771,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OU\h'|\n(41u'
@@ -3770,7 +3787,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -3784,13 +3801,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of full GC events.
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGCT\h'|\n(41u'
@@ -3806,7 +3823,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'GCT\h'|\n(41u'
@@ -3831,13 +3848,15 @@
 .rm e+
 .rm f+
 .rm g+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-35
 
 .LP
-.SS
+.SS 
 \-gcoldcapacity Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -4039,17 +4058,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Old Generation Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OGCMN\h'|\n(41u'
@@ -4065,7 +4084,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OGCMX\h'|\n(41u'
@@ -4081,7 +4100,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OGC\h'|\n(41u'
@@ -4097,7 +4116,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'OC\h'|\n(41u'
@@ -4113,7 +4132,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -4127,13 +4146,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of full GC events.
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGCT\h'|\n(41u'
@@ -4149,7 +4168,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'GCT\h'|\n(41u'
@@ -4174,13 +4193,15 @@
 .rm e+
 .rm f+
 .rm g+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-35
 
 .LP
-.SS
+.SS 
 \-gcpermcapacity Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -4382,17 +4403,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Permanent Generation Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PGCMN\h'|\n(41u'
@@ -4408,7 +4429,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PGCMX\h'|\n(41u'
@@ -4424,7 +4445,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PGC\h'|\n(41u'
@@ -4440,7 +4461,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'PC\h'|\n(41u'
@@ -4456,7 +4477,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -4470,13 +4491,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of full GC events.
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGCT\h'|\n(41u'
@@ -4492,7 +4513,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'GCT\h'|\n(41u'
@@ -4517,13 +4538,15 @@
 .rm e+
 .rm f+
 .rm g+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-35
 
 .LP
-.SS
+.SS 
 \-gcutil Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -4765,17 +4788,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Summary of Garbage Collection Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S0\h'|\n(41u'
@@ -4791,7 +4814,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'S1\h'|\n(41u'
@@ -4807,7 +4830,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'E\h'|\n(41u'
@@ -4823,7 +4846,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'O\h'|\n(41u'
@@ -4839,7 +4862,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'P\h'|\n(41u'
@@ -4855,7 +4878,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGC\h'|\n(41u'
@@ -4871,7 +4894,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'YGCT\h'|\n(41u'
@@ -4885,13 +4908,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGC\h'|\n(41u'Number of full GC events.
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'FGCT\h'|\n(41u'
@@ -4907,7 +4930,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'GCT\h'|\n(41u'
@@ -4934,13 +4957,15 @@
 .rm g+
 .rm h+
 .rm i+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-43
 
 .LP
-.SS
+.SS 
 \-printcompilation Option
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -5062,17 +5087,17 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'HotSpot Compiler Method Statistics\h'|\n(41u'
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Column\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Compiled\h'|\n(41u'
@@ -5088,7 +5113,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Size\h'|\n(41u'
@@ -5102,13 +5127,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Type\h'|\n(41u'Compilation type.
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'Method\h'|\n(41u'
@@ -5129,6 +5154,7 @@
 .rm a+
 .rm b+
 .rm c+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-19
 
 .LP
@@ -5137,7 +5163,7 @@
 .LP
 This section presents some examples of monitoring a local JVM with a \f2lvmid\fP of 21891.
 .LP
-.SS
+.SS 
 Using the gcutil option
 .LP
 .LP
@@ -5188,7 +5214,7 @@
 .LP
 The output of this example shows that a young generation collection occurred between the 3rd and 4th sample. The collection took 0.001 seconds and promoted objects from the eden space (E) to the old space (O), resulting in an increase of old space utilization from 9.49% to 9.51%. Before the collection, the survivor space was 12.44% utilized, but after this collection it is only 7.74% utilized.
 .LP
-.SS
+.SS 
 Repeating the column header string
 .LP
 .LP
@@ -5250,7 +5276,7 @@
 .LP
 Another collection occurs between the 5th and 6th samples. This collection found very few survivors and returned the tenuring threshold to 31.
 .LP
-.SS
+.SS 
 Including a time stamp for each sample
 .LP
 .LP
@@ -5285,7 +5311,7 @@
 .LP
 The \f2Timestamp\fP column reports the elapsed time in seconds since the start of the target JVM. In addition, the \f3\-gcoldcapacity\fP output shows the old generation capacity (OGC) and the old space capacity (OC) increasing as the heap expands to meet allocation and/or promotion demands. The old generation capacity (OGC) has grown to from 11696 KB to 13820 KB after the 81st Full GC (FGC). The maximum capacity of the generation (and space) is 60544 KB (OGCMX), so it still has room to expand.
 .LP
-.SS
+.SS 
 Monitor instrumentation for a remote JVM
 .LP
 .LP
@@ -5313,17 +5339,17 @@
 .RS 3
 .TP 2
 o
-java(1) \- the Java Application Launcher
+java(1) \- the Java Application Launcher 
 .TP 2
 o
-jps(1) \- the Java Process Status Application
+jps(1) \- the Java Process Status Application 
 .TP 2
 o
-jstatd(1) \- the jvmstat daemon
+jstatd(1) \- the jvmstat daemon 
 .TP 2
 o
-rmiregistry(1) \- the Java Remote Object Registry
+rmiregistry(1) \- the Java Remote Object Registry 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/jstatd.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/jstatd.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH jstatd 1 "10 May 2011"
+.TH jstatd 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -42,8 +42,8 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options. The options may be in any order. If there are redundant or contradictory options, the last option specified will take precedence.
+options 
+Command\-line options. The options may be in any order. If there are redundant or contradictory options, the last option specified will take precedence. 
 .RE
 
 .LP
@@ -65,17 +65,17 @@
 .LP
 .RS 3
 .TP 3
-\-nr
-Do not attempt to create an internal RMI registry within the \f2jstatd\fP process when an existing RMI registry is not found.
+\-nr 
+Do not attempt to create an internal RMI registry within the \f2jstatd\fP process when an existing RMI registry is not found. 
 .TP 3
-\-p\  port
-Port number where the RMI registry is expected to be found, or, if not found, created if \f2\-nr\fP is not specified.
+\-p\  port 
+Port number where the RMI registry is expected to be found, or, if not found, created if \f2\-nr\fP is not specified. 
 .TP 3
-\-n\  rminame
-Name to which the remote RMI object is bound in the RMI registry. The default name is \f2JStatRemoteHost\fP. If multiple \f3jstatd\fP servers are started on the same host, the name of the exported RMI object for each server can be made unique by specifying this option. However, doing so will require that the unique server name be included in the monitoring client's \f2hostid\fP and \f2vmid\fP strings.
+\-n\  rminame 
+Name to which the remote RMI object is bound in the RMI registry. The default name is \f2JStatRemoteHost\fP. If multiple \f3jstatd\fP servers are started on the same host, the name of the exported RMI object for each server can be made unique by specifying this option. However, doing so will require that the unique server name be included in the monitoring client's \f2hostid\fP and \f2vmid\fP strings. 
 .TP 3
-\-Joption
-Pass \f2option\fP to the \f3java\fP launcher called by \f3javac\fP. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying VM executing applications written in Java.
+\-Joption 
+Pass \f2option\fP to the \f3java\fP launcher called by \f3javac\fP. For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying VM executing applications written in Java. 
 .RE
 
 .LP
@@ -88,11 +88,11 @@
 The \f3jstatd\fP server does not provide any authentication of remote clients. Therefore, running a \f3jstatd\fP server process exposes the instrumentation export by all JVMs for which the \f3jstatd\fP process has access permissions to any user on the network. This exposure may be undesireable in your environment and local security policies should be considered before starting the \f3jstatd\fP process, particularly in production environments or on unsecure networks.
 .LP
 .LP
-The \f3jstatd\fP server installs an instance of RMISecurityPolicy if no other security manager has been installed and therefore requires a security policy file to be specified. The policy file must conform to the default policy implementation's
+The \f3jstatd\fP server installs an instance of RMISecurityPolicy if no other security manager has been installed and therefore requires a security policy file to be specified. The policy file must conform to the default policy implementation's 
 .na
 \f2Policy File Syntax\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html.
 .LP
 .LP
 The following policy file will allow the \f3jstatd\fP server to run without any security exceptions. This policy is less liberal then granting all permissions to all codebases, but is more liberal than a policy that grants the minimal permissions to run the \f3jstatd\fP server.
@@ -143,7 +143,7 @@
 .LP
 Here are some examples of starting \f3jstatd\fP. Note that the \f3jstatd\fP scripts automatically start the server in the background.
 .LP
-.SS
+.SS 
 Using Internal RMI Registry
 .LP
 .LP
@@ -158,7 +158,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Using External RMI Registry
 .LP
 .LP
@@ -203,7 +203,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Inhibiting creation of an in\-process RMI registry
 .LP
 .LP
@@ -218,7 +218,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Enabling RMI logging capabilities.
 .LP
 .LP
@@ -238,20 +238,20 @@
 .RS 3
 .TP 2
 o
-java(1) \- the Java Application Launcher
+java(1) \- the Java Application Launcher 
 .TP 2
 o
-jps(1) \- the Java Process Status Application
+jps(1) \- the Java Process Status Application 
 .TP 2
 o
-jstat(1) \- the Java Virtual Machine Statistics Monitoring Tool
+jstat(1) \- the Java Virtual Machine Statistics Monitoring Tool 
 .TP 2
 o
 .na
 \f2rmiregistry\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#rmi \- the Java Remote Object Registry
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#rmi \- the Java Remote Object Registry 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/keytool.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/keytool.1	2013-05-05 09:38:28.000000000 -0700
@@ -1,4 +1,4 @@
-." Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
+." Copyright (c) 1998-2011 keytool tool, Oracle and/or its affiliates. All rights reserved.
 ." DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 ."
 ." This code is free software; you can redistribute it and/or modify it
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH keytool 1 "10 May 2011"
+.TH keytool 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -43,7 +43,7 @@
 .LP
 .SH "DESCRIPTION"
 .LP
-\f3keytool\fP is a key and certificate management utility. It allows users to administer their own public/private key pairs and associated certificates for use in self\-authentication (where the user authenticates himself/herself to other users/services) or data integrity and authentication services, using digital signatures. It also allows users to cache the public keys (in the form of certificates) of their communicating peers.
+\f3keytool\fP is a key and certificate management utility. It allows users to administer their own public/private key pairs and associated certificates for use in self\-authentication (where the user authenticates himself/herself to other users/services) or data integrity and authentication services, using digital signatures. It also allows users to cache the public keys (in the form of certificates) of their communicating peers. 
 .LP
 A \f2certificate\fP is a digitally signed statement from one entity (person, company, etc.), saying that the public key (and some other information) of some other entity has a particular value. (See Certificates.) When data is digitally signed, the signature can be verified to check the data integrity and authenticity. \f2Integrity\fP means that the data has not been modified or tampered with, and \f2authenticity\fP means the data indeed comes from whoever claims to have created and signed it.
 .LP
@@ -61,22 +61,22 @@
 .RS 3
 .TP 2
 o
-All command and option names are preceded by a minus sign (\-).
+All command and option names are preceded by a minus sign (\-). 
 .TP 2
 o
-The options for each command may be provided in any order.
+The options for each command may be provided in any order. 
 .TP 2
 o
-All items not italicized or in braces or square brackets are required to appear as is.
+All items not italicized or in braces or square brackets are required to appear as is. 
 .TP 2
 o
-Braces surrounding an option generally signify that a default value will be used if the option is not specified on the command line. Braces are also used around the \f2\-v\fP, \f2\-rfc\fP, and \f2\-J\fP options, which only have meaning if they appear on the command line (that is, they don't have any "default" values other than not existing).
+Braces surrounding an option generally signify that a default value will be used if the option is not specified on the command line. Braces are also used around the \f2\-v\fP, \f2\-rfc\fP, and \f2\-J\fP options, which only have meaning if they appear on the command line (that is, they don't have any "default" values other than not existing). 
 .TP 2
 o
-Brackets surrounding an option signify that the user is prompted for the value(s) if the option is not specified on the command line. (For a \f2\-keypass\fP option, if you do not specify the option on the command line, \f3keytool\fP will first attempt to use the keystore password to recover the private/secret key, and if this fails, will then prompt you for the private/secret key password.)
+Brackets surrounding an option signify that the user is prompted for the value(s) if the option is not specified on the command line. (For a \f2\-keypass\fP option, if you do not specify the option on the command line, \f3keytool\fP will first attempt to use the keystore password to recover the private/secret key, and if this fails, will then prompt you for the private/secret key password.) 
 .TP 2
 o
-Items in italics (option values) represent the actual values that must be supplied. For example, here is the format of the \f2\-printcert\fP command:
+Items in italics (option values) represent the actual values that must be supplied. For example, here is the format of the \f2\-printcert\fP command: 
 .nf
 \f3
 .fl
@@ -85,7 +85,7 @@
 \fP
 .fi
 .LP
-When specifying a \f2\-printcert\fP command, replace \f2cert_file\fP with the actual file name, as in:
+When specifying a \f2\-printcert\fP command, replace \f2cert_file\fP with the actual file name, as in: 
 .nf
 \f3
 .fl
@@ -95,10 +95,10 @@
 .fi
 .TP 2
 o
-Option values must be quoted if they contain a blank (space).
+Option values must be quoted if they contain a blank (space). 
 .TP 2
 o
-The \f2\-help\fP command is the default. Thus, the command line
+The \f2\-help\fP command is the default. Thus, the command line 
 .nf
 \f3
 .fl
@@ -107,7 +107,7 @@
 \fP
 .fi
 .LP
-is equivalent to
+is equivalent to 
 .nf
 \f3
 .fl
@@ -118,7 +118,7 @@
 .RE
 
 .LP
-.SS
+.SS 
 Option Defaults
 .LP
 .LP
@@ -187,24 +187,24 @@
 .RS 3
 .TP 2
 o
-If the underlying private key is of type "DSA", the \f2\-sigalg\fP option defaults to "SHA1withDSA"
+If the underlying private key is of type "DSA", the \f2\-sigalg\fP option defaults to "SHA1withDSA" 
 .TP 2
 o
-If the underlying private key is of type "RSA", the \f2\-sigalg\fP option defaults to "SHA256withRSA".
+If the underlying private key is of type "RSA", the \f2\-sigalg\fP option defaults to "SHA256withRSA". 
 .TP 2
 o
-If the underlying private key is of type "EC", the \f2\-sigalg\fP option defaults to "SHA256withECDSA".
+If the underlying private key is of type "EC", the \f2\-sigalg\fP option defaults to "SHA256withECDSA". 
 .RE
 
 .LP
 .LP
-Please consult the
+Please consult the 
 .na
 \f2Java Cryptography Architecture API Specification & Reference\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA for a full list of \f2\-keyalg\fP and \f2\-sigalg\fP you can choose from.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA for a full list of \f2\-keyalg\fP and \f2\-sigalg\fP you can choose from.
 .LP
-.SS
+.SS 
 Common Options
 .LP
 .LP
@@ -218,59 +218,59 @@
 .LP
 .RS 3
 .TP 3
-\-storetype storetype
+\-storetype storetype 
 .LP
-This qualifier specifies the type of keystore to be instantiated.
+This qualifier specifies the type of keystore to be instantiated.  
 .TP 3
-\-keystore keystore
+\-keystore keystore 
 .LP
-The keystore location.
+The keystore location. 
 .LP
-If the JKS storetype is used and a keystore file does not yet exist, then certain \f3keytool\fP commands may result in a new keystore file being created. For example, if \f2keytool \-genkeypair\fP is invoked and the \f2\-keystore\fP option is not specified, the default keystore file named \f2.keystore\fP in the user's home directory will be created if it does not already exist. Similarly, if the \f2\-keystore \fP\f2ks_file\fP option is specified but \f2ks_file\fP does not exist, then it will be created
+If the JKS storetype is used and a keystore file does not yet exist, then certain \f3keytool\fP commands may result in a new keystore file being created. For example, if \f2keytool \-genkeypair\fP is invoked and the \f2\-keystore\fP option is not specified, the default keystore file named \f2.keystore\fP in the user's home directory will be created if it does not already exist. Similarly, if the \f2\-keystore \fP\f2ks_file\fP option is specified but \f2ks_file\fP does not exist, then it will be created 
 .LP
-Note that the input stream from the \f2\-keystore\fP option is passed to the \f2KeyStore.load\fP method. If \f2NONE\fP is specified as the URL, then a null stream is passed to the \f2KeyStore.load\fP method. \f2NONE\fP should be specified if the \f2KeyStore\fP is not file\-based (for example, if it resides on a hardware token device).
+Note that the input stream from the \f2\-keystore\fP option is passed to the \f2KeyStore.load\fP method. If \f2NONE\fP is specified as the URL, then a null stream is passed to the \f2KeyStore.load\fP method. \f2NONE\fP should be specified if the \f2KeyStore\fP is not file\-based (for example, if it resides on a hardware token device).  
 .TP 3
-\-storepass[:env|:file] argument
+\-storepass[:env|:file] argument 
 .LP
-The password which is used to protect the integrity of the keystore.
+The password which is used to protect the integrity of the keystore. 
 .LP
-If the modifier \f2env\fP or \f2file\fP is not specified, then the password has the value \f2argument\fP, which must be at least 6 characters long. Otherwise, the password is retrieved as follows:
+If the modifier \f2env\fP or \f2file\fP is not specified, then the password has the value \f2argument\fP, which must be at least 6 characters long. Otherwise, the password is retrieved as follows: 
 .RS 3
 .TP 2
 o
-\f2env\fP: Retrieve the password from the environment variable named \f2argument\fP
+\f2env\fP: Retrieve the password from the environment variable named \f2argument\fP 
 .TP 2
 o
-\f2file\fP: Retrieve the password from the file named \f2argument\fP
+\f2file\fP: Retrieve the password from the file named \f2argument\fP 
 .RE
 .LP
-\f3Note\fP: All other options that require passwords, such as \f2\-keypass\fP, \f2\-srckeypass\fP, \f2\-destkeypass\fP \f2\-srcstorepass\fP, and \f2\-deststorepass\fP, accept the \f2env\fP and \f2file\fP modifiers. (Remember to separate the password option and the modifier with a colon, (\f2:\fP).)
+\f3Note\fP: All other options that require passwords, such as \f2\-keypass\fP, \f2\-srckeypass\fP, \f2\-destkeypass\fP \f2\-srcstorepass\fP, and \f2\-deststorepass\fP, accept the \f2env\fP and \f2file\fP modifiers. (Remember to separate the password option and the modifier with a colon, (\f2:\fP).) 
 .LP
-The password must be provided to all commands that access the keystore contents. For such commands, if a \f2\-storepass\fP option is not provided at the command line, the user is prompted for it.
+The password must be provided to all commands that access the keystore contents. For such commands, if a \f2\-storepass\fP option is not provided at the command line, the user is prompted for it. 
 .LP
-When retrieving information from the keystore, the password is optional; if no password is given, the integrity of the retrieved information cannot be checked and a warning is displayed.
+When retrieving information from the keystore, the password is optional; if no password is given, the integrity of the retrieved information cannot be checked and a warning is displayed.  
 .TP 3
-\-providerName provider_name
+\-providerName provider_name 
 .LP
-Used to identify a cryptographic service provider's name when listed in the security properties file.
+Used to identify a cryptographic service provider's name when listed in the security properties file.  
 .TP 3
-\-providerClass provider_class_name
+\-providerClass provider_class_name 
 .LP
-Used to specify the name of cryptographic service provider's master class file when the service provider is not listed in the security properties file.
+Used to specify the name of cryptographic service provider's master class file when the service provider is not listed in the security properties file.  
 .TP 3
-\-providerArg provider_arg
+\-providerArg provider_arg 
 .LP
-Used in conjunction with \f2\-providerClass\fP. Represents an optional string input argument for the constructor of \f2provider_class_name\fP.
+Used in conjunction with \f2\-providerClass\fP. Represents an optional string input argument for the constructor of \f2provider_class_name\fP.  
 .TP 3
-\-protected
+\-protected 
 .LP
-Either \f2true\fP or \f2false\fP. This value should be specified as \f2true\fP if a password must be given via a protected authentication path such as a dedicated PIN reader.
+Either \f2true\fP or \f2false\fP. This value should be specified as \f2true\fP if a password must be given via a protected authentication path such as a dedicated PIN reader. 
 .LP
-Note: Since there are two keystores involved in \f2\-importkeystore\fP command, two options, namely, \f2\-srcprotected\fP and \f2\-destprotected\fP are provided for the source keystore and the destination keystore respectively.
+Note: Since there are two keystores involved in \f2\-importkeystore\fP command, two options, namely, \f2\-srcprotected\fP and \f2\-destprotected\fP are provided for the source keystore and the destination keystore respectively.  
 .TP 3
-\-ext {name{:critical}{=value}}
+\-ext {name{:critical}{=value}} 
 .LP
-Denotes an X.509 certificate extension. The option can be used in \-genkeypair and \-gencert to embed extensions into the certificate generated, or in \f2\-certreq\fP to show what extensions are requested in the certificate request. The option can appear multiple times. name can be a supported extension name (see below) or an arbitrary OID number. value, if provided, denotes the parameter for the extension; if omitted, denotes the default value (if defined) of the extension or the extension requires no parameter. The \f2:critical\fP modifier, if provided, means the extension's isCritical attribute is true; otherwise, false. You may use \f2:c\fP in place of \f2:critical\fP.
+Denotes an X.509 certificate extension. The option can be used in \-genkeypair and \-gencert to embed extensions into the certificate generated, or in \f2\-certreq\fP to show what extensions are requested in the certificate request. The option can appear multiple times. name can be a supported extension name (see below) or an arbitrary OID number. value, if provided, denotes the parameter for the extension; if omitted, denotes the default value (if defined) of the extension or the extension requires no parameter. The \f2:critical\fP modifier, if provided, means the extension's isCritical attribute is true; otherwise, false. You may use \f2:c\fP in place of \f2:critical\fP.  
 .RE
 
 .LP
@@ -278,6 +278,7 @@
 Currently keytool supports these named extensions (case\-insensitive):
 .LP
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -521,13 +522,13 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Name\fP\h'|\n(41u'\f3Value\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'BC or BasicConstraints\h'|\n(41u'
@@ -543,7 +544,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'KU or KeyUsage\h'|\n(41u'
@@ -559,7 +560,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'EKU or ExtendedkeyUsage\h'|\n(41u'
@@ -577,7 +578,7 @@
 .ne \n(e|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'
@@ -602,7 +603,7 @@
 .ne \n(g|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'
@@ -625,7 +626,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'SIA or SubjectInfoAccess\h'|\n(41u'
@@ -643,7 +644,7 @@
 .ne \n(j|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'
@@ -678,11 +679,12 @@
 .rm h+
 .rm i+
 .rm j+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-38
 
 .LP
 .LP
-For name as OID, value is the HEX dumped DER encoding of the extnValue for the extension excluding the OCTET STRING type and length bytes. Any extra character other than standard HEX numbers (0\-9, a\-f, A\-F) are ignored in the HEX string. Therefore, both \f2"01:02:03:04"\fP and \f2"01020304"\fP are accepted as identical values. If there's no value, the extension has an empty value field then.
+For name as OID, value is the HEX dumped DER encoding of the extnValue for the extension excluding the OCTET STRING type and length bytes. Any extra character other than standard HEX numbers (0\-9, a\-f, A\-F) are ignored in the HEX string. Therefore, both \f2"01:02:03:04"\fP and \f2"01020304"\fP are accepted as identical values. If there is no value, the extension has an empty value field then.
 .LP
 .LP
 A special name \f2'honored'\fP, used in \f2\-gencert\fP only, denotes how the extensions included in the certificate request should be honored. The value for this name is a comma separated list of \f2"all"\fP (all requested extensions are honored), \f2"name{:[critical|non\-critical]}"\fP (the named extension is honored, but using a different isCritical attribute) and \f2"\-name"\fP (used with all, denotes an exception). Requested extensions are not honored by default.
@@ -698,24 +700,24 @@
 .LP
 .SH "COMMANDS"
 .LP
-.SS
+.SS 
 Creating or Adding Data to the Keystore
 .LP
 .RS 3
 .TP 3
-\-gencert {\-rfc} {\-infile infile} {\-outfile outfile} {\-alias alias} {\-sigalg sigalg} {\-dname dname} {\-startdate startdate {\-ext ext}* {\-validity valDays} [\-keypass keypass] {\-keystore keystore} [\-storepass storepass] {\-storetype storetype} {\-providername provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-gencert {\-rfc} {\-infile infile} {\-outfile outfile} {\-alias alias} {\-sigalg sigalg} {\-dname dname} {\-startdate startdate {\-ext ext}* {\-validity valDays} [\-keypass keypass] {\-keystore keystore} [\-storepass storepass] {\-storetype storetype} {\-providername provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Generates a certificate as a response to a certificate request file (which can be created by the \f2keytool \-certreq\fP command). The command reads the request from \f2infile\fP (if omitted, from the standard input), signs it using alias's private key, and output the X.509 certificate into \f2outfile\fP (if omitted, to the standard output). If \f2\-rfc\fP is specified, output format is BASE64\-encoded PEM; otherwise, a binary DER is created.
+Generates a certificate as a response to a certificate request file (which can be created by the \f2keytool \-certreq\fP command). The command reads the request from \f2infile\fP (if omitted, from the standard input), signs it using alias's private key, and output the X.509 certificate into \f2outfile\fP (if omitted, to the standard output). If \f2\-rfc\fP is specified, output format is BASE64\-encoded PEM; otherwise, a binary DER is created. 
 .LP
-\f2sigalg\fP specifies the algorithm that should be used to sign the certificate. \f2startdate\fP is the start time/date that the certificate is valid. \f2valDays\fP tells the number of days for which the certificate should be considered valid.
+\f2sigalg\fP specifies the algorithm that should be used to sign the certificate. \f2startdate\fP is the start time/date that the certificate is valid. \f2valDays\fP tells the number of days for which the certificate should be considered valid. 
 .LP
-If \f2dname\fP is provided, it's used as the subject of the generated certificate. Otherwise, the one from the certificate request is used.
+If \f2dname\fP is provided, it's used as the subject of the generated certificate. Otherwise, the one from the certificate request is used. 
 .LP
-\f2ext\fP shows what X.509 extensions will be embedded in the certificate. Read Common Options for the grammar of \f2\-ext\fP.
+\f2ext\fP shows what X.509 extensions will be embedded in the certificate. Read Common Options for the grammar of \f2\-ext\fP. 
 .LP
-The \f2\-gencert\fP command enables you to create certificate chains. The following example creates a certificate, \f2e1\fP, that contains three certificates in its certificate chain.
+The \f2\-gencert\fP command enables you to create certificate chains. The following example creates a certificate, \f2e1\fP, that contains three certificates in its certificate chain. 
 .LP
-The following commands creates four key pairs named \f2ca\fP, \f2ca1\fP, \f2ca2\fP, and \f2e1\fP:
+The following commands creates four key pairs named \f2ca\fP, \f2ca1\fP, \f2ca2\fP, and \f2e1\fP: 
 .nf
 \f3
 .fl
@@ -730,7 +732,7 @@
 \fP
 .fi
 .LP
-The following two commands create a chain of signed certificates; \f2ca\fP signs ca1 and \f2ca1 signs ca2\fP, all of which are self\-issued:
+The following two commands create a chain of signed certificates; \f2ca\fP signs ca1 and \f2ca1 signs ca2\fP, all of which are self\-issued: 
 .nf
 \f3
 .fl
@@ -741,7 +743,7 @@
 \fP
 .fi
 .LP
-The following command creates the certificate \f2e1\fP and stores it in the file \f2e1.cert\fP, which is signed by \f2ca2\fP. As a result, \f2e1\fP should contain \f2ca\fP, \f2ca1\fP, and \f2ca2\fP in its certificate chain:
+The following command creates the certificate \f2e1\fP and stores it in the file \f2e1.cert\fP, which is signed by \f2ca2\fP. As a result, \f2e1\fP should contain \f2ca\fP, \f2ca1\fP, and \f2ca2\fP in its certificate chain: 
 .nf
 \f3
 .fl
@@ -750,29 +752,29 @@
 \fP
 .fi
 .TP 3
-\-genkeypair {\-alias alias} {\-keyalg keyalg} {\-keysize keysize} {\-sigalg sigalg} [\-dname dname] [\-keypass keypass] {\-startdate value} {\-ext ext}* {\-validity valDays} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-genkeypair {\-alias alias} {\-keyalg keyalg} {\-keysize keysize} {\-sigalg sigalg} [\-dname dname] [\-keypass keypass] {\-startdate value} {\-ext ext}* {\-validity valDays} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Generates a key pair (a public key and associated private key). Wraps the public key into an X.509 v3 self\-signed certificate, which is stored as a single\-element certificate chain. This certificate chain and the private key are stored in a new keystore entry identified by \f2alias\fP.
+Generates a key pair (a public key and associated private key). Wraps the public key into an X.509 v3 self\-signed certificate, which is stored as a single\-element certificate chain. This certificate chain and the private key are stored in a new keystore entry identified by \f2alias\fP. 
 .LP
-\f2keyalg\fP specifies the algorithm to be used to generate the key pair, and \f2keysize\fP specifies the size of each key to be generated. \f2sigalg\fP specifies the algorithm that should be used to sign the self\-signed certificate; this algorithm must be compatible with \f2keyalg\fP.
+\f2keyalg\fP specifies the algorithm to be used to generate the key pair, and \f2keysize\fP specifies the size of each key to be generated. \f2sigalg\fP specifies the algorithm that should be used to sign the self\-signed certificate; this algorithm must be compatible with \f2keyalg\fP. 
 .LP
-\f2dname\fP specifies the X.500 Distinguished Name to be associated with \f2alias\fP, and is used as the \f2issuer\fP and \f2subject\fP fields in the self\-signed certificate. If no distinguished name is provided at the command line, the user will be prompted for one.
+\f2dname\fP specifies the X.500 Distinguished Name to be associated with \f2alias\fP, and is used as the \f2issuer\fP and \f2subject\fP fields in the self\-signed certificate. If no distinguished name is provided at the command line, the user will be prompted for one. 
 .LP
-\f2keypass\fP is a password used to protect the private key of the generated key pair. If no password is provided, the user is prompted for it. If you press RETURN at the prompt, the key password is set to the same password as that used for the keystore. \f2keypass\fP must be at least 6 characters long.
+\f2keypass\fP is a password used to protect the private key of the generated key pair. If no password is provided, the user is prompted for it. If you press RETURN at the prompt, the key password is set to the same password as that used for the keystore. \f2keypass\fP must be at least 6 characters long. 
 .LP
-\f2startdate\fP specifies the issue time of the certificate, also known as the "Not Before" value of the X.509 certificate's Validity field.
+\f2startdate\fP specifies the issue time of the certificate, also known as the "Not Before" value of the X.509 certificate's Validity field. 
 .LP
-The option value can be set in one of these two forms:
+The option value can be set in one of these two forms: 
 .RS 3
 .TP 3
 1.
-([+\-]\f2nnn\fP[ymdHMS])+
+([+\-]\f2nnn\fP[ymdHMS])+ 
 .TP 3
 2.
-[yyyy/mm/dd] [HH:MM:SS]
+[yyyy/mm/dd] [HH:MM:SS] 
 .RE
 .LP
-With the first form, the issue time is shifted by the specified value from the current time. The value is a concatenation of a sequence of sub values. Inside each sub value, the plus sign ("+") means shifting forward, and the minus sign ("\-") means shifting backward. The time to be shifted is \f2nnn\fP units of years, months, days, hours, minutes, or seconds (denoted by a single character of "y", "m", "d", "H", "M", or "S" respectively). The exact value of the issue time is calculated using the \f2java.util.GregorianCalendar.add(int field, int amount)\fP method on each sub value, from left to right. For example, by specifying \f2"\-startdate \-1y+1m\-1d"\fP, the issue time will be:
+With the first form, the issue time is shifted by the specified value from the current time. The value is a concatenation of a sequence of sub values. Inside each sub value, the plus sign ("+") means shifting forward, and the minus sign ("\-") means shifting backward. The time to be shifted is \f2nnn\fP units of years, months, days, hours, minutes, or seconds (denoted by a single character of "y", "m", "d", "H", "M", or "S" respectively). The exact value of the issue time is calculated using the \f2java.util.GregorianCalendar.add(int field, int amount)\fP method on each sub value, from left to right. For example, by specifying \f2"\-startdate \-1y+1m\-1d"\fP, the issue time will be: 
 .nf
 \f3
 .fl
@@ -789,197 +791,197 @@
 \fP
 .fi
 .LP
-With the second form, the user sets the exact issue time in two parts, year/month/day and hour:minute:second (using the local time zone). The user may provide only one part, which means the other part is the same as the current date (or time). User must provide the exact number of digits as shown in the format definition (padding with 0 if shorter). When both the date and time are provided, there is one (and only one) space character between the two parts. The hour should always be provided in 24 hour format.
+With the second form, the user sets the exact issue time in two parts, year/month/day and hour:minute:second (using the local time zone). The user may provide only one part, which means the other part is the same as the current date (or time). User must provide the exact number of digits as shown in the format definition (padding with 0 if shorter). When both the date and time are provided, there is one (and only one) space character between the two parts. The hour should always be provided in 24 hour format. 
 .LP
-When the option is not provided, the start date is the current time. The option can be provided at most once.
+When the option is not provided, the start date is the current time. The option can be provided at most once. 
 .LP
-\f2valDays\fP specifies the number of days (starting at the date specified by \f2\-startdate\fP, or the current date if \f2\-startdate\fP is not specified) for which the certificate should be considered valid.
+\f2valDays\fP specifies the number of days (starting at the date specified by \f2\-startdate\fP, or the current date if \f2\-startdate\fP is not specified) for which the certificate should be considered valid. 
 .LP
-This command was named \f2\-genkey\fP in previous releases. This old name is still supported in this release and will be supported in future releases, but for clarity the new name, \f2\-genkeypair\fP, is preferred going forward.
+This command was named \f2\-genkey\fP in previous releases. This old name is still supported in this release and will be supported in future releases, but for clarity the new name, \f2\-genkeypair\fP, is preferred going forward.  
 .TP 3
-\-genseckey {\-alias alias} {\-keyalg keyalg} {\-keysize keysize} [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-genseckey {\-alias alias} {\-keyalg keyalg} {\-keysize keysize} [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Generates a secret key and stores it in a new \f2KeyStore.SecretKeyEntry\fP identified by \f2alias\fP.
+Generates a secret key and stores it in a new \f2KeyStore.SecretKeyEntry\fP identified by \f2alias\fP. 
 .LP
-\f2keyalg\fP specifies the algorithm to be used to generate the secret key, and \f2keysize\fP specifies the size of the key to be generated. \f2keypass\fP is a password used to protect the secret key. If no password is provided, the user is prompted for it. If you press RETURN at the prompt, the key password is set to the same password as that used for the keystore. \f2keypass\fP must be at least 6 characters long.
+\f2keyalg\fP specifies the algorithm to be used to generate the secret key, and \f2keysize\fP specifies the size of the key to be generated. \f2keypass\fP is a password used to protect the secret key. If no password is provided, the user is prompted for it. If you press RETURN at the prompt, the key password is set to the same password as that used for the keystore. \f2keypass\fP must be at least 6 characters long.  
 .TP 3
-\-importcert {\-alias alias} {\-file cert_file} [\-keypass keypass] {\-noprompt} {\-trustcacerts} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-importcert {\-alias alias} {\-file cert_file} [\-keypass keypass] {\-noprompt} {\-trustcacerts} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Reads the certificate or certificate chain (where the latter is supplied in a PKCS#7 formatted reply or a sequence of X.509 certificates) from the file \f2cert_file\fP, and stores it in the keystore entry identified by \f2alias\fP. If no file is given, the certificate or certificate chain is read from stdin.
+Reads the certificate or certificate chain (where the latter is supplied in a PKCS#7 formatted reply or a sequence of X.509 certificates) from the file \f2cert_file\fP, and stores it in the keystore entry identified by \f2alias\fP. If no file is given, the certificate or certificate chain is read from stdin. 
 .LP
-\f3keytool\fP can import X.509 v1, v2, and v3 certificates, and PKCS#7 formatted certificate chains consisting of certificates of that type. The data to be imported must be provided either in binary encoding format, or in printable encoding format (also known as Base64 encoding) as defined by the Internet RFC 1421 standard. In the latter case, the encoding must be bounded at the beginning by a string that starts with "\-\-\-\-\-BEGIN", and bounded at the end by a string that starts with "\-\-\-\-\-END".
+\f3keytool\fP can import X.509 v1, v2, and v3 certificates, and PKCS#7 formatted certificate chains consisting of certificates of that type. The data to be imported must be provided either in binary encoding format, or in printable encoding format (also known as Base64 encoding) as defined by the Internet RFC 1421 standard. In the latter case, the encoding must be bounded at the beginning by a string that starts with "\-\-\-\-\-BEGIN", and bounded at the end by a string that starts with "\-\-\-\-\-END". 
 .LP
-You import a certificate for two reasons:
+You import a certificate for two reasons: 
 .RS 3
 .TP 3
 1.
-to add it to the list of trusted certificates, or
+to add it to the list of trusted certificates, or 
 .TP 3
 2.
-to import a certificate reply received from a CA as the result of submitting a Certificate Signing Request (see the \-certreq command) to that CA.
+to import a certificate reply received from a CA as the result of submitting a Certificate Signing Request (see the \-certreq command) to that CA. 
 .RE
 .LP
-Which type of import is intended is indicated by the value of the \f2\-alias\fP option:
+Which type of import is intended is indicated by the value of the \f2\-alias\fP option: 
 .RS 3
 .TP 3
 1.
-\f3If the alias does not point to a key entry\fP, then \f3keytool\fP assumes you are adding a trusted certificate entry. In this case, the alias should not already exist in the keystore. If the alias does already exist, then \f3keytool\fP outputs an error, since there is already a trusted certificate for that alias, and does not import the certificate.
+\f3If the alias does not point to a key entry\fP, then \f3keytool\fP assumes you are adding a trusted certificate entry. In this case, the alias should not already exist in the keystore. If the alias does already exist, then \f3keytool\fP outputs an error, since there is already a trusted certificate for that alias, and does not import the certificate. 
 .TP 3
 2.
-\f3If the alias points to a key entry\fP, then \f3keytool\fP assumes you are importing a certificate reply.
+\f3If the alias points to a key entry\fP, then \f3keytool\fP assumes you are importing a certificate reply. 
 .RE
-\f3Importing a New Trusted Certificate\fP
+\f3Importing a New Trusted Certificate\fP 
 .LP
-Before adding the certificate to the keystore, \f3keytool\fP tries to verify it by attempting to construct a chain of trust from that certificate to a self\-signed certificate (belonging to a root CA), using trusted certificates that are already available in the keystore.
+Before adding the certificate to the keystore, \f3keytool\fP tries to verify it by attempting to construct a chain of trust from that certificate to a self\-signed certificate (belonging to a root CA), using trusted certificates that are already available in the keystore. 
 .LP
-If the \f2\-trustcacerts\fP option has been specified, additional certificates are considered for the chain of trust, namely the certificates in a file named "cacerts".
+If the \f2\-trustcacerts\fP option has been specified, additional certificates are considered for the chain of trust, namely the certificates in a file named "cacerts". 
 .LP
-If \f3keytool\fP fails to establish a trust path from the certificate to be imported up to a self\-signed certificate (either from the keystore or the "cacerts" file), the certificate information is printed out, and the user is prompted to verify it, e.g., by comparing the displayed certificate fingerprints with the fingerprints obtained from some other (trusted) source of information, which might be the certificate owner himself/herself. Be very careful to ensure the certificate is valid prior to importing it as a "trusted" certificate! \-\- see WARNING Regarding Importing Trusted Certificates. The user then has the option of aborting the import operation. If the \f2\-noprompt\fP option is given, however, there will be no interaction with the user.
-\f3Importing a Certificate Reply\fP
+If \f3keytool\fP fails to establish a trust path from the certificate to be imported up to a self\-signed certificate (either from the keystore or the "cacerts" file), the certificate information is printed out, and the user is prompted to verify it, e.g., by comparing the displayed certificate fingerprints with the fingerprints obtained from some other (trusted) source of information, which might be the certificate owner himself/herself. Be very careful to ensure the certificate is valid prior to importing it as a "trusted" certificate! \-\- see WARNING Regarding Importing Trusted Certificates. The user then has the option of aborting the import operation. If the \f2\-noprompt\fP option is given, however, there will be no interaction with the user. 
+\f3Importing a Certificate Reply\fP 
 .LP
-When importing a certificate reply, the certificate reply is validated using trusted certificates from the keystore, and optionally using the certificates configured in the "cacerts" keystore file (if the \f2\-trustcacerts\fP option was specified).
+When importing a certificate reply, the certificate reply is validated using trusted certificates from the keystore, and optionally using the certificates configured in the "cacerts" keystore file (if the \f2\-trustcacerts\fP option was specified). 
 .LP
-The methods of determining whether the certificate reply is trusted are described in the following:
+The methods of determining whether the certificate reply is trusted are described in the following: 
 .RS 3
 .TP 2
 o
-\f3If the reply is a single X.509 certificate\fP, \f3keytool\fP attempts to establish a trust chain, starting at the certificate reply and ending at a self\-signed certificate (belonging to a root CA). The certificate reply and the hierarchy of certificates used to authenticate the certificate reply form the new certificate chain of \f2alias\fP. If a trust chain cannot be established, the certificate reply is not imported. In this case, \f3keytool\fP does not print out the certificate and prompt the user to verify it, because it is very hard (if not impossible) for a user to determine the authenticity of the certificate reply.
+\f3If the reply is a single X.509 certificate\fP, \f3keytool\fP attempts to establish a trust chain, starting at the certificate reply and ending at a self\-signed certificate (belonging to a root CA). The certificate reply and the hierarchy of certificates used to authenticate the certificate reply form the new certificate chain of \f2alias\fP. If a trust chain cannot be established, the certificate reply is not imported. In this case, \f3keytool\fP does not print out the certificate and prompt the user to verify it, because it is very hard (if not impossible) for a user to determine the authenticity of the certificate reply. 
 .TP 2
 o
-\f3If the reply is a PKCS#7 formatted certificate chain or a sequence of X.509 certificates\fP, the chain is ordered with the user certificate first followed by zero or more CA certificates. If the chain ends with a self\-signed root CA certificate and \f2\-trustcacerts\fP option was specified, \f3keytool\fP will attempt to match it with any of the trusted certificates in the keystore or the "cacerts" keystore file. If the chain does not end with a self\-signed root CA certificate and the \f2\-trustcacerts\fP option was specified, \f3keytool\fP will try to find one from the trusted certificates in the keystore or the "cacerts" keystore file and add it to the end of the chain. If the certificate is not found and \f2\-noprompt\fP option is not specified, the information of the last certificate in the chain is printed out, and the user is prompted to verify it.
+\f3If the reply is a PKCS#7 formatted certificate chain or a sequence of X.509 certificates\fP, the chain is ordered with the user certificate first followed by zero or more CA certificates. If the chain ends with a self\-signed root CA certificate and \f2\-trustcacerts\fP option was specified, \f3keytool\fP will attempt to match it with any of the trusted certificates in the keystore or the "cacerts" keystore file. If the chain does not end with a self\-signed root CA certificate and the \f2\-trustcacerts\fP option was specified, \f3keytool\fP will try to find one from the trusted certificates in the keystore or the "cacerts" keystore file and add it to the end of the chain. If the certificate is not found and \f2\-noprompt\fP option is not specified, the information of the last certificate in the chain is printed out, and the user is prompted to verify it. 
 .RE
 .LP
-If the public key in the certificate reply matches the user's public key already stored with under \f2alias\fP, the old certificate chain is replaced with the new certificate chain in the reply. The old chain can only be replaced if a valid \f2keypass\fP, the password used to protect the private key of the entry, is supplied. If no password is provided, and the private key password is different from the keystore password, the user is prompted for it.
+If the public key in the certificate reply matches the user's public key already stored with under \f2alias\fP, the old certificate chain is replaced with the new certificate chain in the reply. The old chain can only be replaced if a valid \f2keypass\fP, the password used to protect the private key of the entry, is supplied. If no password is provided, and the private key password is different from the keystore password, the user is prompted for it. 
 .LP
-This command was named \f2\-import\fP in previous releases. This old name is still supported in this release and will be supported in future releases, but for clarify the new name, \f2\-importcert\fP, is preferred going forward.
+This command was named \f2\-import\fP in previous releases. This old name is still supported in this release and will be supported in future releases, but for clarify the new name, \f2\-importcert\fP, is preferred going forward.    
 .TP 3
-\-importkeystore \-srckeystore srckeystore \-destkeystore destkeystore {\-srcstoretype srcstoretype} {\-deststoretype deststoretype} [\-srcstorepass srcstorepass] [\-deststorepass deststorepass] {\-srcprotected} {\-destprotected} {\-srcalias srcalias {\-destalias destalias} [\-srckeypass srckeypass] [\-destkeypass destkeypass] } {\-noprompt} {\-srcProviderName src_provider_name} {\-destProviderName dest_provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-importkeystore \-srckeystore srckeystore \-destkeystore destkeystore {\-srcstoretype srcstoretype} {\-deststoretype deststoretype} [\-srcstorepass srcstorepass] [\-deststorepass deststorepass] {\-srcprotected} {\-destprotected} {\-srcalias srcalias {\-destalias destalias} [\-srckeypass srckeypass] [\-destkeypass destkeypass] } {\-noprompt} {\-srcProviderName src_provider_name} {\-destProviderName dest_provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Imports a single entry or all entries from a source keystore to a destination keystore.
+Imports a single entry or all entries from a source keystore to a destination keystore. 
 .LP
-When the \f2srcalias\fP option is provided, the command imports the single entry identified by the alias to the destination keystore. If a destination alias is not provided with \f2destalias\fP, then \f2srcalias\fP is used as the destination alias. If the source entry is protected by a password, \f2srckeypass\fP will be used to recover the entry. If \f2srckeypass\fP is not provided, then \f3keytool\fP will attempt to use \f2srcstorepass\fP to recover the entry. If \f2srcstorepass\fP is either not provided or is incorrect, the user will be prompted for a password. The destination entry will be protected using \f2destkeypass\fP. If \f2destkeypass\fP is not provided, the destination entry will be protected with the source entry password.
+When the \f2srcalias\fP option is provided, the command imports the single entry identified by the alias to the destination keystore. If a destination alias is not provided with \f2destalias\fP, then \f2srcalias\fP is used as the destination alias. If the source entry is protected by a password, \f2srckeypass\fP will be used to recover the entry. If \f2srckeypass\fP is not provided, then \f3keytool\fP will attempt to use \f2srcstorepass\fP to recover the entry. If \f2srcstorepass\fP is either not provided or is incorrect, the user will be prompted for a password. The destination entry will be protected using \f2destkeypass\fP. If \f2destkeypass\fP is not provided, the destination entry will be protected with the source entry password. 
 .LP
-If the \f2srcalias\fP option is not provided, then all entries in the source keystore are imported into the destination keystore. Each destination entry will be stored under the alias from the source entry. If the source entry is protected by a password, \f2srcstorepass\fP will be used to recover the entry. If \f2srcstorepass\fP is either not provided or is incorrect, the user will be prompted for a password. If a source keystore entry type is not supported in the destination keystore, or if an error occurs while storing an entry into the destination keystore, the user will be prompted whether to skip the entry and continue, or to quit. The destination entry will be protected with the source entry password.
+If the \f2srcalias\fP option is not provided, then all entries in the source keystore are imported into the destination keystore. Each destination entry will be stored under the alias from the source entry. If the source entry is protected by a password, \f2srcstorepass\fP will be used to recover the entry. If \f2srcstorepass\fP is either not provided or is incorrect, the user will be prompted for a password. If a source keystore entry type is not supported in the destination keystore, or if an error occurs while storing an entry into the destination keystore, the user will be prompted whether to skip the entry and continue, or to quit. The destination entry will be protected with the source entry password. 
 .LP
-If the destination alias already exists in the destination keystore, the user is prompted to either overwrite the entry, or to create a new entry under a different alias name.
+If the destination alias already exists in the destination keystore, the user is prompted to either overwrite the entry, or to create a new entry under a different alias name. 
 .LP
-Note that if \f2\-noprompt\fP is provided, the user will not be prompted for a new destination alias. Existing entries will automatically be overwritten with the destination alias name. Finally, entries that can not be imported are automatically skipped and a warning is output.
+Note that if \f2\-noprompt\fP is provided, the user will not be prompted for a new destination alias. Existing entries will automatically be overwritten with the destination alias name. Finally, entries that can not be imported are automatically skipped and a warning is output.  
 .TP 3
-\-printcertreq {\-file file}
+\-printcertreq {\-file file} 
 .LP
-Prints the content of a PKCS #10 format certificate request, which can be generated by the keytool \-certreq command. The command reads the request from file; if omitted, from the standard input.
+Prints the content of a PKCS #10 format certificate request, which can be generated by the keytool \-certreq command. The command reads the request from file; if omitted, from the standard input.  
 .RE
 
 .LP
-.SS
+.SS 
 Exporting Data
 .LP
 .RS 3
 .TP 3
-\-certreq {\-alias alias} {\-dname dname} {\-sigalg sigalg} {\-file certreq_file} [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-certreq {\-alias alias} {\-dname dname} {\-sigalg sigalg} {\-file certreq_file} [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Generates a Certificate Signing Request (CSR), using the PKCS#10 format.
+Generates a Certificate Signing Request (CSR), using the PKCS#10 format. 
 .LP
-A CSR is intended to be sent to a certificate authority (CA). The CA will authenticate the certificate requestor (usually off\-line) and will return a certificate or certificate chain, used to replace the existing certificate chain (which initially consists of a self\-signed certificate) in the keystore.
+A CSR is intended to be sent to a certificate authority (CA). The CA will authenticate the certificate requestor (usually off\-line) and will return a certificate or certificate chain, used to replace the existing certificate chain (which initially consists of a self\-signed certificate) in the keystore. 
 .LP
-The private key associated with \f2alias\fP is used to create the PKCS#10 certificate request. In order to access the private key, the appropriate password must be provided, since private keys are protected in the keystore with a password. If \f2keypass\fP is not provided at the command line, and is different from the password used to protect the integrity of the keystore, the user is prompted for it. If dname is provided, it's used as the subject in the CSR. Otherwise, the X.500 Distinguished Name associated with alias is used.
+The private key associated with \f2alias\fP is used to create the PKCS#10 certificate request. In order to access the private key, the appropriate password must be provided, since private keys are protected in the keystore with a password. If \f2keypass\fP is not provided at the command line, and is different from the password used to protect the integrity of the keystore, the user is prompted for it. If dname is provided, it's used as the subject in the CSR. Otherwise, the X.500 Distinguished Name associated with alias is used. 
 .LP
-\f2sigalg\fP specifies the algorithm that should be used to sign the CSR.
+\f2sigalg\fP specifies the algorithm that should be used to sign the CSR. 
 .LP
-The CSR is stored in the file \f2certreq_file\fP. If no file is given, the CSR is output to stdout.
+The CSR is stored in the file \f2certreq_file\fP. If no file is given, the CSR is output to stdout. 
 .LP
-Use the \f2importcert\fP command to import the response from the CA.
+Use the \f2importcert\fP command to import the response from the CA.  
 .TP 3
-\-exportcert {\-alias alias} {\-file cert_file} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-rfc} {\-v} {\-protected} {\-Jjavaoption}
+\-exportcert {\-alias alias} {\-file cert_file} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-rfc} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Reads (from the keystore) the certificate associated with \f2alias\fP, and stores it in the file \f2cert_file\fP.
+Reads (from the keystore) the certificate associated with \f2alias\fP, and stores it in the file \f2cert_file\fP. 
 .LP
-If no file is given, the certificate is output to stdout.
+If no file is given, the certificate is output to stdout. 
 .LP
-The certificate is by default output in binary encoding, but will instead be output in the printable encoding format, as defined by the Internet RFC 1421 standard, if the \f2\-rfc\fP option is specified.
+The certificate is by default output in binary encoding, but will instead be output in the printable encoding format, as defined by the Internet RFC 1421 standard, if the \f2\-rfc\fP option is specified. 
 .LP
-If \f2alias\fP refers to a trusted certificate, that certificate is output. Otherwise, \f2alias\fP refers to a key entry with an associated certificate chain. In that case, the first certificate in the chain is returned. This certificate authenticates the public key of the entity addressed by \f2alias\fP.
+If \f2alias\fP refers to a trusted certificate, that certificate is output. Otherwise, \f2alias\fP refers to a key entry with an associated certificate chain. In that case, the first certificate in the chain is returned. This certificate authenticates the public key of the entity addressed by \f2alias\fP. 
 .LP
-This command was named \f2\-export\fP in previous releases. This old name is still supported in this release and will be supported in future releases, but for clarify the new name, \f2\-exportcert\fP, is preferred going forward.
+This command was named \f2\-export\fP in previous releases. This old name is still supported in this release and will be supported in future releases, but for clarify the new name, \f2\-exportcert\fP, is preferred going forward.  
 .RE
 
 .LP
-.SS
+.SS 
 Displaying Data
 .LP
 .RS 3
 .TP 3
-\-list {\-alias alias} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v | \-rfc} {\-protected} {\-Jjavaoption}
+\-list {\-alias alias} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v | \-rfc} {\-protected} {\-Jjavaoption} 
 .LP
-Prints (to stdout) the contents of the keystore entry identified by \f2alias\fP. If no alias is specified, the contents of the entire keystore are printed.
+Prints (to stdout) the contents of the keystore entry identified by \f2alias\fP. If no alias is specified, the contents of the entire keystore are printed. 
 .LP
-This command by default prints the SHA1 fingerprint of a certificate. If the \f2\-v\fP option is specified, the certificate is printed in human\-readable format, with additional information such as the owner, issuer, serial number, and any extensions. If the \f2\-rfc\fP option is specified, certificate contents are printed using the printable encoding format, as defined by the Internet RFC 1421 standard
+This command by default prints the SHA1 fingerprint of a certificate. If the \f2\-v\fP option is specified, the certificate is printed in human\-readable format, with additional information such as the owner, issuer, serial number, and any extensions. If the \f2\-rfc\fP option is specified, certificate contents are printed using the printable encoding format, as defined by the Internet RFC 1421 standard 
 .LP
-You cannot specify both \f2\-v\fP and \f2\-rfc\fP.
+You cannot specify both \f2\-v\fP and \f2\-rfc\fP.  
 .TP 3
-\-printcert {\-file cert_file | \-sslserver host[:port]} {\-jarfile JAR_file {\-rfc} {\-v} {\-Jjavaoption}
+\-printcert {\-file cert_file | \-sslserver host[:port]} {\-jarfile JAR_file {\-rfc} {\-v} {\-Jjavaoption} 
 .LP
-Reads the certificate from the file \f2cert_file\fP, the SSL server located at \f2host:port\fP, or the signed JAR file \f2JAR_file\fP (with the option \f2\-jarfile\fP and prints its contents in a human\-readable format. When no port is specified, the standard HTTPS port 443 is assumed. Note that \f2\-sslserver\fP and \f2\-file\fP options cannot be provided at the same time. Otherwise, an error is reported. If neither option is given, the certificate is read from stdin.
+Reads the certificate from the file \f2cert_file\fP, the SSL server located at \f2host:port\fP, or the signed JAR file \f2JAR_file\fP (with the option \f2\-jarfile\fP and prints its contents in a human\-readable format. When no port is specified, the standard HTTPS port 443 is assumed. Note that \f2\-sslserver\fP and \f2\-file\fP options cannot be provided at the same time. Otherwise, an error is reported. If neither option is given, the certificate is read from stdin. 
 .LP
-If \f2\-rfc\fP is specified, keytool prints the certificate in PEM mode as defined by the Internet RFC 1421 standard.
+If \f2\-rfc\fP is specified, keytool prints the certificate in PEM mode as defined by the Internet RFC 1421 standard. 
 .LP
-If the certificate is read from a file or stdin, it may be either binary encoded or in printable encoding format, as defined by the Internet RFC 1421 standard
+If the certificate is read from a file or stdin, it may be either binary encoded or in printable encoding format, as defined by the Internet RFC 1421 standard 
 .LP
-If the SSL server is behind a firewall, \f2\-J\-Dhttps.proxyHost=proxyhost\fP and \f2\-J\-Dhttps.proxyPort=proxyport\fP can be specified on the command line for proxy tunneling. See the
+If the SSL server is behind a firewall, \f2\-J\-Dhttps.proxyHost=proxyhost\fP and \f2\-J\-Dhttps.proxyPort=proxyport\fP can be specified on the command line for proxy tunneling. See the 
 .na
 \f2JSSE Reference Guide\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html for more information.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html for more information. 
 .LP
-\f3Note\fP: This option can be used independently of a keystore.
+\f3Note\fP: This option can be used independently of a keystore.  
 .TP 3
-\-printcrl \-file crl_ {\-v}
+\-printcrl \-file crl_ {\-v} 
 .LP
-Reads the certificate revocation list (CRL) from the file \f2crl_file\fP.
+Reads the certificate revocation list (CRL) from the file \f2crl_file\fP. 
 .LP
-A Certificate Revocation List (CRL) is a list of digital certificates which have been revoked by the Certificate Authority (CA) that issued them. The CA generates \f2crl_file\fP.
+A Certificate Revocation List (CRL) is a list of digital certificates which have been revoked by the Certificate Authority (CA) that issued them. The CA generates \f2crl_file\fP. 
 .LP
-\f3Note\fP: This option can be used independently of a keystore.
+\f3Note\fP: This option can be used independently of a keystore.  
 .RE
 
 .LP
-.SS
+.SS 
 Managing the Keystore
 .LP
 .RS 3
 .TP 3
-\-storepasswd [\-new new_storepass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-Jjavaoption}
+\-storepasswd [\-new new_storepass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-Jjavaoption} 
 .LP
-Changes the password used to protect the integrity of the keystore contents. The new password is \f2new_storepass\fP, which must be at least 6 characters long.
+Changes the password used to protect the integrity of the keystore contents. The new password is \f2new_storepass\fP, which must be at least 6 characters long.  
 .TP 3
-\-keypasswd {\-alias alias} [\-keypass old_keypass] [\-new new_keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-Jjavaoption}
+\-keypasswd {\-alias alias} [\-keypass old_keypass] [\-new new_keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-Jjavaoption} 
 .LP
-Changes the password under which the private/secret key identified by \f2alias\fP is protected, from \f2old_keypass\fP to \f2new_keypass\fP, which must be at least 6 characters long.
+Changes the password under which the private/secret key identified by \f2alias\fP is protected, from \f2old_keypass\fP to \f2new_keypass\fP, which must be at least 6 characters long. 
 .LP
-If the \f2\-keypass\fP option is not provided at the command line, and the key password is different from the keystore password, the user is prompted for it.
+If the \f2\-keypass\fP option is not provided at the command line, and the key password is different from the keystore password, the user is prompted for it. 
 .LP
-If the \f2\-new\fP option is not provided at the command line, the user is prompted for it.
+If the \f2\-new\fP option is not provided at the command line, the user is prompted for it.  
 .TP 3
-\-delete [\-alias alias] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-delete [\-alias alias] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Deletes from the keystore the entry identified by \f2alias\fP. The user is prompted for the alias, if no alias is provided at the command line.
+Deletes from the keystore the entry identified by \f2alias\fP. The user is prompted for the alias, if no alias is provided at the command line.  
 .TP 3
-\-changealias {\-alias alias} [\-destalias destalias] [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption}
+\-changealias {\-alias alias} [\-destalias destalias] [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
 .LP
-Move an existing keystore entry from the specified \f2alias\fP to a new alias, \f2destalias\fP. If no destination alias is provided, the command will prompt for one. If the original entry is protected with an entry password, the password can be supplied via the "\-keypass" option. If no key password is provided, the \f2storepass\fP (if given) will be attempted first. If that attempt fails, the user will be prompted for a password.
+Move an existing keystore entry from the specified \f2alias\fP to a new alias, \f2destalias\fP. If no destination alias is provided, the command will prompt for one. If the original entry is protected with an entry password, the password can be supplied via the "\-keypass" option. If no key password is provided, the \f2storepass\fP (if given) will be attempted first. If that attempt fails, the user will be prompted for a password.  
 .RE
 
 .LP
-.SS
+.SS 
 Getting Help
 .LP
 .RS 3
 .TP 3
-\-help
+\-help 
 .LP
-Lists the basic commands and their options.
+Lists the basic commands and their options. 
 .LP
-For more information about a specific command, enter the following, where \f2command_name\fP is the name of the command:
+For more information about a specific command, enter the following, where \f2command_name\fP is the name of the command: 
 .nf
 \f3
 .fl
@@ -995,7 +997,7 @@
 .LP
 Suppose you want to create a keystore for managing your public/private key pair and certificates from entities you trust.
 .LP
-.SS
+.SS 
 Generating Your Key Pair
 .LP
 .LP
@@ -1041,7 +1043,7 @@
 .LP
 The rest of the examples assume you executed the \f2\-genkeypair\fP command without options specified, and that you responded to the prompts with values equal to those given in the first \f2\-genkeypair\fP command, above (for example, a distinguished name of "cn=Mark Jones, ou=Java, o=Oracle, c=US").
 .LP
-.SS
+.SS 
 Requesting a Signed Certificate from a Certification Authority
 .LP
 .LP
@@ -1059,7 +1061,7 @@
 .LP
 This creates a CSR (for the entity identified by the default alias "mykey") and puts the request in the file named "MarkJ.csr". Submit this file to a CA, such as VeriSign, Inc. The CA will authenticate you, the requestor (usually off\-line), and then will return a certificate, signed by them, authenticating your public key. (In some cases, they will actually return a chain of certificates, each one authenticating the public key of the signer of the previous certificate in the chain.)
 .LP
-.SS
+.SS 
 Importing a Certificate for the CA
 .LP
 .LP
@@ -1071,10 +1073,10 @@
 .RS 3
 .TP 2
 o
-If the certificate reply is a certificate chain, you just need the top certificate of the chain (that is, the "root" CA certificate authenticating that CA's public key).
+If the certificate reply is a certificate chain, you just need the top certificate of the chain (that is, the "root" CA certificate authenticating that CA's public key). 
 .TP 2
 o
-If the certificate reply is a single certificate, you need a certificate for the issuing CA (the one that signed it), and if that certificate is not self\-signed, you need a certificate for its signer, and so on, up to a self\-signed "root" CA certificate.
+If the certificate reply is a single certificate, you need a certificate for the issuing CA (the one that signed it), and if that certificate is not self\-signed, you need a certificate for its signer, and so on, up to a self\-signed "root" CA certificate. 
 .RE
 
 .LP
@@ -1102,11 +1104,11 @@
 .LP
 This creates a "trusted certificate" entry in the keystore, with the data from the file "ABCCA.cer", and assigns the alias "abc" to the entry.
 .LP
-.SS
+.SS 
 Importing the Certificate Reply from the CA
 .LP
 .LP
-Once you've imported a certificate authenticating the public key of the CA you submitted your certificate signing request to (or there's already such a certificate in the "cacerts" file), you can import the certificate reply and thereby replace your self\-signed certificate with a certificate chain. This chain is the one returned by the CA in response to your request (if the CA reply is a chain), or one constructed (if the CA reply is a single certificate) using the certificate reply and trusted certificates that are already available in the keystore where you import the reply or in the "cacerts" keystore file.
+Once you've imported a certificate authenticating the public key of the CA you submitted your certificate signing request to (or there is already such a certificate in the "cacerts" file), you can import the certificate reply and thereby replace your self\-signed certificate with a certificate chain. This chain is the one returned by the CA in response to your request (if the CA reply is a chain), or one constructed (if the CA reply is a single certificate) using the certificate reply and trusted certificates that are already available in the keystore where you import the reply or in the "cacerts" keystore file.
 .LP
 .LP
 For example, suppose you sent your certificate signing request to VeriSign. You can then import the reply via the following, which assumes the returned certificate is named "VSMarkJ.cer":
@@ -1120,7 +1122,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Exporting a Certificate Authenticating Your Public Key
 .LP
 .LP
@@ -1141,7 +1143,7 @@
 .LP
 Given that certificate, and the signed JAR file, a client can use the \f3jarsigner\fP tool to authenticate your signature.
 .LP
-.SS
+.SS 
 Importing Keystore
 .LP
 .LP
@@ -1189,7 +1191,7 @@
 .fi
 
 .LP
-.SS
+.SS 
 Generating Certificates for a Typical SSL Server
 .LP
 .LP
@@ -1226,7 +1228,7 @@
 .LP
 .SH "TERMINOLOGY and WARNINGS"
 .LP
-.SS
+.SS 
 KeyStore
 .LP
 .LP
@@ -1235,26 +1237,26 @@
 .RS 3
 .TP 2
 o
-\f3KeyStore Entries\fP
+\f3KeyStore Entries\fP 
 .LP
-Keystores may have different types of entries. The two most applicable entry types for \f3keytool\fP include:
+Keystores may have different types of entries. The two most applicable entry types for \f3keytool\fP include: 
 .RS 3
 .TP 3
 1.
-\f3key entries\fP \- each holds very sensitive cryptographic key information, which is stored in a protected format to prevent unauthorized access. Typically, a key stored in this type of entry is a secret key, or a private key accompanied by the certificate "chain" for the corresponding public key. The \f3keytool\fP can handle both types of entries, while the \f3jarsigner\fP tool only handle the latter type of entry, that is private keys and their associated certificate chains.
+\f3key entries\fP \- each holds very sensitive cryptographic key information, which is stored in a protected format to prevent unauthorized access. Typically, a key stored in this type of entry is a secret key, or a private key accompanied by the certificate "chain" for the corresponding public key. The \f3keytool\fP can handle both types of entries, while the \f3jarsigner\fP tool only handle the latter type of entry, that is private keys and their associated certificate chains. 
 .TP 3
 2.
-\f3trusted certificate entries\fP \- each contains a single public key certificate belonging to another party. It is called a "trusted certificate" because the keystore owner trusts that the public key in the certificate indeed belongs to the identity identified by the "subject" (owner) of the certificate. The issuer of the certificate vouches for this, by signing the certificate.
+\f3trusted certificate entries\fP \- each contains a single public key certificate belonging to another party. It is called a "trusted certificate" because the keystore owner trusts that the public key in the certificate indeed belongs to the identity identified by the "subject" (owner) of the certificate. The issuer of the certificate vouches for this, by signing the certificate. 
 .RE
 .TP 2
 o
-\f3KeyStore Aliases\fP
+\f3KeyStore Aliases\fP 
 .LP
-All keystore entries (key and trusted certificate entries) are accessed via unique \f2aliases\fP.
+All keystore entries (key and trusted certificate entries) are accessed via unique \f2aliases\fP. 
 .LP
-An alias is specified when you add an entity to the keystore using the \-genseckey command to generate a secret key, \-genkeypair command to generate a key pair (public and private key) or the \-importcert command to add a certificate or certificate chain to the list of trusted certificates. Subsequent \f3keytool\fP commands must use this same alias to refer to the entity.
+An alias is specified when you add an entity to the keystore using the \-genseckey command to generate a secret key, \-genkeypair command to generate a key pair (public and private key) or the \-importcert command to add a certificate or certificate chain to the list of trusted certificates. Subsequent \f3keytool\fP commands must use this same alias to refer to the entity. 
 .LP
-For example, suppose you use the alias \f2duke\fP to generate a new public/private key pair and wrap the public key into a self\-signed certificate (see Certificate Chains) via the following command:
+For example, suppose you use the alias \f2duke\fP to generate a new public/private key pair and wrap the public key into a self\-signed certificate (see Certificate Chains) via the following command: 
 .nf
 \f3
 .fl
@@ -1263,7 +1265,7 @@
 \fP
 .fi
 .LP
-This specifies an initial password of "dukekeypasswd" required by subsequent commands to access the private key associated with the alias \f2duke\fP. If you later want to change duke's private key password, you use a command like the following:
+This specifies an initial password of "dukekeypasswd" required by subsequent commands to access the private key associated with the alias \f2duke\fP. If you later want to change duke's private key password, you use a command like the following: 
 .nf
 \f3
 .fl
@@ -1272,36 +1274,36 @@
 \fP
 .fi
 .LP
-This changes the password from "dukekeypasswd" to "newpass".
+This changes the password from "dukekeypasswd" to "newpass". 
 .LP
-Please note: A password should not actually be specified on a command line or in a script unless it is for testing purposes, or you are on a secure system. If you don't specify a required password option on a command line, you will be prompted for it.
+Please note: A password should not actually be specified on a command line or in a script unless it is for testing purposes, or you are on a secure system. If you don't specify a required password option on a command line, you will be prompted for it.   
 .TP 2
 o
-\f3KeyStore Implementation\fP
+\f3KeyStore Implementation\fP 
 .LP
-The \f2KeyStore\fP class provided in the \f2java.security\fP package supplies well\-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular \f2type\fP of keystore.
+The \f2KeyStore\fP class provided in the \f2java.security\fP package supplies well\-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular \f2type\fP of keystore. 
 .LP
-Currently, two command\-line tools (\f3keytool\fP and \f3jarsigner\fP) and a GUI\-based tool named \f3Policy Tool\fP make use of keystore implementations. Since \f2KeyStore\fP is publicly available, users can write additional security applications that use it.
+Currently, two command\-line tools (\f3keytool\fP and \f3jarsigner\fP) and a GUI\-based tool named \f3Policy Tool\fP make use of keystore implementations. Since \f2KeyStore\fP is publicly available, users can write additional security applications that use it. 
 .LP
-There is a built\-in default implementation, provided by Oracle. It implements the keystore as a file, utilizing a proprietary keystore type (format) named "JKS". It protects each private key with its individual password, and also protects the integrity of the entire keystore with a (possibly different) password.
+There is a built\-in default implementation, provided by Oracle. It implements the keystore as a file, utilizing a proprietary keystore type (format) named "JKS". It protects each private key with its individual password, and also protects the integrity of the entire keystore with a (possibly different) password. 
 .LP
-Keystore implementations are provider\-based. More specifically, the application interfaces supplied by \f2KeyStore\fP are implemented in terms of a "Service Provider Interface" (SPI). That is, there is a corresponding abstract \f2KeystoreSpi\fP class, also in the \f2java.security\fP package, which defines the Service Provider Interface methods that "providers" must implement. (The term "provider" refers to a package or a set of packages that supply a concrete implementation of a subset of services that can be accessed by the Java Security API.) Thus, to provide a keystore implementation, clients must implement a "provider" and supply a KeystoreSpi subclass implementation, as described in
+Keystore implementations are provider\-based. More specifically, the application interfaces supplied by \f2KeyStore\fP are implemented in terms of a "Service Provider Interface" (SPI). That is, there is a corresponding abstract \f2KeystoreSpi\fP class, also in the \f2java.security\fP package, which defines the Service Provider Interface methods that "providers" must implement. (The term "provider" refers to a package or a set of packages that supply a concrete implementation of a subset of services that can be accessed by the Java Security API.) Thus, to provide a keystore implementation, clients must implement a "provider" and supply a KeystoreSpi subclass implementation, as described in 
 .na
 \f2How to Implement a Provider for the Java Cryptography Architecture\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html. 
 .LP
-Applications can choose different \f2types\fP of keystore implementations from different providers, using the "getInstance" factory method supplied in the \f2KeyStore\fP class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private/secret keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible.
+Applications can choose different \f2types\fP of keystore implementations from different providers, using the "getInstance" factory method supplied in the \f2KeyStore\fP class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private/secret keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible. 
 .LP
-\f3keytool\fP works on any file\-based keystore implementation. (It treats the keystore location that is passed to it at the command line as a filename and converts it to a FileInputStream, from which it loads the keystore information.) The \f3jarsigner\fP and \f3policytool\fP tools, on the other hand, can read a keystore from any location that can be specified using a URL.
+\f3keytool\fP works on any file\-based keystore implementation. (It treats the keystore location that is passed to it at the command line as a filename and converts it to a FileInputStream, from which it loads the keystore information.) The \f3jarsigner\fP and \f3policytool\fP tools, on the other hand, can read a keystore from any location that can be specified using a URL. 
 .LP
-For \f3keytool\fP and \f3jarsigner\fP, you can specify a keystore type at the command line, via the \f2\-storetype\fP option. For \f3Policy Tool\fP, you can specify a keystore type via the "Keystore" menu.
+For \f3keytool\fP and \f3jarsigner\fP, you can specify a keystore type at the command line, via the \f2\-storetype\fP option. For \f3Policy Tool\fP, you can specify a keystore type via the "Keystore" menu. 
 .LP
-If you don't explicitly specify a keystore type, the tools choose a keystore implementation based simply on the value of the \f2keystore.type\fP property specified in the security properties file. The security properties file is called \f2java.security\fP, and it resides in the security properties directory, \f2java.home\fP/lib/security, where \f2java.home\fP is the runtime environment's directory (the \f2jre\fP directory in the SDK or the top\-level directory of the Java 2 Runtime Environment).
+If you don't explicitly specify a keystore type, the tools choose a keystore implementation based simply on the value of the \f2keystore.type\fP property specified in the security properties file. The security properties file is called \f2java.security\fP, and it resides in the security properties directory, \f2java.home\fP/lib/security, where \f2java.home\fP is the runtime environment's directory (the \f2jre\fP directory in the SDK or the top\-level directory of the Java 2 Runtime Environment).  
 .LP
-Each tool gets the \f2keystore.type\fP value and then examines all the currently\-installed providers until it finds one that implements keystores of that type. It then uses the keystore implementation from that provider.
+Each tool gets the \f2keystore.type\fP value and then examines all the currently\-installed providers until it finds one that implements keystores of that type. It then uses the keystore implementation from that provider. 
 .LP
-The \f2KeyStore\fP class defines a static method named \f2getDefaultType\fP that lets applications and applets retrieve the value of the \f2keystore.type\fP property. The following line of code creates an instance of the default keystore type (as specified in the \f2keystore.type\fP property):
+The \f2KeyStore\fP class defines a static method named \f2getDefaultType\fP that lets applications and applets retrieve the value of the \f2keystore.type\fP property. The following line of code creates an instance of the default keystore type (as specified in the \f2keystore.type\fP property): 
 .nf
 \f3
 .fl
@@ -1310,7 +1312,7 @@
 \fP
 .fi
 .LP
-The default keystore type is "jks" (the proprietary type of the keystore implementation provided by Oracle). This is specified by the following line in the security properties file:
+The default keystore type is "jks" (the proprietary type of the keystore implementation provided by Oracle). This is specified by the following line in the security properties file: 
 .nf
 \f3
 .fl
@@ -1319,9 +1321,9 @@
 \fP
 .fi
 .LP
-To have the tools utilize a keystore implementation other than the default, you can change that line to specify a different keystore type.
+To have the tools utilize a keystore implementation other than the default, you can change that line to specify a different keystore type. 
 .LP
-For example, if you have a provider package that supplies a keystore implementation for a keystore type called "pkcs12", change the line to
+For example, if you have a provider package that supplies a keystore implementation for a keystore type called "pkcs12", change the line to 
 .nf
 \f3
 .fl
@@ -1330,100 +1332,100 @@
 \fP
 .fi
 .LP
-Note: case doesn't matter in keystore type designations. For example, "JKS" would be considered the same as "jks".
+Note: case doesn't matter in keystore type designations. For example, "JKS" would be considered the same as "jks".  
 .RE
 
 .LP
-.SS
+.SS 
 Certificate
 .LP
-A \f3certificate\fP (also known as a \f3public\-key certificate\fP) is a digitally signed statement from one entity (the \f2issuer\fP), saying that the public key (and some other information) of another entity (the \f2subject\fP) has some specific value.
+A \f3certificate\fP (also known as a \f3public\-key certificate\fP) is a digitally signed statement from one entity (the \f2issuer\fP), saying that the public key (and some other information) of another entity (the \f2subject\fP) has some specific value. 
 .RS 3
 .TP 2
 o
-\f3Certificate Terms\fP
+\f3Certificate Terms\fP 
 .RS 3
 .TP 3
-Public Keys
+Public Keys 
 .LP
-These are numbers associated with a particular entity, and are intended to be known to everyone who needs to have trusted interactions with that entity. Public keys are used to verify signatures.
+These are numbers associated with a particular entity, and are intended to be known to everyone who needs to have trusted interactions with that entity. Public keys are used to verify signatures.  
 .TP 3
-Digitally Signed
+Digitally Signed 
 .LP
-If some data is \f2digitally signed\fP it has been stored with the "identity" of an entity, and a signature that proves that entity knows about the data. The data is rendered unforgeable by signing with the entity's private key.
+If some data is \f2digitally signed\fP it has been stored with the "identity" of an entity, and a signature that proves that entity knows about the data. The data is rendered unforgeable by signing with the entity's private key.  
 .TP 3
-Identity
+Identity 
 .LP
-A known way of addressing an entity. In some systems the identity is the public key, in others it can be anything from a Unix UID to an Email address to an X.509 Distinguished Name.
+A known way of addressing an entity. In some systems the identity is the public key, in others it can be anything from a Unix UID to an Email address to an X.509 Distinguished Name.  
 .TP 3
-Signature
+Signature 
 .LP
-A signature is computed over some data using the private key of an entity (the \f2signer\fP, which in the case of a certificate is also known as the \f2issuer\fP).
+A signature is computed over some data using the private key of an entity (the \f2signer\fP, which in the case of a certificate is also known as the \f2issuer\fP).  
 .TP 3
-Private Keys
+Private Keys 
 .LP
-These are numbers, each of which is supposed to be known only to the particular entity whose private key it is (that is, it's supposed to be kept secret). Private and public keys exist in pairs in all public key cryptography systems (also referred to as "public key crypto systems"). In a typical public key crypto system, such as DSA, a private key corresponds to exactly one public key. Private keys are used to compute signatures.
+These are numbers, each of which is supposed to be known only to the particular entity whose private key it is (that is, it's supposed to be kept secret). Private and public keys exist in pairs in all public key cryptography systems (also referred to as "public key crypto systems"). In a typical public key crypto system, such as DSA, a private key corresponds to exactly one public key. Private keys are used to compute signatures.  
 .TP 3
-Entity
+Entity 
 .LP
-An entity is a person, organization, program, computer, business, bank, or something else you are trusting to some degree.
+An entity is a person, organization, program, computer, business, bank, or something else you are trusting to some degree.  
 .RE
 .LP
-Basically, public key cryptography requires access to users' public keys. In a large\-scale networked environment it is impossible to guarantee that prior relationships between communicating entities have been established or that a trusted repository exists with all used public keys. Certificates were invented as a solution to this public key distribution problem. Now a \f2Certification Authority\fP (CA) can act as a trusted third party. CAs are entities (for example, businesses) that are trusted to sign (issue) certificates for other entities. It is assumed that CAs will only create valid and reliable certificates, as they are bound by legal agreements. There are many public Certification Authorities, such as
+Basically, public key cryptography requires access to users' public keys. In a large\-scale networked environment it is impossible to guarantee that prior relationships between communicating entities have been established or that a trusted repository exists with all used public keys. Certificates were invented as a solution to this public key distribution problem. Now a \f2Certification Authority\fP (CA) can act as a trusted third party. CAs are entities (for example, businesses) that are trusted to sign (issue) certificates for other entities. It is assumed that CAs will only create valid and reliable certificates, as they are bound by legal agreements. There are many public Certification Authorities, such as 
 .na
 \f2VeriSign\fP @
 .fi
-http://www.verisign.com/,
+http://www.verisign.com/, 
 .na
 \f2Thawte\fP @
 .fi
-http://www.thawte.com/,
+http://www.thawte.com/, 
 .na
 \f2Entrust\fP @
 .fi
-http://www.entrust.com/, and so on. You can also run your own Certification Authority using products such as Microsoft Certificate Server or the Entrust CA product for your organization.
+http://www.entrust.com/, and so on. You can also run your own Certification Authority using products such as Microsoft Certificate Server or the Entrust CA product for your organization. 
 .LP
-Using \f3keytool\fP, it is possible to display, import, and export certificates. It is also possible to generate self\-signed certificates.
+Using \f3keytool\fP, it is possible to display, import, and export certificates. It is also possible to generate self\-signed certificates. 
 .LP
-\f3keytool\fP currently handles X.509 certificates.
+\f3keytool\fP currently handles X.509 certificates.  
 .TP 2
 o
-\f3X.509 Certificates\fP
+\f3X.509 Certificates\fP 
 .LP
-The X.509 standard defines what information can go into a certificate, and describes how to write it down (the data format). All the data in a certificate is encoded using two related standards called ASN.1/DER. \f2Abstract Syntax Notation 1\fP describes data. The \f2Definite Encoding Rules\fP describe a single way to store and transfer that data.
+The X.509 standard defines what information can go into a certificate, and describes how to write it down (the data format). All the data in a certificate is encoded using two related standards called ASN.1/DER. \f2Abstract Syntax Notation 1\fP describes data. The \f2Definite Encoding Rules\fP describe a single way to store and transfer that data. 
 .LP
-All X.509 certificates have the following data, in addition to the signature:
+All X.509 certificates have the following data, in addition to the signature: 
 .RS 3
 .TP 3
-Version
+Version 
 .LP
-This identifies which version of the X.509 standard applies to this certificate, which affects what information can be specified in it. Thus far, three versions are defined. \f3keytool\fP can import and export v1, v2, and v3 certificates. It generates v3 certificates.
+This identifies which version of the X.509 standard applies to this certificate, which affects what information can be specified in it. Thus far, three versions are defined. \f3keytool\fP can import and export v1, v2, and v3 certificates. It generates v3 certificates. 
 .LP
-\f2X.509 Version 1\fP has been available since 1988, is widely deployed, and is the most generic.
+\f2X.509 Version 1\fP has been available since 1988, is widely deployed, and is the most generic. 
 .LP
-\f2X.509 Version 2\fP introduced the concept of subject and issuer unique identifiers to handle the possibility of reuse of subject and/or issuer names over time. Most certificate profile documents strongly recommend that names not be reused, and that certificates should not make use of unique identifiers. Version 2 certificates are not widely used.
+\f2X.509 Version 2\fP introduced the concept of subject and issuer unique identifiers to handle the possibility of reuse of subject and/or issuer names over time. Most certificate profile documents strongly recommend that names not be reused, and that certificates should not make use of unique identifiers. Version 2 certificates are not widely used. 
 .LP
-\f2X.509 Version 3\fP is the most recent (1996) and supports the notion of extensions, whereby anyone can define an extension and include it in the certificate. Some common extensions in use today are: \f2KeyUsage\fP (limits the use of the keys to particular purposes such as "signing\-only") and \f2AlternativeNames\fP (allows other identities to also be associated with this public key, e.g. DNS names, Email addresses, IP addresses). Extensions can be marked \f2critical\fP to indicate that the extension should be checked and enforced/used. For example, if a certificate has the KeyUsage extension marked critical and set to "keyCertSign" then if this certificate is presented during SSL communication, it should be rejected, as the certificate extension indicates that the associated private key should only be used for signing certificates and not for SSL use.
+\f2X.509 Version 3\fP is the most recent (1996) and supports the notion of extensions, whereby anyone can define an extension and include it in the certificate. Some common extensions in use today are: \f2KeyUsage\fP (limits the use of the keys to particular purposes such as "signing\-only") and \f2AlternativeNames\fP (allows other identities to also be associated with this public key, e.g. DNS names, Email addresses, IP addresses). Extensions can be marked \f2critical\fP to indicate that the extension should be checked and enforced/used. For example, if a certificate has the KeyUsage extension marked critical and set to "keyCertSign" then if this certificate is presented during SSL communication, it should be rejected, as the certificate extension indicates that the associated private key should only be used for signing certificates and not for SSL use.  
 .TP 3
-Serial Number
+Serial Number 
 .LP
-The entity that created the certificate is responsible for assigning it a serial number to distinguish it from other certificates it issues. This information is used in numerous ways, for example when a certificate is revoked its serial number is placed in a Certificate Revocation List (CRL).
+The entity that created the certificate is responsible for assigning it a serial number to distinguish it from other certificates it issues. This information is used in numerous ways, for example when a certificate is revoked its serial number is placed in a Certificate Revocation List (CRL).  
 .TP 3
-Signature Algorithm Identifier
+Signature Algorithm Identifier 
 .LP
-This identifies the algorithm used by the CA to sign the certificate.
+This identifies the algorithm used by the CA to sign the certificate.  
 .TP 3
-Issuer Name
+Issuer Name 
 .LP
-The X.500 Distinguished Name of the entity that signed the certificate. This is normally a CA. Using this certificate implies trusting the entity that signed this certificate. (Note that in some cases, such as \f2root or top\-level\fP CA certificates, the issuer signs its own certificate.)
+The X.500 Distinguished Name of the entity that signed the certificate. This is normally a CA. Using this certificate implies trusting the entity that signed this certificate. (Note that in some cases, such as \f2root or top\-level\fP CA certificates, the issuer signs its own certificate.)  
 .TP 3
-Validity Period
+Validity Period 
 .LP
-Each certificate is valid only for a limited amount of time. This period is described by a start date and time and an end date and time, and can be as short as a few seconds or almost as long as a century. The validity period chosen depends on a number of factors, such as the strength of the private key used to sign the certificate or the amount one is willing to pay for a certificate. This is the expected period that entities can rely on the public value, if the associated private key has not been compromised.
+Each certificate is valid only for a limited amount of time. This period is described by a start date and time and an end date and time, and can be as short as a few seconds or almost as long as a century. The validity period chosen depends on a number of factors, such as the strength of the private key used to sign the certificate or the amount one is willing to pay for a certificate. This is the expected period that entities can rely on the public value, if the associated private key has not been compromised.  
 .TP 3
-Subject Name
+Subject Name 
 .LP
-The name of the entity whose public key the certificate identifies. This name uses the X.500 standard, so it is intended to be unique across the Internet. This is the X.500 Distinguished Name (DN) of the entity, for example,
+The name of the entity whose public key the certificate identifies. This name uses the X.500 standard, so it is intended to be unique across the Internet. This is the X.500 Distinguished Name (DN) of the entity, for example, 
 .nf
 \f3
 .fl
@@ -1432,36 +1434,36 @@
 \fP
 .fi
 .LP
-(These refer to the subject's Common Name, Organizational Unit, Organization, and Country.)
+(These refer to the subject's Common Name, Organizational Unit, Organization, and Country.)  
 .TP 3
-Subject Public Key Information
+Subject Public Key Information 
 .LP
-This is the public key of the entity being named, together with an algorithm identifier which specifies which public key crypto system this key belongs to and any associated key parameters.
+This is the public key of the entity being named, together with an algorithm identifier which specifies which public key crypto system this key belongs to and any associated key parameters.  
 .RE
 .TP 2
 o
-\f3Certificate Chains\fP
+\f3Certificate Chains\fP 
 .LP
-\f3keytool\fP can create and manage keystore "key" entries that each contain a private key and an associated certificate "chain". The first certificate in the chain contains the public key corresponding to the private key.
+\f3keytool\fP can create and manage keystore "key" entries that each contain a private key and an associated certificate "chain". The first certificate in the chain contains the public key corresponding to the private key. 
 .LP
-When keys are first generated (see the \-genkeypair command), the chain starts off containing a single element, a \f2self\-signed certificate\fP. A self\-signed certificate is one for which the issuer (signer) is the same as the subject (the entity whose public key is being authenticated by the certificate). Whenever the \f2\-genkeypair\fP command is called to generate a new public/private key pair, it also wraps the public key into a self\-signed certificate.
+When keys are first generated (see the \-genkeypair command), the chain starts off containing a single element, a \f2self\-signed certificate\fP. A self\-signed certificate is one for which the issuer (signer) is the same as the subject (the entity whose public key is being authenticated by the certificate). Whenever the \f2\-genkeypair\fP command is called to generate a new public/private key pair, it also wraps the public key into a self\-signed certificate. 
 .LP
-Later, after a Certificate Signing Request (CSR) has been generated (see the \-certreq command) and sent to a Certification Authority (CA), the response from the CA is imported (see \-importcert), and the self\-signed certificate is replaced by a chain of certificates. At the bottom of the chain is the certificate (reply) issued by the CA authenticating the subject's public key. The next certificate in the chain is one that authenticates the \f2CA\fP's public key.
+Later, after a Certificate Signing Request (CSR) has been generated (see the \-certreq command) and sent to a Certification Authority (CA), the response from the CA is imported (see \-importcert), and the self\-signed certificate is replaced by a chain of certificates. At the bottom of the chain is the certificate (reply) issued by the CA authenticating the subject's public key. The next certificate in the chain is one that authenticates the \f2CA\fP's public key. 
 .LP
-In many cases, this is a self\-signed certificate (that is, a certificate from the CA authenticating its own public key) and the last certificate in the chain. In other cases, the CA may return a chain of certificates. In this case, the bottom certificate in the chain is the same (a certificate signed by the CA, authenticating the public key of the key entry), but the second certificate in the chain is a certificate signed by a \f2different\fP CA, authenticating the public key of the CA you sent the CSR to. Then, the next certificate in the chain will be a certificate authenticating the second CA's key, and so on, until a self\-signed "root" certificate is reached. Each certificate in the chain (after the first) thus authenticates the public key of the signer of the previous certificate in the chain.
+In many cases, this is a self\-signed certificate (that is, a certificate from the CA authenticating its own public key) and the last certificate in the chain. In other cases, the CA may return a chain of certificates. In this case, the bottom certificate in the chain is the same (a certificate signed by the CA, authenticating the public key of the key entry), but the second certificate in the chain is a certificate signed by a \f2different\fP CA, authenticating the public key of the CA you sent the CSR to. Then, the next certificate in the chain will be a certificate authenticating the second CA's key, and so on, until a self\-signed "root" certificate is reached. Each certificate in the chain (after the first) thus authenticates the public key of the signer of the previous certificate in the chain. 
 .LP
-Many CAs only return the issued certificate, with no supporting chain, especially when there is a flat hierarchy (no intermediates CAs). In this case, the certificate chain must be established from trusted certificate information already stored in the keystore.
+Many CAs only return the issued certificate, with no supporting chain, especially when there is a flat hierarchy (no intermediates CAs). In this case, the certificate chain must be established from trusted certificate information already stored in the keystore. 
 .LP
-A different reply format (defined by the PKCS#7 standard) also includes the supporting certificate chain, in addition to the issued certificate. Both reply formats can be handled by \f3keytool\fP.
+A different reply format (defined by the PKCS#7 standard) also includes the supporting certificate chain, in addition to the issued certificate. Both reply formats can be handled by \f3keytool\fP. 
 .LP
-The top\-level (root) CA certificate is self\-signed. However, the trust into the root's public key does not come from the root certificate itself (anybody could generate a self\-signed certificate with the distinguished name of say, the VeriSign root CA!), but from other sources like a newspaper. The root CA public key is widely known. The only reason it is stored in a certificate is because this is the format understood by most tools, so the certificate in this case is only used as a "vehicle" to transport the root CA's public key. Before you add the root CA certificate to your keystore, you should view it (using the \f2\-printcert\fP option) and compare the displayed fingerprint with the well\-known fingerprint (obtained from a newspaper, the root CA's Web page, etc.).
+The top\-level (root) CA certificate is self\-signed. However, the trust into the root's public key does not come from the root certificate itself (anybody could generate a self\-signed certificate with the distinguished name of say, the VeriSign root CA!), but from other sources like a newspaper. The root CA public key is widely known. The only reason it is stored in a certificate is because this is the format understood by most tools, so the certificate in this case is only used as a "vehicle" to transport the root CA's public key. Before you add the root CA certificate to your keystore, you should view it (using the \f2\-printcert\fP option) and compare the displayed fingerprint with the well\-known fingerprint (obtained from a newspaper, the root CA's Web page, etc.).   
 .TP 2
 o
-\f3The cacerts Certificates File\fP
+\f3The cacerts Certificates File\fP 
 .LP
-A certificates file named \f3"cacerts"\fP resides in the security properties directory, \f2java.home\fP/lib/security, where \f2java.home\fP is the runtime environment's directory (the \f2jre\fP directory in the SDK or the top\-level directory of the Java 2 Runtime Environment).
+A certificates file named \f3"cacerts"\fP resides in the security properties directory, \f2java.home\fP/lib/security, where \f2java.home\fP is the runtime environment's directory (the \f2jre\fP directory in the SDK or the top\-level directory of the Java 2 Runtime Environment).  
 .LP
-The "cacerts" file represents a system\-wide keystore with CA certificates. System administrators can configure and manage that file using \f3keytool\fP, specifying "jks" as the keystore type. The "cacerts" keystore file ships with a default set of root CA certificates; list them with the following command:
+The "cacerts" file represents a system\-wide keystore with CA certificates. System administrators can configure and manage that file using \f3keytool\fP, specifying "jks" as the keystore type. The "cacerts" keystore file ships with a default set of root CA certificates; list them with the following command: 
 .nf
 \f3
 .fl
@@ -1470,22 +1472,22 @@
 \fP
 .fi
 .LP
-The initial password of the "cacerts" keystore file is "changeit". System administrators should change that password and the default access permission of that file upon installing the SDK.
+The initial password of the "cacerts" keystore file is "changeit". System administrators should change that password and the default access permission of that file upon installing the SDK. 
 .LP
-\f3IMPORTANT: Verify Your \fP\f4cacerts\fP\f3 File\fP: Since you trust the CAs in the \f2cacerts\fP file as entities for signing and issuing certificates to other entities, you must manage the \f2cacerts\fP file carefully. The \f2cacerts\fP file should contain only certificates of the CAs you trust. It is your responsibility to verify the trusted root CA certificates bundled in the \f2cacerts\fP file and make your own trust decisions. To remove an untrusted CA certificate from the \f2cacerts\fP file, use the delete option of the \f2keytool\fP command. You can find the \f2cacerts\fP file in the JRE installation directory. Contact your system administrator if you do not have permission to edit this file.
+\f3IMPORTANT: Verify Your \fP\f4cacerts\fP\f3 File\fP: Since you trust the CAs in the \f2cacerts\fP file as entities for signing and issuing certificates to other entities, you must manage the \f2cacerts\fP file carefully. The \f2cacerts\fP file should contain only certificates of the CAs you trust. It is your responsibility to verify the trusted root CA certificates bundled in the \f2cacerts\fP file and make your own trust decisions. To remove an untrusted CA certificate from the \f2cacerts\fP file, use the delete option of the \f2keytool\fP command. You can find the \f2cacerts\fP file in the JRE installation directory. Contact your system administrator if you do not have permission to edit this file.  
 .TP 2
 o
-\f3The Internet RFC 1421 Certificate Encoding Standard\fP
+\f3The Internet RFC 1421 Certificate Encoding Standard\fP 
 .LP
-Certificates are often stored using the printable encoding format defined by the Internet RFC 1421 standard, instead of their binary encoding. This certificate format, also known as "Base 64 encoding", facilitates exporting certificates to other applications by email or through some other mechanism.
+Certificates are often stored using the printable encoding format defined by the Internet RFC 1421 standard, instead of their binary encoding. This certificate format, also known as "Base 64 encoding", facilitates exporting certificates to other applications by email or through some other mechanism. 
 .LP
-Certificates read by the \f2\-importcert\fP and \f2\-printcert\fP commands can be in either this format or binary encoded.
+Certificates read by the \f2\-importcert\fP and \f2\-printcert\fP commands can be in either this format or binary encoded. 
 .LP
-The \f2\-exportcert\fP command by default outputs a certificate in binary encoding, but will instead output a certificate in the printable encoding format, if the \f2\-rfc\fP option is specified.
+The \f2\-exportcert\fP command by default outputs a certificate in binary encoding, but will instead output a certificate in the printable encoding format, if the \f2\-rfc\fP option is specified. 
 .LP
-The \f2\-list\fP command by default prints the SHA1 fingerprint of a certificate. If the \f2\-v\fP option is specified, the certificate is printed in human\-readable format, while if the \f2\-rfc\fP option is specified, the certificate is output in the printable encoding format.
+The \f2\-list\fP command by default prints the SHA1 fingerprint of a certificate. If the \f2\-v\fP option is specified, the certificate is printed in human\-readable format, while if the \f2\-rfc\fP option is specified, the certificate is output in the printable encoding format. 
 .LP
-In its printable encoding format, the encoded certificate is bounded at the beginning by
+In its printable encoding format, the encoded certificate is bounded at the beginning by 
 .nf
 \f3
 .fl
@@ -1494,7 +1496,7 @@
 \fP
 .fi
 .LP
-and at the end by
+and at the end by 
 .nf
 \f3
 .fl
@@ -1505,7 +1507,7 @@
 .RE
 
 .LP
-.SS
+.SS 
 X.500 Distinguished Names
 .LP
 .LP
@@ -1514,22 +1516,22 @@
 .RS 3
 .TP 2
 o
-\f2commonName\fP \- common name of a person, e.g., "Susan Jones"
+\f2commonName\fP \- common name of a person, e.g., "Susan Jones" 
 .TP 2
 o
-\f2organizationUnit\fP \- small organization (e.g., department or division) name, e.g., "Purchasing"
+\f2organizationUnit\fP \- small organization (e.g., department or division) name, e.g., "Purchasing" 
 .TP 2
 o
-\f2organizationName\fP \- large organization name, e.g., "ABCSystems, Inc."
+\f2organizationName\fP \- large organization name, e.g., "ABCSystems, Inc." 
 .TP 2
 o
-\f2localityName\fP \- locality (city) name, e.g., "Palo Alto"
+\f2localityName\fP \- locality (city) name, e.g., "Palo Alto" 
 .TP 2
 o
-\f2stateName\fP \- state or province name, e.g., "California"
+\f2stateName\fP \- state or province name, e.g., "California" 
 .TP 2
 o
-\f2country\fP \- two\-letter country code, e.g., "CH"
+\f2country\fP \- two\-letter country code, e.g., "CH" 
 .RE
 
 .LP
@@ -1623,7 +1625,7 @@
 .LP
 It is never necessary to specify a distinguished name string on a command line. If it is needed for a command, but not supplied on the command line, the user is prompted for each of the subcomponents. In this case, a comma does not need to be escaped by a "\\".
 .LP
-.SS
+.SS 
 WARNING Regarding Importing Trusted Certificates
 .LP
 .LP
@@ -1665,7 +1667,7 @@
 .LP
 Note: it is not required that you execute a \f2\-printcert\fP command prior to importing a certificate, since before adding a certificate to the list of trusted certificates in the keystore, the \f2\-importcert\fP command prints out the certificate information and prompts you to verify it. You then have the option of aborting the import operation. Note, however, this is only the case if you invoke the \f2\-importcert\fP command without the \f2\-noprompt\fP option. If the \f2\-noprompt\fP option is given, there is no interaction with the user.
 .LP
-.SS
+.SS 
 Warning Regarding Passwords
 .LP
 .LP
@@ -1677,11 +1679,11 @@
 .LP
 If you don't specify a required password option on a command line, you will be prompted for it.
 .LP
-.SS
+.SS 
 Warning Regarding Certificate Conformance
 .LP
 .LP
-The Internet standard
+The Internet standard 
 .na
 \f2RFC 5280\fP @
 .fi
@@ -1692,21 +1694,21 @@
 .RS 3
 .TP 2
 o
-jar(1) tool documentation
+jar(1) tool documentation 
 .TP 2
 o
-jarsigner(1) tool documentation
+jarsigner(1) tool documentation 
 .TP 2
 o
-the
+the 
 .na
 \f4Security\fP @
 .fi
-http://download.oracle.com/javase/tutorial/security/index.html trail of the
+http://docs.oracle.com/javase/tutorial/security/index.html trail of the 
 .na
 \f4Java Tutorial\fP @
 .fi
-http://download.oracle.com/javase/tutorial/ for examples of the use of \f3keytool\fP
+http://docs.oracle.com/javase/tutorial/ for examples of the use of \f3keytool\fP 
 .RE
 
 .LP
@@ -1727,13 +1729,13 @@
 .RS 3
 .TP 2
 o
-\f2\-export\fP, renamed to \f2\-exportcert\fP
+\f2\-export\fP, renamed to \f2\-exportcert\fP 
 .TP 2
 o
-\f2\-genkey\fP, renamed to \f2\-genkeypair\fP
+\f2\-genkey\fP, renamed to \f2\-genkeypair\fP 
 .TP 2
 o
-\f2\-import\fP, renamed to \f2\-importcert\fP
+\f2\-import\fP, renamed to \f2\-importcert\fP 
 .RE
 
 .LP
@@ -1746,20 +1748,20 @@
 .na
 \f2\-keyclone\fP @
 .fi
-http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#keycloneCmd
+http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#keycloneCmd 
 .TP 2
 o
 .na
 \f2\-identitydb\fP @
 .fi
-http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#identitydbCmd
+http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#identitydbCmd 
 .TP 2
 o
 .na
 \f2\-selfcert\fP @
 .fi
-http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#selfcertCmd
+http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#selfcertCmd 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/native2ascii.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/native2ascii.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH native2ascii 1 "10 May 2011"
+.TH native2ascii 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -50,23 +50,23 @@
 .LP
 .RS 3
 .TP 3
-\-reverse
+\-reverse 
 Perform the reverse operation: Convert a file encoded in ISO\-8859\-1 with Unicode escapes to a file in any character encoding supported by the Java runtime environment.
 .br
 .br
 .TP 3
-\-encoding encoding_name
-Specifies the name of the character encoding to be used by the conversion procedure. If this option is not present, the default character encoding (as determined by the \f2java.nio.charset.Charset.defaultCharset\fP method) is used. The \f2encoding_name\fP string must be the name of a character encoding that is supported by the Java runtime environment \- see the
+\-encoding encoding_name 
+Specifies the name of the character encoding to be used by the conversion procedure. If this option is not present, the default character encoding (as determined by the \f2java.nio.charset.Charset.defaultCharset\fP method) is used. The \f2encoding_name\fP string must be the name of a character encoding that is supported by the Java runtime environment \- see the 
 .na
 \f4Supported Encodings\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html document.
+http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html document.
 .br
 .br
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/orbd.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/orbd.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH orbd 1 "10 May 2011"
+.TH orbd 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -29,11 +29,11 @@
 \f3orbd\fP is used to enable clients to transparently locate and invoke persistent objects on servers in the CORBA environment.
 .LP
 .LP
-\f3See also:\fP
+\f3See also:\fP 
 .na
 \f2Naming Service\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html
 .LP
 .SH "SYNOPSIS"
 .LP
@@ -54,10 +54,10 @@
 .RS 3
 .TP 2
 o
-The object reference in the Naming Service remains independent of the server life cycle. For example, the object reference could be published by the server in the Naming Service when it is first installed, and then, independent of how many times the server is started or shutdown, the ORBD will always return the correct object reference to the invoking client.
+The object reference in the Naming Service remains independent of the server life cycle. For example, the object reference could be published by the server in the Naming Service when it is first installed, and then, independent of how many times the server is started or shutdown, the ORBD will always return the correct object reference to the invoking client. 
 .TP 2
 o
-The client needs to lookup the object reference in the Naming Service only once, and can keep re\-using this reference independent of the changes introduced due to server life cycle.
+The client needs to lookup the object reference in the Naming Service only once, and can keep re\-using this reference independent of the changes introduced due to server life cycle. 
 .RE
 
 .LP
@@ -65,79 +65,79 @@
 To access ORBD's Server Manager, the server must be started using servertool(1), which is a command\-line interface for application programmers to register, unregister, startup, and shutdown a persistent server. For more information on the Server Manager, see the section in this document titled \f2Server Manager\fP.
 .LP
 .LP
-When \f2orbd\fP starts up, it also starts a naming service. For more information on the naming service, link to
+When \f2orbd\fP starts up, it also starts a naming service. For more information on the naming service, link to 
 .na
 \f2Naming Service\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html.
 .LP
 .SH "OPTIONS"
 .LP
-.SS
+.SS 
 Required Options
 .LP
 .RS 3
 .TP 3
-\-ORBInitialPort nameserverport
-Specifies the port on which the name server should be started. Once started, \f2orbd\fP will listen for incoming requests on this port. Note that when using Solaris software, you must become root to start a process on a port under 1024. For this reason, we recommend that you use a port number greater than or equal to 1024. (required)
+\-ORBInitialPort nameserverport 
+Specifies the port on which the name server should be started. Once started, \f2orbd\fP will listen for incoming requests on this port. Note that when using Solaris software, you must become root to start a process on a port under 1024. For this reason, we recommend that you use a port number greater than or equal to 1024. (required) 
 .RE
 
 .LP
 .LP
 
 .LP
-.SS
+.SS 
 OTHER OPTIONS
 .LP
 .RS 3
 .TP 3
-\-port port
-Specifies the activation port where ORBD should be started, and where ORBD will be accepting requests for persistent objects. The default value for this port is 1049. This port number is added to the port field of the persistent Interoperable Object References (IOR). (optional)
+\-port port 
+Specifies the activation port where ORBD should be started, and where ORBD will be accepting requests for persistent objects. The default value for this port is 1049. This port number is added to the port field of the persistent Interoperable Object References (IOR). (optional) 
 .RE
 
 .LP
 .RS 3
 .TP 3
-\-defaultdb directory
-Specifies the base where the ORBD persistent storage directory \f2orb.db\fP is created. If this option is not specified, the default value is "./orb.db". (optional)
+\-defaultdb directory 
+Specifies the base where the ORBD persistent storage directory \f2orb.db\fP is created. If this option is not specified, the default value is "./orb.db". (optional) 
 .RE
 
 .LP
 .RS 3
 .TP 3
-\-serverPollingTime milliseconds
-Specifies how often ORBD checks for the health of persistent servers registered via \f2servertool\fP. The default value is 1,000 ms. The value specified for \f2milliseconds\fP must be a valid positive integer. (optional)
+\-serverPollingTime milliseconds 
+Specifies how often ORBD checks for the health of persistent servers registered via \f2servertool\fP. The default value is 1,000 ms. The value specified for \f2milliseconds\fP must be a valid positive integer. (optional) 
 .RE
 
 .LP
 .RS 3
 .TP 3
-\-serverStartupDelay milliseconds
-Specifies how long ORBD waits before sending a location forward exception after a persistent server that is registered via \f2servertool\fP is restarted. The default value is 1,000 ms. The value specified for \f2milliseconds\fP must be a valid positive integer. (optional)
+\-serverStartupDelay milliseconds 
+Specifies how long ORBD waits before sending a location forward exception after a persistent server that is registered via \f2servertool\fP is restarted. The default value is 1,000 ms. The value specified for \f2milliseconds\fP must be a valid positive integer. (optional) 
 .RE
 
 .LP
 .RS 3
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying virtual machine.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying virtual machine. 
 .TP 3
-
+ 
 .RE
 
 .LP
 .SH "Starting and Stopping the Naming Service"
 .LP
 .LP
-A Naming Service is a CORBA service that allows
+A Naming Service is a CORBA service that allows 
 .na
 \f2CORBA objects\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlGlossary.html#CORBA%20object to be named by means of binding a name to an object reference. The
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlGlossary.html#CORBA%20object to be named by means of binding a name to an object reference. The 
 .na
 \f2name binding\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlGlossary.html#name%20binding may be stored in the naming service, and a client may supply the name to obtain the desired object reference.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlGlossary.html#name%20binding may be stored in the naming service, and a client may supply the name to obtain the desired object reference.
 .LP
 .LP
 Prior to running a client or a server, you will start ORBD. ORBD includes a persistent Naming Service and a transient Naming Service, both of which are an implementation of the COS Naming Service.
@@ -146,7 +146,7 @@
 The \f4Persistent\fP\f3 Naming Service\fP provides persistence for naming contexts. This means that this information is persistent across service shutdowns and startups, and is recoverable in the event of a service failure. If ORBD is restarted, the Persistent Naming Service will restore the naming context graph, so that the binding of all clients' and servers' names remains intact (persistent).
 .LP
 .LP
-\
+\ 
 .LP
 .LP
 For backward compatibility, \f2tnameserv\fP, a \f4Transient\fP\f3 Naming Service\fP shipped with older versions of the JDK, is also included in this release of J2SE. A transient naming service retains naming contexts as long as it is running. If there is a service interruption, the naming context graph is lost.
@@ -212,26 +212,26 @@
 To stop the naming service, use the relevant operating system command, such as \f2pkill orbd\fP on Solaris, or \f2Ctrl+C\fP in the DOS window in which \f2orbd\fP is running. Note that names registered with the naming service may disappear when the service is terminated if the naming service is transient. The Java IDL naming service will run until it is explicitly stopped.
 .LP
 .LP
-For more information on the Naming Service included with ORBD, see
+For more information on the Naming Service included with ORBD, see 
 .na
 \f2Naming Service\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html.
 .LP
 .SH "Server Manager"
 .LP
 .LP
 To access ORBD's Server Manager and run a persistent server, the server must be started using servertool(1), which is a command\-line interface for application programmers to register, unregister, startup, and shutdown a persistent server. When a server is started using \f2servertool\fP, it must be started on the same host and port on which \f2orbd\fP is executing. If the server is run on a different port, the information stored in the database for local contexts will be invalid and the service will not work properly.
 .LP
-.SS
+.SS 
 Server Manager: an Example
 .LP
 .LP
-Using the
+Using the 
 .na
 \f2sample tutorial\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlExample.html for our demonstration, you would run the \f2idlj\fP compiler and \f2javac\fP compiler as shown in the tutorial. To run the Server Manager, follow these steps for running the application:
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlExample.html for our demonstration, you would run the \f2idlj\fP compiler and \f2javac\fP compiler as shown in the tutorial. To run the Server Manager, follow these steps for running the application:
 .LP
 .LP
 Start \f2orbd\fP.
@@ -240,12 +240,12 @@
 To start \f2orbd\fP from a UNIX command shell, enter:
 .LP
 .LP
-\
+\ 
 .LP
 .nf
 \f3
 .fl
-  orbd \-ORBInitialPort 1050
+  orbd \-ORBInitialPort 1050 
 .fl
 \fP
 .fi
@@ -314,7 +314,7 @@
 Run the client application from another terminal window or prompt:
 .LP
 .LP
-\
+\ 
 .LP
 .nf
 \f3
@@ -332,10 +332,10 @@
 Specify the name server (\f2orbd\fP) port as done in the previous step, for example, \f2\-ORBInitialPort 1050\fP.
 .LP
 .LP
-\
+\ 
 .LP
 .LP
-\
+\ 
 .LP
 .LP
 When you have finished experimenting with the Server Manager, be sure to shut down or kill the name server (\f2orbd\fP) and \f2servertool\fP.
@@ -354,15 +354,15 @@
 .na
 \f2Naming Service\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html
 .br
 .TP 2
 o
-servertool(1)
+servertool(1) 
 .RE
 
 .LP
 .br
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/pack200.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/pack200.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH pack200 1 "10 May 2011"
+.TH pack200 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -35,14 +35,14 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options.
+options 
+Command\-line options. 
 .TP 3
-output\-file
-Name of the output file.
+output\-file 
+Name of the output file. 
 .TP 3
-JAR\-file
-Name of the input file.
+JAR\-file 
+Name of the input file. 
 .RE
 
 .LP
@@ -54,7 +54,7 @@
 .LP
 The \f2pack200\fP tool uses several options to fine\-tune and set the compression engine.
 .LP
-.SS
+.SS 
 Typical usage:
 .LP
 .LP
@@ -138,17 +138,17 @@
 .LP
 .RS 3
 .TP 3
-true
+true 
 .TP 3
-false
-In either case, the packer will set the deflation hint accordingly in the output archive, and will not transmit the individual deflation hints of archive elements.
+false 
+In either case, the packer will set the deflation hint accordingly in the output archive, and will not transmit the individual deflation hints of archive elements. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-keep
-Preserve deflation hints observed in the input JAR. (This is the default.)
+keep 
+Preserve deflation hints observed in the input JAR. (This is the default.) 
 .RE
 
 .LP
@@ -160,11 +160,11 @@
 .LP
 .RS 3
 .TP 3
-latest
-The packer will attempt to determine the latest modification time, among all the available entries in the original archive, or the latest modification time of all the available entries in that segment. This single value will be transmitted as part of the segment and applied to all the entries in each segment. This can marginally decrease the transmitted size of the archive at the expense of setting all installed files to a single date.
+latest 
+The packer will attempt to determine the latest modification time, among all the available entries in the original archive, or the latest modification time of all the available entries in that segment. This single value will be transmitted as part of the segment and applied to all the entries in each segment. This can marginally decrease the transmitted size of the archive at the expense of setting all installed files to a single date. 
 .TP 3
-keep
-Preserves modification times observed in the input JAR. (This is the default.)
+keep 
+Preserves modification times observed in the input JAR. (This is the default.) 
 .RE
 
 .LP
@@ -182,14 +182,14 @@
 .LP
 .RS 3
 .TP 3
-error
-The \f2pack200\fP operation as a whole will fail with a suitable explanation.
+error 
+The \f2pack200\fP operation as a whole will fail with a suitable explanation. 
 .TP 3
-strip
-The attribute will be dropped. Note: Removing the required VM attributes may cause Class Loader failures.
+strip 
+The attribute will be dropped. Note: Removing the required VM attributes may cause Class Loader failures. 
 .TP 3
-pass
-Upon encountering this attribute, the entire class will be transmitted as though it is a resource.
+pass 
+Upon encountering this attribute, the entire class will be transmitted as though it is a resource. 
 .RE
 
 .LP
@@ -207,16 +207,16 @@
 .LP
 .RS 3
 .TP 3
-some\-layout\-string
-The layout language is defined in the JSR 200 specification.
+some\-layout\-string 
+The layout language is defined in the JSR 200 specification. 
 .LP
-Example: \f2\-\-class\-attribute=SourceFile=RUH\fP
+Example: \f2\-\-class\-attribute=SourceFile=RUH\fP  
 .TP 3
-error
-Upon encountering this attribute, the pack200 operation will fail with a suitable explanation.
+error 
+Upon encountering this attribute, the pack200 operation will fail with a suitable explanation. 
 .TP 3
-strip
-Upon encountering this attribute, the attribute will be removed from the output. Note: removing VM\-required attributes may cause Class Loader failures.
+strip 
+Upon encountering this attribute, the attribute will be removed from the output. Note: removing VM\-required attributes may cause Class Loader failures. 
 .RE
 
 .LP
@@ -304,28 +304,28 @@
 .RS 3
 .TP 2
 o
-unpack200(1)
+unpack200(1) 
 .TP 2
 o
 .na
 \f2Java SE Documentation\fP @
 .fi
-http://download.oracle.com/javase/7/docs/index.html
+http://docs.oracle.com/javase/7/docs/index.html 
 .TP 2
 o
 .na
 \f2Java Deployment Guide \- Pack200\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/deployment/deployment\-guide/pack200.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/deployment/deployment\-guide/pack200.html 
 .TP 2
 o
-jar(1) \- Java Archive Tool
+jar(1) \- Java Archive Tool 
 .TP 2
 o
-jarsigner(1) \- JAR Signer tool
+jarsigner(1) \- JAR Signer tool 
 .TP 2
 o
-\f2attributes(5)\fP man page
+\f2attributes(5)\fP man page 
 .RE
 
 .LP
@@ -337,4 +337,4 @@
 .LP
 The Java SE API Specification provided with the JDK is the superseding authority, in case of discrepancies.
 .LP
-
+ 
--- jdk/src/bsd/doc/man/policytool.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/policytool.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,71 +19,86 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH policytool 1 "10 May 2011"
+.TH policytool 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
 policytool \- PolicyTool Administration GUI Utility
 .LP
-\f3policytool\fP reads and writes a plain text policy file based on user input via the utility GUI.
+\f3policytool\fP reads and writes a plain text policy file based on user input via the utility GUI.   
 .SH "SYNOPSIS"
 .LP
-.RS 3
-.TP 3
-\
-.TP 3
+.LP
 Run the policytool Administrator's utility
+.LP
+.LP
 \f4policytool\fP
-.TP 3
+.LP
+.LP
 Run policytool and load the specified policy file
+.LP
+.LP
 \f4policytool\fP\f2[\-file\ \fP\f2filename\fP\f2]\fP
-.TP 3
-\
-.TP 3
+.LP
+.LP
 where:
+.LP
 .RS 3
 .TP 3
-file
-directs \f2policytool\fP to load a local policy file
+file 
+directs \f2policytool\fP to load a local policy file 
 .TP 3
-filename
-The file name
+filename 
+The file name 
 .RE
+
+.LP
 .SH "DESCRIPTION"
 .LP
-\f3policytool\fP is a GUI that allows users to create and manage policy files. For details, see
+.LP
+\f3policytool\fP is a GUI that allows users to create and manage policy files. For details, see 
 .na
 \f2the Policytool Users Guide\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/PolicyGuide.html.
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyGuide.html. 
+.LP
 .SH "OPTIONS"
+.LP
 .RS 3
 .TP 3
-file
-Loads \f2filename\fP.
+file 
+Loads \f2filename\fP. 
+.RE
+
+.LP
 .SH "SEE ALSO"
+.LP
 .na
 \f2Default Policy Implementation and Syntax\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html
 .br
+
+.LP
 .na
 \f2Policy Tool Users' Guide\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/PolicyGuide.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyGuide.html
 .br
+
+.LP
 .na
 \f2Security Permissions\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/permissions.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/permissions.html
 .br
+
+.LP
 .na
 \f2Security Overview\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html
 .br
-.RE
-.RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/rmic.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/rmic.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH rmic 1 "10 May 2011"
+.TH rmic 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -75,11 +75,11 @@
 .LP
 .RS 3
 .TP 3
-\-bootclasspath path
-Overrides location of bootstrap class files
+\-bootclasspath path 
+Overrides location of bootstrap class files 
 .TP 3
-\-classpath path
-Specifies the path \f3rmic\fP uses to look up classes. This option overrides the default or the CLASSPATH environment variable if it is set. Directories are separated by colons. Thus the general format for \f2path\fP is:
+\-classpath path 
+Specifies the path \f3rmic\fP uses to look up classes. This option overrides the default or the CLASSPATH environment variable if it is set. Directories are separated by colons. Thus the general format for \f2path\fP is: 
 .nf
 \f3
 .fl
@@ -87,7 +87,7 @@
 .fl
 \fP
 .fi
-For example:
+For example: 
 .nf
 \f3
 .fl
@@ -96,8 +96,8 @@
 \fP
 .fi
 .TP 3
-\-d directory
-Specifies the root destination directory for the generated class hierarchy. You can use this option to specify a destination directory for the stub, skeleton, and tie files. For example, the command
+\-d directory 
+Specifies the root destination directory for the generated class hierarchy. You can use this option to specify a destination directory for the stub, skeleton, and tie files. For example, the command 
 .nf
 \f3
 .fl
@@ -107,43 +107,43 @@
 .fi
 would place the stub and skeleton classes derived from \f2MyClass\fP into the directory \f2/java/classes/foo\fP. If the \f2\-d\fP option is not specified, the default behavior is as if \f2"\-d\ ."\fP were specified: the package hierarchy of the target class is created in the current directory, and stub/tie/skeleton files are placed within it. (Note that in some previous versions of \f3rmic\fP, if \f2\-d\fP was not specified, then the package hierarchy was \f2not\fP created, and all of the output files were placed directly in the current directory.)
 .br
-\
+\  
 .TP 3
-\-extdirs path
-Overrides location of installed extensions
+\-extdirs path 
+Overrides location of installed extensions 
 .TP 3
-\-g
-Enables generation of all debugging information, including local variables. By default, only line number information is generated.
+\-g 
+Enables generation of all debugging information, including local variables. By default, only line number information is generated. 
 .TP 3
-\-idl
-Causes \f2rmic\fP to generate OMG IDL for the classes specified and any classes referenced. IDL provides a purely declarative, programming language\-independent way of specifying an object's API. The IDL is used as a specification for methods and data that can be written in and invoked from any language that provides CORBA bindings. This includes Java and C++ among others. See the
+\-idl 
+Causes \f2rmic\fP to generate OMG IDL for the classes specified and any classes referenced. IDL provides a purely declarative, programming language\-independent way of specifying an object's API. The IDL is used as a specification for methods and data that can be written in and invoked from any language that provides CORBA bindings. This includes Java and C++ among others. See the 
 .na
 \f2Java Language to IDL Mapping\fP @
 .fi
 http://www.omg.org/technology/documents/formal/java_language_mapping_to_omg_idl.htm (OMG) document for a complete description.
 .br
 .br
-When the \f2\-idl\fP option is used, other options also include:
+When the \f2\-idl\fP option is used, other options also include: 
 .RS 3
 .TP 3
-\-always or \-alwaysgenerate
-Forces re\-generation even when existing stubs/ties/IDL are newer than the input class.
+\-always or \-alwaysgenerate 
+Forces re\-generation even when existing stubs/ties/IDL are newer than the input class. 
 .TP 3
-\-factory
-Uses factory keyword in generated IDL.
+\-factory 
+Uses factory keyword in generated IDL. 
 .TP 3
-\-idlModule\  fromJavaPackage[.class]\  toIDLModule
-Specifies IDLEntity package mapping. For example:\  \f2\-idlModule foo.bar my::real::idlmod\fP.
+\-idlModule\  fromJavaPackage[.class]\  toIDLModule 
+Specifies IDLEntity package mapping. For example:\  \f2\-idlModule foo.bar my::real::idlmod\fP. 
 .TP 3
-\-idlFile\  fromJavaPackage[.class]\  toIDLFile
-Specifies IDLEntity file mapping. For example:\  \f2\-idlFile test.pkg.X TEST16.idl\fP.\
+\-idlFile\  fromJavaPackage[.class]\  toIDLFile 
+Specifies IDLEntity file mapping. For example:\  \f2\-idlFile test.pkg.X TEST16.idl\fP.\  
 .RE
 .TP 3
-\-iiop
+\-iiop 
 Causes \f2rmic\fP to generate IIOP stub and tie classes, rather than JRMP stub and skeleton classes. A stub class is a local proxy for a remote object and is used by clients to send calls to a server. Each remote interface requires a stub class, which implements that remote interface. A client's reference to a remote object is actually a reference to a stub. Tie classes are used on the server side to process incoming calls, and dispatch the calls to the proper implementation class. Each implementation class requires a tie class.
 .br
 .br
-Invoking \f2rmic\fP with the \f2\-iiop\fP generates stubs and ties that conform to this naming convention:
+Invoking \f2rmic\fP with the \f2\-iiop\fP generates stubs and ties that conform to this naming convention: 
 .nf
 \f3
 .fl
@@ -153,49 +153,49 @@
 .fl
 \fP
 .fi
-When the \f2\-iiop\fP option is used, other options also include:
+When the \f2\-iiop\fP option is used, other options also include: 
 .RS 3
 .TP 3
-\-always or \-alwaysgenerate
-Forces re\-generation even when existing stubs/ties/IDL are newer than the input class.
+\-always or \-alwaysgenerate 
+Forces re\-generation even when existing stubs/ties/IDL are newer than the input class. 
 .TP 3
-\-nolocalstubs
-Do not create stubs optimized for same\-process clients and servers.
+\-nolocalstubs 
+Do not create stubs optimized for same\-process clients and servers. 
 .TP 3
-\-noValueMethods
-Must be used with the \f2\-idl\fP option. Prevents addition of \f2valuetype\fP methods and initializers to emitted IDL. These methods and initializers are optional for \f2valuetype\fPs, and are generated unless the \f2\-noValueMethods\fP option is specified when using the \f2\-idl\fP option.
+\-noValueMethods 
+Must be used with the \f2\-idl\fP option. Prevents addition of \f2valuetype\fP methods and initializers to emitted IDL. These methods and initializers are optional for \f2valuetype\fPs, and are generated unless the \f2\-noValueMethods\fP option is specified when using the \f2\-idl\fP option. 
 .TP 3
-\-poa
-Changes the inheritance from \f2org.omg.CORBA_2_3.portable.ObjectImpl\fP to \f2org.omg.PortableServer.Servant\fP. The \f2PortableServer\fP module for the
+\-poa 
+Changes the inheritance from \f2org.omg.CORBA_2_3.portable.ObjectImpl\fP to \f2org.omg.PortableServer.Servant\fP. The \f2PortableServer\fP module for the 
 .na
 \f2Portable Object Adapter\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/POA.html (POA) defines the native \f2Servant\fP type. In the Java programming language, the \f2Servant\fP type is mapped to the Java \f2org.omg.PortableServer.Servant\fP class. It serves as the base class for all POA servant implementations and provides a number of methods that may be invoked by the application programmer, as well as methods which are invoked by the POA itself and may be overridden by the user to control aspects of servant behavior. Based on the OMG IDL to Java Language Mapping Specification, CORBA V 2.3.1 ptc/00\-01\-08.pdf.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/POA.html (POA) defines the native \f2Servant\fP type. In the Java programming language, the \f2Servant\fP type is mapped to the Java \f2org.omg.PortableServer.Servant\fP class. It serves as the base class for all POA servant implementations and provides a number of methods that may be invoked by the application programmer, as well as methods which are invoked by the POA itself and may be overridden by the user to control aspects of servant behavior. Based on the OMG IDL to Java Language Mapping Specification, CORBA V 2.3.1 ptc/00\-01\-08.pdf. 
 .RE
 .TP 3
-\-J
-Used in conjunction with any \f2java\fP option, it passes the option following the \f2\-J\fP (no spaces between the \-J and the option) on to the \f2java\fP interpreter.
+\-J 
+Used in conjunction with any \f2java\fP option, it passes the option following the \f2\-J\fP (no spaces between the \-J and the option) on to the \f2java\fP interpreter. 
 .TP 3
-\-keep or \-keepgenerated
-Retains the generated \f2.java\fP source files for the stub, skeleton, and/or tie classes and writes them to the same directory as the \f2.class\fP files.
+\-keep or \-keepgenerated 
+Retains the generated \f2.java\fP source files for the stub, skeleton, and/or tie classes and writes them to the same directory as the \f2.class\fP files. 
 .TP 3
-\-nowarn
-Turns off warnings. If used the compiler does not print out any warnings.
+\-nowarn 
+Turns off warnings. If used the compiler does not print out any warnings. 
 .TP 3
-\-nowrite
-Does not write compiled classes to the file system.
+\-nowrite 
+Does not write compiled classes to the file system. 
 .TP 3
-\-vcompat
-Generates stub and skeleton classes compatible with both the 1.1 and 1.2 JRMP stub protocol versions. (This option was the default in releases prior to 5.0.) The generated stub classes will use the 1.1 stub protocol version when loaded in a JDK 1.1 virtual machine and will use the 1.2 stub protocol version when loaded into a 1.2 (or later) virtual machine. The generated skeleton classes will support both 1.1 and 1.2 stub protocol versions. The generated classes are relatively large in order to support both modes of operation.
+\-vcompat 
+Generates stub and skeleton classes compatible with both the 1.1 and 1.2 JRMP stub protocol versions. (This option was the default in releases prior to 5.0.) The generated stub classes will use the 1.1 stub protocol version when loaded in a JDK 1.1 virtual machine and will use the 1.2 stub protocol version when loaded into a 1.2 (or later) virtual machine. The generated skeleton classes will support both 1.1 and 1.2 stub protocol versions. The generated classes are relatively large in order to support both modes of operation. 
 .TP 3
-\-verbose
-Causes the compiler and linker to print out messages about what classes are being compiled and what class files are being loaded.
+\-verbose 
+Causes the compiler and linker to print out messages about what classes are being compiled and what class files are being loaded. 
 .TP 3
-\-v1.1
-Generates stub and skeleton classes for the 1.1 JRMP stub protocol version only. Note that this option is only useful for generating stub classes that are serialization\-compatible with pre\-existing, statically\-deployed stub classes that were generated by the \f3rmic\fP tool from JDK 1.1 and that cannot be upgraded (and dynamic class loading is not being used).
+\-v1.1 
+Generates stub and skeleton classes for the 1.1 JRMP stub protocol version only. Note that this option is only useful for generating stub classes that are serialization\-compatible with pre\-existing, statically\-deployed stub classes that were generated by the \f3rmic\fP tool from JDK 1.1 and that cannot be upgraded (and dynamic class loading is not being used). 
 .TP 3
-\-v1.2
-(default) Generates stub classes for the 1.2 JRMP stub protocol version only. No skeleton classes are generated with this option because skeleton classes are not used with the 1.2 stub protocol version. The generated stub classes will not work if they are loaded into a JDK 1.1 virtual machine.
+\-v1.2 
+(default) Generates stub classes for the 1.2 JRMP stub protocol version only. No skeleton classes are generated with this option because skeleton classes are not used with the 1.2 stub protocol version. The generated stub classes will not work if they are loaded into a JDK 1.1 virtual machine. 
 .RE
 
 .LP
@@ -203,8 +203,8 @@
 .LP
 .RS 3
 .TP 3
-CLASSPATH
-Used to provide the system a path to user\-defined classes. Directories are separated by colons. For example,
+CLASSPATH 
+Used to provide the system a path to user\-defined classes. Directories are separated by colons. For example, 
 .nf
 \f3
 .fl
@@ -218,10 +218,10 @@
 .SH "SEE ALSO"
 .LP
 .LP
-java(1), javac(1),
+java(1), javac(1), 
 .na
 \f2CLASSPATH\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#classpath
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#classpath
 .LP
-
+ 
--- jdk/src/bsd/doc/man/rmid.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/rmid.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH rmid 1 "10 May 2011"
+.TH rmid 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -42,15 +42,15 @@
 .SH "DESCRIPTION"
 .LP
 .LP
-The \f3rmid\fP tool starts the activation system daemon. The activation system daemon must be started before activatable objects can be either registered with the activation system or activated in a VM. See the
+The \f3rmid\fP tool starts the activation system daemon. The activation system daemon must be started before activatable objects can be either registered with the activation system or activated in a VM. See the 
 .na
 \f2Java RMI Specification\fP @
 .fi
-http://download.oracle.com/javase/7/docs/platform/rmi/spec/rmiTOC.html and
+http://docs.oracle.com/javase/7/docs/platform/rmi/spec/rmiTOC.html and 
 .na
 \f2Activation tutorials\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/rmi/activation/overview.html for details on how to write programs that use activatable remote objects.
+http://docs.oracle.com/javase/7/docs/technotes/guides/rmi/activation/overview.html for details on how to write programs that use activatable remote objects.
 .LP
 .LP
 The daemon can be started by executing the \f2rmid\fP command, and specifying a security policy file, as follows:
@@ -73,10 +73,10 @@
 .RS 3
 .TP 2
 o
-starts the Activator and an internal registry on the default port, 1098, and
+starts the Activator and an internal registry on the default port, 1098, and 
 .TP 2
 o
-binds an \f2ActivationSystem\fP to the name \f2java.rmi.activation.ActivationSystem\fP in this internal registry.
+binds an \f2ActivationSystem\fP to the name \f2java.rmi.activation.ActivationSystem\fP in this internal registry. 
 .RE
 
 .LP
@@ -95,11 +95,11 @@
 .LP
 starts the activation system daemon and a registry on the registry's default port, 1099.
 .LP
-.SS
+.SS 
 Starting rmid from inetd/xinetd
 .LP
 .LP
-An alternative to starting \f2rmid\fP from the command line is to configure \f2inetd\fP (Solaris) or \f2xinetd\fP (Bsd) to start \f2rmid\fP on demand.
+An alternative to starting \f2rmid\fP from the command line is to configure \f2inetd\fP (Solaris) or \f2xinetd\fP (Linux or BSD) to start \f2rmid\fP on demand.
 .LP
 .LP
 When \f2rmid\fP starts up, it attempts to obtain an inherited channel (inherited from \f2inetd\fP/\f2xinetd\fP) by invoking the \f2System.inheritedChannel\fP method. If the inherited channel is \f2null\fP or not an instance of \f2java.nio.channels.ServerSocketChannel\fP, then \f2rmid\fP assumes that it was not started by \f2inetd\fP/\f2xinetd\fP, and it starts up as described above.
@@ -110,25 +110,25 @@
 .RS 3
 .TP 2
 o
-Output printed to \f2System.err\fP is redirected to a file. This file is located in the directory specified by the \f2java.io.tmpdir\fP system property (typically \f2/var/tmp\fP or \f2/tmp\fP) with the prefix \f2"rmid\-err"\fP and the suffix \f2"tmp"\fP.
+Output printed to \f2System.err\fP is redirected to a file. This file is located in the directory specified by the \f2java.io.tmpdir\fP system property (typically \f2/var/tmp\fP or \f2/tmp\fP) with the prefix \f2"rmid\-err"\fP and the suffix \f2"tmp"\fP. 
 .TP 2
 o
-The \f2\-port\fP option is disallowed. If this option is specified, \f2rmid\fP will exit with an error message.
+The \f2\-port\fP option is disallowed. If this option is specified, \f2rmid\fP will exit with an error message. 
 .TP 2
 o
-The \f2\-log\fP option is required. If this option is not specified, \f2rmid\fP will exit with an error message.
+The \f2\-log\fP option is required. If this option is not specified, \f2rmid\fP will exit with an error message. 
 .RE
 
 .LP
 .LP
-See the man pages for \f2inetd\fP (Solaris) or \f2xinetd\fP (Bsd) for details on how to configure services to be started on demand.
+See the man pages for \f2inetd\fP (Solaris) or \f2xinetd\fP (Linux or BSD) for details on how to configure services to be started on demand.
 .LP
 .SH "OPTIONS"
 .LP
 .RS 3
 .TP 3
-\-C<someCommandLineOption>
-Specifies an option that is passed as a command\-line argument to each child process (activation group) of \f2rmid\fP when that process is created. For example, you could pass a property to each virtual machine spawned by the activation system daemon:
+\-C<someCommandLineOption> 
+Specifies an option that is passed as a command\-line argument to each child process (activation group) of \f2rmid\fP when that process is created. For example, you could pass a property to each virtual machine spawned by the activation system daemon: 
 .nf
 \f3
 .fl
@@ -136,7 +136,7 @@
 .fl
 \fP
 .fi
-This ability to pass command\-line arguments to child processes can be useful for debugging. For example, the following command:
+This ability to pass command\-line arguments to child processes can be useful for debugging. For example, the following command: 
 .nf
 \f3
 .fl
@@ -144,11 +144,11 @@
 .fl
 \fP
 .fi
-will enable server\-call logging in all child VMs.
+will enable server\-call logging in all child VMs. 
 .LP
 .TP 3
-\-J<someCommandLineOption>
-Specifies an option that is passed to the \f2java\fP interpreter running \f2rmid\fP. For example, to specify that \f2rmid\fP use a policy file named \f2rmid.policy\fP, the \f2\-J\fP option can be used to define the \f2java.security.policy\fP property on \f2rmid\fP's command line, for example:
+\-J<someCommandLineOption> 
+Specifies an option that is passed to the \f2java\fP interpreter running \f2rmid\fP. For example, to specify that \f2rmid\fP use a policy file named \f2rmid.policy\fP, the \f2\-J\fP option can be used to define the \f2java.security.policy\fP property on \f2rmid\fP's command line, for example: 
 .nf
 \f3
 .fl
@@ -157,16 +157,16 @@
 \fP
 .fi
 .TP 3
-\-J\-Dsun.rmi.activation.execPolicy=<policy>
-Specifies the policy that \f2rmid\fP employs to check commands and command\-line options used to launch the VM in which an activation group runs. Please note that this option exists only in Sun's implementation of the Java RMI activation daemon. If this property is not specified on the command line, the result is the same as if \f2\-J\-Dsun.rmi.activation.execPolicy=default\fP were specified. The possible values of \f2<policy>\fP can be \f2default\fP, \f2<policyClassName>\fP, or \f2none\fP:
+\-J\-Dsun.rmi.activation.execPolicy=<policy> 
+Specifies the policy that \f2rmid\fP employs to check commands and command\-line options used to launch the VM in which an activation group runs. Please note that this option exists only in Sun's implementation of the Java RMI activation daemon. If this property is not specified on the command line, the result is the same as if \f2\-J\-Dsun.rmi.activation.execPolicy=default\fP were specified. The possible values of \f2<policy>\fP can be \f2default\fP, \f2<policyClassName>\fP, or \f2none\fP: 
 .RS 3
 .TP 2
 o
-\f3default (or if this property is \fP\f4unspecified\fP\f3)\fP
+\f3default (or if this property is \fP\f4unspecified\fP\f3)\fP 
 .LP
-The default \f2execPolicy\fP allows \f2rmid\fP to execute commands with specific command\-line options only if \f2rmid\fP has been granted permission to execute those commands and options in the security policy file that \f2rmid\fP uses. Only the default activation group implementation can be used with the \f2default\fP execution policy.
+The default \f2execPolicy\fP allows \f2rmid\fP to execute commands with specific command\-line options only if \f2rmid\fP has been granted permission to execute those commands and options in the security policy file that \f2rmid\fP uses. Only the default activation group implementation can be used with the \f2default\fP execution policy. 
 .LP
-\f2rmid\fP launches a VM for an activation group using the information in the group's registered activation group descriptor, an \f2ActivationGroupDesc\fP. The group descriptor specifies an optional \f2ActivationGroupDesc.CommandEnvironment\fP which includes the \f2command\fP to execute to start the activation group as well as any command line \f2options\fP to be added to the command line. By default, \f2rmid\fP uses the \f2java\fP command found in \f2java.home\fP. The group descriptor also contains \f2properties\fP overrides that are added to the command line as options defined as:
+\f2rmid\fP launches a VM for an activation group using the information in the group's registered activation group descriptor, an \f2ActivationGroupDesc\fP. The group descriptor specifies an optional \f2ActivationGroupDesc.CommandEnvironment\fP which includes the \f2command\fP to execute to start the activation group as well as any command line \f2options\fP to be added to the command line. By default, \f2rmid\fP uses the \f2java\fP command found in \f2java.home\fP. The group descriptor also contains \f2properties\fP overrides that are added to the command line as options defined as: 
 .nf
 \f3
 .fl
@@ -175,33 +175,33 @@
 \fP
 .fi
 .LP
-The permission \f2com.sun.rmi.rmid.ExecPermission\fP is used to grant \f2rmid\fP permission to execute a command, specified in the group descriptor's \f2CommandEnvironment\fP to launch an activation group. The permission \f2com.sun.rmi.rmid.ExecOptionPermission\fP is used to allow \f2rmid\fP to use command\-line options, specified as properties overrides in the group descriptor or as options in the \f2CommandEnvironment\fP, when launching the activation group.
+The permission \f2com.sun.rmi.rmid.ExecPermission\fP is used to grant \f2rmid\fP permission to execute a command, specified in the group descriptor's \f2CommandEnvironment\fP to launch an activation group. The permission \f2com.sun.rmi.rmid.ExecOptionPermission\fP is used to allow \f2rmid\fP to use command\-line options, specified as properties overrides in the group descriptor or as options in the \f2CommandEnvironment\fP, when launching the activation group. 
 .LP
-When granting \f2rmid\fP permission to execute various commands and options, the permissions \f2ExecPermission\fP and \f2ExecOptionPermission\fP need to be granted universally (i.e., granted to all code sources).
+When granting \f2rmid\fP permission to execute various commands and options, the permissions \f2ExecPermission\fP and \f2ExecOptionPermission\fP need to be granted universally (i.e., granted to all code sources). 
 .RS 3
 .TP 3
-ExecPermission
-The \f2ExecPermission\fP class represents permission for \f2rmid\fP to execute a specific \f2command\fP to launch an activation group.
+ExecPermission 
+The \f2ExecPermission\fP class represents permission for \f2rmid\fP to execute a specific \f2command\fP to launch an activation group. 
 .LP
 \f3Syntax\fP
 .br
-The \f2name\fP of an \f2ExecPermission\fP is the path name of a command to grant \f2rmid\fP permission to execute. A path name that ends in "/*" indicates all the files contained in that directory (where "/" is the file\-separator character, \f2File.separatorChar\fP). A path name that ends with "/\-" indicates all files and subdirectories contained in that directory (recursively). A path name consisting of the special token "<<ALL FILES>>" matches \f3any\fP file.
+The \f2name\fP of an \f2ExecPermission\fP is the path name of a command to grant \f2rmid\fP permission to execute. A path name that ends in "/*" indicates all the files contained in that directory (where "/" is the file\-separator character, \f2File.separatorChar\fP). A path name that ends with "/\-" indicates all files and subdirectories contained in that directory (recursively). A path name consisting of the special token "<<ALL FILES>>" matches \f3any\fP file. 
 .LP
-\f3Note:\fP A path name consisting of a single "*" indicates all the files in the current directory, while a path name consisting of a single "\-" indicates all the files in the current directory and (recursively) all files and subdirectories contained in the current directory.
+\f3Note:\fP A path name consisting of a single "*" indicates all the files in the current directory, while a path name consisting of a single "\-" indicates all the files in the current directory and (recursively) all files and subdirectories contained in the current directory.  
 .TP 3
-ExecOptionPermission
-The \f2ExecOptionPermission\fP class represents permission for \f2rmid\fP to use a specific command\-line \f2option\fP when launching an activation group. The \f2name\fP of an \f2ExecOptionPermission\fP is the value of a command line option.
+ExecOptionPermission 
+The \f2ExecOptionPermission\fP class represents permission for \f2rmid\fP to use a specific command\-line \f2option\fP when launching an activation group. The \f2name\fP of an \f2ExecOptionPermission\fP is the value of a command line option. 
 .LP
 \f3Syntax\fP
 .br
-Options support a limited wildcard scheme. An asterisk signifies a wildcard match, and it may appear as the option name itself (i.e., it matches any option), or an asterisk may appear at the end of the option name only if the asterisk follows either a "." or "=".
+Options support a limited wildcard scheme. An asterisk signifies a wildcard match, and it may appear as the option name itself (i.e., it matches any option), or an asterisk may appear at the end of the option name only if the asterisk follows either a "." or "=". 
 .LP
-For example: "*" or "\-Dfoo.*" or "\-Da.b.c=*" is valid, "*foo" or "\-Da*b" or "ab*" is not.
+For example: "*" or "\-Dfoo.*" or "\-Da.b.c=*" is valid, "*foo" or "\-Da*b" or "ab*" is not.  
 .TP 3
-Policy file for rmid
-When granting \f2rmid\fP permission to execute various commands and options, the permissions \f2ExecPermission\fP and \f2ExecOptionPermission\fP need to be granted universally (i.e., granted to all code sources). It is safe to grant these permissions universally because only \f2rmid\fP checks these permissions.
+Policy file for rmid 
+When granting \f2rmid\fP permission to execute various commands and options, the permissions \f2ExecPermission\fP and \f2ExecOptionPermission\fP need to be granted universally (i.e., granted to all code sources). It is safe to grant these permissions universally because only \f2rmid\fP checks these permissions. 
 .LP
-An example policy file that grants various execute permissions to \f2rmid\fP is:
+An example policy file that grants various execute permissions to \f2rmid\fP is: 
 .nf
 \f3
 .fl
@@ -239,21 +239,21 @@
 .fl
 \fP
 .fi
-The first permission granted allow \f2rmid\fP to execute the 1.7.0 version of the \f2java\fP command, specified by its explicit path name. Note that by default, the version of the \f2java\fP command found in \f2java.home\fP is used (the same one that \f2rmid\fP uses), and does not need to be specified in the policy file. The second permission allows \f2rmid\fP to execute any command in the directory \f2/files/apps/rmidcmds\fP.
+The first permission granted allow \f2rmid\fP to execute the 1.7.0 version of the \f2java\fP command, specified by its explicit path name. Note that by default, the version of the \f2java\fP command found in \f2java.home\fP is used (the same one that \f2rmid\fP uses), and does not need to be specified in the policy file. The second permission allows \f2rmid\fP to execute any command in the directory \f2/files/apps/rmidcmds\fP. 
 .LP
-The third permission granted, an \f2ExecOptionPermission\fP, allows \f2rmid\fP to launch an activation group that defines the security policy file to be \f2/files/policies/group.policy\fP. The next permission allows the \f2java.security.debug\fP property to be used by an activation group. The last permission allows any property in the \f2sun.rmi\fP property name hierarchy to be used by activation groups.
+The third permission granted, an \f2ExecOptionPermission\fP, allows \f2rmid\fP to launch an activation group that defines the security policy file to be \f2/files/policies/group.policy\fP. The next permission allows the \f2java.security.debug\fP property to be used by an activation group. The last permission allows any property in the \f2sun.rmi\fP property name hierarchy to be used by activation groups. 
 .LP
-To start \f2rmid\fP with a policy file, the \f2java.security.policy\fP property needs to be specified on \f2rmid\fP's command line, for example:
+To start \f2rmid\fP with a policy file, the \f2java.security.policy\fP property needs to be specified on \f2rmid\fP's command line, for example: 
 .LP
-\f2rmid \-J\-Djava.security.policy=rmid.policy\fP
+\f2rmid \-J\-Djava.security.policy=rmid.policy\fP  
 .RE
 .TP 2
 o
-\f4<policyClassName>\fP
+\f4<policyClassName>\fP 
 .LP
-If the default behavior is not flexible enough, an administrator can provide, when starting \f2rmid\fP, the name of a class whose \f2checkExecCommand\fP method is executed in order to check commands to be executed by rmid.
+If the default behavior is not flexible enough, an administrator can provide, when starting \f2rmid\fP, the name of a class whose \f2checkExecCommand\fP method is executed in order to check commands to be executed by rmid. 
 .LP
-The \f2policyClassName\fP specifies a public class with a public, no\-argument constructor and an implementation of the following \f2checkExecCommand\fP method:
+The \f2policyClassName\fP specifies a public class with a public, no\-argument constructor and an implementation of the following \f2checkExecCommand\fP method: 
 .nf
 \f3
 .fl
@@ -265,25 +265,25 @@
 .fl
 \fP
 .fi
-Before launching an activation group, \f2rmid\fP calls the policy's \f2checkExecCommand\fP method, passing it the activation group descriptor and an array containing the complete command to launch the activation group. If the \f2checkExecCommand\fP throws a \f2SecurityException\fP, \f2rmid\fP will not launch the activation group and an \f2ActivationException\fP will be thrown to the caller attempting to activate the object.
+Before launching an activation group, \f2rmid\fP calls the policy's \f2checkExecCommand\fP method, passing it the activation group descriptor and an array containing the complete command to launch the activation group. If the \f2checkExecCommand\fP throws a \f2SecurityException\fP, \f2rmid\fP will not launch the activation group and an \f2ActivationException\fP will be thrown to the caller attempting to activate the object. 
 .TP 2
 o
-\f3none\fP
+\f3none\fP 
 .LP
-If the \f2sun.rmi.activation.execPolicy\fP property value is "none", then \f2rmid\fP will not perform any validation of commands to launch activation groups.
+If the \f2sun.rmi.activation.execPolicy\fP property value is "none", then \f2rmid\fP will not perform any validation of commands to launch activation groups.  
 .RE
 .LP
 .TP 3
-\-log dir
-Specifies the name of the directory the activation system daemon uses to write its database and associated information. The log directory defaults to creating a directory, \f2log\fP, in the directory in which the \f2rmid\fP command was executed.
+\-log dir 
+Specifies the name of the directory the activation system daemon uses to write its database and associated information. The log directory defaults to creating a directory, \f2log\fP, in the directory in which the \f2rmid\fP command was executed. 
 .LP
 .TP 3
-\-port port
-Specifies the port \f2rmid\fP's registry uses. The activation system daemon binds the \f2ActivationSystem\fP, with the name \f2java.rmi.activation.ActivationSystem\fP, in this registry. Thus, the \f2ActivationSystem\fP on the local machine can be obtained using the following \f2Naming.lookup\fP method call:
+\-port port 
+Specifies the port \f2rmid\fP's registry uses. The activation system daemon binds the \f2ActivationSystem\fP, with the name \f2java.rmi.activation.ActivationSystem\fP, in this registry. Thus, the \f2ActivationSystem\fP on the local machine can be obtained using the following \f2Naming.lookup\fP method call: 
 .nf
 \f3
 .fl
-    import java.rmi.*;
+    import java.rmi.*; 
 .fl
     import java.rmi.activation.*;
 .fl
@@ -295,8 +295,8 @@
 .fl
 .fi
 .TP 3
-\-stop
-Stops the current invocation of \f2rmid\fP, for a port specified by the \f2\-port\fP option. If no port is specified, it will stop the \f2rmid\fP running on port 1098.
+\-stop 
+Stops the current invocation of \f2rmid\fP, for a port specified by the \f2\-port\fP option. If no port is specified, it will stop the \f2rmid\fP running on port 1098. 
 .RE
 
 .LP
@@ -304,8 +304,8 @@
 .LP
 .RS 3
 .TP 3
-CLASSPATH
-Used to provide the system a path to user\-defined classes. Directories are separated by colons. For example:
+CLASSPATH 
+Used to provide the system a path to user\-defined classes. Directories are separated by colons. For example: 
 .nf
 \f3
 .fl
@@ -319,10 +319,10 @@
 .SH "SEE ALSO"
 .LP
 .LP
-rmic(1),
+rmic(1), 
 .na
 \f2CLASSPATH\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/tools/index.html#classpath, java(1)
+http://docs.oracle.com/javase/7/docs/technotes/tools/index.html#classpath, java(1)
 .LP
-
+ 
--- jdk/src/bsd/doc/man/rmiregistry.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/rmiregistry.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,14 +19,14 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH rmiregistry 1 "10 May 2011"
+.TH rmiregistry 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
 rmiregistry \- The Java Remote Object Registry
 .LP
 .RS 3
-The \f3rmiregistry\fP command starts a remote object registry on the specified port on the current host.
+The \f3rmiregistry\fP command starts a remote object registry on the specified port on the current host. 
 .RE
 
 .LP
@@ -65,19 +65,19 @@
 .LP
 .RS 3
 .TP 3
-\-J
-Used in conjunction with any \f2java\fP option, it passes the option following the \f2\-J\fP (no spaces between the \-J and the option) on to the \f2java\fP interpreter.
+\-J 
+Used in conjunction with any \f2java\fP option, it passes the option following the \f2\-J\fP (no spaces between the \-J and the option) on to the \f2java\fP interpreter. 
 .RE
 
 .LP
 .SH "SEE ALSO"
 .LP
-java(1),
+java(1), 
 .na
 \f2java.rmi.registry.LocateRegistry\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/rmi/registry/LocateRegistry.html and
+http://docs.oracle.com/javase/7/docs/api/java/rmi/registry/LocateRegistry.html and 
 .na
 \f2java.rmi.Naming\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/rmi/Naming.html
+http://docs.oracle.com/javase/7/docs/api/java/rmi/Naming.html  
--- jdk/src/bsd/doc/man/schemagen.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/schemagen.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH schemagen 1 "10 May 2011"
+.TH schemagen 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -39,7 +39,7 @@
 The current schema generator can process either Java source files or class files.
 .LP
 .LP
-We also provide an Ant task to run the schema generator \- see the instructions for
+We also provide an Ant task to run the schema generator \- see the instructions for 
 .na
 \f2using schemagen with Ant\fP @
 .fi
@@ -59,13 +59,13 @@
 .LP
 If your java sources/classes reference other classes, they must be accessable on your system CLASSPATH environment variable, or they need to be given to the tool by using the \f2\-classpath\fP/\f2\-cp\fP options. Otherwise you will see errors when generating your schema.
 .LP
-.SS
+.SS 
 Command Line Options
 .LP
 .nf
 \f3
 .fl
-Usage: schemagen [\-options ...] <java files>
+Usage: schemagen [\-options ...] <java files> 
 .fl
 
 .fl
@@ -94,7 +94,7 @@
 .SH "Generated Resource Files"
 .LP
 .LP
-The current schema generator simply creates a schema file for each namespace referenced in your Java classes. There is no way to control the name of the generated schema files at this time. For that purpose, use
+The current schema generator simply creates a schema file for each namespace referenced in your Java classes. There is no way to control the name of the generated schema files at this time. For that purpose, use 
 .na
 \f2the schema generator ant task\fP @
 .fi
@@ -110,18 +110,18 @@
 .na
 \f2command\-line instructions\fP @
 .fi
-https://jaxb.dev.java.net/nonav/2.1.3/docs/schemagen.html,
+https://jaxb.dev.java.net/nonav/2.1.3/docs/schemagen.html, 
 .na
 \f2using the SchemaGen Ant task\fP @
 .fi
-https://jaxb.dev.java.net/nonav/2.1.3/docs/schemagenTask.html]
+https://jaxb.dev.java.net/nonav/2.1.3/docs/schemagenTask.html] 
 .TP 2
 o
 .na
 \f2Java Architecture for XML Binding (JAXB)\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/xml/jaxb/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/xml/jaxb/index.html 
 .RE
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/serialver.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/serialver.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH serialver 1 "10 May 2011"
+.TH serialver 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -40,11 +40,11 @@
 .LP
 .RS 3
 .TP 3
-options
-Command\-line options, as specified in this document.
+options 
+Command\-line options, as specified in this document. 
 .TP 3
-classnames
-One or more class names
+classnames 
+One or more class names 
 .RE
 
 .LP
@@ -57,18 +57,18 @@
 .LP
 .RS 3
 .TP 3
-\-classpath <directories and zip/jar files separated by :>
-Set search path for application classes and resources.
+\-classpath <directories and zip/jar files separated by :> 
+Set search path for application classes and resources. 
 .RE
 
 .LP
 .RS 3
 .TP 3
-\-show
-Displays a simple user interface. Enter the full class name and press either the Enter key or the Show button to display the serialVersionUID.
+\-show 
+Displays a simple user interface. Enter the full class name and press either the Enter key or the Show button to display the serialVersionUID. 
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for the java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. 
 .RE
 
 .LP
@@ -92,6 +92,6 @@
 .na
 \f2java.io.ObjectStreamClass\fP @
 .fi
-http://download.oracle.com/javase/7/docs/api/java/io/ObjectStreamClass.html
+http://docs.oracle.com/javase/7/docs/api/java/io/ObjectStreamClass.html
 .LP
-
+ 
--- jdk/src/bsd/doc/man/servertool.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/servertool.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,13 +19,13 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH servertool 1 "10 May 2011"
+.TH servertool 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
 servertool \- The Java(TM) IDL Server Tool
 .LP
-\f3servertool\fP provides a command\-line interface for application programmers to register, unregister, startup, and shutdown a persistent server.
+\f3servertool\fP provides a command\-line interface for application programmers to register, unregister, startup, and shutdown a persistent server. 
 .SH "SYNOPSIS"
 .LP
 .nf
@@ -55,11 +55,11 @@
 .LP
 .RS 3
 .TP 3
-\-ORBInitialHost nameserverhost
-Specifies the host machine on which the name server is running and listening for incoming requests. The \f2nameserverhost\fP defaults to \f2localhost\fP if this option is not specified. If \f2orbd\fP and \f2servertool\fP are running on different machines, you must specify the name or IP address of the host on which \f2orbd\fP is running.
+\-ORBInitialHost nameserverhost 
+Specifies the host machine on which the name server is running and listening for incoming requests. The \f2nameserverhost\fP defaults to \f2localhost\fP if this option is not specified. If \f2orbd\fP and \f2servertool\fP are running on different machines, you must specify the name or IP address of the host on which \f2orbd\fP is running. 
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying virtual machine.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying virtual machine. 
 .RE
 
 .LP
@@ -67,47 +67,47 @@
 .LP
 .RS 3
 .TP 3
-register \-server\ <server\ class\ name> \ \-classpath\ <classpath\ to\ server> [\ \-applicationName\ <application\ name> \-args\ <args\ to\ server> \-vmargs\ <flags\ to\ be\ passed\ to\ Java\ VM> \ ]
-Register a new persistent server with the Object Request Broker Daemon (ORBD). If the server is not already registered, it is registered and activated. This command causes an install method to be invoked in the main class of the server identified by the \f2\-server\fP option. The install method must be \f2public static void install(org.omg.CORBA.ORB)\fP. The install method is optional and enables the developer to provide their own server installation behavior (for example, creating database schema).
+register \-server\ <server\ class\ name> \ \-classpath\ <classpath\ to\ server> [\ \-applicationName\ <application\ name> \-args\ <args\ to\ server> \-vmargs\ <flags\ to\ be\ passed\ to\ Java\ VM> \ ] 
+Register a new persistent server with the Object Request Broker Daemon (ORBD). If the server is not already registered, it is registered and activated. This command causes an install method to be invoked in the main class of the server identified by the \f2\-server\fP option. The install method must be \f2public static void install(org.omg.CORBA.ORB)\fP. The install method is optional and enables the developer to provide their own server installation behavior (for example, creating database schema). 
 .TP 3
-unregister \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name>
-Unregister a server from the ORBD by using either its server id or its application name. This command causes an uninstall method to be invoked in the main class of the server identified by the \f2\-server\fP option. The uninstall method must be \f2public static void uninstall(org.omg.CORBA.ORB)\fP. The uninstall method is optional and enables the developer to provide their own server uninstall behavior (for example, undoing the behavior of the install method).
+unregister \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> 
+Unregister a server from the ORBD by using either its server id or its application name. This command causes an uninstall method to be invoked in the main class of the server identified by the \f2\-server\fP option. The uninstall method must be \f2public static void uninstall(org.omg.CORBA.ORB)\fP. The uninstall method is optional and enables the developer to provide their own server uninstall behavior (for example, undoing the behavior of the install method). 
 .TP 3
-getserverid \-applicationName\ <application\ name>
-Return the server id that corresponds with an application.
+getserverid \-applicationName\ <application\ name> 
+Return the server id that corresponds with an application. 
 .TP 3
-list
-List information about all persistent servers registered with the ORBD.
+list 
+List information about all persistent servers registered with the ORBD. 
 .TP 3
-listappnames
-List the application names for all servers currently registered with the ORBD.
+listappnames 
+List the application names for all servers currently registered with the ORBD. 
 .TP 3
-listactive
-List information about all persistent servers that have been launched by the ORBD and are currently running.
+listactive 
+List information about all persistent servers that have been launched by the ORBD and are currently running. 
 .TP 3
-locate \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> [\-endpointType\ <endpointType>\ ]
-Locate the endpoints (ports) of a specific type for all ORBs created by a registered server. If a server is not already running, it is activated. If an endpoint type is not specified, then the plain/non\-protected endpoint associated with each ORB in a server is returned.
+locate \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> [\-endpointType\ <endpointType>\ ] 
+Locate the endpoints (ports) of a specific type for all ORBs created by a registered server. If a server is not already running, it is activated. If an endpoint type is not specified, then the plain/non\-protected endpoint associated with each ORB in a server is returned. 
 .TP 3
-locateperorb \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> [\-orbid\ <ORB\ name>\ ]
-Locate all the endpoints (ports) registered by a specific ORB of registered server. If a server is not already running, then it is activated. If an \f2orbid\fP is not specified, the default value of "" is assigned to the \f2orbid\fP. If any ORBs are created with an \f2orbid\fP of empty string, all ports registered by it are returned.
+locateperorb \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> [\-orbid\ <ORB\ name>\ ] 
+Locate all the endpoints (ports) registered by a specific ORB of registered server. If a server is not already running, then it is activated. If an \f2orbid\fP is not specified, the default value of "" is assigned to the \f2orbid\fP. If any ORBs are created with an \f2orbid\fP of empty string, all ports registered by it are returned. 
 .TP 3
-orblist \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name>
-Lists the ORBId of the ORBs defined on a server. An ORBId is the string name for the ORB created by the server. If the server is not already running, it is activated.
+orblist \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> 
+Lists the ORBId of the ORBs defined on a server. An ORBId is the string name for the ORB created by the server. If the server is not already running, it is activated. 
 .TP 3
-shutdown \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name>
-Shutdown an active server that is registered with ORBD. During execution of this command, the \f2shutdown()\fP method defined in the class specified by either the \f2\-serverid\fP or \f2\-applicationName\fP parameter is also invoked to shutdown the server process appropriately.
+shutdown \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> 
+Shutdown an active server that is registered with ORBD. During execution of this command, the \f2shutdown()\fP method defined in the class specified by either the \f2\-serverid\fP or \f2\-applicationName\fP parameter is also invoked to shutdown the server process appropriately. 
 .TP 3
-startup \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name>
-Startup or activate a server that is registered with ORBD. If the server is not running, this command launches the server. If the server is already running, an error message is returned to the user.
+startup \-serverid\ <server\ id\ >\ | \-applicationName\ <application\ name> 
+Startup or activate a server that is registered with ORBD. If the server is not running, this command launches the server. If the server is already running, an error message is returned to the user. 
 .TP 3
-help
-List all the commands available to the server through the server tool.
+help 
+List all the commands available to the server through the server tool. 
 .TP 3
-quit
-Exit the server tool.
+quit 
+Exit the server tool. 
 .RE
 
 .LP
 .SH "SEE ALSO"
 .LP
-orbd(1)
+orbd(1)  
--- jdk/src/bsd/doc/man/tnameserv.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/tnameserv.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,18 +19,18 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH tnameserv 1 "10 May 2011"
+.TH tnameserv 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
 Java IDL: Transient Naming Service \- \f2tnameserv\fP
 .LP
 .LP
-This document discusses using the Java IDL Transient Naming Service, \f2tnameserv\fP. Java IDL also includes the Object Request Broker Daemon (ORBD). ORBD is a daemon process containing a Bootstrap Service, a Transient Naming Service, a \f3Persistent\fP Naming Service, and a Server Manager. The Java IDL tutorials all use ORBD, however, you can substitute \f2tnameserv\fP for \f2orbd\fP in any of the examples that use a Transient Naming Service. For documentation on the \f2orbd\fP tool, link to its orbd(1) or the
+This document discusses using the Java IDL Transient Naming Service, \f2tnameserv\fP. Java IDL also includes the Object Request Broker Daemon (ORBD). ORBD is a daemon process containing a Bootstrap Service, a Transient Naming Service, a \f3Persistent\fP Naming Service, and a Server Manager. The Java IDL tutorials all use ORBD, however, you can substitute \f2tnameserv\fP for \f2orbd\fP in any of the examples that use a Transient Naming Service. For documentation on the \f2orbd\fP tool, link to its orbd(1) or the 
 .na
 \f2Java IDL Naming Service Included with ORBD\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html topic.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html topic.
 .LP
 .LP
 Topics in this section include:
@@ -38,19 +38,19 @@
 .RS 3
 .TP 2
 o
-Java\ IDL Transient Naming Service
+Java\ IDL Transient Naming Service 
 .TP 2
 o
-Starting the Java\ IDL Transient Naming Service
+Starting the Java\ IDL Transient Naming Service 
 .TP 2
 o
-Stopping the Java\ IDL Transient Naming Service
+Stopping the Java\ IDL Transient Naming Service 
 .TP 2
 o
-Sample Client: Adding Objects to the Namespace
+Sample Client: Adding Objects to the Namespace 
 .TP 2
 o
-Sample Client: Browsing the Namespace
+Sample Client: Browsing the Namespace 
 .RE
 
 .LP
@@ -109,22 +109,22 @@
 .LP
 Clients of the name server must be made aware of the new port number. Do this by setting the \f2org.omg.CORBA.ORBInitialPort\fP property to the new port number when creating the ORB object.
 .LP
-.SS
+.SS 
 Running the server and client on different hosts
 .LP
 .LP
 In most of the Java IDL and RMI\-IIOP tutorials, the Naming Service, Server, and Client are all running on the development machine. In real world deployment, it is likely that the client and server will run on different host machines than the Naming Service.
 .LP
 .LP
-For the client and server to find the Naming Service, they must be made aware of the port number and host on which the naming service is running. Do this by setting the \f2org.omg.CORBA.ORBInitialPort\fP and \f2org.omg.CORBA.ORBInitialHost\fP properties in the client and server files to the machine name and port number on which the Naming Service is running. An example of this is shown in
+For the client and server to find the Naming Service, they must be made aware of the port number and host on which the naming service is running. Do this by setting the \f2org.omg.CORBA.ORBInitialPort\fP and \f2org.omg.CORBA.ORBInitialHost\fP properties in the client and server files to the machine name and port number on which the Naming Service is running. An example of this is shown in 
 .na
 \f2The Hello World Example Using RMI\-IIOP\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/rmi\-iiop/rmiiiopexample.html. You could also use the command line options \f2\-ORBInitialPort\fP \f2nameserverport#\fP and \f2\-ORBInitialHost\fP \f2nameserverhostname\fP to tell the client and server where to find the Naming Service.
+http://docs.oracle.com/javase/7/docs/technotes/guides/rmi\-iiop/rmiiiopexample.html. You could also use the command line options \f2\-ORBInitialPort\fP \f2nameserverport#\fP and \f2\-ORBInitialHost\fP \f2nameserverhostname\fP to tell the client and server where to find the Naming Service. 
 .na
 \f2Java IDL: Running the Hello World Example on TWO Machines\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/idl/tutorial/jidl2machines.html shows one way of doing this using the command line option.
+http://docs.oracle.com/javase/7/docs/technotes/guides/idl/tutorial/jidl2machines.html shows one way of doing this using the command line option.
 .LP
 .LP
 For example, suppose the Transient Naming Service, \f2tnameserv\fP is running on port 1050 on host \f2nameserverhost\fP. The client is running on host \f2clienthost\fP and the server is running on host \f2serverhost\fP.
@@ -132,7 +132,7 @@
 .RS 3
 .TP 2
 o
-Start \f2tnameserv\fP on the host \f2nameserverhost\fP, as follows:
+Start \f2tnameserv\fP on the host \f2nameserverhost\fP, as follows: 
 .nf
 \f3
 .fl
@@ -144,7 +144,7 @@
 .fi
 .TP 2
 o
-Start the server on the \f2serverhost\fP, as follows:
+Start the server on the \f2serverhost\fP, as follows: 
 .nf
 \f3
 .fl
@@ -154,7 +154,7 @@
 .fi
 .TP 2
 o
-Start the client on the \f2clienthost\fP, as follows:
+Start the client on the \f2clienthost\fP, as follows: 
 .nf
 \f3
 .fl
@@ -165,14 +165,14 @@
 .RE
 
 .LP
-.SS
+.SS 
 The \-J option
 .LP
-This command\-line option is available for use with \f2tnameserve\fP:
+This command\-line option is available for use with \f2tnameserve\fP: 
 .RS 3
 .TP 3
-\-Joption
-Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying virtual machine.
+\-Joption 
+Pass \f2option\fP to the Java virtual machine, where \f2option\fP is one of the options described on the reference page for java(1). For example, \f3\-J\-Xms48m\fP sets the startup memory to 48 megabytes. It is a common convention for \f3\-J\fP to pass options to the underlying virtual machine. 
 .RE
 
 .LP
@@ -189,21 +189,21 @@
 .RS 3
 .TP 2
 o
-\f4Initial Naming Context\fP
+\f4Initial Naming Context\fP 
 .RS 3
 .TP 2
 *
-\f3plans\fP
+\f3plans\fP 
 .TP 2
 *
-\f4Personal\fP
+\f4Personal\fP 
 .RS 3
 .TP 2
 -
-\f3calendar\fP
+\f3calendar\fP 
 .TP 2
 -
-\f3schedule\fP
+\f3schedule\fP 
 .RE
 .RE
 .RE
@@ -237,7 +237,7 @@
 .fi
 
 .LP
-In the above section, Starting the Java IDL Transient Naming Service, the nameserver was started on port 1050. The following code ensures that the client program is aware of this port number.
+In the above section, Starting the Java IDL Transient Naming Service, the nameserver was started on port 1050. The following code ensures that the client program is aware of this port number. 
 .nf
 \f3
 .fl
@@ -253,7 +253,7 @@
 .fi
 
 .LP
-This code obtains the initial naming context and assigns it to \f3ctx\fP. The second line copies \f3ctx\fP into a dummy object reference \f3objref\fP that we'll attach to various names and add into the namespace.
+This code obtains the initial naming context and assigns it to \f3ctx\fP. The second line copies \f3ctx\fP into a dummy object reference \f3objref\fP that we'll attach to various names and add into the namespace. 
 .nf
 \f3
 .fl
@@ -269,7 +269,7 @@
 .fi
 
 .LP
-This code creates a name "plans" of type "text" and binds it to our dummy object reference. "plans" is then added under the initial naming context using \f2rebind\fP. The \f2rebind\fP method allows us to run this program over and over again without getting the exceptions we'd get from using \f2bind\fP.
+This code creates a name "plans" of type "text" and binds it to our dummy object reference. "plans" is then added under the initial naming context using \f2rebind\fP. The \f2rebind\fP method allows us to run this program over and over again without getting the exceptions we'd get from using \f2bind\fP. 
 .nf
 \f3
 .fl
@@ -279,7 +279,7 @@
 .fl
         ctx.rebind(name1, objref);
 .fl
-        System.out.println("plans rebind sucessful!");
+        System.out.println("plans rebind successful!");
 .fl
 
 .fl
@@ -287,7 +287,7 @@
 .fi
 
 .LP
-This code creates a naming context called "Personal" of type "directory". The resulting object reference, \f3ctx2\fP, is bound to the name and added under the initial naming context.
+This code creates a naming context called "Personal" of type "directory". The resulting object reference, \f3ctx2\fP, is bound to the name and added under the initial naming context. 
 .nf
 \f3
 .fl
@@ -305,7 +305,7 @@
 .fi
 
 .LP
-The remainder of the code binds the dummy object reference using the names "schedule" and "calendar" under the "Personal" naming context (\f3ctx2\fP).
+The remainder of the code binds the dummy object reference using the names "schedule" and "calendar" under the "Personal" naming context (\f3ctx2\fP). 
 .nf
 \f3
 .fl
@@ -315,7 +315,7 @@
 .fl
         ctx2.rebind(name3, objref);
 .fl
-        System.out.println("schedule rebind sucessful!");
+        System.out.println("schedule rebind successful!");
 .fl
 
 .fl
@@ -325,7 +325,7 @@
 .fl
         ctx2.rebind(name4, objref);
 .fl
-        System.out.println("calender rebind sucessful!");
+        System.out.println("calender rebind successful!");
 .fl
 
 .fl
@@ -375,7 +375,7 @@
 .fi
 
 .LP
-In the above section, Starting the Java IDL Transient Naming Service, the nameserver was started on port 1050. The following code ensures that the client program is aware of this port number.
+In the above section, Starting the Java IDL Transient Naming Service, the nameserver was started on port 1050. The following code ensures that the client program is aware of this port number. 
 .nf
 \f3
 .fl
@@ -395,7 +395,7 @@
 .fi
 
 .LP
-The following code obtains the intial naming context.
+The following code obtains the initial naming context. 
 .nf
 \f3
 .fl
@@ -409,7 +409,7 @@
 .fi
 
 .LP
-The \f2list\fP method lists the bindings in the naming context. In this case, up to 1000 bindings from the initial naming context will be returned in the BindingListHolder; any remaining bindings are returned in the BindingIteratorHolder.
+The \f2list\fP method lists the bindings in the naming context. In this case, up to 1000 bindings from the initial naming context will be returned in the BindingListHolder; any remaining bindings are returned in the BindingIteratorHolder. 
 .nf
 \f3
 .fl
@@ -425,7 +425,7 @@
 .fi
 
 .LP
-This code gets the array of bindings out of the returned BindingListHolder. If there are no bindings, the program ends.
+This code gets the array of bindings out of the returned BindingListHolder. If there are no bindings, the program ends. 
 .nf
 \f3
 .fl
@@ -439,7 +439,7 @@
 .fi
 
 .LP
-The remainder of the code loops through the bindings and prints the names out.
+The remainder of the code loops through the bindings and prints the names out. 
 .nf
 \f3
 .fl
@@ -491,4 +491,4 @@
 .fi
 
 .LP
-
+ 
--- jdk/src/bsd/doc/man/unpack200.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/unpack200.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH unpack200 1 "10 May 2011"
+.TH unpack200 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -35,11 +35,11 @@
 .LP
 .RS 3
 .TP 3
-input\-file
-Name of the input file, which can be a pack200 gzip file or a pack200 file. The input could also be JAR file produced by pack200(1) with an effort of 0. In this case the contents of the input file will be copied to the output JAR file with the Pack200 marker.
+input\-file 
+Name of the input file, which can be a pack200 gzip file or a pack200 file. The input could also be JAR file produced by pack200(1) with an effort of 0. In this case the contents of the input file will be copied to the output JAR file with the Pack200 marker. 
 .TP 3
-JAR\-file
-Name of the output JAR file.
+JAR\-file 
+Name of the output JAR file. 
 .RE
 
 .LP
@@ -120,28 +120,28 @@
 .RS 3
 .TP 2
 o
-pack200(1)
+pack200(1) 
 .TP 2
 o
 .na
 \f2Java SE Documentation\fP @
 .fi
-http://download.oracle.com/javase/7/docs/index.html
+http://docs.oracle.com/javase/7/docs/index.html 
 .TP 2
 o
 .na
 \f2Java Deployment Guide \- Pack200\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/deployment/deployment\-guide/pack200.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/deployment/deployment\-guide/pack200.html 
 .TP 2
 o
-jar(1) \- Java Archive Tool
+jar(1) \- Java Archive Tool 
 .TP 2
 o
-jarsigner(1) \- JAR Signer tool
+jarsigner(1) \- JAR Signer tool 
 .TP 2
 o
-\f2attributes(5)\fP man page
+\f2attributes(5)\fP man page 
 .RE
 
 .LP
@@ -153,4 +153,4 @@
 .LP
 The Java SE API Specification provided with the JDK is the superseding authority, in case of discrepancies.
 .LP
-
+ 
--- jdk/src/bsd/doc/man/wsgen.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/wsgen.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH wsgen 1 "10 May 2011"
+.TH wsgen 1 "16 Mar 2012"
 .SH "Name"
 wsgen \- Java(TM) API for XML Web Services (JAX\-WS) 2.0
 .LP
@@ -30,7 +30,7 @@
 The \f2wsgen\fP tool generates JAX\-WS portable artifacts used in JAX\-WS web services. The tool reads a web service endpoint implementation class (SEI) and generates all the required artifacts for web service deployment, and invocation
 .SH "Overview"
 .LP
-The \f2wsgen\fP tool generates JAX\-WS portable artifacts used in JAX\-WS web services. The tool reads a web service endpoint class and generates all the required artifacts for web service deployment, and invocation. JAXWS 2.1.1 RI also provides a wsgen ant task, see
+The \f2wsgen\fP tool generates JAX\-WS portable artifacts used in JAX\-WS web services. The tool reads a web service endpoint class and generates all the required artifacts for web service deployment, and invocation. JAXWS 2.1.1 RI also provides a wsgen ant task, see 
 .na
 \f2Wsgen ant task\fP @
 .fi
@@ -40,25 +40,25 @@
 .RS 3
 .TP 2
 o
-\f3Solaris/Bsd\fP
+\f3Solaris/Linux/BSD\fP 
 .RS 3
 .TP 2
 *
-\f2export JAXWS_HOME=/pathto/jaxws\-ri\fP
+\f2export JAXWS_HOME=/pathto/jaxws\-ri\fP 
 .TP 2
 *
-\f2$JAXWS_HOME/bin/wsgen.sh \-help\fP
+\f2$JAXWS_HOME/bin/wsgen.sh \-help\fP 
 .RE
 .TP 2
 o
-\f3Windows\fP
+\f3Windows\fP 
 .RS 3
 .TP 2
 *
-\f2set JAXWS_HOME=c:\\pathto\\jaxws\-ri\fP
+\f2set JAXWS_HOME=c:\\pathto\\jaxws\-ri\fP 
 .TP 2
 *
-\f2%JAXWS_HOME%\\bin\\wsgen.bat \-help\fP
+\f2%JAXWS_HOME%\\bin\\wsgen.bat \-help\fP 
 .RE
 .RE
 
@@ -77,6 +77,7 @@
 The following table lists the \f2wsgen\fP options.
 .br
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -361,13 +362,13 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Option\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-classpath <path>\fP\h'|\n(41u'
@@ -383,7 +384,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-cp <path>\fP\h'|\n(41u'
@@ -399,7 +400,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-d <directory>\fP\h'|\n(41u'
@@ -415,7 +416,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-extension\fP\h'|\n(41u'
@@ -429,17 +430,17 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-help\fP\h'|\n(41u'Display help
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-keep\fP\h'|\n(41u'Keep generated files
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-r <directory>\fP\h'|\n(41u'
@@ -455,7 +456,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-s <directory>\fP\h'|\n(41u'
@@ -471,7 +472,7 @@
 .sp |\n(31u
 .ne \n(g|u+\n(.Vu
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-verbose\fP\h'|\n(41u'
@@ -487,7 +488,7 @@
 .sp |\n(31u
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-version\fP\h'|\n(41u'
@@ -503,7 +504,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-wsdl[:protocol]\fP\h'|\n(41u'
@@ -519,7 +520,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-servicename <name>\fP\h'|\n(41u'
@@ -535,7 +536,7 @@
 .sp |\n(31u
 .ne \n(k|u+\n(.Vu
 .if (\n(k|+\n(#^-1v)>\n(#- .nr #- +(\n(k|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f4\-portname <name>\fP\h'|\n(41u'
@@ -564,6 +565,7 @@
 .rm i+
 .rm j+
 .rm k+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-53
 
 .LP
@@ -571,7 +573,7 @@
 .nf
 \f3
 .fl
-\fP\f3wsgen \-d stock \-cp myclasspath stock.StockService\fP
+\fP\f3wsgen \-d stock \-cp myclasspath stock.StockService\fP 
 .fl
 .fi
 .LP
@@ -579,7 +581,7 @@
 .nf
 \f3
 .fl
-\fP\f3wsgen \-wsdl \-d stock \-cp myclasspath stock.StockService\fP
+\fP\f3wsgen \-wsdl \-d stock \-cp myclasspath stock.StockService\fP 
 .fl
 .fi
 .LP
@@ -587,10 +589,10 @@
 .nf
 \f3
 .fl
-\fP\f3wsgen \-wsdl:Xsoap1.2 \-d stock \-cp myclasspath stock.StockService\fP
+\fP\f3wsgen \-wsdl:Xsoap1.2 \-d stock \-cp myclasspath stock.StockService\fP 
 .fl
 .fi
 .LP
 Will generate a SOAP 1.2 WSDL.
 .LP
-Note that you do not have to generate WSDL at the development time as JAXWS runtime will automatically generate a WSDL for you when you deploy your service.
+Note that you do not have to generate WSDL at the development time as JAXWS runtime will automatically generate a WSDL for you when you deploy your service. 
--- jdk/src/bsd/doc/man/wsimport.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/wsimport.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH wsimport 1 "10 May 2011"
+.TH wsimport 1 "16 Mar 2012"
 .SH "Name"
 wsimport \- Java(TM) API for XML Web Services (JAX\-WS) 2.0
 .LP
@@ -33,22 +33,22 @@
 .RS 3
 .TP 2
 o
-Service Endpoint Interface (SEI)
+Service Endpoint Interface (SEI) 
 .TP 2
 o
-Service
+Service 
 .TP 2
 o
-Exception class mapped from wsdl:fault (if any)
+Exception class mapped from wsdl:fault (if any) 
 .TP 2
 o
-Async Reponse Bean derived from response wsdl:message (if any)
+Async Reponse Bean derived from response wsdl:message (if any) 
 .TP 2
 o
-JAXB generated value types (mapped java classes from schema types)
+JAXB generated value types (mapped java classes from schema types) 
 .RE
 .LP
-These artifacts can be packaged in a WAR file with the WSDL and schema documents along with the endpoint implementation to be deployed. also provides wsimport ant task, see
+These artifacts can be packaged in a WAR file with the WSDL and schema documents along with the endpoint implementation to be deployed. also provides wsimport ant task, see 
 .na
 \f2Wsimport ant task\fP @
 .fi
@@ -60,19 +60,19 @@
 .RS 3
 .TP 2
 o
-\f3Solaris/Bsd\fP
+\f3Solaris/Linux/BSD\fP 
 .RS 3
 .TP 2
 *
-\f2/bin/wsimport.sh \-help\fP
+\f2/bin/wsimport.sh \-help\fP 
 .RE
 .TP 2
 o
-\f3Windows\fP
+\f3Windows\fP 
 .RS 3
 .TP 2
 *
-\f2\\bin\\wsimport.bat \-help\fP
+\f2\\bin\\wsimport.bat \-help\fP 
 .RE
 .RE
 
@@ -88,6 +88,7 @@
 .LP
 The following table lists the \f2wsimport\fP options.
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -431,13 +432,13 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Option\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-d <directory> \fP\h'|\n(41u'
@@ -453,7 +454,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-b <path> \fP\h'|\n(41u'
@@ -469,7 +470,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-B <jaxbOption>\fP\h'|\n(41u'
@@ -485,7 +486,7 @@
 .sp |\n(31u
 .ne \n(d|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-catalog\fP\h'|\n(41u'
@@ -501,7 +502,7 @@
 .sp |\n(31u
 .ne \n(e|u+\n(.Vu
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-extension \fP\h'|\n(41u'
@@ -515,7 +516,7 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-help \fP\h'|\n(41u'Display help
@@ -523,7 +524,7 @@
 .ne \n(g|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
 .if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'
@@ -544,13 +545,13 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-keep \fP\h'|\n(41u'Keep generated files
 .ne \n(h|u+\n(.Vu
 .if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-p \fP\h'|\n(41u'
@@ -566,7 +567,7 @@
 .sp |\n(31u
 .ne \n(i|u+\n(.Vu
 .if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-s <directory> \fP\h'|\n(41u'
@@ -582,7 +583,7 @@
 .sp |\n(31u
 .ne \n(j|u+\n(.Vu
 .if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-verbose \fP\h'|\n(41u'
@@ -598,7 +599,7 @@
 .sp |\n(31u
 .ne \n(k|u+\n(.Vu
 .if (\n(k|+\n(#^-1v)>\n(#- .nr #- +(\n(k|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-version \fP\h'|\n(41u'
@@ -616,7 +617,7 @@
 .ne \n(m|u+\n(.Vu
 .if (\n(l|+\n(#^-1v)>\n(#- .nr #- +(\n(l|+\n(#^-\n(#--1v)
 .if (\n(m|+\n(#^-1v)>\n(#- .nr #- +(\n(m|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'
@@ -639,7 +640,7 @@
 .sp |\n(31u
 .ne \n(n|u+\n(.Vu
 .if (\n(n|+\n(#^-1v)>\n(#- .nr #- +(\n(n|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-target \fP\h'|\n(41u'
@@ -653,7 +654,7 @@
 .mk 32
 .if \n(32>\n(31 .nr 31 \n(32
 .sp |\n(31u
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-quiet \fP\h'|\n(41u'Suppress wsimport output
@@ -675,9 +676,10 @@
 .rm l+
 .rm m+
 .rm n+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-66
 .LP
-Multiple JAX\-WS and JAXB binding files can be specified using \f2\-b\fP option and they can be used to customize various things like package names, bean names, etc. More information on JAX\-WS and JAXB binding files can be found in the
+Multiple JAX\-WS and JAXB binding files can be specified using \f2\-b\fP option and they can be used to customize various things like package names, bean names, etc. More information on JAX\-WS and JAXB binding files can be found in the 
 .na
 \f2customization documentation\fP @
 .fi
@@ -685,6 +687,7 @@
 .LP
 The following table lists \f2wsimport\fP non\-standard options:
 .LP
+.TS
 .if \n+(b.=1 .nr d. \n(.c-\n(c.-1
 .de 35
 .ps \n(.s
@@ -856,13 +859,13 @@
 .ls
 ..
 .ec
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3Option\fP\h'|\n(41u'\f3Description\fP
 .ne \n(a|u+\n(.Vu
 .if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-XadditionalHeaders\fP\h'|\n(41u'
@@ -878,7 +881,7 @@
 .sp |\n(31u
 .ne \n(b|u+\n(.Vu
 .if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-Xauthfile <file>\fP\h'|\n(41u'
@@ -894,7 +897,7 @@
 .sp |\n(31u
 .ne \n(c|u+\n(.Vu
 .if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-Xdebug\fP\h'|\n(41u'
@@ -912,7 +915,7 @@
 .ne \n(e|u+\n(.Vu
 .if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
 .if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\h'|\n(41u'
@@ -935,7 +938,7 @@
 .sp |\n(31u
 .ne \n(f|u+\n(.Vu
 .if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
-.ta \n(80u \n(81u
+.ta \n(80u \n(81u 
 .nr 31 \n(.f
 .nr 35 1m
 \&\h'|\n(40u'\f3\-Xnocompile\fP\h'|\n(41u'
@@ -959,6 +962,7 @@
 .rm d+
 .rm e+
 .rm f+
+.TE
 .if \n-(b.=0 .nr c. \n(.c-\n(d.-26
 
 .LP
@@ -972,4 +976,4 @@
 .LP
 This will generate the Java artifacts and compile them by importing the \f2http://stockquote.example.com/quote?wsdl\fP.
 .br
-
+ 
--- jdk/src/bsd/doc/man/xjc.1	2012-08-10 10:22:51.000000000 -0700
+++ jdk/src/bsd/doc/man/xjc.1	2013-05-05 09:38:28.000000000 -0700
@@ -19,7 +19,7 @@
 ." or visit www.oracle.com if you need additional information or have any
 ." questions.
 ."
-.TH xjc 1 "10 May 2011"
+.TH xjc 1 "16 Mar 2012"
 
 .LP
 .SH "Name"
@@ -35,7 +35,7 @@
 .SH "Launching xjc"
 .LP
 .LP
-The binding compiler can be launched using the appropriate \f2xjc\fP shell script in the \f2bin\fP directory for your platform. We also provide an Ant task to run the binding complier \- see the instructions for
+The binding compiler can be launched using the appropriate \f2xjc\fP shell script in the \f2bin\fP directory for your platform. We also provide an Ant task to run the binding complier \- see the instructions for 
 .na
 \f2using the XJC Ant task\fP @
 .fi
@@ -44,7 +44,7 @@
 .LP
 \f2% xjc \-help\fP
 .LP
-.SS
+.SS 
 Output
 .LP
 .nf
@@ -124,115 +124,115 @@
 .LP
 .RS 3
 .TP 3
-\-nv
-By default, the XJC binding compiler performs strict validation of the source schema before processing it. Use this option to disable strict schema validation. This does not mean that the binding compiler will not perform any validation, it simply means that it will perform less\-strict validation.
+\-nv 
+By default, the XJC binding compiler performs strict validation of the source schema before processing it. Use this option to disable strict schema validation. This does not mean that the binding compiler will not perform any validation, it simply means that it will perform less\-strict validation. 
 .TP 3
-\-extension
-By default, the XJC binding compiler strictly enforces the rules outlined in the Compatibility chapter of the JAXB Specification. Appendix E.2 defines a set of W3C XML Schema features that are not completely supported by JAXB v1.0. In some cases, you may be allowed to use them in the "\-extension" mode enabled by this switch. In the default (strict) mode, you are also limited to using only the binding customizations defined in the specification. By using the "\-extension" switch, you will be allowed to use the JAXB Vendor Extensions
+\-extension 
+By default, the XJC binding compiler strictly enforces the rules outlined in the Compatibility chapter of the JAXB Specification. Appendix E.2 defines a set of W3C XML Schema features that are not completely supported by JAXB v1.0. In some cases, you may be allowed to use them in the "\-extension" mode enabled by this switch. In the default (strict) mode, you are also limited to using only the binding customizations defined in the specification. By using the "\-extension" switch, you will be allowed to use the JAXB Vendor Extensions 
 .TP 3
-\-b <file>
+\-b <file> 
 Specify one or more external binding files to process. (Each binding file must have its own \f2"\-b"\fP switch.) The syntax of the external binding files is extremely flexible. You may have a single binding file that contains customizations for multiple schemas or you can break the customizations into multiple bindings files: \f2xjc schema1.xsd schema2.xsd schema3.xsd \-b bindings123.xjb\fP
 .br
-\f2xjc schema1.xsd schema2.xsd schema3.xsd \-b bindings1.xjb \-b bindings2.xjb \-b bindings3.xjb\fP In addition, the ordering of the schema files and binding files on the command line does not matter.
+\f2xjc schema1.xsd schema2.xsd schema3.xsd \-b bindings1.xjb \-b bindings2.xjb \-b bindings3.xjb\fP In addition, the ordering of the schema files and binding files on the command line does not matter. 
 .TP 3
-\-d <dir>
-By default, the XJC binding compiler will generate the Java content classes in the current directory. Use this option to specify an alternate output directory. The output directory must already exist, the XJC binding compiler will not create it for you.
+\-d <dir> 
+By default, the XJC binding compiler will generate the Java content classes in the current directory. Use this option to specify an alternate output directory. The output directory must already exist, the XJC binding compiler will not create it for you. 
 .TP 3
-\-p <pkg>
-Specifying a target package via this command\-line option overrides any binding customization for package name and the default package name algorithm defined in the specification.
+\-p <pkg> 
+Specifying a target package via this command\-line option overrides any binding customization for package name and the default package name algorithm defined in the specification. 
 .TP 3
-\-httpproxy <proxy>
-Specify the HTTP/HTTPS proxy. The format is [user[:password]@]proxyHost[:proxyPort]. The old \f2\-host\fP and \f2\-port\fP are still supported by the RI for backwards compatibility, but they have been deprecated. Note that the password specified with this option is an argument that is visible to other users who use the \f2top\fP command, for example. For greater security, use \f2\-httpproxyfile\fP, below.
+\-httpproxy <proxy> 
+Specify the HTTP/HTTPS proxy. The format is [user[:password]@]proxyHost[:proxyPort]. The old \f2\-host\fP and \f2\-port\fP are still supported by the RI for backwards compatibility, but they have been deprecated. Note that the password specified with this option is an argument that is visible to other users who use the \f2top\fP command, for example. For greater security, use \f2\-httpproxyfile\fP, below. 
 .TP 3
-\-httpproxyfile <file>
-Specify the HTTP/HTTPS proxy using a file. Same format as above, but the password specified in the file is not visible to other users.
+\-httpproxyfile <file> 
+Specify the HTTP/HTTPS proxy using a file. Same format as above, but the password specified in the file is not visible to other users. 
 .TP 3
-\-classpath <arg>
-Specify where to find client application class files used by the \f2<jxb:javaType>\fP and \f2<xjc:superClass>\fP customizations.
+\-classpath <arg> 
+Specify where to find client application class files used by the \f2<jxb:javaType>\fP and \f2<xjc:superClass>\fP customizations. 
 .TP 3
-\-catalog <file>
-Specify catalog files to resolve external entity references. Supports TR9401, XCatalog, and OASIS XML Catalog format. Please read the XML Entity and URI Resolvers document or the \f2catalog\-resolver\fP sample application.
+\-catalog <file> 
+Specify catalog files to resolve external entity references. Supports TR9401, XCatalog, and OASIS XML Catalog format. Please read the XML Entity and URI Resolvers document or the \f2catalog\-resolver\fP sample application. 
 .TP 3
-\-readOnly
-By default, the XJC binding compiler does not write\-protect the Java source files it generates. Use this option to force the XJC binding compiler to mark the generated Java sources read\-only.
+\-readOnly 
+By default, the XJC binding compiler does not write\-protect the Java source files it generates. Use this option to force the XJC binding compiler to mark the generated Java sources read\-only. 
 .TP 3
-\-npa
-Supress the generation of package level annotations into **/package\-info.java. Using this switch causes the generated code to internalize those annotations into the other generated classes.
+\-npa 
+Supress the generation of package level annotations into **/package\-info.java. Using this switch causes the generated code to internalize those annotations into the other generated classes. 
 .TP 3
-\-no\-header
-Supress the generation of a file header comment that includes some note and timestamp. Using this makes the generated code more diff\-friendly.
+\-no\-header 
+Supress the generation of a file header comment that includes some note and timestamp. Using this makes the generated code more diff\-friendly. 
 .TP 3
-\-target 2.0
-Avoid generating code that relies on any JAXB 2.1 features. This will allow the generated code to run with JAXB 2.0 runtime (such as JavaSE 6.)
+\-target 2.0 
+Avoid generating code that relies on any JAXB 2.1 features. This will allow the generated code to run with JAXB 2.0 runtime (such as JavaSE 6.) 
 .TP 3
-\-xmlschema
-Treat input schemas as W3C XML Schema (default). If you do not specify this switch, your input schemas will be treated as W3C XML Schema.
+\-xmlschema 
+Treat input schemas as W3C XML Schema (default). If you do not specify this switch, your input schemas will be treated as W3C XML Schema. 
 .TP 3
-\-relaxng
-Treat input schemas as RELAX NG (experimental, unsupported). Support for RELAX NG schemas is provided as a JAXB Vendor Extension.
+\-relaxng 
+Treat input schemas as RELAX NG (experimental, unsupported). Support for RELAX NG schemas is provided as a JAXB Vendor Extension. 
 .TP 3
-\-relaxng\-compact
-Treat input schemas as RELAX NG compact syntax(experimental, unsupported). Support for RELAX NG schemas is provided as a JAXB Vendor Extension.
+\-relaxng\-compact 
+Treat input schemas as RELAX NG compact syntax(experimental, unsupported). Support for RELAX NG schemas is provided as a JAXB Vendor Extension. 
 .TP 3
-\-dtd
-Treat input schemas as XML DTD (experimental, unsupported). Support for RELAX NG schemas is provided as a JAXB Vendor Extension.
+\-dtd 
+Treat input schemas as XML DTD (experimental, unsupported). Support for RELAX NG schemas is provided as a JAXB Vendor Extension. 
 .TP 3
-\-wsdl
-Treat input as WSDL and compile schemas inside it (experimental,unsupported).
+\-wsdl 
+Treat input as WSDL and compile schemas inside it (experimental,unsupported). 
 .TP 3
-\-quiet
-Suppress compiler output, such as progress information and warnings.
+\-quiet 
+Suppress compiler output, such as progress information and warnings. 
 .TP 3
-\-verbose
-Be extra verbose, such as printing informational messages or displaying stack traces upon some errors.
+\-verbose 
+Be extra verbose, such as printing informational messages or displaying stack traces upon some errors. 
 .TP 3
-\-help
-Display a brief summary of the compiler switches.
+\-help 
+Display a brief summary of the compiler switches. 
 .TP 3
-\-version
-Display the compiler version information.
+\-version 
+Display the compiler version information. 
 .TP 3
-<schema file/URL/dir>
-Specify one or more schema files to compile. If you specify a directory, then xjc will scan it for all schema files and compile them.
+<schema file/URL/dir> 
+Specify one or more schema files to compile. If you specify a directory, then xjc will scan it for all schema files and compile them. 
 .RE
 
 .LP
-.SS
+.SS 
 Non\-Standard Command Line Options
 .LP
 .RS 3
 .TP 3
-\-Xlocator
-Causes the generated code to expose SAX Locator information about the source XML in the Java bean instances after unmarshalling.
+\-Xlocator 
+Causes the generated code to expose SAX Locator information about the source XML in the Java bean instances after unmarshalling. 
 .TP 3
-\-Xsync\-methods
-Causes all of the generated method signatures to include the \f2synchronized\fP keyword.
+\-Xsync\-methods 
+Causes all of the generated method signatures to include the \f2synchronized\fP keyword. 
 .TP 3
-\-mark\-generated
-Mark the generated code with the annotation \f2@javax.annotation.Generated\fP.
+\-mark\-generated 
+Mark the generated code with the annotation \f2@javax.annotation.Generated\fP. 
 .TP 3
-\-episode <file>
-Generate the specified episode file for separate compilation.
+\-episode <file> 
+Generate the specified episode file for separate compilation. 
 .RE
 
 .LP
-.SS
+.SS 
 Deprecated and Removed Command Line Options
 .LP
 .RS 3
 .TP 3
-\-host & \-port
-These options have been deprecated and replaced with the \f3\-httpproxy\fP option. For backwards compatibility, we will continue to support these options, but they will no longer be documented and may be removed from future releases.
+\-host & \-port 
+These options have been deprecated and replaced with the \f3\-httpproxy\fP option. For backwards compatibility, we will continue to support these options, but they will no longer be documented and may be removed from future releases. 
 .TP 3
-\-use\-runtime
-Since the JAXB 2.0 specification has defined a portable runtime, it is no longer necessary for the JAXB RI to generate **/impl/runtime packages. Therefore, this switch is obsolete and has been removed.
+\-use\-runtime 
+Since the JAXB 2.0 specification has defined a portable runtime, it is no longer necessary for the JAXB RI to generate **/impl/runtime packages. Therefore, this switch is obsolete and has been removed. 
 .TP 3
-\-source
-The \-source compatibility switch was introduced in the first JAXB 2.0 Early Access release. We have decided to remove this switch from future releases of JAXB 2.0. If you need to generate 1.0.x code, please use an installation of the 1.0.x codebase.
+\-source 
+The \-source compatibility switch was introduced in the first JAXB 2.0 Early Access release. We have decided to remove this switch from future releases of JAXB 2.0. If you need to generate 1.0.x code, please use an installation of the 1.0.x codebase. 
 .RE
 
 .LP
-.SS
+.SS 
 Compiler Restrictions
 .LP
 .LP
@@ -244,30 +244,30 @@
 .RS 3
 .TP 2
 o
-To compile multiple schemas at the same time, keep the following precedence rules for the target Java package name in mind:
+To compile multiple schemas at the same time, keep the following precedence rules for the target Java package name in mind: 
 .RS 3
 .TP 3
 1.
-The "\f2\-p\fP" command line option takes the highest precedence.
+The "\f2\-p\fP" command line option takes the highest precedence. 
 .TP 3
 2.
-<\f2jaxb:package\fP> customization
+<\f2jaxb:package\fP> customization 
 .TP 3
 3.
-If \f2targetNamespace\fP is declared, apply \f2targetNamespace\fP \-> Java package name algorithm defined in the specification.
+If \f2targetNamespace\fP is declared, apply \f2targetNamespace\fP \-> Java package name algorithm defined in the specification. 
 .TP 3
 4.
-If no \f2targetNamespace\fP is declared, use a hardcoded package named "generated".
+If no \f2targetNamespace\fP is declared, use a hardcoded package named "generated". 
 .RE
 .TP 2
 o
-It is not legal to have more than one <\f2jaxb:schemaBindings\fP> per namespace, so it is impossible to have two schemas in the same target namespace compiled into different Java packages.
+It is not legal to have more than one <\f2jaxb:schemaBindings\fP> per namespace, so it is impossible to have two schemas in the same target namespace compiled into different Java packages. 
 .TP 2
 o
-All schemas being compiled into the same Java package must be submitted to the XJC binding compiler at the same time \- they cannot be compiled independently and work as expected.
+All schemas being compiled into the same Java package must be submitted to the XJC binding compiler at the same time \- they cannot be compiled independently and work as expected. 
 .TP 2
 o
-Element substitution groups spread across multiple schema files must be compiled at the same time.
+Element substitution groups spread across multiple schema files must be compiled at the same time. 
 .RE
 
 .LP
@@ -280,18 +280,18 @@
 .na
 \f2command\-line instructions\fP @
 .fi
-https://jaxb.dev.java.net/nonav/2.1.3/docs/xjc.html,
+https://jaxb.dev.java.net/nonav/2.1.3/docs/xjc.html, 
 .na
 \f2using the XJC Ant task\fP @
 .fi
-https://jaxb.dev.java.net/nonav/2.1.3/docs/xjcTask.html]
+https://jaxb.dev.java.net/nonav/2.1.3/docs/xjcTask.html] 
 .TP 2
 o
 .na
 \f2Java Architecture for XML Binding (JAXB)\fP @
 .fi
-http://download.oracle.com/javase/7/docs/technotes/guides/xml/jaxb/index.html
+http://docs.oracle.com/javase/7/docs/technotes/guides/xml/jaxb/index.html 
 .RE
 
 .LP
-
+ 
--- jdk/src/macosx/classes/com/apple/laf/AquaPanelUI.java	2012-08-10 10:23:05.000000000 -0700
+++ jdk/src/macosx/classes/com/apple/laf/AquaPanelUI.java	2013-05-05 09:38:28.000000000 -0700
@@ -32,20 +32,10 @@
 import com.apple.laf.AquaUtils.RecyclableSingleton;
 import com.apple.laf.AquaUtils.RecyclableSingletonFromDefaultConstructor;
 
-import java.awt.Graphics;
-
 public class AquaPanelUI extends BasicPanelUI {
     static RecyclableSingleton<AquaPanelUI> instance = new RecyclableSingletonFromDefaultConstructor<AquaPanelUI>(AquaPanelUI.class);
 
     public static ComponentUI createUI(final JComponent c) {
         return instance.get();
     }
-
-    @Override
-    public final void update(final Graphics g, final JComponent c) {
-        if (c.isOpaque()) {
-            AquaUtils.fillRect(g, c);
-        }
-        paint(g, c);
-    }
 }
--- jdk/src/macosx/classes/com/apple/laf/AquaRootPaneUI.java	2012-08-10 10:23:07.000000000 -0700
+++ jdk/src/macosx/classes/com/apple/laf/AquaRootPaneUI.java	2013-05-05 09:38:28.000000000 -0700
@@ -319,12 +319,4 @@
             updateComponentTreeUIActivation(element, active);
         }
     }
-
-    @Override
-    public final void update(final Graphics g, final JComponent c) {
-        if (c.isOpaque()) {
-            AquaUtils.fillRect(g, c);
-        }
-        paint(g, c);
-    }
 }
--- jdk/src/macosx/classes/com/apple/laf/AquaToolBarUI.java	2012-08-10 10:23:07.000000000 -0700
+++ jdk/src/macosx/classes/com/apple/laf/AquaToolBarUI.java	2013-05-05 09:38:28.000000000 -0700
@@ -73,7 +73,9 @@
             g.translate(x, y);
 
             if (c.isOpaque()) {
-                AquaUtils.fillRect(g, c, c.getBackground(), 0, 0, w - 1, h - 1);
+                final Color background = c.getBackground();
+                g.setColor(background);
+                g.fillRect(0, 0, w - 1, h - 1);
             }
 
             final Color oldColor = g.getColor();
@@ -135,12 +137,4 @@
             return true;
         }
     }
-
-    @Override
-    public final void update(final Graphics g, final JComponent c) {
-        if (c.isOpaque()) {
-            AquaUtils.fillRect(g, c);
-        }
-        paint(g, c);
-    }
 }
--- jdk/src/macosx/classes/com/apple/laf/AquaUtils.java	2012-08-10 10:23:08.000000000 -0700
+++ jdk/src/macosx/classes/com/apple/laf/AquaUtils.java	2013-05-05 09:38:28.000000000 -0700
@@ -28,19 +28,18 @@
 import java.awt.*;
 import java.awt.image.*;
 import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Method;
 import java.security.PrivilegedAction;
 import java.util.*;
 
 import javax.swing.*;
 import javax.swing.border.Border;
-import javax.swing.plaf.UIResource;
 
 import sun.awt.AppContext;
 
 import sun.lwawt.macosx.CImage;
 import sun.lwawt.macosx.CImage.Creator;
-import sun.lwawt.macosx.CPlatformWindow;
 import sun.swing.SwingUtilities2;
 
 import com.apple.laf.AquaImageFactory.SlicedImageControl;
@@ -390,51 +389,4 @@
             return false;
         }
     }
-
-    protected static boolean isWindowTextured(final Component c) {
-        if (!(c instanceof JComponent)) {
-            return false;
-        }
-        final JRootPane pane = ((JComponent) c).getRootPane();
-        if (pane == null) {
-            return false;
-        }
-        Object prop = pane.getClientProperty(
-                CPlatformWindow.WINDOW_BRUSH_METAL_LOOK);
-        if (prop != null) {
-            return Boolean.parseBoolean(prop.toString());
-        }
-        prop = pane.getClientProperty(CPlatformWindow.WINDOW_STYLE);
-        return prop != null && "textured".equals(prop);
-    }
-
-    private static Color resetAlpha(final Color color) {
-        return new Color(color.getRed(), color.getGreen(), color.getBlue(), 0);
-    }
-
-    protected static void fillRect(final Graphics g, final Component c) {
-        fillRect(g, c, c.getBackground(), 0, 0, c.getWidth(), c.getHeight());
-    }
-
-    protected static void fillRect(final Graphics g, final Component c,
-                                   final Color color, final int x, final int y,
-                                   final int w, final int h) {
-        if (!(g instanceof Graphics2D)) {
-            return;
-        }
-        final Graphics2D cg = (Graphics2D) g.create();
-        try {
-            if (color instanceof UIResource && isWindowTextured(c)
-                    && color.equals(SystemColor.window)) {
-                cg.setComposite(AlphaComposite.Src);
-                cg.setColor(resetAlpha(color));
-            } else {
-                cg.setColor(color);
-            }
-            cg.fillRect(x, y, w, h);
-        } finally {
-            cg.dispose();
-        }
-    }
 }
-
--- jdk/src/macosx/classes/com/apple/laf/ScreenMenuItem.java	2012-08-10 10:23:09.000000000 -0700
+++ jdk/src/macosx/classes/com/apple/laf/ScreenMenuItem.java	2013-05-05 09:38:28.000000000 -0700
@@ -34,7 +34,7 @@
 
 import sun.lwawt.macosx.CMenuItem;
 
-class ScreenMenuItem extends MenuItem implements ActionListener, ComponentListener, ScreenMenuPropertyHandler {
+final class ScreenMenuItem extends MenuItem implements ActionListener, ComponentListener, ScreenMenuPropertyHandler {
     ScreenMenuPropertyListener fListener;
     JMenuItem fMenuItem;
 
@@ -96,21 +96,34 @@
         fMenuItem.removeComponentListener(this);
     }
 
-    public void setAccelerator(final KeyStroke ks) {
-        if (ks == null) {
-            setShortcut(null);
+    static void syncLabelAndKS(MenuItem menuItem, String label, KeyStroke ks) {
+        final MenuComponentPeer peer = menuItem.getPeer();
+        if (!(peer instanceof CMenuItem)) {
+            //Is it possible?
             return;
         }
-
-        final MenuComponentPeer peer = getPeer();
-        if (peer instanceof CMenuItem) {
-            final CMenuItem ourPeer = (CMenuItem)peer;
-            ourPeer.setLabel(fMenuItem.getText(), ks.getKeyChar(), ks.getKeyCode(), ks.getModifiers());
+        final CMenuItem cmi = (CMenuItem) peer;
+        if (ks == null) {
+            cmi.setLabel(label);
         } else {
-            setShortcut(new MenuShortcut(ks.getKeyCode(), (ks.getModifiers() & InputEvent.SHIFT_MASK) != 0));
+            cmi.setLabel(label, ks.getKeyChar(), ks.getKeyCode(),
+                         ks.getModifiers());
         }
     }
 
+    @Override
+    public synchronized void setLabel(final String label) {
+        syncLabelAndKS(this, label, fMenuItem.getAccelerator());
+    }
+
+    @Override
+    public void setAccelerator(final KeyStroke ks) {
+        // We call CMenuItem.setLabel(..,..,..) directly and does not initialize
+        // shortcut property. So shortcut property should not be used from the
+        // peers code directly or indirectly.
+        syncLabelAndKS(this, fMenuItem.getText(), ks);
+    }
+
     public void actionPerformed(final ActionEvent e) {
         fMenuItem.doClick(0); // This takes care of all the different events
     }
--- jdk/src/macosx/classes/com/apple/laf/ScreenMenuItemCheckbox.java	2012-08-10 10:23:09.000000000 -0700
+++ jdk/src/macosx/classes/com/apple/laf/ScreenMenuItemCheckbox.java	2013-05-05 09:38:28.000000000 -0700
@@ -36,7 +36,7 @@
 
 import sun.lwawt.macosx.*;
 
-class ScreenMenuItemCheckbox extends CheckboxMenuItem implements ActionListener, ComponentListener, ScreenMenuPropertyHandler, ItemListener {
+final class ScreenMenuItemCheckbox extends CheckboxMenuItem implements ActionListener, ComponentListener, ScreenMenuPropertyHandler, ItemListener {
     JMenuItem fMenuItem;
     MenuContainer fParent;
 
@@ -110,19 +110,17 @@
         super.removeNotify();
     }
 
-    public void setAccelerator(final KeyStroke ks) {
-        if (ks == null) {
-            setShortcut(null);
-            return;
-        }
+    @Override
+    public synchronized void setLabel(final String label) {
+        ScreenMenuItem.syncLabelAndKS(this, label, fMenuItem.getAccelerator());
+    }
 
-        final MenuComponentPeer peer = getPeer();
-        if (peer instanceof CMenuItem) {
-            final CMenuItem ourPeer = (CMenuItem)peer;
-            ourPeer.setLabel(fMenuItem.getText(), ks.getKeyChar(), ks.getKeyCode(), ks.getModifiers());
-        } else {
-            setShortcut(new MenuShortcut(ks.getKeyCode(), (ks.getModifiers() & InputEvent.SHIFT_MASK) != 0));
-        }
+    @Override
+    public void setAccelerator(final KeyStroke ks) {
+        // We call CMenuItem.setLabel(..,..,..) directly and does not initialize
+        // shortcut property. So shortcut property should not be used from the
+        // peers code directly or indirectly.
+        ScreenMenuItem.syncLabelAndKS(this, fMenuItem.getText(), ks);
     }
 
     public void actionPerformed(final ActionEvent e) {
--- jdk/src/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java	2013-05-05 09:38:28.000000000 -0700
@@ -31,8 +31,12 @@
 import java.awt.Component;
 import java.awt.Graphics;
 import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
 import java.awt.Image;
 import java.awt.ImageCapabilities;
+import java.awt.Rectangle;
 import java.awt.Transparency;
 import java.awt.color.ColorSpace;
 import java.awt.image.BufferedImage;
@@ -44,6 +48,7 @@
 
 import sun.awt.CGraphicsConfig;
 import sun.awt.CGraphicsDevice;
+import sun.awt.TextureSizeConstraining;
 import sun.awt.image.OffScreenImage;
 import sun.awt.image.SunVolatileImage;
 import sun.awt.image.SurfaceManager;
@@ -65,7 +70,7 @@
 import sun.lwawt.macosx.CPlatformView;
 
 public class CGLGraphicsConfig extends CGraphicsConfig
-    implements OGLGraphicsConfig
+    implements OGLGraphicsConfig, TextureSizeConstraining
 {
     //private static final int kOpenGLSwapInterval = RuntimeOptions.getCurrentOptions().OpenGLSwapInterval;
     private static final int kOpenGLSwapInterval = 0; // TODO
@@ -79,11 +84,14 @@
     private OGLContext context;
     private Object disposerReferent = new Object();
 
+    private final int cachedMaxTextureSize;
+
     public static native int getDefaultPixFmt(int screennum);
     private static native boolean initCGL();
     private static native long getCGLConfigInfo(int screennum, int visualnum,
                                                 int swapInterval);
     private static native int getOGLCapabilities(long configInfo);
+    private static native int _getMaxTextureSize();
 
     static {
         cglAvailable = initCGL();
@@ -103,6 +111,10 @@
         // CGLGraphicsConfigInfo data when this object goes away
         Disposer.addRecord(disposerReferent,
                            new CGLGCDisposerRecord(pConfigInfo));
+
+        // 7200762: Workaround a deadlock by caching the value
+        //          A fix for JDK 8 will remove the workaround
+        this.cachedMaxTextureSize = _getMaxTextureSize();
     }
 
     @Override
@@ -242,6 +254,8 @@
         } finally {
             rq.unlock();
         }
+
+        updateTotalDisplayBounds();
     }
 
     @Override
@@ -478,4 +492,53 @@
     public void removeDeviceEventListener(AccelDeviceEventListener l) {
         AccelDeviceEventNotifier.removeListener(l);
     }
+
+    private static final Rectangle totalDisplayBounds = new Rectangle();
+
+    private static void updateTotalDisplayBounds() {
+        synchronized (totalDisplayBounds) {
+            Rectangle virtualBounds = new Rectangle();
+            for (GraphicsDevice gd : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {
+                for (GraphicsConfiguration gc : gd.getConfigurations()) {
+                    virtualBounds = virtualBounds.union(gc.getBounds());
+                }
+            }
+            totalDisplayBounds.setBounds(virtualBounds);
+        }
+    }
+
+
+    // 7160609: GL still fails to create a square texture of this size,
+    //          so we use this value to cap the total display bounds.
+    private int getMaxTextureSize() {
+        return cachedMaxTextureSize;
+    }
+
+    @Override
+    public int getMaxTextureWidth() {
+        int width;
+
+        synchronized (totalDisplayBounds) {
+            if (totalDisplayBounds.width == 0) {
+                updateTotalDisplayBounds();
+            }
+            width = totalDisplayBounds.width;
+        }
+
+        return Math.min(width, getMaxTextureSize());
+    }
+
+    @Override
+    public int getMaxTextureHeight() {
+        int height;
+
+        synchronized (totalDisplayBounds) {
+            if (totalDisplayBounds.height == 0) {
+                updateTotalDisplayBounds();
+            }
+            height = totalDisplayBounds.height;
+        }
+
+        return Math.min(height, getMaxTextureSize());
+    }
 }
--- jdk/src/macosx/classes/sun/java2d/opengl/CGLLayer.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/java2d/opengl/CGLLayer.java	2013-05-05 09:38:28.000000000 -0700
@@ -68,12 +68,11 @@
     }
 
     public boolean isOpaque() {
-        return !peer.isTranslucent();
+        return peer.isOpaque();
     }
 
     public int getTransparency() {
-        return peer.isTranslucent() ? Transparency.TRANSLUCENT :
-               Transparency.OPAQUE;
+        return (peer.isOpaque() ? Transparency.OPAQUE : Transparency.TRANSLUCENT);
     }
 
     public Object getDestination() {
--- jdk/src/macosx/classes/sun/lwawt/LWComponentPeer.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/LWComponentPeer.java	2013-05-05 09:38:28.000000000 -0700
@@ -424,7 +424,8 @@
 
     @Override
     public final Graphics getGraphics() {
-        final Graphics g = getOnscreenGraphics();
+        Graphics g = getWindowPeerOrSelf().isOpaque() ? getOnscreenGraphics()
+                                                      : getOffscreenGraphics();
         if (g != null) {
             synchronized (getPeerTreeLock()){
                 applyConstrain(g);
@@ -442,7 +443,13 @@
         final LWWindowPeer wp = getWindowPeerOrSelf();
         return wp.getOnscreenGraphics(getForeground(), getBackground(),
                                       getFont());
+    }
+
+    public final Graphics getOffscreenGraphics() {
+        final LWWindowPeer wp = getWindowPeerOrSelf();
 
+        return wp.getOffscreenGraphics(getForeground(), getBackground(),
+                                       getFont());
     }
 
     private void applyConstrain(final Graphics g) {
@@ -456,7 +463,7 @@
     }
 
     //TODO Move this method to SG2D?
-    void SG2DConstraint(final SunGraphics2D sg2d, Region r) {
+    private void SG2DConstraint(final SunGraphics2D sg2d, Region r) {
         sg2d.constrainX = sg2d.transX;
         sg2d.constrainY = sg2d.transY;
 
@@ -703,7 +710,7 @@
         // Obtain the metrics from the offscreen window where this peer is
         // mostly drawn to.
         // TODO: check for "use platform metrics" settings
-        Graphics g = getWindowPeer().getGraphics();
+        Graphics g = getWindowPeer().getOffscreenGraphics();
         try {
             if (g != null) {
                 return g.getFontMetrics(f);
@@ -1004,33 +1011,14 @@
     @Override
     public final void applyShape(final Region shape) {
         synchronized (getStateLock()) {
-            if (region == shape || (region != null && region.equals(shape))) {
-                return;
-            }
-        }
-        applyShapeImpl(shape);
-    }
-
-    void applyShapeImpl(final Region shape) {
-        synchronized (getStateLock()) {
-            if (shape != null) {
-                region = Region.WHOLE_REGION.getIntersection(shape);
-            } else {
-                region = null;
-            }
+            region = shape;
         }
         repaintParent(getBounds());
     }
 
     protected final Region getRegion() {
         synchronized (getStateLock()) {
-            return isShaped() ? region : Region.getInstance(getSize());
-        }
-    }
-
-    public boolean isShaped() {
-        synchronized (getStateLock()) {
-            return region != null;
+            return region == null ? Region.getInstance(getSize()) : region;
         }
     }
 
@@ -1398,6 +1386,11 @@
         }
     }
 
+    // Just a helper method, thus final
+    protected final void flushOffscreenGraphics() {
+        flushOffscreenGraphics(getSize());
+    }
+
     protected static final void flushOnscreenGraphics(){
         final OGLRenderQueue rq = OGLRenderQueue.getInstance();
         rq.lock();
@@ -1408,6 +1401,36 @@
         }
     }
 
+    /*
+     * Flushes the given rectangle from the back buffer to the screen.
+     */
+    protected void flushOffscreenGraphics(Rectangle r) {
+        flushOffscreenGraphics(r.x, r.y, r.width, r.height);
+    }
+
+    private void flushOffscreenGraphics(int x, int y, int width, int height) {
+        Image bb = getWindowPeerOrSelf().getBackBuffer();
+        if (bb != null) {
+            // g is a screen Graphics from the delegate
+            final Graphics g = getOnscreenGraphics();
+
+            if (g != null && g instanceof Graphics2D) {
+                try {
+                    Graphics2D g2d = (Graphics2D)g;
+                    Point p = localToWindow(new Point(0, 0));
+                    Composite composite = g2d.getComposite();
+                    g2d.setComposite(AlphaComposite.Src);
+                    g.drawImage(bb, x, y, x + width, y + height, p.x + x,
+                            p.y + y, p.x + x + width, p.y + y + height,
+                            null);
+                    g2d.setComposite(composite);
+                } finally {
+                    g.dispose();
+                }
+            }
+        }
+    }
+
     /**
      * Used by ContainerPeer to skip all the paint events during layout.
      *
--- jdk/src/macosx/classes/sun/lwawt/LWRepaintArea.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/LWRepaintArea.java	2013-05-05 09:38:28.000000000 -0700
@@ -58,6 +58,9 @@
 
     private static void flushBuffers(final LWComponentPeer peer) {
         if (peer != null) {
+            if (!peer.getWindowPeerOrSelf().isOpaque()) {
+                peer.flushOffscreenGraphics();
+            }
             peer.flushOnscreenGraphics();
         }
     }
--- jdk/src/macosx/classes/sun/lwawt/LWTextAreaPeer.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/LWTextAreaPeer.java	2013-05-05 09:38:28.000000000 -0700
@@ -129,6 +129,16 @@
     }
 
     @Override
+    public void setText(final String l) {
+        // Please note that we do not want to post an event
+        // if TextArea.setText() replaces an empty text by an empty text,
+        // that is, if component's text remains unchanged.
+        if (!l.isEmpty() || getTextComponent().getDocument().getLength() != 0) {
+            super.setText(l);
+        }
+    }
+
+    @Override
     public void replaceRange(final String text, final int start,
                              final int end) {
         synchronized (getDelegateLock()) {
--- jdk/src/macosx/classes/sun/lwawt/LWTextComponentPeer.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/LWTextComponentPeer.java	2013-05-05 09:38:28.000000000 -0700
@@ -124,7 +124,7 @@
     }
 
     @Override
-    public final void setText(final String l) {
+    public void setText(final String l) {
         synchronized (getDelegateLock()) {
             // JTextArea.setText() posts two different events (remove & insert).
             // Since we make no differences between text events,
--- jdk/src/macosx/classes/sun/lwawt/LWToolkit.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/LWToolkit.java	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -522,6 +522,12 @@
         postEvent(targetToAppContext(event.getSource()), event);
     }
 
+    // use peer's back buffer to implement non-opaque windows.
+    @Override
+    public boolean needUpdateWindow() {
+        return true;
+    }
+
     @Override
     public void grab(Window w) {
         if (w.getPeer() != null) {
@@ -532,7 +538,7 @@
     @Override
     public void ungrab(Window w) {
         if (w.getPeer() != null) {
-            ((LWWindowPeer)w.getPeer()).ungrab();
+            ((LWWindowPeer)w.getPeer()).ungrab(false);
         }
     }
 }
--- jdk/src/macosx/classes/sun/lwawt/LWWindowPeer.java	2012-08-10 10:23:11.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/LWWindowPeer.java	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,7 +37,6 @@
 import sun.java2d.*;
 import sun.java2d.loops.Blit;
 import sun.java2d.loops.CompositeType;
-import sun.java2d.pipe.Region;
 import sun.util.logging.PlatformLogger;
 
 public class LWWindowPeer
@@ -110,10 +109,6 @@
 
     private volatile boolean skipNextFocusChange;
 
-    private static final Color nonOpaqueBackground = new Color(0, 0, 0, 0);
-
-    private volatile boolean textured;
-
     /**
      * Current modal blocker or null.
      *
@@ -171,14 +166,9 @@
             setTitle(((Dialog) getTarget()).getTitle());
         }
 
-        setAlwaysOnTop(getTarget().isAlwaysOnTop());
+        updateAlwaysOnTopState();
         updateMinimumSize();
 
-        final Shape shape = getTarget().getShape();
-        if (shape != null) {
-            applyShape(Region.getInstance(shape, null));
-        }
-
         final float opacity = getTarget().getOpacity();
         if (opacity < 1.0f) {
             setOpacity(opacity);
@@ -188,7 +178,7 @@
 
         updateInsets(platformWindow.getInsets());
         if (getSurfaceData() == null) {
-            replaceSurfaceData(false);
+            replaceSurfaceData();
         }
     }
 
@@ -289,7 +279,7 @@
             // "buffer", that's why numBuffers - 1
             assert numBuffers > 1;
 
-            replaceSurfaceData(numBuffers - 1, caps, false);
+            replaceSurfaceData(numBuffers - 1, caps);
         } catch (InvalidPipeException z) {
             throw new AWTException(z.toString());
         }
@@ -355,6 +345,18 @@
             h = MINIMUM_HEIGHT;
         }
 
+        if (graphicsConfig instanceof TextureSizeConstraining) {
+            final int maxW = ((TextureSizeConstraining)graphicsConfig).getMaxTextureWidth();
+            final int maxH = ((TextureSizeConstraining)graphicsConfig).getMaxTextureHeight();
+
+            if (w > maxW) {
+                w = maxW;
+            }
+            if (h > maxH) {
+                h = maxH;
+            }
+        }
+
         // Don't post ComponentMoved/Resized and Paint events
         // until we've got a notification from the delegate
         setBounds(x, y, w, h, op, false, false);
@@ -402,8 +404,8 @@
     }
 
     @Override
-    public void setAlwaysOnTop(boolean value) {
-        platformWindow.setAlwaysOnTop(value);
+    public void updateAlwaysOnTopState() {
+        platformWindow.setAlwaysOnTop(getTarget().isAlwaysOnTop());
     }
 
     @Override
@@ -426,14 +428,33 @@
 
     @Override
     public void updateMinimumSize() {
-        Dimension d = null;
+        final Dimension min;
         if (getTarget().isMinimumSizeSet()) {
-            d = getTarget().getMinimumSize();
+            min = getTarget().getMinimumSize();
+            min.width = Math.max(min.width, MINIMUM_WIDTH);
+            min.height = Math.max(min.height, MINIMUM_HEIGHT);
+        } else {
+            min = new Dimension(MINIMUM_WIDTH, MINIMUM_HEIGHT);
+        }
+
+        final int maxW, maxH;
+        if (graphicsConfig instanceof TextureSizeConstraining) {
+            maxW = ((TextureSizeConstraining)graphicsConfig).getMaxTextureWidth();
+            maxH = ((TextureSizeConstraining)graphicsConfig).getMaxTextureHeight();
+        } else {
+            maxW = maxH = Integer.MAX_VALUE;
         }
-        if (d == null) {
-            d = new Dimension(MINIMUM_WIDTH, MINIMUM_HEIGHT);
+
+        final Dimension max;
+        if (getTarget().isMaximumSizeSet()) {
+            max = getTarget().getMaximumSize();
+            max.width = Math.min(max.width, maxW);
+            max.height = Math.min(max.height, maxH);
+        } else {
+            max = new Dimension(maxW, maxH);
         }
-        platformWindow.setMinimumSize(d.width, d.height);
+
+        platformWindow.setSizeConstraints(min.width, min.height, max.width, max.height);
     }
 
     @Override
@@ -451,44 +472,19 @@
     public final void setOpaque(final boolean isOpaque) {
         if (this.isOpaque != isOpaque) {
             this.isOpaque = isOpaque;
-            updateOpaque();
+            getPlatformWindow().setOpaque(isOpaque);
+            replaceSurfaceData();
+            repaintPeer();
         }
     }
 
-    private void updateOpaque() {
-        getPlatformWindow().setOpaque(!isTranslucent());
-        replaceSurfaceData(false);
-        repaintPeer();
+    public final boolean isOpaque() {
+        return isOpaque;
     }
 
     @Override
     public void updateWindow() {
-    }
-
-    public final boolean isTextured() {
-        return textured;
-    }
-
-    public final void setTextured(final boolean isTextured) {
-        textured = isTextured;
-    }
-
-    public final boolean isTranslucent() {
-        synchronized (getStateLock()) {
-            /*
-             * Textured window is a special case of translucent window.
-             * The difference is only in nswindow background. So when we set
-             * texture property our peer became fully translucent. It doesn't
-             * fill background, create non opaque backbuffers and layer etc.
-             */
-            return !isOpaque || isShaped() || isTextured();
-        }
-    }
-
-    @Override
-    final void applyShapeImpl(final Region shape) {
-        super.applyShapeImpl(shape);
-        updateOpaque();
+        flushOffscreenGraphics();
     }
 
     @Override
@@ -643,20 +639,7 @@
                                                getFont());
         if (g != null) {
             try {
-                if (g instanceof Graphics2D) {
-                    ((Graphics2D) g).setComposite(AlphaComposite.Src);
-                }
-                if (isTranslucent()) {
-                    g.setColor(nonOpaqueBackground);
-                    g.fillRect(0, 0, w, h);
-                }
-                if (!isTextured()) {
-                    if (g instanceof SunGraphics2D) {
-                        SG2DConstraint((SunGraphics2D) g, getRegion());
-                    }
-                    g.setColor(getBackground());
-                    g.fillRect(0, 0, w, h);
-                }
+                g.clearRect(0, 0, w, h);
             } finally {
                 g.dispose();
             }
@@ -963,6 +946,35 @@
         });
     }
 
+    /**
+     * This method returns a back buffer Graphics to render all the
+     * peers to. After the peer is painted, the back buffer contents
+     * should be flushed to the screen. All the target painting
+     * (Component.paint() method) should be done directly to the screen.
+     */
+    protected final Graphics getOffscreenGraphics(Color fg, Color bg, Font f) {
+        final Image bb = getBackBuffer();
+        if (bb == null) {
+            return null;
+        }
+        if (fg == null) {
+            fg = SystemColor.windowText;
+        }
+        if (bg == null) {
+            bg = SystemColor.window;
+        }
+        if (f == null) {
+            f = DEFAULT_FONT;
+        }
+        final Graphics2D g = (Graphics2D) bb.getGraphics();
+        if (g != null) {
+            g.setColor(fg);
+            g.setBackground(bg);
+            g.setFont(f);
+        }
+        return g;
+    }
+
     /*
      * May be called by delegate to provide SD to Java2D code.
      */
@@ -973,16 +985,11 @@
     }
 
     private void replaceSurfaceData() {
-        replaceSurfaceData(true);
-    }
-
-    private void replaceSurfaceData(boolean blit) {
-        replaceSurfaceData(backBufferCount, backBufferCaps, blit);
+        replaceSurfaceData(backBufferCount, backBufferCaps);
     }
 
     private void replaceSurfaceData(int newBackBufferCount,
-                                    BufferCapabilities newBackBufferCaps,
-                                    boolean blit) {
+                                                 BufferCapabilities newBackBufferCaps) {
         synchronized (surfaceDataLock) {
             final SurfaceData oldData = getSurfaceData();
             surfaceData = platformWindow.replaceSurfaceData();
@@ -995,10 +1002,7 @@
             if (getSurfaceData() != null && oldData != getSurfaceData()) {
                 clearBackground(size.width, size.height);
             }
-
-            if (blit) {
-                blitSurfaceData(oldData, getSurfaceData());
-            }
+            blitSurfaceData(oldData, getSurfaceData());
 
             if (oldData != null && oldData != getSurfaceData()) {
                 // TODO: drop oldData for D3D/WGL pipelines
@@ -1013,18 +1017,11 @@
                 Graphics g = backBuffer.getGraphics();
                 try {
                     Rectangle r = getBounds();
+                    g.setColor(getBackground());
                     if (g instanceof Graphics2D) {
                         ((Graphics2D) g).setComposite(AlphaComposite.Src);
                     }
-                    g.setColor(nonOpaqueBackground);
                     g.fillRect(0, 0, r.width, r.height);
-                    if (g instanceof SunGraphics2D) {
-                        SG2DConstraint((SunGraphics2D) g, getRegion());
-                    }
-                    if (!isTextured()) {
-                        g.setColor(getBackground());
-                        g.fillRect(0, 0, r.width, r.height);
-                    }
                     if (oldBB != null) {
                         // Draw the old back buffer to the new one
                         g.drawImage(oldBB, 0, 0, null);
@@ -1048,7 +1045,7 @@
                                           CompositeType.Src,
                                           dst.getSurfaceType());
             if (blit != null) {
-                blit.Blit(src, dst, AlphaComposite.Src,
+                blit.Blit(src, dst, ((Graphics2D) getGraphics()).getComposite(),
                           getRegion(), 0, 0, 0, 0, size.width, size.height);
             }
         }
@@ -1271,13 +1268,19 @@
         grabbingWindow = this;
     }
 
-    void ungrab() {
+    final void ungrab(boolean doPost) {
         if (isGrabbing()) {
             grabbingWindow = null;
-            postEvent(new UngrabEvent(getTarget()));
+            if (doPost) {
+                postEvent(new UngrabEvent(getTarget()));
+            }
         }
     }
 
+    void ungrab() {
+        ungrab(true);
+    }
+
     private boolean isGrabbing() {
         return this == grabbingWindow;
     }
--- jdk/src/macosx/classes/sun/lwawt/PlatformWindow.java	2012-08-10 10:23:12.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/PlatformWindow.java	2013-05-05 09:38:28.000000000 -0700
@@ -131,7 +131,10 @@
 
     public void setResizable(boolean resizable);
 
-    public void setMinimumSize(int width, int height);
+    /**
+     * Applies the minimum and maximum size to the platform window.
+     */
+    public void setSizeConstraints(int minW, int minH, int maxW, int maxH);
 
     /**
      * Transforms the given Graphics object according to the native
--- jdk/src/macosx/classes/sun/lwawt/macosx/CDropTargetContextPeer.java	2012-08-10 10:23:12.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CDropTargetContextPeer.java	2013-05-05 09:38:28.000000000 -0700
@@ -38,7 +38,7 @@
     private long    fNativeDropTransfer = 0;
     private long    fNativeDataAvailable = 0;
     private Object  fNativeData    = null;
-    private boolean insideTarget = false;
+    private boolean insideTarget = true;
 
     Object awtLockAccess = new Object();
 
--- jdk/src/macosx/classes/sun/lwawt/macosx/CEmbeddedFrame.java	2012-08-10 10:23:12.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CEmbeddedFrame.java	2013-05-05 09:38:28.000000000 -0700
@@ -119,7 +119,9 @@
 
     public void handleWindowFocusEvent(boolean parentWindowActive) {
         this.parentWindowActive = parentWindowActive;
-        if (focused) {
+        // ignore focus "lost" native request as it may mistakenly
+        // deactivate active window (see 8001161)
+        if (focused && parentWindowActive) {
             responder.handleWindowFocusEvent(parentWindowActive);
         }
     }
--- jdk/src/macosx/classes/sun/lwawt/macosx/CFileDialog.java	2012-08-10 10:23:12.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CFileDialog.java	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -174,7 +174,7 @@
     }
 
     @Override
-    public void setAlwaysOnTop(boolean alwaysOnTop) {
+    public void updateAlwaysOnTopState() {
     }
 
     @Override
--- jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformEmbeddedFrame.java	2012-08-10 10:23:13.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformEmbeddedFrame.java	2013-05-05 09:38:28.000000000 -0700
@@ -117,7 +117,7 @@
         Rectangle r = peer.getBounds();
         Image im = null;
         if (!r.isEmpty()) {
-            int transparency = peer.isTranslucent() ? Transparency.TRANSLUCENT : Transparency.OPAQUE;
+            int transparency = (peer.isOpaque() ? Transparency.OPAQUE : Transparency.TRANSLUCENT);
             im = peer.getGraphicsConfiguration().createCompatibleImage(r.width, r.height, transparency);
         }
         return im;
@@ -180,7 +180,7 @@
     public void setResizable(boolean resizable) {}
 
     @Override
-    public void setMinimumSize(int width, int height) {}
+    public void setSizeConstraints(int minW, int minH, int maxW, int maxH) {}
 
     @Override
     public Graphics transformGraphics(Graphics g) {
--- jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformView.java	2012-08-10 10:23:13.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformView.java	2013-05-05 09:38:28.000000000 -0700
@@ -64,7 +64,7 @@
     }
 
     public boolean isOpaque() {
-        return !peer.isTranslucent();
+        return peer.isOpaque();
     }
 
     /*
--- jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java	2012-08-10 10:23:13.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java	2013-05-05 09:38:28.000000000 -0700
@@ -299,7 +299,7 @@
 
         // If the target is a dialog, popup or tooltip we want it to ignore the brushed metal look.
         if (isPopup) {
-            styleBits = SET(styleBits, TEXTURED, false);
+            styleBits = SET(styleBits, TEXTURED, true);
             // Popups in applets don't activate applet's process
             styleBits = SET(styleBits, NONACTIVATING, true);
         }
@@ -373,8 +373,6 @@
             }
         }
 
-        peer.setTextured(IS(TEXTURED, styleBits));
-
         return styleBits;
     }
 
@@ -672,20 +670,15 @@
 
         // Re-apply the size constraints and the size to ensure the space
         // occupied by the grow box is counted properly
-        setMinimumSize(1, 1); // the method ignores its arguments
+        peer.updateMinimumSize();
 
         Rectangle bounds = peer.getBounds();
         setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
     }
 
     @Override
-    public void setMinimumSize(int width, int height) {
-        //TODO width, height should be used
-        //NOTE: setResizable() calls setMinimumSize(1,1) relaying on the logic below
-        final long nsWindowPtr = getNSWindowPtr();
-        final Dimension min = target.getMinimumSize();
-        final Dimension max = target.getMaximumSize();
-        nativeSetNSWindowMinMax(nsWindowPtr, min.getWidth(), min.getHeight(), max.getWidth(), max.getHeight());
+    public void setSizeConstraints(int minW, int minH, int maxW, int maxH) {
+        nativeSetNSWindowMinMax(getNSWindowPtr(), minW, minH, maxW, maxH);
     }
 
     @Override
@@ -742,19 +735,10 @@
     @Override
     public void setOpaque(boolean isOpaque) {
         CWrapper.NSWindow.setOpaque(getNSWindowPtr(), isOpaque);
-        if (!isOpaque && !peer.isTextured()) {
+        if (!isOpaque) {
             long clearColor = CWrapper.NSColor.clearColor();
             CWrapper.NSWindow.setBackgroundColor(getNSWindowPtr(), clearColor);
         }
-
-        //This is a temporary workaround. Looks like after 7124236 will be fixed
-        //the correct place for invalidateShadow() is CGLayer.drawInCGLContext.
-        SwingUtilities.invokeLater(new Runnable() {
-            @Override
-            public void run() {
-                invalidateShadow();
-            }
-        });
     }
 
     @Override
@@ -824,10 +808,6 @@
     }
 
 
-    public final void invalidateShadow(){
-        nativeRevalidateNSWindowShadow(getNSWindowPtr());
-    }
-
     // ----------------------------------------------------------------------
     //                          UTILITY METHODS
     // ----------------------------------------------------------------------
--- jdk/src/macosx/classes/sun/lwawt/macosx/CPrinterDialogPeer.java	2012-08-10 10:23:13.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CPrinterDialogPeer.java	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -87,7 +87,7 @@
     }
 
     // 1.6 peer method
-    public void setAlwaysOnTop(boolean value) {
+    public void updateAlwaysOnTopState() {
         // no-op, since we just show the native print dialog
     }
 
--- jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	2012-08-10 10:23:14.000000000 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
 import sun.awt.*;
 import sun.lwawt.*;
 import sun.lwawt.LWWindowPeer.PeerType;
+import sun.security.action.GetBooleanAction;
 
 
 class NamedCursor extends Cursor {
@@ -90,14 +91,6 @@
         }
     }
 
-    static String getSystemProperty(final String name, final String deflt) {
-        return AccessController.doPrivileged (new PrivilegedAction<String>() {
-            public String run() {
-                return System.getProperty(name, deflt);
-            }
-        });
-    }
-
     public LWCToolkit() {
         SunToolkit.setDataTransfererClassName("sun.lwawt.macosx.CDataTransferer");
 
@@ -709,8 +702,8 @@
      */
     public synchronized static boolean getSunAwtDisableCALayers() {
         if (sunAwtDisableCALayers == null) {
-            sunAwtDisableCALayers =
-            getBooleanSystemProperty("sun.awt.disableCALayers");
+            sunAwtDisableCALayers = AccessController.doPrivileged(
+                new GetBooleanAction("sun.awt.disableCALayers"));
         }
         return sunAwtDisableCALayers.booleanValue();
     }
@@ -759,11 +752,6 @@
     }
 
     @Override
-    public boolean isWindowShapingSupported() {
-        return true;
-    }
-
-    @Override
     public boolean isWindowTranslucencySupported() {
         return true;
     }
@@ -773,10 +761,6 @@
         return true;
     }
 
-    public boolean isSwingBackbufferTranslucencySupported() {
-        return true;
-    }
-
     @Override
     public boolean enableInputMethodsForTextComponent() {
         return true;
--- jdk/src/macosx/native/sun/awt/AWTEvent.h	2012-08-10 10:23:21.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/AWTEvent.h	2013-05-05 09:38:28.000000000 -0700
@@ -33,5 +33,7 @@
 void DeliverJavaMouseEvent(JNIEnv *env, NSEvent *event, jobject peer);
 void SendAdditionalJavaEvents(JNIEnv *env, NSEvent *nsEvent, jobject peer);
 jint GetJavaMouseModifiers(NSInteger button, NSUInteger modifierFlags);
+jint NsKeyModifiersToJavaModifiers(NSUInteger nsFlags, BOOL isExtMods);
+NSUInteger JavaModifiersToNsKeyModifiers(jint javaModifiers, BOOL isExtMods);
 
 #endif /* __AWTEVENT_H */
--- jdk/src/macosx/native/sun/awt/AWTEvent.m	2012-08-10 10:23:21.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/AWTEvent.m	2013-05-05 09:38:28.000000000 -0700
@@ -244,6 +244,7 @@
     //NSUInteger cgsRightMask;
     unsigned short leftKeyCode;
     unsigned short rightKeyCode;
+    jint javaExtMask;
     jint javaMask;
     jint javaKey;
 }
@@ -254,6 +255,7 @@
         0,
         0,
         0, // no Java equivalent
+        0, // no Java equivalent
         java_awt_event_KeyEvent_VK_CAPS_LOCK
     },
     {
@@ -263,6 +265,7 @@
         56,
         60,
         java_awt_event_InputEvent_SHIFT_DOWN_MASK,
+        java_awt_event_InputEvent_SHIFT_MASK,
         java_awt_event_KeyEvent_VK_SHIFT
     },
     {
@@ -272,6 +275,7 @@
         59,
         62,
         java_awt_event_InputEvent_CTRL_DOWN_MASK,
+        java_awt_event_InputEvent_CTRL_MASK,
         java_awt_event_KeyEvent_VK_CONTROL
     },
     {
@@ -281,6 +285,7 @@
         58,
         61,
         java_awt_event_InputEvent_ALT_DOWN_MASK,
+        java_awt_event_InputEvent_ALT_MASK,
         java_awt_event_KeyEvent_VK_ALT
     },
     {
@@ -290,6 +295,7 @@
         55,
         54,
         java_awt_event_InputEvent_META_DOWN_MASK,
+        java_awt_event_InputEvent_META_MASK,
         java_awt_event_KeyEvent_VK_META
     },
     // NSNumericPadKeyMask
@@ -298,10 +304,11 @@
         0,
         0,
         0, // no Java equivalent
+        0, // no Java equivalent
         java_awt_event_KeyEvent_VK_HELP
     },
     // NSFunctionKeyMask
-    {0, 0, 0, 0, 0}
+    {0, 0, 0, 0, 0, 0}
 };
 
 /*
@@ -491,15 +498,14 @@
 /*
  * This returns the java modifiers for a key NSEvent.
  */
-static jint
-NsKeyModifiersToJavaModifiers(NSUInteger nsFlags)
+jint NsKeyModifiersToJavaModifiers(NSUInteger nsFlags, BOOL isExtMods)
 {
     jint javaModifiers = 0;
     const struct _nsKeyToJavaModifier* cur;
 
     for (cur = nsKeyToJavaModifierTable; cur->nsMask != 0; ++cur) {
         if ((cur->nsMask & nsFlags) != 0) {
-            javaModifiers |= cur->javaMask;
+            javaModifiers |= isExtMods? cur->javaExtMask : cur->javaMask;
         }
     }
 
@@ -507,6 +513,33 @@
 }
 
 /*
+ * This returns the NSEvent flags for java key modifiers.
+ */
+NSUInteger JavaModifiersToNsKeyModifiers(jint javaModifiers, BOOL isExtMods)
+{
+    NSUInteger nsFlags = 0;
+    const struct _nsKeyToJavaModifier* cur;
+
+    for (cur = nsKeyToJavaModifierTable; cur->nsMask != 0; ++cur) {
+        jint mask = isExtMods? cur->javaExtMask : cur->javaMask; 
+        if ((mask & javaModifiers) != 0) {
+            nsFlags |= cur->nsMask;
+        }
+    }
+
+    // special case
+    jint mask = isExtMods? java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK : 
+                           java_awt_event_InputEvent_ALT_GRAPH_MASK;
+
+    if ((mask & javaModifiers) != 0) {
+        nsFlags |= NSAlternateKeyMask;      
+    }
+
+    return nsFlags;
+}
+
+
+/*
  * Returns the correct java character for a key event.  Most unicode
  * characters don't require any fussing, but a few seem to need adjusting,
  * see nsCharToJavaChar.
@@ -517,7 +550,7 @@
     unichar returnValue = java_awt_event_KeyEvent_CHAR_UNDEFINED;
     NSString *chars = nil;
     unichar testChar = 0, testDeadChar = 0;
-    jint javaModifiers = NsKeyModifiersToJavaModifiers([event modifierFlags]);
+    jint javaModifiers = NsKeyModifiersToJavaModifiers([event modifierFlags], TRUE);
 
     switch ([event type]) {
     case NSFlagsChanged:
@@ -657,7 +690,7 @@
             testChar = [chars characterAtIndex:0];
         }
 
-        javaModifiers = NsKeyModifiersToJavaModifiers([event modifierFlags]);
+        javaModifiers = NsKeyModifiersToJavaModifiers([event modifierFlags], TRUE);
         if (javaModifiers == 0) {
       // TODO: dead key chars
 //            testDeadChar = GetDeadKeyCharacter(event);
@@ -692,7 +725,7 @@
 jint GetJavaMouseModifiers(NSInteger button, NSUInteger modifierFlags)
 {
     // Mousing needs the key modifiers
-    jint modifiers = NsKeyModifiersToJavaModifiers(modifierFlags);
+    jint modifiers = NsKeyModifiersToJavaModifiers(modifierFlags, TRUE);
 
 
     /*
@@ -788,7 +821,7 @@
     jint javaKeyCode, javaKeyLocation;
     BOOL postsTyped = NO;
     unichar testChar, testDeadChar = 0;
-    jint javaModifiers = NsKeyModifiersToJavaModifiers([nsEvent modifierFlags]);
+    jint javaModifiers = NsKeyModifiersToJavaModifiers([nsEvent modifierFlags], TRUE);
 
     if (javaModifiers == 0) {
         testDeadChar = [nsEvent deadKeyCharacter];
@@ -984,7 +1017,7 @@
 
 JNF_COCOA_ENTER(env);
 
-    jmodifiers = NsKeyModifiersToJavaModifiers(modifierFlags);
+    jmodifiers = NsKeyModifiersToJavaModifiers(modifierFlags, TRUE);
 
 JNF_COCOA_EXIT(env);
 
--- jdk/src/macosx/native/sun/awt/AWTWindow.m	2012-08-10 10:23:21.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/AWTWindow.m	2013-05-05 09:38:28.000000000 -0700
@@ -1017,17 +1017,14 @@
 (JNIEnv *env, jclass clazz, jlong windowPtr)
 {
 JNF_COCOA_ENTER(env);
+AWT_ASSERT_NOT_APPKIT_THREAD;
 
     NSWindow *nsWindow = OBJC(windowPtr);
-    if ([NSThread isMainThread]) {
+    [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
+        AWT_ASSERT_APPKIT_THREAD;
+
         [nsWindow invalidateShadow];
-    } else {
-        [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
-            AWT_ASSERT_APPKIT_THREAD;
-
-            [nsWindow invalidateShadow];
-        }];
-    }
+    }];
 
 JNF_COCOA_EXIT(env);
 }
--- jdk/src/macosx/native/sun/awt/CDragSource.m	2012-08-10 10:23:22.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/CDragSource.m	2013-05-05 09:38:28.000000000 -0700
@@ -460,7 +460,7 @@
     }
 
     // Convert fModifiers (extModifiers) to NS:
-    NSUInteger modifiers = [DnDUtilities mapJavaExtModifiersToNSKeyModifiers:fModifiers];
+    NSUInteger modifiers = JavaModifiersToNsKeyModifiers(fModifiers, TRUE); 
 
     // Just a dummy value ...
     NSInteger eventNumber = 0;
@@ -658,7 +658,7 @@
     }
 
     // b) drag actions (key modifiers) have changed:
-    jint modifiers = [DnDUtilities currentJavaExtKeyModifiers];
+    jint modifiers = NsKeyModifiersToJavaModifiers([NSEvent modifierFlags], YES);
     if (fDragKeyModifiers != modifiers) {
         NSDragOperation currentOp = [DnDUtilities nsDragOperationForModifiers:[NSEvent modifierFlags]];
         NSDragOperation allowedOp = [DnDUtilities mapJavaDragOperationToNS:fSourceActions] & currentOp;
--- jdk/src/macosx/native/sun/awt/CMenuItem.m	2012-08-10 10:23:22.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/CMenuItem.m	2013-05-05 09:38:28.000000000 -0700
@@ -70,6 +70,18 @@
     JNIEnv *env = [ThreadUtilities getJNIEnv];
 JNF_COCOA_ENTER(env);
 
+    // If we are called as a result of user pressing a shorcut, do nothing,
+    // because AWTView has already sent corresponding key event to the Java 
+    // layer from performKeyEquivalent
+    NSEvent *currEvent = [[NSApplication sharedApplication] currentEvent];
+    if ([currEvent type] == NSKeyDown) {
+        NSString *menuKey = [sender keyEquivalent];
+        NSString *eventKey = [currEvent charactersIgnoringModifiers];
+        if ([menuKey isEqualToString:eventKey]) {
+            return;
+        }
+    }
+
     if (fIsCheckbox) {
         static JNF_CLASS_CACHE(jc_CCheckboxMenuItem, "sun/lwawt/macosx/CCheckboxMenuItem");
         static JNF_MEMBER_CACHE(jm_ckHandleAction, jc_CCheckboxMenuItem, "handleAction", "(Z)V");
@@ -83,14 +95,8 @@
         static JNF_CLASS_CACHE(jc_CMenuItem, "sun/lwawt/macosx/CMenuItem");
         static JNF_MEMBER_CACHE(jm_handleAction, jc_CMenuItem, "handleAction", "(JI)V"); // AWT_THREADING Safe (event)
 
-        NSEvent *currEvent = [[NSApplication sharedApplication] currentEvent];
         NSUInteger modifiers = [currEvent modifierFlags];
-        jint javaModifiers = 0;
-
-        if ((modifiers & NSCommandKeyMask) != 0)   javaModifiers |= java_awt_Event_META_MASK;
-        if ((modifiers & NSShiftKeyMask) != 0)     javaModifiers |= java_awt_Event_SHIFT_MASK;
-        if ((modifiers & NSControlKeyMask) != 0)   javaModifiers |= java_awt_Event_CTRL_MASK;
-        if ((modifiers & NSAlternateKeyMask) != 0) javaModifiers |= java_awt_Event_ALT_MASK;
+        jint javaModifiers = NsKeyModifiersToJavaModifiers(modifiers, NO);
 
         JNFCallVoidMethod(env, fPeer, jm_handleAction, UTC(currEvent), javaModifiers); // AWT_THREADING Safe (event)
     }
@@ -117,10 +123,7 @@
             modifiers &= ~java_awt_event_KeyEvent_SHIFT_MASK;
         }
 
-        if ((modifiers & java_awt_event_KeyEvent_SHIFT_MASK) != 0) modifierMask |= NSShiftKeyMask;
-        if ((modifiers & java_awt_event_KeyEvent_CTRL_MASK) != 0)  modifierMask |= NSControlKeyMask;
-        if ((modifiers & java_awt_event_KeyEvent_ALT_MASK) != 0)   modifierMask |= NSAlternateKeyMask;
-        if ((modifiers & java_awt_event_KeyEvent_META_MASK) != 0)  modifierMask |= NSCommandKeyMask;
+        modifierMask = JavaModifiersToNsKeyModifiers(modifiers, NO);
     }
 
     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
--- jdk/src/macosx/native/sun/awt/DnDUtilities.h	2012-08-10 10:23:22.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/DnDUtilities.h	2013-05-05 09:38:28.000000000 -0700
@@ -42,7 +42,6 @@
 + (jint)narrowJavaDropActions:(jint)actions;
 
 // Mouse and key modifiers mapping:
-+ (NSUInteger)mapJavaExtModifiersToNSKeyModifiers:(jint)modifiers;
 + (NSUInteger)mapJavaExtModifiersToNSMouseDownButtons:(jint)modifiers;
 + (NSUInteger)mapJavaExtModifiersToNSMouseUpButtons:(jint)modifiers;
 
@@ -50,9 +49,6 @@
 + (jint)extractJavaExtKeyModifiersFromJavaExtModifiers:(jint)modifiers;
 + (jint)extractJavaExtMouseModifiersFromJavaExtModifiers:(jint)modifiers;
 
-// Get the current keyboard modifier keys as java modifiers (for operationChanged)
-+ (jint)currentJavaExtKeyModifiers;
-
 // Getting the state of the current Drag
 + (NSDragOperation)nsDragOperationForModifiers:(NSUInteger)modifiers;
 + (jint) javaKeyModifiersForNSDragOperation:(NSDragOperation)dragOp;
--- jdk/src/macosx/native/sun/awt/DnDUtilities.m	2012-08-10 10:23:22.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/DnDUtilities.m	2013-05-05 09:38:28.000000000 -0700
@@ -161,28 +161,6 @@
 }
 
 // Mouse and key modifiers mapping:
-+ (NSUInteger)mapJavaExtModifiersToNSKeyModifiers:(jint)modifiers
-{
-    NSUInteger result = 0;
-
-    if ((modifiers & java_awt_event_InputEvent_SHIFT_DOWN_MASK) != 0)
-        result |= NSShiftKeyMask;
-
-    if ((modifiers & java_awt_event_InputEvent_CTRL_DOWN_MASK) != 0)
-        result |= NSControlKeyMask;
-
-    if ((modifiers & java_awt_event_InputEvent_META_DOWN_MASK) != 0)
-        result |= NSCommandKeyMask;
-
-    if ((modifiers & java_awt_event_InputEvent_ALT_DOWN_MASK) != 0)
-        result |= NSAlternateKeyMask;
-
-    if ((modifiers & java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK) != 0)
-        result |= NSAlternateKeyMask;
-
-    return result;
-}
-
 + (NSUInteger)mapJavaExtModifiersToNSMouseDownButtons:(jint)modifiers
 {
     NSUInteger result = NSLeftMouseDown;
@@ -245,32 +223,6 @@
     return modifiers & mask;
 }
 
-
-+ (jint)currentJavaExtKeyModifiers
-{
-    NSUInteger modifiers = [NSEvent modifierFlags];
-    jint jmodifiers = 0;
-
-    if(modifiers & NSShiftKeyMask) {
-        jmodifiers |= java_awt_event_InputEvent_SHIFT_DOWN_MASK;
-    }
-
-    if(modifiers & NSControlKeyMask) {
-        jmodifiers |= java_awt_event_InputEvent_CTRL_DOWN_MASK;
-    }
-
-    if(modifiers & NSAlternateKeyMask) {
-        jmodifiers |= java_awt_event_InputEvent_ALT_DOWN_MASK;
-    }
-
-    if(modifiers & NSCommandKeyMask) {
-        jmodifiers |= java_awt_event_InputEvent_META_DOWN_MASK;
-    }
-
-    return jmodifiers;
-}
-
-
 + (NSDragOperation) nsDragOperationForModifiers:(NSUInteger)modifiers {
 
     // Java first
--- jdk/src/macosx/native/sun/awt/ImageSurfaceData.h	2012-08-10 10:23:22.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/ImageSurfaceData.h	2013-05-05 09:38:28.000000000 -0700
@@ -41,7 +41,7 @@
 // If there is an image present, this is a no-op
 void makeSureImageIsCreated(ImageSDOps* isdo);
 
-struct _ContextInfo
+typedef struct _ContextInfo
 {
     BOOL                useWindowContextReference;
     BOOL                canUseJavaPixelsAsContext;
@@ -50,10 +50,9 @@
     size_t                bytesPerRow;
     CGImageAlphaInfo    alphaInfo;
     CGColorSpaceRef        colorSpace;
-}
-typedef ContextInfo;
+} ContextInfo;
 
-struct _ImageInfo
+typedef struct _ImageInfo
 {
     size_t                bitsPerComponent;
     size_t                bitsPerPixel;
@@ -61,8 +60,7 @@
     size_t                bytesPerRow;
     CGImageAlphaInfo    alphaInfo;
     CGColorSpaceRef        colorSpace;
-}
-typedef ImageInfo;
+} ImageInfo;
 
 struct _ImageSDOps
 {
--- jdk/src/macosx/native/sun/awt/ImageSurfaceData.m	2012-08-10 10:23:22.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/ImageSurfaceData.m	2013-05-05 09:38:28.000000000 -0700
@@ -53,10 +53,6 @@
 // for vImage framework headers
 #include <Accelerate/Accelerate.h>
 
-
-// private Quartz routines needed here
-CG_EXTERN void CGContextSetCTM(CGContextRef ref, CGAffineTransform tx);
-
 static ContextInfo sDefaultContextInfo[sun_java2d_OSXOffScreenSurfaceData_TYPE_3BYTE_RGB+1] =
 {
     {YES,    YES,    8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_CUSTOM            // special case
@@ -942,7 +938,6 @@
     // intitalize the context to match the Java coordinate system
 
     // BG, since the context is created above, we can just concat
-    //CGContextSetCTM(qsdo->cgRef, CGAffineTransformMake(1, 0, 0, -1, 0, isdo->height));
     CGContextConcatCTM(qsdo->cgRef, CGAffineTransformMake(1, 0, 0, -1, 0, isdo->height));
 
     CGContextSaveGState(qsdo->cgRef); // this will make sure we don't go pass device context settings
@@ -1114,7 +1109,9 @@
                 if (qsdo->cgRef != NULL)
                 {
                     CGContextSaveGState(qsdo->cgRef);
-                    CGContextSetCTM(qsdo->cgRef, CGAffineTransformMake(1, 0, 0, 1, 0, 0));
+                    CGAffineTransform currCTM = CGContextGetCTM(qsdo->cgRef);
+                    CGAffineTransform inverse = CGAffineTransformInvert(currCTM);
+                    CGContextConcatCTM(qsdo->cgRef, inverse);
                     CGContextSetBlendMode(qsdo->cgRef, kCGBlendModeCopy);
                     CGContextSetAlpha(qsdo->cgRef, 1.0f);
                     CGContextDrawImage(qsdo->cgRef, CGRectMake(0, 0, width, height), javaImg);
--- jdk/src/macosx/native/sun/awt/QuartzRenderer.m	2012-08-10 10:23:24.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/QuartzRenderer.m	2013-05-05 09:38:28.000000000 -0700
@@ -50,9 +50,6 @@
 // same value as defined in Sun's own code
 #define XOR_ALPHA_CUTOFF 128
 
-// private Quartz routines needed here
-CG_EXTERN void CGContextSetCTM(CGContextRef ref, CGAffineTransform tx);
-
 
 static CGFloat gRoundRectCtrlpts[10][12] =
 {
@@ -536,7 +533,7 @@
 
     makeSureImageIsCreated(isdo);
 
-    CGAffineTransform ctm = CGContextGetCTM(cgRef);
+    CGContextSaveGState(cgRef);
     CGContextConcatCTM(cgRef, CGAffineTransformMake(a, b, c, d, tx, ty));
     jint alphaInfo = isdo->contextInfo.alphaInfo & kCGBitmapAlphaInfoMask;
 
@@ -551,7 +548,7 @@
         CGImageRelease(subImg);
     }
 
-    CGContextSetCTM(cgRef, ctm);
+    CGContextRestoreGState(cgRef);
     UnlockImage(env, isdo);
 }
 
--- jdk/src/macosx/native/sun/awt/QuartzSurfaceData.m	2012-08-10 10:23:24.000000000 -0700
+++ jdk/src/macosx/native/sun/awt/QuartzSurfaceData.m	2013-05-05 09:38:28.000000000 -0700
@@ -40,9 +40,6 @@
 #import <AppKit/AppKit.h>
 #import "ThreadUtilities.h"
 
-// private Quartz routines needed here
-CG_EXTERN void CGContextSetCTM(CGContextRef ref, CGAffineTransform tx);
-
 //#define DEBUG
 #if defined DEBUG
     #define PRINT(msg) {fprintf(stderr, "%s\n", msg);}
@@ -50,9 +47,6 @@
     #define PRINT(msg) {}
 #endif
 
-// from CGAffineTransformPrivate.h
-extern CGPoint CGPointApplyInverseAffineTransform(CGPoint point, CGAffineTransform t);
-
 #define kOffset (0.5f)
 
 BOOL gAdjustForJavaDrawing;
@@ -608,7 +602,8 @@
                 // We need to flip both y coefficeints to flip the offset point into the java coordinate system.
                 ctm.b = -ctm.b; ctm.d = -ctm.d; ctm.tx = 0.0f; ctm.ty = 0.0f;
                 CGPoint offsets = {kOffset, kOffset};
-                offsets = CGPointApplyInverseAffineTransform(offsets, ctm);
+                CGAffineTransform inverse = CGAffineTransformInvert(ctm);
+                offsets = CGPointApplyAffineTransform(offsets, inverse);
                 qsdo->graphicsStateInfo.offsetX = offsets.x;
                 qsdo->graphicsStateInfo.offsetY = offsets.y;
             }
--- jdk/src/macosx/native/sun/java2d/opengl/CGLGraphicsConfig.m	2012-08-10 10:23:24.000000000 -0700
+++ jdk/src/macosx/native/sun/java2d/opengl/CGLGraphicsConfig.m	2013-05-05 09:38:28.000000000 -0700
@@ -445,3 +445,20 @@
         return cglinfo->context->caps;
     }
 }
+
+JNIEXPORT jint JNICALL
+Java_sun_java2d_opengl_CGLGraphicsConfig__1getMaxTextureSize
+    (JNIEnv *env, jclass cglgc)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "CGLGraphicsConfig__1getMaxTextureSize");
+
+    __block int max = 0;
+
+    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
+        [sharedContext makeCurrentContext];
+        j2d_glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max);
+    }];
+
+    return (jint)max;
+}
+
--- jdk/src/share/bin/java.c	2012-08-10 10:23:29.000000000 -0700
+++ jdk/src/share/bin/java.c	2013-05-05 09:38:28.000000000 -0700
@@ -104,7 +104,6 @@
 static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv,
                               InvocationFunctions *ifn);
 static jstring NewPlatformString(JNIEnv *env, char *s);
-static jobjectArray NewPlatformStringArray(JNIEnv *env, char **strv, int strc);
 static jclass LoadMainClass(JNIEnv *env, int mode, char *name);
 
 static void TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv);
@@ -160,7 +159,7 @@
  * Running Java code in primordial thread caused many problems. We will
  * create a new thread to invoke JVM. See 6316197 for more information.
  */
-static jlong threadStackSize = 0;  /* stack size of the new thread */
+static jlong threadStackSize    = 0;  /* stack size of the new thread */
 static jlong maxHeapSize        = 0;  /* max heap size */
 static jlong initialHeapSize    = 0;  /* inital heap size */
 
@@ -202,6 +201,14 @@
 
     InitLauncher(javaw);
     DumpState();
+    if (JLI_IsTraceLauncher()) {
+        int i;
+        printf("Command line args:\n");
+        for (i = 0; i < argc ; i++) {
+            printf("argv[%d] = %s\n", i, argv[i]);
+        }
+        AddOption("-Dsun.java.launcher.diag=true", NULL);
+    }
 
     /*
      * Make sure the specified version of the JRE is running.
@@ -222,15 +229,6 @@
      */
     SelectVersion(argc, argv, &main_class);
 
-    if (JLI_IsTraceLauncher()) {
-        int i;
-        printf("Command line args:\n");
-        for (i = 0; i < argc ; i++) {
-            printf("argv[%d] = %s\n", i, argv[i]);
-        }
-        AddOption("-Dsun.java.launcher.diag=true", NULL);
-    }
-
     CreateExecutionEnvironment(&argc, &argv,
                                jrepath, sizeof(jrepath),
                                jvmpath, sizeof(jvmpath),
@@ -435,8 +433,8 @@
                                        "([Ljava/lang/String;)V");
     CHECK_EXCEPTION_NULL_LEAVE(mainID);
 
-    /* Build argument array */
-    mainArgs = NewPlatformStringArray(env, argv, argc);
+    /* Build platform specific argument array */
+    mainArgs = CreateApplicationArgs(env, argv, argc);
     CHECK_EXCEPTION_NULL_LEAVE(mainArgs);
 
     /* Invoke main method. */
@@ -1113,8 +1111,9 @@
 
 static jclass helperClass = NULL;
 
-static jclass
-GetLauncherHelperClass(JNIEnv *env) {
+jclass
+GetLauncherHelperClass(JNIEnv *env)
+{
     if (helperClass == NULL) {
         NULL_CHECK0(helperClass = FindBootStrapClass(env,
                 "sun/launcher/LauncherHelper"));
@@ -1158,7 +1157,7 @@
  * Returns a new array of Java string objects for the specified
  * array of platform strings.
  */
-static jobjectArray
+jobjectArray
 NewPlatformStringArray(JNIEnv *env, char **strv, int strc)
 {
     jarray cls;
@@ -1203,7 +1202,7 @@
         end   = CounterGet();
         printf("%ld micro seconds to load main class\n",
                (long)(jint)Counter2Micros(end-start));
-        printf("----_JAVA_LAUNCHER_DEBUG----\n");
+        printf("----%s----\n", JLDEBUG_ENV_ENTRY);
     }
 
     return (jclass)result;
--- jdk/src/share/bin/java.h	2012-08-10 10:23:29.000000000 -0700
+++ jdk/src/share/bin/java.h	2013-05-05 09:38:28.000000000 -0700
@@ -219,6 +219,10 @@
                                                   const char *name));
 jclass FindBootStrapClass(JNIEnv *env, const char *classname);
 
+jobjectArray CreateApplicationArgs(JNIEnv *env, char **strv, int argc);
+jobjectArray NewPlatformStringArray(JNIEnv *env, char **strv, int strc);
+jclass GetLauncherHelperClass(JNIEnv *env);
+
 int JNICALL JavaMain(void * args); /* entry point                  */
 
 enum LaunchMode {               // cf. sun.launcher.LauncherHelper
--- jdk/src/share/bin/jli_util.c	2012-08-10 10:23:29.000000000 -0700
+++ jdk/src/share/bin/jli_util.c	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -102,9 +102,9 @@
 void
 JLI_SetTraceLauncher()
 {
-   if (getenv("_JAVA_LAUNCHER_DEBUG") != 0) {
+   if (getenv(JLDEBUG_ENV_ENTRY) != 0) {
         _launcher_debug = JNI_TRUE;
-        JLI_TraceLauncher("----_JAVA_LAUNCHER_DEBUG----\n");
+        JLI_TraceLauncher("----%s----\n", JLDEBUG_ENV_ENTRY);
    }
 }
 
--- jdk/src/share/bin/jli_util.h	2012-08-10 10:23:29.000000000 -0700
+++ jdk/src/share/bin/jli_util.h	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,7 +27,10 @@
 #define _JLI_UTIL_H
 
 #include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
 #include <jni.h>
+#define JLDEBUG_ENV_ENTRY "_JAVA_LAUNCHER_DEBUG"
 
 void *JLI_MemAlloc(size_t size);
 void *JLI_MemRealloc(void *ptr, size_t size);
@@ -35,6 +38,14 @@
 void  JLI_MemFree(void *ptr);
 int   JLI_StrCCmp(const char *s1, const char* s2);
 
+typedef struct {
+    char *arg;
+    jboolean has_wildcard;
+} StdArg;
+
+StdArg *JLI_GetStdArgs();
+int     JLI_GetStdArgc();
+
 #define JLI_StrLen(p1)          strlen((p1))
 #define JLI_StrChr(p1, p2)      strchr((p1), (p2))
 #define JLI_StrRChr(p1, p2)     strrchr((p1), (p2))
@@ -55,9 +66,11 @@
 #include <io.h>
 #define JLI_StrCaseCmp(p1, p2)          stricmp((p1), (p2))
 #define JLI_StrNCaseCmp(p1, p2, p3)     strnicmp((p1), (p2), (p3))
-#define JLI_Snprintf                    _snprintf
+int  JLI_Snprintf(char *buffer, size_t size, const char *format, ...);
+void JLI_CmdToArgs(char *cmdline);
 #else
 #include <unistd.h>
+#include <strings.h>
 #define JLI_StrCaseCmp(p1, p2)          strcasecmp((p1), (p2))
 #define JLI_StrNCaseCmp(p1, p2, p3)     strncasecmp((p1), (p2), (p3))
 #define JLI_Snprintf                    snprintf
--- jdk/src/share/bin/main.c	2012-08-10 10:23:29.000000000 -0700
+++ jdk/src/share/bin/main.c	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -87,22 +87,41 @@
     const jboolean const_javaw = JNI_TRUE;
 
     __initenv = _environ;
-    margc = __argc;
-    margv = __argv;
-
 
 #else /* JAVAW */
 int
-main(int argc, char ** argv)
+main(int argc, char **argv)
 {
     int margc;
     char** margv;
     const jboolean const_javaw = JNI_FALSE;
-
+#endif /* JAVAW */
+#ifdef _WIN32
+    {
+        int i = 0;
+        if (getenv(JLDEBUG_ENV_ENTRY) != NULL) {
+            printf("Windows original main args:\n");
+            for (i = 0 ; i < __argc ; i++) {
+                printf("wwwd_args[%d] = %s\n", i, __argv[i]);
+            }
+        }
+    }
+    JLI_CmdToArgs(GetCommandLine());
+    margc = JLI_GetStdArgc();
+    // add one more to mark the end
+    margv = (char **)JLI_MemAlloc((margc + 1) * (sizeof(char *)));
+    {
+        int i = 0;
+        StdArg *stdargs = JLI_GetStdArgs();
+        for (i = 0 ; i < margc ; i++) {
+            margv[i] = stdargs[i].arg;
+        }
+        margv[i] = NULL;
+    }
+#else /* *NIXES */
     margc = argc;
     margv = argv;
-#endif /* JAVAW */
-
+#endif /* WIN32 */
     return JLI_Launch(margc, margv,
                    sizeof(const_jargs) / sizeof(char *), const_jargs,
                    sizeof(const_appclasspath) / sizeof(char *), const_appclasspath,
--- jdk/src/share/bin/parse_manifest.c	2012-08-10 10:23:29.000000000 -0700
+++ jdk/src/share/bin/parse_manifest.c	2013-05-05 09:38:28.000000000 -0700
@@ -490,9 +490,9 @@
 #ifdef O_BINARY
         | O_BINARY /* use binary mode on windows */
 #endif
-        )) == -1)
+        )) == -1) {
         return (-1);
-
+    }
     info->manifest_version = NULL;
     info->main_class = NULL;
     info->jre_version = NULL;
@@ -539,12 +539,14 @@
     zentry  entry;
     void    *data = NULL;
 
-    fd = open(jarfile, O_RDONLY
+    if ((fd = open(jarfile, O_RDONLY
 #ifdef O_BINARY
         | O_BINARY /* use binary mode on windows */
 #endif
-        );
-    if (fd != -1 && find_file(fd, &entry, filename) == 0) {
+        )) == -1) {
+        return NULL;
+    }
+    if (find_file(fd, &entry, filename) == 0) {
         data = inflate_file(fd, &entry, size);
     }
     close(fd);
@@ -586,8 +588,9 @@
 #ifdef O_BINARY
         | O_BINARY /* use binary mode on windows */
 #endif
-        )) == -1)
+        )) == -1) {
         return (-1);
+    }
 
     if (rc = find_file(fd, &entry, manifest_name) != 0) {
         close(fd);
--- jdk/src/share/bin/wildcard.c	2012-08-10 10:23:30.000000000 -0700
+++ jdk/src/share/bin/wildcard.c	2013-05-05 09:38:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -129,11 +129,11 @@
     HANDLE handle;
     char *firstFile; /* Stupid FindFirstFile...FindNextFile */
 };
-
+// since this is used repeatedly we keep it here.
+static WIN32_FIND_DATA find_data;
 static WildcardIterator
 WildcardIterator_for(const char *wildcard)
 {
-    WIN32_FIND_DATA find_data;
     WildcardIterator it = NEW_(WildcardIterator);
     HANDLE handle = FindFirstFile(wildcard, &find_data);
     if (handle == INVALID_HANDLE_VALUE)
@@ -146,7 +146,6 @@
 static char *
 WildcardIterator_next(WildcardIterator it)
 {
-    WIN32_FIND_DATA find_data;
     if (it->firstFile != NULL) {
         char *firstFile = it->firstFile;
         it->firstFile = NULL;
@@ -412,7 +411,7 @@
     FileList_expandWildcards(fl);
     expanded = FileList_join(fl, PATH_SEPARATOR);
     FileList_free(fl);
-    if (getenv("_JAVA_LAUNCHER_DEBUG") != 0)
+    if (getenv(JLDEBUG_ENV_ENTRY) != 0)
         printf("Expanded wildcards:\n"
                "    before: \"%s\"\n"
                "    after : \"%s\"\n",
--- jdk/src/share/classes/com/sun/beans/TypeResolver.java	2012-08-10 10:23:31.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/TypeResolver.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -45,9 +45,6 @@
  * @author Sergey Malenkov
  */
 public final class TypeResolver {
-
-    private static final WeakCache<Type, Map<Type, Type>> CACHE = new WeakCache<>();
-
     /**
      * Replaces the given {@code type} in an inherited method
      * with the actual type it has in the given {@code inClass}.
@@ -152,55 +149,12 @@
      * @param formal  the type where occurrences of the variables
      *                in {@code actual} will be replaced by the corresponding bound values
      * @return a resolved type
+     *
+     * @see #TypeResolver(Type)
+     * @see #resolve(Type)
      */
     public static Type resolve(Type actual, Type formal) {
-        if (formal instanceof Class) {
-            return formal;
-        }
-        if (formal instanceof GenericArrayType) {
-            Type comp = ((GenericArrayType) formal).getGenericComponentType();
-            comp = resolve(actual, comp);
-            return (comp instanceof Class)
-                    ? Array.newInstance((Class<?>) comp, 0).getClass()
-                    : GenericArrayTypeImpl.make(comp);
-        }
-        if (formal instanceof ParameterizedType) {
-            ParameterizedType fpt = (ParameterizedType) formal;
-            Type[] actuals = resolve(actual, fpt.getActualTypeArguments());
-            return ParameterizedTypeImpl.make(
-                    (Class<?>) fpt.getRawType(), actuals, fpt.getOwnerType());
-        }
-        if (formal instanceof WildcardType) {
-            WildcardType fwt = (WildcardType) formal;
-            Type[] upper = resolve(actual, fwt.getUpperBounds());
-            Type[] lower = resolve(actual, fwt.getLowerBounds());
-            return new WildcardTypeImpl(upper, lower);
-        }
-        if (formal instanceof TypeVariable) {
-            Map<Type, Type> map;
-            synchronized (CACHE) {
-                map = CACHE.get(actual);
-                if (map == null) {
-                    map = new HashMap<>();
-                    prepare(map, actual);
-                    CACHE.put(actual, map);
-                }
-            }
-            Type result = map.get(formal);
-            if (result == null || result.equals(formal)) {
-                return formal;
-            }
-            result = fixGenericArray(result);
-            // A variable can be bound to another variable that is itself bound
-            // to something.  For example, given:
-            // class Super<T> {...}
-            // class Mid<X> extends Super<T> {...}
-            // class Sub extends Mid<String>
-            // the variable T is bound to X, which is in turn bound to String.
-            // So if we have to resolve T, we need the tail recursion here.
-            return resolve(actual, result);
-        }
-        throw new IllegalArgumentException("Bad Type kind: " + formal.getClass());
+        return getTypeResolver(actual).resolve(formal);
     }
 
     /**
@@ -210,14 +164,12 @@
      * @param actual   the type that supplies bindings for type variables
      * @param formals  the array of types to resolve
      * @return an array of resolved types
+     *
+     * @see #TypeResolver(Type)
+     * @see #resolve(Type[])
      */
     public static Type[] resolve(Type actual, Type[] formals) {
-        int length = formals.length;
-        Type[] actuals = new Type[length];
-        for (int i = 0; i < length; i++) {
-            actuals[i] = resolve(actual, formals[i]);
-        }
-        return actuals;
+        return getTypeResolver(actual).resolve(formals);
     }
 
     /**
@@ -276,6 +228,32 @@
         return classes;
     }
 
+    public static TypeResolver getTypeResolver(Type type) {
+        synchronized (CACHE) {
+            TypeResolver resolver = CACHE.get(type);
+            if (resolver == null) {
+                resolver = new TypeResolver(type);
+                CACHE.put(type, resolver);
+            }
+            return resolver;
+        }
+    }
+
+    private static final WeakCache<Type, TypeResolver> CACHE = new WeakCache<>();
+
+    private final Map<TypeVariable<?>, Type> map = new HashMap<>();
+
+    /**
+     * Constructs the type resolver for the given actual type.
+     *
+     * @param actual  the type that supplies bindings for type variables
+     *
+     * @see #prepare(Type)
+     */
+    private TypeResolver(Type actual) {
+        prepare(actual);
+    }
+
     /**
      * Fills the map from type parameters
      * to types as seen by the given {@code type}.
@@ -287,10 +265,9 @@
      * to a {@link ParameterizedType ParameterizedType} with no parameters,
      * or it represents the erasure of a {@link ParameterizedType ParameterizedType}.
      *
-     * @param map   the mappings of all type variables
      * @param type  the next type in the hierarchy
      */
-    private static void prepare(Map<Type, Type> map, Type type) {
+    private void prepare(Type type) {
         Class<?> raw = (Class<?>)((type instanceof Class<?>)
                 ? type
                 : ((ParameterizedType)type).getRawType());
@@ -303,25 +280,91 @@
 
         assert formals.length == actuals.length;
         for (int i = 0; i < formals.length; i++) {
-            map.put(formals[i], actuals[i]);
+            this.map.put(formals[i], actuals[i]);
         }
         Type gSuperclass = raw.getGenericSuperclass();
         if (gSuperclass != null) {
-            prepare(map, gSuperclass);
+            prepare(gSuperclass);
         }
         for (Type gInterface : raw.getGenericInterfaces()) {
-            prepare(map, gInterface);
+            prepare(gInterface);
         }
         // If type is the raw version of a parameterized class, we type-erase
         // all of its type variables, including inherited ones.
         if (type instanceof Class<?> && formals.length > 0) {
-            for (Map.Entry<Type, Type> entry : map.entrySet()) {
+            for (Map.Entry<TypeVariable<?>, Type> entry : this.map.entrySet()) {
                 entry.setValue(erase(entry.getValue()));
             }
         }
     }
 
     /**
+     * Replaces the given {@code formal} type
+     * with the type it stand for in this type resolver.
+     *
+     * @param formal  the array of types to resolve
+     * @return a resolved type
+     */
+    private Type resolve(Type formal) {
+        if (formal instanceof Class) {
+            return formal;
+        }
+        if (formal instanceof GenericArrayType) {
+            Type comp = ((GenericArrayType)formal).getGenericComponentType();
+            comp = resolve(comp);
+            return (comp instanceof Class)
+                    ? Array.newInstance((Class<?>)comp, 0).getClass()
+                    : GenericArrayTypeImpl.make(comp);
+        }
+        if (formal instanceof ParameterizedType) {
+            ParameterizedType fpt = (ParameterizedType)formal;
+            Type[] actuals = resolve(fpt.getActualTypeArguments());
+            return ParameterizedTypeImpl.make(
+                    (Class<?>)fpt.getRawType(), actuals, fpt.getOwnerType());
+        }
+        if (formal instanceof WildcardType) {
+            WildcardType fwt = (WildcardType)formal;
+            Type[] upper = resolve(fwt.getUpperBounds());
+            Type[] lower = resolve(fwt.getLowerBounds());
+            return new WildcardTypeImpl(upper, lower);
+        }
+        if (!(formal instanceof TypeVariable)) {
+            throw new IllegalArgumentException("Bad Type kind: " + formal.getClass());
+        }
+        Type actual = this.map.get((TypeVariable) formal);
+        if (actual == null || actual.equals(formal)) {
+            return formal;
+        }
+        actual = fixGenericArray(actual);
+        return resolve(actual);
+        // A variable can be bound to another variable that is itself bound
+        // to something.  For example, given:
+        // class Super<T> {...}
+        // class Mid<X> extends Super<T> {...}
+        // class Sub extends Mid<String>
+        // the variable T is bound to X, which is in turn bound to String.
+        // So if we have to resolve T, we need the tail recursion here.
+    }
+
+    /**
+     * Replaces all formal types in the given array
+     * with the types they stand for in this type resolver.
+     *
+     * @param formals  the array of types to resolve
+     * @return an array of resolved types
+     *
+     * @see #resolve(Type)
+     */
+    private Type[] resolve(Type[] formals) {
+        int length = formals.length;
+        Type[] actuals = new Type[length];
+        for (int i = 0; i < length; i++) {
+            actuals[i] = resolve(formals[i]);
+        }
+        return actuals;
+    }
+
+    /**
      * Replaces a {@link GenericArrayType GenericArrayType}
      * with plain array class where it is possible.
      * Bug <a href="http://bugs.sun.com/view_bug.do?bug_id=5041784">5041784</a>
--- jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java	2012-08-10 10:23:31.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,9 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
@@ -46,6 +49,8 @@
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
 
+import sun.misc.SharedSecrets;
+
 /**
  * The main class to parse JavaBeans XML archive.
  *
@@ -56,11 +61,10 @@
  * @see ElementHandler
  */
 public final class DocumentHandler extends DefaultHandler {
-    private final Map<String, Class<? extends ElementHandler>> handlers = new HashMap<String, Class<? extends ElementHandler>>();
-
-    private final Map<String, Object> environment = new HashMap<String, Object>();
-
-    private final List<Object> objects = new ArrayList<Object>();
+    private final AccessControlContext acc = AccessController.getContext();
+    private final Map<String, Class<? extends ElementHandler>> handlers = new HashMap<>();
+    private final Map<String, Object> environment = new HashMap<>();
+    private final List<Object> objects = new ArrayList<>();
 
     private Reference<ClassLoader> loader;
     private ExceptionListener listener;
@@ -351,23 +355,32 @@
      *
      * @param input  the input source to parse
      */
-    public void parse(InputSource input) {
-        try {
-            SAXParserFactory.newInstance().newSAXParser().parse(input, this);
-        }
-        catch (ParserConfigurationException exception) {
-            handleException(exception);
-        }
-        catch (SAXException wrapper) {
-            Exception exception = wrapper.getException();
-            if (exception == null) {
-                exception = wrapper;
+    public void parse(final InputSource input) {
+        if ((this.acc == null) && (null != System.getSecurityManager())) {
+            throw new SecurityException("AccessControlContext is not set");
+        }
+        AccessControlContext stack = AccessController.getContext();
+        SharedSecrets.getJavaSecurityAccess().doIntersectionPrivilege(new PrivilegedAction<Void>() {
+            public Void run() {
+                try {
+                    SAXParserFactory.newInstance().newSAXParser().parse(input, DocumentHandler.this);
+                }
+                catch (ParserConfigurationException exception) {
+                    handleException(exception);
+                }
+                catch (SAXException wrapper) {
+                    Exception exception = wrapper.getException();
+                    if (exception == null) {
+                        exception = wrapper;
+                    }
+                    handleException(exception);
+                }
+                catch (IOException exception) {
+                    handleException(exception);
+                }
+                return null;
             }
-            handleException(exception);
-        }
-        catch (IOException exception) {
-            handleException(exception);
-        }
+        }, stack, this.acc);
     }
 
     /**
--- jdk/src/share/classes/com/sun/beans/decoder/MethodElementHandler.java	2012-08-10 10:23:32.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/decoder/MethodElementHandler.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,8 @@
 
 import java.lang.reflect.Method;
 
+import sun.reflect.misc.MethodUtil;
+
 /**
  * This class is intended to handle &lt;method&gt; element.
  * It describes invocation of the method.
@@ -101,7 +103,7 @@
         if (method.isVarArgs()) {
             args = getArguments(args, method.getParameterTypes());
         }
-        Object value = method.invoke(bean, args);
+        Object value = MethodUtil.invoke(method, bean, args);
         return method.getReturnType().equals(void.class)
                 ? ValueObjectImpl.VOID
                 : ValueObjectImpl.create(value);
--- jdk/src/share/classes/com/sun/beans/decoder/PropertyElementHandler.java	2012-08-10 10:23:32.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/decoder/PropertyElementHandler.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,8 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
+import sun.reflect.misc.MethodUtil;
+
 /**
  * This class is intended to handle &lt;property&gt; element.
  * This element simplifies access to the properties.
@@ -168,11 +170,11 @@
     private static Object getPropertyValue(Object bean, String name, Integer index) throws IllegalAccessException, IntrospectionException, InvocationTargetException, NoSuchMethodException {
         Class<?> type = bean.getClass();
         if (index == null) {
-            return findGetter(type, name).invoke(bean);
+            return MethodUtil.invoke(findGetter(type, name), bean, new Object[] {});
         } else if (type.isArray() && (name == null)) {
             return Array.get(bean, index);
         } else {
-            return findGetter(type, name, int.class).invoke(bean, index);
+            return MethodUtil.invoke(findGetter(type, name, int.class), bean, new Object[] {index});
         }
     }
 
@@ -197,11 +199,11 @@
                 : null;
 
         if (index == null) {
-            findSetter(type, name, param).invoke(bean, value);
+            MethodUtil.invoke(findSetter(type, name, param), bean, new Object[] {value});
         } else if (type.isArray() && (name == null)) {
             Array.set(bean, index, value);
         } else {
-            findSetter(type, name, int.class, param).invoke(bean, index, value);
+            MethodUtil.invoke(findSetter(type, name, int.class, param), bean, new Object[] {index, value});
         }
     }
 
--- jdk/src/share/classes/com/sun/beans/editors/BooleanEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/BooleanEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "boolean" type.
+ */
+
+import java.beans.*;
+
+public class BooleanEditor extends PropertyEditorSupport {
+
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value.toString()
+                : "null";
+    }
+
+    public String getAsText() {
+        Object value = getValue();
+        return (value instanceof Boolean)
+             ? getValidName((Boolean) value)
+             : null;
+    }
+
+    public void setAsText(String text) throws java.lang.IllegalArgumentException {
+        if (text == null) {
+            setValue(null);
+        } else if (isValidName(true, text)) {
+            setValue(Boolean.TRUE);
+        } else if (isValidName(false, text)) {
+            setValue(Boolean.FALSE);
+        } else {
+            throw new java.lang.IllegalArgumentException(text);
+        }
+    }
+
+    public String[] getTags() {
+        return new String[] {getValidName(true), getValidName(false)};
+    }
+
+    // the following method should be localized (4890258)
+
+    private String getValidName(boolean value) {
+        return value ? "True" : "False";
+    }
+
+    private boolean isValidName(boolean value, String name) {
+        return getValidName(value).equalsIgnoreCase(name);
+    }
+}
--- jdk/src/share/classes/com/sun/beans/editors/ByteEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/ByteEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "byte" type.
+ *
+ */
+
+import java.beans.*;
+
+public class ByteEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? "((byte)" + value + ")"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Byte.decode(text));
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/ColorEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/ColorEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+import java.awt.*;
+import java.beans.*;
+
+public class ColorEditor extends Panel implements PropertyEditor {
+    private static final long serialVersionUID = 1781257185164716054L;
+
+    public ColorEditor() {
+        setLayout(null);
+
+        ourWidth = hPad;
+
+        // Create a sample color block bordered in black
+        Panel p = new Panel();
+        p.setLayout(null);
+        p.setBackground(Color.black);
+        sample = new Canvas();
+        p.add(sample);
+        sample.reshape(2, 2, sampleWidth, sampleHeight);
+        add(p);
+        p.reshape(ourWidth, 2, sampleWidth+4, sampleHeight+4);
+        ourWidth += sampleWidth + 4 + hPad;
+
+        text = new TextField("", 14);
+        add(text);
+        text.reshape(ourWidth,0,100,30);
+        ourWidth += 100 + hPad;
+
+        choser = new Choice();
+        int active = 0;
+        for (int i = 0; i < colorNames.length; i++) {
+            choser.addItem(colorNames[i]);
+        }
+        add(choser);
+        choser.reshape(ourWidth,0,100,30);
+        ourWidth += 100 + hPad;
+
+        resize(ourWidth,40);
+    }
+
+    public void setValue(Object o) {
+        Color c = (Color)o;
+        changeColor(c);
+    }
+
+    public Dimension preferredSize() {
+        return new Dimension(ourWidth, 40);
+    }
+
+    public boolean keyUp(Event e, int key) {
+        if (e.target == text) {
+            try {
+                setAsText(text.getText());
+            } catch (IllegalArgumentException ex) {
+                // Quietly ignore.
+            }
+        }
+        return (false);
+    }
+
+    public void setAsText(String s) throws java.lang.IllegalArgumentException {
+        if (s == null) {
+            changeColor(null);
+            return;
+        }
+        int c1 = s.indexOf(',');
+        int c2 = s.indexOf(',', c1+1);
+        if (c1 < 0 || c2 < 0) {
+            // Invalid string.
+            throw new IllegalArgumentException(s);
+        }
+        try {
+            int r = Integer.parseInt(s.substring(0,c1));
+            int g = Integer.parseInt(s.substring(c1+1, c2));
+            int b = Integer.parseInt(s.substring(c2+1));
+            Color c = new Color(r,g,b);
+            changeColor(c);
+        } catch (Exception ex) {
+            throw new IllegalArgumentException(s);
+        }
+
+    }
+
+    public boolean action(Event e, Object arg) {
+        if (e.target == choser) {
+            changeColor(colors[choser.getSelectedIndex()]);
+        }
+        return false;
+    }
+
+    public String getJavaInitializationString() {
+        return (this.color != null)
+                ? "new java.awt.Color(" + this.color.getRGB() + ",true)"
+                : "null";
+    }
+
+
+    private void changeColor(Color c) {
+
+        if (c == null) {
+            this.color = null;
+            this.text.setText("");
+            return;
+        }
+
+        color = c;
+
+        text.setText("" + c.getRed() + "," + c.getGreen() + "," + c.getBlue());
+
+        int active = 0;
+        for (int i = 0; i < colorNames.length; i++) {
+            if (color.equals(colors[i])) {
+                active = i;
+            }
+        }
+        choser.select(active);
+
+        sample.setBackground(color);
+        sample.repaint();
+
+        support.firePropertyChange("", null, null);
+    }
+
+    public Object getValue() {
+        return color;
+    }
+
+    public boolean isPaintable() {
+        return true;
+    }
+
+    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
+        Color oldColor = gfx.getColor();
+        gfx.setColor(Color.black);
+        gfx.drawRect(box.x, box.y, box.width-3, box.height-3);
+        gfx.setColor(color);
+        gfx.fillRect(box.x+1, box.y+1, box.width-4, box.height-4);
+        gfx.setColor(oldColor);
+    }
+
+    public String getAsText() {
+        return (this.color != null)
+                ? this.color.getRed() + "," + this.color.getGreen() + "," + this.color.getBlue()
+                : null;
+    }
+
+    public String[] getTags() {
+        return null;
+    }
+
+    public java.awt.Component getCustomEditor() {
+        return this;
+    }
+
+    public boolean supportsCustomEditor() {
+        return true;
+    }
+
+    public void addPropertyChangeListener(PropertyChangeListener l) {
+        support.addPropertyChangeListener(l);
+    }
+
+    public void removePropertyChangeListener(PropertyChangeListener l) {
+        support.removePropertyChangeListener(l);
+    }
+
+
+    private String colorNames[] = { " ", "white", "lightGray", "gray", "darkGray",
+                        "black", "red", "pink", "orange",
+                        "yellow", "green", "magenta", "cyan",
+                        "blue"};
+    private Color colors[] = { null, Color.white, Color.lightGray, Color.gray, Color.darkGray,
+                        Color.black, Color.red, Color.pink, Color.orange,
+                        Color.yellow, Color.green, Color.magenta, Color.cyan,
+                        Color.blue};
+
+    private Canvas sample;
+    private int sampleHeight = 20;
+    private int sampleWidth = 40;
+    private int hPad = 5;
+    private int ourWidth;
+
+    private Color color;
+    private TextField text;
+    private Choice choser;
+
+    private PropertyChangeSupport support = new PropertyChangeSupport(this);
+}
--- jdk/src/share/classes/com/sun/beans/editors/DoubleEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/DoubleEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "double" type.
+ *
+ */
+
+import java.beans.*;
+
+public class DoubleEditor extends NumberEditor {
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Double.valueOf(text));
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/EnumEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/EnumEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.sun.beans.editors;
+
+import java.awt.Component;
+import java.awt.Graphics;
+import java.awt.Rectangle;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyEditor;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Property editor for java.lang.Enum subclasses.
+ *
+ * @see PropertyEditor
+ *
+ * @since 1.7
+ *
+ * @author Sergey A. Malenkov
+ */
+public class EnumEditor implements PropertyEditor {
+    private final List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
+
+    private final Class type;
+    private final String[] tags;
+
+    private Object value;
+
+    public EnumEditor( Class type ) {
+        Object[] values = type.getEnumConstants();
+        if ( values == null ) {
+            throw new IllegalArgumentException( "Unsupported " + type );
+        }
+        this.type = type;
+        this.tags = new String[values.length];
+        for ( int i = 0; i < values.length; i++ ) {
+            this.tags[i] = ( ( Enum )values[i] ).name();
+        }
+    }
+
+    public Object getValue() {
+        return this.value;
+    }
+
+    public void setValue( Object value ) {
+        if ( ( value != null ) && !this.type.isInstance( value ) ) {
+            throw new IllegalArgumentException( "Unsupported value: " + value );
+        }
+        Object oldValue;
+        PropertyChangeListener[] listeners;
+        synchronized ( this.listeners ) {
+            oldValue = this.value;
+            this.value = value;
+
+            if ( ( value == null ) ? oldValue == null : value.equals( oldValue ) ) {
+                return; // do not fire event if value is not changed
+            }
+            int size = this.listeners.size();
+            if ( size == 0 ) {
+                return; // do not fire event if there are no any listener
+            }
+            listeners = this.listeners.toArray( new PropertyChangeListener[size] );
+        }
+        PropertyChangeEvent event = new PropertyChangeEvent( this, null, oldValue, value );
+        for ( PropertyChangeListener listener : listeners ) {
+            listener.propertyChange( event );
+        }
+    }
+
+    public String getAsText() {
+        return ( this.value != null )
+                ? ( ( Enum )this.value ).name()
+                : null;
+    }
+
+    public void setAsText( String text ) {
+        setValue( ( text != null )
+                ? Enum.valueOf( this.type, text )
+                : null );
+    }
+
+    public String[] getTags() {
+        return this.tags.clone();
+    }
+
+    public String getJavaInitializationString() {
+        String name = getAsText();
+        return ( name != null )
+                ? this.type.getName() + '.' + name
+                : "null";
+    }
+
+    public boolean isPaintable() {
+        return false;
+    }
+
+    public void paintValue( Graphics gfx, Rectangle box ) {
+    }
+
+    public boolean supportsCustomEditor() {
+        return false;
+    }
+
+    public Component getCustomEditor() {
+        return null;
+    }
+
+    public void addPropertyChangeListener( PropertyChangeListener listener ) {
+        synchronized ( this.listeners ) {
+            this.listeners.add( listener );
+        }
+    }
+
+    public void removePropertyChangeListener( PropertyChangeListener listener ) {
+        synchronized ( this.listeners ) {
+            this.listeners.remove( listener );
+        }
+    }
+}
--- jdk/src/share/classes/com/sun/beans/editors/FloatEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/FloatEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "float" type.
+ *
+ */
+
+import java.beans.*;
+
+public class FloatEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value + "F"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Float.valueOf(text));
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/FontEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/FontEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+import java.awt.*;
+import java.beans.*;
+
+public class FontEditor extends Panel implements java.beans.PropertyEditor {
+    private static final long serialVersionUID = 6732704486002715933L;
+
+    public FontEditor() {
+        setLayout(null);
+
+        toolkit = Toolkit.getDefaultToolkit();
+        fonts = toolkit.getFontList();
+
+        familyChoser = new Choice();
+        for (int i = 0; i < fonts.length; i++) {
+            familyChoser.addItem(fonts[i]);
+        }
+        add(familyChoser);
+        familyChoser.reshape(20, 5, 100, 30);
+
+        styleChoser = new Choice();
+        for (int i = 0; i < styleNames.length; i++) {
+            styleChoser.addItem(styleNames[i]);
+        }
+        add(styleChoser);
+        styleChoser.reshape(145, 5, 70, 30);
+
+        sizeChoser = new Choice();
+        for (int i = 0; i < pointSizes.length; i++) {
+            sizeChoser.addItem("" + pointSizes[i]);
+        }
+        add(sizeChoser);
+        sizeChoser.reshape(220, 5, 70, 30);
+
+        resize(300,40);
+    }
+
+
+    public Dimension preferredSize() {
+        return new Dimension(300, 40);
+    }
+
+    public void setValue(Object o) {
+        font = (Font) o;
+        if (this.font == null)
+            return;
+
+        changeFont(font);
+        // Update the current GUI choices.
+        for (int i = 0; i < fonts.length; i++) {
+            if (fonts[i].equals(font.getFamily())) {
+                familyChoser.select(i);
+                break;
+            }
+        }
+        for (int i = 0; i < styleNames.length; i++) {
+            if (font.getStyle() == styles[i]) {
+                styleChoser.select(i);
+                break;
+            }
+        }
+        for (int i = 0; i < pointSizes.length; i++) {
+            if (font.getSize() <= pointSizes[i]) {
+                sizeChoser.select(i);
+                break;
+            }
+        }
+    }
+
+    private void changeFont(Font f) {
+        font = f;
+        if (sample != null) {
+            remove(sample);
+        }
+        sample = new Label(sampleText);
+        sample.setFont(font);
+        add(sample);
+        Component p = getParent();
+        if (p != null) {
+            p.invalidate();
+            p.layout();
+        }
+        invalidate();
+        layout();
+        repaint();
+        support.firePropertyChange("", null, null);
+    }
+
+    public Object getValue() {
+        return (font);
+    }
+
+    public String getJavaInitializationString() {
+        if (this.font == null)
+            return "null";
+
+        return "new java.awt.Font(\"" + font.getName() + "\", " +
+                   font.getStyle() + ", " + font.getSize() + ")";
+    }
+
+    public boolean action(Event e, Object arg) {
+        String family = familyChoser.getSelectedItem();
+        int style = styles[styleChoser.getSelectedIndex()];
+        int size = pointSizes[sizeChoser.getSelectedIndex()];
+        try {
+            Font f = new Font(family, style, size);
+            changeFont(f);
+        } catch (Exception ex) {
+            System.err.println("Couldn't create font " + family + "-" +
+                        styleNames[style] + "-" + size);
+        }
+        return (false);
+    }
+
+
+    public boolean isPaintable() {
+        return true;
+    }
+
+    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
+        // Silent noop.
+        Font oldFont = gfx.getFont();
+        gfx.setFont(font);
+        FontMetrics fm = gfx.getFontMetrics();
+        int vpad = (box.height - fm.getAscent())/2;
+        gfx.drawString(sampleText, 0, box.height-vpad);
+        gfx.setFont(oldFont);
+    }
+
+    public String getAsText() {
+        if (this.font == null) {
+            return null;
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append(this.font.getName());
+        sb.append(' ');
+
+        boolean b = this.font.isBold();
+        if (b) {
+            sb.append("BOLD");
+        }
+        boolean i = this.font.isItalic();
+        if (i) {
+            sb.append("ITALIC");
+        }
+        if (b || i) {
+            sb.append(' ');
+        }
+        sb.append(this.font.getSize());
+        return sb.toString();
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Font.decode(text));
+    }
+
+    public String[] getTags() {
+        return null;
+    }
+
+    public java.awt.Component getCustomEditor() {
+        return this;
+    }
+
+    public boolean supportsCustomEditor() {
+        return true;
+    }
+
+    public void addPropertyChangeListener(PropertyChangeListener l) {
+        support.addPropertyChangeListener(l);
+    }
+
+    public void removePropertyChangeListener(PropertyChangeListener l) {
+        support.removePropertyChangeListener(l);
+    }
+
+    private Font font;
+    private Toolkit toolkit;
+    private String sampleText = "Abcde...";
+
+    private Label sample;
+    private Choice familyChoser;
+    private Choice styleChoser;
+    private Choice sizeChoser;
+
+    private String fonts[];
+    private String[] styleNames = { "plain", "bold", "italic" };
+    private int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC };
+    private int[] pointSizes = { 3, 5, 8, 10, 12, 14, 18, 24, 36, 48 };
+
+    private PropertyChangeSupport support = new PropertyChangeSupport(this);
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/IntegerEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/IntegerEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "int" type.
+ *
+ */
+
+import java.beans.*;
+
+public class IntegerEditor extends NumberEditor {
+
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Integer.decode(text));
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/LongEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/LongEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "long" type.
+ *
+ */
+
+import java.beans.*;
+
+public class LongEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value + "L"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Long.decode(text));
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/NumberEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/NumberEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Abstract Property editor for a java builtin number types.
+ *
+ */
+
+import java.beans.*;
+
+abstract public class NumberEditor extends PropertyEditorSupport {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value.toString()
+                : "null";
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/ShortEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/ShortEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "short" type.
+ *
+ */
+
+import java.beans.*;
+
+public class ShortEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? "((short)" + value + ")"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Short.decode(text));
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/editors/StringEditor.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/editors/StringEditor.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package com.sun.beans.editors;
+
+import java.beans.*;
+
+public class StringEditor extends PropertyEditorSupport {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        if (value == null)
+            return "null";
+
+        String str = value.toString();
+        int length = str.length();
+        StringBuilder sb = new StringBuilder(length + 2);
+        sb.append('"');
+        for (int i = 0; i < length; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+            case '\b': sb.append("\\b");  break;
+            case '\t': sb.append("\\t");  break;
+            case '\n': sb.append("\\n");  break;
+            case '\f': sb.append("\\f");  break;
+            case '\r': sb.append("\\r");  break;
+            case '\"': sb.append("\\\""); break;
+            case '\\': sb.append("\\\\"); break;
+            default:
+                if ((ch < ' ') || (ch > '~')) {
+                    sb.append("\\u");
+                    String hex = Integer.toHexString((int) ch);
+                    for (int len = hex.length(); len < 4; len++) {
+                        sb.append('0');
+                    }
+                    sb.append(hex);
+                } else {
+                    sb.append(ch);
+                }
+                break;
+            }
+        }
+        sb.append('"');
+        return sb.toString();
+    }
+
+    public void setAsText(String text) {
+        setValue(text);
+    }
+
+}
--- jdk/src/share/classes/com/sun/beans/finder/BeanInfoFinder.java	2012-08-10 10:23:32.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/BeanInfoFinder.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
         extends InstanceFinder<BeanInfo> {
 
     private static final String DEFAULT = "sun.beans.infos";
+    private static final String DEFAULT_NEW = "com.sun.beans.infos";
 
     public BeanInfoFinder() {
         super(BeanInfo.class, true, "BeanInfo", DEFAULT);
@@ -53,10 +54,13 @@
 
     @Override
     protected BeanInfo instantiate(Class<?> type, String prefix, String name) {
+        if (DEFAULT.equals(prefix)) {
+            prefix = DEFAULT_NEW;
+        }
         // this optimization will only use the BeanInfo search path
         // if is has changed from the original
         // or trying to get the ComponentBeanInfo
-        BeanInfo info = !DEFAULT.equals(prefix) || "ComponentBeanInfo".equals(name)
+        BeanInfo info = !DEFAULT_NEW.equals(prefix) || "ComponentBeanInfo".equals(name)
                 ? super.instantiate(type, prefix, name)
                 : null;
 
--- jdk/src/share/classes/com/sun/beans/finder/ClassFinder.java	2012-08-10 10:23:33.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/ClassFinder.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
  */
 package com.sun.beans.finder;
 
+import static sun.reflect.misc.ReflectUtil.checkPackageAccess;
+
 /**
  * This is utility class that provides {@code static} methods
  * to find a class with the specified name using the specified class loader.
@@ -54,6 +56,7 @@
      * @see Thread#getContextClassLoader()
      */
     public static Class<?> findClass(String name) throws ClassNotFoundException {
+        checkPackageAccess(name);
         try {
             ClassLoader loader = Thread.currentThread().getContextClassLoader();
             if (loader == null) {
@@ -94,6 +97,7 @@
      * @see Class#forName(String,boolean,ClassLoader)
      */
     public static Class<?> findClass(String name, ClassLoader loader) throws ClassNotFoundException {
+        checkPackageAccess(name);
         if (loader != null) {
             try {
                 return Class.forName(name, false, loader);
--- jdk/src/share/classes/com/sun/beans/finder/ConstructorFinder.java	2012-08-10 10:23:33.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/ConstructorFinder.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,8 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 
+import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
+
 /**
  * This utility class provides {@code static} methods
  * to find a public constructor with specified parameter types
@@ -61,7 +63,7 @@
         if (Modifier.isAbstract(type.getModifiers())) {
             throw new NoSuchMethodException("Abstract class cannot be instantiated");
         }
-        if (!Modifier.isPublic(type.getModifiers())) {
+        if (!Modifier.isPublic(type.getModifiers()) || !isPackageAccessible(type)) {
             throw new NoSuchMethodException("Class is not accessible");
         }
         PrimitiveWrapperMap.replacePrimitivesWithWrappers(args);
--- jdk/src/share/classes/com/sun/beans/finder/FieldFinder.java	2012-08-10 10:23:33.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/FieldFinder.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
+import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
+
 /**
  * This utility class provides {@code static} methods
  * to find a public field with specified name
@@ -56,7 +58,8 @@
         if (!Modifier.isPublic(field.getModifiers())) {
             throw new NoSuchFieldException("Field '" + name + "' is not public");
         }
-        if (!Modifier.isPublic(field.getDeclaringClass().getModifiers())) {
+        type = field.getDeclaringClass();
+        if (!Modifier.isPublic(type.getModifiers()) || !isPackageAccessible(type)) {
             throw new NoSuchFieldException("Field '" + name + "' is not accessible");
         }
         return field;
--- jdk/src/share/classes/com/sun/beans/finder/MethodFinder.java	2012-08-10 10:23:33.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/MethodFinder.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,8 @@
 import java.lang.reflect.Type;
 import java.util.Arrays;
 
+import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
+
 /**
  * This utility class provides {@code static} methods
  * to find a public method with specified name and parameter types
@@ -64,11 +66,14 @@
         Signature signature = new Signature(type, name, args);
 
         Method method = CACHE.get(signature);
-        if (method != null) {
+        boolean cached = method != null;
+        if (cached && isPackageAccessible(method.getDeclaringClass())) {
             return method;
         }
         method = findAccessibleMethod(new MethodFinder(name, args).find(type.getMethods()));
-        CACHE.put(signature, method);
+        if (!cached) {
+            CACHE.put(signature, method);
+        }
         return method;
     }
 
@@ -120,7 +125,7 @@
      */
     public static Method findAccessibleMethod(Method method) throws NoSuchMethodException {
         Class<?> type = method.getDeclaringClass();
-        if (Modifier.isPublic(type.getModifiers())) {
+        if (Modifier.isPublic(type.getModifiers()) && isPackageAccessible(type)) {
             return method;
         }
         if (Modifier.isStatic(method.getModifiers())) {
@@ -164,10 +169,8 @@
                             return findAccessibleMethod(m);
                         }
                         Type[] gpts = m.getGenericParameterTypes();
-                        if (params.length == gpts.length) {
-                            if (Arrays.equals(params, TypeResolver.erase(TypeResolver.resolve(pt, gpts)))) {
-                                return findAccessibleMethod(m);
-                            }
+                        if (Arrays.equals(params, TypeResolver.erase(TypeResolver.resolve(pt, gpts)))) {
+                            return findAccessibleMethod(m);
                         }
                     }
                 }
--- jdk/src/share/classes/com/sun/beans/finder/PropertyEditorFinder.java	2012-08-10 10:23:33.000000000 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/PropertyEditorFinder.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,14 +28,14 @@
 
 import java.beans.PropertyEditor;
 
-import sun.beans.editors.BooleanEditor;
-import sun.beans.editors.ByteEditor;
-import sun.beans.editors.DoubleEditor;
-import sun.beans.editors.EnumEditor;
-import sun.beans.editors.FloatEditor;
-import sun.beans.editors.IntegerEditor;
-import sun.beans.editors.LongEditor;
-import sun.beans.editors.ShortEditor;
+import com.sun.beans.editors.BooleanEditor;
+import com.sun.beans.editors.ByteEditor;
+import com.sun.beans.editors.DoubleEditor;
+import com.sun.beans.editors.EnumEditor;
+import com.sun.beans.editors.FloatEditor;
+import com.sun.beans.editors.IntegerEditor;
+import com.sun.beans.editors.LongEditor;
+import com.sun.beans.editors.ShortEditor;
 
 /**
  * This is utility class that provides functionality
@@ -48,10 +48,13 @@
 public final class PropertyEditorFinder
         extends InstanceFinder<PropertyEditor> {
 
+    private static final String DEFAULT = "sun.beans.editors";
+    private static final String DEFAULT_NEW = "com.sun.beans.editors";
+
     private final WeakCache<Class<?>, Class<?>> registry;
 
     public PropertyEditorFinder() {
-        super(PropertyEditor.class, false, "Editor", "sun.beans.editors");
+        super(PropertyEditor.class, false, "Editor", DEFAULT);
 
         this.registry = new WeakCache<Class<?>, Class<?>>();
         this.registry.put(Byte.TYPE, ByteEditor.class);
@@ -84,4 +87,9 @@
         }
         return editor;
     }
+
+    @Override
+    protected PropertyEditor instantiate(Class<?> type, String prefix, String name) {
+        return super.instantiate(type, DEFAULT.equals(prefix) ? DEFAULT_NEW : prefix, name);
+    }
 }
--- jdk/src/share/classes/com/sun/beans/infos/ComponentBeanInfo.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/com/sun/beans/infos/ComponentBeanInfo.java	2013-05-05 09:38:35.000000000 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.infos;
+
+import java.beans.*;
+
+/**
+ * BeanInfo descriptor for a standard AWT component.
+ */
+
+public class ComponentBeanInfo extends SimpleBeanInfo {
+    private static final Class beanClass = java.awt.Component.class;
+
+    public PropertyDescriptor[] getPropertyDescriptors() {
+        try {
+            PropertyDescriptor
+                      name = new PropertyDescriptor("name",       beanClass),
+                background = new PropertyDescriptor("background", beanClass),
+                foreground = new PropertyDescriptor("foreground", beanClass),
+                      font = new PropertyDescriptor("font",       beanClass),
+                   enabled = new PropertyDescriptor("enabled",    beanClass),
+                   visible = new PropertyDescriptor("visible",    beanClass),
+                 focusable = new PropertyDescriptor("focusable",  beanClass);
+
+            enabled.setExpert(true);
+            visible.setHidden(true);
+
+            background.setBound(true);
+            foreground.setBound(true);
+            font.setBound(true);
+            focusable.setBound(true);
+
+            PropertyDescriptor[] rv = {name, background, foreground, font, enabled, visible, focusable };
+            return rv;
+        } catch (IntrospectionException e) {
+            throw new Error(e.toString());
+        }
+    }
+}
--- jdk/src/share/classes/com/sun/crypto/provider/AESCrypt.java	2012-08-10 10:23:33.000000000 -0700
+++ jdk/src/share/classes/com/sun/crypto/provider/AESCrypt.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
 package com.sun.crypto.provider;
 
 import java.security.InvalidKeyException;
+import java.util.Arrays;
 
 /**
  * Rijndael --pronounced Reindaal-- is a symmetric cipher with a 128-bit
@@ -54,7 +55,12 @@
     private Object[] sessionK = null;
     private int[] K = null;
 
-    /** (ROUNDS-1) * 4 */
+    /** Cipher encryption/decryption key */
+    // skip re-generating Session and Sub keys if the cipher key is
+    // the same
+    private byte[] lastKey = null;
+
+    /** ROUNDS * 4 */
     private int limit = 0;
 
     AESCrypt() {
@@ -82,41 +88,45 @@
                 key.length + " bytes");
         }
 
-        // generate session key and reset sub key.
-        sessionK = makeKey(key);
-        setSubKey(decrypting);
+        if (!Arrays.equals(key, lastKey)) {
+            // re-generate session key 'sessionK' when cipher key changes
+            makeSessionKey(key);
+            lastKey = key.clone();  // save cipher key
+        }
+
+        // set sub key to the corresponding session Key
+        this.K = (int[]) sessionK[(decrypting? 1:0)];
     }
 
-    private void setSubKey(boolean decrypting) {
-        int[][] Kd = (int[][]) sessionK[decrypting ? 1 : 0];
-        int rounds = Kd.length;
-        this.K = new int[rounds*4];
-        for(int i=0; i<rounds; i++) {
+    /**
+     * Expand an int[(ROUNDS+1)][4] into int[(ROUNDS+1)*4].
+     * For decryption round keys, need to rotate right by 4 ints.
+     * @param kr The round keys for encryption or decryption.
+     * @param decrypting True if 'kr' is for decryption and false otherwise.
+     */
+    private static final int[] expandToSubKey(int[][] kr, boolean decrypting) {
+        int total = kr.length;
+        int[] expK = new int[total*4];
+        if (decrypting) {
+            // decrypting, rotate right by 4 ints
+            // i.e. i==0
             for(int j=0; j<4; j++) {
-                K[i*4 + j] = Kd[i][j];
+                expK[j] = kr[total-1][j];
             }
-        }
-
-        if (decrypting) {
-            int j0 = K[K.length-4];
-            int j1 = K[K.length-3];
-            int j2 = K[K.length-2];
-            int j3 = K[K.length-1];
-
-            for (int i=this.K.length-1; i>3; i--) {
-                this.K[i] = this.K[i-4];
+            for(int i=1; i<total; i++) {
+                for(int j=0; j<4; j++) {
+                    expK[i*4 + j] = kr[i-1][j];
+                }
+            }
+        } else {
+            // encrypting, straight expansion
+            for(int i=0; i<total; i++) {
+                for(int j=0; j<4; j++) {
+                    expK[i*4 + j] = kr[i][j];
+                }
             }
-            K[0] = j0;
-            K[1] = j1;
-            K[2] = j2;
-            K[3] = j3;
         }
-
-        ROUNDS_12 = (rounds>=13);
-        ROUNDS_14 = (rounds==15);
-
-        rounds--;
-        limit=rounds*4;
+        return expK;
     }
 
     private static int[]
@@ -566,10 +576,10 @@
     /**
      * Expand a user-supplied key material into a session key.
      *
-     * @param key The 128/192/256-bit user-key to use.
+     * @param k The 128/192/256-bit cipher key to use.
      * @exception InvalidKeyException  If the key is invalid.
      */
-    private static Object[] makeKey(byte[] k) throws InvalidKeyException {
+    private void makeSessionKey(byte[] k) throws InvalidKeyException {
         if (k == null) {
             throw new InvalidKeyException("Empty key");
         }
@@ -639,10 +649,18 @@
                            U4[ tt         & 0xFF];
             }
         }
-        // assemble the encryption (Ke) and decryption (Kd) round keys into
-        // one sessionKey object
-        Object[] result = new Object[] {Ke, Kd};
-        return result;
+
+        // assemble the encryption (Ke) and decryption (Kd) round keys
+        // and expand them into arrays of ints.
+        int[] expandedKe = expandToSubKey(Ke, false); // decrypting==false
+        int[] expandedKd = expandToSubKey(Kd, true);  // decrypting==true
+
+        ROUNDS_12 = (ROUNDS>=12);
+        ROUNDS_14 = (ROUNDS==14);
+        limit = ROUNDS*4;
+
+        // store the expanded sub keys into 'sessionK'
+        sessionK = new Object[] { expandedKe, expandedKd };
     }
 
 
--- jdk/src/share/classes/com/sun/crypto/provider/DHKeyAgreement.java	2012-08-10 10:23:34.000000000 -0700
+++ jdk/src/share/classes/com/sun/crypto/provider/DHKeyAgreement.java	2013-05-05 09:38:35.000000000 -0700
@@ -41,6 +41,8 @@
 import javax.crypto.SecretKey;
 import javax.crypto.spec.*;
 
+import sun.security.util.KeyUtil;
+
 /**
  * This class implements the Diffie-Hellman key agreement protocol between
  * any number of parties.
@@ -200,6 +202,9 @@
             throw new InvalidKeyException("Incompatible parameters");
         }
 
+        // validate the Diffie-Hellman public key
+        KeyUtil.validate(dhPubKey);
+
         // store the y value
         this.y = dhPubKey.getY();
 
--- jdk/src/share/classes/com/sun/imageio/plugins/jpeg/JPEGImageReader.java	2012-08-10 10:23:37.000000000 -0700
+++ jdk/src/share/classes/com/sun/imageio/plugins/jpeg/JPEGImageReader.java	2013-05-05 09:38:35.000000000 -0700
@@ -238,12 +238,17 @@
      * sending warnings to listeners.
      */
     protected void warningOccurred(int code) {
-        if ((code < 0) || (code > MAX_WARNING)){
-            throw new InternalError("Invalid warning index");
+        cbLock.lock();
+        try {
+            if ((code < 0) || (code > MAX_WARNING)){
+                throw new InternalError("Invalid warning index");
+            }
+            processWarningOccurred
+                ("com.sun.imageio.plugins.jpeg.JPEGImageReaderResources",
+                 Integer.toString(code));
+        } finally {
+            cbLock.unlock();
         }
-        processWarningOccurred
-            ("com.sun.imageio.plugins.jpeg.JPEGImageReaderResources",
-             Integer.toString(code));
     }
 
     /**
@@ -260,7 +265,12 @@
      * library warnings from being printed to stderr.
      */
     protected void warningWithMessage(String msg) {
-        processWarningOccurred(msg);
+        cbLock.lock();
+        try {
+            processWarningOccurred(msg);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     public void setInput(Object input,
@@ -269,18 +279,55 @@
     {
         setThreadLock();
         try {
+            cbLock.check();
+
             super.setInput(input, seekForwardOnly, ignoreMetadata);
             this.ignoreMetadata = ignoreMetadata;
             resetInternalState();
             iis = (ImageInputStream) input; // Always works
-            setSource(structPointer, iis);
+            setSource(structPointer);
         } finally {
             clearThreadLock();
         }
     }
 
-    private native void setSource(long structPointer,
-                                  ImageInputStream source);
+    /**
+     * This method is called from native code in order to fill
+     * native input buffer.
+     *
+     * We block any attempt to change the reading state during this
+     * method, in order to prevent a corruption of the native decoder
+     * state.
+     *
+     * @return number of bytes read from the stream.
+     */
+    private int readInputData(byte[] buf, int off, int len) throws IOException {
+        cbLock.lock();
+        try {
+            return iis.read(buf, off, len);
+        } finally {
+            cbLock.unlock();
+        }
+    }
+
+    /**
+     * This method is called from the native code in order to
+     * skip requested number of bytes in the input stream.
+     *
+     * @param n
+     * @return
+     * @throws IOException
+     */
+    private long skipInputBytes(long n) throws IOException {
+        cbLock.lock();
+        try {
+            return iis.skipBytes(n);
+        } finally {
+            cbLock.unlock();
+        }
+    }
+
+    private native void setSource(long structPointer);
 
     private void checkTablesOnly() throws IOException {
         if (debug) {
@@ -332,6 +379,8 @@
     public int getNumImages(boolean allowSearch) throws IOException {
         setThreadLock();
         try { // locked thread
+            cbLock.check();
+
             return getNumImagesOnThread(allowSearch);
         } finally {
             clearThreadLock();
@@ -531,8 +580,13 @@
         if (debug) {
             System.out.println("pushing back " + num + " bytes");
         }
-        iis.seek(iis.getStreamPosition()-num);
-        // The buffer is clear after this, so no need to set haveSeeked.
+        cbLock.lock();
+        try {
+            iis.seek(iis.getStreamPosition()-num);
+            // The buffer is clear after this, so no need to set haveSeeked.
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     /**
@@ -639,7 +693,12 @@
                  * Ignore this profile.
                  */
                 iccCS = null;
-                warningOccurred(WARNING_IGNORE_INVALID_ICC);
+                cbLock.lock();
+                try {
+                    warningOccurred(WARNING_IGNORE_INVALID_ICC);
+                } finally {
+                    cbLock.unlock();
+                }
             }
         }
     }
@@ -648,6 +707,7 @@
         setThreadLock();
         try {
             if (currentImage != imageIndex) {
+                cbLock.check();
                 readHeader(imageIndex, true);
             }
             return width;
@@ -660,6 +720,7 @@
         setThreadLock();
         try {
             if (currentImage != imageIndex) {
+                cbLock.check();
                 readHeader(imageIndex, true);
             }
             return height;
@@ -688,6 +749,8 @@
         setThreadLock();
         try {
             if (currentImage != imageIndex) {
+                cbLock.check();
+
                 readHeader(imageIndex, true);
             }
 
@@ -711,6 +774,7 @@
     private Iterator getImageTypesOnThread(int imageIndex)
         throws IOException {
         if (currentImage != imageIndex) {
+            cbLock.check();
             readHeader(imageIndex, true);
         }
 
@@ -926,6 +990,7 @@
         setThreadLock();
         try {
             if (!tablesOnlyChecked) {
+                cbLock.check();
                 checkTablesOnly();
             }
             return streamMetadata;
@@ -946,6 +1011,8 @@
                 return imageMetadata;
             }
 
+            cbLock.check();
+
             gotoImage(imageIndex);
 
             imageMetadata = new JPEGMetadata(false, false, iis, this);
@@ -962,6 +1029,7 @@
         throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
             try {
                 readInternal(imageIndex, param, false);
             } catch (RuntimeException e) {
@@ -1191,58 +1259,63 @@
         }
         target.setRect(destROI.x, destROI.y + y, raster);
 
-        processImageUpdate(image,
-                           destROI.x, destROI.y+y,
-                           raster.getWidth(), 1,
-                           1, 1,
-                           destinationBands);
-        if ((y > 0) && (y%progInterval == 0)) {
-            int height = target.getHeight()-1;
-            float percentOfPass = ((float)y)/height;
-            if (progressive) {
-                if (knownPassCount != UNKNOWN) {
-                    processImageProgress((pass + percentOfPass)*100.0F
-                                         / knownPassCount);
-                } else if (maxProgressivePass != Integer.MAX_VALUE) {
-                    // Use the range of allowed progressive passes
-                    processImageProgress((pass + percentOfPass)*100.0F
-                        / (maxProgressivePass - minProgressivePass + 1));
-                } else {
-                    // Assume there are a minimum of MIN_ESTIMATED_PASSES
-                    // and that there is always one more pass
-                    // Compute the percentage as the percentage at the end
-                    // of the previous pass, plus the percentage of this
-                    // pass scaled to be the percentage of the total remaining,
-                    // assuming a minimum of MIN_ESTIMATED_PASSES passes and
-                    // that there is always one more pass.  This is monotonic
-                    // and asymptotic to 1.0, which is what we need.
-                    int remainingPasses = // including this one
-                        Math.max(2, MIN_ESTIMATED_PASSES-pass);
-                    int totalPasses = pass + remainingPasses-1;
-                    progInterval = Math.max(height/20*totalPasses,
-                                            totalPasses);
-                    if (y%progInterval == 0) {
-                        percentToDate = previousPassPercentage +
-                            (1.0F - previousPassPercentage)
-                            * (percentOfPass)/remainingPasses;
-                        if (debug) {
-                            System.out.print("pass= " + pass);
-                            System.out.print(", y= " + y);
-                            System.out.print(", progInt= " + progInterval);
-                            System.out.print(", % of pass: " + percentOfPass);
-                            System.out.print(", rem. passes: "
-                                             + remainingPasses);
-                            System.out.print(", prev%: "
-                                             + previousPassPercentage);
-                            System.out.print(", %ToDate: " + percentToDate);
-                            System.out.print(" ");
+        cbLock.lock();
+        try {
+            processImageUpdate(image,
+                               destROI.x, destROI.y+y,
+                               raster.getWidth(), 1,
+                               1, 1,
+                               destinationBands);
+            if ((y > 0) && (y%progInterval == 0)) {
+                int height = target.getHeight()-1;
+                float percentOfPass = ((float)y)/height;
+                if (progressive) {
+                    if (knownPassCount != UNKNOWN) {
+                        processImageProgress((pass + percentOfPass)*100.0F
+                                             / knownPassCount);
+                    } else if (maxProgressivePass != Integer.MAX_VALUE) {
+                        // Use the range of allowed progressive passes
+                        processImageProgress((pass + percentOfPass)*100.0F
+                                             / (maxProgressivePass - minProgressivePass + 1));
+                    } else {
+                        // Assume there are a minimum of MIN_ESTIMATED_PASSES
+                        // and that there is always one more pass
+                        // Compute the percentage as the percentage at the end
+                        // of the previous pass, plus the percentage of this
+                        // pass scaled to be the percentage of the total remaining,
+                        // assuming a minimum of MIN_ESTIMATED_PASSES passes and
+                        // that there is always one more pass.  This is monotonic
+                        // and asymptotic to 1.0, which is what we need.
+                        int remainingPasses = // including this one
+                            Math.max(2, MIN_ESTIMATED_PASSES-pass);
+                        int totalPasses = pass + remainingPasses-1;
+                        progInterval = Math.max(height/20*totalPasses,
+                                                totalPasses);
+                        if (y%progInterval == 0) {
+                            percentToDate = previousPassPercentage +
+                                (1.0F - previousPassPercentage)
+                                * (percentOfPass)/remainingPasses;
+                            if (debug) {
+                                System.out.print("pass= " + pass);
+                                System.out.print(", y= " + y);
+                                System.out.print(", progInt= " + progInterval);
+                                System.out.print(", % of pass: " + percentOfPass);
+                                System.out.print(", rem. passes: "
+                                                 + remainingPasses);
+                                System.out.print(", prev%: "
+                                                 + previousPassPercentage);
+                                System.out.print(", %ToDate: " + percentToDate);
+                                System.out.print(" ");
+                            }
+                            processImageProgress(percentToDate*100.0F);
                         }
-                        processImageProgress(percentToDate*100.0F);
                     }
+                } else {
+                    processImageProgress(percentOfPass * 100.0F);
                 }
-            } else {
-                processImageProgress(percentOfPass * 100.0F);
             }
+        } finally {
+            cbLock.unlock();
         }
     }
 
@@ -1255,33 +1328,58 @@
     }
 
     private void passStarted (int pass) {
-        this.pass = pass;
-        previousPassPercentage = percentToDate;
-        processPassStarted(image,
-                           pass,
-                           minProgressivePass,
-                           maxProgressivePass,
-                           0, 0,
-                           1,1,
-                           destinationBands);
+        cbLock.lock();
+        try {
+            this.pass = pass;
+            previousPassPercentage = percentToDate;
+            processPassStarted(image,
+                               pass,
+                               minProgressivePass,
+                               maxProgressivePass,
+                               0, 0,
+                               1,1,
+                               destinationBands);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     private void passComplete () {
-        processPassComplete(image);
+        cbLock.lock();
+        try {
+            processPassComplete(image);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     void thumbnailStarted(int thumbnailIndex) {
-        processThumbnailStarted(currentImage, thumbnailIndex);
+        cbLock.lock();
+        try {
+            processThumbnailStarted(currentImage, thumbnailIndex);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     // Provide access to protected superclass method
     void thumbnailProgress(float percentageDone) {
-        processThumbnailProgress(percentageDone);
+        cbLock.lock();
+        try {
+            processThumbnailProgress(percentageDone);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     // Provide access to protected superclass method
     void thumbnailComplete() {
-        processThumbnailComplete();
+        cbLock.lock();
+        try {
+            processThumbnailComplete();
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     /**
@@ -1305,6 +1403,11 @@
     public void abort() {
         setThreadLock();
         try {
+            /**
+             * NB: we do not check the call back lock here,
+             * we allow to abort the reader any time.
+             */
+
             super.abort();
             abortRead(structPointer);
         } finally {
@@ -1327,6 +1430,7 @@
         setThreadLock();
         Raster retval = null;
         try {
+            cbLock.check();
             /*
              * This could be further optimized by not resetting the dest.
              * offset and creating a translated raster in readInternal()
@@ -1366,6 +1470,8 @@
     public int getNumThumbnails(int imageIndex) throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             getImageMetadata(imageIndex);  // checks iis state for us
             // Now check the jfif segments
             JFIFMarkerSegment jfif =
@@ -1386,6 +1492,8 @@
         throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             if ((thumbnailIndex < 0)
                 || (thumbnailIndex >= getNumThumbnails(imageIndex))) {
                 throw new IndexOutOfBoundsException("No such thumbnail");
@@ -1404,6 +1512,8 @@
         throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             if ((thumbnailIndex < 0)
                 || (thumbnailIndex >= getNumThumbnails(imageIndex))) {
                 throw new IndexOutOfBoundsException("No such thumbnail");
@@ -1423,6 +1533,8 @@
         throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             if ((thumbnailIndex < 0)
                 || (thumbnailIndex >= getNumThumbnails(imageIndex))) {
                 throw new IndexOutOfBoundsException("No such thumbnail");
@@ -1463,6 +1575,7 @@
     public void reset() {
         setThreadLock();
         try {
+            cbLock.check();
             super.reset();
         } finally {
             clearThreadLock();
@@ -1474,6 +1587,8 @@
     public void dispose() {
         setThreadLock();
         try {
+            cbLock.check();
+
             if (structPointer != 0) {
                 disposerRecord.dispose();
                 structPointer = 0;
@@ -1535,6 +1650,36 @@
             theThread = null;
         }
     }
+
+    private CallBackLock cbLock = new CallBackLock();
+
+    private static class CallBackLock {
+
+        private State lockState;
+
+        CallBackLock() {
+            lockState = State.Unlocked;
+        }
+
+        void check() {
+            if (lockState != State.Unlocked) {
+                throw new IllegalStateException("Access to the reader is not allowed");
+            }
+        }
+
+        private void lock() {
+            lockState = State.Locked;
+        }
+
+        private void unlock() {
+            lockState = State.Unlocked;
+        }
+
+        private static enum State {
+            Unlocked,
+            Locked
+        }
+    }
 }
 
 /**
--- jdk/src/share/classes/com/sun/imageio/plugins/jpeg/JPEGImageWriter.java	2012-08-10 10:23:37.000000000 -0700
+++ jdk/src/share/classes/com/sun/imageio/plugins/jpeg/JPEGImageWriter.java	2013-05-05 09:38:35.000000000 -0700
@@ -178,8 +178,7 @@
     static {
         java.security.AccessController.doPrivileged(
             new sun.security.action.LoadLibraryAction("jpeg"));
-        initWriterIDs(ImageOutputStream.class,
-                      JPEGQTable.class,
+        initWriterIDs(JPEGQTable.class,
                       JPEGHuffmanTable.class);
     }
 
@@ -195,11 +194,13 @@
     public void setOutput(Object output) {
         setThreadLock();
         try {
+            cbLock.check();
+
             super.setOutput(output); // validates output
             resetInternalState();
             ios = (ImageOutputStream) output; // so this will always work
             // Set the native destination
-            setDest(structPointer, ios);
+            setDest(structPointer);
         } finally {
             clearThreadLock();
         }
@@ -354,6 +355,8 @@
                       ImageWriteParam param) throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             writeOnThread(streamMetadata, image, param);
         } finally {
             clearThreadLock();
@@ -1077,13 +1080,18 @@
                              haveMetadata,
                              restartInterval);
 
-        if (aborted) {
-            processWriteAborted();
-        } else {
-            processImageComplete();
-        }
+        cbLock.lock();
+        try {
+            if (aborted) {
+                processWriteAborted();
+            } else {
+                processImageComplete();
+            }
 
-        ios.flush();
+            ios.flush();
+        } finally {
+            cbLock.unlock();
+        }
         currentImage++;  // After a successful write
     }
 
@@ -1091,6 +1099,8 @@
         throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             prepareWriteSequenceOnThread(streamMetadata);
         } finally {
             clearThreadLock();
@@ -1170,6 +1180,8 @@
         throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             if (sequencePrepared == false) {
                 throw new IllegalStateException("sequencePrepared not called!");
             }
@@ -1183,6 +1195,8 @@
     public void endWriteSequence() throws IOException {
         setThreadLock();
         try {
+            cbLock.check();
+
             if (sequencePrepared == false) {
                 throw new IllegalStateException("sequencePrepared not called!");
             }
@@ -1195,6 +1209,10 @@
     public synchronized void abort() {
         setThreadLock();
         try {
+            /**
+             * NB: we do not check the call back lock here, we allow to abort
+             * the reader any time.
+             */
             super.abort();
             abortWrite(structPointer);
         } finally {
@@ -1218,6 +1236,8 @@
     public void reset() {
         setThreadLock();
         try {
+            cbLock.check();
+
             super.reset();
         } finally {
             clearThreadLock();
@@ -1227,6 +1247,8 @@
     public void dispose() {
         setThreadLock();
         try {
+            cbLock.check();
+
             if (structPointer != 0) {
                 disposerRecord.dispose();
                 structPointer = 0;
@@ -1246,13 +1268,18 @@
      * sending warnings to listeners.
      */
     void warningOccurred(int code) {
-        if ((code < 0) || (code > MAX_WARNING)){
-            throw new InternalError("Invalid warning index");
+        cbLock.lock();
+        try {
+            if ((code < 0) || (code > MAX_WARNING)){
+                throw new InternalError("Invalid warning index");
+            }
+            processWarningOccurred
+                (currentImage,
+                 "com.sun.imageio.plugins.jpeg.JPEGImageWriterResources",
+                Integer.toString(code));
+        } finally {
+            cbLock.unlock();
         }
-        processWarningOccurred
-            (currentImage,
-             "com.sun.imageio.plugins.jpeg.JPEGImageWriterResources",
-             Integer.toString(code));
     }
 
     /**
@@ -1269,21 +1296,41 @@
      * library warnings from being printed to stderr.
      */
     void warningWithMessage(String msg) {
-        processWarningOccurred(currentImage, msg);
+        cbLock.lock();
+        try {
+            processWarningOccurred(currentImage, msg);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     void thumbnailStarted(int thumbnailIndex) {
-        processThumbnailStarted(currentImage, thumbnailIndex);
+        cbLock.lock();
+        try {
+            processThumbnailStarted(currentImage, thumbnailIndex);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     // Provide access to protected superclass method
     void thumbnailProgress(float percentageDone) {
-        processThumbnailProgress(percentageDone);
+        cbLock.lock();
+        try {
+            processThumbnailProgress(percentageDone);
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     // Provide access to protected superclass method
     void thumbnailComplete() {
-        processThumbnailComplete();
+        cbLock.lock();
+        try {
+            processThumbnailComplete();
+        } finally {
+            cbLock.unlock();
+        }
     }
 
     ///////// End of Package-access API
@@ -1610,16 +1657,14 @@
     ////////////// Native methods and callbacks
 
     /** Sets up static native structures. */
-    private static native void initWriterIDs(Class iosClass,
-                                             Class qTableClass,
+    private static native void initWriterIDs(Class qTableClass,
                                              Class huffClass);
 
     /** Sets up per-writer native structure and returns a pointer to it. */
     private native long initJPEGImageWriter();
 
     /** Sets up native structures for output stream */
-    private native void setDest(long structPointer,
-                                ImageOutputStream ios);
+    private native void setDest(long structPointer);
 
     /**
      * Returns <code>true</code> if the write was aborted.
@@ -1744,7 +1789,12 @@
         }
         raster.setRect(sourceLine);
         if ((y > 7) && (y%8 == 0)) {  // Every 8 scanlines
-            processImageProgress((float) y / (float) sourceHeight * 100.0F);
+            cbLock.lock();
+            try {
+                processImageProgress((float) y / (float) sourceHeight * 100.0F);
+            } finally {
+                cbLock.unlock();
+            }
         }
     }
 
@@ -1772,6 +1822,25 @@
         }
     }
 
+    /**
+     * This method is called from native code in order to write encoder
+     * output to the destination.
+     *
+     * We block any attempt to change the writer state during this
+     * method, in order to prevent a corruption of the native encoder
+     * state.
+     */
+    private void writeOutputData(byte[] data, int offset, int len)
+            throws IOException
+    {
+        cbLock.lock();
+        try {
+            ios.write(data, offset, len);
+        } finally {
+            cbLock.unlock();
+        }
+    }
+
     private Thread theThread = null;
     private int theLockCount = 0;
 
@@ -1806,4 +1875,34 @@
             theThread = null;
         }
     }
+
+    private CallBackLock cbLock = new CallBackLock();
+
+    private static class CallBackLock {
+
+        private State lockState;
+
+        CallBackLock() {
+            lockState = State.Unlocked;
+        }
+
+        void check() {
+            if (lockState != State.Unlocked) {
+                throw new IllegalStateException("Access to the writer is not allowed");
+            }
+        }
+
+        private void lock() {
+            lockState = State.Locked;
+        }
+
+        private void unlock() {
+            lockState = State.Unlocked;
+        }
+
+        private static enum State {
+            Unlocked,
+            Locked
+        }
+    }
 }
--- jdk/src/share/classes/com/sun/java/swing/plaf/windows/WindowsRootPaneUI.java	2012-08-10 10:24:01.000000000 -0700
+++ jdk/src/share/classes/com/sun/java/swing/plaf/windows/WindowsRootPaneUI.java	2013-05-05 09:38:36.000000000 -0700
@@ -30,6 +30,8 @@
 import java.awt.Event;
 import java.awt.KeyEventPostProcessor;
 import java.awt.Window;
+import java.awt.Toolkit;
+import sun.awt.SunToolkit;
 
 import java.awt.event.ActionEvent;
 import java.awt.event.KeyEvent;
@@ -125,7 +127,19 @@
                 }
                 JMenu menu = mbar != null ? mbar.getMenu(0) : null;
 
-                if (menu != null) {
+                // It might happen that the altRelease event is processed
+                // with a reasonable delay since it has been generated.
+                // Here we check the last deactivation time of the containing
+                // window. If this time appears to be greater than the altRelease
+                // event time the event is skipped to avoid unexpected menu
+                // activation. See 7121442.
+                boolean skip = false;
+                Toolkit tk = Toolkit.getDefaultToolkit();
+                if (tk instanceof SunToolkit) {
+                    skip = ev.getWhen() <= ((SunToolkit)tk).getWindowDeactivationTime(winAncestor);
+                }
+
+                if (menu != null && !skip) {
                     MenuElement[] path = new MenuElement[2];
                     path[0] = mbar;
                     path[1] = menu;
--- jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java	2012-08-10 10:24:12.000000000 -0700
+++ jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java	2013-05-05 09:38:36.000000000 -0700
@@ -1003,7 +1003,6 @@
 
         /** Write a constant pool reference. */
         public void putRef(Entry e) {
-            assert(index != null);
             addValue(encodeRefOrNull(e, index));
         }
         public void putRef(Entry e, Index index) {
@@ -1055,6 +1054,8 @@
 
 
     int encodeRef(Entry e, Index ix) {
+        if (ix == null)
+            throw new RuntimeException("null index for " + e.stringValue());
         int coding = ix.indexOf(e);
         if (verbose > 2)
             Utils.log.fine("putRef "+coding+" => "+e);
--- jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	2012-08-10 10:24:13.000000000 -0700
+++ jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	2013-05-05 09:38:36.000000000 -0700
@@ -1053,6 +1053,8 @@
 
         /** Index of all CP entries of a given tag and class. */
         public Index getMemberIndex(byte tag, ClassEntry classRef) {
+            if (classRef == null)
+                throw new RuntimeException("missing class reference for " + tagName(tag));
             if (indexByTagAndClass == null)
                 indexByTagAndClass = new Index[CONSTANT_Limit][];
             Index allClasses =  getIndexByTag(CONSTANT_Class);
--- jdk/src/share/classes/com/sun/java/util/jar/pack/NativeUnpack.java	2012-08-10 10:24:14.000000000 -0700
+++ jdk/src/share/classes/com/sun/java/util/jar/pack/NativeUnpack.java	2013-05-05 09:38:36.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -104,6 +104,10 @@
         return (p200 == null)? null: p200._nunp;
     }
 
+    private synchronized long getUnpackerPtr() {
+        return unpackerPtr;
+    }
+
     // Callback from the unpacker engine to get more data.
     private long readInputFn(ByteBuffer pbuf, long minlen) throws IOException {
         if (in == null)  return 0;  // nothing is readable
--- jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java	2012-08-10 10:24:14.000000000 -0700
+++ jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java	2013-05-05 09:38:36.000000000 -0700
@@ -84,7 +84,7 @@
      * @param out an OutputStream
      * @exception IOException if an error is encountered.
      */
-    public void pack(JarFile in, OutputStream out) throws IOException {
+    public synchronized void pack(JarFile in, OutputStream out) throws IOException {
         assert(Utils.currentInstance.get() == null);
         TimeZone tz = (props.getBoolean(Utils.PACK_DEFAULT_TIMEZONE))
                       ? null
@@ -119,7 +119,7 @@
      * @param out an OutputStream
      * @exception IOException if an error is encountered.
      */
-    public void pack(JarInputStream in, OutputStream out) throws IOException {
+    public synchronized void pack(JarInputStream in, OutputStream out) throws IOException {
         assert(Utils.currentInstance.get() == null);
         TimeZone tz = (props.getBoolean(Utils.PACK_DEFAULT_TIMEZONE)) ? null :
             TimeZone.getDefault();
--- jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java	2012-08-10 10:24:14.000000000 -0700
+++ jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java	2013-05-05 09:38:36.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -107,7 +107,7 @@
      * @param out a JarOutputStream.
      * @exception IOException if an error is encountered.
      */
-    public void unpack(InputStream in, JarOutputStream out) throws IOException {
+    public synchronized void unpack(InputStream in, JarOutputStream out) throws IOException {
         if (in == null) {
             throw new NullPointerException("null input");
         }
@@ -152,7 +152,7 @@
      * @param out a JarOutputStream.
      * @exception IOException if an error is encountered.
      */
-    public void unpack(File in, JarOutputStream out) throws IOException {
+    public synchronized void unpack(File in, JarOutputStream out) throws IOException {
         if (in == null) {
             throw new NullPointerException("null input");
         }
--- jdk/src/share/classes/com/sun/jmx/mbeanserver/ClassLoaderRepositorySupport.java	2012-08-10 10:24:19.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/mbeanserver/ClassLoaderRepositorySupport.java	2013-05-05 09:38:36.000000000 -0700
@@ -36,6 +36,7 @@
 
 import javax.management.ObjectName;
 import javax.management.loading.PrivateClassLoader;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * This class keeps the list of Class Loaders registered in the MBean Server.
@@ -192,6 +193,7 @@
                                final ClassLoader without,
                                final ClassLoader stop)
             throws ClassNotFoundException {
+        ReflectUtil.checkPackageAccess(className);
         final int size = list.length;
         for(int i=0; i<size; i++) {
             try {
--- jdk/src/share/classes/com/sun/jmx/mbeanserver/Introspector.java	2012-08-10 10:24:19.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/mbeanserver/Introspector.java	2013-05-05 09:38:36.000000000 -0700
@@ -56,6 +56,8 @@
 import java.lang.reflect.InvocationTargetException;
 import javax.management.AttributeNotFoundException;
 import javax.management.openmbean.CompositeData;
+import sun.reflect.misc.MethodUtil;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * This class contains the methods for performing all the tests needed to verify
@@ -528,8 +530,10 @@
                     // to locate method
                     readMethod = SimpleIntrospector.getReadMethod(clazz, element);
                 }
-                if (readMethod != null)
-                    return readMethod.invoke(complex);
+                if (readMethod != null) {
+                    ReflectUtil.checkPackageAccess(readMethod.getDeclaringClass());
+                    return MethodUtil.invoke(readMethod, complex, new Class[0]);
+                }
 
                 throw new AttributeNotFoundException(
                     "Could not find the getter method for the property " +
--- jdk/src/share/classes/com/sun/jmx/mbeanserver/JmxMBeanServer.java	2012-08-10 10:24:19.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/mbeanserver/JmxMBeanServer.java	2013-05-05 09:38:36.000000000 -0700
@@ -51,6 +51,7 @@
 import javax.management.MBeanRegistrationException;
 import javax.management.MBeanServer;
 import javax.management.MBeanServerDelegate;
+import javax.management.MBeanServerPermission;
 import javax.management.NotCompliantMBeanException;
 import javax.management.NotificationFilter;
 import javax.management.NotificationListener;
@@ -1409,6 +1410,8 @@
         // Default is true.
         final boolean fairLock = DEFAULT_FAIR_LOCK_POLICY;
 
+        checkNewMBeanServerPermission();
+
         // This constructor happens to disregard the value of the interceptors
         // flag - that is, it always uses the default value - false.
         // This is admitedly a bug, but we chose not to fix it for now
@@ -1494,4 +1497,11 @@
         }
     }
 
+    private static void checkNewMBeanServerPermission() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            Permission perm = new MBeanServerPermission("newMBeanServer");
+            sm.checkPermission(perm);
+        }
+    }
 }
--- jdk/src/share/classes/com/sun/jmx/mbeanserver/MBeanInstantiator.java	2012-08-10 10:24:19.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/mbeanserver/MBeanInstantiator.java	2013-05-05 09:38:36.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,11 +32,14 @@
 import java.io.ObjectInputStream;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+import java.security.Permission;
 import java.util.Map;
 import java.util.logging.Level;
 
 import javax.management.InstanceNotFoundException;
 import javax.management.MBeanException;
+import javax.management.MBeanPermission;
 import javax.management.NotCompliantMBeanException;
 import javax.management.ObjectName;
 import javax.management.OperationsException;
@@ -44,7 +47,7 @@
 import javax.management.RuntimeErrorException;
 import javax.management.RuntimeMBeanException;
 import javax.management.RuntimeOperationsException;
-
+import sun.reflect.misc.ConstructorUtil;
 import sun.reflect.misc.ReflectUtil;
 
 /**
@@ -56,7 +59,6 @@
  * @since 1.5
  */
 public class MBeanInstantiator {
-
     private final ModifiableClassLoaderRepository clr;
     //    private MetaData meta = null;
 
@@ -88,6 +90,7 @@
                              "Exception occurred during object instantiation");
         }
 
+        ReflectUtil.checkPackageAccess(className);
         try {
             if (clr == null) throw new ClassNotFoundException(className);
             theClass = clr.loadClass(className);
@@ -162,6 +165,7 @@
                     continue;
                 }
 
+                ReflectUtil.checkPackageAccess(signature[i]);
                 // Ok we do not have a primitive type ! We need to build
                 // the signature of the method
                 //
@@ -205,8 +209,10 @@
      */
     public Object instantiate(Class<?> theClass)
         throws ReflectionException, MBeanException {
-        Object moi;
 
+        checkMBeanPermission(theClass, null, null, "instantiate");
+
+        Object moi;
 
         // ------------------------------
         // ------------------------------
@@ -218,6 +224,7 @@
         // Instantiate the new object
         try {
             ReflectUtil.checkPackageAccess(theClass);
+            ensureClassAccess(theClass);
             moi= cons.newInstance();
         } catch (InvocationTargetException e) {
             // Wrap the exception.
@@ -260,8 +267,10 @@
     public Object instantiate(Class<?> theClass, Object params[],
                               String signature[], ClassLoader loader)
         throws ReflectionException, MBeanException {
-        // Instantiate the new object
 
+        checkMBeanPermission(theClass, null, null, "instantiate");
+
+        // Instantiate the new object
         // ------------------------------
         // ------------------------------
         final Class<?>[] tab;
@@ -291,6 +300,7 @@
         }
         try {
             ReflectUtil.checkPackageAccess(theClass);
+            ensureClassAccess(theClass);
             moi = cons.newInstance(params);
         }
         catch (NoSuchMethodError error) {
@@ -407,6 +417,8 @@
             throw new  RuntimeOperationsException(new
              IllegalArgumentException(), "Null className passed in parameter");
         }
+
+        ReflectUtil.checkPackageAccess(className);
         Class<?> theClass;
         if (loaderName == null) {
             // Load the class using the agent class loader
@@ -619,13 +631,13 @@
      **/
     static Class<?> loadClass(String className, ClassLoader loader)
         throws ReflectionException {
-
         Class<?> theClass;
         if (className == null) {
             throw new RuntimeOperationsException(new
                 IllegalArgumentException("The class name cannot be null"),
                               "Exception occurred during object instantiation");
         }
+        ReflectUtil.checkPackageAccess(className);
         try {
             if (loader == null)
                 loader = MBeanInstantiator.class.getClassLoader();
@@ -676,6 +688,7 @@
                 // We need to load the class through the class
                 // loader of the target object.
                 //
+                ReflectUtil.checkPackageAccess(signature[i]);
                 tab[i] = Class.forName(signature[i], false, aLoader);
             }
         } catch (ClassNotFoundException e) {
@@ -701,7 +714,7 @@
 
     private Constructor<?> findConstructor(Class<?> c, Class<?>[] params) {
         try {
-            return c.getConstructor(params);
+            return ConstructorUtil.getConstructor(c, params);
         } catch (Exception e) {
             return null;
         }
@@ -715,4 +728,27 @@
                                           char.class, boolean.class})
             primitiveClasses.put(c.getName(), c);
     }
+
+    private static void checkMBeanPermission(Class<?> clazz,
+                                             String member,
+                                             ObjectName objectName,
+                                             String actions) {
+        SecurityManager sm = System.getSecurityManager();
+        if (clazz != null && sm != null) {
+            Permission perm = new MBeanPermission(clazz.getName(),
+                                                  member,
+                                                  objectName,
+                                                  actions);
+            sm.checkPermission(perm);
+        }
+    }
+
+    private static void ensureClassAccess(Class clazz)
+            throws IllegalAccessException
+    {
+        int mod = clazz.getModifiers();
+        if (!Modifier.isPublic(mod)) {
+            throw new IllegalAccessException("Class is not public and can't be instantiated");
+        }
+    }
 }
--- jdk/src/share/classes/com/sun/jmx/mbeanserver/MBeanSupport.java	2012-08-10 10:24:19.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/mbeanserver/MBeanSupport.java	2013-05-05 09:38:36.000000000 -0700
@@ -38,6 +38,7 @@
 import javax.management.ObjectName;
 import javax.management.ReflectionException;
 import com.sun.jmx.mbeanserver.MXBeanMappingFactory;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * Base class for MBeans.  There is one instance of this class for
@@ -131,6 +132,7 @@
                 " is not an instance of " + mbeanInterfaceType.getName();
             throw new NotCompliantMBeanException(msg);
         }
+        ReflectUtil.checkPackageAccess(mbeanInterfaceType);
         this.resource = resource;
         MBeanIntrospector<M> introspector = getMBeanIntrospector();
         this.perInterface = introspector.getPerInterface(mbeanInterfaceType);
--- jdk/src/share/classes/com/sun/jmx/remote/internal/ServerNotifForwarder.java	2012-08-10 10:24:20.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/remote/internal/ServerNotifForwarder.java	2013-05-05 09:38:36.000000000 -0700
@@ -68,9 +68,9 @@
         this.notifBuffer = notifBuffer;
         this.connectionId = connectionId;
         connectionTimeout = EnvHelp.getServerConnectionTimeout(env);
-        checkNotificationEmission = EnvHelp.computeBooleanFromString(
-            env,
-            "jmx.remote.x.check.notification.emission",false);
+
+        String stringBoolean = (String) env.get("jmx.remote.x.check.notification.emission");
+        checkNotificationEmission = EnvHelp.computeBooleanFromString( stringBoolean );
         notificationAccessController =
                 EnvHelp.getNotificationAccessController(env);
     }
--- jdk/src/share/classes/com/sun/jmx/remote/util/EnvHelp.java	2012-08-10 10:24:20.000000000 -0700
+++ jdk/src/share/classes/com/sun/jmx/remote/util/EnvHelp.java	2013-05-05 09:38:36.000000000 -0700
@@ -665,97 +665,57 @@
      * Computes a boolean value from a string value retrieved from a
      * property in the given map.
      *
-     * @param env the environment map.
-     * @param prop the name of the property in the environment map whose
-     * returned string value must be converted into a boolean value.
-     * @param systemProperty if true, consult a system property of the
-     * same name if there is no entry in the environment map.
+     * @param stringBoolean the string value that must be converted
+     * into a boolean value.
      *
      * @return
      *   <ul>
-     *   <li>{@code false} if {@code env.get(prop)} is {@code null}</li>
+     *   <li>{@code false} if {@code stringBoolean} is {@code null}</li>
      *   <li>{@code false} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("false")}
+     *       {@code stringBoolean.equalsIgnoreCase("false")}
      *       is {@code true}</li>
      *   <li>{@code true} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("true")}
+     *       {@code stringBoolean.equalsIgnoreCase("true")}
      *       is {@code true}</li>
      *   </ul>
      *
-     * @throws IllegalArgumentException if {@code env} is {@code null} or
-     * {@code env.get(prop)} is not {@code null} and
+     * @throws IllegalArgumentException if
      * {@code ((String)env.get(prop)).equalsIgnoreCase("false")} and
      * {@code ((String)env.get(prop)).equalsIgnoreCase("true")} are
      * {@code false}.
-     * @throws ClassCastException if {@code env.get(prop)} cannot be cast
-     * to {@code String}.
      */
-    public static boolean computeBooleanFromString(
-            Map<String, ?> env, String prop, boolean systemProperty) {
-
-        if (env == null)
-            throw new IllegalArgumentException("env map cannot be null");
-
+    public static boolean computeBooleanFromString(String stringBoolean) {
         // returns a default value of 'false' if no property is found...
-        return computeBooleanFromString(env,prop,systemProperty,false);
+        return computeBooleanFromString(stringBoolean,false);
     }
 
     /**
      * Computes a boolean value from a string value retrieved from a
      * property in the given map.
      *
-     * @param env the environment map.
-     * @param prop the name of the property in the environment map whose
-     * returned string value must be converted into a boolean value.
-     * @param systemProperty if true, consult a system property of the
-     * same name if there is no entry in the environment map.
+     * @param stringBoolean the string value that must be converted
+     * into a boolean value.
      * @param defaultValue a default value to return in case no property
      *        was defined.
      *
      * @return
      *   <ul>
-     *   <li>{@code defaultValue} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code false}</li>
-     *   <li>{@code defaultValue} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code true} and
-     *       {@code System.getProperty(prop)} is {@code null}</li>
-     *   <li>{@code false} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code true} and
-     *       {@code System.getProperty(prop).equalsIgnoreCase("false")}
-     *       is {@code true}</li>
-     *   <li>{@code true} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code true} and
-     *       {@code System.getProperty(prop).equalsIgnoreCase("true")}
-     *       is {@code true}</li>
+     *   <li>{@code defaultValue} if {@code stringBoolean}
+     *   is {@code null}</li>
      *   <li>{@code false} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("false")}
+     *       {@code stringBoolean.equalsIgnoreCase("false")}
      *       is {@code true}</li>
      *   <li>{@code true} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("true")}
+     *       {@code stringBoolean.equalsIgnoreCase("true")}
      *       is {@code true}</li>
      *   </ul>
      *
-     * @throws IllegalArgumentException if {@code env} is {@code null} or
-     * {@code env.get(prop)} is not {@code null} and
+     * @throws IllegalArgumentException if
      * {@code ((String)env.get(prop)).equalsIgnoreCase("false")} and
      * {@code ((String)env.get(prop)).equalsIgnoreCase("true")} are
      * {@code false}.
-     * @throws ClassCastException if {@code env.get(prop)} cannot be cast
-     * to {@code String}.
      */
-    public static boolean computeBooleanFromString(
-            Map<String, ?> env, String prop,
-            boolean systemProperty, boolean defaultValue) {
-
-        if (env == null)
-            throw new IllegalArgumentException("env map cannot be null");
-
-        String stringBoolean = (String) env.get(prop);
-        if (stringBoolean == null && systemProperty) {
-            stringBoolean =
-                    AccessController.doPrivileged(new GetPropertyAction(prop));
-        }
-
+    public static boolean computeBooleanFromString( String stringBoolean, boolean defaultValue) {
         if (stringBoolean == null)
             return defaultValue;
         else if (stringBoolean.equalsIgnoreCase("true"))
@@ -763,8 +723,8 @@
         else if (stringBoolean.equalsIgnoreCase("false"))
             return false;
         else
-            throw new IllegalArgumentException(prop +
-                " must be \"true\" or \"false\" instead of \"" +
+            throw new IllegalArgumentException(
+                "Property value must be \"true\" or \"false\" instead of \"" +
                 stringBoolean + "\"");
     }
 
--- jdk/src/share/classes/com/sun/jndi/ldap/Connection.java	2012-08-10 10:24:27.000000000 -0700
+++ jdk/src/share/classes/com/sun/jndi/ldap/Connection.java	2013-05-05 09:38:36.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -685,11 +685,9 @@
                         ldr = ldr.next;
                     }
                 }
+                parent.processConnectionClosure();
             }
         }
-        if (nparent) {
-            parent.processConnectionClosure();
-        }
     }
 
 
--- jdk/src/share/classes/com/sun/jndi/ldap/LdapClient.java	2012-08-10 10:24:27.000000000 -0700
+++ jdk/src/share/classes/com/sun/jndi/ldap/LdapClient.java	2013-05-05 09:38:36.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -487,16 +487,14 @@
      */
     void processConnectionClosure() {
         // Notify listeners
-        synchronized (unsolicited) {
-            if (unsolicited.size() > 0) {
-                String msg;
-                if (conn != null) {
-                    msg = conn.host + ":" + conn.port + " connection closed";
-                } else {
-                    msg = "Connection closed";
-                }
-                notifyUnsolicited(new CommunicationException(msg));
+        if (unsolicited.size() > 0) {
+            String msg;
+            if (conn != null) {
+                msg = conn.host + ":" + conn.port + " connection closed";
+            } else {
+                msg = "Connection closed";
             }
+            notifyUnsolicited(new CommunicationException(msg));
         }
 
         // Remove from pool
--- jdk/src/share/classes/com/sun/media/sound/AbstractMidiDevice.java	2012-08-10 10:24:31.000000000 -0700
+++ jdk/src/share/classes/com/sun/media/sound/AbstractMidiDevice.java	2013-05-05 09:38:36.000000000 -0700
@@ -56,7 +56,7 @@
     // from simultaneous creation and destruction
     // reduces possibility of deadlock, compared to
     // synchronizing to the class instance
-    private Object traRecLock = new Object();
+    private final Object traRecLock = new Object();
 
     // DEVICE ATTRIBUTES
 
@@ -474,7 +474,7 @@
         This is necessary for Receivers retrieved via MidiSystem.getReceiver()
         (which opens the device implicitely).
      */
-    protected abstract class AbstractReceiver implements MidiDeviceReceiver {
+    abstract class AbstractReceiver implements MidiDeviceReceiver {
         private boolean open = true;
 
 
@@ -483,24 +483,24 @@
             Receiver. Therefore, subclasses should not override this method.
             Instead, they should implement implSend().
         */
-        public synchronized void send(MidiMessage message, long timeStamp) {
-            if (open) {
-                implSend(message, timeStamp);
-            } else {
+        @Override
+        public final synchronized void send(final MidiMessage message,
+                                            final long timeStamp) {
+            if (!open) {
                 throw new IllegalStateException("Receiver is not open");
             }
+            implSend(message, timeStamp);
         }
 
-
-        protected abstract void implSend(MidiMessage message, long timeStamp);
-
+        abstract void implSend(MidiMessage message, long timeStamp);
 
         /** Close the Receiver.
          * Here, the call to the magic method closeInternal() takes place.
          * Therefore, subclasses that override this method must call
          * 'super.close()'.
          */
-        public void close() {
+        @Override
+        public final void close() {
             open = false;
             synchronized (AbstractMidiDevice.this.traRecLock) {
                 AbstractMidiDevice.this.getReceiverList().remove(this);
@@ -508,11 +508,12 @@
             AbstractMidiDevice.this.closeInternal(this);
         }
 
-        public MidiDevice getMidiDevice() {
+        @Override
+        public final MidiDevice getMidiDevice() {
             return AbstractMidiDevice.this;
         }
 
-        protected boolean isOpen() {
+        final boolean isOpen() {
             return open;
         }
 
--- jdk/src/share/classes/com/sun/media/sound/FastShortMessage.java	2012-08-10 10:24:31.000000000 -0700
+++ jdk/src/share/classes/com/sun/media/sound/FastShortMessage.java	2013-05-05 09:38:36.000000000 -0700
@@ -32,7 +32,7 @@
  *
  * @author Florian Bomers
  */
-class FastShortMessage extends ShortMessage {
+final class FastShortMessage extends ShortMessage {
     private int packedMsg;
 
     public FastShortMessage(int packedMsg) throws InvalidMidiDataException {
--- jdk/src/share/classes/com/sun/media/sound/FastSysexMessage.java	2012-08-10 10:24:31.000000000 -0700
+++ jdk/src/share/classes/com/sun/media/sound/FastSysexMessage.java	2013-05-05 09:38:36.000000000 -0700
@@ -32,7 +32,7 @@
  *
  * @author Florian Bomers
  */
-class FastSysexMessage extends SysexMessage {
+final class FastSysexMessage extends SysexMessage {
 
     FastSysexMessage(byte[] data) throws InvalidMidiDataException {
         super(data);
--- jdk/src/share/classes/com/sun/media/sound/MidiOutDevice.java	2012-08-10 10:24:32.000000000 -0700
+++ jdk/src/share/classes/com/sun/media/sound/MidiOutDevice.java	2013-05-05 09:38:36.000000000 -0700
@@ -103,9 +103,9 @@
 
     class MidiOutReceiver extends AbstractReceiver {
 
-        protected void implSend(MidiMessage message, long timeStamp) {
-            int length = message.getLength();
-            int status = message.getStatus();
+        void implSend(final MidiMessage message, final long timeStamp) {
+            final int length = message.getLength();
+            final int status = message.getStatus();
             if (length <= 3 && status != 0xF0 && status != 0xF7) {
                 int packedMsg;
                 if (message instanceof ShortMessage) {
@@ -140,11 +140,15 @@
                 }
                 nSendShortMessage(id, packedMsg, timeStamp);
             } else {
+                final byte[] data;
                 if (message instanceof FastSysexMessage) {
-                    nSendLongMessage(id, ((FastSysexMessage) message).getReadOnlyMessage(),
-                                     length, timeStamp);
+                    data = ((FastSysexMessage) message).getReadOnlyMessage();
                 } else {
-                    nSendLongMessage(id, message.getMessage(), length, timeStamp);
+                    data = message.getMessage();
+                }
+                final int dataLength = Math.min(length, data.length);
+                if (dataLength > 0) {
+                    nSendLongMessage(id, data, dataLength, timeStamp);
                 }
             }
         }
--- jdk/src/share/classes/com/sun/media/sound/RealTimeSequencer.java	2012-08-10 10:24:35.000000000 -0700
+++ jdk/src/share/classes/com/sun/media/sound/RealTimeSequencer.java	2013-05-05 09:38:36.000000000 -0700
@@ -1026,7 +1026,7 @@
 
     class SequencerReceiver extends AbstractReceiver {
 
-        protected void implSend(MidiMessage message, long timeStamp) {
+        void implSend(MidiMessage message, long timeStamp) {
             if (recording) {
                 long tickPos = 0;
 
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/Init.java	2012-08-10 10:25:05.000000000 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/Init.java	2013-05-05 09:38:37.000000000 -0700
@@ -154,7 +154,7 @@
                 }
             }
                         for (Node el=config.getFirstChild();el!=null;el=el.getNextSibling()) {
-                if (!(el instanceof Element)) {
+                if (el.getNodeType() != Node.ELEMENT_NODE) {
                         continue;
                 }
                 String tag=el.getLocalName();
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/c14n/implementations/CanonicalizerBase.java	2012-08-10 10:25:07.000000000 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/c14n/implementations/CanonicalizerBase.java	2013-05-05 09:38:36.000000000 -0700
@@ -202,7 +202,7 @@
         try {
          NameSpaceSymbTable ns=new NameSpaceSymbTable();
          int nodeLevel=NODE_BEFORE_DOCUMENT_ELEMENT;
-         if (rootNode instanceof Element) {
+         if (rootNode != null && rootNode.getNodeType() == Node.ELEMENT_NODE) {
                 //Fills the nssymbtable with the definitions of the parent of the root subnode
                 getParentNameSpaces((Element)rootNode,ns);
                 nodeLevel=NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;
@@ -332,7 +332,7 @@
                                 return;
                         sibling=parentNode.getNextSibling();
                         parentNode=parentNode.getParentNode();
-                        if (!(parentNode instanceof Element)) {
+                        if (parentNode !=null && parentNode.getNodeType() != Node.ELEMENT_NODE) {
                                 documentLevel=NODE_AFTER_DOCUMENT_ELEMENT;
                                 parentNode=null;
                         }
@@ -388,7 +388,7 @@
                 return;
         boolean currentNodeIsVisible = false;
         NameSpaceSymbTable ns=new  NameSpaceSymbTable();
-        if (currentNode instanceof Element)
+        if (currentNode != null && currentNode.getNodeType() == Node.ELEMENT_NODE)
                 getParentNameSpaces((Element)currentNode,ns);
         Node sibling=null;
         Node parentNode=null;
@@ -509,7 +509,7 @@
                                 return;
                         sibling=parentNode.getNextSibling();
                         parentNode=parentNode.getParentNode();
-                        if (!(parentNode instanceof Element)) {
+                        if (parentNode != null && parentNode.getNodeType() != Node.ELEMENT_NODE) {
                                 parentNode=null;
                                 documentLevel=NODE_AFTER_DOCUMENT_ELEMENT;
                         }
@@ -591,18 +591,14 @@
         final void getParentNameSpaces(Element el,NameSpaceSymbTable ns)  {
                 List parents=new ArrayList(10);
                 Node n1=el.getParentNode();
-                if (!(n1 instanceof Element)) {
+                if (n1 == null || n1.getNodeType() != Node.ELEMENT_NODE) {
                         return;
                 }
                 //Obtain all the parents of the elemnt
-                Element parent=(Element) n1;
-                while (parent!=null) {
-                        parents.add(parent);
-                        Node n=parent.getParentNode();
-                        if (!(n instanceof Element )) {
-                                break;
-                        }
-                        parent=(Element)n;
+                Node parent = n1;
+                while (parent!=null && parent.getNodeType() == Node.ELEMENT_NODE) {
+                        parents.add((Element)parent);
+                        parent = parent.getParentNode();
                 }
                 //Visit them in reverse order.
                 ListIterator it=parents.listIterator(parents.size());
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/encryption/XMLCipher.java	2012-08-10 10:25:08.000000000 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/encryption/XMLCipher.java	2013-05-05 09:38:36.000000000 -0700
@@ -1445,7 +1445,7 @@
                 // The de-serialiser returns a fragment whose children we need to
                 // take on.
 
-                if (sourceParent instanceof Document) {
+                if (sourceParent != null && sourceParent.getNodeType() == Node.DOCUMENT_NODE) {
 
                     // If this is a content decryption, this may have problems
 
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/implementations/RetrievalMethodResolver.java	2012-08-10 10:25:22.000000000 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/implementations/RetrievalMethodResolver.java	2013-05-05 09:38:36.000000000 -0700
@@ -283,7 +283,7 @@
            Element e=null;
            while (it.hasNext()) {
                    Node currentNode=(Node)it.next();
-                   if (currentNode instanceof Element) {
+                   if (currentNode != null && currentNode.getNodeType() == Node.ELEMENT_NODE) {
                            e=(Element)currentNode;
                            break;
                    }
@@ -292,14 +292,14 @@
            List parents=new ArrayList(10);
 
                 //Obtain all the parents of the elemnt
-                do {
+                while (e != null) {
                         parents.add(e);
                         Node n=e.getParentNode();
-                        if (!(n instanceof Element )) {
+                        if (n == null || n.getNodeType() != Node.ELEMENT_NODE) {
                                 break;
                         }
                         e=(Element)n;
-                } while (e!=null);
+                }
                 //Visit them in reverse order.
                 ListIterator it2=parents.listIterator(parents.size()-1);
                 Element ele=null;
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/IdResolver.java	2012-08-10 10:25:34.000000000 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/IdResolver.java	2013-05-05 09:38:37.000000000 -0700
@@ -223,7 +223,7 @@
         } while (sibling==null  && parentNode!=null) {
                         sibling=parentNode.getNextSibling();
                         parentNode=parentNode.getParentNode();
-                        if (!(parentNode instanceof Element)) {
+                        if (parentNode != null && parentNode.getNodeType() != Node.ELEMENT_NODE) {
                                 parentNode=null;
                         }
                 }
--- jdk/src/share/classes/com/sun/script/javascript/RhinoScriptEngine.java	2012-08-10 10:25:37.000000000 -0700
+++ jdk/src/share/classes/com/sun/script/javascript/RhinoScriptEngine.java	2013-05-05 09:38:37.000000000 -0700
@@ -146,7 +146,11 @@
      */
     public RhinoScriptEngine() {
         if (System.getSecurityManager() != null) {
-            accCtxt = AccessController.getContext();
+            try {
+                AccessController.checkPermission(new AllPermission());
+            } catch (AccessControlException ace) {
+                accCtxt = AccessController.getContext();
+            }
         }
 
         Context cx = enterContext();
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic.properties	2013-05-05 09:38:37.000000000 -0700
@@ -71,9 +71,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=FileChooser help
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=Open selected directory
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Preview
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_de.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_de.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=FileChooser-Hilfe
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=Ausgew\u00E4hltes Verzeichnis \u00F6ffnen
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Vorschau
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_es.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_es.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=Ayuda del Selector de Archivos
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=Abrir directorio seleccionado
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Vista Previa
 ColorChooser.ok.textAndMnemonic=Aceptar
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_fr.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_fr.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=Aide du s\u00E9lecteur de fichiers
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=Ouvre le r\u00E9pertoire s\u00E9lectionn\u00E9
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Aper\u00E7u
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_it.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_it.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=Guida FileChooser
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=Apre la directory selezionata
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Anteprima
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_ja.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_ja.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=FileChooser\u306E\u30D8\u30EB\u30D7\u3067\u3059
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=\u9078\u629E\u3057\u305F\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u3092\u958B\u304D\u307E\u3059
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=\u30D7\u30EC\u30D3\u30E5\u30FC
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_ko.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_ko.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=FileChooser \uB3C4\uC6C0\uB9D0
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=\uC120\uD0DD\uB41C \uB514\uB809\uD1A0\uB9AC \uC5F4\uAE30
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=\uBBF8\uB9AC\uBCF4\uAE30
 ColorChooser.ok.textAndMnemonic=\uD655\uC778
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_pt_BR.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_pt_BR.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=Ajuda do FileChooser
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=Abrir diret\u00F3rio selecionado
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Visualizar
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_sv.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_sv.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=Hj\u00E4lp - Filv\u00E4ljare
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=\u00D6ppna vald katalog
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=Granska
 ColorChooser.ok.textAndMnemonic=OK
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_zh_CN.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_zh_CN.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=FileChooser \u5E2E\u52A9
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=\u6253\u5F00\u9009\u62E9\u7684\u76EE\u5F55
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=\u9884\u89C8
 ColorChooser.ok.textAndMnemonic=\u786E\u5B9A
--- jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_zh_TW.properties	2012-08-10 10:25:42.000000000 -0700
+++ jdk/src/share/classes/com/sun/swing/internal/plaf/basic/resources/basic_zh_TW.properties	2013-05-05 09:38:37.000000000 -0700
@@ -70,9 +70,6 @@
 FileChooser.helpButtonToolTip.textAndMnemonic=\u300C\u6A94\u6848\u9078\u64C7\u5668\u300D\u8AAA\u660E
 FileChooser.directoryOpenButtonToolTip.textAndMnemonic=\u958B\u555F\u9078\u53D6\u7684\u76EE\u9304
 
-FileChooser.filesListAccessibleName=Files List
-FileChooser.filesDetailsAccessibleName=Files Details
-
 ############ COLOR CHOOSER STRINGS #############
 ColorChooser.preview.textAndMnemonic=\u9810\u89BD
 ColorChooser.ok.textAndMnemonic=\u78BA\u5B9A
--- jdk/src/share/classes/java/awt/AWTEvent.java	2012-08-10 10:25:54.000000000 -0700
+++ jdk/src/share/classes/java/awt/AWTEvent.java	2013-05-05 09:38:32.000000000 -0700
@@ -35,8 +35,6 @@
 
 import java.security.AccessControlContext;
 import java.security.AccessController;
-import java.io.ObjectInputStream;
-import java.io.IOException;
 
 /**
  * The root event class for all AWT events.
@@ -262,9 +260,11 @@
                 public void setPosted(AWTEvent ev) {
                     ev.isPosted = true;
                 }
+
                 public void setSystemGenerated(AWTEvent ev) {
                     ev.isSystemGenerated = true;
                 }
+
                 public boolean isSystemGenerated(AWTEvent ev) {
                     return ev.isSystemGenerated;
                 }
@@ -272,6 +272,15 @@
                 public AccessControlContext getAccessControlContext(AWTEvent ev) {
                     return ev.getAccessControlContext();
                 }
+
+                public byte[] getBData(AWTEvent ev) {
+                    return ev.bdata;
+                }
+
+                public void setBData(AWTEvent ev, byte[] bdata) {
+                    ev.bdata = bdata;
+                }
+
             });
     }
 
--- jdk/src/share/classes/java/awt/CheckboxMenuItem.java	2012-08-10 10:25:54.000000000 -0700
+++ jdk/src/share/classes/java/awt/CheckboxMenuItem.java	2013-05-05 09:38:32.000000000 -0700
@@ -31,6 +31,7 @@
 import java.io.ObjectInputStream;
 import java.io.IOException;
 import javax.accessibility.*;
+import sun.awt.AWTAccessor;
 
 
 /**
@@ -68,6 +69,13 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setCheckboxMenuItemAccessor(
+            new AWTAccessor.CheckboxMenuItemAccessor() {
+                public boolean getState(CheckboxMenuItem cmi) {
+                    return cmi.state;
+                }
+            });
     }
 
    /**
--- jdk/src/share/classes/java/awt/Cursor.java	2012-08-10 10:25:55.000000000 -0700
+++ jdk/src/share/classes/java/awt/Cursor.java	2013-05-05 09:38:32.000000000 -0700
@@ -24,10 +24,6 @@
  */
 package java.awt;
 
-import java.awt.AWTException;
-import java.awt.Point;
-import java.awt.Toolkit;
-
 import java.io.File;
 import java.io.FileInputStream;
 
@@ -39,6 +35,7 @@
 import java.security.AccessController;
 
 import sun.util.logging.PlatformLogger;
+import sun.awt.AWTAccessor;
 
 /**
  * A class to encapsulate the bitmap representation of the mouse cursor.
@@ -199,6 +196,21 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setCursorAccessor(
+            new AWTAccessor.CursorAccessor() {
+                public long getPData(Cursor cursor) {
+                    return cursor.pData;
+                }
+
+                public void setPData(Cursor cursor, long pData) {
+                    cursor.pData = pData;
+                }
+
+                public int getType(Cursor cursor) {
+                    return cursor.type;
+                }
+            });
     }
 
     /**
--- jdk/src/share/classes/java/awt/DefaultKeyboardFocusManager.java	2012-08-10 10:25:55.000000000 -0700
+++ jdk/src/share/classes/java/awt/DefaultKeyboardFocusManager.java	2013-05-05 09:38:32.000000000 -0700
@@ -39,6 +39,7 @@
 
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 import sun.awt.CausedFocusEvent;
 
 /**
@@ -75,6 +76,15 @@
         typeAheadMarkers = new LinkedList();
     private boolean consumeNextKeyTyped;
 
+    static {
+        AWTAccessor.setDefaultKeyboardFocusManagerAccessor(
+            new AWTAccessor.DefaultKeyboardFocusManagerAccessor() {
+                public void consumeNextKeyTyped(DefaultKeyboardFocusManager dkfm, KeyEvent e) {
+                    dkfm.consumeNextKeyTyped(e);
+                }
+            });
+    }
+
     private static class TypeAheadMarker {
         long after;
         Component untilFocused;
--- jdk/src/share/classes/java/awt/Dialog.java	2012-08-10 10:25:55.000000000 -0700
+++ jdk/src/share/classes/java/awt/Dialog.java	2013-05-05 09:38:32.000000000 -0700
@@ -39,6 +39,7 @@
 import sun.awt.util.IdentityArrayList;
 import sun.awt.util.IdentityLinkedList;
 import sun.security.util.SecurityConstants;
+import java.security.AccessControlException;
 
 /**
  * A Dialog is a top-level window with a title and a border
@@ -128,6 +129,8 @@
      */
     boolean undecorated = false;
 
+    private transient boolean initialized = false;
+
     /**
      * Modal dialogs block all input to some top-level windows.
      * Whether a particular window is blocked depends on dialog's type
@@ -671,6 +674,7 @@
         this.title = title;
         setModalityType(modalityType);
         SunToolkit.checkAndSetPolicy(this);
+        initialized = true;
     }
 
     /**
@@ -722,6 +726,7 @@
         this.title = title;
         setModalityType(modalityType);
         SunToolkit.checkAndSetPolicy(this);
+        initialized = true;
     }
 
     /**
@@ -851,12 +856,9 @@
         if (modalityType == type) {
             return;
         }
-        if (type == ModalityType.TOOLKIT_MODAL) {
-            SecurityManager sm = System.getSecurityManager();
-            if (sm != null) {
-                sm.checkPermission(SecurityConstants.AWT.TOOLKIT_MODALITY_PERMISSION);
-            }
-        }
+
+        checkModalityPermission(type);
+
         modalityType = type;
         modal = (modalityType != ModalityType.MODELESS);
     }
@@ -1025,6 +1027,9 @@
      */
     @Deprecated
     public void show() {
+        if (!initialized) throw new IllegalStateException(
+            "The dialog component has not been initialized properly");
+
         beforeFirstShow = false;
         if (!isModal()) {
             conditionalShow(null, null);
@@ -1600,18 +1605,51 @@
         }
     }
 
+    private void checkModalityPermission(ModalityType mt) {
+        if (mt == ModalityType.TOOLKIT_MODAL) {
+            SecurityManager sm = System.getSecurityManager();
+            if (sm != null) {
+                sm.checkPermission(
+                    SecurityConstants.AWT.TOOLKIT_MODALITY_PERMISSION
+                );
+            }
+        }
+    }
+
     private void readObject(ObjectInputStream s)
         throws ClassNotFoundException, IOException, HeadlessException
     {
         GraphicsEnvironment.checkHeadless();
-        s.defaultReadObject();
+
+        java.io.ObjectInputStream.GetField fields =
+                    s.readFields();
+
+        ModalityType localModalityType = (ModalityType)fields.get("modalityType", null);
+
+        try {
+            checkModalityPermission(localModalityType);
+        } catch (AccessControlException ace) {
+            localModalityType = DEFAULT_MODALITY_TYPE;
+        }
 
         // in 1.5 or earlier modalityType was absent, so use "modal" instead
-        if (modalityType == null) {
+        if (localModalityType == null) {
+            this.modal = fields.get("modal", false);
             setModal(modal);
+        } else {
+            this.modalityType = localModalityType;
         }
 
+        this.resizable = fields.get("resizable", true);
+        this.undecorated = fields.get("undecorated", false);
+        this.title = (String)fields.get("title", "");
+
         blockedWindows = new IdentityArrayList();
+
+        SunToolkit.checkAndSetPolicy(this);
+
+        initialized = true;
+
     }
 
     /*
--- jdk/src/share/classes/java/awt/EventDispatchThread.java	2012-08-10 10:25:55.000000000 -0700
+++ jdk/src/share/classes/java/awt/EventDispatchThread.java	2013-05-05 09:38:32.000000000 -0700
@@ -67,8 +67,7 @@
     private static final PlatformLogger eventLog = PlatformLogger.getLogger("java.awt.event.EventDispatchThread");
 
     private EventQueue theQueue;
-    private boolean doDispatch = true;
-    private volatile boolean shutdown = false;
+    private volatile boolean doDispatch = true;
 
     private static final int ANY_EVENT = -1;
 
@@ -86,11 +85,6 @@
         doDispatch = false;
     }
 
-    public void interrupt() {
-        shutdown = true;
-        super.interrupt();
-    }
-
     public void run() {
         while (true) {
             try {
@@ -100,7 +94,12 @@
                     }
                 });
             } finally {
-                if(getEventQueue().detachDispatchThread(this, shutdown)) {
+                // 7189350: doDispatch is reset from stopDispatching(),
+                //    on InterruptedException, or ThreadDeath. Either way,
+                //    this indicates that we must force shutting down.
+                if (getEventQueue().detachDispatchThread(this,
+                            !doDispatch || isInterrupted()))
+                {
                     break;
                 }
             }
@@ -158,8 +157,7 @@
     void pumpEventsForFilter(int id, Conditional cond, EventFilter filter) {
         addEventFilter(filter);
         doDispatch = true;
-        shutdown |= isInterrupted();
-        while (doDispatch && !shutdown && cond.evaluate()) {
+        while (doDispatch && !isInterrupted() && cond.evaluate()) {
             pumpOneEventForFilters(id);
         }
         removeEventFilter(filter);
@@ -247,12 +245,12 @@
             }
         }
         catch (ThreadDeath death) {
-            shutdown = true;
+            doDispatch = false;
             throw death;
         }
         catch (InterruptedException interruptedException) {
-            shutdown = true; // AppContext.dispose() interrupts all
-                             // Threads in the AppContext
+            doDispatch = false; // AppContext.dispose() interrupts all
+                                // Threads in the AppContext
         }
         catch (Throwable e) {
             processException(e);
--- jdk/src/share/classes/java/awt/EventQueue.java	2012-08-10 10:25:55.000000000 -0700
+++ jdk/src/share/classes/java/awt/EventQueue.java	2013-05-05 09:38:32.000000000 -0700
@@ -52,7 +52,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import java.security.AccessControlContext;
-import java.security.ProtectionDomain;
 
 import sun.misc.SharedSecrets;
 import sun.misc.JavaSecurityAccess;
@@ -188,6 +187,23 @@
                 public boolean isDispatchThreadImpl(EventQueue eventQueue) {
                     return eventQueue.isDispatchThreadImpl();
                 }
+                public void removeSourceEvents(EventQueue eventQueue,
+                                               Object source,
+                                               boolean removeAllEvents)
+                {
+                    eventQueue.removeSourceEvents(source, removeAllEvents);
+                }
+                public boolean noEvents(EventQueue eventQueue) {
+                    return eventQueue.noEvents();
+                }
+                public void wakeup(EventQueue eventQueue, boolean isShutdown) {
+                    eventQueue.wakeup(isShutdown);
+                }
+                public void invokeAndWait(Object source, Runnable r)
+                    throws InterruptedException, InvocationTargetException
+                {
+                    EventQueue.invokeAndWait(source, r);
+                }
             });
     }
 
@@ -1223,8 +1239,14 @@
      * @since           1.2
      */
     public static void invokeAndWait(Runnable runnable)
-             throws InterruptedException, InvocationTargetException {
+        throws InterruptedException, InvocationTargetException
+    {
+        invokeAndWait(Toolkit.getDefaultToolkit(), runnable);
+    }
 
+    static void invokeAndWait(Object source, Runnable runnable)
+        throws InterruptedException, InvocationTargetException
+    {
         if (EventQueue.isDispatchThread()) {
             throw new Error("Cannot call invokeAndWait from the event dispatcher thread");
         }
@@ -1233,8 +1255,7 @@
         Object lock = new AWTInvocationLock();
 
         InvocationEvent event =
-            new InvocationEvent(Toolkit.getDefaultToolkit(), runnable, lock,
-                                true);
+            new InvocationEvent(source, runnable, lock, true);
 
         synchronized (lock) {
             Toolkit.getEventQueue().postEvent(event);
--- jdk/src/share/classes/java/awt/KeyboardFocusManager.java	2012-08-10 10:25:56.000000000 -0700
+++ jdk/src/share/classes/java/awt/KeyboardFocusManager.java	2013-05-05 09:38:32.000000000 -0700
@@ -56,7 +56,6 @@
 import sun.util.logging.PlatformLogger;
 
 import sun.awt.AppContext;
-import sun.awt.HeadlessToolkit;
 import sun.awt.SunToolkit;
 import sun.awt.CausedFocusEvent;
 import sun.awt.KeyboardFocusManagerPeerProvider;
@@ -148,6 +147,9 @@
                 public KeyboardFocusManager getCurrentKeyboardFocusManager(AppContext ctx) {
                     return KeyboardFocusManager.getCurrentKeyboardFocusManager(ctx);
                 }
+                public Container getCurrentFocusCycleRoot() {
+                    return KeyboardFocusManager.currentFocusCycleRoot;
+                }
             }
         );
     }
--- jdk/src/share/classes/java/awt/Menu.java	2012-08-10 10:25:56.000000000 -0700
+++ jdk/src/share/classes/java/awt/Menu.java	2013-05-05 09:38:32.000000000 -0700
@@ -31,6 +31,7 @@
 import java.awt.peer.MenuPeer;
 import java.awt.event.KeyEvent;
 import javax.accessibility.*;
+import sun.awt.AWTAccessor;
 
 /**
  * A <code>Menu</code> object is a pull-down menu component
@@ -62,6 +63,13 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setMenuAccessor(
+            new AWTAccessor.MenuAccessor() {
+                public Vector getItems(Menu menu) {
+                    return menu.items;
+                }
+            });
     }
 
     /**
--- jdk/src/share/classes/java/awt/MenuBar.java	2012-08-10 10:25:56.000000000 -0700
+++ jdk/src/share/classes/java/awt/MenuBar.java	2013-05-05 09:38:32.000000000 -0700
@@ -28,6 +28,7 @@
 import java.io.ObjectInputStream;
 import java.util.Vector;
 import java.util.Enumeration;
+import sun.awt.AWTAccessor;
 import java.awt.peer.MenuBarPeer;
 import java.awt.event.KeyEvent;
 import javax.accessibility.*;
@@ -74,6 +75,16 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+        AWTAccessor.setMenuBarAccessor(
+            new AWTAccessor.MenuBarAccessor() {
+                public Menu getHelpMenu(MenuBar menuBar) {
+                    return menuBar.helpMenu;
+                }
+
+                public Vector getMenus(MenuBar menuBar) {
+                    return menuBar.menus;
+                }
+            });
     }
 
     /**
--- jdk/src/share/classes/java/awt/MenuComponent.java	2012-08-10 10:25:56.000000000 -0700
+++ jdk/src/share/classes/java/awt/MenuComponent.java	2013-05-05 09:38:32.000000000 -0700
@@ -29,7 +29,6 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import sun.awt.AppContext;
-import sun.awt.SunToolkit;
 import sun.awt.AWTAccessor;
 import javax.accessibility.*;
 
@@ -143,6 +142,9 @@
                 public MenuContainer getParent(MenuComponent menuComp) {
                     return menuComp.parent;
                 }
+                public Font getFont_NoClientCode(MenuComponent menuComp) {
+                    return menuComp.getFont_NoClientCode();
+                }
             });
     }
 
--- jdk/src/share/classes/java/awt/MenuItem.java	2012-08-10 10:25:56.000000000 -0700
+++ jdk/src/share/classes/java/awt/MenuItem.java	2013-05-05 09:38:32.000000000 -0700
@@ -31,7 +31,7 @@
 import java.io.ObjectInputStream;
 import java.io.IOException;
 import javax.accessibility.*;
-
+import sun.awt.AWTAccessor;
 
 /**
  * All items in a menu must belong to the class
@@ -76,6 +76,29 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setMenuItemAccessor(
+            new AWTAccessor.MenuItemAccessor() {
+                public boolean isEnabled(MenuItem item) {
+                    return item.enabled;
+                }
+
+                public String getLabel(MenuItem item) {
+                    return item.label;
+                }
+
+                public MenuShortcut getShortcut(MenuItem item) {
+                    return item.shortcut;
+                }
+
+                public String getActionCommandImpl(MenuItem item) {
+                    return item.getActionCommandImpl();
+                }
+
+                public boolean isItemEnabled(MenuItem item) {
+                    return item.isItemEnabled();
+                }
+            });
     }
 
     /**
--- jdk/src/share/classes/java/awt/ScrollPaneAdjustable.java	2012-08-10 10:25:57.000000000 -0700
+++ jdk/src/share/classes/java/awt/ScrollPaneAdjustable.java	2013-05-05 09:38:32.000000000 -0700
@@ -24,6 +24,8 @@
  */
 package java.awt;
 
+import sun.awt.AWTAccessor;
+
 import java.awt.event.AdjustmentEvent;
 import java.awt.event.AdjustmentListener;
 import java.awt.peer.ScrollPanePeer;
@@ -156,6 +158,13 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+        AWTAccessor.setScrollPaneAdjustableAccessor(
+                new AWTAccessor.ScrollPaneAdjustableAccessor() {
+            public void setTypedValue(final ScrollPaneAdjustable adj,
+                                      final int v, final int type) {
+                adj.setTypedValue(v, type);
+            }
+        });
     }
 
     /**
--- jdk/src/share/classes/java/awt/SequencedEvent.java	2012-08-10 10:25:57.000000000 -0700
+++ jdk/src/share/classes/java/awt/SequencedEvent.java	2013-05-05 09:38:32.000000000 -0700
@@ -26,6 +26,7 @@
 package java.awt;
 
 import java.util.LinkedList;
+import sun.awt.AWTAccessor;
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
 
@@ -54,6 +55,17 @@
     private AppContext appContext;
     private boolean disposed;
 
+    static {
+        AWTAccessor.setSequencedEventAccessor(new AWTAccessor.SequencedEventAccessor() {
+            public AWTEvent getNested(AWTEvent sequencedEvent) {
+                return ((SequencedEvent)sequencedEvent).nested;
+            }
+            public boolean isSequencedEvent(AWTEvent event) {
+                return event instanceof SequencedEvent;
+            }
+        });
+    }
+
     /**
      * Constructs a new SequencedEvent which will dispatch the specified
      * nested event.
--- jdk/src/share/classes/java/awt/SystemTray.java	2012-08-10 10:25:57.000000000 -0700
+++ jdk/src/share/classes/java/awt/SystemTray.java	2013-05-05 09:38:32.000000000 -0700
@@ -33,6 +33,7 @@
 import sun.awt.SunToolkit;
 import sun.awt.HeadlessToolkit;
 import sun.security.util.SecurityConstants;
+import sun.awt.AWTAccessor;
 
 /**
  * The <code>SystemTray</code> class represents the system tray for a
@@ -127,6 +128,18 @@
 
     private static final TrayIcon[] EMPTY_TRAY_ARRAY = new TrayIcon[0];
 
+    static {
+        AWTAccessor.setSystemTrayAccessor(
+            new AWTAccessor.SystemTrayAccessor() {
+                public void firePropertyChange(SystemTray tray,
+                                               String propertyName,
+                                               Object oldValue,
+                                               Object newValue) {
+                    tray.firePropertyChange(propertyName, oldValue, newValue);
+                }
+            });
+    }
+
     /**
      * Private <code>SystemTray</code> constructor.
      *
--- jdk/src/share/classes/java/awt/TextComponent.java	2012-08-10 10:25:57.000000000 -0700
+++ jdk/src/share/classes/java/awt/TextComponent.java	2013-05-05 09:38:32.000000000 -0700
@@ -107,12 +107,6 @@
     // the background color of non-editable TextComponents.
     boolean backgroundSetByClientCode = false;
 
-    /**
-     * True if this <code>TextComponent</code> has access
-     * to the System clipboard.
-     */
-    transient private boolean canAccessClipboard;
-
     transient protected TextListener textListener;
 
     /*
@@ -137,7 +131,6 @@
         GraphicsEnvironment.checkHeadless();
         this.text = (text != null) ? text : "";
         setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
-        checkSystemClipboardAccess();
     }
 
     private void enableInputMethodsIfNecessary() {
@@ -233,14 +226,9 @@
      * @see         java.awt.TextComponent#getText
      */
     public synchronized void setText(String t) {
-        boolean skipTextEvent = (text == null || text.isEmpty())
-                && (t == null || t.isEmpty());
         text = (t != null) ? t : "";
         TextComponentPeer peer = (TextComponentPeer)this.peer;
-        // Please note that we do not want to post an event
-        // if TextArea.setText() or TextField.setText() replaces an empty text
-        // by an empty text, that is, if component's text remains unchanged.
-        if (peer != null && !skipTextEvent) {
+        if (peer != null) {
             peer.setText(text);
         }
     }
@@ -732,17 +720,14 @@
     /**
      * Assigns a valid value to the canAccessClipboard instance variable.
      */
-    private void checkSystemClipboardAccess() {
-        canAccessClipboard = true;
+    private boolean canAccessClipboard() {
         SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            try {
-                sm.checkSystemClipboardAccess();
-            }
-            catch (SecurityException e) {
-                canAccessClipboard = false;
-            }
-        }
+        if (sm == null) return true;
+        try {
+            sm.checkSystemClipboardAccess();
+            return true;
+        } catch (SecurityException e) {}
+        return false;
     }
 
     /*
@@ -825,7 +810,6 @@
             }
         }
         enableInputMethodsIfNecessary();
-        checkSystemClipboardAccess();
     }
 
 
--- jdk/src/share/classes/java/awt/TrayIcon.java	2012-08-10 10:25:58.000000000 -0700
+++ jdk/src/share/classes/java/awt/TrayIcon.java	2013-05-05 09:38:32.000000000 -0700
@@ -25,19 +25,11 @@
 
 package java.awt;
 
-import java.awt.Point;
-import java.awt.Toolkit;
-import java.awt.GraphicsEnvironment;
 import java.awt.event.*;
-import java.awt.AWTEvent;
-import java.awt.AWTEventMulticaster;
-import java.awt.EventQueue;
-import java.awt.PopupMenu;
-import java.awt.Image;
-import java.util.EventListener;
 import java.awt.peer.TrayIconPeer;
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 import sun.awt.HeadlessToolkit;
 import java.util.EventObject;
 import java.security.AccessControlContext;
@@ -129,6 +121,16 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setTrayIconAccessor(
+            new AWTAccessor.TrayIconAccessor() {
+                public void addNotify(TrayIcon trayIcon) throws AWTException {
+                    trayIcon.addNotify();
+                }
+                public void removeNotify(TrayIcon trayIcon) {
+                    trayIcon.removeNotify();
+                }
+            });
     }
 
     private TrayIcon()
--- jdk/src/share/classes/java/awt/Window.java	2012-08-10 10:25:58.000000000 -0700
+++ jdk/src/share/classes/java/awt/Window.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1206,7 +1206,7 @@
         }
         else {
             try {
-                EventQueue.invokeAndWait(action);
+                EventQueue.invokeAndWait(this, action);
             }
             catch (InterruptedException e) {
                 System.err.println("Disposal was interrupted:");
@@ -2234,7 +2234,7 @@
                 WindowPeer peer = (WindowPeer)this.peer;
                 synchronized(getTreeLock()) {
                     if (peer != null) {
-                        peer.setAlwaysOnTop(alwaysOnTop);
+                        peer.updateAlwaysOnTopState();
                     }
                 }
             }
--- jdk/src/share/classes/java/awt/event/KeyEvent.java	2012-08-10 10:26:01.000000000 -0700
+++ jdk/src/share/classes/java/awt/event/KeyEvent.java	2013-05-05 09:38:32.000000000 -0700
@@ -25,12 +25,12 @@
 
 package java.awt.event;
 
-import java.awt.Event;
 import java.awt.Component;
 import java.awt.GraphicsEnvironment;
 import java.awt.Toolkit;
 import java.io.IOException;
 import java.io.ObjectInputStream;
+import sun.awt.AWTAccessor;
 
 /**
  * An event which indicates that a keystroke occurred in a component.
@@ -914,6 +914,23 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setKeyEventAccessor(
+            new AWTAccessor.KeyEventAccessor() {
+                public void setRawCode(KeyEvent ev, long rawCode) {
+                    ev.rawCode = rawCode;
+                }
+
+                public void setPrimaryLevelUnicode(KeyEvent ev,
+                                                   long primaryLevelUnicode) {
+                    ev.primaryLevelUnicode = primaryLevelUnicode;
+                }
+
+                public void setExtendedKeyCode(KeyEvent ev,
+                                               long extendedKeyCode) {
+                    ev.extendedKeyCode = extendedKeyCode;
+                }
+            });
     }
 
     /**
--- jdk/src/share/classes/java/awt/peer/WindowPeer.java	2012-08-10 10:26:07.000000000 -0700
+++ jdk/src/share/classes/java/awt/peer/WindowPeer.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,15 +55,14 @@
     void toBack();
 
     /**
-     * Sets if the window should always stay on top of all other windows or
-     * not.
-     *
-     * @param alwaysOnTop if the window should always stay on top of all other
-     *        windows or not
+     * Updates the window's always-on-top state.
+     * Sets if the window should always stay
+     * on top of all other windows or not.
      *
+     * @see Window#getAlwaysOnTop()
      * @see Window#setAlwaysOnTop(boolean)
      */
-    void setAlwaysOnTop(boolean alwaysOnTop);
+    void updateAlwaysOnTopState();
 
     /**
      * Updates the window's focusable state.
--- jdk/src/share/classes/java/beans/IndexedPropertyDescriptor.java	2012-08-10 10:26:08.000000000 -0700
+++ jdk/src/share/classes/java/beans/IndexedPropertyDescriptor.java	2013-05-05 09:38:32.000000000 -0700
@@ -181,21 +181,20 @@
                 // the Indexed readMethod was explicitly set to null.
                 return null;
             }
-            String nextMethodName = Introspector.GET_PREFIX + getBaseName();
             if (indexedReadMethodName == null) {
                 Class type = getIndexedPropertyType0();
                 if (type == boolean.class || type == null) {
                     indexedReadMethodName = Introspector.IS_PREFIX + getBaseName();
                 } else {
-                    indexedReadMethodName = nextMethodName;
+                    indexedReadMethodName = Introspector.GET_PREFIX + getBaseName();
                 }
             }
 
             Class[] args = { int.class };
             indexedReadMethod = Introspector.findMethod(cls, indexedReadMethodName, 1, args);
-            if ((indexedReadMethod == null) && !indexedReadMethodName.equals(nextMethodName)) {
+            if (indexedReadMethod == null) {
                 // no "is" method, so look for a "get" method.
-                indexedReadMethodName = nextMethodName;
+                indexedReadMethodName = Introspector.GET_PREFIX + getBaseName();
                 indexedReadMethod = Introspector.findMethod(cls, indexedReadMethodName, 1, args);
             }
             setIndexedReadMethod0(indexedReadMethod);
@@ -495,6 +494,16 @@
         indexedReadMethodName = old.indexedReadMethodName;
     }
 
+    void updateGenericsFor(Class<?> type) {
+        super.updateGenericsFor(type);
+        try {
+            setIndexedPropertyType(findIndexedPropertyType(getIndexedReadMethod0(), getIndexedWriteMethod0()));
+        }
+        catch (IntrospectionException exception) {
+            setIndexedPropertyType(null);
+        }
+    }
+
     /**
      * Returns a hash code value for the object.
      * See {@link java.lang.Object#hashCode} for a complete description.
--- jdk/src/share/classes/java/beans/Introspector.java	2012-08-10 10:26:08.000000000 -0700
+++ jdk/src/share/classes/java/beans/Introspector.java	2013-05-05 09:38:32.000000000 -0700
@@ -25,7 +25,6 @@
 
 package java.beans;
 
-import com.sun.beans.TypeResolver;
 import com.sun.beans.WeakCache;
 import com.sun.beans.finder.ClassFinder;
 
@@ -35,7 +34,6 @@
 import java.lang.ref.SoftReference;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.lang.reflect.Type;
 
 import java.util.Map;
 import java.util.ArrayList;
@@ -574,26 +572,25 @@
             // replace existing property descriptor
             // only if we have types to resolve
             // in the context of this.beanClass
-            try {
-                String name = pd.getName();
-                Method read = pd.getReadMethod();
-                Method write = pd.getWriteMethod();
-                boolean cls = true;
-                if (read != null) cls = cls && read.getGenericReturnType() instanceof Class;
-                if (write != null) cls = cls && write.getGenericParameterTypes()[0] instanceof Class;
-                if (pd instanceof IndexedPropertyDescriptor) {
-                    IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)pd;
-                    Method readI = ipd.getIndexedReadMethod();
-                    Method writeI = ipd.getIndexedWriteMethod();
-                    if (readI != null) cls = cls && readI.getGenericReturnType() instanceof Class;
-                    if (writeI != null) cls = cls && writeI.getGenericParameterTypes()[1] instanceof Class;
-                    if (!cls) {
-                        pd = new IndexedPropertyDescriptor(this.beanClass, name, read, write, readI, writeI);
-                    }
-                } else if (!cls) {
-                    pd = new PropertyDescriptor(this.beanClass, name, read, write);
+            Method read = pd.getReadMethod();
+            Method write = pd.getWriteMethod();
+            boolean cls = true;
+            if (read != null) cls = cls && read.getGenericReturnType() instanceof Class;
+            if (write != null) cls = cls && write.getGenericParameterTypes()[0] instanceof Class;
+            if (pd instanceof IndexedPropertyDescriptor) {
+                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) pd;
+                Method readI = ipd.getIndexedReadMethod();
+                Method writeI = ipd.getIndexedWriteMethod();
+                if (readI != null) cls = cls && readI.getGenericReturnType() instanceof Class;
+                if (writeI != null) cls = cls && writeI.getGenericParameterTypes()[1] instanceof Class;
+                if (!cls) {
+                    pd = new IndexedPropertyDescriptor((IndexedPropertyDescriptor) pd);
+                    pd.updateGenericsFor(this.beanClass);
                 }
-            } catch ( IntrospectionException e ) {
+            }
+            else if (!cls) {
+                pd = new PropertyDescriptor(pd);
+                pd.updateGenericsFor(this.beanClass);
             }
         }
         list.add(pd);
@@ -953,61 +950,44 @@
                     continue;
                 }
 
-                if (name.startsWith(ADD_PREFIX)) {
-                    Class<?> returnType = method.getReturnType();
-                    if (returnType == void.class) {
-                        Type[] parameterTypes = method.getGenericParameterTypes();
-                        if (parameterTypes.length == 1) {
-                            Class<?> type = TypeResolver.erase(TypeResolver.resolveInClass(beanClass, parameterTypes[0]));
-                            if (Introspector.isSubclass(type, eventListenerType)) {
-                                String listenerName = name.substring(3);
-                                if (listenerName.length() > 0 &&
-                                    type.getName().endsWith(listenerName)) {
-                                    if (adds == null) {
-                                        adds = new HashMap();
-                                    }
-                                    adds.put(listenerName, method);
-                                }
-                            }
+                Class argTypes[] = FeatureDescriptor.getParameterTypes(beanClass, method);
+                Class resultType = FeatureDescriptor.getReturnType(beanClass, method);
+
+                if (name.startsWith(ADD_PREFIX) && argTypes.length == 1 &&
+                    resultType == Void.TYPE &&
+                    Introspector.isSubclass(argTypes[0], eventListenerType)) {
+                    String listenerName = name.substring(3);
+                    if (listenerName.length() > 0 &&
+                        argTypes[0].getName().endsWith(listenerName)) {
+                        if (adds == null) {
+                            adds = new HashMap();
                         }
+                        adds.put(listenerName, method);
                     }
                 }
-                else if (name.startsWith(REMOVE_PREFIX)) {
-                    Class<?> returnType = method.getReturnType();
-                    if (returnType == void.class) {
-                        Type[] parameterTypes = method.getGenericParameterTypes();
-                        if (parameterTypes.length == 1) {
-                            Class<?> type = TypeResolver.erase(TypeResolver.resolveInClass(beanClass, parameterTypes[0]));
-                            if (Introspector.isSubclass(type, eventListenerType)) {
-                                String listenerName = name.substring(6);
-                                if (listenerName.length() > 0 &&
-                                    type.getName().endsWith(listenerName)) {
-                                    if (removes == null) {
-                                        removes = new HashMap();
-                                    }
-                                    removes.put(listenerName, method);
-                                }
-                            }
+                else if (name.startsWith(REMOVE_PREFIX) && argTypes.length == 1 &&
+                         resultType == Void.TYPE &&
+                         Introspector.isSubclass(argTypes[0], eventListenerType)) {
+                    String listenerName = name.substring(6);
+                    if (listenerName.length() > 0 &&
+                        argTypes[0].getName().endsWith(listenerName)) {
+                        if (removes == null) {
+                            removes = new HashMap();
                         }
+                        removes.put(listenerName, method);
                     }
                 }
-                else if (name.startsWith(GET_PREFIX)) {
-                    Class<?>[] parameterTypes = method.getParameterTypes();
-                    if (parameterTypes.length == 0) {
-                        Class<?> returnType = FeatureDescriptor.getReturnType(beanClass, method);
-                        if (returnType.isArray()) {
-                            Class<?> type = returnType.getComponentType();
-                            if (Introspector.isSubclass(type, eventListenerType)) {
-                                String listenerName  = name.substring(3, name.length() - 1);
-                                if (listenerName.length() > 0 &&
-                                    type.getName().endsWith(listenerName)) {
-                                    if (gets == null) {
-                                        gets = new HashMap();
-                                    }
-                                    gets.put(listenerName, method);
-                                }
-                            }
+                else if (name.startsWith(GET_PREFIX) && argTypes.length == 0 &&
+                         resultType.isArray() &&
+                         Introspector.isSubclass(resultType.getComponentType(),
+                                                 eventListenerType)) {
+                    String listenerName  = name.substring(3, name.length() - 1);
+                    if (listenerName.length() > 0 &&
+                        resultType.getComponentType().getName().endsWith(listenerName)) {
+                        if (gets == null) {
+                            gets = new HashMap();
                         }
+                        gets.put(listenerName, method);
                     }
                 }
             }
@@ -1259,11 +1239,11 @@
     private boolean isEventHandler(Method m) {
         // We assume that a method is an event handler if it has a single
         // argument, whose type inherit from java.util.Event.
-        Type argTypes[] = m.getGenericParameterTypes();
+        Class argTypes[] = FeatureDescriptor.getParameterTypes(beanClass, m);
         if (argTypes.length != 1) {
             return false;
         }
-        return isSubclass(TypeResolver.erase(TypeResolver.resolveInClass(beanClass, argTypes[0])), EventObject.class);
+        return isSubclass(argTypes[0], EventObject.class);
     }
 
     /*
@@ -1315,25 +1295,24 @@
                 }
 
                 // make sure method signature matches.
-                if (method.getName().equals(methodName)) {
-                    Type[] params = method.getGenericParameterTypes();
-                    if (params.length == argCount) {
-                        if (args != null) {
-                            boolean different = false;
-                            if (argCount > 0) {
-                                for (int j = 0; j < argCount; j++) {
-                                    if (TypeResolver.erase(TypeResolver.resolveInClass(start, params[j])) != args[j]) {
-                                        different = true;
-                                        continue;
-                                    }
-                                }
-                                if (different) {
+                Class params[] = FeatureDescriptor.getParameterTypes(start, method);
+                if (method.getName().equals(methodName) &&
+                    params.length == argCount) {
+                    if (args != null) {
+                        boolean different = false;
+                        if (argCount > 0) {
+                            for (int j = 0; j < argCount; j++) {
+                                if (params[j] != args[j]) {
+                                    different = true;
                                     continue;
                                 }
                             }
+                            if (different) {
+                                continue;
+                            }
                         }
-                        return method;
                     }
+                    return method;
                 }
             }
         }
@@ -1460,7 +1439,7 @@
     private PropertyDescriptor[] properties;
     private int defaultProperty;
     private MethodDescriptor[] methods;
-    private final Reference<BeanInfo> targetBeanInfoRef;
+    private Reference<BeanInfo> targetBeanInfoRef;
 
     public GenericBeanInfo(BeanDescriptor beanDescriptor,
                 EventSetDescriptor[] events, int defaultEvent,
@@ -1472,7 +1451,9 @@
         this.properties = properties;
         this.defaultProperty = defaultProperty;
         this.methods = methods;
-        this.targetBeanInfoRef = new SoftReference<BeanInfo>(targetBeanInfo);
+        this.targetBeanInfoRef = (targetBeanInfo != null)
+                ? new SoftReference<>(targetBeanInfo)
+                : null;
     }
 
     /**
@@ -1539,10 +1520,25 @@
     }
 
     public java.awt.Image getIcon(int iconKind) {
-        BeanInfo targetBeanInfo = this.targetBeanInfoRef.get();
+        BeanInfo targetBeanInfo = getTargetBeanInfo();
         if (targetBeanInfo != null) {
             return targetBeanInfo.getIcon(iconKind);
         }
         return super.getIcon(iconKind);
     }
+
+    private BeanInfo getTargetBeanInfo() {
+        if (this.targetBeanInfoRef == null) {
+            return null;
+        }
+        BeanInfo targetBeanInfo = this.targetBeanInfoRef.get();
+        if (targetBeanInfo == null) {
+            targetBeanInfo = ThreadGroupContext.getContext().getBeanInfoFinder()
+                    .find(this.beanDescriptor.getBeanClass());
+            if (targetBeanInfo != null) {
+                this.targetBeanInfoRef = new SoftReference<>(targetBeanInfo);
+            }
+        }
+        return targetBeanInfo;
+    }
 }
--- jdk/src/share/classes/java/beans/PropertyDescriptor.java	2012-08-10 10:26:08.000000000 -0700
+++ jdk/src/share/classes/java/beans/PropertyDescriptor.java	2013-05-05 09:38:32.000000000 -0700
@@ -210,13 +210,12 @@
                 // The read method was explicitly set to null.
                 return null;
             }
-            String nextMethodName = Introspector.GET_PREFIX + getBaseName();
             if (readMethodName == null) {
                 Class type = getPropertyType0();
                 if (type == boolean.class || type == null) {
                     readMethodName = Introspector.IS_PREFIX + getBaseName();
                 } else {
-                    readMethodName = nextMethodName;
+                    readMethodName = Introspector.GET_PREFIX + getBaseName();
                 }
             }
 
@@ -226,8 +225,8 @@
             // methods.  If an "is" method exists, this is the official
             // reader method so look for this one first.
             readMethod = Introspector.findMethod(cls, readMethodName, 0);
-            if ((readMethod == null) && !readMethodName.equals(nextMethodName)) {
-                readMethodName = nextMethodName;
+            if (readMethod == null) {
+                readMethodName = Introspector.GET_PREFIX + getBaseName();
                 readMethod = Introspector.findMethod(cls, readMethodName, 0);
             }
             try {
@@ -630,6 +629,16 @@
         constrained = old.constrained;
     }
 
+    void updateGenericsFor(Class<?> type) {
+        setClass0(type);
+        try {
+            setPropertyType(findPropertyType(getReadMethod0(), getWriteMethod0()));
+        }
+        catch (IntrospectionException exception) {
+            setPropertyType(null);
+        }
+    }
+
     /**
      * Returns the property type that corresponds to the read and write method.
      * The type precedence is given to the readMethod.
--- jdk/src/share/classes/java/beans/ThreadGroupContext.java	2012-08-10 10:26:08.000000000 -0700
+++ jdk/src/share/classes/java/beans/ThreadGroupContext.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,7 +29,6 @@
 import com.sun.beans.finder.PropertyEditorFinder;
 
 import java.awt.GraphicsEnvironment;
-import java.util.HashMap;
 import java.util.Map;
 import java.util.WeakHashMap;
 
@@ -42,7 +41,7 @@
  */
 final class ThreadGroupContext {
 
-    private static final Map<ThreadGroup, ThreadGroupContext> contexts = new WeakHashMap<>();
+    private static final WeakIdentityMap<ThreadGroupContext> contexts = new WeakIdentityMap<>();
 
     /**
      * Returns the appropriate {@code AppContext} for the caller,
@@ -69,6 +68,8 @@
     private BeanInfoFinder beanInfoFinder;
     private PropertyEditorFinder propertyEditorFinder;
 
+    private ThreadGroupContext() {
+    }
 
     boolean isDesignTime() {
         return this.isDesignTime;
--- jdk/src/share/classes/java/beans/WeakIdentityMap.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/java/beans/WeakIdentityMap.java	2013-05-05 09:38:32.000000000 -0700
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.beans;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+
+/**
+ * Hash table based mapping, which uses weak references to store keys
+ * and reference-equality in place of object-equality to compare them.
+ * An entry will automatically be removed when its key is no longer
+ * in ordinary use.  Both null values and the null key are supported.
+ *
+ * @see java.util.IdentityHashMap
+ * @see java.util.WeakHashMap
+ */
+final class WeakIdentityMap<T> {
+
+    private static final int MAXIMUM_CAPACITY = 1 << 30; // it MUST be a power of two
+    private static final Object NULL = new Object(); // special object for null key
+
+    private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();
+
+    private Entry<T>[] table = newTable(1<<3); // table's length MUST be a power of two
+    private int threshold = 6; // the next size value at which to resize
+    private int size = 0; // the number of key-value mappings
+
+    public T get(Object key) {
+        removeStaleEntries();
+        if (key == null) {
+            key = NULL;
+        }
+        int hash = key.hashCode();
+        int index = getIndex(this.table, hash);
+        for (Entry<T> entry = this.table[index]; entry != null; entry = entry.next) {
+            if (entry.isMatched(key, hash)) {
+                return entry.value;
+            }
+        }
+        return null;
+    }
+
+    public T put(Object key, T value) {
+        removeStaleEntries();
+        if (key == null) {
+            key = NULL;
+        }
+        int hash = key.hashCode();
+        int index = getIndex(this.table, hash);
+        for (Entry<T> entry = this.table[index]; entry != null; entry = entry.next) {
+            if (entry.isMatched(key, hash)) {
+                T oldValue = entry.value;
+                entry.value = value;
+                return oldValue;
+            }
+        }
+        this.table[index] = new Entry<T>(key, hash, value, this.queue, this.table[index]);
+        if (++this.size >= this.threshold) {
+            if (this.table.length == MAXIMUM_CAPACITY) {
+                this.threshold = Integer.MAX_VALUE;
+            }
+            else {
+                removeStaleEntries();
+                Entry<T>[] table = newTable(this.table.length * 2);
+                transfer(this.table, table);
+
+                // If ignoring null elements and processing ref queue caused massive
+                // shrinkage, then restore old table.  This should be rare, but avoids
+                // unbounded expansion of garbage-filled tables.
+                if (this.size >= this.threshold / 2) {
+                    this.table = table;
+                    this.threshold *= 2;
+                }
+                else {
+                    transfer(table, this.table);
+                }
+            }
+        }
+        return null;
+    }
+
+    private void removeStaleEntries() {
+        for (Object ref = this.queue.poll(); ref != null; ref = this.queue.poll()) {
+            @SuppressWarnings("unchecked")
+            Entry<T> entry = (Entry<T>) ref;
+            int index = getIndex(this.table, entry.hash);
+
+            Entry<T> prev = this.table[index];
+            Entry<T> current = prev;
+            while (current != null) {
+                Entry<T> next = current.next;
+                if (current == entry) {
+                    if (prev == entry) {
+                        this.table[index] = next;
+                    }
+                    else {
+                        prev.next = next;
+                    }
+                    entry.value = null; // Help GC
+                    entry.next = null; // Help GC
+                    this.size--;
+                    break;
+                }
+                prev = current;
+                current = next;
+            }
+        }
+    }
+
+    private void transfer(Entry<T>[] oldTable, Entry<T>[] newTable) {
+        for (int i = 0; i < oldTable.length; i++) {
+            Entry<T> entry = oldTable[i];
+            oldTable[i] = null;
+            while (entry != null) {
+                Entry<T> next = entry.next;
+                Object key = entry.get();
+                if (key == null) {
+                    entry.value = null; // Help GC
+                    entry.next = null; // Help GC
+                    this.size--;
+                }
+                else {
+                    int index = getIndex(newTable, entry.hash);
+                    entry.next = newTable[index];
+                    newTable[index] = entry;
+                }
+                entry = next;
+            }
+        }
+    }
+
+
+    @SuppressWarnings("unchecked")
+    private Entry<T>[] newTable(int length) {
+        return (Entry<T>[]) new Entry<?>[length];
+    }
+
+    private static int getIndex(Entry<?>[] table, int hash) {
+        return hash & (table.length - 1);
+    }
+
+    private static class Entry<T> extends WeakReference<Object> {
+        private final int hash;
+        private T value;
+        private Entry<T> next;
+
+        Entry(Object key, int hash, T value, ReferenceQueue<Object> queue, Entry<T> next) {
+            super(key, queue);
+            this.hash = hash;
+            this.value = value;
+            this.next  = next;
+        }
+
+        boolean isMatched(Object key, int hash) {
+            return (this.hash == hash) && (key == get());
+        }
+    }
+}
--- jdk/src/share/classes/java/beans/XMLDecoder.java	2012-08-10 10:26:09.000000000 -0700
+++ jdk/src/share/classes/java/beans/XMLDecoder.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,9 @@
 import java.io.Closeable;
 import java.io.InputStream;
 import java.io.IOException;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import org.xml.sax.InputSource;
 import org.xml.sax.helpers.DefaultHandler;
@@ -61,6 +64,7 @@
  * @author Philip Milne
  */
 public class XMLDecoder implements AutoCloseable {
+    private final AccessControlContext acc = AccessController.getContext();
     private final DocumentHandler handler = new DocumentHandler();
     private final InputSource input;
     private Object owner;
@@ -189,7 +193,15 @@
             return false;
         }
         if (this.array == null) {
-            this.handler.parse(this.input);
+            if ((this.acc == null) && (null != System.getSecurityManager())) {
+                throw new SecurityException("AccessControlContext is not set");
+            }
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    XMLDecoder.this.handler.parse(XMLDecoder.this.input);
+                    return null;
+                }
+            }, this.acc);
             this.array = this.handler.getObjects();
         }
         return true;
--- jdk/src/share/classes/java/beans/XMLEncoder.java	2012-08-10 10:26:09.000000000 -0700
+++ jdk/src/share/classes/java/beans/XMLEncoder.java	2013-05-05 09:38:32.000000000 -0700
@@ -631,7 +631,12 @@
         }
 
         if (d.name != null) {
-            outputXML(isArgument ? "object" : "void", " idref=" + quote(d.name), value);
+            if (isArgument) {
+                writeln("<object idref=" + quote(d.name) + "/>");
+            }
+            else {
+                outputXML("void", " idref=" + quote(d.name), value);
+            }
         }
         else if (d.exp != null) {
             outputStatement(d.exp, outer, isArgument);
@@ -710,12 +715,14 @@
         }
         else {
             d.refs = 2;
-            getValueData(target).refs++;
-            List<Statement> statements = statementList(target);
-            if (!statements.contains(exp)) {
-                statements.add(exp);
+            if (d.name == null) {
+                getValueData(target).refs++;
+                List<Statement> statements = statementList(target);
+                if (!statements.contains(exp)) {
+                    statements.add(exp);
+                }
+                outputValue(target, outer, false);
             }
-            outputValue(target, outer, false);
             if (expression) {
                 outputValue(value, outer, isArgument);
             }
--- jdk/src/share/classes/java/io/FilePermission.java	2012-08-10 10:26:11.000000000 -0700
+++ jdk/src/share/classes/java/io/FilePermission.java	2013-05-05 09:38:32.000000000 -0700
@@ -418,7 +418,7 @@
      */
 
     public int hashCode() {
-        return this.cpath.hashCode();
+        return 0;
     }
 
     /**
--- jdk/src/share/classes/java/io/ObjectInputStream.java	2012-08-10 10:26:15.000000000 -0700
+++ jdk/src/share/classes/java/io/ObjectInputStream.java	2013-05-05 09:38:32.000000000 -0700
@@ -41,6 +41,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import static java.io.ObjectStreamClass.processQueue;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * An ObjectInputStream deserializes primitive data and objects previously
@@ -1519,6 +1520,12 @@
         }
     }
 
+    private boolean isCustomSubclass() {
+        // Return true if this class is a custom subclass of ObjectInputStream
+        return getClass().getClassLoader()
+                    != ObjectInputStream.class.getClassLoader();
+    }
+
     /**
      * Reads in and returns class descriptor for a dynamic proxy class.  Sets
      * passHandle to proxy class descriptor's assigned handle.  If proxy class
@@ -1548,6 +1555,15 @@
         try {
             if ((cl = resolveProxyClass(ifaces)) == null) {
                 resolveEx = new ClassNotFoundException("null class");
+            } else if (!Proxy.isProxyClass(cl)) {
+                throw new InvalidClassException("Not a proxy");
+            } else {
+                // ReflectUtil.checkProxyPackageAccess makes a test
+                // equivalent to isCustomSubclass so there's no need
+                // to condition this call to isCustomSubclass == true here.
+                ReflectUtil.checkProxyPackageAccess(
+                        getClass().getClassLoader(),
+                        cl.getInterfaces());
             }
         } catch (ClassNotFoundException ex) {
             resolveEx = ex;
@@ -1589,9 +1605,12 @@
         Class cl = null;
         ClassNotFoundException resolveEx = null;
         bin.setBlockDataMode(true);
+        final boolean checksRequired = isCustomSubclass();
         try {
             if ((cl = resolveClass(readDesc)) == null) {
                 resolveEx = new ClassNotFoundException("null class");
+            } else if (checksRequired) {
+                ReflectUtil.checkPackageAccess(cl);
             }
         } catch (ClassNotFoundException ex) {
             resolveEx = ex;
@@ -1750,6 +1769,12 @@
         ObjectStreamClass desc = readClassDesc(false);
         desc.checkDeserialize();
 
+        Class<?> cl = desc.forClass();
+        if (cl == String.class || cl == Class.class
+                || cl == ObjectStreamClass.class) {
+            throw new InvalidClassException("invalid class descriptor");
+        }
+
         Object obj;
         try {
             obj = desc.isInstantiable() ? desc.newInstance() : null;
--- jdk/src/share/classes/java/lang/Class.java	2012-08-10 10:26:32.000000000 -0700
+++ jdk/src/share/classes/java/lang/Class.java	2013-05-05 09:38:32.000000000 -0700
@@ -65,7 +65,9 @@
 import sun.reflect.generics.scope.ClassScope;
 import sun.security.util.SecurityConstants;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Proxy;
 import sun.reflect.annotation.*;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * Instances of the class {@code Class} represent classes and
@@ -320,7 +322,7 @@
         throws InstantiationException, IllegalAccessException
     {
         if (System.getSecurityManager() != null) {
-            checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+            checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), false);
         }
         return newInstance0();
     }
@@ -1297,7 +1299,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), false);
 
         // Privileged so this implementation can look at DECLARED classes,
         // something the caller might not have privilege to do.  The code here
@@ -1372,7 +1374,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), true);
         return copyFields(privateGetPublicFields(null));
     }
 
@@ -1423,7 +1425,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), true);
         return copyMethods(privateGetPublicMethods());
     }
 
@@ -1472,7 +1474,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), true);
         return copyConstructors(privateGetDeclaredConstructors(true));
     }
 
@@ -1531,7 +1533,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), true);
         Field field = getField0(name);
         if (field == null) {
             throw new NoSuchFieldException(name);
@@ -1616,7 +1618,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), true);
         Method method = getMethod0(name, parameterTypes);
         if (method == null) {
             throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
@@ -1670,7 +1672,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader(), true);
         return getConstructor0(parameterTypes, Member.PUBLIC);
     }
 
@@ -1712,7 +1714,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), false);
         return getDeclaredClasses0();
     }
 
@@ -1756,7 +1758,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), true);
         return copyFields(privateGetDeclaredFields(false));
     }
 
@@ -1804,7 +1806,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), true);
         return copyMethods(privateGetDeclaredMethods(false));
     }
 
@@ -1849,7 +1851,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), true);
         return copyConstructors(privateGetDeclaredConstructors(false));
     }
 
@@ -1893,7 +1895,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), true);
         Field field = searchFields(privateGetDeclaredFields(false), name);
         if (field == null) {
             throw new NoSuchFieldException(name);
@@ -1948,7 +1950,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), true);
         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
         if (method == null) {
             throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
@@ -1998,7 +2000,7 @@
         // be very careful not to change the stack depth of this
         // checkMemberAccess call for security reasons
         // see java.lang.SecurityManager.checkMemberAccess
-        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
+        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader(), true);
         return getConstructor0(parameterTypes, Member.DECLARED);
     }
 
@@ -2168,19 +2170,26 @@
      * <p> Default policy: allow all clients access with normal Java access
      * control.
      */
-    private void checkMemberAccess(int which, ClassLoader ccl) {
+    private void checkMemberAccess(int which, ClassLoader ccl, boolean checkProxyInterfaces) {
         SecurityManager s = System.getSecurityManager();
         if (s != null) {
             s.checkMemberAccess(this, which);
             ClassLoader cl = getClassLoader0();
-            if ((ccl != null) && (ccl != cl) &&
-                  ((cl == null) || !cl.isAncestor(ccl))) {
+            if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
                 String name = this.getName();
                 int i = name.lastIndexOf('.');
                 if (i != -1) {
-                    s.checkPackageAccess(name.substring(0, i));
+                    // skip the package access check on a proxy class in default proxy package
+                    String pkg = name.substring(0, i);
+                    if (!Proxy.isProxyClass(this) || !pkg.equals(ReflectUtil.PROXY_PACKAGE)) {
+                        s.checkPackageAccess(pkg);
+                    }
                 }
             }
+            // check package access on the proxy interfaces
+            if (checkProxyInterfaces && Proxy.isProxyClass(this)) {
+                ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
+            }
         }
     }
 
--- jdk/src/share/classes/java/lang/ProcessBuilder.java	2012-08-10 10:26:45.000000000 -0700
+++ jdk/src/share/classes/java/lang/ProcessBuilder.java	2013-05-05 09:38:32.000000000 -0700
@@ -30,6 +30,7 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.FileOutputStream;
+import java.security.AccessControlException;
 import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.List;
@@ -1012,8 +1013,9 @@
         String prog = cmdarray[0];
 
         SecurityManager security = System.getSecurityManager();
-        if (security != null)
+        if (security != null) {
             security.checkExec(prog);
+        }
 
         String dir = directory == null ? null : directory.toString();
 
@@ -1024,13 +1026,24 @@
                                      redirects,
                                      redirectErrorStream);
         } catch (IOException e) {
+            String exceptionInfo = ": " + e.getMessage();
+            Throwable cause = e;
+            if (security != null) {
+                // Can not disclose the fail reason for read-protected files.
+                try {
+                    security.checkRead(prog);
+                } catch (AccessControlException ace) {
+                    exceptionInfo = "";
+                    cause = ace;
+                }
+            }
             // It's much easier for us to create a high-quality error
             // message than the low-level C code which found the problem.
             throw new IOException(
                 "Cannot run program \"" + prog + "\""
                 + (dir == null ? "" : " (in directory \"" + dir + "\")")
-                + ": " + e.getMessage(),
-                e);
+                + exceptionInfo,
+                cause);
         }
     }
 }
--- jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java	2012-08-10 10:26:57.000000000 -0700
+++ jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java	2013-05-05 09:38:32.000000000 -0700
@@ -44,6 +44,15 @@
         if (!m.isResolved())
             throw new InternalError();
 
+        if (m.getDeclaringClass().isInterface() && !m.isAbstract()) {
+            // Check for corner case: invokeinterface of Object method.
+            MemberName m2 = new MemberName(Object.class, m.getName(), m.getMethodType(), m.getModifiers());
+            m2 = MemberName.getFactory().resolveOrNull(m2, false, null);
+            if (m2 != null && m2.isPublic()) {
+                m = m2;
+            }
+        }
+
         MethodHandleNatives.init(this, (Object) m, doDispatch, lookupClass);
     }
 
--- jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	2012-08-10 10:26:57.000000000 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,6 @@
 
 package java.lang.invoke;
 
-import sun.invoke.util.VerifyType;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
@@ -35,6 +34,7 @@
 import java.util.List;
 import sun.invoke.empty.Empty;
 import sun.invoke.util.ValueConversions;
+import sun.invoke.util.VerifyType;
 import sun.invoke.util.Wrapper;
 import sun.misc.Unsafe;
 import static java.lang.invoke.MethodHandleStatics.*;
@@ -1258,4 +1258,151 @@
         return THROW_EXCEPTION;
     }
     static <T extends Throwable> Empty throwException(T t) throws T { throw t; }
+
+    /**
+     * Create an alias for the method handle which, when called,
+     * appears to be called from the same class loader and protection domain
+     * as hostClass.
+     * This is an expensive no-op unless the method which is called
+     * is sensitive to its caller.  A small number of system methods
+     * are in this category, including Class.forName and Method.invoke.
+     */
+    static
+    MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
+        return BindCaller.bindCaller(mh, hostClass);
+    }
+
+    // Put the whole mess into its own nested class.
+    // That way we can lazily load the code and set up the constants.
+    private static class BindCaller {
+        static
+        MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
+            // Do not use this function to inject calls into system classes.
+            if (hostClass == null
+                ||    (hostClass.isArray() ||
+                       hostClass.isPrimitive() ||
+                       hostClass.getName().startsWith("java.") ||
+                       hostClass.getName().startsWith("sun."))) {
+                throw new InternalError();  // does not happen, and should not anyway
+            }
+            // For simplicity, convert mh to a varargs-like method.
+            MethodHandle vamh = prepareForInvoker(mh);
+            // Cache the result of makeInjectedInvoker once per argument class.
+            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
+            return restoreToType(bccInvoker.bindTo(vamh), mh.type());
+        }
+
+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+        private static MethodHandle makeInjectedInvoker(Class<?> hostClass) {
+            Class<?> bcc = UNSAFE.defineAnonymousClass(hostClass, T_BYTES, null);
+            if (hostClass.getClassLoader() != bcc.getClassLoader())
+                throw new InternalError(hostClass.getName()+" (CL)");
+            try {
+                if (hostClass.getProtectionDomain() != bcc.getProtectionDomain())
+                    throw new InternalError(hostClass.getName()+" (PD)");
+            } catch (SecurityException ex) {
+                // Self-check was blocked by security manager.  This is OK.
+                // In fact the whole try body could be turned into an assertion.
+            }
+            try {
+                MethodHandle init = IMPL_LOOKUP.findStatic(bcc, "init", MethodType.methodType(void.class));
+                init.invokeExact();  // force initialization of the class
+            } catch (Throwable ex) {
+                throw uncaughtException(ex);
+            }
+            MethodHandle bccInvoker;
+            try {
+                MethodType invokerMT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
+                bccInvoker = IMPL_LOOKUP.findStatic(bcc, "invoke_V", invokerMT);
+            } catch (ReflectiveOperationException ex) {
+                throw uncaughtException(ex);
+            }
+            // Test the invoker, to ensure that it really injects into the right place.
+            try {
+                MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
+                Object ok = bccInvoker.invokeExact(vamh, new Object[]{hostClass, bcc});
+            } catch (Throwable ex) {
+                throw new InternalError(ex.toString());
+            }
+            return bccInvoker;
+        }
+        private static ClassValue<MethodHandle> CV_makeInjectedInvoker = new ClassValue<MethodHandle>() {
+            @Override protected MethodHandle computeValue(Class<?> hostClass) {
+                return makeInjectedInvoker(hostClass);
+            }
+        };
+
+        // Adapt mh so that it can be called directly from an injected invoker:
+        private static MethodHandle prepareForInvoker(MethodHandle mh) {
+            mh = mh.asFixedArity();
+            MethodType mt = mh.type();
+            int arity = mt.parameterCount();
+            MethodHandle vamh = mh.asType(mt.generic());
+            vamh = vamh.asSpreader(Object[].class, arity);
+            return vamh;
+        }
+
+        // Undo the adapter effect of prepareForInvoker:
+        private static MethodHandle restoreToType(MethodHandle vamh, MethodType type) {
+            return vamh.asCollector(Object[].class, type.parameterCount()).asType(type);
+        }
+
+        private static final MethodHandle MH_checkCallerClass;
+        static {
+            final Class<?> THIS_CLASS = BindCaller.class;
+            assert(checkCallerClass(THIS_CLASS, THIS_CLASS));
+            try {
+                MH_checkCallerClass = IMPL_LOOKUP
+                    .findStatic(THIS_CLASS, "checkCallerClass",
+                                MethodType.methodType(boolean.class, Class.class, Class.class));
+                assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS, THIS_CLASS));
+            } catch (Throwable ex) {
+                throw new InternalError(ex.toString());
+            }
+        }
+
+        private static boolean checkCallerClass(Class<?> expected, Class<?> expected2) {
+            final int FRAME_COUNT_ARG = 2;  // [0] Reflection [1] BindCaller [2] Expected
+            Class<?> actual = sun.reflect.Reflection.getCallerClass(FRAME_COUNT_ARG);
+            if (actual != expected && actual != expected2)
+                throw new InternalError("found "+actual.getName()+", expected "+expected.getName()
+                                        +(expected == expected2 ? "" : ", or else "+expected2.getName()));
+            return true;
+        }
+
+        private static final byte[] T_BYTES;
+        static {
+            final Object[] values = {null};
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                    public Void run() {
+                        try {
+                            Class<T> tClass = T.class;
+                            String tName = tClass.getName();
+                            String tResource = tName.substring(tName.lastIndexOf('.')+1)+".class";
+                            java.net.URLConnection uconn = tClass.getResource(tResource).openConnection();
+                            int len = uconn.getContentLength();
+                            byte[] bytes = new byte[len];
+                            try (java.io.InputStream str = uconn.getInputStream()) {
+                                int nr = str.read(bytes);
+                                if (nr != len)  throw new java.io.IOException(tResource);
+                            }
+                            values[0] = bytes;
+                        } catch (java.io.IOException ex) {
+                            throw new InternalError(ex.toString());
+                        }
+                        return null;
+                    }
+                });
+            T_BYTES = (byte[]) values[0];
+        }
+
+        // The following class is used as a template for Unsafe.defineAnonymousClass:
+        private static class T {
+            static void init() { }  // side effect: initializes this class
+            static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
+                return vamh.invokeExact(args);
+            }
+        }
+    }
 }
--- jdk/src/share/classes/java/lang/invoke/MethodHandleNatives.java	2012-08-10 10:26:57.000000000 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleNatives.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -401,4 +401,130 @@
         assert(!HAVE_RICOCHET_FRAMES) : "this code should not be executed if `-XX:+UseRicochetFrames is enabled";
         return true;
     }
+
+    /**
+     * Is this method a caller-sensitive method?
+     * I.e., does it call Reflection.getCallerClass or a similer method
+     * to ask about the identity of its caller?
+     */
+    // FIXME: Replace this pattern match by an annotation @sun.reflect.CallerSensitive.
+    static boolean isCallerSensitive(MemberName mem) {
+        if (!mem.isInvocable())  return false;  // fields are not caller sensitive
+        Class<?> defc = mem.getDeclaringClass();
+        switch (mem.getName()) {
+        case "doPrivileged":
+        case "doPrivilegedWithCombiner":
+            return defc == java.security.AccessController.class;
+        case "checkMemberAccess":
+            return canBeCalledVirtual(mem, java.lang.SecurityManager.class);
+        case "getUnsafe":
+            return defc == sun.misc.Unsafe.class;
+        case "lookup":
+            return defc == java.lang.invoke.MethodHandles.class;
+        case "findStatic":
+        case "findVirtual":
+        case "findConstructor":
+        case "findSpecial":
+        case "findGetter":
+        case "findSetter":
+        case "findStaticGetter":
+        case "findStaticSetter":
+        case "bind":
+        case "unreflect":
+        case "unreflectSpecial":
+        case "unreflectConstructor":
+        case "unreflectGetter":
+        case "unreflectSetter":
+            return defc == java.lang.invoke.MethodHandles.Lookup.class;
+        case "invoke":
+            return defc == java.lang.reflect.Method.class;
+        case "get":
+        case "getBoolean":
+        case "getByte":
+        case "getChar":
+        case "getShort":
+        case "getInt":
+        case "getLong":
+        case "getFloat":
+        case "getDouble":
+        case "set":
+        case "setBoolean":
+        case "setByte":
+        case "setChar":
+        case "setShort":
+        case "setInt":
+        case "setLong":
+        case "setFloat":
+        case "setDouble":
+            return defc == java.lang.reflect.Field.class;
+        case "newInstance":
+            if (defc == java.lang.reflect.Constructor.class)  return true;
+            if (defc == java.lang.Class.class)  return true;
+            break;
+        case "forName":
+        case "getClassLoader":
+        case "getClasses":
+        case "getFields":
+        case "getMethods":
+        case "getConstructors":
+        case "getDeclaredClasses":
+        case "getDeclaredFields":
+        case "getDeclaredMethods":
+        case "getDeclaredConstructors":
+        case "getField":
+        case "getMethod":
+        case "getConstructor":
+        case "getDeclaredField":
+        case "getDeclaredMethod":
+        case "getDeclaredConstructor":
+            return defc == java.lang.Class.class;
+        case "getConnection":
+        case "getDriver":
+        case "getDrivers":
+        case "deregisterDriver":
+            return defc == java.sql.DriverManager.class;
+        case "newUpdater":
+            if (defc == java.util.concurrent.atomic.AtomicIntegerFieldUpdater.class)  return true;
+            if (defc == java.util.concurrent.atomic.AtomicLongFieldUpdater.class)  return true;
+            if (defc == java.util.concurrent.atomic.AtomicReferenceFieldUpdater.class)  return true;
+            break;
+        case "getContextClassLoader":
+            return canBeCalledVirtual(mem, java.lang.Thread.class);
+        case "getPackage":
+        case "getPackages":
+            return defc == java.lang.Package.class;
+        case "getParent":
+        case "getSystemClassLoader":
+            return defc == java.lang.ClassLoader.class;
+        case "load":
+        case "loadLibrary":
+            if (defc == java.lang.Runtime.class)  return true;
+            if (defc == java.lang.System.class)  return true;
+            break;
+        case "getCallerClass":
+            if (defc == sun.reflect.Reflection.class)  return true;
+            if (defc == java.lang.System.class)  return true;
+            break;
+        case "getCallerClassLoader":
+            return defc == java.lang.ClassLoader.class;
+        case "registerAsParallelCapable":
+            return canBeCalledVirtual(mem, java.lang.ClassLoader.class);
+        case "getProxyClass":
+        case "newProxyInstance":
+            return defc == java.lang.reflect.Proxy.class;
+        case "asInterfaceInstance":
+            return defc == java.lang.invoke.MethodHandleProxies.class;
+        case "getBundle":
+        case "clearCache":
+            return defc == java.util.ResourceBundle.class;
+        }
+        return false;
+    }
+    static boolean canBeCalledVirtual(MemberName symbolicRef, Class<?> definingClass) {
+        Class<?> symbolicRefClass = symbolicRef.getDeclaringClass();
+        if (symbolicRefClass == definingClass)  return true;
+        if (symbolicRef.isStatic() || symbolicRef.isPrivate())  return false;
+        return (definingClass.isAssignableFrom(symbolicRefClass) ||  // Msym overrides Mdef
+                symbolicRefClass.isInterface());                     // Mdef implements Msym
+    }
 }
--- jdk/src/share/classes/java/lang/invoke/MethodHandleProxies.java	2012-08-10 10:26:57.000000000 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleProxies.java	2013-05-05 09:38:32.000000000 -0700
@@ -26,8 +26,12 @@
 package java.lang.invoke;
 
 import java.lang.reflect.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import sun.invoke.WrapperInstance;
 import java.util.ArrayList;
+import sun.reflect.Reflection;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * This class consists exclusively of static methods that help adapt
@@ -137,6 +141,21 @@
     <T> T asInterfaceInstance(final Class<T> intfc, final MethodHandle target) {
         if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
             throw new IllegalArgumentException("not a public interface: "+intfc.getName());
+        final MethodHandle mh;
+        if (System.getSecurityManager() != null) {
+            final int CALLER_FRAME = 2; // 0: Reflection, 1: asInterfaceInstance, 2: caller
+            final Class<?> caller = Reflection.getCallerClass(CALLER_FRAME);
+            final ClassLoader ccl = (caller != null) ? caller.getClassLoader() : null;
+            ReflectUtil.checkProxyPackageAccess(ccl, intfc);
+            mh = maybeBindCaller(target, caller);
+        } else {
+            mh = target;
+        }
+        ClassLoader proxyLoader = intfc.getClassLoader();
+        if (proxyLoader == null) {
+            ClassLoader cl = Thread.currentThread().getContextClassLoader(); // avoid use of BCP
+            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();
+        }
         final Method[] methods = getSingleNameMethods(intfc);
         if (methods == null)
             throw new IllegalArgumentException("not a single-method interface: "+intfc.getName());
@@ -144,31 +163,61 @@
         for (int i = 0; i < methods.length; i++) {
             Method sm = methods[i];
             MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());
-            MethodHandle checkTarget = target.asType(smMT);  // make throw WMT
+            MethodHandle checkTarget = mh.asType(smMT);  // make throw WMT
             checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));
             vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());
         }
-        return intfc.cast(Proxy.newProxyInstance(
-                intfc.getClassLoader(),
-                new Class[]{ intfc, WrapperInstance.class },
-                new InvocationHandler() {
-                    private Object getArg(String name) {
-                        if ((Object)name == "getWrapperInstanceTarget")  return target;
-                        if ((Object)name == "getWrapperInstanceType")    return intfc;
-                        throw new AssertionError();
+        final InvocationHandler ih = new InvocationHandler() {
+                private Object getArg(String name) {
+                    if ((Object)name == "getWrapperInstanceTarget")  return target;
+                    if ((Object)name == "getWrapperInstanceType")    return intfc;
+                    throw new AssertionError();
+                }
+                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                    for (int i = 0; i < methods.length; i++) {
+                        if (method.equals(methods[i]))
+                            return vaTargets[i].invokeExact(args);
                     }
-                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                        for (int i = 0; i < methods.length; i++) {
-                            if (method.equals(methods[i]))
-                                return vaTargets[i].invokeExact(args);
-                        }
-                        if (method.getDeclaringClass() == WrapperInstance.class)
-                            return getArg(method.getName());
-                        if (isObjectMethod(method))
-                            return callObjectMethod(this, method, args);
-                        throw new InternalError("bad proxy method: "+method);
-                    }
-                }));
+                    if (method.getDeclaringClass() == WrapperInstance.class)
+                        return getArg(method.getName());
+                    if (isObjectMethod(method))
+                        return callObjectMethod(this, method, args);
+                    throw new InternalError("bad proxy method: "+method);
+                }
+            };
+
+        final Object proxy;
+        if (System.getSecurityManager() != null) {
+            // sun.invoke.WrapperInstance is a restricted interface not accessible
+            // by any non-null class loader.
+            final ClassLoader loader = proxyLoader;
+            proxy = AccessController.doPrivileged(new PrivilegedAction<Object>() {
+                public Object run() {
+                    return Proxy.newProxyInstance(
+                            loader,
+                            new Class<?>[]{ intfc, WrapperInstance.class },
+                            ih);
+                }
+            });
+        } else {
+            proxy = Proxy.newProxyInstance(proxyLoader,
+                                           new Class<?>[]{ intfc, WrapperInstance.class },
+                                           ih);
+        }
+        return intfc.cast(proxy);
+    }
+
+    private static MethodHandle maybeBindCaller(MethodHandle target, Class<?> hostClass) {
+        if (hostClass == null || hostClass.getClassLoader() == null)
+            return target;
+
+        MethodHandle cbmh = MethodHandleImpl.bindCaller(target, hostClass);
+        if (target.isVarargsCollector()) {
+            MethodType type = cbmh.type();
+            int arity = type.parameterCount();
+            return cbmh.asVarargsCollector(type.parameterType(arity-1));
+        }
+        return cbmh;
     }
 
     /**
--- jdk/src/share/classes/java/lang/invoke/MethodHandleStatics.java	2012-08-10 10:26:57.000000000 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleStatics.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -107,7 +107,7 @@
     /*non-public*/ static RuntimeException newIllegalArgumentException(String message, Object obj, Object obj2) {
         return new IllegalArgumentException(message(message, obj, obj2));
     }
-    /*non-public*/ static Error uncaughtException(Exception ex) {
+    /*non-public*/ static Error uncaughtException(Throwable ex) {
         Error err = new InternalError("uncaught exception");
         err.initCause(ex);
         return err;
--- jdk/src/share/classes/java/lang/invoke/MethodHandles.java	2012-08-10 10:26:57.000000000 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandles.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -584,17 +584,20 @@
         MethodHandle findStatic(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
             MemberName method = resolveOrFail(refc, name, type, true);
             checkSecurityManager(refc, method);  // stack walk magic: do not refactor
-            return accessStatic(refc, method);
+            Class<?> callerClass = findBoundCallerClass(method);  // stack walk magic: do not refactor
+            return accessStatic(refc, method, callerClass);
         }
         private
-        MethodHandle accessStatic(Class<?> refc, MemberName method) throws IllegalAccessException {
+        MethodHandle accessStatic(Class<?> refc, MemberName method, Class<?> callerClass) throws IllegalAccessException {
             checkMethod(refc, method, true);
-            return MethodHandleImpl.findMethod(method, false, lookupClassOrNull());
+            MethodHandle mh = MethodHandleImpl.findMethod(method, false, lookupClassOrNull());
+            mh = maybeBindCaller(method, mh, callerClass);
+            return mh;
         }
         private
         MethodHandle resolveStatic(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
             MemberName method = resolveOrFail(refc, name, type, true);
-            return accessStatic(refc, method);
+            return accessStatic(refc, method, lookupClass);
         }
 
         /**
@@ -638,15 +641,17 @@
         public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
             MemberName method = resolveOrFail(refc, name, type, false);
             checkSecurityManager(refc, method);  // stack walk magic: do not refactor
-            return accessVirtual(refc, method);
+            Class<?> callerClass = findBoundCallerClass(method);  // stack walk magic: do not refactor
+            return accessVirtual(refc, method, callerClass);
         }
         private MethodHandle resolveVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
             MemberName method = resolveOrFail(refc, name, type, false);
-            return accessVirtual(refc, method);
+            return accessVirtual(refc, method, lookupClass);
         }
-        private MethodHandle accessVirtual(Class<?> refc, MemberName method) throws IllegalAccessException {
+        private MethodHandle accessVirtual(Class<?> refc, MemberName method, Class<?> callerClass) throws IllegalAccessException {
             checkMethod(refc, method, false);
             MethodHandle mh = MethodHandleImpl.findMethod(method, true, lookupClassOrNull());
+            mh = maybeBindCaller(method, mh, callerClass);
             return restrictProtectedReceiver(method, mh);
         }
 
@@ -684,9 +689,10 @@
         }
         private MethodHandle accessConstructor(Class<?> refc, MemberName ctor) throws IllegalAccessException {
             assert(ctor.isConstructor());
-            checkAccess(refc, ctor);
+            checkAccess(refc, ctor, false /* is_setter */);
             MethodHandle rawMH = MethodHandleImpl.findMethod(ctor, false, lookupClassOrNull());
             MethodHandle allocMH = MethodHandleImpl.makeAllocator(rawMH);
+            assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
             return fixVarargs(allocMH, rawMH);
         }
         private MethodHandle resolveConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
@@ -749,19 +755,45 @@
             checkSpecialCaller(specialCaller);
             MemberName method = resolveOrFail(refc, name, type, false, false, specialCaller);
             checkSecurityManager(refc, method);  // stack walk magic: do not refactor
-            return accessSpecial(refc, method, specialCaller);
+            Class<?> callerClass = findBoundCallerClass(method);  // stack walk magic: do not refactor
+            return accessSpecial(refc, method, callerClass, specialCaller);
         }
         private MethodHandle accessSpecial(Class<?> refc, MemberName method,
+                                           Class<?> callerClass,
                                            Class<?> specialCaller) throws NoSuchMethodException, IllegalAccessException {
             checkMethod(refc, method, false);
+
+            Class<?> refcAsSuper;
+            if (refc != lookupClass() &&
+                refc != (refcAsSuper = lookupClass().getSuperclass()) &&
+                refc.isAssignableFrom(lookupClass())) {
+                assert(!method.getName().equals("<init>"));  // not this code path
+                // Per JVMS 6.5, desc. of invokespecial instruction:
+                // If the method is in a superclass of the LC,
+                // and if our original search was above LC.super,
+                // repeat the search (symbolic lookup) from LC.super.
+                // FIXME: MemberName.resolve should handle this instead.
+                MemberName m2 = new MemberName(refcAsSuper,
+                                               method.getName(),
+                                               method.getMethodType(),
+                                               REF_invokeSpecial);
+                m2 = IMPL_NAMES.resolveOrNull(m2, true, lookupClassOrNull());
+                if (m2 == null)  throw new InternalError(method.toString());
+                method = m2;
+                refc = refcAsSuper;
+                // redo basic checks
+                checkMethod(refc, method, false);
+            }
+
             MethodHandle mh = MethodHandleImpl.findMethod(method, false, specialCaller);
+            mh = maybeBindCaller(method, mh, callerClass);
             return restrictReceiver(method, mh, specialCaller);
         }
         private MethodHandle resolveSpecial(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
             Class<?> specialCaller = lookupClass();
             checkSpecialCaller(specialCaller);
             MemberName method = resolveOrFail(refc, name, type, false, false, specialCaller);
-            return accessSpecial(refc, method, specialCaller);
+            return accessSpecial(refc, method, lookupClass, specialCaller);
         }
 
         /**
@@ -922,6 +954,9 @@
             checkSecurityManager(refc, method);  // stack walk magic: do not refactor
             checkMethod(refc, method, false);
             MethodHandle dmh = MethodHandleImpl.findMethod(method, true, lookupClassOrNull());
+            Class<?> callerClass = findBoundCallerClass(method);  // stack walk magic: do not refactor
+            MethodHandle bcmh = maybeBindCaller(method, dmh, callerClass);
+            if (bcmh != dmh)  return fixVarargs(bcmh.bindTo(receiver), dmh);
             MethodHandle bmh = MethodHandleImpl.bindReceiver(dmh, receiver);
             if (bmh == null)
                 throw method.makeAccessException("no access", this);
@@ -956,6 +991,8 @@
                 return MethodHandleImpl.findMethod(method, true, /*no lookupClass*/ null);
             checkMethod(method.getDeclaringClass(), method, method.isStatic());
             MethodHandle mh = MethodHandleImpl.findMethod(method, true, lookupClassOrNull());
+            Class<?> callerClass = findBoundCallerClass(method);  // stack walk magic: do not refactor
+            mh = maybeBindCaller(method, mh, callerClass);
             return restrictProtectedReceiver(method, mh);
         }
 
@@ -987,6 +1024,8 @@
             // ignore m.isAccessible:  this is a new kind of access
             checkMethod(m.getDeclaringClass(), method, false);
             MethodHandle mh = MethodHandleImpl.findMethod(method, false, lookupClassOrNull());
+            Class<?> callerClass = findBoundCallerClass(method);  // stack walk magic: do not refactor
+            mh = maybeBindCaller(method, mh, callerClass);
             return restrictReceiver(method, mh, specialCaller);
         }
 
@@ -1018,9 +1057,10 @@
             if (c.isAccessible()) {
                 rawCtor = MethodHandleImpl.findMethod(ctor, false, /*no lookupClass*/ null);
             } else {
-                checkAccess(c.getDeclaringClass(), ctor);
+                checkAccess(c.getDeclaringClass(), ctor, false /* is_setter */);
                 rawCtor = MethodHandleImpl.findMethod(ctor, false, lookupClassOrNull());
             }
+            assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
             MethodHandle allocator = MethodHandleImpl.makeAllocator(rawCtor);
             return fixVarargs(allocator, rawCtor);
         }
@@ -1095,7 +1135,29 @@
         }
 
         /**
+         * Find my trustable caller class if m is a caller sensitive method.
+         * If this lookup object has private access, then the caller class is the lookupClass.
+         * Otherwise, it is the caller of the currently executing public API method (e.g., findVirtual).
+         * This is the same caller class as is used by checkSecurityManager.
+         * This function performs stack walk magic: do not refactor it.
+         */
+        Class<?> findBoundCallerClass(MemberName m) {
+            Class<?> callerClass = null;
+            if (MethodHandleNatives.isCallerSensitive(m)) {
+                // Do not refactor this to a more "logical" place, since it is stack walk magic.
+                // Note that this is the same expression as in Step 2 below in checkSecurityManager.
+                callerClass = ((allowedModes & PRIVATE) != 0
+                               ? lookupClass  // for strong access modes, no extra check
+                               // next line does stack walk magic; do not refactor:
+                               : getCallerClassAtEntryPoint(true));
+            }
+            return callerClass;
+        }
+        /**
          * Perform necessary <a href="MethodHandles.Lookup.html#secmgr">access checks</a>.
+         * Determines a trustable caller class to compare with refc, the symbolic reference class.
+         * If this lookup object has private access, then the caller class is the lookupClass.
+         * Otherwise, it is the caller of the currently executing public API method (e.g., findVirtual).
          * This function performs stack walk magic: do not refactor it.
          */
         void checkSecurityManager(Class<?> refc, MemberName m) {
@@ -1149,14 +1211,17 @@
             else if (wantStatic != m.isStatic())
                 message = wantStatic ? "expected a static method" : "expected a non-static method";
             else
-                { checkAccess(refc, m); return; }
+                { checkAccess(refc, m, false /* is_setter */); return; }
             throw m.makeAccessException(message, this);
         }
 
-        void checkAccess(Class<?> refc, MemberName m) throws IllegalAccessException {
+        void checkAccess(Class<?> refc, MemberName m, boolean isSetter) throws IllegalAccessException {
             int allowedModes = this.allowedModes;
             if (allowedModes == TRUSTED)  return;
             int mods = m.getModifiers();
+            if (m.isField() && Modifier.isFinal(mods) && isSetter) {
+              throw m.makeAccessException("unexpected set of a final field", this);
+            }
             if (Modifier.isPublic(mods) && Modifier.isPublic(refc.getModifiers()) && allowedModes != 0)
                 return;  // common case
             int requestedModes = fixmods(mods);  // adjust 0 => PACKAGE
@@ -1232,6 +1297,18 @@
             MethodHandle narrowMH = MethodHandleImpl.convertArguments(mh, narrowType, rawType, 0);
             return fixVarargs(narrowMH, mh);
         }
+        private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh,
+                                             Class<?> callerClass)
+                                             throws IllegalAccessException {
+            if (allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))
+                return mh;
+            Class<?> hostClass = lookupClass;
+            if ((allowedModes & PRIVATE) == 0)  // caller must use full-power lookup
+                hostClass = callerClass;  // callerClass came from a security manager style stack walk
+            MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, hostClass);
+            cbmh = fixVarargs(cbmh, mh);  // in JDK 7 version, varargs happens earlier and must be repaired
+            return cbmh;
+        }
 
         MethodHandle makeAccessor(Class<?> refc, MemberName field,
                                   boolean trusted, boolean isSetter,
@@ -1243,7 +1320,7 @@
                                                 : "expected a non-static field", this);
             if (trusted)
                 return MethodHandleImpl.accessField(field, isSetter, /*no lookupClass*/ null);
-            checkAccess(refc, field);
+            checkAccess(refc, field, isSetter);
             MethodHandle mh = MethodHandleImpl.accessField(field, isSetter, lookupClassOrNull());
             return restrictProtectedReceiver(field, mh);
         }
--- jdk/src/share/classes/java/lang/management/ManagementFactory.java	2012-08-10 10:26:58.000000000 -0700
+++ jdk/src/share/classes/java/lang/management/ManagementFactory.java	2013-05-05 09:38:32.000000000 -0700
@@ -802,20 +802,20 @@
      */
     private static void addMXBean(final MBeanServer mbs, final PlatformManagedObject pmo) {
         // Make DynamicMBean out of MXBean by wrapping it with a StandardMBean
-        final DynamicMBean dmbean;
-        if (pmo instanceof DynamicMBean) {
-            dmbean = DynamicMBean.class.cast(pmo);
-        } else if (pmo instanceof NotificationEmitter) {
-            dmbean = new StandardEmitterMBean(pmo, null, true, (NotificationEmitter) pmo);
-        } else {
-            dmbean = new StandardMBean(pmo, null, true);
-        }
-
         try {
             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
                 public Void run() throws InstanceAlreadyExistsException,
                                          MBeanRegistrationException,
                                          NotCompliantMBeanException {
+                    final DynamicMBean dmbean;
+                    if (pmo instanceof DynamicMBean) {
+                        dmbean = DynamicMBean.class.cast(pmo);
+                    } else if (pmo instanceof NotificationEmitter) {
+                        dmbean = new StandardEmitterMBean(pmo, null, true, (NotificationEmitter) pmo);
+                    } else {
+                        dmbean = new StandardMBean(pmo, null, true);
+                    }
+
                     mbs.registerMBean(dmbean, pmo.getObjectName());
                     return null;
                 }
--- jdk/src/share/classes/java/lang/ref/Finalizer.java	2012-08-10 10:26:59.000000000 -0700
+++ jdk/src/share/classes/java/lang/ref/Finalizer.java	2013-05-05 09:38:32.000000000 -0700
@@ -38,9 +38,9 @@
      */
     static native void invokeFinalizeMethod(Object o) throws Throwable;
 
-    static private ReferenceQueue queue = new ReferenceQueue();
-    static private Finalizer unfinalized = null;
-    static private Object lock = new Object();
+    private static ReferenceQueue queue = new ReferenceQueue();
+    private static Finalizer unfinalized = null;
+    private static final Object lock = new Object();
 
     private Finalizer
         next = null,
@@ -142,7 +142,11 @@
     /* Called by Runtime.runFinalization() */
     static void runFinalization() {
         forkSecondaryFinalizer(new Runnable() {
+            private volatile boolean running;
             public void run() {
+                if (running)
+                    return;
+                running = true;
                 for (;;) {
                     Finalizer f = (Finalizer)queue.poll();
                     if (f == null) break;
@@ -155,7 +159,11 @@
     /* Invoked by java.lang.Shutdown */
     static void runAllFinalizers() {
         forkSecondaryFinalizer(new Runnable() {
+            private volatile boolean running;
             public void run() {
+                if (running)
+                    return;
+                running = true;
                 for (;;) {
                     Finalizer f;
                     synchronized (lock) {
@@ -168,10 +176,14 @@
     }
 
     private static class FinalizerThread extends Thread {
+        private volatile boolean running;
         FinalizerThread(ThreadGroup g) {
             super(g, "Finalizer");
         }
         public void run() {
+            if (running)
+                return;
+            running = true;
             for (;;) {
                 try {
                     Finalizer f = (Finalizer)queue.remove();
--- jdk/src/share/classes/java/lang/reflect/Proxy.java	2012-08-10 10:27:00.000000000 -0700
+++ jdk/src/share/classes/java/lang/reflect/Proxy.java	2013-05-05 09:38:32.000000000 -0700
@@ -27,6 +27,9 @@
 
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.security.AccessController;
+import java.security.Permission;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
@@ -36,6 +39,9 @@
 import java.util.List;
 import java.util.WeakHashMap;
 import sun.misc.ProxyGenerator;
+import sun.reflect.Reflection;
+import sun.reflect.misc.ReflectUtil;
+import sun.security.util.SecurityConstants;
 
 /**
  * {@code Proxy} provides static methods for creating dynamic proxy
@@ -265,9 +271,69 @@
      * @param   h the invocation handler for this proxy instance
      */
     protected Proxy(InvocationHandler h) {
+        doNewInstanceCheck();
         this.h = h;
     }
 
+    private static class ProxyAccessHelper {
+        // The permission is implementation specific.
+        static final Permission PROXY_PERMISSION =
+            new ReflectPermission("proxyConstructorNewInstance");
+        // These system properties are defined to provide a short-term
+        // workaround if customers need to disable the new security checks.
+        static final boolean allowNewInstance;
+        static final boolean allowNullLoader;
+        static {
+            allowNewInstance = getBooleanProperty("sun.reflect.proxy.allowsNewInstance");
+            allowNullLoader = getBooleanProperty("sun.reflect.proxy.allowsNullLoader");
+        }
+
+        private static boolean getBooleanProperty(final String key) {
+            String s = AccessController.doPrivileged(new PrivilegedAction<String>() {
+                public String run() {
+                    return System.getProperty(key);
+                }
+            });
+            return Boolean.valueOf(s);
+        }
+
+        static boolean needsNewInstanceCheck(Class<?> proxyClass) {
+            if (!Proxy.isProxyClass(proxyClass) || allowNewInstance) {
+                return false;
+            }
+
+            if (proxyClass.getName().startsWith(ReflectUtil.PROXY_PACKAGE + ".")) {
+                // all proxy interfaces are public
+                return false;
+            }
+            for (Class<?> intf : proxyClass.getInterfaces()) {
+                if (!Modifier.isPublic(intf.getModifiers())) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    /*
+     * Access check on a proxy class that implements any non-public interface.
+     *
+     * @throws  SecurityException if a security manager exists, and
+     *          the caller does not have the permission.
+     */
+    private void doNewInstanceCheck() {
+        SecurityManager sm = System.getSecurityManager();
+        Class<?> proxyClass = this.getClass();
+        if (sm != null && ProxyAccessHelper.needsNewInstanceCheck(proxyClass)) {
+            try {
+                sm.checkPermission(ProxyAccessHelper.PROXY_PERMISSION);
+            } catch (SecurityException e) {
+                throw new SecurityException("Not allowed to construct a Proxy "
+                        + "instance that implements a non-public interface", e);
+            }
+        }
+    }
+
     /**
      * Returns the {@code java.lang.Class} object for a proxy class
      * given a class loader and an array of interfaces.  The proxy class
@@ -346,6 +412,51 @@
                                          Class<?>... interfaces)
         throws IllegalArgumentException
     {
+        return getProxyClass0(loader, interfaces); // stack walk magic: do not refactor
+    }
+
+    private static void checkProxyLoader(ClassLoader ccl,
+                                         ClassLoader loader)
+    {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            if (loader == null && ccl != null) {
+                if (!ProxyAccessHelper.allowNullLoader) {
+                    sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
+                }
+            }
+        }
+    }
+
+    /*
+     * Generate a proxy class (caller-sensitive).
+     *
+     * To define a proxy class, it performs the access checks as in
+     * Class.forName (VM will invoke ClassLoader.checkPackageAccess):
+     * 1. "getClassLoader" permission check if loader == null
+     * 2. checkPackageAccess on the interfaces it implements
+     *
+     * To get a constructor and new instance of a proxy class, it performs
+     * the package access check on the interfaces it implements
+     * as in Class.getConstructor.
+     *
+     * If an interface is non-public, the proxy class must be defined by
+     * the defining loader of the interface.  If the caller's class loader
+     * is not the same as the defining loader of the interface, the VM
+     * will throw IllegalAccessError when the generated proxy class is
+     * being defined via the defineClass0 method.
+     */
+    private static Class<?> getProxyClass0(ClassLoader loader,
+                                           Class<?>... interfaces) {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            final int CALLER_FRAME = 3; // 0: Reflection, 1: getProxyClass0 2: Proxy 3: caller
+            final Class<?> caller = Reflection.getCallerClass(CALLER_FRAME);
+            final ClassLoader ccl = caller.getClassLoader();
+            checkProxyLoader(ccl, loader);
+            ReflectUtil.checkProxyPackageAccess(ccl, interfaces);
+        }
+
         if (interfaces.length > 65535) {
             throw new IllegalArgumentException("interface limit exceeded");
         }
@@ -497,8 +608,9 @@
                 }
             }
 
-            if (proxyPkg == null) {     // if no non-public proxy interfaces,
-                proxyPkg = "";          // use the unnamed package
+            if (proxyPkg == null) {
+                // if no non-public proxy interfaces, use com.sun.proxy package
+                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
             }
 
             {
@@ -598,22 +710,43 @@
         /*
          * Look up or generate the designated proxy class.
          */
-        Class<?> cl = getProxyClass(loader, interfaces);
+        Class<?> cl = getProxyClass0(loader, interfaces); // stack walk magic: do not refactor
 
         /*
          * Invoke its constructor with the designated invocation handler.
          */
         try {
-            Constructor cons = cl.getConstructor(constructorParams);
-            return cons.newInstance(new Object[] { h });
+            final Constructor<?> cons = cl.getConstructor(constructorParams);
+            final InvocationHandler ih = h;
+            SecurityManager sm = System.getSecurityManager();
+            if (sm != null && ProxyAccessHelper.needsNewInstanceCheck(cl)) {
+                // create proxy instance with doPrivilege as the proxy class may
+                // implement non-public interfaces that requires a special permission
+                return AccessController.doPrivileged(new PrivilegedAction<Object>() {
+                    public Object run() {
+                        return newInstance(cons, ih);
+                    }
+                });
+            } else {
+                return newInstance(cons, ih);
+            }
         } catch (NoSuchMethodException e) {
             throw new InternalError(e.toString());
-        } catch (IllegalAccessException e) {
-            throw new InternalError(e.toString());
-        } catch (InstantiationException e) {
+        }
+    }
+
+    private static Object newInstance(Constructor<?> cons, InvocationHandler h) {
+        try {
+            return cons.newInstance(new Object[] {h} );
+        } catch (IllegalAccessException | InstantiationException e) {
             throw new InternalError(e.toString());
         } catch (InvocationTargetException e) {
-            throw new InternalError(e.toString());
+            Throwable t = e.getCause();
+            if (t instanceof RuntimeException) {
+                throw (RuntimeException) t;
+            } else {
+                throw new InternalError(t.toString());
+            }
         }
     }
 
--- jdk/src/share/classes/java/net/AbstractPlainDatagramSocketImpl.java	2012-08-10 10:27:00.000000000 -0700
+++ jdk/src/share/classes/java/net/AbstractPlainDatagramSocketImpl.java	2013-05-05 09:38:32.000000000 -0700
@@ -124,7 +124,7 @@
      * not connected already.
      */
     protected void disconnect() {
-        disconnect0(connectedAddress.family);
+        disconnect0(connectedAddress.holder().getFamily());
         connected = false;
         connectedAddress = null;
         connectedPort = -1;
--- jdk/src/share/classes/java/net/InMemoryCookieStore.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/InMemoryCookieStore.java	2013-05-05 09:38:31.000000000 -0700
@@ -91,10 +91,8 @@
                 if (cookie.getDomain() != null) {
                     addIndex(domainIndex, cookie.getDomain(), cookie);
                 }
-                if (uri != null) {
-                    // add it to uri index, too
-                    addIndex(uriIndex, getEffectiveURI(uri), cookie);
-                }
+                // add it to uri index, too
+                addIndex(uriIndex, getEffectiveURI(uri), cookie);
             }
         } finally {
             lock.unlock();
--- jdk/src/share/classes/java/net/Inet4Address.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/Inet4Address.java	2013-05-05 09:38:31.000000000 -0700
@@ -102,27 +102,28 @@
 
     Inet4Address() {
         super();
-        hostName = null;
-        address = 0;
-        family = IPv4;
+        holder().hostName = null;
+        holder().address = 0;
+        holder().family = IPv4;
     }
 
     Inet4Address(String hostName, byte addr[]) {
-        this.hostName = hostName;
-        this.family = IPv4;
+        holder().hostName = hostName;
+        holder().family = IPv4;
         if (addr != null) {
             if (addr.length == INADDRSZ) {
-                address  = addr[3] & 0xFF;
+                int address  = addr[3] & 0xFF;
                 address |= ((addr[2] << 8) & 0xFF00);
                 address |= ((addr[1] << 16) & 0xFF0000);
                 address |= ((addr[0] << 24) & 0xFF000000);
+                holder().address = address;
             }
         }
     }
     Inet4Address(String hostName, int address) {
-        this.hostName = hostName;
-        this.family = IPv4;
-        this.address = address;
+        holder().hostName = hostName;
+        holder().family = IPv4;
+        holder().address = address;
     }
 
     /**
@@ -136,8 +137,8 @@
     private Object writeReplace() throws ObjectStreamException {
         // will replace the to be serialized 'this' object
         InetAddress inet = new InetAddress();
-        inet.hostName = this.hostName;
-        inet.address = this.address;
+        inet.holder().hostName = holder().getHostName();
+        inet.holder().address = holder().getAddress();
 
         /**
          * Prior to 1.4 an InetAddress was created with a family
@@ -145,7 +146,7 @@
          * For compatibility reasons we must therefore write the
          * the InetAddress with this family.
          */
-        inet.family = 2;
+        inet.holder().family = 2;
 
         return inet;
     }
@@ -159,7 +160,7 @@
      * @since   JDK1.1
      */
     public boolean isMulticastAddress() {
-        return ((address & 0xf0000000) == 0xe0000000);
+        return ((holder().getAddress() & 0xf0000000) == 0xe0000000);
     }
 
     /**
@@ -169,7 +170,7 @@
      * @since 1.4
      */
     public boolean isAnyLocalAddress() {
-        return address == 0;
+        return holder().getAddress() == 0;
     }
 
     /**
@@ -198,6 +199,7 @@
         // defined in "Documenting Special Use IPv4 Address Blocks
         // that have been Registered with IANA" by Bill Manning
         // draft-manning-dsua-06.txt
+        int address = holder().getAddress();
         return (((address >>> 24) & 0xFF) == 169)
             && (((address >>> 16) & 0xFF) == 254);
     }
@@ -214,6 +216,7 @@
         // 10/8 prefix
         // 172.16/12 prefix
         // 192.168/16 prefix
+        int address = holder().getAddress();
         return (((address >>> 24) & 0xFF) == 10)
             || ((((address >>> 24) & 0xFF) == 172)
                 && (((address >>> 16) & 0xF0) == 16))
@@ -260,6 +263,7 @@
      */
     public boolean isMCLinkLocal() {
         // 224.0.0/24 prefix and ttl == 1
+        int address = holder().getAddress();
         return (((address >>> 24) & 0xFF) == 224)
             && (((address >>> 16) & 0xFF) == 0)
             && (((address >>> 8) & 0xFF) == 0);
@@ -275,6 +279,7 @@
      */
     public boolean isMCSiteLocal() {
         // 239.255/16 prefix or ttl < 32
+        int address = holder().getAddress();
         return (((address >>> 24) & 0xFF) == 239)
             && (((address >>> 16) & 0xFF) == 255);
     }
@@ -290,6 +295,7 @@
      */
     public boolean isMCOrgLocal() {
         // 239.192 - 239.195
+        int address = holder().getAddress();
         return (((address >>> 24) & 0xFF) == 239)
             && (((address >>> 16) & 0xFF) >= 192)
             && (((address >>> 16) & 0xFF) <= 195);
@@ -303,6 +309,7 @@
      * @return  the raw IP address of this object.
      */
     public byte[] getAddress() {
+        int address = holder().getAddress();
         byte[] addr = new byte[INADDRSZ];
 
         addr[0] = (byte) ((address >>> 24) & 0xFF);
@@ -328,7 +335,7 @@
      * @return  a hash code value for this IP address.
      */
     public int hashCode() {
-        return address;
+        return holder().getAddress();
     }
 
     /**
@@ -349,7 +356,7 @@
      */
     public boolean equals(Object obj) {
         return (obj != null) && (obj instanceof Inet4Address) &&
-            (((InetAddress)obj).address == address);
+            (((InetAddress)obj).holder().getAddress() == holder().getAddress());
     }
 
     // Utilities
--- jdk/src/share/classes/java/net/Inet4AddressImpl.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/Inet4AddressImpl.java	2013-05-05 09:38:31.000000000 -0700
@@ -40,7 +40,7 @@
     public synchronized InetAddress anyLocalAddress() {
         if (anyLocalAddress == null) {
             anyLocalAddress = new Inet4Address(); // {0x00,0x00,0x00,0x00}
-            anyLocalAddress.hostName = "0.0.0.0";
+            anyLocalAddress.holder().hostName = "0.0.0.0";
         }
         return anyLocalAddress;
     }
--- jdk/src/share/classes/java/net/Inet6Address.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/Inet6Address.java	2013-05-05 09:38:31.000000000 -0700
@@ -213,18 +213,18 @@
 
     Inet6Address() {
         super();
-        hostName = null;
+        holder().hostName = null;
         ipaddress = new byte[INADDRSZ];
-        family = IPv6;
+        holder().family = IPv6;
     }
 
     /* checking of value for scope_id should be done by caller
      * scope_id must be >= 0, or -1 to indicate not being set
      */
     Inet6Address(String hostName, byte addr[], int scope_id) {
-        this.hostName = hostName;
+        holder().hostName = hostName;
         if (addr.length == INADDRSZ) { // normal IPv6 address
-            family = IPv6;
+            holder().family = IPv6;
             ipaddress = addr.clone();
         }
         if (scope_id >= 0) {
@@ -325,9 +325,9 @@
     }
 
     private void initif(String hostName, byte addr[],NetworkInterface nif) throws UnknownHostException {
-        this.hostName = hostName;
+        holder().hostName = hostName;
         if (addr.length == INADDRSZ) { // normal IPv6 address
-            family = IPv6;
+            holder().family = IPv6;
             ipaddress = addr.clone();
         }
         if (nif != null) {
@@ -412,6 +412,11 @@
         throws IOException, ClassNotFoundException {
         scope_ifname = null;
         scope_ifname_set = false;
+
+        if (getClass().getClassLoader() != null) {
+            throw new SecurityException ("invalid address type");
+        }
+
         s.defaultReadObject();
 
         if (ifname != null && !"".equals (ifname)) {
@@ -445,7 +450,7 @@
                                              ipaddress.length);
         }
 
-        if (family != IPv6) {
+        if (holder().getFamily() != IPv6) {
             throw new InvalidObjectException("invalid address family type");
         }
     }
--- jdk/src/share/classes/java/net/Inet6AddressImpl.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/Inet6AddressImpl.java	2013-05-05 09:38:32.000000000 -0700
@@ -81,7 +81,7 @@
         if (anyLocalAddress == null) {
             if (InetAddress.preferIPv6Address) {
                 anyLocalAddress = new Inet6Address();
-                anyLocalAddress.hostName = "::";
+                anyLocalAddress.holder().hostName = "::";
             } else {
                 anyLocalAddress = (new Inet4AddressImpl()).anyLocalAddress();
             }
--- jdk/src/share/classes/java/net/InetAddress.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/InetAddress.java	2013-05-05 09:38:32.000000000 -0700
@@ -34,8 +34,12 @@
 import java.util.ArrayList;
 import java.security.AccessController;
 import java.io.ObjectStreamException;
+import java.io.ObjectStreamField;
 import java.io.IOException;
 import java.io.ObjectInputStream;
+import java.io.ObjectInputStream.GetField;
+import java.io.ObjectOutputStream;
+import java.io.ObjectOutputStream.PutField;
 import sun.security.action.*;
 import sun.net.InetAddressCachePolicy;
 import sun.net.util.IPAddressUtil;
@@ -199,25 +203,47 @@
     /* Specify address family preference */
     static transient boolean preferIPv6Address = false;
 
-    /**
-     * @serial
-     */
-    String hostName;
+    static class InetAddressHolder {
 
-    /**
-     * Holds a 32-bit IPv4 address.
-     *
-     * @serial
-     */
-    int address;
+        InetAddressHolder() {}
 
-    /**
-     * Specifies the address family type, for instance, '1' for IPv4
-     * addresses, and '2' for IPv6 addresses.
-     *
-     * @serial
-     */
-    int family;
+        InetAddressHolder(String hostName, int address, int family) {
+            this.hostName = hostName;
+            this.address = address;
+            this.family = family;
+        }
+
+        String hostName;
+
+        String getHostName() {
+            return hostName;
+        }
+
+        /**
+         * Holds a 32-bit IPv4 address.
+         */
+        int address;
+
+        int getAddress() {
+            return address;
+        }
+
+        /**
+         * Specifies the address family type, for instance, '1' for IPv4
+         * addresses, and '2' for IPv6 addresses.
+         */
+        int family;
+
+        int getFamily() {
+            return family;
+        }
+    }
+
+    final transient InetAddressHolder holder;
+
+    InetAddressHolder holder() {
+        return holder;
+    }
 
     /* Used to store the name service provider */
     private static List<NameService> nameServices = null;
@@ -245,6 +271,7 @@
      * put in the address cache, since it is not created by name.
      */
     InetAddress() {
+        holder = new InetAddressHolder();
     }
 
     /**
@@ -257,7 +284,7 @@
      */
     private Object readResolve() throws ObjectStreamException {
         // will replace the deserialized 'this' object
-        return new Inet4Address(this.hostName, this.address);
+        return new Inet4Address(holder().getHostName(), holder().getAddress());
     }
 
     /**
@@ -494,10 +521,10 @@
      * @see SecurityManager#checkConnect
      */
     String getHostName(boolean check) {
-        if (hostName == null) {
-            hostName = InetAddress.getHostFromNameService(this, check);
+        if (holder().getHostName() == null) {
+            holder().hostName = InetAddress.getHostFromNameService(this, check);
         }
-        return hostName;
+        return holder().getHostName();
     }
 
     /**
@@ -660,6 +687,7 @@
      * @return  a string representation of this IP address.
      */
     public String toString() {
+        String hostName = holder().getHostName();
         return ((hostName != null) ? hostName : "")
             + "/" + getHostAddress();
     }
@@ -1515,14 +1543,58 @@
         }
     }
 
+    private static final long FIELDS_OFFSET;
+    private static final sun.misc.Unsafe UNSAFE;
+
+    static {
+        try {
+            sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
+            FIELDS_OFFSET = unsafe.objectFieldOffset(
+                InetAddress.class.getDeclaredField("holder")
+            );
+            UNSAFE = unsafe;
+        } catch (ReflectiveOperationException e) {
+            throw new Error(e);
+        }
+    }
+
     private void readObject (ObjectInputStream s) throws
                          IOException, ClassNotFoundException {
-        s.defaultReadObject ();
         if (getClass().getClassLoader() != null) {
-            hostName = null;
-            address = 0;
             throw new SecurityException ("invalid address type");
         }
+        GetField gf = s.readFields();
+        String host = (String)gf.get("hostName", null);
+        int address= gf.get("address", 0);
+        int family= gf.get("family", 0);
+        InetAddressHolder h = new InetAddressHolder(host, address, family);
+        UNSAFE.putObject(this, FIELDS_OFFSET, h);
+    }
+
+    /* needed because the serializable fields no longer exist */
+
+    /**
+     * @serialField hostName String
+     * @serialField address int
+     * @serialField family int
+     */
+    private static final ObjectStreamField[] serialPersistentFields = {
+        new ObjectStreamField("hostName", String.class),
+        new ObjectStreamField("address", int.class),
+        new ObjectStreamField("family", int.class),
+    };
+
+    private void writeObject (ObjectOutputStream s) throws
+                        IOException {
+        if (getClass().getClassLoader() != null) {
+            throw new SecurityException ("invalid address type");
+        }
+        PutField pf = s.putFields();
+        pf.put("hostName", holder().hostName);
+        pf.put("address", holder().address);
+        pf.put("family", holder().family);
+        s.writeFields();
+        s.flush();
     }
 }
 
--- jdk/src/share/classes/java/net/InetSocketAddress.java	2012-08-10 10:27:01.000000000 -0700
+++ jdk/src/share/classes/java/net/InetSocketAddress.java	2013-05-05 09:38:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,9 +24,12 @@
  */
 package java.net;
 
-import java.io.ObjectInputStream;
 import java.io.IOException;
 import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamException;
+import java.io.ObjectStreamField;
 
 /**
  *
@@ -46,23 +49,105 @@
  * @see java.net.ServerSocket
  * @since 1.4
  */
-public class InetSocketAddress extends SocketAddress {
-    /* The hostname of the Socket Address
-     * @serial
-     */
-    private String hostname = null;
-    /* The IP address of the Socket Address
-     * @serial
-     */
-    private InetAddress addr = null;
-    /* The port number of the Socket Address
-     * @serial
-     */
-    private int port;
+public class InetSocketAddress
+    extends SocketAddress
+{
+    // Private implementation class pointed to by all public methods.
+    private static class InetSocketAddressHolder {
+        // The hostname of the Socket Address
+        private String hostname;
+        // The IP address of the Socket Address
+        private InetAddress addr;
+        // The port number of the Socket Address
+        private int port;
+
+        private InetSocketAddressHolder(String hostname, InetAddress addr, int port) {
+            this.hostname = hostname;
+            this.addr = addr;
+            this.port = port;
+        }
+
+        private int getPort() {
+            return port;
+        }
+
+        private InetAddress getAddress() {
+            return addr;
+        }
+
+        private String getHostName() {
+            if (hostname != null)
+                return hostname;
+            if (addr != null)
+                return addr.getHostName();
+            return null;
+        }
+
+        private String getHostString() {
+            if (hostname != null)
+                return hostname;
+            if (addr != null) {
+                if (addr.holder().getHostName() != null)
+                    return addr.holder().getHostName();
+                else
+                    return addr.getHostAddress();
+            }
+            return null;
+        }
+
+        private boolean isUnresolved() {
+            return addr == null;
+        }
+
+        @Override
+        public String toString() {
+            if (isUnresolved()) {
+                return hostname + ":" + port;
+            } else {
+                return addr.toString() + ":" + port;
+            }
+        }
+
+        @Override
+        public final boolean equals(Object obj) {
+            if (obj == null || !(obj instanceof InetSocketAddressHolder))
+                return false;
+            InetSocketAddressHolder that = (InetSocketAddressHolder)obj;
+            boolean sameIP;
+            if (addr != null)
+                sameIP = addr.equals(that.addr);
+            else if (hostname != null)
+                sameIP = (that.addr == null) &&
+                    hostname.equalsIgnoreCase(that.hostname);
+            else
+                sameIP = (that.addr == null) && (that.hostname == null);
+            return sameIP && (port == that.port);
+        }
+
+        @Override
+        public final int hashCode() {
+            if (addr != null)
+                return addr.hashCode() + port;
+            if (hostname != null)
+                return hostname.toLowerCase().hashCode() + port;
+            return port;
+        }
+    }
+
+    private final transient InetSocketAddressHolder holder;
 
     private static final long serialVersionUID = 5076001401234631237L;
 
-    private InetSocketAddress() {
+    private static int checkPort(int port) {
+        if (port < 0 || port > 0xFFFF)
+            throw new IllegalArgumentException("port out of range:" + port);
+        return port;
+    }
+
+    private static String checkHost(String hostname) {
+        if (hostname == null)
+            throw new IllegalArgumentException("hostname can't be null");
+        return hostname;
     }
 
     /**
@@ -97,14 +182,10 @@
      * range of valid port values.
      */
     public InetSocketAddress(InetAddress addr, int port) {
-        if (port < 0 || port > 0xFFFF) {
-            throw new IllegalArgumentException("port out of range:" + port);
-        }
-        this.port = port;
-        if (addr == null)
-            this.addr = InetAddress.anyLocalAddress();
-        else
-            this.addr = addr;
+        holder = new InetSocketAddressHolder(
+                        null,
+                        addr == null ? InetAddress.anyLocalAddress() : addr,
+                        checkPort(port));
     }
 
     /**
@@ -132,19 +213,20 @@
      * @see     #isUnresolved()
      */
     public InetSocketAddress(String hostname, int port) {
-        if (port < 0 || port > 0xFFFF) {
-            throw new IllegalArgumentException("port out of range:" + port);
-        }
-        if (hostname == null) {
-            throw new IllegalArgumentException("hostname can't be null");
-        }
+        checkHost(hostname);
+        InetAddress addr = null;
+        String host = null;
         try {
             addr = InetAddress.getByName(hostname);
         } catch(UnknownHostException e) {
-            this.hostname = hostname;
-            addr = null;
+            host = hostname;
         }
-        this.port = port;
+        holder = new InetSocketAddressHolder(host, addr, checkPort(port));
+    }
+
+    // private constructor for creating unresolved instances
+    private InetSocketAddress(int port, String hostname) {
+        holder = new InetSocketAddressHolder(hostname, null, port);
     }
 
     /**
@@ -169,31 +251,67 @@
      * @since 1.5
      */
     public static InetSocketAddress createUnresolved(String host, int port) {
-        if (port < 0 || port > 0xFFFF) {
-            throw new IllegalArgumentException("port out of range:" + port);
-        }
-        if (host == null) {
-            throw new IllegalArgumentException("hostname can't be null");
-        }
-        InetSocketAddress s = new InetSocketAddress();
-        s.port = port;
-        s.hostname = host;
-        s.addr = null;
-        return s;
+        return new InetSocketAddress(checkPort(port), checkHost(host));
     }
 
-    private void readObject(ObjectInputStream s)
-        throws IOException, ClassNotFoundException {
-        s.defaultReadObject();
+    /**
+     * @serialField hostname String
+     * @serialField addr InetAddress
+     * @serialField port int
+     */
+    private static final ObjectStreamField[] serialPersistentFields = {
+         new ObjectStreamField("hostname", String.class),
+         new ObjectStreamField("addr", InetAddress.class),
+         new ObjectStreamField("port", int.class)};
+
+    private void writeObject(ObjectOutputStream out)
+        throws IOException
+    {
+        // Don't call defaultWriteObject()
+         ObjectOutputStream.PutField pfields = out.putFields();
+         pfields.put("hostname", holder.hostname);
+         pfields.put("addr", holder.addr);
+         pfields.put("port", holder.port);
+         out.writeFields();
+     }
+
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException
+    {
+        // Don't call defaultReadObject()
+        ObjectInputStream.GetField oisFields = in.readFields();
+        final String oisHostname = (String)oisFields.get("hostname", null);
+        final InetAddress oisAddr = (InetAddress)oisFields.get("addr", null);
+        final int oisPort = oisFields.get("port", -1);
 
         // Check that our invariants are satisfied
-        if (port < 0 || port > 0xFFFF) {
-            throw new InvalidObjectException("port out of range:" + port);
-        }
-
-        if (hostname == null && addr == null) {
+        checkPort(oisPort);
+        if (oisHostname == null && oisAddr == null)
             throw new InvalidObjectException("hostname and addr " +
                                              "can't both be null");
+
+        InetSocketAddressHolder h = new InetSocketAddressHolder(oisHostname,
+                                                                oisAddr,
+                                                                oisPort);
+        UNSAFE.putObject(this, FIELDS_OFFSET, h);
+    }
+
+    private void readObjectNoData()
+        throws ObjectStreamException
+    {
+        throw new InvalidObjectException("Stream data required");
+    }
+
+    private static final long FIELDS_OFFSET;
+    private static final sun.misc.Unsafe UNSAFE;
+    static {
+        try {
+            sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
+            FIELDS_OFFSET = unsafe.objectFieldOffset(
+                    InetSocketAddress.class.getDeclaredField("holder"));
+            UNSAFE = unsafe;
+        } catch (ReflectiveOperationException e) {
+            throw new Error(e);
         }
     }
 
@@ -203,7 +321,7 @@
      * @return the port number.
      */
     public final int getPort() {
-        return port;
+        return holder.getPort();
     }
 
     /**
@@ -213,7 +331,7 @@
      * @return the InetAdress or <code>null</code> if it is unresolved.
      */
     public final InetAddress getAddress() {
-        return addr;
+        return holder.getAddress();
     }
 
     /**
@@ -224,31 +342,19 @@
      * @return  the hostname part of the address.
      */
     public final String getHostName() {
-        if (hostname != null)
-            return hostname;
-        if (addr != null)
-            return addr.getHostName();
-        return null;
+        return holder.getHostName();
     }
 
     /**
      * Returns the hostname, or the String form of the address if it
      * doesn't have a hostname (it was created using a literal).
-     * This has the benefit of <b>not</b> attemptimg a reverse lookup.
+     * This has the benefit of <b>not</b> attempting a reverse lookup.
      *
      * @return the hostname, or String representation of the address.
      * @since 1.7
      */
     public final String getHostString() {
-        if (hostname != null)
-            return hostname;
-        if (addr != null) {
-            if (addr.hostName != null)
-                return addr.hostName;
-            else
-                return addr.getHostAddress();
-        }
-        return null;
+        return holder.getHostString();
     }
 
     /**
@@ -258,7 +364,7 @@
      *          an <code>InetAddress</code>.
      */
     public final boolean isUnresolved() {
-        return addr == null;
+        return holder.isUnresolved();
     }
 
     /**
@@ -269,12 +375,9 @@
      *
      * @return  a string representation of this object.
      */
+    @Override
     public String toString() {
-        if (isUnresolved()) {
-            return hostname + ":" + port;
-        } else {
-            return addr.toString() + ":" + port;
-        }
+        return holder.toString();
     }
 
     /**
@@ -297,19 +400,11 @@
      *          <code>false</code> otherwise.
      * @see java.net.InetAddress#equals(java.lang.Object)
      */
+    @Override
     public final boolean equals(Object obj) {
         if (obj == null || !(obj instanceof InetSocketAddress))
             return false;
-        InetSocketAddress sockAddr = (InetSocketAddress) obj;
-        boolean sameIP = false;
-        if (this.addr != null)
-            sameIP = this.addr.equals(sockAddr.addr);
-        else if (this.hostname != null)
-            sameIP = (sockAddr.addr == null) &&
-                this.hostname.equalsIgnoreCase(sockAddr.hostname);
-        else
-            sameIP = (sockAddr.addr == null) && (sockAddr.hostname == null);
-        return sameIP && (this.port == sockAddr.port);
+        return holder.equals(((InetSocketAddress) obj).holder);
     }
 
     /**
@@ -317,11 +412,8 @@
      *
      * @return  a hash code value for this socket address.
      */
+    @Override
     public final int hashCode() {
-        if (addr != null)
-            return addr.hashCode() + port;
-        if (hostname != null)
-            return hostname.toLowerCase().hashCode() + port;
-        return port;
+        return holder.hashCode();
     }
 }
--- jdk/src/share/classes/java/net/URL.java	2012-08-10 10:27:02.000000000 -0700
+++ jdk/src/share/classes/java/net/URL.java	2013-05-05 09:38:32.000000000 -0700
@@ -28,6 +28,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Hashtable;
 import java.util.StringTokenizer;
 import sun.security.util.SecurityConstants;
@@ -1116,6 +1118,22 @@
     static Hashtable handlers = new Hashtable();
     private static Object streamHandlerLock = new Object();
 
+    // special case the gopher protocol, disabled by default
+    private static final String GOPHER = "gopher";
+    private static final String ENABLE_GOPHER_PROP = "jdk.net.registerGopherProtocol";
+    private static final boolean enableGopher = AccessController.doPrivileged(
+                new PrivilegedAction<Boolean>() {
+                    @Override
+                    public Boolean run() {
+                        String prop = System.getProperty(ENABLE_GOPHER_PROP);
+                        return prop == null ? false :
+                                   (prop.equalsIgnoreCase("false") ? false : true);
+                    }
+                });
+
+    // package name of the JDK implementation protocol handlers
+    private static final String JDK_PACKAGE_PREFIX =  "sun.net.www.protocol";
+
     /**
      * Returns the Stream Handler.
      * @param protocol the protocol to use
@@ -1147,7 +1165,7 @@
 
                 // REMIND: decide whether to allow the "null" class prefix
                 // or not.
-                packagePrefixList += "sun.net.www.protocol";
+                packagePrefixList += JDK_PACKAGE_PREFIX;
 
                 StringTokenizer packagePrefixIter =
                     new StringTokenizer(packagePrefixList, "|");
@@ -1157,6 +1175,14 @@
 
                     String packagePrefix =
                       packagePrefixIter.nextToken().trim();
+
+                    // do not try to instantiate the JDK gopher handler
+                    // unless the system property had been explicitly set
+                    if (protocol.equalsIgnoreCase(GOPHER) &&
+                        packagePrefix.equals(JDK_PACKAGE_PREFIX) &&
+                        !enableGopher) {
+                            continue;
+                    }
                     try {
                         String clsName = packagePrefix + "." + protocol +
                           ".Handler";
--- jdk/src/share/classes/java/rmi/server/LogStream.java	2012-08-10 10:27:08.000000000 -0700
+++ jdk/src/share/classes/java/rmi/server/LogStream.java	2013-05-05 09:38:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -120,6 +120,13 @@
      */
     @Deprecated
     public static synchronized void setDefaultStream(PrintStream newDefault) {
+        SecurityManager sm = System.getSecurityManager();
+
+        if (sm != null) {
+            sm.checkPermission(
+                new java.util.logging.LoggingPermission("control", null));
+        }
+
         defaultStream = newDefault;
     }
 
--- jdk/src/share/classes/java/security/AccessController.java	2012-08-10 10:27:09.000000000 -0700
+++ jdk/src/share/classes/java/security/AccessController.java	2013-05-05 09:38:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -290,11 +290,11 @@
      */
     public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action) {
 
-        DomainCombiner dc = null;
         AccessControlContext acc = getStackAccessControlContext();
-        if (acc == null || (dc = acc.getAssignedCombiner()) == null) {
+        if (acc == null) {
             return AccessController.doPrivileged(action);
         }
+        DomainCombiner dc = acc.getAssignedCombiner();
         return AccessController.doPrivileged(action, preserveCombiner(dc));
     }
 
@@ -386,11 +386,11 @@
     public static <T> T doPrivilegedWithCombiner
         (PrivilegedExceptionAction<T> action) throws PrivilegedActionException {
 
-        DomainCombiner dc = null;
         AccessControlContext acc = getStackAccessControlContext();
-        if (acc == null || (dc = acc.getAssignedCombiner()) == null) {
+        if (acc == null) {
             return AccessController.doPrivileged(action);
         }
+        DomainCombiner dc = acc.getAssignedCombiner();
         return AccessController.doPrivileged(action, preserveCombiner(dc));
     }
 
@@ -417,7 +417,12 @@
         // perform 'combine' on the caller of doPrivileged,
         // even if the caller is from the bootclasspath
         ProtectionDomain[] pds = new ProtectionDomain[] {callerPd};
-        return new AccessControlContext(combiner.combine(pds, null), combiner);
+        if (combiner == null) {
+            return new AccessControlContext(pds);
+        } else {
+            return new AccessControlContext(combiner.combine(pds, null),
+                                            combiner);
+        }
     }
 
 
--- jdk/src/share/classes/java/sql/DriverManager.java	2012-08-10 10:27:15.000000000 -0700
+++ jdk/src/share/classes/java/sql/DriverManager.java	2013-05-05 09:38:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -516,7 +516,7 @@
                  */
                 try{
                     while(driversIterator.hasNext()) {
-                        println(" Loading done by the java.util.ServiceLoader :  "+driversIterator.next());
+                        driversIterator.next();
                     }
                 } catch(Throwable t) {
                 // Do nothing
--- jdk/src/share/classes/java/util/ServiceLoader.java	2012-08-10 10:27:19.000000000 -0700
+++ jdk/src/share/classes/java/util/ServiceLoader.java	2013-05-05 09:38:33.000000000 -0700
@@ -358,14 +358,21 @@
             }
             String cn = nextName;
             nextName = null;
+            Class<?> c = null;
             try {
-                S p = service.cast(Class.forName(cn, true, loader)
-                                   .newInstance());
-                providers.put(cn, p);
-                return p;
+                c = Class.forName(cn, false, loader);
             } catch (ClassNotFoundException x) {
                 fail(service,
                      "Provider " + cn + " not found");
+            }
+            if (!service.isAssignableFrom(c)) {
+                fail(service,
+                     "Provider " + cn  + " not a subtype");
+            }
+            try {
+                S p = service.cast(c.newInstance());
+                providers.put(cn, p);
+                return p;
             } catch (Throwable x) {
                 fail(service,
                      "Provider " + cn + " could not be instantiated: " + x,
--- jdk/src/share/classes/java/util/TimeZone.java	2012-08-10 10:27:19.000000000 -0700
+++ jdk/src/share/classes/java/util/TimeZone.java	2013-05-05 09:38:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,7 +43,8 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.concurrent.ConcurrentHashMap;
-import sun.awt.AppContext;
+import sun.misc.SharedSecrets;
+import sun.misc.JavaAWTAccess;
 import sun.security.action.GetPropertyAction;
 import sun.util.TimeZoneNameUtility;
 import sun.util.calendar.ZoneInfo;
@@ -161,6 +162,16 @@
     private static final int ONE_HOUR   = 60*ONE_MINUTE;
     private static final int ONE_DAY    = 24*ONE_HOUR;
 
+    /*
+     * Provides access implementation-private methods without using reflection
+     *
+     * Note that javaAWTAccess may be null if sun.awt.AppContext class hasn't
+     * been loaded. If so, it implies that AWTSecurityManager is not our
+     * SecurityManager and we can use a local static variable.
+     * This works around a build time issue.
+     */
+    private static JavaAWTAccess javaAWTAccess;
+
     // Proclaim serialization compatibility with JDK 1.1
     static final long serialVersionUID = 3581463369166924961L;
 
@@ -720,13 +731,19 @@
      * used or if the AppContext doesn't have the default TimeZone.
      */
     private synchronized static TimeZone getDefaultInAppContext() {
-        if (!hasSetInAppContext) {
-            return null;
-        }
-
-        AppContext ac = AppContext.getAppContext();
-        if (ac != null && !ac.isDisposed()) {
-            return (TimeZone) ac.get(TimeZone.class);
+        javaAWTAccess = SharedSecrets.getJavaAWTAccess();
+        if (javaAWTAccess == null) {
+            return mainAppContextDefault;
+        } else {
+            if (!javaAWTAccess.isDisposed()) {
+                TimeZone tz = (TimeZone)
+                    javaAWTAccess.get(TimeZone.class);
+                if (tz == null && javaAWTAccess.isMainAppContext()) {
+                    return mainAppContextDefault;
+                } else {
+                    return tz;
+                }
+            }
         }
         return null;
     }
@@ -738,17 +755,15 @@
      * AppContext otherwise.
      */
     private synchronized static void setDefaultInAppContext(TimeZone tz) {
-        if (!hasSetInAppContext && tz == null) {
-            return;
-        }
-
-        AppContext ac = AppContext.getAppContext();
-        if (ac != null && !ac.isDisposed()) {
-            if (tz != null) {
-                ac.put(TimeZone.class, tz);
-                hasSetInAppContext = true;
-            } else {
-                ac.remove(TimeZone.class);
+        javaAWTAccess = SharedSecrets.getJavaAWTAccess();
+        if (javaAWTAccess == null) {
+            mainAppContextDefault = tz;
+        } else {
+            if (!javaAWTAccess.isDisposed()) {
+                javaAWTAccess.put(TimeZone.class, tz);
+                if (javaAWTAccess.isMainAppContext()) {
+                    mainAppContextDefault = null;
+                }
             }
         }
     }
@@ -804,8 +819,8 @@
     static final String         GMT_ID        = "GMT";
     private static final int    GMT_ID_LENGTH = 3;
 
-    // true if the default TimeZone has been set in any AppContext
-    private static boolean hasSetInAppContext;
+    // a static TimeZone we can reference if no AppContext is in place
+    private static TimeZone mainAppContextDefault;
 
     /**
      * Parses a custom time zone identifier and returns a corresponding zone.
@@ -890,15 +905,13 @@
         }
         int gmtOffset =  (hours * 60 + num) * 60 * 1000;
 
+        zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         if (gmtOffset == 0) {
-            zi = ZoneInfoFile.getZoneInfo(GMT_ID);
             if (negative) {
                 zi.setID("GMT-00:00");
             } else {
                 zi.setID("GMT+00:00");
             }
-        } else {
-            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         }
         return zi;
     }
--- jdk/src/share/classes/java/util/concurrent/ConcurrentHashMap.java	2012-08-10 10:27:20.000000000 -0700
+++ jdk/src/share/classes/java/util/concurrent/ConcurrentHashMap.java	2013-05-05 09:38:33.000000000 -0700
@@ -40,6 +40,7 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
 
 /**
  * A hash table supporting full concurrency of retrievals and
@@ -1535,7 +1536,23 @@
     @SuppressWarnings("unchecked")
     private void readObject(java.io.ObjectInputStream s)
         throws IOException, ClassNotFoundException {
-        s.defaultReadObject();
+        // Don't call defaultReadObject()
+        ObjectInputStream.GetField oisFields = s.readFields();
+        final Segment<K,V>[] oisSegments = (Segment<K,V>[])oisFields.get("segments", null);
+
+        final int ssize = oisSegments.length;
+        if (ssize < 1 || ssize > MAX_SEGMENTS
+            || (ssize & (ssize-1)) != 0 )  // ssize not power of two
+            throw new java.io.InvalidObjectException("Bad number of segments:"
+                                                     + ssize);
+        int sshift = 0, ssizeTmp = ssize;
+        while (ssizeTmp > 1) {
+            ++sshift;
+            ssizeTmp >>>= 1;
+        }
+        UNSAFE.putIntVolatile(this, SEGSHIFT_OFFSET, 32 - sshift);
+        UNSAFE.putIntVolatile(this, SEGMASK_OFFSET, ssize - 1);
+        UNSAFE.putObjectVolatile(this, SEGMENTS_OFFSET, oisSegments);
 
         // set hashMask
         UNSAFE.putIntVolatile(this, HASHSEED_OFFSET, randomHashSeed(this));
@@ -1568,6 +1585,9 @@
     private static final long TBASE;
     private static final int TSHIFT;
     private static final long HASHSEED_OFFSET;
+    private static final long SEGSHIFT_OFFSET;
+    private static final long SEGMASK_OFFSET;
+    private static final long SEGMENTS_OFFSET;
 
     static {
         int ss, ts;
@@ -1581,6 +1601,12 @@
             ss = UNSAFE.arrayIndexScale(sc);
             HASHSEED_OFFSET = UNSAFE.objectFieldOffset(
                 ConcurrentHashMap.class.getDeclaredField("hashSeed"));
+            SEGSHIFT_OFFSET = UNSAFE.objectFieldOffset(
+                ConcurrentHashMap.class.getDeclaredField("segmentShift"));
+            SEGMASK_OFFSET = UNSAFE.objectFieldOffset(
+                ConcurrentHashMap.class.getDeclaredField("segmentMask"));
+            SEGMENTS_OFFSET = UNSAFE.objectFieldOffset(
+                ConcurrentHashMap.class.getDeclaredField("segments"));
         } catch (Exception e) {
             throw new Error(e);
         }
--- jdk/src/share/classes/java/util/concurrent/Executors.java	2012-08-10 10:27:20.000000000 -0700
+++ jdk/src/share/classes/java/util/concurrent/Executors.java	2013-05-05 09:38:33.000000000 -0700
@@ -530,18 +530,17 @@
                 return AccessController.doPrivileged(
                     new PrivilegedExceptionAction<T>() {
                         public T run() throws Exception {
-                            ClassLoader savedcl = null;
                             Thread t = Thread.currentThread();
-                            try {
-                                ClassLoader cl = t.getContextClassLoader();
-                                if (ccl != cl) {
-                                    t.setContextClassLoader(ccl);
-                                    savedcl = cl;
-                                }
+                            ClassLoader cl = t.getContextClassLoader();
+                            if (ccl == cl) {
                                 return task.call();
-                            } finally {
-                                if (savedcl != null)
-                                    t.setContextClassLoader(savedcl);
+                            } else {
+                                t.setContextClassLoader(ccl);
+                                try {
+                                    return task.call();
+                                } finally {
+                                    t.setContextClassLoader(cl);
+                                }
                             }
                         }
                     }, acc);
--- jdk/src/share/classes/java/util/concurrent/PriorityBlockingQueue.java	2012-08-10 10:27:20.000000000 -0700
+++ jdk/src/share/classes/java/util/concurrent/PriorityBlockingQueue.java	2013-05-05 09:38:33.000000000 -0700
@@ -35,8 +35,7 @@
 
 package java.util.concurrent;
 
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.*;
 import java.util.*;
 
 /**
@@ -111,7 +110,7 @@
      * java.util.PriorityQueue operations within a lock, as was done
      * in a previous version of this class. To maintain
      * interoperability, a plain PriorityQueue is still used during
-     * serialization, which maintains compatibility at the expense of
+     * serialization, which maintains compatibility at the espense of
      * transiently doubling overhead.
      */
 
@@ -308,13 +307,14 @@
     /**
      * Mechanics for poll().  Call only while holding lock.
      */
-    private E dequeue() {
+    private E extract() {
+        E result;
         int n = size - 1;
         if (n < 0)
-            return null;
+            result = null;
         else {
             Object[] array = queue;
-            E result = (E) array[0];
+            result = (E) array[0];
             E x = (E) array[n];
             array[n] = null;
             Comparator<? super E> cmp = comparator;
@@ -323,8 +323,8 @@
             else
                 siftDownUsingComparator(0, x, array, n, cmp);
             size = n;
-            return result;
         }
+        return result;
     }
 
     /**
@@ -381,43 +381,39 @@
      */
     private static <T> void siftDownComparable(int k, T x, Object[] array,
                                                int n) {
-        if (n > 0) {
-            Comparable<? super T> key = (Comparable<? super T>)x;
-            int half = n >>> 1;           // loop while a non-leaf
-            while (k < half) {
-                int child = (k << 1) + 1; // assume left child is least
-                Object c = array[child];
-                int right = child + 1;
-                if (right < n &&
-                    ((Comparable<? super T>) c).compareTo((T) array[right]) > 0)
-                    c = array[child = right];
-                if (key.compareTo((T) c) <= 0)
-                    break;
-                array[k] = c;
-                k = child;
-            }
-            array[k] = key;
+        Comparable<? super T> key = (Comparable<? super T>)x;
+        int half = n >>> 1;           // loop while a non-leaf
+        while (k < half) {
+            int child = (k << 1) + 1; // assume left child is least
+            Object c = array[child];
+            int right = child + 1;
+            if (right < n &&
+                ((Comparable<? super T>) c).compareTo((T) array[right]) > 0)
+                c = array[child = right];
+            if (key.compareTo((T) c) <= 0)
+                break;
+            array[k] = c;
+            k = child;
         }
+        array[k] = key;
     }
 
     private static <T> void siftDownUsingComparator(int k, T x, Object[] array,
                                                     int n,
                                                     Comparator<? super T> cmp) {
-        if (n > 0) {
-            int half = n >>> 1;
-            while (k < half) {
-                int child = (k << 1) + 1;
-                Object c = array[child];
-                int right = child + 1;
-                if (right < n && cmp.compare((T) c, (T) array[right]) > 0)
-                    c = array[child = right];
-                if (cmp.compare(x, (T) c) <= 0)
-                    break;
-                array[k] = c;
-                k = child;
-            }
-            array[k] = x;
+        int half = n >>> 1;
+        while (k < half) {
+            int child = (k << 1) + 1;
+            Object c = array[child];
+            int right = child + 1;
+            if (right < n && cmp.compare((T) c, (T) array[right]) > 0)
+                c = array[child = right];
+            if (cmp.compare(x, (T) c) <= 0)
+                break;
+            array[k] = c;
+            k = child;
         }
+        array[k] = x;
     }
 
     /**
@@ -523,11 +519,13 @@
     public E poll() {
         final ReentrantLock lock = this.lock;
         lock.lock();
+        E result;
         try {
-            return dequeue();
+            result = extract();
         } finally {
             lock.unlock();
         }
+        return result;
     }
 
     public E take() throws InterruptedException {
@@ -535,7 +533,7 @@
         lock.lockInterruptibly();
         E result;
         try {
-            while ( (result = dequeue()) == null)
+            while ( (result = extract()) == null)
                 notEmpty.await();
         } finally {
             lock.unlock();
@@ -549,7 +547,7 @@
         lock.lockInterruptibly();
         E result;
         try {
-            while ( (result = dequeue()) == null && nanos > 0)
+            while ( (result = extract()) == null && nanos > 0)
                 nanos = notEmpty.awaitNanos(nanos);
         } finally {
             lock.unlock();
@@ -560,11 +558,13 @@
     public E peek() {
         final ReentrantLock lock = this.lock;
         lock.lock();
+        E result;
         try {
-            return (size == 0) ? null : (E) queue[0];
+            result = size > 0 ? (E) queue[0] : null;
         } finally {
             lock.unlock();
         }
+        return result;
     }
 
     /**
@@ -648,28 +648,32 @@
      * @return {@code true} if this queue changed as a result of the call
      */
     public boolean remove(Object o) {
+        boolean removed = false;
         final ReentrantLock lock = this.lock;
         lock.lock();
         try {
             int i = indexOf(o);
-            if (i == -1)
-                return false;
-            removeAt(i);
-            return true;
+            if (i != -1) {
+                removeAt(i);
+                removed = true;
+            }
         } finally {
             lock.unlock();
         }
+        return removed;
     }
 
+
     /**
      * Identity-based version for use in Itr.remove
      */
-    void removeEQ(Object o) {
+    private void removeEQ(Object o) {
         final ReentrantLock lock = this.lock;
         lock.lock();
         try {
             Object[] array = queue;
-            for (int i = 0, n = size; i < n; i++) {
+            int n = size;
+            for (int i = 0; i < n; i++) {
                 if (o == array[i]) {
                     removeAt(i);
                     break;
@@ -689,13 +693,15 @@
      * @return {@code true} if this queue contains the specified element
      */
     public boolean contains(Object o) {
+        int index;
         final ReentrantLock lock = this.lock;
         lock.lock();
         try {
-            return indexOf(o) != -1;
+            index = indexOf(o);
         } finally {
             lock.unlock();
         }
+        return index != -1;
     }
 
     /**
@@ -721,6 +727,7 @@
         }
     }
 
+
     public String toString() {
         final ReentrantLock lock = this.lock;
         lock.lock();
@@ -731,7 +738,7 @@
             StringBuilder sb = new StringBuilder();
             sb.append('[');
             for (int i = 0; i < n; ++i) {
-                Object e = queue[i];
+                E e = (E)queue[i];
                 sb.append(e == this ? "(this Collection)" : e);
                 if (i != n - 1)
                     sb.append(',').append(' ');
@@ -749,7 +756,23 @@
      * @throws IllegalArgumentException      {@inheritDoc}
      */
     public int drainTo(Collection<? super E> c) {
-        return drainTo(c, Integer.MAX_VALUE);
+        if (c == null)
+            throw new NullPointerException();
+        if (c == this)
+            throw new IllegalArgumentException();
+        final ReentrantLock lock = this.lock;
+        lock.lock();
+        try {
+            int n = 0;
+            E e;
+            while ( (e = extract()) != null) {
+                c.add(e);
+                ++n;
+            }
+            return n;
+        } finally {
+            lock.unlock();
+        }
     }
 
     /**
@@ -768,10 +791,11 @@
         final ReentrantLock lock = this.lock;
         lock.lock();
         try {
-            int n = Math.min(size, maxElements);
-            for (int i = 0; i < n; i++) {
-                c.add((E) queue[0]); // In this order, in case add() throws.
-                dequeue();
+            int n = 0;
+            E e;
+            while (n < maxElements && (e = extract()) != null) {
+                c.add(e);
+                ++n;
             }
             return n;
         } finally {
@@ -819,7 +843,8 @@
      * The following code can be used to dump the queue into a newly
      * allocated array of {@code String}:
      *
-     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
+     * <pre>
+     *     String[] y = x.toArray(new String[0]);</pre>
      *
      * Note that {@code toArray(new Object[0])} is identical in function to
      * {@code toArray()}.
@@ -872,7 +897,7 @@
      */
     final class Itr implements Iterator<E> {
         final Object[] array; // Array of all elements
-        int cursor;           // index of next element to return
+        int cursor;           // index of next element to return;
         int lastRet;          // index of last element, or -1 if no such
 
         Itr(Object[] array) {
@@ -900,18 +925,17 @@
     }
 
     /**
-     * Saves this queue to a stream (that is, serializes it).
-     *
-     * For compatibility with previous version of this class, elements
-     * are first copied to a java.util.PriorityQueue, which is then
-     * serialized.
+     * Saves the state to a stream (that is, serializes it).  For
+     * compatibility with previous version of this class,
+     * elements are first copied to a java.util.PriorityQueue,
+     * which is then serialized.
      */
     private void writeObject(java.io.ObjectOutputStream s)
         throws java.io.IOException {
         lock.lock();
         try {
-            // avoid zero capacity argument
-            q = new PriorityQueue<E>(Math.max(size, 1), comparator);
+            int n = size; // avoid zero capacity argument
+            q = new PriorityQueue<E>(n == 0 ? 1 : n, comparator);
             q.addAll(this);
             s.defaultWriteObject();
         } finally {
@@ -921,7 +945,10 @@
     }
 
     /**
-     * Reconstitutes this queue from a stream (that is, deserializes it).
+     * Reconstitutes the {@code PriorityBlockingQueue} instance from a stream
+     * (that is, deserializes it).
+     *
+     * @param s the stream
      */
     private void readObject(java.io.ObjectInputStream s)
         throws java.io.IOException, ClassNotFoundException {
--- jdk/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java	2012-08-10 10:27:21.000000000 -0700
+++ jdk/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java	2013-05-05 09:38:33.000000000 -0700
@@ -34,8 +34,10 @@
  */
 
 package java.util.concurrent;
-import java.util.concurrent.locks.*;
-import java.util.concurrent.atomic.*;
+import java.util.concurrent.locks.AbstractQueuedSynchronizer;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.*;
 
 /**
@@ -491,10 +493,15 @@
      * policy limiting the number of threads.  Even though it is not
      * treated as an error, failure to create threads may result in
      * new tasks being rejected or existing ones remaining stuck in
-     * the queue. On the other hand, no special precautions exist to
-     * handle OutOfMemoryErrors that might be thrown while trying to
-     * create threads, since there is generally no recourse from
-     * within this class.
+     * the queue.
+     *
+     * We go further and preserve pool invariants even in the face of
+     * errors such as OutOfMemoryError, that might be thrown while
+     * trying to create threads.  Such errors are rather common due to
+     * the need to allocate a native stack in Thread#start, and users
+     * will want to perform clean pool shutdown to clean up.  There
+     * will likely be enough memory available for the cleanup code to
+     * complete without encountering yet another OutOfMemoryError.
      */
     private volatile ThreadFactory threadFactory;
 
@@ -568,9 +575,13 @@
      * task execution.  This protects against interrupts that are
      * intended to wake up a worker thread waiting for a task from
      * instead interrupting a task being run.  We implement a simple
-     * non-reentrant mutual exclusion lock rather than use ReentrantLock
-     * because we do not want worker tasks to be able to reacquire the
-     * lock when they invoke pool control methods like setCorePoolSize.
+     * non-reentrant mutual exclusion lock rather than use
+     * ReentrantLock because we do not want worker tasks to be able to
+     * reacquire the lock when they invoke pool control methods like
+     * setCorePoolSize.  Additionally, to suppress interrupts until
+     * the thread actually starts running tasks, we initialize lock
+     * state to a negative value, and clear it upon start (in
+     * runWorker).
      */
     private final class Worker
         extends AbstractQueuedSynchronizer
@@ -594,6 +605,7 @@
          * @param firstTask the first task (null if none)
          */
         Worker(Runnable firstTask) {
+            setState(-1); // inhibit interrupts until runWorker
             this.firstTask = firstTask;
             this.thread = getThreadFactory().newThread(this);
         }
@@ -609,7 +621,7 @@
         // The value 1 represents the locked state.
 
         protected boolean isHeldExclusively() {
-            return getState() == 1;
+            return getState() != 0;
         }
 
         protected boolean tryAcquire(int unused) {
@@ -630,6 +642,16 @@
         public boolean tryLock()  { return tryAcquire(1); }
         public void unlock()      { release(1); }
         public boolean isLocked() { return isHeldExclusively(); }
+
+        void interruptIfStarted() {
+            Thread t;
+            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
+                try {
+                    t.interrupt();
+                } catch (SecurityException ignore) {
+                }
+            }
+        }
     }
 
     /*
@@ -728,12 +750,8 @@
         final ReentrantLock mainLock = this.mainLock;
         mainLock.lock();
         try {
-            for (Worker w : workers) {
-                try {
-                    w.thread.interrupt();
-                } catch (SecurityException ignore) {
-                }
-            }
+            for (Worker w : workers)
+                w.interruptIfStarted();
         } finally {
             mainLock.unlock();
         }
@@ -790,19 +808,6 @@
 
     private static final boolean ONLY_ONE = true;
 
-    /**
-     * Ensures that unless the pool is stopping, the current thread
-     * does not have its interrupt set. This requires a double-check
-     * of state in case the interrupt was cleared concurrently with a
-     * shutdownNow -- if so, the interrupt is re-enabled.
-     */
-    private void clearInterruptsForTaskRun() {
-        if (runStateLessThan(ctl.get(), STOP) &&
-            Thread.interrupted() &&
-            runStateAtLeast(ctl.get(), STOP))
-            Thread.currentThread().interrupt();
-    }
-
     /*
      * Misc utilities, most of which are also exported to
      * ScheduledThreadPoolExecutor
@@ -862,12 +867,13 @@
      * Checks if a new worker can be added with respect to current
      * pool state and the given bound (either core or maximum). If so,
      * the worker count is adjusted accordingly, and, if possible, a
-     * new worker is created and started running firstTask as its
+     * new worker is created and started, running firstTask as its
      * first task. This method returns false if the pool is stopped or
      * eligible to shut down. It also returns false if the thread
-     * factory fails to create a thread when asked, which requires a
-     * backout of workerCount, and a recheck for termination, in case
-     * the existence of this worker was holding up termination.
+     * factory fails to create a thread when asked.  If the thread
+     * creation fails, either due to the thread factory returning
+     * null, or due to an exception (typically OutOfMemoryError in
+     * Thread#start), we roll back cleanly.
      *
      * @param firstTask the task the new thread should run first (or
      * null if none). Workers are created with an initial first task
@@ -910,46 +916,65 @@
             }
         }
 
-        Worker w = new Worker(firstTask);
-        Thread t = w.thread;
+        boolean workerStarted = false;
+        boolean workerAdded = false;
+        Worker w = null;
+        try {
+            final ReentrantLock mainLock = this.mainLock;
+            w = new Worker(firstTask);
+            final Thread t = w.thread;
+            if (t != null) {
+                mainLock.lock();
+                try {
+                    // Recheck while holding lock.
+                    // Back out on ThreadFactory failure or if
+                    // shut down before lock acquired.
+                    int c = ctl.get();
+                    int rs = runStateOf(c);
+
+                    if (rs < SHUTDOWN ||
+                        (rs == SHUTDOWN && firstTask == null)) {
+                        if (t.isAlive()) // precheck that t is startable
+                            throw new IllegalThreadStateException();
+                        workers.add(w);
+                        int s = workers.size();
+                        if (s > largestPoolSize)
+                            largestPoolSize = s;
+                        workerAdded = true;
+                    }
+                } finally {
+                    mainLock.unlock();
+                }
+                if (workerAdded) {
+                    t.start();
+                    workerStarted = true;
+                }
+            }
+        } finally {
+            if (! workerStarted)
+                addWorkerFailed(w);
+        }
+        return workerStarted;
+    }
 
+    /**
+     * Rolls back the worker thread creation.
+     * - removes worker from workers, if present
+     * - decrements worker count
+     * - rechecks for termination, in case the existence of this
+     *   worker was holding up termination
+     */
+    private void addWorkerFailed(Worker w) {
         final ReentrantLock mainLock = this.mainLock;
         mainLock.lock();
         try {
-            // Recheck while holding lock.
-            // Back out on ThreadFactory failure or if
-            // shut down before lock acquired.
-            int c = ctl.get();
-            int rs = runStateOf(c);
-
-            if (t == null ||
-                (rs >= SHUTDOWN &&
-                 ! (rs == SHUTDOWN &&
-                    firstTask == null))) {
-                decrementWorkerCount();
-                tryTerminate();
-                return false;
-            }
-
-            workers.add(w);
-
-            int s = workers.size();
-            if (s > largestPoolSize)
-                largestPoolSize = s;
+            if (w != null)
+                workers.remove(w);
+            decrementWorkerCount();
+            tryTerminate();
         } finally {
             mainLock.unlock();
         }
-
-        t.start();
-        // It is possible (but unlikely) for a thread to have been
-        // added to workers, but not yet started, during transition to
-        // STOP, which could result in a rare missed interrupt,
-        // because Thread.interrupt is not guaranteed to have any effect
-        // on a non-yet-started Thread (see Thread#interrupt).
-        if (runStateOf(ctl.get()) == STOP && ! t.isInterrupted())
-            t.interrupt();
-
-        return true;
     }
 
     /**
@@ -1096,15 +1121,25 @@
      * @param w the worker
      */
     final void runWorker(Worker w) {
+        Thread wt = Thread.currentThread();
         Runnable task = w.firstTask;
         w.firstTask = null;
+        w.unlock(); // allow interrupts
         boolean completedAbruptly = true;
         try {
             while (task != null || (task = getTask()) != null) {
                 w.lock();
-                clearInterruptsForTaskRun();
+                // If pool is stopping, ensure thread is interrupted;
+                // if not, ensure thread is not interrupted.  This
+                // requires a recheck in second case to deal with
+                // shutdownNow race while clearing interrupt
+                if ((runStateAtLeast(ctl.get(), STOP) ||
+                     (Thread.interrupted() &&
+                      runStateAtLeast(ctl.get(), STOP))) &&
+                    !wt.isInterrupted())
+                    wt.interrupt();
                 try {
-                    beforeExecute(w.thread, task);
+                    beforeExecute(wt, task);
                     Throwable thrown = null;
                     try {
                         task.run();
@@ -2064,3 +2099,4 @@
         }
     }
 }
+
--- jdk/src/share/classes/java/util/jar/JarFile.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/jar/JarFile.java	2013-05-05 09:38:33.000000000 -0700
@@ -34,6 +34,7 @@
 import java.security.cert.Certificate;
 import java.security.AccessController;
 import java.security.CodeSource;
+import sun.misc.IOUtils;
 import sun.security.action.GetPropertyAction;
 import sun.security.util.ManifestEntryVerifier;
 import sun.misc.SharedSecrets;
@@ -329,6 +330,9 @@
             if (names != null) {
                 for (int i = 0; i < names.length; i++) {
                     JarEntry e = getJarEntry(names[i]);
+                    if (e == null) {
+                        throw new JarException("corrupted jar file");
+                    }
                     if (!e.isDirectory()) {
                         if (mev == null) {
                             mev = new ManifestEntryVerifier
@@ -348,6 +352,10 @@
             // treat the jar file as being unsigned
             jv = null;
             verify = false;
+            if (JarVerifier.debug != null) {
+                JarVerifier.debug.println("jarfile parsing error!");
+                ex.printStackTrace();
+            }
         }
 
         // if after initializing the verifier we have nothing
@@ -375,11 +383,9 @@
      * META-INF files.
      */
     private byte[] getBytes(ZipEntry ze) throws IOException {
-        byte[] b = new byte[(int)ze.getSize()];
-        try (DataInputStream is = new DataInputStream(super.getInputStream(ze))) {
-            is.readFully(b, 0, b.length);
+        try (InputStream is = super.getInputStream(ze)) {
+            return IOUtils.readFully(is, (int)ze.getSize(), true);
         }
-        return b;
     }
 
     /**
@@ -479,12 +485,7 @@
         if (!isKnownToNotHaveClassPathAttribute()) {
             JarEntry manEntry = getManEntry();
             if (manEntry != null) {
-                byte[] b = new byte[(int)manEntry.getSize()];
-                try (DataInputStream dis = new DataInputStream(
-                         super.getInputStream(manEntry))) {
-                    dis.readFully(b, 0, b.length);
-                }
-
+                byte[] b = getBytes(manEntry);
                 int last = b.length - src.length;
                 int i = 0;
                 next:
--- jdk/src/share/classes/java/util/logging/FileHandler.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/FileHandler.java	2013-05-05 09:38:33.000000000 -0700
@@ -220,7 +220,7 @@
      * @exception  NullPointerException if pattern property is an empty String.
      */
     public FileHandler() throws IOException, SecurityException {
-        checkAccess();
+        checkPermission();
         configure();
         openFiles();
     }
@@ -246,7 +246,7 @@
         if (pattern.length() < 1 ) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = 0;
@@ -278,7 +278,7 @@
         if (pattern.length() < 1 ) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = 0;
@@ -315,7 +315,7 @@
         if (limit < 0 || count < 1 || pattern.length() < 1) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = limit;
@@ -354,7 +354,7 @@
         if (limit < 0 || count < 1 || pattern.length() < 1) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = limit;
@@ -367,7 +367,7 @@
     // configured instance variables.
     private void openFiles() throws IOException {
         LogManager manager = LogManager.getLogManager();
-        manager.checkAccess();
+        manager.checkPermission();
         if (count < 1) {
            throw new IllegalArgumentException("file count = " + count);
         }
--- jdk/src/share/classes/java/util/logging/Handler.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/Handler.java	2013-05-05 09:38:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -111,7 +111,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public void setFormatter(Formatter newFormatter) throws SecurityException {
-        checkAccess();
+        checkPermission();
         // Check for a null pointer:
         newFormatter.getClass();
         formatter = newFormatter;
@@ -140,7 +140,7 @@
      */
     public void setEncoding(String encoding)
                         throws SecurityException, java.io.UnsupportedEncodingException {
-        checkAccess();
+        checkPermission();
         if (encoding != null) {
             try {
                 if(!java.nio.charset.Charset.isSupported(encoding)) {
@@ -175,7 +175,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public void setFilter(Filter newFilter) throws SecurityException {
-        checkAccess();
+        checkPermission();
         filter = newFilter;
     }
 
@@ -199,7 +199,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public void setErrorManager(ErrorManager em) {
-        checkAccess();
+        checkPermission();
         if (em == null) {
            throw new NullPointerException();
         }
@@ -213,7 +213,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public ErrorManager getErrorManager() {
-        checkAccess();
+        checkPermission();
         return errorManager;
     }
 
@@ -253,7 +253,7 @@
         if (newLevel == null) {
             throw new NullPointerException();
         }
-        checkAccess();
+        checkPermission();
         logLevel = newLevel;
     }
 
@@ -296,9 +296,9 @@
     // If "sealed" is true, we check that the caller has
     // appropriate security privileges to update Handler
     // state and if not throw a SecurityException.
-    void checkAccess() throws SecurityException {
+    void checkPermission() throws SecurityException {
         if (sealed) {
-            manager.checkAccess();
+            manager.checkPermission();
         }
     }
 }
--- jdk/src/share/classes/java/util/logging/Level.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/Level.java	2013-05-05 09:38:33.000000000 -0700
@@ -24,6 +24,10 @@
  */
 
 package java.util.logging;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.ResourceBundle;
 
 /**
@@ -59,7 +63,6 @@
  */
 
 public class Level implements java.io.Serializable {
-    private static java.util.ArrayList<Level> known = new java.util.ArrayList<>();
     private static String defaultBundle = "sun.util.logging.resources.logging";
 
     /**
@@ -77,6 +80,9 @@
      */
     private final String resourceBundleName;
 
+    // localized level name
+    private String localizedLevelName;
+
     /**
      * OFF is a special level that can be used to turn off logging.
      * This level is initialized to <CODE>Integer.MAX_VALUE</CODE>.
@@ -202,9 +208,8 @@
         this.name = name;
         this.value = value;
         this.resourceBundleName = resourceBundleName;
-        synchronized (Level.class) {
-            known.add(this);
-        }
+        this.localizedLevelName = resourceBundleName == null ? name : null;
+        KnownLevel.add(this);
     }
 
     /**
@@ -236,12 +241,76 @@
      * @return localized name
      */
     public String getLocalizedName() {
+        return getLocalizedLevelName();
+    }
+
+    // package-private getLevelName() is used by the implementation
+    // instead of getName() to avoid calling the subclass's version
+    final String getLevelName() {
+        return this.name;
+    }
+
+    final synchronized String getLocalizedLevelName() {
+        if (localizedLevelName != null) {
+            return localizedLevelName;
+        }
+
         try {
             ResourceBundle rb = ResourceBundle.getBundle(resourceBundleName);
-            return rb.getString(name);
+            localizedLevelName = rb.getString(name);
         } catch (Exception ex) {
-            return name;
+            localizedLevelName = name;
+        }
+        return localizedLevelName;
+    }
+
+    // Returns a mirrored Level object that matches the given name as
+    // specified in the Level.parse method.  Returns null if not found.
+    //
+    // It returns the same Level object as the one returned by Level.parse
+    // method if the given name is a non-localized name or integer.
+    //
+    // If the name is a localized name, findLevel and parse method may
+    // return a different level value if there is a custom Level subclass
+    // that overrides Level.getLocalizedName() to return a different string
+    // than what's returned by the default implementation.
+    //
+    static Level findLevel(String name) {
+        if (name == null) {
+            throw new NullPointerException();
+        }
+
+        KnownLevel level;
+
+        // Look for a known Level with the given non-localized name.
+        level = KnownLevel.findByName(name);
+        if (level != null) {
+            return level.mirroredLevel;
         }
+
+        // Now, check if the given name is an integer.  If so,
+        // first look for a Level with the given value and then
+        // if necessary create one.
+        try {
+            int x = Integer.parseInt(name);
+            level = KnownLevel.findByValue(x);
+            if (level == null) {
+                // add new Level
+                Level levelObject = new Level(name, x);
+                level = KnownLevel.findByValue(x);
+            }
+            return level.mirroredLevel;
+        } catch (NumberFormatException ex) {
+            // Not an integer.
+            // Drop through.
+        }
+
+        level = KnownLevel.findByLocalizedLevelName(name);
+        if (level != null) {
+            return level.mirroredLevel;
+        }
+
+        return null;
     }
 
     /**
@@ -268,21 +337,15 @@
     // Serialization magic to prevent "doppelgangers".
     // This is a performance optimization.
     private Object readResolve() {
-        synchronized (Level.class) {
-            for (int i = 0; i < known.size(); i++) {
-                Level other = known.get(i);
-                if (this.name.equals(other.name) && this.value == other.value
-                        && (this.resourceBundleName == other.resourceBundleName ||
-                            (this.resourceBundleName != null &&
-                            this.resourceBundleName.equals(other.resourceBundleName)))) {
-                    return other;
-                }
-            }
-            // Woops.  Whoever sent us this object knows
-            // about a new log level.  Add it to our list.
-            known.add(this);
-            return this;
+        KnownLevel o = KnownLevel.matches(this);
+        if (o != null) {
+            return o.levelObject;
         }
+
+        // Woops.  Whoever sent us this object knows
+        // about a new log level.  Add it to our list.
+        Level level = new Level(this.name, this.value, this.resourceBundleName);
+        return level;
     }
 
     /**
@@ -296,6 +359,7 @@
      * <li>     "SEVERE"
      * <li>     "1000"
      * </ul>
+     *
      * @param  name   string to be parsed
      * @throws NullPointerException if the name is null
      * @throws IllegalArgumentException if the value is not valid.
@@ -315,12 +379,12 @@
         // Check that name is not null.
         name.length();
 
+        KnownLevel level;
+
         // Look for a known Level with the given non-localized name.
-        for (int i = 0; i < known.size(); i++) {
-            Level l = known.get(i);
-            if (name.equals(l.name)) {
-                return l;
-            }
+        level = KnownLevel.findByName(name);
+        if (level != null) {
+            return level.levelObject;
         }
 
         // Now, check if the given name is an integer.  If so,
@@ -328,14 +392,13 @@
         // if necessary create one.
         try {
             int x = Integer.parseInt(name);
-            for (int i = 0; i < known.size(); i++) {
-                Level l = known.get(i);
-                if (l.value == x) {
-                    return l;
-                }
+            level = KnownLevel.findByValue(x);
+            if (level == null) {
+                // add new Level
+                Level levelObject = new Level(name, x);
+                level = KnownLevel.findByValue(x);
             }
-            // Create a new Level.
-            return new Level(name, x);
+            return level.levelObject;
         } catch (NumberFormatException ex) {
             // Not an integer.
             // Drop through.
@@ -344,11 +407,9 @@
         // Finally, look for a known level with the given localized name,
         // in the current default locale.
         // This is relatively expensive, but not excessively so.
-        for (int i = 0; i < known.size(); i++) {
-            Level l =  known.get(i);
-            if (name.equals(l.getLocalizedName())) {
-                return l;
-            }
+        level = KnownLevel.findByLocalizedName(name);
+        if (level != null) {
+            return level.levelObject;
         }
 
         // OK, we've tried everything and failed
@@ -375,4 +436,124 @@
     public int hashCode() {
         return this.value;
     }
+
+    // KnownLevel class maintains the global list of all known levels.
+    // The API allows multiple custom Level instances of the same name/value
+    // be created. This class provides convenient methods to find a level
+    // by a given name, by a given value, or by a given localized name.
+    //
+    // KnownLevel wraps the following Level objects:
+    // 1. levelObject:   standard Level object or custom Level object
+    // 2. mirroredLevel: Level object representing the level specified in the
+    //                   logging configuration.
+    //
+    // Level.getName, Level.getLocalizedName, Level.getResourceBundleName methods
+    // are non-final but the name and resource bundle name are parameters to
+    // the Level constructor.  Use the mirroredLevel object instead of the
+    // levelObject to prevent the logging framework to execute foreign code
+    // implemented by untrusted Level subclass.
+    //
+    // Implementation Notes:
+    // If Level.getName, Level.getLocalizedName, Level.getResourceBundleName methods
+    // were final, the following KnownLevel implementation can be removed.
+    // Future API change should take this into consideration.
+    static final class KnownLevel {
+        private static Map<String, List<KnownLevel>> nameToLevels = new HashMap<>();
+        private static Map<Integer, List<KnownLevel>> intToLevels = new HashMap<>();
+        final Level levelObject;     // instance of Level class or Level subclass
+        final Level mirroredLevel;   // instance of Level class
+        KnownLevel(Level l) {
+            this.levelObject = l;
+            if (l.getClass() == Level.class) {
+                this.mirroredLevel = l;
+            } else {
+                this.mirroredLevel = new Level(l.name, l.value, l.resourceBundleName);
+            }
+        }
+
+        static synchronized void add(Level l) {
+            // the mirroredLevel object is always added to the list
+            // before the custom Level instance
+            KnownLevel o = new KnownLevel(l);
+            List<KnownLevel> list = nameToLevels.get(l.name);
+            if (list == null) {
+                list = new ArrayList<>();
+                nameToLevels.put(l.name, list);
+            }
+            list.add(o);
+
+            list = intToLevels.get(l.value);
+            if (list == null) {
+                list = new ArrayList<>();
+                intToLevels.put(l.value, list);
+            }
+            list.add(o);
+        }
+
+        // Returns a KnownLevel with the given non-localized name.
+        static synchronized KnownLevel findByName(String name) {
+            List<KnownLevel> list = nameToLevels.get(name);
+            if (list != null) {
+                return list.get(0);
+            }
+            return null;
+        }
+
+        // Returns a KnownLevel with the given value.
+        static synchronized KnownLevel findByValue(int value) {
+            List<KnownLevel> list = intToLevels.get(value);
+            if (list != null) {
+                return list.get(0);
+            }
+            return null;
+        }
+
+        // Returns a KnownLevel with the given localized name matching
+        // by calling the Level.getLocalizedLevelName() method (i.e. found
+        // from the resourceBundle associated with the Level object).
+        // This method does not call Level.getLocalizedName() that may
+        // be overridden in a subclass implementation
+        static synchronized KnownLevel findByLocalizedLevelName(String name) {
+            for (List<KnownLevel> levels : nameToLevels.values()) {
+                for (KnownLevel l : levels) {
+                    String lname = l.levelObject.getLocalizedLevelName();
+                    if (name.equals(lname)) {
+                        return l;
+                    }
+                }
+            }
+            return null;
+        }
+
+        // Returns a KnownLevel with the given localized name matching
+        // by calling the Level.getLocalizedName() method
+        static synchronized KnownLevel findByLocalizedName(String name) {
+            for (List<KnownLevel> levels : nameToLevels.values()) {
+                for (KnownLevel l : levels) {
+                    String lname = l.levelObject.getLocalizedName();
+                    if (name.equals(lname)) {
+                        return l;
+                    }
+                }
+            }
+            return null;
+        }
+
+        static synchronized KnownLevel matches(Level l) {
+            List<KnownLevel> list = nameToLevels.get(l.name);
+            if (list != null) {
+                for (KnownLevel level : list) {
+                    Level other = level.mirroredLevel;
+                    if (l.value == other.value &&
+                           (l.resourceBundleName == other.resourceBundleName ||
+                               (l.resourceBundleName != null &&
+                                l.resourceBundleName.equals(other.resourceBundleName)))) {
+                        return level;
+                    }
+                }
+            }
+            return null;
+        }
+    }
+
 }
--- jdk/src/share/classes/java/util/logging/LogManager.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/LogManager.java	2013-05-05 09:38:33.000000000 -0700
@@ -34,6 +34,8 @@
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeSupport;
 import java.net.URL;
+import sun.misc.JavaAWTAccess;
+import sun.misc.SharedSecrets;
 import sun.security.action.GetPropertyAction;
 
 /**
@@ -155,10 +157,9 @@
                          = new PropertyChangeSupport(LogManager.class);
     private final static Level defaultLevel = Level.INFO;
 
-    // Table of named Loggers that maps names to Loggers.
-    private Hashtable<String,LoggerWeakRef> namedLoggers = new Hashtable<>();
-    // Tree of named Loggers
-    private LogNode root = new LogNode(null);
+    // LoggerContext for system loggers and user loggers
+    private final LoggerContext systemContext = new SystemLoggerContext();
+    private final LoggerContext userContext = new LoggerContext();
     private Logger rootLogger;
 
     // Have we done the primordial reading of the configuration file?
@@ -197,6 +198,7 @@
                     // Create and retain Logger for the root of the namespace.
                     manager.rootLogger = manager.new RootLogger();
                     manager.addLogger(manager.rootLogger);
+                    manager.systemContext.addLocalLogger(manager.rootLogger);
 
                     // Adding the global Logger. Doing so in the Logger.<clinit>
                     // would deadlock with the LogManager.<clinit>.
@@ -279,14 +281,14 @@
                         return;
                     }
                     readPrimordialConfiguration = true;
+
                     try {
-                        AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
-                                public Object run() throws Exception {
+                        AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
+                                public Void run() throws Exception {
                                     readConfiguration();
 
                                     // Platform loggers begin to delegate to java.util.logging.Logger
                                     sun.util.logging.PlatformLogger.redirectPlatformLoggers();
-
                                     return null;
                                 }
                             });
@@ -314,7 +316,7 @@
         if (l == null) {
             throw new NullPointerException();
         }
-        checkAccess();
+        checkPermission();
         changes.addPropertyChangeListener(l);
     }
 
@@ -333,24 +335,72 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void removePropertyChangeListener(PropertyChangeListener l) throws SecurityException {
-        checkAccess();
+        checkPermission();
         changes.removePropertyChangeListener(l);
     }
 
-    // Package-level method.
+    // Returns the LoggerContext for the user code (i.e. application or AppContext).
+    // Loggers are isolated from each AppContext.
+    private LoggerContext getUserContext() {
+        LoggerContext context = null;
+
+        SecurityManager sm = System.getSecurityManager();
+        JavaAWTAccess javaAwtAccess = SharedSecrets.getJavaAWTAccess();
+        if (sm != null && javaAwtAccess != null) {
+            synchronized (javaAwtAccess) {
+                // AppContext.getAppContext() returns the system AppContext if called
+                // from a system thread but Logger.getLogger might be called from
+                // an applet code. Instead, find the AppContext of the applet code
+                // from the execution stack.
+                Object ecx = javaAwtAccess.getExecutionContext();
+                if (ecx == null) {
+                    // fall back to AppContext.getAppContext()
+                    ecx = javaAwtAccess.getContext();
+                }
+                context = (LoggerContext)javaAwtAccess.get(ecx, LoggerContext.class);
+                if (context == null) {
+                    if (javaAwtAccess.isMainAppContext()) {
+                        context = userContext;
+                    } else {
+                        context = new LoggerContext();
+                        // during initialization, rootLogger is null when
+                        // instantiating itself RootLogger
+                        if (manager.rootLogger != null)
+                            context.addLocalLogger(manager.rootLogger);
+                    }
+                    javaAwtAccess.put(ecx, LoggerContext.class, context);
+                }
+            }
+        } else {
+            context = userContext;
+        }
+        return context;
+    }
+
+    private List<LoggerContext> contexts() {
+        List<LoggerContext> cxs = new ArrayList<>();
+        cxs.add(systemContext);
+        cxs.add(getUserContext());
+        return cxs;
+    }
+
     // Find or create a specified logger instance. If a logger has
     // already been created with the given name it is returned.
     // Otherwise a new logger instance is created and registered
     // in the LogManager global namespace.
-
     // This method will always return a non-null Logger object.
     // Synchronization is not required here. All synchronization for
     // adding a new Logger object is handled by addLogger().
-    Logger demandLogger(String name) {
+    //
+    // This method must delegate to the LogManager implementation to
+    // add a new Logger or return the one that has been added previously
+    // as a LogManager subclass may override the addLogger, getLogger,
+    // readConfiguration, and other methods.
+    Logger demandLogger(String name, String resourceBundleName) {
         Logger result = getLogger(name);
         if (result == null) {
             // only allocate the new logger once
-            Logger newLogger = new Logger(name, null);
+            Logger newLogger = new Logger(name, resourceBundleName);
             do {
                 if (addLogger(newLogger)) {
                     // We successfully added the new Logger that we
@@ -375,24 +425,246 @@
         return result;
     }
 
-    // If logger.getUseParentHandlers() returns 'true' and any of the logger's
-    // parents have levels or handlers defined, make sure they are instantiated.
-    private void processParentHandlers(Logger logger, String name) {
-        int ix = 1;
-        for (;;) {
-            int ix2 = name.indexOf(".", ix);
-            if (ix2 < 0) {
-                break;
+    Logger demandSystemLogger(String name, String resourceBundleName) {
+        // Add a system logger in the system context's namespace
+        final Logger sysLogger = systemContext.demandLogger(name, resourceBundleName);
+
+        // Add the system logger to the LogManager's namespace if not exist
+        // so that there is only one single logger of the given name.
+        // System loggers are visible to applications unless a logger of
+        // the same name has been added.
+        Logger logger;
+        do {
+            // First attempt to call addLogger instead of getLogger
+            // This would avoid potential bug in custom LogManager.getLogger
+            // implementation that adds a logger if does not exist
+            if (addLogger(sysLogger)) {
+                // successfully added the new system logger
+                logger = sysLogger;
+            } else {
+                logger = getLogger(name);
+            }
+        } while (logger == null);
+
+        // LogManager will set the sysLogger's handlers via LogManager.addLogger method.
+        if (logger != sysLogger && sysLogger.getHandlers().length == 0) {
+            // if logger already exists but handlers not set
+            final Logger l = logger;
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    for (Handler hdl : l.getHandlers()) {
+                        sysLogger.addHandler(hdl);
+                    }
+                    return null;
+                }
+            });
+        }
+        return sysLogger;
+    }
+
+    // LoggerContext maintains the logger namespace per context.
+    // The default LogManager implementation has one system context and user
+    // context.  The system context is used to maintain the namespace for
+    // all system loggers and is queried by the system code.  If a system logger
+    // doesn't exist in the user context, it'll also be added to the user context.
+    // The user context is queried by the user code and all other loggers are
+    // added in the user context.
+    static class LoggerContext {
+        // Table of named Loggers that maps names to Loggers.
+        private final Hashtable<String,LoggerWeakRef> namedLoggers = new Hashtable<>();
+        // Tree of named Loggers
+        private final LogNode root;
+
+        private LoggerContext() {
+            this.root = new LogNode(null, this);
+        }
+
+        Logger demandLogger(String name, String resourceBundleName) {
+            // a LogManager subclass may have its own implementation to add and
+            // get a Logger.  So delegate to the LogManager to do the work.
+            return manager.demandLogger(name, resourceBundleName);
+        }
+
+        synchronized Logger findLogger(String name) {
+            LoggerWeakRef ref = namedLoggers.get(name);
+            if (ref == null) {
+                return null;
+            }
+            Logger logger = ref.get();
+            if (logger == null) {
+                // Hashtable holds stale weak reference
+                // to a logger which has been GC-ed.
+                removeLogger(name);
+            }
+            return logger;
+        }
+
+        // Add a logger to this context.  This method will only set its level
+        // and process parent loggers.  It doesn't set its handlers.
+        synchronized boolean addLocalLogger(Logger logger) {
+            final String name = logger.getName();
+            if (name == null) {
+                throw new NullPointerException();
+            }
+
+            // cleanup some Loggers that have been GC'ed
+            manager.drainLoggerRefQueueBounded();
+
+            LoggerWeakRef ref = namedLoggers.get(name);
+            if (ref != null) {
+                if (ref.get() == null) {
+                    // It's possible that the Logger was GC'ed after the
+                    // drainLoggerRefQueueBounded() call above so allow
+                    // a new one to be registered.
+                    removeLogger(name);
+                } else {
+                    // We already have a registered logger with the given name.
+                    return false;
+                }
+            }
+
+            // We're adding a new logger.
+            // Note that we are creating a weak reference here.
+            ref = manager.new LoggerWeakRef(logger);
+            namedLoggers.put(name, ref);
+
+            // Apply any initial level defined for the new logger.
+            Level level = manager.getLevelProperty(name + ".level", null);
+            if (level != null) {
+                doSetLevel(logger, level);
+            }
+
+            processParentHandlers(logger, name);
+
+            // Find the new node and its parent.
+            LogNode node = getNode(name);
+            node.loggerRef = ref;
+            Logger parent = null;
+            LogNode nodep = node.parent;
+            while (nodep != null) {
+                LoggerWeakRef nodeRef = nodep.loggerRef;
+                if (nodeRef != null) {
+                    parent = nodeRef.get();
+                    if (parent != null) {
+                        break;
+                    }
+                }
+                nodep = nodep.parent;
+            }
+
+            if (parent != null) {
+                doSetParent(logger, parent);
+            }
+            // Walk over the children and tell them we are their new parent.
+            node.walkAndSetParent(logger);
+            // new LogNode is ready so tell the LoggerWeakRef about it
+            ref.setNode(node);
+            return true;
+        }
+
+        void removeLogger(String name) {
+            namedLoggers.remove(name);
+        }
+
+        synchronized Enumeration<String> getLoggerNames() {
+            return namedLoggers.keys();
+        }
+
+        // If logger.getUseParentHandlers() returns 'true' and any of the logger's
+        // parents have levels or handlers defined, make sure they are instantiated.
+        private void processParentHandlers(final Logger logger, final String name) {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    if (logger != manager.rootLogger) {
+                        boolean useParent = manager.getBooleanProperty(name + ".useParentHandlers", true);
+                        if (!useParent) {
+                            logger.setUseParentHandlers(false);
+                        }
+                    }
+                    return null;
+                }
+            });
+
+            int ix = 1;
+            for (;;) {
+                int ix2 = name.indexOf(".", ix);
+                if (ix2 < 0) {
+                    break;
+                }
+                String pname = name.substring(0, ix2);
+                if (manager.getProperty(pname + ".level") != null ||
+                    manager.getProperty(pname + ".handlers") != null) {
+                    // This pname has a level/handlers definition.
+                    // Make sure it exists.
+                    demandLogger(pname, null);
+                }
+                ix = ix2+1;
+            }
+        }
+
+        // Gets a node in our tree of logger nodes.
+        // If necessary, create it.
+        LogNode getNode(String name) {
+            if (name == null || name.equals("")) {
+                return root;
+            }
+            LogNode node = root;
+            while (name.length() > 0) {
+                int ix = name.indexOf(".");
+                String head;
+                if (ix > 0) {
+                    head = name.substring(0, ix);
+                    name = name.substring(ix + 1);
+                } else {
+                    head = name;
+                    name = "";
+                }
+                if (node.children == null) {
+                    node.children = new HashMap<>();
+                }
+                LogNode child = node.children.get(head);
+                if (child == null) {
+                    child = new LogNode(node, this);
+                    node.children.put(head, child);
+                }
+                node = child;
             }
-            String pname = name.substring(0,ix2);
+            return node;
+        }
+    }
 
-            if (getProperty(pname+".level")    != null ||
-                getProperty(pname+".handlers") != null) {
-                // This pname has a level/handlers definition.
-                // Make sure it exists.
-                demandLogger(pname);
+    static class SystemLoggerContext extends LoggerContext {
+        // Add a system logger in the system context's namespace as well as
+        // in the LogManager's namespace if not exist so that there is only
+        // one single logger of the given name.  System loggers are visible
+        // to applications unless a logger of the same name has been added.
+        Logger demandLogger(String name, String resourceBundleName) {
+            Logger result = findLogger(name);
+            if (result == null) {
+                // only allocate the new system logger once
+                Logger newLogger = new Logger(name, resourceBundleName);
+                do {
+                    if (addLocalLogger(newLogger)) {
+                        // We successfully added the new Logger that we
+                        // created above so return it without refetching.
+                        result = newLogger;
+                    } else {
+                        // We didn't add the new Logger that we created above
+                        // because another thread added a Logger with the same
+                        // name after our null check above and before our call
+                        // to addLogger(). We have to refetch the Logger because
+                        // addLogger() returns a boolean instead of the Logger
+                        // reference itself. However, if the thread that created
+                        // the other Logger is not holding a strong reference to
+                        // the other Logger, then it is possible for the other
+                        // Logger to be GC'ed after we saw it in addLogger() and
+                        // before we can refetch it. If it has been GC'ed then
+                        // we'll just loop around and try again.
+                        result = findLogger(name);
+                    }
+                } while (result == null);
             }
-            ix = ix2+1;
+            return result;
         }
     }
 
@@ -401,32 +673,27 @@
     // be made based on the logging configuration, which can
     // only be modified by trusted code.
     private void loadLoggerHandlers(final Logger logger, final String name,
-                                    final String handlersPropertyName) {
+                                    final String handlersPropertyName)
+    {
         AccessController.doPrivileged(new PrivilegedAction<Object>() {
             public Object run() {
-                if (logger != rootLogger) {
-                    boolean useParent = getBooleanProperty(name + ".useParentHandlers", true);
-                    if (!useParent) {
-                        logger.setUseParentHandlers(false);
-                    }
-                }
-
                 String names[] = parseClassNames(handlersPropertyName);
                 for (int i = 0; i < names.length; i++) {
                     String word = names[i];
                     try {
-                        Class   clz = ClassLoader.getSystemClassLoader().loadClass(word);
+                        Class clz = ClassLoader.getSystemClassLoader().loadClass(word);
                         Handler hdl = (Handler) clz.newInstance();
-                        try {
-                            // Check if there is a property defining the
-                            // this handler's level.
-                            String levs = getProperty(word + ".level");
-                            if (levs != null) {
-                                hdl.setLevel(Level.parse(levs));
+                        // Check if there is a property defining the
+                        // this handler's level.
+                        String levs = getProperty(word + ".level");
+                        if (levs != null) {
+                            Level l = Level.findLevel(levs);
+                            if (l != null) {
+                                hdl.setLevel(l);
+                            } else {
+                                // Probably a bad level. Drop through.
+                                System.err.println("Can't set level for " + word);
                             }
-                        } catch (Exception ex) {
-                            System.err.println("Can't set level for " + word);
-                            // Probably a bad level. Drop through.
                         }
                         // Add this Handler to the logger
                         logger.addHandler(hdl);
@@ -437,7 +704,8 @@
                     }
                 }
                 return null;
-            }});
+            }
+        });
     }
 
 
@@ -482,7 +750,7 @@
             if (node != null) {
                 // if we have a LogNode, then we were a named Logger
                 // so clear namedLoggers weak ref to us
-                manager.namedLoggers.remove(name);
+                node.context.removeLogger(name);
                 name = null;  // clear our ref to the Logger's name
 
                 node.loggerRef = null;  // clear LogNode's weak ref to us
@@ -571,73 +839,22 @@
      *          false if a logger of that name already exists.
      * @exception NullPointerException if the logger name is null.
      */
-    public synchronized boolean addLogger(Logger logger) {
+    public boolean addLogger(Logger logger) {
         final String name = logger.getName();
         if (name == null) {
             throw new NullPointerException();
         }
-
-        // cleanup some Loggers that have been GC'ed
-        drainLoggerRefQueueBounded();
-
-        LoggerWeakRef ref = namedLoggers.get(name);
-        if (ref != null) {
-            if (ref.get() == null) {
-                // It's possible that the Logger was GC'ed after the
-                // drainLoggerRefQueueBounded() call above so allow
-                // a new one to be registered.
-                namedLoggers.remove(name);
-            } else {
-                // We already have a registered logger with the given name.
-                return false;
-            }
-        }
-
-        // We're adding a new logger.
-        // Note that we are creating a weak reference here.
-        ref = new LoggerWeakRef(logger);
-        namedLoggers.put(name, ref);
-
-        // Apply any initial level defined for the new logger.
-        Level level = getLevelProperty(name+".level", null);
-        if (level != null) {
-            doSetLevel(logger, level);
-        }
-
-        // Do we have a per logger handler too?
-        // Note: this will add a 200ms penalty
-        loadLoggerHandlers(logger, name, name+".handlers");
-        processParentHandlers(logger, name);
-
-        // Find the new node and its parent.
-        LogNode node = findNode(name);
-        node.loggerRef = ref;
-        Logger parent = null;
-        LogNode nodep = node.parent;
-        while (nodep != null) {
-            LoggerWeakRef nodeRef = nodep.loggerRef;
-            if (nodeRef != null) {
-                parent = nodeRef.get();
-                if (parent != null) {
-                    break;
-                }
-            }
-            nodep = nodep.parent;
-        }
-
-        if (parent != null) {
-            doSetParent(logger, parent);
+        LoggerContext cx = getUserContext();
+        if (cx.addLocalLogger(logger)) {
+            // Do we have a per logger handler too?
+            // Note: this will add a 200ms penalty
+            loadLoggerHandlers(logger, name, name + ".handlers");
+            return true;
+        } else {
+            return false;
         }
-        // Walk over the children and tell them we are their new parent.
-        node.walkAndSetParent(logger);
-
-        // new LogNode is ready so tell the LoggerWeakRef about it
-        ref.setNode(node);
-
-        return true;
     }
 
-
     // Private method to set a level on a logger.
     // If necessary, we raise privilege before doing the call.
     private static void doSetLevel(final Logger logger, final Level level) {
@@ -656,8 +873,6 @@
             }});
     }
 
-
-
     // Private method to set a parent on a logger.
     // If necessary, we raise privilege before doing the setParent call.
     private static void doSetParent(final Logger logger, final Logger parent) {
@@ -676,36 +891,6 @@
             }});
     }
 
-    // Find a node in our tree of logger nodes.
-    // If necessary, create it.
-    private LogNode findNode(String name) {
-        if (name == null || name.equals("")) {
-            return root;
-        }
-        LogNode node = root;
-        while (name.length() > 0) {
-            int ix = name.indexOf(".");
-            String head;
-            if (ix > 0) {
-                head = name.substring(0,ix);
-                name = name.substring(ix+1);
-            } else {
-                head = name;
-                name = "";
-            }
-            if (node.children == null) {
-                node.children = new HashMap<>();
-            }
-            LogNode child = node.children.get(head);
-            if (child == null) {
-                child = new LogNode(node);
-                node.children.put(head, child);
-            }
-            node = child;
-        }
-        return node;
-    }
-
     /**
      * Method to find a named logger.
      * <p>
@@ -721,18 +906,8 @@
      * @param name name of the logger
      * @return  matching logger or null if none is found
      */
-    public synchronized Logger getLogger(String name) {
-        LoggerWeakRef ref = namedLoggers.get(name);
-        if (ref == null) {
-            return null;
-        }
-        Logger logger = ref.get();
-        if (logger == null) {
-            // Hashtable holds stale weak reference
-            // to a logger which has been GC-ed.
-            namedLoggers.remove(name);
-        }
-        return logger;
+    public Logger getLogger(String name) {
+        return getUserContext().findLogger(name);
     }
 
     /**
@@ -751,8 +926,8 @@
      * <p>
      * @return  enumeration of logger name strings
      */
-    public synchronized Enumeration<String> getLoggerNames() {
-        return namedLoggers.keys();
+    public Enumeration<String> getLoggerNames() {
+        return getUserContext().getLoggerNames();
     }
 
     /**
@@ -772,7 +947,7 @@
      * @exception  IOException if there are IO problems reading the configuration.
      */
     public void readConfiguration() throws IOException, SecurityException {
-        checkAccess();
+        checkPermission();
 
         // if a configuration class is specified, load it and use it.
         String cname = System.getProperty("java.util.logging.config.class");
@@ -830,27 +1005,27 @@
      */
 
     public void reset() throws SecurityException {
-        checkAccess();
+        checkPermission();
         synchronized (this) {
             props = new Properties();
             // Since we are doing a reset we no longer want to initialize
             // the global handlers, if they haven't been initialized yet.
             initializedGlobalHandlers = true;
         }
-        Enumeration enum_ = getLoggerNames();
-        while (enum_.hasMoreElements()) {
-            String name = (String)enum_.nextElement();
-            resetLogger(name);
+        for (LoggerContext cx : contexts()) {
+            Enumeration<String> enum_ = cx.getLoggerNames();
+            while (enum_.hasMoreElements()) {
+                String name = enum_.nextElement();
+                Logger logger = cx.findLogger(name);
+                if (logger != null) {
+                    resetLogger(logger);
+                }
+            }
         }
     }
 
-
     // Private method to reset an individual target logger.
-    private void resetLogger(String name) {
-        Logger logger = getLogger(name);
-        if (logger == null) {
-            return;
-        }
+    private void resetLogger(Logger logger) {
         // Close all the Logger's handlers.
         Handler[] targets = logger.getHandlers();
         for (int i = 0; i < targets.length; i++) {
@@ -862,6 +1037,7 @@
                 // Problems closing a handler?  Keep going...
             }
         }
+        String name = logger.getName();
         if (name != null && name.equals("")) {
             // This is the root logger.
             logger.setLevel(defaultLevel);
@@ -915,7 +1091,7 @@
      * @exception  IOException if there are problems reading from the stream.
      */
     public void readConfiguration(InputStream ins) throws IOException, SecurityException {
-        checkAccess();
+        checkPermission();
         reset();
 
         // Load the properties
@@ -1009,11 +1185,8 @@
         if (val == null) {
             return defaultValue;
         }
-        try {
-            return Level.parse(val.trim());
-        } catch (Exception ex) {
-            return defaultValue;
-        }
+        Level l = Level.findLevel(val.trim());
+        return l != null ? l : defaultValue;
     }
 
     // Package private method to get a filter property.
@@ -1076,8 +1249,13 @@
         loadLoggerHandlers(rootLogger, null, "handlers");
     }
 
+    private final Permission controlPermission = new LoggingPermission("control", null);
 
-    private Permission ourPermission = new LoggingPermission("control", null);
+    void checkPermission() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null)
+            sm.checkPermission(controlPermission);
+    }
 
     /**
      * Check that the current context is trusted to modify the logging
@@ -1090,11 +1268,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void checkAccess() throws SecurityException {
-        SecurityManager sm = System.getSecurityManager();
-        if (sm == null) {
-            return;
-        }
-        sm.checkPermission(ourPermission);
+        checkPermission();
     }
 
     // Nested class to represent a node in our tree of named loggers.
@@ -1102,9 +1276,11 @@
         HashMap<String,LogNode> children;
         LoggerWeakRef loggerRef;
         LogNode parent;
+        final LoggerContext context;
 
-        LogNode(LogNode parent) {
+        LogNode(LogNode parent, LoggerContext context) {
             this.parent = parent;
+            this.context = context;
         }
 
         // Recursive method to walk the tree below a node and set
@@ -1131,7 +1307,6 @@
     // that we only instantiate the global handlers when they
     // are first needed.
     private class RootLogger extends Logger {
-
         private RootLogger() {
             super("", null);
             setLevel(defaultLevel);
@@ -1163,7 +1338,7 @@
     // Private method to be called when the configuration has
     // changed to apply any level settings to any pre-existing loggers.
     synchronized private void setLevelsOnExistingLoggers() {
-        Enumeration enum_ = props.propertyNames();
+        Enumeration<?> enum_ = props.propertyNames();
         while (enum_.hasMoreElements()) {
             String key = (String)enum_.nextElement();
             if (!key.endsWith(".level")) {
@@ -1177,11 +1352,13 @@
                 System.err.println("Bad level value for property: " + key);
                 continue;
             }
-            Logger l = getLogger(name);
-            if (l == null) {
-                continue;
+            for (LoggerContext cx : contexts()) {
+                Logger l = cx.findLogger(name);
+                if (l == null) {
+                    continue;
+                }
+                l.setLevel(level);
             }
-            l.setLevel(level);
         }
     }
 
--- jdk/src/share/classes/java/util/logging/Logger.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/Logger.java	2013-05-05 09:38:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -273,16 +273,50 @@
         this.manager = manager;
     }
 
-    private void checkAccess() throws SecurityException {
+    private void checkPermission() throws SecurityException {
         if (!anonymous) {
             if (manager == null) {
                 // Complete initialization of the global Logger.
                 manager = LogManager.getLogManager();
             }
-            manager.checkAccess();
+            manager.checkPermission();
         }
     }
 
+    // Until all JDK code converted to call sun.util.logging.PlatformLogger
+    // (see 7054233), we need to determine if Logger.getLogger is to add
+    // a system logger or user logger.
+    //
+    // As an interim solution, if the immediate caller whose caller loader is
+    // null, we assume it's a system logger and add it to the system context.
+    // These system loggers only set the resource bundle to the given
+    // resource bundle name (rather than the default system resource bundle).
+    private static class SystemLoggerHelper {
+        static boolean disableCallerCheck = getBooleanProperty("sun.util.logging.disableCallerCheck");
+        private static boolean getBooleanProperty(final String key) {
+            String s = AccessController.doPrivileged(new PrivilegedAction<String>() {
+                public String run() {
+                    return System.getProperty(key);
+                }
+            });
+            return Boolean.valueOf(s);
+        }
+    }
+
+    private static Logger demandLogger(String name, String resourceBundleName) {
+        LogManager manager = LogManager.getLogManager();
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null && !SystemLoggerHelper.disableCallerCheck) {
+            // 0: Reflection 1: Logger.demandLogger 2: Logger.getLogger 3: caller
+            final int SKIP_FRAMES = 3;
+            Class<?> caller = sun.reflect.Reflection.getCallerClass(SKIP_FRAMES);
+            if (caller.getClassLoader() == null) {
+                return manager.demandSystemLogger(name, resourceBundleName);
+            }
+        }
+        return manager.demandLogger(name, resourceBundleName);
+    }
+
     /**
      * Find or create a logger for a named subsystem.  If a logger has
      * already been created with the given name it is returned.  Otherwise
@@ -324,8 +358,7 @@
         // would throw an IllegalArgumentException in the second call
         // because the wrapper would result in an attempt to replace
         // the existing "resourceBundleForFoo" with null.
-        LogManager manager = LogManager.getLogManager();
-        return manager.demandLogger(name);
+        return demandLogger(name, null);
     }
 
     /**
@@ -372,8 +405,7 @@
     // Synchronization is not required here. All synchronization for
     // adding a new Logger object is handled by LogManager.addLogger().
     public static Logger getLogger(String name, String resourceBundleName) {
-        LogManager manager = LogManager.getLogManager();
-        Logger result = manager.demandLogger(name);
+        Logger result = demandLogger(name, resourceBundleName);
         if (result.resourceBundleName == null) {
             // Note: we may get a MissingResourceException here.
             result.setupResourceInfo(resourceBundleName);
@@ -384,6 +416,17 @@
         return result;
     }
 
+    // package-private
+    // Add a platform logger to the system context.
+    // i.e. caller of sun.util.logging.PlatformLogger.getLogger
+    static Logger getPlatformLogger(String name) {
+        LogManager manager = LogManager.getLogManager();
+
+        // all loggers in the system context will default to
+        // the system logger's resource bundle
+        Logger result = manager.demandSystemLogger(name, SYSTEM_LOGGER_RB_NAME);
+        return result;
+    }
 
     /**
      * Create an anonymous Logger.  The newly created Logger is not
@@ -482,7 +525,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void setFilter(Filter newFilter) throws SecurityException {
-        checkAccess();
+        checkPermission();
         filter = newFilter;
     }
 
@@ -536,7 +579,7 @@
     private void doLog(LogRecord lr) {
         lr.setLoggerName(name);
         String ebname = getEffectiveResourceBundleName();
-        if (ebname != null) {
+        if (ebname != null && !ebname.equals(SYSTEM_LOGGER_RB_NAME)) {
             lr.setResourceBundleName(ebname);
             lr.setResourceBundle(findResourceBundle(ebname));
         }
@@ -1168,7 +1211,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void setLevel(Level newLevel) throws SecurityException {
-        checkAccess();
+        checkPermission();
         synchronized (treeLock) {
             levelObject = newLevel;
             updateEffectiveLevel();
@@ -1223,7 +1266,7 @@
     public void addHandler(Handler handler) throws SecurityException {
         // Check for null handler
         handler.getClass();
-        checkAccess();
+        checkPermission();
         handlers.add(handler);
     }
 
@@ -1237,7 +1280,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void removeHandler(Handler handler) throws SecurityException {
-        checkAccess();
+        checkPermission();
         if (handler == null) {
             return;
         }
@@ -1265,7 +1308,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void setUseParentHandlers(boolean useParentHandlers) {
-        checkAccess();
+        checkPermission();
         this.useParentHandlers = useParentHandlers;
     }
 
@@ -1285,6 +1328,23 @@
     // May also return null if we can't find the resource bundle and
     // there is no suitable previous cached value.
 
+    static final String SYSTEM_LOGGER_RB_NAME = "sun.util.logging.resources.logging";
+
+    private static ResourceBundle findSystemResourceBundle(final Locale locale) {
+        // the resource bundle is in a restricted package
+        return AccessController.doPrivileged(new PrivilegedAction<ResourceBundle>() {
+            public ResourceBundle run() {
+                try {
+                    return ResourceBundle.getBundle(SYSTEM_LOGGER_RB_NAME,
+                                                    locale,
+                                                    ClassLoader.getSystemClassLoader());
+                } catch (MissingResourceException e) {
+                    throw new InternalError(e.toString());
+                }
+            }
+        });
+    }
+
     private synchronized ResourceBundle findResourceBundle(String name) {
         // Return a null bundle for a null name.
         if (name == null) {
@@ -1299,6 +1359,13 @@
             return catalog;
         }
 
+        if (name.equals(SYSTEM_LOGGER_RB_NAME)) {
+            catalog = findSystemResourceBundle(currentLocale);
+            catalogName = name;
+            catalogLocale = currentLocale;
+            return catalog;
+        }
+
         // Use the thread's context ClassLoader.  If there isn't one,
         // use the SystemClassloader.
         ClassLoader cl = Thread.currentThread().getContextClassLoader();
@@ -1315,7 +1382,6 @@
             // ClassLoader.  Drop through.
         }
 
-
         // Fall back to searching up the call stack and trying each
         // calling ClassLoader.
         for (int ix = 0; ; ix++) {
@@ -1405,7 +1471,7 @@
         if (parent == null) {
             throw new NullPointerException();
         }
-        manager.checkAccess();
+        manager.checkPermission();
         doSetParent(parent);
     }
 
--- jdk/src/share/classes/java/util/logging/Logging.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/Logging.java	2013-05-05 09:38:33.000000000 -0700
@@ -34,15 +34,15 @@
  *
  * The <tt>LoggingMXBean</tt> interface provides a standard
  * method for management access to the individual
- * java.util.Logger objects available at runtime.
+ * {@code Logger} objects available at runtime.
  *
  * @author Ron Mann
  * @author Mandy Chung
  * @since 1.5
  *
  * @see javax.management
- * @see java.util.Logger
- * @see java.util.LogManager
+ * @see Logger
+ * @see LogManager
  */
 class Logging implements LoggingMXBean {
 
@@ -75,7 +75,7 @@
         if (level == null) {
             return EMPTY_STRING;
         } else {
-            return level.getName();
+            return level.getLevelName();
         }
     }
 
@@ -85,7 +85,6 @@
         }
 
         Logger logger = logManager.getLogger(loggerName);
-
         if (logger == null) {
             throw new IllegalArgumentException("Logger " + loggerName +
                 "does not exist");
@@ -94,7 +93,10 @@
         Level level = null;
         if (levelName != null) {
             // parse will throw IAE if logLevel is invalid
-            level = Level.parse(levelName);
+            level = Level.findLevel(levelName);
+            if (level == null) {
+                throw new IllegalArgumentException("Unknown level \"" + levelName + "\"");
+            }
         }
 
         logger.setLevel(level);
--- jdk/src/share/classes/java/util/logging/LoggingProxyImpl.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/LoggingProxyImpl.java	2013-05-05 09:38:33.000000000 -0700
@@ -37,7 +37,8 @@
 
     @Override
     public Object getLogger(String name) {
-        return Logger.getLogger(name);
+        // always create a platform logger with the resource bundle name
+        return Logger.getPlatformLogger(name);
     }
 
     @Override
@@ -92,12 +93,16 @@
 
     @Override
     public Object parseLevel(String levelName) {
-        return Level.parse(levelName);
+        Level level = Level.findLevel(levelName);
+        if (level == null) {
+            throw new IllegalArgumentException("Unknown level \"" + levelName + "\"");
+        }
+        return level;
     }
 
     @Override
     public String getLevelName(Object level) {
-        return ((Level) level).getName();
+        return ((Level) level).getLevelName();
     }
 
     @Override
--- jdk/src/share/classes/java/util/logging/MemoryHandler.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/MemoryHandler.java	2013-05-05 09:38:33.000000000 -0700
@@ -238,7 +238,7 @@
             throw new NullPointerException();
         }
         LogManager manager = LogManager.getLogManager();
-        checkAccess();
+        checkPermission();
         pushLevel = newLevel;
     }
 
--- jdk/src/share/classes/java/util/logging/SimpleFormatter.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/SimpleFormatter.java	2013-05-05 09:38:33.000000000 -0700
@@ -162,7 +162,7 @@
                              dat,
                              source,
                              record.getLoggerName(),
-                             record.getLevel().getLocalizedName(),
+                             record.getLevel().getLocalizedLevelName(),
                              message,
                              throwable);
     }
--- jdk/src/share/classes/java/util/logging/StreamHandler.java	2012-08-10 10:27:22.000000000 -0700
+++ jdk/src/share/classes/java/util/logging/StreamHandler.java	2013-05-05 09:38:33.000000000 -0700
@@ -249,7 +249,7 @@
     }
 
     private synchronized void flushAndClose() throws SecurityException {
-        checkAccess();
+        checkPermission();
         if (writer != null) {
             try {
                 if (!doneHeader) {
--- jdk/src/share/classes/javax/crypto/CryptoPermissions.java	2012-08-10 10:27:27.000000000 -0700
+++ jdk/src/share/classes/javax/crypto/CryptoPermissions.java	2013-05-05 09:38:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,10 +30,16 @@
 import java.util.Hashtable;
 import java.util.Vector;
 import java.util.NoSuchElementException;
+import java.util.concurrent.ConcurrentHashMap;
 import java.io.Serializable;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.BufferedReader;
+import java.io.ObjectStreamField;
+import java.io.ObjectInputStream;
+import java.io.ObjectInputStream.GetField;
+import java.io.ObjectOutputStream;
+import java.io.ObjectOutputStream.PutField;
 import java.io.IOException;
 
 /**
@@ -61,15 +67,24 @@
 
     private static final long serialVersionUID = 4946547168093391015L;
 
-    // This class is similar to java.security.Permissions
-    private Hashtable perms;
+    /**
+     * @serialField perms java.util.Hashtable
+     */
+    private static final ObjectStreamField[] serialPersistentFields = {
+        new ObjectStreamField("perms", Hashtable.class),
+    };
+
+    // Switched from Hashtable to ConcurrentHashMap to improve scalability.
+    // To maintain serialization compatibility, this field is made transient
+    // and custom readObject/writeObject methods are used.
+    private transient ConcurrentHashMap<String,PermissionCollection> perms;
 
     /**
      * Creates a new CryptoPermissions object containing
      * no CryptoPermissionCollections.
      */
     CryptoPermissions() {
-        perms = new Hashtable(7);
+        perms = new ConcurrentHashMap<>(7);
     }
 
     /**
@@ -132,9 +147,7 @@
                         getPermissionCollection(cryptoPerm);
         pc.add(cryptoPerm);
         String alg = cryptoPerm.getAlgorithm();
-        if (!perms.containsKey(alg)) {
-            perms.put(alg, pc);
-        }
+        perms.putIfAbsent(alg, pc);
     }
 
     /**
@@ -382,20 +395,17 @@
     PermissionCollection getPermissionCollection(String alg) {
         // If this CryptoPermissions includes CryptoAllPermission,
         // we should return CryptoAllPermission.
-        if (perms.containsKey(CryptoAllPermission.ALG_NAME)) {
-            return
-                (PermissionCollection)(perms.get(CryptoAllPermission.ALG_NAME));
-        }
-
-        PermissionCollection pc = (PermissionCollection)perms.get(alg);
-
-        // If there isn't a PermissionCollection for
-        // the given algorithm,we should return the
-        // PermissionCollection for the wildcard
-        // if there is one.
+        PermissionCollection pc = perms.get(CryptoAllPermission.ALG_NAME);
         if (pc == null) {
-            pc = (PermissionCollection)perms.get(
-                                       CryptoPermission.ALG_NAME_WILDCARD);
+            pc = perms.get(alg);
+
+            // If there isn't a PermissionCollection for
+            // the given algorithm,we should return the
+            // PermissionCollection for the wildcard
+            // if there is one.
+            if (pc == null) {
+                pc = perms.get(CryptoPermission.ALG_NAME_WILDCARD);
+            }
         }
         return pc;
     }
@@ -421,6 +431,28 @@
         }
         return pc;
     }
+
+    private void readObject(ObjectInputStream s)
+        throws IOException, ClassNotFoundException {
+        ObjectInputStream.GetField fields = s.readFields();
+        @SuppressWarnings("unchecked")
+        Hashtable<String,PermissionCollection> permTable =
+                (Hashtable<String,PermissionCollection>)
+                (fields.get("perms", null));
+        if (permTable != null) {
+            perms = new ConcurrentHashMap<>(permTable);
+        } else {
+            perms = new ConcurrentHashMap<>();
+        }
+    }
+
+    private void writeObject(ObjectOutputStream s) throws IOException {
+        Hashtable<String,PermissionCollection> permTable =
+                new Hashtable<>(perms);
+        ObjectOutputStream.PutField fields = s.putFields();
+        fields.put("perms", permTable);
+        s.writeFields();
+    }
 }
 
 final class PermissionsEnumerator implements Enumeration {
@@ -463,7 +495,6 @@
         } else {
             throw new NoSuchElementException("PermissionsEnumerator");
         }
-
     }
 
     private Enumeration getNextEnumWithMore() {
--- jdk/src/share/classes/javax/crypto/JceSecurityManager.java	2012-08-10 10:27:28.000000000 -0700
+++ jdk/src/share/classes/javax/crypto/JceSecurityManager.java	2013-05-05 09:38:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,8 @@
 import java.net.*;
 import java.util.*;
 import java.util.jar.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * The JCE security manager.
@@ -51,7 +53,10 @@
     private static final CryptoPermissions exemptPolicy;
     private static final CryptoAllPermission allPerm;
     private static final Vector TrustedCallersCache = new Vector(2);
-    private static final Map exemptCache = new HashMap();
+    private static final ConcurrentMap<URL,CryptoPermissions> exemptCache =
+            new ConcurrentHashMap<>();
+    private static final CryptoPermissions CACHE_NULL_MARK =
+            new CryptoPermissions();
 
     // singleton instance
     static final JceSecurityManager INSTANCE;
@@ -116,17 +121,19 @@
             return defaultPerm;
         }
 
-        CryptoPermissions appPerms;
-        synchronized (this.getClass()) {
-            if (exemptCache.containsKey(callerCodeBase)) {
-                appPerms = (CryptoPermissions)exemptCache.get(callerCodeBase);
-            } else {
-                appPerms = getAppPermissions(callerCodeBase);
-                exemptCache.put(callerCodeBase, appPerms);
+        CryptoPermissions appPerms = exemptCache.get(callerCodeBase);
+        if (appPerms == null) {
+            // no match found in cache
+            synchronized (this.getClass()) {
+                appPerms = exemptCache.get(callerCodeBase);
+                if (appPerms == null) {
+                    appPerms = getAppPermissions(callerCodeBase);
+                    exemptCache.putIfAbsent(callerCodeBase,
+                        (appPerms == null? CACHE_NULL_MARK:appPerms));
+                }
             }
         }
-
-        if (appPerms == null) {
+        if (appPerms == null || appPerms == CACHE_NULL_MARK) {
             return defaultPerm;
         }
 
--- jdk/src/share/classes/javax/management/modelmbean/DescriptorSupport.java	2012-08-10 10:27:37.000000000 -0700
+++ jdk/src/share/classes/javax/management/modelmbean/DescriptorSupport.java	2013-05-05 09:38:34.000000000 -0700
@@ -1245,13 +1245,12 @@
             return s.substring(1, s.length() - 1);
         }
         final String className = s.substring(1, slash);
+
         final Constructor<?> constr;
         try {
+            ReflectUtil.checkPackageAccess(className);
             final ClassLoader contextClassLoader =
                 Thread.currentThread().getContextClassLoader();
-            if (contextClassLoader == null) {
-                ReflectUtil.checkPackageAccess(className);
-            }
             final Class<?> c =
                 Class.forName(className, false, contextClassLoader);
             constr = c.getConstructor(new Class<?>[] {String.class});
--- jdk/src/share/classes/javax/management/modelmbean/RequiredModelMBean.java	2012-08-10 10:27:37.000000000 -0700
+++ jdk/src/share/classes/javax/management/modelmbean/RequiredModelMBean.java	2013-05-05 09:38:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,11 +39,13 @@
 import java.lang.reflect.InvocationTargetException;
 
 import java.lang.reflect.Method;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.logging.Level;
 import java.util.Map;
 import java.util.Set;
@@ -78,6 +80,8 @@
 import javax.management.RuntimeOperationsException;
 import javax.management.ServiceNotFoundException;
 import javax.management.loading.ClassLoaderRepository;
+import sun.misc.JavaSecurityAccess;
+import sun.misc.SharedSecrets;
 
 import sun.reflect.misc.MethodUtil;
 import sun.reflect.misc.ReflectUtil;
@@ -138,6 +142,9 @@
     private boolean registered = false;
     private transient MBeanServer server = null;
 
+    private final static JavaSecurityAccess javaSecurityAccess = SharedSecrets.getJavaSecurityAccess();
+    final private AccessControlContext acc = AccessController.getContext();
+
     /*************************************/
     /* constructors                      */
     /*************************************/
@@ -1025,10 +1032,31 @@
 
             if (opClassName != null) {
                 try {
-                    final ClassLoader targetClassLoader =
-                        targetObject.getClass().getClassLoader();
-                    targetClass = Class.forName(opClassName, false,
-                                                targetClassLoader);
+                    AccessControlContext stack = AccessController.getContext();
+                    final Object obj = targetObject;
+                    final String className = opClassName;
+                    final ClassNotFoundException[] caughtException = new ClassNotFoundException[1];
+
+                    targetClass = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Class<?>>() {
+
+                        @Override
+                        public Class<?> run() {
+                            try {
+                                ReflectUtil.checkPackageAccess(className);
+                                final ClassLoader targetClassLoader =
+                                    obj.getClass().getClassLoader();
+                                return Class.forName(className, false,
+                                                            targetClassLoader);
+                            } catch (ClassNotFoundException e) {
+                                caughtException[0] = e;
+                            }
+                            return null;
+                        }
+                    }, stack, acc);
+
+                    if (caughtException[0] != null) {
+                        throw caughtException[0];
+                    }
                 } catch (ClassNotFoundException e) {
                     final String msg =
                         "class for invoke " + opName + " not found";
@@ -1061,9 +1089,9 @@
         return result;
     }
 
-    private static Method resolveMethod(Class<?> targetClass,
+    private Method resolveMethod(Class<?> targetClass,
                                         String opMethodName,
-                                        String[] sig)
+                                        final String[] sig)
             throws ReflectionException {
         final boolean tracing = MODELMBEAN_LOGGER.isLoggable(Level.FINER);
 
@@ -1078,30 +1106,45 @@
         if (sig == null)
             argClasses = null;
         else {
+            final AccessControlContext stack = AccessController.getContext();
+            final ReflectionException[] caughtException = new ReflectionException[1];
             final ClassLoader targetClassLoader = targetClass.getClassLoader();
             argClasses = new Class<?>[sig.length];
-            for (int i = 0; i < sig.length; i++) {
-                if (tracing) {
-                    MODELMBEAN_LOGGER.logp(Level.FINER,
-                        RequiredModelMBean.class.getName(),"resolveMethod",
-                            "resolve type " + sig[i]);
-                }
-                argClasses[i] = (Class<?>) primitiveClassMap.get(sig[i]);
-                if (argClasses[i] == null) {
-                    try {
-                        argClasses[i] =
-                            Class.forName(sig[i], false, targetClassLoader);
-                    } catch (ClassNotFoundException e) {
+
+            javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Void>() {
+
+                @Override
+                public Void run() {
+                    for (int i = 0; i < sig.length; i++) {
                         if (tracing) {
                             MODELMBEAN_LOGGER.logp(Level.FINER,
-                                    RequiredModelMBean.class.getName(),
-                                    "resolveMethod",
-                                    "class not found");
+                                RequiredModelMBean.class.getName(),"resolveMethod",
+                                    "resolve type " + sig[i]);
+                        }
+                        argClasses[i] = (Class<?>) primitiveClassMap.get(sig[i]);
+                        if (argClasses[i] == null) {
+                            try {
+                                ReflectUtil.checkPackageAccess(sig[i]);
+                                argClasses[i] =
+                                    Class.forName(sig[i], false, targetClassLoader);
+                            } catch (ClassNotFoundException e) {
+                                if (tracing) {
+                                    MODELMBEAN_LOGGER.logp(Level.FINER,
+                                            RequiredModelMBean.class.getName(),
+                                            "resolveMethod",
+                                            "class not found");
+                                }
+                                final String msg = "Parameter class not found";
+                                caughtException[0] = new ReflectionException(e, msg);
+                            }
                         }
-                        final String msg = "Parameter class not found";
-                        throw new ReflectionException(e, msg);
                     }
+                    return null;
                 }
+            }, stack, acc);
+
+            if (caughtException[0] != null) {
+                throw caughtException[0];
             }
         }
 
@@ -1133,7 +1176,7 @@
     /* Find a method in RequiredModelMBean as determined by the given
        parameters.  Return null if there is none, or if the parameters
        exclude using it.  Called from invoke. */
-    private static Method findRMMBMethod(String opMethodName,
+    private Method findRMMBMethod(String opMethodName,
                                          Object targetObjectField,
                                          String opClassName,
                                          String[] sig) {
@@ -1155,19 +1198,29 @@
         if (opClassName == null)
             targetClass = rmmbClass;
         else {
-            try {
-                final ClassLoader targetClassLoader =
-                    rmmbClass.getClassLoader();
-                targetClass = Class.forName(opClassName, false,
-                                            targetClassLoader);
-                if (!rmmbClass.isAssignableFrom(targetClass))
-                    return null;
-            } catch (ClassNotFoundException e) {
-                return null;
-            }
+            AccessControlContext stack = AccessController.getContext();
+            final String className = opClassName;
+            targetClass = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Class<?>>() {
+
+                @Override
+                public Class<?> run() {
+                    try {
+                        ReflectUtil.checkPackageAccess(className);
+                        final ClassLoader targetClassLoader =
+                            rmmbClass.getClassLoader();
+                        Class clz = Class.forName(className, false,
+                                                    targetClassLoader);
+                        if (!rmmbClass.isAssignableFrom(clz))
+                            return null;
+                        return clz;
+                    } catch (ClassNotFoundException e) {
+                        return null;
+                    }
+                }
+            }, stack, acc);
         }
         try {
-            return resolveMethod(targetClass, opMethodName, sig);
+            return targetClass != null ? resolveMethod(targetClass, opMethodName, sig) : null;
         } catch (ReflectionException e) {
             return null;
         }
@@ -1177,12 +1230,35 @@
      * Invoke the given method, and throw the somewhat unpredictable
      * appropriate exception if the method itself gets an exception.
      */
-    private Object invokeMethod(String opName, Method method,
-                                Object targetObject, Object[] opArgs)
+    private Object invokeMethod(String opName, final Method method,
+                                final Object targetObject, final Object[] opArgs)
             throws MBeanException, ReflectionException {
         try {
-            ReflectUtil.checkPackageAccess(method.getDeclaringClass());
-            return MethodUtil.invoke(method, targetObject, opArgs);
+            final Throwable[] caughtException = new Throwable[1];
+            AccessControlContext stack = AccessController.getContext();
+            Object rslt = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Object>() {
+
+                @Override
+                public Object run() {
+                    try {
+                        ReflectUtil.checkPackageAccess(method.getDeclaringClass());
+                        return MethodUtil.invoke(method, targetObject, opArgs);
+                    } catch (InvocationTargetException e) {
+                        caughtException[0] = e;
+                    } catch (IllegalAccessException e) {
+                        caughtException[0] = e;
+                    }
+                    return null;
+                }
+            }, stack, acc);
+            if (caughtException[0] != null) {
+                if (caughtException[0] instanceof Exception) {
+                    throw (Exception)caughtException[0];
+                } else if(caughtException[0] instanceof Error) {
+                    throw (Error)caughtException[0];
+                }
+            }
+            return rslt;
         } catch (RuntimeErrorException ree) {
             throw new RuntimeOperationsException(ree,
                       "RuntimeException occurred in RequiredModelMBean "+
@@ -1567,7 +1643,7 @@
                 }
 
                 // make sure response class matches type field
-                String respType = attrInfo.getType();
+                final String respType = attrInfo.getType();
                 if (response != null) {
                     String responseClass = response.getClass().getName();
                     if (!respType.equals(responseClass)) {
@@ -1590,9 +1666,31 @@
                             // inequality may come from type subclassing
                             boolean subtype;
                             try {
-                                ClassLoader cl =
-                                    response.getClass().getClassLoader();
-                                Class<?> c = Class.forName(respType, true, cl);
+                                final Class respClass = response.getClass();
+                                final Exception[] caughException = new Exception[1];
+
+                                AccessControlContext stack = AccessController.getContext();
+
+                                Class c = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Class<?>>() {
+
+                                    @Override
+                                    public Class<?> run() {
+                                        try {
+                                            ReflectUtil.checkPackageAccess(respType);
+                                            ClassLoader cl =
+                                                respClass.getClassLoader();
+                                            return Class.forName(respType, true, cl);
+                                        } catch (Exception e) {
+                                            caughException[0] = e;
+                                        }
+                                        return null;
+                                    }
+                                }, stack, acc);
+
+                                if (caughException[0] != null) {
+                                    throw caughException[0];
+                                }
+
                                 subtype = c.isInstance(response);
                             } catch (Exception e) {
                                 subtype = false;
@@ -2745,16 +2843,37 @@
         return MBeanServerFactory.getClassLoaderRepository(server);
     }
 
-    private Class<?> loadClass(String className)
+    private Class<?> loadClass(final String className)
         throws ClassNotFoundException {
-        try {
-            return Class.forName(className);
-        } catch (ClassNotFoundException e) {
-            final ClassLoaderRepository clr =
-                getClassLoaderRepository();
-            if (clr == null) throw new ClassNotFoundException(className);
-            return clr.loadClass(className);
+        AccessControlContext stack = AccessController.getContext();
+        final ClassNotFoundException[] caughtException = new ClassNotFoundException[1];
+
+        Class c = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Class<?>>() {
+
+            @Override
+            public Class<?> run() {
+                try {
+                    ReflectUtil.checkPackageAccess(className);
+                    return Class.forName(className);
+                } catch (ClassNotFoundException e) {
+                    final ClassLoaderRepository clr =
+                        getClassLoaderRepository();
+                    try {
+                        if (clr == null) throw new ClassNotFoundException(className);
+                        return clr.loadClass(className);
+                    } catch (ClassNotFoundException ex) {
+                        caughtException[0] = ex;
+                    }
+                }
+                return null;
+            }
+        }, stack, acc);
+
+        if (caughtException[0] != null) {
+            throw caughtException[0];
         }
+
+        return c;
     }
 
 
@@ -2878,4 +2997,4 @@
             Void.class.getName()
         };
     }
-}
+}
\ No newline at end of file
--- jdk/src/share/classes/javax/management/remote/rmi/RMIConnectionImpl.java	2012-08-10 10:27:41.000000000 -0700
+++ jdk/src/share/classes/javax/management/remote/rmi/RMIConnectionImpl.java	2013-05-05 09:38:34.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,11 +39,17 @@
 import java.rmi.MarshalledObject;
 import java.rmi.UnmarshalException;
 import java.rmi.server.Unreferenced;
+
 import java.security.AccessControlContext;
 import java.security.AccessController;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.Permissions;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.security.ProtectionDomain;
+
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Map;
@@ -60,6 +66,7 @@
 import javax.management.MBeanException;
 import javax.management.MBeanInfo;
 import javax.management.MBeanRegistrationException;
+import javax.management.MBeanPermission;
 import javax.management.MBeanServer;
 import javax.management.NotCompliantMBeanException;
 import javax.management.NotificationFilter;
@@ -143,6 +150,7 @@
         this.mbeanServer = rmiServer.getMBeanServer();
 
         final ClassLoader dcl = defaultClassLoader;
+
         this.classLoaderWithRepository =
             AccessController.doPrivileged(
                 new PrivilegedAction<ClassLoaderWithRepository>() {
@@ -151,13 +159,40 @@
                                       mbeanServer.getClassLoaderRepository(),
                                       dcl);
                     }
+                },
+
+                withPermissions( new MBeanPermission("*", "getClassLoaderRepository"),
+                                 new RuntimePermission("createClassLoader"))
+            );
+
+
+        this.defaultContextClassLoader =
+            AccessController.doPrivileged(
+                new PrivilegedAction<ClassLoader>() {
+            @Override
+                    public ClassLoader run() {
+                        return new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),
+                                dcl);
+                    }
                 });
+
         serverCommunicatorAdmin = new
           RMIServerCommunicatorAdmin(EnvHelp.getServerConnectionTimeout(env));
 
         this.env = env;
     }
 
+    private static AccessControlContext withPermissions(Permission ... perms){
+        Permissions col = new Permissions();
+
+        for (Permission thePerm : perms ) {
+            col.add(thePerm);
+        }
+
+        final ProtectionDomain pd = new ProtectionDomain(null, col);
+        return new AccessControlContext( new ProtectionDomain[] { pd });
+    }
+
     private synchronized ServerNotifForwarder getServerNotifFwd() {
         // Lazily created when first use. Mainly when
         // addNotificationListener is first called.
@@ -507,7 +542,7 @@
                  "connectionId=" + connectionId
                  +" unwrapping query with defaultClassLoader.");
 
-        queryValue = unwrap(query, defaultClassLoader, QueryExp.class);
+        queryValue = unwrap(query, defaultContextClassLoader, QueryExp.class);
 
         try {
             final Object params[] = new Object[] { name, queryValue };
@@ -542,7 +577,7 @@
                  "connectionId=" + connectionId
                  +" unwrapping query with defaultClassLoader.");
 
-        queryValue = unwrap(query, defaultClassLoader, QueryExp.class);
+        queryValue = unwrap(query, defaultContextClassLoader, QueryExp.class);
 
         try {
             final Object params[] = new Object[] { name, queryValue };
@@ -1330,7 +1365,9 @@
                         public ClassLoader run() throws InstanceNotFoundException {
                             return mbeanServer.getClassLoader(name);
                         }
-                    });
+                    },
+                    withPermissions(new MBeanPermission("*", "getClassLoader"))
+            );
         } catch (PrivilegedActionException pe) {
             throw (InstanceNotFoundException) extractException(pe);
         }
@@ -1345,7 +1382,9 @@
                         public Object run() throws InstanceNotFoundException {
                             return mbeanServer.getClassLoaderFor(name);
                         }
-                    });
+                    },
+                    withPermissions(new MBeanPermission("*", "getClassLoaderFor"))
+            );
         } catch (PrivilegedActionException pe) {
             throw (InstanceNotFoundException) extractException(pe);
         }
@@ -1572,7 +1611,8 @@
             ClassLoader orderCL = AccessController.doPrivileged(
                 new PrivilegedExceptionAction<ClassLoader>() {
                     public ClassLoader run() throws Exception {
-                        return new OrderClassLoaders(cl1, cl2);
+                        return new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),
+                                new OrderClassLoaders(cl1, cl2));
                     }
                 }
             );
@@ -1664,6 +1704,8 @@
 
     private final ClassLoader defaultClassLoader;
 
+    private final ClassLoader defaultContextClassLoader;
+
     private final ClassLoaderWithRepository classLoaderWithRepository;
 
     private boolean terminated = false;
@@ -1746,4 +1788,43 @@
 
     private static final ClassLogger logger =
         new ClassLogger("javax.management.remote.rmi", "RMIConnectionImpl");
+
+    private static final class CombinedClassLoader extends ClassLoader {
+
+        private final static class ClassLoaderWrapper extends ClassLoader {
+            ClassLoaderWrapper(ClassLoader cl) {
+                super(cl);
+            }
+
+            @Override
+            protected Class<?> loadClass(String name, boolean resolve)
+                    throws ClassNotFoundException {
+                return super.loadClass(name, resolve);
+            }
+        };
+
+        final ClassLoaderWrapper defaultCL;
+
+        private CombinedClassLoader(ClassLoader parent, ClassLoader defaultCL) {
+            super(parent);
+            this.defaultCL = new ClassLoaderWrapper(defaultCL);
+        }
+
+        @Override
+        protected Class<?> loadClass(String name, boolean resolve)
+        throws ClassNotFoundException {
+            try {
+                super.loadClass(name, resolve);
+            } catch(Exception e) {
+                for(Throwable t = e; t != null; t = t.getCause()) {
+                    if(t instanceof SecurityException) {
+                        throw t==e?(SecurityException)t:new SecurityException(t.getMessage(), e);
+                    }
+                }
+            }
+            final Class<?> cl = defaultCL.loadClass(name, resolve);
+            return cl;
+        }
+
+    }
 }
--- jdk/src/share/classes/javax/management/remote/rmi/RMIConnector.java	2012-08-10 10:27:41.000000000 -0700
+++ jdk/src/share/classes/javax/management/remote/rmi/RMIConnector.java	2013-05-05 09:38:34.000000000 -0700
@@ -277,9 +277,9 @@
             // Check for secure RMIServer stub if the corresponding
             // client-side environment property is set to "true".
             //
-            boolean checkStub = EnvHelp.computeBooleanFromString(
-                    usemap,
-                    "jmx.remote.x.check.stub",false);
+            String stringBoolean =  (String) usemap.get("jmx.remote.x.check.stub");
+            boolean checkStub = EnvHelp.computeBooleanFromString(stringBoolean);
+
             if (checkStub) checkStub(stub, rmiServerImplStubClass);
 
             // Connect IIOP Stub if needed.
--- jdk/src/share/classes/javax/management/remote/rmi/RMIConnectorServer.java	2012-08-10 10:27:41.000000000 -0700
+++ jdk/src/share/classes/javax/management/remote/rmi/RMIConnectorServer.java	2013-05-05 09:38:34.000000000 -0700
@@ -412,9 +412,8 @@
                 if (tracing)
                     logger.trace("start", "Using external directory: " + jndiUrl);
 
-                final boolean rebind = EnvHelp.computeBooleanFromString(
-                    attributes,
-                    JNDI_REBIND_ATTRIBUTE,false);
+                String stringBoolean = (String) attributes.get(JNDI_REBIND_ATTRIBUTE);
+                final boolean rebind = EnvHelp.computeBooleanFromString( stringBoolean );
 
                 if (tracing)
                     logger.trace("start", JNDI_REBIND_ATTRIBUTE + "=" + rebind);
--- jdk/src/share/classes/javax/swing/AncestorNotifier.java	2012-08-10 10:27:55.000000000 -0700
+++ jdk/src/share/classes/javax/swing/AncestorNotifier.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -44,7 +44,7 @@
 
 class AncestorNotifier implements ComponentListener, PropertyChangeListener, Serializable
 {
-    Component firstInvisibleAncestor;
+    transient Component firstInvisibleAncestor;
     EventListenerList listenerList = new EventListenerList();
     JComponent root;
 
--- jdk/src/share/classes/javax/swing/ClientPropertyKey.java	2012-08-10 10:27:55.000000000 -0700
+++ jdk/src/share/classes/javax/swing/ClientPropertyKey.java	2013-05-05 09:38:35.000000000 -0700
@@ -25,6 +25,8 @@
 
 package javax.swing;
 
+import sun.awt.AWTAccessor;
+
 /**
  * An enumeration for keys used as client properties within the Swing
  * implementation.
@@ -86,6 +88,15 @@
      */
     private final boolean reportValueNotSerializable;
 
+    static {
+        AWTAccessor.setClientPropertyKeyAccessor(
+            new AWTAccessor.ClientPropertyKeyAccessor() {
+                public Object getJComponent_TRANSFER_HANDLER() {
+                    return JComponent_TRANSFER_HANDLER;
+                }
+            });
+    }
+
     /**
      * Constructs a key with the {@code reportValueNotSerializable} property
      * set to {@code false}.
--- jdk/src/share/classes/javax/swing/JComponent.java	2012-08-10 10:27:56.000000000 -0700
+++ jdk/src/share/classes/javax/swing/JComponent.java	2013-05-05 09:38:35.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -2636,16 +2636,17 @@
      *    attribute: visualUpdate true
      */
     public void setVisible(boolean aFlag) {
-        if (aFlag != isVisible()) {
+        if(aFlag != isVisible()) {
             super.setVisible(aFlag);
-            if (aFlag) {
-                Container parent = getParent();
-                if (parent != null) {
-                    Rectangle r = getBounds();
-                    parent.repaint(r.x, r.y, r.width, r.height);
-                }
-                revalidate();
+            Container parent = getParent();
+            if(parent != null) {
+                Rectangle r = getBounds();
+                parent.repaint(r.x,r.y,r.width,r.height);
             }
+            // Some (all should) LayoutManagers do not consider components
+            // that are not visible. As such we need to revalidate when the
+            // visible bit changes.
+            revalidate();
         }
     }
 
@@ -5563,22 +5564,4 @@
         ",preferredSize=" + preferredSizeString;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    @Deprecated
-    public void hide() {
-        boolean showing = isShowing();
-        super.hide();
-        if (showing) {
-            Container parent = getParent();
-            if (parent != null) {
-                Rectangle r = getBounds();
-                parent.repaint(r.x, r.y, r.width, r.height);
-            }
-            revalidate();
-        }
-    }
-
 }
--- jdk/src/share/classes/javax/swing/JTable.java	2012-08-10 10:27:58.000000000 -0700
+++ jdk/src/share/classes/javax/swing/JTable.java	2013-05-05 09:38:35.000000000 -0700
@@ -781,15 +781,11 @@
                         scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);
                 if (corner == null || corner instanceof UIResource){
                     corner = null;
-                    Object componentClass = UIManager.get(
-                            "Table.scrollPaneCornerComponent");
-                    if (componentClass instanceof Class){
-                        try {
-                            corner = (Component)
-                                    ((Class)componentClass).newInstance();
-                        } catch (Exception e) {
-                            // just ignore and don't set corner
-                        }
+                    try {
+                        corner = (Component) UIManager.get(
+                                "Table.scrollPaneCornerComponent");
+                    } catch (Exception e) {
+                        // just ignore and don't set corner
                     }
                     scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,
                             corner);
--- jdk/src/share/classes/javax/swing/JViewport.java	2012-08-10 10:27:59.000000000 -0700
+++ jdk/src/share/classes/javax/swing/JViewport.java	2013-05-05 09:38:35.000000000 -0700
@@ -1586,18 +1586,10 @@
         int bdx = blitToX - blitFromX;
         int bdy = blitToY - blitFromY;
 
-        Composite oldComposite = null;
         // Shift the scrolled region
-        if (g instanceof Graphics2D) {
-            Graphics2D g2d = (Graphics2D) g;
-            oldComposite = g2d.getComposite();
-            g2d.setComposite(AlphaComposite.Src);
-        }
         rm.copyArea(this, g, blitFromX, blitFromY, blitW, blitH, bdx, bdy,
                     false);
-        if (oldComposite != null) {
-            ((Graphics2D) g).setComposite(oldComposite);
-        }
+
         // Paint the newly exposed region.
         int x = view.getX();
         int y = view.getY();
--- jdk/src/share/classes/javax/swing/RepaintManager.java	2012-08-10 10:28:00.000000000 -0700
+++ jdk/src/share/classes/javax/swing/RepaintManager.java	2013-05-05 09:38:35.000000000 -0700
@@ -27,11 +27,12 @@
 
 import java.awt.*;
 import java.awt.event.*;
-import java.awt.peer.ComponentPeer;
-import java.awt.peer.ContainerPeer;
 import java.awt.image.VolatileImage;
+import java.security.AccessControlContext;
 import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.applet.*;
 
 import sun.awt.AWTAccessor;
@@ -39,6 +40,8 @@
 import sun.awt.DisplayChangedListener;
 import sun.awt.SunToolkit;
 import sun.java2d.SunGraphicsEnvironment;
+import sun.misc.JavaSecurityAccess;
+import sun.misc.SharedSecrets;
 import sun.security.action.GetPropertyAction;
 
 import com.sun.java.swing.SwingUtilities3;
@@ -119,11 +122,6 @@
     // Whether or not a VolatileImage should be used for double-buffered painting
     static boolean volatileImageBufferEnabled = true;
     /**
-     * Type of VolatileImage which should be used for double-buffered
-     * painting.
-     */
-    private static final int volatileBufferType;
-    /**
      * Value of the system property awt.nativeDoubleBuffering.
      */
     private static boolean nativeDoubleBuffering;
@@ -176,6 +174,9 @@
      */
     private final ProcessingRunnable processingRunnable;
 
+    private final static JavaSecurityAccess javaSecurityAccess =
+        SharedSecrets.getJavaSecurityAccess();
+
 
     static {
         volatileImageBufferEnabled = "true".equals(AccessController.
@@ -209,13 +210,6 @@
             ((SunGraphicsEnvironment)ge).addDisplayChangedListener(
                     new DisplayChangedHandler());
         }
-        Toolkit tk = Toolkit.getDefaultToolkit();
-        if ((tk instanceof SunToolkit)
-                && ((SunToolkit) tk).isSwingBackbufferTranslucencySupported()) {
-            volatileBufferType = Transparency.TRANSLUCENT;
-        } else {
-            volatileBufferType = Transparency.OPAQUE;
-        }
     }
 
     /**
@@ -548,13 +542,26 @@
     // This is called from the toolkit thread when awt needs to run a
     // Runnable before we paint.
     //
-    void nativeQueueSurfaceDataRunnable(AppContext appContext, Component c,
-                                        Runnable r) {
+    void nativeQueueSurfaceDataRunnable(AppContext appContext,
+                                        final Component c, final Runnable r)
+    {
         synchronized(this) {
             if (runnableList == null) {
                 runnableList = new LinkedList<Runnable>();
             }
-            runnableList.add(r);
+            runnableList.add(new Runnable() {
+                public void run() {
+                    AccessControlContext stack = AccessController.getContext();
+                    AccessControlContext acc =
+                        AWTAccessor.getComponentAccessor().getAccessControlContext(c);
+                    javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Void>() {
+                        public Void run() {
+                            r.run();
+                            return null;
+                        }
+                    }, stack, acc);
+                }
+            });
         }
         scheduleProcessingRunnable(appContext);
     }
@@ -652,9 +659,9 @@
      * @see #addInvalidComponent
      */
     public void validateInvalidComponents() {
-        java.util.List<Component> ic;
+        final java.util.List<Component> ic;
         synchronized(this) {
-            if(invalidComponents == null) {
+            if (invalidComponents == null) {
                 return;
             }
             ic = invalidComponents;
@@ -662,7 +669,17 @@
         }
         int n = ic.size();
         for(int i = 0; i < n; i++) {
-            ic.get(i).validate();
+            final Component c = ic.get(i);
+            AccessControlContext stack = AccessController.getContext();
+            AccessControlContext acc =
+                AWTAccessor.getComponentAccessor().getAccessControlContext(c);
+            javaSecurityAccess.doIntersectionPrivilege(
+                new PrivilegedAction<Void>() {
+                    public Void run() {
+                        c.validate();
+                        return null;
+                    }
+                }, stack, acc);
         }
     }
 
@@ -740,74 +757,75 @@
         paintDirtyRegions(tmpDirtyComponents);
     }
 
-    private void paintDirtyRegions(Map<Component,Rectangle>
-                                   tmpDirtyComponents){
-        int i, count;
-        java.util.List<Component> roots;
-        Component dirtyComponent;
-
-        count = tmpDirtyComponents.size();
-        if (count == 0) {
+    private void paintDirtyRegions(
+        final Map<Component,Rectangle> tmpDirtyComponents)
+    {
+        if (tmpDirtyComponents.isEmpty()) {
             return;
         }
 
-        Rectangle rect;
-        int localBoundsX = 0;
-        int localBoundsY = 0;
-        int localBoundsH;
-        int localBoundsW;
-        Enumeration keys;
-
-        roots = new ArrayList<Component>(count);
+        final java.util.List<Component> roots =
+            new ArrayList<Component>(tmpDirtyComponents.size());
 
         for (Component dirty : tmpDirtyComponents.keySet()) {
             collectDirtyComponents(tmpDirtyComponents, dirty, roots);
         }
 
-        count = roots.size();
+        final AtomicInteger count = new AtomicInteger(roots.size());
         painting = true;
         try {
-            for(i=0 ; i < count ; i++) {
-                dirtyComponent = roots.get(i);
-                rect = tmpDirtyComponents.get(dirtyComponent);
-                localBoundsH = dirtyComponent.getHeight();
-                localBoundsW = dirtyComponent.getWidth();
-
-                SwingUtilities.computeIntersection(localBoundsX,
-                                                   localBoundsY,
-                                                   localBoundsW,
-                                                   localBoundsH,
-                                                   rect);
-                if (dirtyComponent instanceof JComponent) {
-                    ((JComponent)dirtyComponent).paintImmediately(
-                        rect.x,rect.y,rect.width, rect.height);
-                }
-                else if (dirtyComponent.isShowing()) {
-                    Graphics g = JComponent.safelyGetGraphics(
-                            dirtyComponent, dirtyComponent);
-                    // If the Graphics goes away, it means someone disposed of
-                    // the window, don't do anything.
-                    if (g != null) {
-                        g.setClip(rect.x, rect.y, rect.width, rect.height);
-                        try {
-                            dirtyComponent.paint(g);
-                        } finally {
-                            g.dispose();
+            for(int j = 0; j < count.get(); j++) {
+                final int i = j;
+                final Component dirtyComponent = roots.get(j);
+
+                AccessControlContext stack = AccessController.getContext();
+                AccessControlContext acc =
+                    AWTAccessor.getComponentAccessor().getAccessControlContext(dirtyComponent);
+                javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Void>() {
+                    public Void run() {
+                        Rectangle rect = tmpDirtyComponents.get(dirtyComponent);
+
+                        int localBoundsH = dirtyComponent.getHeight();
+                        int localBoundsW = dirtyComponent.getWidth();
+                        SwingUtilities.computeIntersection(0,
+                                                           0,
+                                                           localBoundsW,
+                                                           localBoundsH,
+                                                           rect);
+                        if (dirtyComponent instanceof JComponent) {
+                            ((JComponent)dirtyComponent).paintImmediately(
+                                rect.x,rect.y,rect.width, rect.height);
+                        }
+                        else if (dirtyComponent.isShowing()) {
+                            Graphics g = JComponent.safelyGetGraphics(
+                                    dirtyComponent, dirtyComponent);
+                            // If the Graphics goes away, it means someone disposed of
+                            // the window, don't do anything.
+                            if (g != null) {
+                                g.setClip(rect.x, rect.y, rect.width, rect.height);
+                                try {
+                                    dirtyComponent.paint(g);
+                                } finally {
+                                    g.dispose();
+                                }
+                            }
+                        }
+                        // If the repaintRoot has been set, service it now and
+                        // remove any components that are children of repaintRoot.
+                        if (repaintRoot != null) {
+                            adjustRoots(repaintRoot, roots, i + 1);
+                            count.set(roots.size());
+                            paintManager.isRepaintingRoot = true;
+                            repaintRoot.paintImmediately(0, 0, repaintRoot.getWidth(),
+                                                         repaintRoot.getHeight());
+                            paintManager.isRepaintingRoot = false;
+                            // Only service repaintRoot once.
+                            repaintRoot = null;
                         }
+
+                        return null;
                     }
-                }
-                // If the repaintRoot has been set, service it now and
-                // remove any components that are children of repaintRoot.
-                if (repaintRoot != null) {
-                    adjustRoots(repaintRoot, roots, i + 1);
-                    count = roots.size();
-                    paintManager.isRepaintingRoot = true;
-                    repaintRoot.paintImmediately(0, 0, repaintRoot.getWidth(),
-                                                 repaintRoot.getHeight());
-                    paintManager.isRepaintingRoot = false;
-                    // Only service repaintRoot once.
-                    repaintRoot = null;
-                }
+                }, stack, acc);
             }
         } finally {
             painting = false;
@@ -997,8 +1015,7 @@
             if (image != null) {
                 image.flush();
             }
-            image = config.createCompatibleVolatileImage(width, height,
-                                                         volatileBufferType);
+            image = config.createCompatibleVolatileImage(width, height);
             volatileMap.put(config, image);
         }
         return image;
@@ -1492,26 +1509,9 @@
                     for(y=clipY, maxy = clipY + clipH; y < maxy ; y += bh) {
                         osg.translate(-x, -y);
                         osg.setClip(x,y,bw,bh);
-                        if (volatileBufferType != Transparency.OPAQUE
-                                && osg instanceof Graphics2D) {
-                            final Graphics2D g2d = (Graphics2D) osg;
-                            final Color oldBg = g2d.getBackground();
-                            g2d.setBackground(c.getBackground());
-                            g2d.clearRect(x, y, bw, bh);
-                            g2d.setBackground(oldBg);
-                        }
                         c.paintToOffscreen(osg, x, y, bw, bh, maxx, maxy);
                         g.setClip(x, y, bw, bh);
-                        if (volatileBufferType != Transparency.OPAQUE
-                                && g instanceof Graphics2D) {
-                            final Graphics2D g2d = (Graphics2D) g;
-                            final Composite oldComposite = g2d.getComposite();
-                            g2d.setComposite(AlphaComposite.Src);
-                            g2d.drawImage(image, x, y, c);
-                            g2d.setComposite(oldComposite);
-                        } else {
-                            g.drawImage(image, x, y, c);
-                        }
+                        g.drawImage(image, x, y, c);
                         osg.translate(x, y);
                     }
                 }
--- jdk/src/share/classes/javax/swing/UIDefaults.java	2012-08-10 10:28:01.000000000 -0700
+++ jdk/src/share/classes/javax/swing/UIDefaults.java	2013-05-05 09:38:35.000000000 -0700
@@ -677,6 +677,8 @@
         try {
             String className = (String)get(uiClassID);
             if (className != null) {
+                ReflectUtil.checkPackageAccess(className);
+
                 Class cls = (Class)get(className);
                 if (cls == null) {
                     if (uiClassLoader == null) {
--- jdk/src/share/classes/javax/swing/plaf/nimbus/NimbusLookAndFeel.java	2012-08-10 10:28:10.000000000 -0700
+++ jdk/src/share/classes/javax/swing/plaf/nimbus/NimbusLookAndFeel.java	2013-05-05 09:38:34.000000000 -0700
@@ -159,7 +159,12 @@
 
             // Store Table ScrollPane Corner Component
             uiDefaults.put("Table.scrollPaneCornerComponent",
-                    TableScrollPaneCorner.class);
+                    new UIDefaults.ActiveValue() {
+                        @Override
+                        public Object createValue(UIDefaults table) {
+                            return new TableScrollPaneCorner();
+                        }
+                    });
 
             // Setup the settings for ToolBarSeparator which is custom
             // installed for Nimbus
--- jdk/src/share/classes/javax/swing/text/DefaultCaret.java	2012-08-10 10:28:13.000000000 -0700
+++ jdk/src/share/classes/javax/swing/text/DefaultCaret.java	2013-05-05 09:38:35.000000000 -0700
@@ -403,10 +403,6 @@
      * @see MouseListener#mouseClicked
      */
     public void mouseClicked(MouseEvent e) {
-        if (getComponent() == null) {
-            return;
-        }
-
         int nclicks = SwingUtilities2.getAdjustedClickCount(getComponent(), e);
 
         if (! e.isConsumed()) {
--- jdk/src/share/classes/javax/swing/text/DefaultFormatter.java	2012-08-10 10:28:13.000000000 -0700
+++ jdk/src/share/classes/javax/swing/text/DefaultFormatter.java	2013-05-05 09:38:35.000000000 -0700
@@ -24,6 +24,8 @@
  */
 package javax.swing.text;
 
+import sun.reflect.misc.ConstructorUtil;
+
 import java.io.Serializable;
 import java.lang.reflect.*;
 import java.text.ParseException;
@@ -245,7 +247,7 @@
             Constructor cons;
 
             try {
-                cons = vc.getConstructor(new Class[] { String.class });
+                cons = ConstructorUtil.getConstructor(vc, new Class[]{String.class});
 
             } catch (NoSuchMethodException nsme) {
                 cons = null;
--- jdk/src/share/classes/sun/applet/AppletPanel.java	2012-08-10 10:28:21.000000000 -0700
+++ jdk/src/share/classes/sun/applet/AppletPanel.java	2013-05-05 09:38:29.000000000 -0700
@@ -45,6 +45,7 @@
 import java.util.Collections;
 import java.util.Locale;
 import java.util.WeakHashMap;
+import sun.awt.AWTAccessor;
 import sun.awt.AppContext;
 import sun.awt.EmbeddedFrame;
 import sun.awt.SunToolkit;
@@ -448,12 +449,12 @@
                       // to avoid deadlock.
                       try {
                           final AppletPanel p = this;
-
-                          EventQueue.invokeAndWait(new Runnable() {
-                                  public void run() {
-                                      p.validate();
-                                  }
-                              });
+                          Runnable r = new Runnable() {
+                              public void run() {
+                                  p.validate();
+                              }
+                          };
+                          AWTAccessor.getEventQueueAccessor().invokeAndWait(applet, r);
                       }
                       catch(InterruptedException ie) {
                       }
@@ -478,18 +479,19 @@
                       try {
                           final AppletPanel p = this;
                           final Applet a = applet;
-
-                          EventQueue.invokeAndWait(new Runnable() {
-                                  public void run() {
-                                      p.validate();
-                                      a.setVisible(true);
-
-                                      // Fix for BugTraq ID 4041703.
-                                      // Set the default focus for an applet.
-                                      if (hasInitialFocus())
-                                        setDefaultFocus();
+                          Runnable r = new Runnable() {
+                              public void run() {
+                                  p.validate();
+                                  a.setVisible(true);
+
+                                  // Fix for BugTraq ID 4041703.
+                                  // Set the default focus for an applet.
+                                  if (hasInitialFocus()) {
+                                      setDefaultFocus();
                                   }
-                              });
+                              }
+                          };
+                          AWTAccessor.getEventQueueAccessor().invokeAndWait(applet, r);
                       }
                       catch(InterruptedException ie) {
                       }
@@ -512,13 +514,12 @@
                     // to avoid deadlock.
                     try {
                         final Applet a = applet;
-
-                        EventQueue.invokeAndWait(new Runnable() {
-                                public void run()
-                                {
-                                    a.setVisible(false);
-                                }
-                            });
+                        Runnable r = new Runnable() {
+                            public void run() {
+                                a.setVisible(false);
+                            }
+                        };
+                        AWTAccessor.getEventQueueAccessor().invokeAndWait(applet, r);
                     }
                     catch(InterruptedException ie) {
                     }
@@ -570,17 +571,14 @@
                     }
                     status = APPLET_DISPOSE;
 
-                    try
-                    {
+                    try {
                         final Applet a = applet;
-
-                        EventQueue.invokeAndWait(new Runnable()
-                        {
-                            public void run()
-                            {
+                        Runnable r = new Runnable() {
+                            public void run() {
                                 remove(a);
                             }
-                        });
+                        };
+                        AWTAccessor.getEventQueueAccessor().invokeAndWait(applet, r);
                     }
                     catch(InterruptedException ie)
                     {
--- jdk/src/share/classes/sun/awt/AWTAccessor.java	2012-08-10 10:28:23.000000000 -0700
+++ jdk/src/share/classes/sun/awt/AWTAccessor.java	2013-05-05 09:38:29.000000000 -0700
@@ -27,17 +27,19 @@
 
 import java.awt.*;
 import java.awt.KeyboardFocusManager;
+import java.awt.DefaultKeyboardFocusManager;
 import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
 import java.awt.geom.Point2D;
-import java.awt.image.BufferedImage;
 
 import sun.misc.Unsafe;
 import java.awt.peer.ComponentPeer;
 
-import java.security.AccessController;
+import java.lang.reflect.InvocationTargetException;
 import java.security.AccessControlContext;
 
 import java.io.File;
+import java.util.Vector;
 
 /**
  * The AWTAccessor utility class.
@@ -317,7 +319,7 @@
         void setTrayIconWindow(Window w, boolean isTrayIconWindow);
     }
 
-    /*
+    /**
      * An accessor for the AWTEvent class.
      */
     public interface AWTEventAccessor {
@@ -337,12 +339,20 @@
          */
         boolean isSystemGenerated(AWTEvent ev);
 
-
-        /*
+        /**
          * Returns the acc this event was constructed with.
          */
         AccessControlContext getAccessControlContext(AWTEvent ev);
 
+        /**
+         * Returns binary data associated with this event;
+         */
+        byte[] getBData(AWTEvent ev);
+
+        /**
+         * Associates binary data with this event;
+         */
+        void setBData(AWTEvent ev, byte[] bdata);
     }
 
     public interface InputEventAccessor {
@@ -370,11 +380,11 @@
        Rectangle getMaximizedBounds(Frame frame);
     }
 
-    /*
+    /**
      * An interface of accessor for the java.awt.KeyboardFocusManager class.
      */
     public interface KeyboardFocusManagerAccessor {
-        /*
+        /**
          * Indicates whether the native implementation should
          * proceed with a pending focus request for the heavyweight.
          */
@@ -384,7 +394,7 @@
                                            boolean focusedWindowChangeAllowed,
                                            long time,
                                            CausedFocusEvent.Cause cause);
-        /*
+        /**
          * Delivers focus for the lightweight descendant of the heavyweight
          * synchronously.
          */
@@ -393,23 +403,28 @@
                                                       boolean temporary,
                                                       boolean focusedWindowChangeAllowed,
                                                       long time);
-        /*
+        /**
          * Removes the last focus request for the heavyweight from the queue.
          */
         void removeLastFocusRequest(Component heavyweight);
 
-        /*
+        /**
          * Sets the most recent focus owner in the window.
          */
         void setMostRecentFocusOwner(Window window, Component component);
 
-        /*
+        /**
          * Returns current KFM of the specified AppContext.
          */
         KeyboardFocusManager getCurrentKeyboardFocusManager(AppContext ctx);
+
+        /**
+         * Return the current focus cycle root
+         */
+        Container getCurrentFocusCycleRoot();
     }
 
-    /*
+    /**
      * An accessor for the MenuComponent class.
      */
     public interface MenuComponentAccessor {
@@ -427,20 +442,48 @@
          * Returns the menu container of the menu component
          */
         MenuContainer getParent(MenuComponent menuComp);
+
+        /**
+         * Gets the font used for this menu component.
+         */
+        Font getFont_NoClientCode(MenuComponent menuComp);
     }
 
-    /*
+    /**
      * An accessor for the EventQueue class
      */
     public interface EventQueueAccessor {
-        /*
+        /**
          * Gets the event dispatch thread.
          */
         Thread getDispatchThread(EventQueue eventQueue);
-        /*
+
+        /**
          * Checks if the current thread is EDT for the given EQ.
          */
         public boolean isDispatchThreadImpl(EventQueue eventQueue);
+
+        /**
+         * Removes any pending events for the specified source object.
+         */
+        void removeSourceEvents(EventQueue eventQueue, Object source, boolean removeAllEvents);
+
+        /**
+         * Returns whether an event is pending on any of the separate Queues.
+         */
+        boolean noEvents(EventQueue eventQueue);
+
+        /**
+         * Called from PostEventQueue.postEvent to notify that a new event
+         * appeared.
+         */
+        void wakeup(EventQueue eventQueue, boolean isShutdown);
+
+        /**
+         * Static in EventQueue
+         */
+        void invokeAndWait(Object source, Runnable r)
+            throws InterruptedException, InvocationTargetException;
     }
 
     /*
@@ -478,6 +521,174 @@
         boolean isMultipleMode(FileDialog fileDialog);
     }
 
+    /**
+     * An accessor for the ScrollPaneAdjustable class.
+     */
+    public interface ScrollPaneAdjustableAccessor {
+        /**
+         * Sets the value of this scrollbar to the specified value.
+         */
+        void setTypedValue(final ScrollPaneAdjustable adj, final int v,
+                           final int type);
+    }
+
+    /**
+     * An accessor for the CheckboxMenuItem class
+     */
+    public interface CheckboxMenuItemAccessor {
+        /**
+         * Returns whether menu item is checked
+         */
+        boolean getState(CheckboxMenuItem cmi);
+    }
+
+    /**
+     * An accessor for the Cursor class
+     */
+    public interface CursorAccessor {
+        /**
+         * Returns pData of the Cursor class
+         */
+        long getPData(Cursor cursor);
+
+        /**
+         * Sets pData to the Cursor class
+         */
+        void setPData(Cursor cursor, long pData);
+
+        /**
+         * Return type of the Cursor class
+         */
+        int getType(Cursor cursor);
+    }
+
+    /**
+     * An accessor for the MenuBar class
+     */
+    public interface MenuBarAccessor {
+        /**
+         * Returns help menu
+         */
+        Menu getHelpMenu(MenuBar menuBar);
+
+        /**
+         * Returns menus
+         */
+        Vector getMenus(MenuBar menuBar);
+    }
+
+    /**
+     * An accessor for the MenuItem class
+     */
+    public interface MenuItemAccessor {
+        /**
+         * Returns whether menu item is enabled
+         */
+        boolean isEnabled(MenuItem item);
+
+        /**
+         * Gets the command name of the action event that is fired
+         * by this menu item.
+         */
+        String getActionCommandImpl(MenuItem item);
+
+        /**
+         * Returns true if the item and all its ancestors are
+         * enabled, false otherwise
+         */
+        boolean isItemEnabled(MenuItem item);
+
+        /**
+         * Returns label
+         */
+        String getLabel(MenuItem item);
+
+        /**
+         * Returns shortcut
+         */
+        MenuShortcut getShortcut(MenuItem item);
+    }
+
+    /**
+     * An accessor for the Menu class
+     */
+    public interface MenuAccessor {
+        /**
+         * Returns vector of the items that are part of the Menu
+         */
+        Vector getItems(Menu menu);
+    }
+
+    /**
+     * An accessor for the KeyEvent class
+     */
+    public interface KeyEventAccessor {
+        /**
+         * Sets rawCode field for KeyEvent
+         */
+        void setRawCode(KeyEvent ev, long rawCode);
+
+        /**
+         * Sets primaryLevelUnicode field for KeyEvent
+         */
+        void setPrimaryLevelUnicode(KeyEvent ev, long primaryLevelUnicode);
+
+        /**
+         * Sets extendedKeyCode field for KeyEvent
+         */
+        void setExtendedKeyCode(KeyEvent ev, long extendedKeyCode);
+    }
+
+    /**
+     * An accessor for the ClientPropertyKey class
+     */
+    public interface ClientPropertyKeyAccessor {
+        /**
+         * Retrieves JComponent_TRANSFER_HANDLER enum object
+         */
+        Object getJComponent_TRANSFER_HANDLER();
+    }
+
+    /**
+     * An accessor for the SystemTray class
+     */
+    public interface SystemTrayAccessor {
+        /**
+         * Support for reporting bound property changes for Object properties.
+         */
+        void firePropertyChange(SystemTray tray, String propertyName, Object oldValue, Object newValue);
+    }
+
+    /**
+     * An accessor for the TrayIcon class
+     */
+    public interface TrayIconAccessor {
+        void addNotify(TrayIcon trayIcon) throws AWTException;
+        void removeNotify(TrayIcon trayIcon);
+    }
+
+    /**
+     * An accessor for the DefaultKeyboardFocusManager class
+     */
+    public interface DefaultKeyboardFocusManagerAccessor {
+        public void consumeNextKeyTyped(DefaultKeyboardFocusManager dkfm, KeyEvent e);
+    }
+
+    /*
+     * An accessor for the SequencedEventAccessor class
+     */
+    public interface SequencedEventAccessor {
+        /*
+         * Returns the nested event.
+         */
+        AWTEvent getNested(AWTEvent sequencedEvent);
+
+        /*
+         * Returns true if the event is an instances of SequencedEvent.
+         */
+        boolean isSequencedEvent(AWTEvent event);
+    }
+
     /*
      * Accessor instances are initialized in the static initializers of
      * corresponding AWT classes by using setters defined below.
@@ -493,6 +704,18 @@
     private static EventQueueAccessor eventQueueAccessor;
     private static PopupMenuAccessor popupMenuAccessor;
     private static FileDialogAccessor fileDialogAccessor;
+    private static ScrollPaneAdjustableAccessor scrollPaneAdjustableAccessor;
+    private static CheckboxMenuItemAccessor checkboxMenuItemAccessor;
+    private static CursorAccessor cursorAccessor;
+    private static MenuBarAccessor menuBarAccessor;
+    private static MenuItemAccessor menuItemAccessor;
+    private static MenuAccessor menuAccessor;
+    private static KeyEventAccessor keyEventAccessor;
+    private static ClientPropertyKeyAccessor clientPropertyKeyAccessor;
+    private static SystemTrayAccessor systemTrayAccessor;
+    private static TrayIconAccessor trayIconAccessor;
+    private static DefaultKeyboardFocusManagerAccessor defaultKeyboardFocusManagerAccessor;
+    private static SequencedEventAccessor sequencedEventAccessor;
 
     /*
      * Set an accessor object for the java.awt.Component class.
@@ -683,4 +906,208 @@
         return fileDialogAccessor;
     }
 
+    /**
+     * Set an accessor object for the java.awt.ScrollPaneAdjustable class.
+     */
+    public static void setScrollPaneAdjustableAccessor(ScrollPaneAdjustableAccessor adj) {
+        scrollPaneAdjustableAccessor = adj;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.ScrollPaneAdjustable
+     * class.
+     */
+    public static ScrollPaneAdjustableAccessor getScrollPaneAdjustableAccessor() {
+        if (scrollPaneAdjustableAccessor == null) {
+            unsafe.ensureClassInitialized(ScrollPaneAdjustable.class);
+        }
+        return scrollPaneAdjustableAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.CheckboxMenuItem class.
+     */
+    public static void setCheckboxMenuItemAccessor(CheckboxMenuItemAccessor cmia) {
+        checkboxMenuItemAccessor = cmia;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.CheckboxMenuItem class.
+     */
+    public static CheckboxMenuItemAccessor getCheckboxMenuItemAccessor() {
+        if (checkboxMenuItemAccessor == null) {
+            unsafe.ensureClassInitialized(CheckboxMenuItemAccessor.class);
+        }
+        return checkboxMenuItemAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.Cursor class.
+     */
+    public static void setCursorAccessor(CursorAccessor ca) {
+        cursorAccessor = ca;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.Cursor class.
+     */
+    public static CursorAccessor getCursorAccessor() {
+        if (cursorAccessor == null) {
+            unsafe.ensureClassInitialized(CursorAccessor.class);
+        }
+        return cursorAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.MenuBar class.
+     */
+    public static void setMenuBarAccessor(MenuBarAccessor mba) {
+        menuBarAccessor = mba;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.MenuBar class.
+     */
+    public static MenuBarAccessor getMenuBarAccessor() {
+        if (menuBarAccessor == null) {
+            unsafe.ensureClassInitialized(MenuBarAccessor.class);
+        }
+        return menuBarAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.MenuItem class.
+     */
+    public static void setMenuItemAccessor(MenuItemAccessor mia) {
+        menuItemAccessor = mia;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.MenuItem class.
+     */
+    public static MenuItemAccessor getMenuItemAccessor() {
+        if (menuItemAccessor == null) {
+            unsafe.ensureClassInitialized(MenuItemAccessor.class);
+        }
+        return menuItemAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.Menu class.
+     */
+    public static void setMenuAccessor(MenuAccessor ma) {
+        menuAccessor = ma;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.Menu class.
+     */
+    public static MenuAccessor getMenuAccessor() {
+        if (menuAccessor == null) {
+            unsafe.ensureClassInitialized(MenuAccessor.class);
+        }
+        return menuAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.event.KeyEvent class.
+     */
+    public static void setKeyEventAccessor(KeyEventAccessor kea) {
+        keyEventAccessor = kea;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.event.KeyEvent class.
+     */
+    public static KeyEventAccessor getKeyEventAccessor() {
+        if (keyEventAccessor == null) {
+            unsafe.ensureClassInitialized(KeyEventAccessor.class);
+        }
+        return keyEventAccessor;
+    }
+
+    /**
+     * Set an accessor object for the javax.swing.ClientPropertyKey class.
+     */
+    public static void setClientPropertyKeyAccessor(ClientPropertyKeyAccessor cpka) {
+        clientPropertyKeyAccessor = cpka;
+    }
+
+    /**
+     * Retrieve the accessor object for the javax.swing.ClientPropertyKey class.
+     */
+    public static ClientPropertyKeyAccessor getClientPropertyKeyAccessor() {
+        if (clientPropertyKeyAccessor == null) {
+            unsafe.ensureClassInitialized(ClientPropertyKeyAccessor.class);
+        }
+        return clientPropertyKeyAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.SystemTray class.
+     */
+    public static void setSystemTrayAccessor(SystemTrayAccessor sta) {
+        systemTrayAccessor = sta;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.SystemTray class.
+     */
+    public static SystemTrayAccessor getSystemTrayAccessor() {
+        if (systemTrayAccessor == null) {
+            unsafe.ensureClassInitialized(SystemTrayAccessor.class);
+        }
+        return systemTrayAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.TrayIcon class.
+     */
+    public static void setTrayIconAccessor(TrayIconAccessor tia) {
+        trayIconAccessor = tia;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.TrayIcon class.
+     */
+    public static TrayIconAccessor getTrayIconAccessor() {
+        if (trayIconAccessor == null) {
+            unsafe.ensureClassInitialized(TrayIconAccessor.class);
+        }
+        return trayIconAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.DefaultKeyboardFocusManager class.
+     */
+    public static void setDefaultKeyboardFocusManagerAccessor(DefaultKeyboardFocusManagerAccessor dkfma) {
+        defaultKeyboardFocusManagerAccessor = dkfma;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.DefaultKeyboardFocusManager class.
+     */
+    public static DefaultKeyboardFocusManagerAccessor getDefaultKeyboardFocusManagerAccessor() {
+        if (defaultKeyboardFocusManagerAccessor == null) {
+            unsafe.ensureClassInitialized(DefaultKeyboardFocusManagerAccessor.class);
+        }
+        return defaultKeyboardFocusManagerAccessor;
+    }
+
+    /*
+     * Set an accessor object for the java.awt.SequencedEvent class.
+     */
+    public static void setSequencedEventAccessor(SequencedEventAccessor sea) {
+        sequencedEventAccessor = sea;
+    }
+
+    /*
+     * Get the accessor object for the java.awt.SequencedEvent class.
+     */
+    public static SequencedEventAccessor getSequencedEventAccessor() {
+        // The class is not public. So we can't ensure it's initialized.
+        // Null returned value means it's not initialized
+        // (so not a single instance of the event has been created).
+        return sequencedEventAccessor;
+    }
 }
--- jdk/src/share/classes/sun/awt/AppContext.java	2012-08-10 10:28:23.000000000 -0700
+++ jdk/src/share/classes/sun/awt/AppContext.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -327,21 +327,27 @@
             // Before we return the main "system" AppContext, check to
             // see if there's an AWTSecurityManager installed.  If so,
             // allow it to choose the AppContext to return.
-            SecurityManager securityManager = System.getSecurityManager();
-            if ((securityManager != null) &&
-                (securityManager instanceof AWTSecurityManager))
-            {
-                AWTSecurityManager awtSecMgr = (AWTSecurityManager)securityManager;
-                AppContext secAppContext = awtSecMgr.getAppContext();
-                if (secAppContext != null)  {
-                    appContext = secAppContext; // Return what we're told
-                }
+            AppContext secAppContext = getExecutionAppContext();
+            if (secAppContext != null) {
+                appContext = secAppContext; // Return what we're told
             }
         }
 
         return appContext;
     }
 
+    private final static AppContext getExecutionAppContext() {
+        SecurityManager securityManager = System.getSecurityManager();
+        if ((securityManager != null) &&
+            (securityManager instanceof AWTSecurityManager))
+        {
+            AWTSecurityManager awtSecMgr = (AWTSecurityManager) securityManager;
+            AppContext secAppContext = awtSecMgr.getAppContext();
+            return secAppContext; // Return what we're told
+        }
+        return null;
+    }
+
     /**
      * Returns the main ("system") AppContext.
      *
@@ -787,6 +793,42 @@
         }
         return changeSupport.getPropertyChangeListeners(propertyName);
     }
+
+    // Set up JavaAWTAccess in SharedSecrets
+    static {
+        sun.misc.SharedSecrets.setJavaAWTAccess(new sun.misc.JavaAWTAccess() {
+            public Object get(Object key) {
+                return getAppContext().get(key);
+            }
+            public void put(Object key, Object value) {
+                getAppContext().put(key, value);
+            }
+            public void remove(Object key) {
+                getAppContext().remove(key);
+            }
+            public boolean isDisposed() {
+                return getAppContext().isDisposed();
+            }
+            public boolean isMainAppContext() {
+                return (numAppContexts == 1);
+            }
+            public Object getContext() {
+                return getAppContext();
+            }
+            public Object getExecutionContext() {
+                return getExecutionAppContext();
+            }
+            public Object get(Object context, Object key) {
+                return ((AppContext)context).get(key);
+            }
+            public void put(Object context, Object key, Object value) {
+                ((AppContext)context).put(key, value);
+            }
+            public void remove(Object context, Object key) {
+                ((AppContext)context).remove(key);
+            }
+        });
+    }
 }
 
 final class MostRecentKeyValue {
--- jdk/src/share/classes/sun/awt/EmbeddedFrame.java	2012-08-10 10:28:23.000000000 -0700
+++ jdk/src/share/classes/sun/awt/EmbeddedFrame.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,12 +29,6 @@
 import java.awt.event.*;
 import java.awt.image.*;
 import java.awt.peer.*;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Field;
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeEvent;
 import java.util.Set;
@@ -63,8 +57,6 @@
                           implements KeyEventDispatcher, PropertyChangeListener {
 
     private boolean isCursorAllowed = true;
-    private static Field fieldPeer;
-    private static Field currentCycleRoot;
     private boolean supportsXEmbed = false;
     private KeyboardFocusManager appletKFM;
     // JDK 1.1 compatibility
@@ -208,39 +200,8 @@
      */
     public boolean dispatchKeyEvent(KeyEvent e) {
 
-        // We can't guarantee that this is called on the same AppContext as EmbeddedFrame
-        // belongs to. That's why we can't use public methods to find current focus cycle
-        // root. Instead, we access KFM's private field directly.
-        if (currentCycleRoot == null) {
-            currentCycleRoot = (Field)AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    try {
-                        Field unaccessibleRoot = KeyboardFocusManager.class.
-                                                     getDeclaredField("currentFocusCycleRoot");
-                        if (unaccessibleRoot != null) {
-                            unaccessibleRoot.setAccessible(true);
-                        }
-                        return unaccessibleRoot;
-                    } catch (NoSuchFieldException e1) {
-                        assert false;
-                    } catch (SecurityException e2) {
-                        assert false;
-                    }
-                    return null;
-                }
-            });
-        }
-
-        Container currentRoot = null;
-        if (currentCycleRoot != null) {
-            try {
-                // The field is static, so we can pass null to Field.get() as the argument.
-                currentRoot = (Container)currentCycleRoot.get(null);
-            } catch (IllegalAccessException e3) {
-                // This is impossible: currentCycleRoot would be null if setAccessible failed.
-                assert false;
-            }
-        }
+        Container currentRoot = AWTAccessor.getKeyboardFocusManagerAccessor()
+                                    .getCurrentFocusCycleRoot();
 
         // if we are not in EmbeddedFrame's cycle, we should not try to leave.
         if (this != currentRoot) {
@@ -381,32 +342,8 @@
     }
 
     protected  void setPeer(final ComponentPeer p){
-        if (fieldPeer == null) {
-            fieldPeer = (Field)AccessController.doPrivileged(new PrivilegedAction() {
-                    public Object run() {
-                        try {
-                            Field lnkPeer = Component.class.getDeclaredField("peer");
-                            if (lnkPeer != null) {
-                                lnkPeer.setAccessible(true);
-                            }
-                            return lnkPeer;
-                        } catch (NoSuchFieldException e) {
-                            assert false;
-                        } catch (SecurityException e) {
-                            assert false;
-                        }
-                        return null;
-                    }//run
-                });
-        }
-        try{
-            if (fieldPeer !=null){
-                fieldPeer.set(EmbeddedFrame.this, p);
-            }
-        } catch (IllegalAccessException e) {
-            assert false;
-        }
-    };  //setPeer method ends
+        AWTAccessor.getComponentAccessor().setPeer(EmbeddedFrame.this, p);
+    };
 
     /**
      * Synthesize native message to activate or deactivate EmbeddedFrame window
@@ -595,7 +532,7 @@
         public void toBack() {}
         public void updateFocusableWindowState() {}
         public void updateAlwaysOnTop() {}
-        public void setAlwaysOnTop(boolean alwaysOnTop) {}
+        public void updateAlwaysOnTopState() {}
         public Component getGlobalHeavyweightFocusOwner() { return null; }
         public void setBoundsPrivate(int x, int y, int width, int height) {
             setBounds(x, y, width, height, SET_BOUNDS);
--- jdk/src/share/classes/sun/awt/FontConfiguration.java	2012-08-10 10:28:23.000000000 -0700
+++ jdk/src/share/classes/sun/awt/FontConfiguration.java	2013-05-05 09:38:29.000000000 -0700
@@ -1146,7 +1146,7 @@
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!FontUtilities.isLinux) {
+        if (!FontUtilities.isLinux || FontUtilities.isBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
--- jdk/src/share/classes/sun/awt/OSInfo.java	2012-08-10 10:28:24.000000000 -0700
+++ jdk/src/share/classes/sun/awt/OSInfo.java	2013-05-05 09:38:29.000000000 -0700
@@ -39,6 +39,7 @@
         WINDOWS,
         LINUX,
         SOLARIS,
+        BSD,
         MACOSX,
         UNKNOWN
     }
@@ -101,6 +102,10 @@
                 return SOLARIS;
             }
 
+            if (osName.contains("BSD")) {
+                return BSD;
+            }
+
             if (osName.contains("OS X")) {
                 return MACOSX;
             }
--- jdk/src/share/classes/sun/awt/SunToolkit.java	2012-08-10 10:28:24.000000000 -0700
+++ jdk/src/share/classes/sun/awt/SunToolkit.java	2013-05-05 09:38:29.000000000 -0700
@@ -51,14 +51,8 @@
 import sun.awt.image.*;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 
 public abstract class SunToolkit extends Toolkit
     implements WindowClosingSupport, WindowClosingListener,
@@ -80,7 +74,6 @@
      */
     public static final int GRAB_EVENT_MASK = 0x80000000;
 
-    private static Method  wakeupMethod;
     /* The key to put()/get() the PostEventQueue into/from the AppContext.
      */
     private static final String POST_EVENT_QUEUE_KEY = "PostEventQueue";
@@ -294,52 +287,8 @@
         return appContext;
     }
 
-    public static Field getField(final Class klass, final String fieldName) {
-        return AccessController.doPrivileged(new PrivilegedAction<Field>() {
-            public Field run() {
-                try {
-                    Field field = klass.getDeclaredField(fieldName);
-                    assert (field != null);
-                    field.setAccessible(true);
-                    return field;
-                } catch (SecurityException e) {
-                    assert false;
-                } catch (NoSuchFieldException e) {
-                    assert false;
-                }
-                return null;
-            }//run
-        });
-    }
-
     static void wakeupEventQueue(EventQueue q, boolean isShutdown){
-        if (wakeupMethod == null){
-            wakeupMethod = (Method)AccessController.doPrivileged(new PrivilegedAction(){
-                    public Object run(){
-                        try {
-                            Method method  = EventQueue.class.getDeclaredMethod("wakeup",new Class [] {Boolean.TYPE} );
-                            if (method != null) {
-                                method.setAccessible(true);
-                            }
-                            return method;
-                        } catch (NoSuchMethodException e) {
-                            assert false;
-                        } catch (SecurityException e) {
-                            assert false;
-                        }
-                        return null;
-                    }//run
-                });
-        }
-        try{
-            if (wakeupMethod != null){
-                wakeupMethod.invoke(q, new Object[]{Boolean.valueOf(isShutdown)});
-            }
-        } catch (InvocationTargetException e){
-            assert false;
-        } catch (IllegalAccessException e) {
-            assert false;
-        }
+        AWTAccessor.getEventQueueAccessor().wakeup(q, isShutdown);
     }
 
     /*
@@ -513,6 +462,19 @@
         if (event == null) {
             throw new NullPointerException();
         }
+
+        AWTAccessor.SequencedEventAccessor sea = AWTAccessor.getSequencedEventAccessor();
+        if (sea != null && sea.isSequencedEvent(event)) {
+            AWTEvent nested = sea.getNested(event);
+            if (nested.getID() == WindowEvent.WINDOW_LOST_FOCUS &&
+                nested instanceof TimedWindowEvent)
+            {
+                TimedWindowEvent twe = (TimedWindowEvent)nested;
+                ((SunToolkit)Toolkit.getDefaultToolkit()).
+                    setWindowDeactivationTime((Window)twe.getSource(), twe.getWhen());
+            }
+        }
+
         // All events posted via this method are system-generated.
         // Placing the following call here reduces considerably the
         // number of places throughout the toolkit that would
@@ -556,15 +518,19 @@
             // Don't call flushPendingEvents() recursively
             if (!isFlushingPendingEvents) {
                 isFlushingPendingEvents = true;
-                AppContext appContext = AppContext.getAppContext();
-                PostEventQueue postEventQueue =
-                    (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
-                if (postEventQueue != null) {
-                    postEventQueue.flush();
+                try {
+                    AppContext appContext = AppContext.getAppContext();
+                    PostEventQueue postEventQueue =
+                        (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
+                    if (postEventQueue != null) {
+                        postEventQueue.flush();
+                    }
+                }
+                finally {
+                    isFlushingPendingEvents = false;
                 }
             }
         } finally {
-            isFlushingPendingEvents = false;
             flushLock.unlock();
         }
     }
@@ -1455,22 +1421,6 @@
             || comp instanceof Window);
     }
 
-    public static Method getMethod(final Class clz, final String methodName, final Class[] params) {
-        Method res = null;
-        try {
-            res = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {
-                    public Method run() throws Exception {
-                        Method m = clz.getDeclaredMethod(methodName, params);
-                        m.setAccessible(true);
-                        return m;
-                    }
-                });
-        } catch (PrivilegedActionException ex) {
-            ex.printStackTrace();
-        }
-        return res;
-    }
-
     public static class OperationTimedOut extends RuntimeException {
         public OperationTimedOut(String msg) {
             super(msg);
@@ -1613,21 +1563,9 @@
     private boolean queueEmpty = false;
     private final Object waitLock = "Wait Lock";
 
-    static Method eqNoEvents;
-
     private boolean isEQEmpty() {
         EventQueue queue = getSystemEventQueueImpl();
-        synchronized(SunToolkit.class) {
-            if (eqNoEvents == null) {
-                eqNoEvents = getMethod(java.awt.EventQueue.class, "noEvents", null);
-            }
-        }
-        try {
-            return (Boolean)eqNoEvents.invoke(queue);
-        } catch (Exception e) {
-            e.printStackTrace();
-            return false;
-        }
+        return AWTAccessor.getEventQueueAccessor().noEvents(queue);
     }
 
     /**
@@ -1882,20 +1820,14 @@
      * consumeNextKeyTyped() method is not currently used,
      * however Swing could use it in the future.
      */
-    private static Method consumeNextKeyTypedMethod = null;
     public static synchronized void consumeNextKeyTyped(KeyEvent keyEvent) {
-        if (consumeNextKeyTypedMethod == null) {
-            consumeNextKeyTypedMethod = getMethod(DefaultKeyboardFocusManager.class,
-                                                  "consumeNextKeyTyped",
-                                                  new Class[] {KeyEvent.class});
-        }
         try {
-            consumeNextKeyTypedMethod.invoke(KeyboardFocusManager.getCurrentKeyboardFocusManager(),
-                                             keyEvent);
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
-        } catch (InvocationTargetException ite) {
-            ite.printStackTrace();
+            AWTAccessor.getDefaultKeyboardFocusManagerAccessor().consumeNextKeyTyped(
+                (DefaultKeyboardFocusManager)KeyboardFocusManager.
+                    getCurrentKeyboardFocusManager(),
+                keyEvent);
+        } catch (ClassCastException cce) {
+             cce.printStackTrace();
         }
     }
 
@@ -1915,25 +1847,6 @@
         return (Window)comp;
     }
 
-    /**
-     * Returns the value of the system property indicated by the specified key.
-     */
-    public static String getSystemProperty(final String key) {
-        return (String)AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(key);
-                }
-            });
-    }
-
-    /**
-     * Returns the boolean value of the system property indicated by the specified key.
-     */
-    protected static Boolean getBooleanSystemProperty(String key) {
-        return Boolean.valueOf(AccessController.
-                   doPrivileged(new GetBooleanAction(key)));
-    }
-
     private static Boolean sunAwtDisableMixing = null;
 
     /**
@@ -1942,7 +1855,8 @@
      */
     public synchronized static boolean getSunAwtDisableMixing() {
         if (sunAwtDisableMixing == null) {
-            sunAwtDisableMixing = getBooleanSystemProperty("sun.awt.disableMixing");
+            sunAwtDisableMixing = AccessController.doPrivileged(
+                                      new GetBooleanAction("sun.awt.disableMixing"));
         }
         return sunAwtDisableMixing.booleanValue();
     }
@@ -1956,6 +1870,28 @@
         return false;
     }
 
+    private static final Object DEACTIVATION_TIMES_MAP_KEY = new Object();
+
+    public synchronized void setWindowDeactivationTime(Window w, long time) {
+        AppContext ctx = getAppContext(w);
+        WeakHashMap<Window, Long> map = (WeakHashMap<Window, Long>)ctx.get(DEACTIVATION_TIMES_MAP_KEY);
+        if (map == null) {
+            map = new WeakHashMap<Window, Long>();
+            ctx.put(DEACTIVATION_TIMES_MAP_KEY, map);
+        }
+        map.put(w, time);
+    }
+
+    public synchronized long getWindowDeactivationTime(Window w) {
+        AppContext ctx = getAppContext(w);
+        WeakHashMap<Window, Long> map = (WeakHashMap<Window, Long>)ctx.get(DEACTIVATION_TIMES_MAP_KEY);
+        if (map == null) {
+            return -1;
+        }
+        Long time = map.get(w);
+        return time == null ? -1 : time;
+    }
+
     // Cosntant alpha
     public boolean isWindowOpacitySupported() {
         return false;
@@ -1976,13 +1912,6 @@
     }
 
     /**
-     * Returns true if swing backbuffer should be translucent.
-     */
-    public boolean isSwingBackbufferTranslucencySupported() {
-        return false;
-    }
-
-    /**
      * Returns whether or not a containing top level window for the passed
      * component is
      * {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}.
--- jdk/src/share/classes/sun/awt/TextureSizeConstraining.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/sun/awt/TextureSizeConstraining.java	2013-05-05 09:38:29.000000000 -0700
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.awt;
+
+/**
+ * A GraphicsConfiguration implements the TextureSizeConstraining
+ * interface to indicate that it imposes certain limitations on the
+ * maximum size of supported textures.
+ */
+public interface TextureSizeConstraining {
+
+    /**
+     * Returns the maximum width of any texture image.
+     */
+    public int getMaxTextureWidth();
+
+    /**
+     * Returns the maximum height of any texture image.
+     */
+    public int getMaxTextureHeight();
+
+}
--- jdk/src/share/classes/sun/awt/TimedWindowEvent.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/sun/awt/TimedWindowEvent.java	2013-05-05 09:38:29.000000000 -0700
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.awt;
+
+import java.awt.event.WindowEvent;
+import java.awt.Window;
+
+public class TimedWindowEvent extends WindowEvent {
+
+    private long time;
+
+    public long getWhen() {
+        return time;
+    }
+
+    public TimedWindowEvent(Window source, int id, Window opposite, long time) {
+        super(source, id, opposite);
+        this.time = time;
+    }
+
+    public TimedWindowEvent(Window source, int id, Window opposite,
+                            int oldState, int newState, long time)
+    {
+        super(source, id, opposite, oldState, newState);
+        this.time = time;
+    }
+}
+
--- jdk/src/share/classes/sun/awt/datatransfer/TransferableProxy.java	2012-08-10 10:28:25.000000000 -0700
+++ jdk/src/share/classes/sun/awt/datatransfer/TransferableProxy.java	2013-05-05 09:38:29.000000000 -0700
@@ -102,11 +102,11 @@
     protected final boolean isLocal;
 }
 
-class ClassLoaderObjectOutputStream extends ObjectOutputStream {
+final class ClassLoaderObjectOutputStream extends ObjectOutputStream {
     private final Map<Set<String>, ClassLoader> map =
         new HashMap<Set<String>, ClassLoader>();
 
-    public ClassLoaderObjectOutputStream(OutputStream os) throws IOException {
+    ClassLoaderObjectOutputStream(OutputStream os) throws IOException {
         super(os);
     }
 
@@ -140,15 +140,15 @@
         map.put(s, classLoader);
     }
 
-    public Map<Set<String>, ClassLoader> getClassLoaderMap() {
+    Map<Set<String>, ClassLoader> getClassLoaderMap() {
         return new HashMap(map);
     }
 }
 
-class ClassLoaderObjectInputStream extends ObjectInputStream {
+final class ClassLoaderObjectInputStream extends ObjectInputStream {
     private final Map<Set<String>, ClassLoader> map;
 
-    public ClassLoaderObjectInputStream(InputStream is,
+    ClassLoaderObjectInputStream(InputStream is,
                                         Map<Set<String>, ClassLoader> map)
       throws IOException {
         super(is);
@@ -166,8 +166,11 @@
         s.add(className);
 
         ClassLoader classLoader = map.get(s);
-
-        return Class.forName(className, false, classLoader);
+        if (classLoader != null) {
+            return Class.forName(className, false, classLoader);
+        } else {
+            return super.resolveClass(classDesc);
+        }
     }
 
     protected Class<?> resolveProxyClass(String[] interfaces)
@@ -179,6 +182,9 @@
         }
 
         ClassLoader classLoader = map.get(s);
+        if (classLoader == null) {
+            return super.resolveProxyClass(interfaces);
+        }
 
         // The code below is mostly copied from the superclass.
         ClassLoader nonPublicLoader = null;
--- jdk/src/share/classes/sun/awt/image/ByteComponentRaster.java	2012-08-10 10:28:26.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/ByteComponentRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -198,7 +198,7 @@
         }
         this.bandOffset = this.dataOffsets[0];
 
-        verify(false);
+        verify();
     }
 
     /**
@@ -857,38 +857,78 @@
     }
 
     /**
-     * Verify that the layout parameters are consistent with
-     * the data.  If strictCheck
-     * is false, this method will check for ArrayIndexOutOfBounds conditions.  If
-     * strictCheck is true, this method will check for additional error
-     * conditions such as line wraparound (width of a line greater than
-     * the scanline stride).
-     * @return   String   Error string, if the layout is incompatible with
-     *                    the data.  Otherwise returns null.
-     */
-    private void verify (boolean strictCheck) {
-        // Make sure data for Raster is in a legal range
-        for (int i=0; i < dataOffsets.length; i++) {
+     * Verify that the layout parameters are consistent with the data.
+     *
+     * The method verifies whether scanline stride and pixel stride do not
+     * cause an integer overflow during calculation of a position of the pixel
+     * in data buffer. It also verifies whether the data buffer has enough data
+     *  to correspond the raster layout attributes.
+     *
+     * @throws RasterFormatException if an integer overflow is detected,
+     * or if data buffer has not enough capacity.
+     */
+    protected final void verify() {
+        /* Need to re-verify the dimensions since a sample model may be
+         * specified to the constructor
+         */
+        if (width <= 0 || height <= 0 ||
+            height > (Integer.MAX_VALUE / width))
+        {
+            throw new RasterFormatException("Invalid raster dimension");
+        }
+
+        for (int i = 0; i < dataOffsets.length; i++) {
             if (dataOffsets[i] < 0) {
-                throw new RasterFormatException("Data offsets for band "+i+
-                                                "("+dataOffsets[i]+
-                                                ") must be >= 0");
+                throw new RasterFormatException("Data offsets for band " + i
+                            + "(" + dataOffsets[i]
+                            + ") must be >= 0");
             }
         }
 
         int maxSize = 0;
         int size;
 
-        for (int i=0; i < numDataElements; i++) {
-            size = (height-1)*scanlineStride + (width-1)*pixelStride +
-                dataOffsets[i];
+        // we can be sure that width and height are greater than 0
+        if (scanlineStride < 0 ||
+            scanlineStride > (Integer.MAX_VALUE / height))
+        {
+            // integer overflow
+            throw new RasterFormatException("Incorrect scanline stride: "
+                    + scanlineStride);
+        }
+        int lastScanOffset = (height - 1) * scanlineStride;
+
+        if (pixelStride < 0 ||
+            pixelStride > (Integer.MAX_VALUE / width))
+        {
+            // integer overflow
+            throw new RasterFormatException("Incorrect pixel stride: "
+                    + pixelStride);
+        }
+        int lastPixelOffset = (width - 1) * pixelStride;
+
+        if (lastPixelOffset > (Integer.MAX_VALUE - lastScanOffset)) {
+            // integer overflow
+            throw new RasterFormatException("Incorrect raster attributes");
+        }
+        lastPixelOffset += lastScanOffset;
+
+        for (int i = 0; i < numDataElements; i++) {
+            if (dataOffsets[i] > (Integer.MAX_VALUE - lastPixelOffset)) {
+                throw new RasterFormatException("Incorrect band offset: "
+                            + dataOffsets[i]);
+
+            }
+
+            size = lastPixelOffset + dataOffsets[i];
+
             if (size > maxSize) {
                 maxSize = size;
             }
         }
         if (data.length < maxSize) {
-            throw new RasterFormatException("Data array too small (should be "+
-                                          maxSize+" )");
+            throw new RasterFormatException("Data array too small (should be "
+                    + maxSize + " )");
         }
     }
 
--- jdk/src/share/classes/sun/awt/image/ByteInterleavedRaster.java	2012-08-10 10:28:26.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/ByteInterleavedRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -250,7 +250,7 @@
             }
         }
 
-        verify(false);
+        verify();
     }
 
     /**
@@ -1292,33 +1292,6 @@
         return createCompatibleWritableRaster(width,height);
     }
 
-    /**
-     * Verify that the layout parameters are consistent with
-     * the data.  If strictCheck
-     * is false, this method will check for ArrayIndexOutOfBounds conditions.  If
-     * strictCheck is true, this method will check for additional error
-     * conditions such as line wraparound (width of a line greater than
-     * the scanline stride).
-     * @return   String   Error string, if the layout is incompatible with
-     *                    the data.  Otherwise returns null.
-     */
-    private void verify (boolean strictCheck) {
-        int maxSize = 0;
-        int size;
-
-        for (int i=0; i < numDataElements; i++) {
-            size = (height-1)*scanlineStride + (width-1)*pixelStride +
-                dataOffsets[i];
-            if (size > maxSize) {
-                maxSize = size;
-            }
-        }
-        if (data.length < maxSize) {
-            throw new RasterFormatException("Data array too small (should be "+
-                                          maxSize+" )");
-        }
-    }
-
     public String toString() {
         return new String ("ByteInterleavedRaster: width = "+width+" height = "
                            + height
--- jdk/src/share/classes/sun/awt/image/BytePackedRaster.java	2012-08-10 10:28:26.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/BytePackedRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -1368,11 +1368,35 @@
             throw new RasterFormatException("Data offsets must be >= 0");
         }
 
+        /* Need to re-verify the dimensions since a sample model may be
+         * specified to the constructor
+         */
+        if (width <= 0 || height <= 0 ||
+            height > (Integer.MAX_VALUE / width))
+        {
+            throw new RasterFormatException("Invalid raster dimension");
+        }
+
+
+        /*
+         * pixelBitstride was verified in constructor, so just make
+         * sure that it is safe to multiply it by width.
+         */
+        if ((width - 1) > Integer.MAX_VALUE / pixelBitStride) {
+            throw new RasterFormatException("Invalid raster dimension");
+        }
+
+        if (scanlineStride < 0 ||
+            scanlineStride > (Integer.MAX_VALUE / height))
+        {
+            throw new RasterFormatException("Invalid scanline stride");
+        }
+
         int lastbit = (dataBitOffset
                        + (height-1) * scanlineStride * 8
                        + (width-1) * pixelBitStride
                        + pixelBitStride - 1);
-        if (lastbit / 8 >= data.length) {
+        if (lastbit < 0 || lastbit / 8 >= data.length) {
             throw new RasterFormatException("raster dimensions overflow " +
                                             "array bounds");
         }
--- jdk/src/share/classes/sun/awt/image/ImageRepresentation.java	2012-08-10 10:28:26.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/ImageRepresentation.java	2013-05-05 09:38:29.000000000 -0700
@@ -333,10 +333,10 @@
         hints = h;
     }
 
-    private native void setICMpixels(int x, int y, int w, int h, int[] lut,
+    private native boolean setICMpixels(int x, int y, int w, int h, int[] lut,
                                     byte[] pix, int off, int scansize,
                                     IntegerComponentRaster ict);
-    private native int setDiffICM(int x, int y, int w, int h, int[] lut,
+    private native boolean setDiffICM(int x, int y, int w, int h, int[] lut,
                                  int transPix, int numLut, IndexColorModel icm,
                                  byte[] pix, int off, int scansize,
                                  ByteComponentRaster bct, int chanOff);
@@ -426,10 +426,10 @@
                 IndexColorModel icm = (IndexColorModel) model;
                 ByteComponentRaster bct = (ByteComponentRaster) biRaster;
                 int numlut = numSrcLUT;
-                if (setDiffICM(x, y, w, h, srcLUT, srcLUTtransIndex,
+                if (!setDiffICM(x, y, w, h, srcLUT, srcLUTtransIndex,
                                numSrcLUT, icm,
                                pix, off, scansize, bct,
-                               bct.getDataOffset(0)) == 0) {
+                               bct.getDataOffset(0))) {
                     convertToRGB();
                 }
                 else {
@@ -470,9 +470,14 @@
                     if (s_useNative) {
                         // Note that setICMpixels modifies the raster directly
                         // so we must mark it as changed afterwards
-                        setICMpixels(x, y, w, h, srcLUT, pix, off, scansize,
-                                     iraster);
-                        iraster.markDirty();
+                        if (setICMpixels(x, y, w, h, srcLUT, pix, off, scansize,
+                                     iraster))
+                        {
+                            iraster.markDirty();
+                        } else {
+                            abort();
+                            return;
+                        }
                     }
                     else {
                         int[] storage = new int[w*h];
--- jdk/src/share/classes/sun/awt/image/IntegerComponentRaster.java	2012-08-10 10:28:26.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/IntegerComponentRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -208,7 +208,7 @@
                                             " SinglePixelPackedSampleModel");
         }
 
-        verify(false);
+        verify();
     }
 
 
@@ -629,16 +629,26 @@
     }
 
     /**
-     * Verify that the layout parameters are consistent with
-     * the data.  If strictCheck
-     * is false, this method will check for ArrayIndexOutOfBounds conditions.  If
-     * strictCheck is true, this method will check for additional error
-     * conditions such as line wraparound (width of a line greater than
-     * the scanline stride).
-     * @return   String   Error string, if the layout is incompatible with
-     *                    the data.  Otherwise returns null.
-     */
-    private void verify (boolean strictCheck) {
+     * Verify that the layout parameters are consistent with the data.
+     *
+     * The method verifies whether scanline stride and pixel stride do not
+     * cause an integer overflow during calculation of a position of the pixel
+     * in data buffer. It also verifies whether the data buffer has enough data
+     *  to correspond the raster layout attributes.
+     *
+     * @throws RasterFormatException if an integer overflow is detected,
+     * or if data buffer has not enough capacity.
+     */
+    protected final void verify() {
+        /* Need to re-verify the dimensions since a sample model may be
+         * specified to the constructor
+         */
+        if (width <= 0 || height <= 0 ||
+            height > (Integer.MAX_VALUE / width))
+        {
+            throw new RasterFormatException("Invalid raster dimension");
+        }
+
         if (dataOffsets[0] < 0) {
             throw new RasterFormatException("Data offset ("+dataOffsets[0]+
                                             ") must be >= 0");
@@ -647,17 +657,46 @@
         int maxSize = 0;
         int size;
 
-        for (int i=0; i < numDataElements; i++) {
-            size = (height-1)*scanlineStride + (width-1)*pixelStride +
-                dataOffsets[i];
+        // we can be sure that width and height are greater than 0
+        if (scanlineStride < 0 ||
+            scanlineStride > (Integer.MAX_VALUE / height))
+        {
+            // integer overflow
+            throw new RasterFormatException("Incorrect scanline stride: "
+                    + scanlineStride);
+        }
+        int lastScanOffset = (height - 1) * scanlineStride;
+
+        if (pixelStride < 0 ||
+            pixelStride > (Integer.MAX_VALUE / width))
+        {
+            // integer overflow
+            throw new RasterFormatException("Incorrect pixel stride: "
+                    + pixelStride);
+        }
+        int lastPixelOffset = (width - 1) * pixelStride;
+
+        if (lastPixelOffset > (Integer.MAX_VALUE - lastScanOffset)) {
+            // integer overflow
+            throw new RasterFormatException("Incorrect raster attributes");
+        }
+        lastPixelOffset += lastScanOffset;
+
+        for (int i = 0; i < numDataElements; i++) {
+            if (dataOffsets[i] > (Integer.MAX_VALUE - lastPixelOffset)) {
+                throw new RasterFormatException("Incorrect band offset: "
+                            + dataOffsets[i]);
+            }
+
+            size = lastPixelOffset + dataOffsets[i];
+
             if (size > maxSize) {
                 maxSize = size;
             }
         }
         if (data.length < maxSize) {
-            throw new RasterFormatException("Data array too small (should be "+
-                                          maxSize
-                                          +" but is "+data.length+" )");
+            throw new RasterFormatException("Data array too small (should be "
+                    + maxSize + " )");
         }
     }
 
--- jdk/src/share/classes/sun/awt/image/IntegerInterleavedRaster.java	2012-08-10 10:28:26.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/IntegerInterleavedRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -151,7 +151,7 @@
             throw new RasterFormatException("IntegerInterleavedRasters must have"+
                                             " SinglePixelPackedSampleModel");
         }
-        verify(false);
+        verify();
     }
 
 
@@ -540,31 +540,6 @@
         return createCompatibleWritableRaster(width,height);
     }
 
-    /**
-     * Verify that the layout parameters are consistent with
-     * the data.  If strictCheck
-     * is false, this method will check for ArrayIndexOutOfBounds conditions.  If
-     * strictCheck is true, this method will check for additional error
-     * conditions such as line wraparound (width of a line greater than
-     * the scanline stride).
-     * @return   String   Error string, if the layout is incompatible with
-     *                    the data.  Otherwise returns null.
-     */
-    private void verify (boolean strictCheck) {
-        int maxSize = 0;
-        int size;
-
-        size = (height-1)*scanlineStride + (width-1) + dataOffsets[0];
-        if (size > maxSize) {
-            maxSize = size;
-        }
-        if (data.length < maxSize) {
-            throw new RasterFormatException("Data array too small (should be "+
-                                          maxSize
-                                          +" but is "+data.length+" )");
-        }
-    }
-
     public String toString() {
         return new String ("IntegerInterleavedRaster: width = "+width
                            +" height = " + height
--- jdk/src/share/classes/sun/awt/image/ShortComponentRaster.java	2012-08-10 10:28:27.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/ShortComponentRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -198,7 +198,7 @@
         }
         this.bandOffset = this.dataOffsets[0];
 
-        verify(false);
+        verify();
     }
 
     /**
@@ -791,38 +791,77 @@
     }
 
     /**
-     * Verify that the layout parameters are consistent with
-     * the data.  If strictCheck
-     * is false, this method will check for ArrayIndexOutOfBounds conditions.  If
-     * strictCheck is true, this method will check for additional error
-     * conditions such as line wraparound (width of a line greater than
-     * the scanline stride).
-     * @return   String   Error string, if the layout is incompatible with
-     *                    the data.  Otherwise returns null.
-     */
-    private void verify (boolean strictCheck) {
-        // Make sure data for Raster is in a legal range
-        for (int i=0; i < dataOffsets.length; i++) {
+     * Verify that the layout parameters are consistent with the data.
+     *
+     * The method verifies whether scanline stride and pixel stride do not
+     * cause an integer overflow during calculation of a position of the pixel
+     * in data buffer. It also verifies whether the data buffer has enough data
+     *  to correspond the raster layout attributes.
+     *
+     * @throws RasterFormatException if an integer overflow is detected,
+     * or if data buffer has not enough capacity.
+     */
+    protected final void verify() {
+        /* Need to re-verify the dimensions since a sample model may be
+         * specified to the constructor
+         */
+        if (width <= 0 || height <= 0 ||
+            height > (Integer.MAX_VALUE / width))
+        {
+            throw new RasterFormatException("Invalid raster dimension");
+        }
+
+        for (int i = 0; i < dataOffsets.length; i++) {
             if (dataOffsets[i] < 0) {
-                throw new RasterFormatException("Data offsets for band "+i+
-                                                "("+dataOffsets[i]+
-                                                ") must be >= 0");
+                throw new RasterFormatException("Data offsets for band " + i
+                            + "(" + dataOffsets[i]
+                            + ") must be >= 0");
             }
         }
 
         int maxSize = 0;
         int size;
 
-        for (int i=0; i < numDataElements; i++) {
-            size = (height-1)*scanlineStride + (width-1)*pixelStride +
-                dataOffsets[i];
+        // we can be sure that width and height are greater than 0
+        if (scanlineStride < 0 ||
+            scanlineStride > (Integer.MAX_VALUE / height))
+        {
+            // integer overflow
+            throw new RasterFormatException("Incorrect scanline stride: "
+                    + scanlineStride);
+        }
+        int lastScanOffset = (height - 1) * scanlineStride;
+
+        if (pixelStride < 0 ||
+            pixelStride > (Integer.MAX_VALUE / width))
+        {
+            // integer overflow
+            throw new RasterFormatException("Incorrect pixel stride: "
+                    + pixelStride);
+        }
+        int lastPixelOffset = (width - 1) * pixelStride;
+
+        if (lastPixelOffset > (Integer.MAX_VALUE - lastScanOffset)) {
+            // integer overflow
+            throw new RasterFormatException("Incorrect raster attributes");
+        }
+        lastPixelOffset += lastScanOffset;
+
+        for (int i = 0; i < numDataElements; i++) {
+            if (dataOffsets[i] > (Integer.MAX_VALUE - lastPixelOffset)) {
+                throw new RasterFormatException("Incorrect band offset: "
+                            + dataOffsets[i]);
+            }
+
+            size = lastPixelOffset + dataOffsets[i];
+
             if (size > maxSize) {
                 maxSize = size;
             }
         }
         if (data.length < maxSize) {
-            throw new RasterFormatException("Data array too small (should be "+
-                                          maxSize+" )");
+            throw new RasterFormatException("Data array too small (should be "
+                    + maxSize + " )");
         }
     }
 
--- jdk/src/share/classes/sun/awt/image/ShortInterleavedRaster.java	2012-08-10 10:28:27.000000000 -0700
+++ jdk/src/share/classes/sun/awt/image/ShortInterleavedRaster.java	2013-05-05 09:38:29.000000000 -0700
@@ -171,7 +171,7 @@
               sampleModel);
         }
         this.bandOffset = this.dataOffsets[0];
-        verify(false);
+        verify();
     }
 
     /**
@@ -762,33 +762,6 @@
         return createCompatibleWritableRaster(width,height);
     }
 
-    /**
-     * Verify that the layout parameters are consistent with
-     * the data.  If strictCheck
-     * is false, this method will check for ArrayIndexOutOfBounds conditions.  If
-     * strictCheck is true, this method will check for additional error
-     * conditions such as line wraparound (width of a line greater than
-     * the scanline stride).
-     * @return   String   Error string, if the layout is incompatible with
-     *                    the data.  Otherwise returns null.
-     */
-    private void verify (boolean strictCheck) {
-        int maxSize = 0;
-        int size;
-
-        for (int i=0; i < numDataElements; i++) {
-            size = (height-1)*scanlineStride + (width-1)*pixelStride +
-                dataOffsets[i];
-            if (size > maxSize) {
-                maxSize = size;
-            }
-        }
-        if (data.length < maxSize) {
-            throw new RasterFormatException("Data array too small (should be "+
-                                          maxSize+" )");
-        }
-    }
-
     public String toString() {
         return new String ("ShortInterleavedRaster: width = "+width
                            +" height = " + height
--- jdk/src/share/classes/sun/beans/editors/BooleanEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/BooleanEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,51 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "boolean" type.
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class BooleanEditor extends PropertyEditorSupport {
-
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value.toString()
-                : "null";
-    }
-
-    public String getAsText() {
-        Object value = getValue();
-        return (value instanceof Boolean)
-             ? getValidName((Boolean) value)
-             : null;
-    }
-
-    public void setAsText(String text) throws java.lang.IllegalArgumentException {
-        if (text == null) {
-            setValue(null);
-        } else if (isValidName(true, text)) {
-            setValue(Boolean.TRUE);
-        } else if (isValidName(false, text)) {
-            setValue(Boolean.FALSE);
-        } else {
-            throw new java.lang.IllegalArgumentException(text);
-        }
-    }
-
-    public String[] getTags() {
-        return new String[] {getValidName(true), getValidName(false)};
-    }
-
-    // the following method should be localized (4890258)
-
-    private String getValidName(boolean value) {
-        return value ? "True" : "False";
-    }
-
-    private boolean isValidName(boolean value, String name) {
-        return getValidName(value).equalsIgnoreCase(name);
-    }
+public class BooleanEditor extends com.sun.beans.editors.BooleanEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/ByteEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/ByteEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,23 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "byte" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class ByteEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? "((byte)" + value + ")"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Byte.decode(text));
-    }
-
+public class ByteEditor extends com.sun.beans.editors.ByteEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/ColorEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/ColorEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,190 +25,8 @@
 
 package sun.beans.editors;
 
-import java.awt.*;
-import java.beans.*;
-
-public class ColorEditor extends Panel implements PropertyEditor {
-    private static final long serialVersionUID = 1781257185164716054L;
-
-    public ColorEditor() {
-        setLayout(null);
-
-        ourWidth = hPad;
-
-        // Create a sample color block bordered in black
-        Panel p = new Panel();
-        p.setLayout(null);
-        p.setBackground(Color.black);
-        sample = new Canvas();
-        p.add(sample);
-        sample.reshape(2, 2, sampleWidth, sampleHeight);
-        add(p);
-        p.reshape(ourWidth, 2, sampleWidth+4, sampleHeight+4);
-        ourWidth += sampleWidth + 4 + hPad;
-
-        text = new TextField("", 14);
-        add(text);
-        text.reshape(ourWidth,0,100,30);
-        ourWidth += 100 + hPad;
-
-        choser = new Choice();
-        int active = 0;
-        for (int i = 0; i < colorNames.length; i++) {
-            choser.addItem(colorNames[i]);
-        }
-        add(choser);
-        choser.reshape(ourWidth,0,100,30);
-        ourWidth += 100 + hPad;
-
-        resize(ourWidth,40);
-    }
-
-    public void setValue(Object o) {
-        Color c = (Color)o;
-        changeColor(c);
-    }
-
-    public Dimension preferredSize() {
-        return new Dimension(ourWidth, 40);
-    }
-
-    public boolean keyUp(Event e, int key) {
-        if (e.target == text) {
-            try {
-                setAsText(text.getText());
-            } catch (IllegalArgumentException ex) {
-                // Quietly ignore.
-            }
-        }
-        return (false);
-    }
-
-    public void setAsText(String s) throws java.lang.IllegalArgumentException {
-        if (s == null) {
-            changeColor(null);
-            return;
-        }
-        int c1 = s.indexOf(',');
-        int c2 = s.indexOf(',', c1+1);
-        if (c1 < 0 || c2 < 0) {
-            // Invalid string.
-            throw new IllegalArgumentException(s);
-        }
-        try {
-            int r = Integer.parseInt(s.substring(0,c1));
-            int g = Integer.parseInt(s.substring(c1+1, c2));
-            int b = Integer.parseInt(s.substring(c2+1));
-            Color c = new Color(r,g,b);
-            changeColor(c);
-        } catch (Exception ex) {
-            throw new IllegalArgumentException(s);
-        }
-
-    }
-
-    public boolean action(Event e, Object arg) {
-        if (e.target == choser) {
-            changeColor(colors[choser.getSelectedIndex()]);
-        }
-        return false;
-    }
-
-    public String getJavaInitializationString() {
-        return (this.color != null)
-                ? "new java.awt.Color(" + this.color.getRGB() + ",true)"
-                : "null";
-    }
-
-
-    private void changeColor(Color c) {
-
-        if (c == null) {
-            this.color = null;
-            this.text.setText("");
-            return;
-        }
-
-        color = c;
-
-        text.setText("" + c.getRed() + "," + c.getGreen() + "," + c.getBlue());
-
-        int active = 0;
-        for (int i = 0; i < colorNames.length; i++) {
-            if (color.equals(colors[i])) {
-                active = i;
-            }
-        }
-        choser.select(active);
-
-        sample.setBackground(color);
-        sample.repaint();
-
-        support.firePropertyChange("", null, null);
-    }
-
-    public Object getValue() {
-        return color;
-    }
-
-    public boolean isPaintable() {
-        return true;
-    }
-
-    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
-        Color oldColor = gfx.getColor();
-        gfx.setColor(Color.black);
-        gfx.drawRect(box.x, box.y, box.width-3, box.height-3);
-        gfx.setColor(color);
-        gfx.fillRect(box.x+1, box.y+1, box.width-4, box.height-4);
-        gfx.setColor(oldColor);
-    }
-
-    public String getAsText() {
-        return (this.color != null)
-                ? this.color.getRed() + "," + this.color.getGreen() + "," + this.color.getBlue()
-                : null;
-    }
-
-    public String[] getTags() {
-        return null;
-    }
-
-    public java.awt.Component getCustomEditor() {
-        return this;
-    }
-
-    public boolean supportsCustomEditor() {
-        return true;
-    }
-
-    public void addPropertyChangeListener(PropertyChangeListener l) {
-        support.addPropertyChangeListener(l);
-    }
-
-    public void removePropertyChangeListener(PropertyChangeListener l) {
-        support.removePropertyChangeListener(l);
-    }
-
-
-    private String colorNames[] = { " ", "white", "lightGray", "gray", "darkGray",
-                        "black", "red", "pink", "orange",
-                        "yellow", "green", "magenta", "cyan",
-                        "blue"};
-    private Color colors[] = { null, Color.white, Color.lightGray, Color.gray, Color.darkGray,
-                        Color.black, Color.red, Color.pink, Color.orange,
-                        Color.yellow, Color.green, Color.magenta, Color.cyan,
-                        Color.blue};
-
-    private Canvas sample;
-    private int sampleHeight = 20;
-    private int sampleWidth = 40;
-    private int hPad = 5;
-    private int ourWidth;
-
-    private Color color;
-    private TextField text;
-    private Choice choser;
-
-    private PropertyChangeSupport support = new PropertyChangeSupport(this);
+/**
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
+ */
+public class ColorEditor extends com.sun.beans.editors.ColorEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/DoubleEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/DoubleEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,16 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "double" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class DoubleEditor extends NumberEditor {
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Double.valueOf(text));
-    }
-
+public class DoubleEditor extends com.sun.beans.editors.DoubleEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/EnumEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/EnumEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,122 +22,14 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-package sun.beans.editors;
 
-import java.awt.Component;
-import java.awt.Graphics;
-import java.awt.Rectangle;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.beans.PropertyEditor;
-import java.util.ArrayList;
-import java.util.List;
+package sun.beans.editors;
 
 /**
- * Property editor for java.lang.Enum subclasses.
- *
- * @see PropertyEditor
- *
- * @since 1.7
- *
- * @author Sergey A. Malenkov
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-public final class EnumEditor implements PropertyEditor {
-    private final List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
-
-    private final Class type;
-    private final String[] tags;
-
-    private Object value;
-
-    public EnumEditor( Class type ) {
-        Object[] values = type.getEnumConstants();
-        if ( values == null ) {
-            throw new IllegalArgumentException( "Unsupported " + type );
-        }
-        this.type = type;
-        this.tags = new String[values.length];
-        for ( int i = 0; i < values.length; i++ ) {
-            this.tags[i] = ( ( Enum )values[i] ).name();
-        }
-    }
-
-    public Object getValue() {
-        return this.value;
-    }
-
-    public void setValue( Object value ) {
-        if ( ( value != null ) && !this.type.isInstance( value ) ) {
-            throw new IllegalArgumentException( "Unsupported value: " + value );
-        }
-        Object oldValue;
-        PropertyChangeListener[] listeners;
-        synchronized ( this.listeners ) {
-            oldValue = this.value;
-            this.value = value;
-
-            if ( ( value == null ) ? oldValue == null : value.equals( oldValue ) ) {
-                return; // do not fire event if value is not changed
-            }
-            int size = this.listeners.size();
-            if ( size == 0 ) {
-                return; // do not fire event if there are no any listener
-            }
-            listeners = this.listeners.toArray( new PropertyChangeListener[size] );
-        }
-        PropertyChangeEvent event = new PropertyChangeEvent( this, null, oldValue, value );
-        for ( PropertyChangeListener listener : listeners ) {
-            listener.propertyChange( event );
-        }
-    }
-
-    public String getAsText() {
-        return ( this.value != null )
-                ? ( ( Enum )this.value ).name()
-                : null;
-    }
-
-    public void setAsText( String text ) {
-        setValue( ( text != null )
-                ? Enum.valueOf( this.type, text )
-                : null );
-    }
-
-    public String[] getTags() {
-        return this.tags.clone();
-    }
-
-    public String getJavaInitializationString() {
-        String name = getAsText();
-        return ( name != null )
-                ? this.type.getName() + '.' + name
-                : "null";
-    }
-
-    public boolean isPaintable() {
-        return false;
-    }
-
-    public void paintValue( Graphics gfx, Rectangle box ) {
-    }
-
-    public boolean supportsCustomEditor() {
-        return false;
-    }
-
-    public Component getCustomEditor() {
-        return null;
-    }
-
-    public void addPropertyChangeListener( PropertyChangeListener listener ) {
-        synchronized ( this.listeners ) {
-            this.listeners.add( listener );
-        }
-    }
-
-    public void removePropertyChangeListener( PropertyChangeListener listener ) {
-        synchronized ( this.listeners ) {
-            this.listeners.remove( listener );
-        }
+public class EnumEditor extends com.sun.beans.editors.EnumEditor {
+    public EnumEditor(Class type) {
+        super(type);
     }
 }
--- jdk/src/share/classes/sun/beans/editors/FloatEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/FloatEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,23 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "float" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class FloatEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value + "F"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Float.valueOf(text));
-    }
-
+public class FloatEditor extends com.sun.beans.editors.FloatEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/FontEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/FontEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,195 +25,8 @@
 
 package sun.beans.editors;
 
-import java.awt.*;
-import java.beans.*;
-
-public class FontEditor extends Panel implements java.beans.PropertyEditor {
-    private static final long serialVersionUID = 6732704486002715933L;
-
-    public FontEditor() {
-        setLayout(null);
-
-        toolkit = Toolkit.getDefaultToolkit();
-        fonts = toolkit.getFontList();
-
-        familyChoser = new Choice();
-        for (int i = 0; i < fonts.length; i++) {
-            familyChoser.addItem(fonts[i]);
-        }
-        add(familyChoser);
-        familyChoser.reshape(20, 5, 100, 30);
-
-        styleChoser = new Choice();
-        for (int i = 0; i < styleNames.length; i++) {
-            styleChoser.addItem(styleNames[i]);
-        }
-        add(styleChoser);
-        styleChoser.reshape(145, 5, 70, 30);
-
-        sizeChoser = new Choice();
-        for (int i = 0; i < pointSizes.length; i++) {
-            sizeChoser.addItem("" + pointSizes[i]);
-        }
-        add(sizeChoser);
-        sizeChoser.reshape(220, 5, 70, 30);
-
-        resize(300,40);
-    }
-
-
-    public Dimension preferredSize() {
-        return new Dimension(300, 40);
-    }
-
-    public void setValue(Object o) {
-        font = (Font) o;
-        if (this.font == null)
-            return;
-
-        changeFont(font);
-        // Update the current GUI choices.
-        for (int i = 0; i < fonts.length; i++) {
-            if (fonts[i].equals(font.getFamily())) {
-                familyChoser.select(i);
-                break;
-            }
-        }
-        for (int i = 0; i < styleNames.length; i++) {
-            if (font.getStyle() == styles[i]) {
-                styleChoser.select(i);
-                break;
-            }
-        }
-        for (int i = 0; i < pointSizes.length; i++) {
-            if (font.getSize() <= pointSizes[i]) {
-                sizeChoser.select(i);
-                break;
-            }
-        }
-    }
-
-    private void changeFont(Font f) {
-        font = f;
-        if (sample != null) {
-            remove(sample);
-        }
-        sample = new Label(sampleText);
-        sample.setFont(font);
-        add(sample);
-        Component p = getParent();
-        if (p != null) {
-            p.invalidate();
-            p.layout();
-        }
-        invalidate();
-        layout();
-        repaint();
-        support.firePropertyChange("", null, null);
-    }
-
-    public Object getValue() {
-        return (font);
-    }
-
-    public String getJavaInitializationString() {
-        if (this.font == null)
-            return "null";
-
-        return "new java.awt.Font(\"" + font.getName() + "\", " +
-                   font.getStyle() + ", " + font.getSize() + ")";
-    }
-
-    public boolean action(Event e, Object arg) {
-        String family = familyChoser.getSelectedItem();
-        int style = styles[styleChoser.getSelectedIndex()];
-        int size = pointSizes[sizeChoser.getSelectedIndex()];
-        try {
-            Font f = new Font(family, style, size);
-            changeFont(f);
-        } catch (Exception ex) {
-            System.err.println("Couldn't create font " + family + "-" +
-                        styleNames[style] + "-" + size);
-        }
-        return (false);
-    }
-
-
-    public boolean isPaintable() {
-        return true;
-    }
-
-    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
-        // Silent noop.
-        Font oldFont = gfx.getFont();
-        gfx.setFont(font);
-        FontMetrics fm = gfx.getFontMetrics();
-        int vpad = (box.height - fm.getAscent())/2;
-        gfx.drawString(sampleText, 0, box.height-vpad);
-        gfx.setFont(oldFont);
-    }
-
-    public String getAsText() {
-        if (this.font == null) {
-            return null;
-        }
-        StringBuilder sb = new StringBuilder();
-        sb.append(this.font.getName());
-        sb.append(' ');
-
-        boolean b = this.font.isBold();
-        if (b) {
-            sb.append("BOLD");
-        }
-        boolean i = this.font.isItalic();
-        if (i) {
-            sb.append("ITALIC");
-        }
-        if (b || i) {
-            sb.append(' ');
-        }
-        sb.append(this.font.getSize());
-        return sb.toString();
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Font.decode(text));
-    }
-
-    public String[] getTags() {
-        return null;
-    }
-
-    public java.awt.Component getCustomEditor() {
-        return this;
-    }
-
-    public boolean supportsCustomEditor() {
-        return true;
-    }
-
-    public void addPropertyChangeListener(PropertyChangeListener l) {
-        support.addPropertyChangeListener(l);
-    }
-
-    public void removePropertyChangeListener(PropertyChangeListener l) {
-        support.removePropertyChangeListener(l);
-    }
-
-    private Font font;
-    private Toolkit toolkit;
-    private String sampleText = "Abcde...";
-
-    private Label sample;
-    private Choice familyChoser;
-    private Choice styleChoser;
-    private Choice sizeChoser;
-
-    private String fonts[];
-    private String[] styleNames = { "plain", "bold", "italic" };
-    private int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC };
-    private int[] pointSizes = { 3, 5, 8, 10, 12, 14, 18, 24, 36, 48 };
-
-    private PropertyChangeSupport support = new PropertyChangeSupport(this);
-
+/**
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
+ */
+public class FontEditor extends com.sun.beans.editors.FontEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/IntegerEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/IntegerEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,17 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "int" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class IntegerEditor extends NumberEditor {
-
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Integer.decode(text));
-    }
-
+public class IntegerEditor extends com.sun.beans.editors.IntegerEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/LongEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/LongEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,23 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "long" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class LongEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value + "L"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Long.decode(text));
-    }
-
+public class LongEditor extends com.sun.beans.editors.LongEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/NumberEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/NumberEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,19 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Abstract Property editor for a java builtin number types.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-abstract public class NumberEditor extends PropertyEditorSupport {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value.toString()
-                : "null";
-    }
-
+abstract public class NumberEditor extends com.sun.beans.editors.NumberEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/ShortEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/ShortEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,27 +23,10 @@
  * questions.
  */
 
-
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "short" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class ShortEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? "((short)" + value + ")"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Short.decode(text));
-    }
-
+public class ShortEditor extends com.sun.beans.editors.ShortEditor {
 }
--- jdk/src/share/classes/sun/beans/editors/StringEditor.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/editors/StringEditor.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,52 +23,10 @@
  * questions.
  */
 
-
 package sun.beans.editors;
 
-import java.beans.*;
-
-public class StringEditor extends PropertyEditorSupport {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        if (value == null)
-            return "null";
-
-        String str = value.toString();
-        int length = str.length();
-        StringBuilder sb = new StringBuilder(length + 2);
-        sb.append('"');
-        for (int i = 0; i < length; i++) {
-            char ch = str.charAt(i);
-            switch (ch) {
-            case '\b': sb.append("\\b");  break;
-            case '\t': sb.append("\\t");  break;
-            case '\n': sb.append("\\n");  break;
-            case '\f': sb.append("\\f");  break;
-            case '\r': sb.append("\\r");  break;
-            case '\"': sb.append("\\\""); break;
-            case '\\': sb.append("\\\\"); break;
-            default:
-                if ((ch < ' ') || (ch > '~')) {
-                    sb.append("\\u");
-                    String hex = Integer.toHexString((int) ch);
-                    for (int len = hex.length(); len < 4; len++) {
-                        sb.append('0');
-                    }
-                    sb.append(hex);
-                } else {
-                    sb.append(ch);
-                }
-                break;
-            }
-        }
-        sb.append('"');
-        return sb.toString();
-    }
-
-    public void setAsText(String text) {
-        setValue(text);
-    }
-
+/**
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
+ */
+public class StringEditor extends com.sun.beans.editors.StringEditor {
 }
--- jdk/src/share/classes/sun/beans/infos/ComponentBeanInfo.java	2012-08-10 10:28:28.000000000 -0700
+++ jdk/src/share/classes/sun/beans/infos/ComponentBeanInfo.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 1996, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.beans.infos;
-
-import java.beans.*;
-
-/**
- * BeanInfo descriptor for a standard AWT component.
- */
-
-public class ComponentBeanInfo extends SimpleBeanInfo {
-    private static final Class beanClass = java.awt.Component.class;
-
-    public PropertyDescriptor[] getPropertyDescriptors() {
-        try {
-            PropertyDescriptor
-                      name = new PropertyDescriptor("name",       beanClass),
-                background = new PropertyDescriptor("background", beanClass),
-                foreground = new PropertyDescriptor("foreground", beanClass),
-                      font = new PropertyDescriptor("font",       beanClass),
-                   enabled = new PropertyDescriptor("enabled",    beanClass),
-                   visible = new PropertyDescriptor("visible",    beanClass),
-                 focusable = new PropertyDescriptor("focusable",  beanClass);
-
-            enabled.setExpert(true);
-            visible.setHidden(true);
-
-            background.setBound(true);
-            foreground.setBound(true);
-            font.setBound(true);
-            focusable.setBound(true);
-
-            PropertyDescriptor[] rv = {name, background, foreground, font, enabled, visible, focusable };
-            return rv;
-        } catch (IntrospectionException e) {
-            throw new Error(e.toString());
-        }
-    }
-}
--- jdk/src/share/classes/sun/font/CMap.java	2012-08-10 10:28:29.000000000 -0700
+++ jdk/src/share/classes/sun/font/CMap.java	2013-05-05 09:38:29.000000000 -0700
@@ -841,7 +841,6 @@
 
         CMapFormat6(ByteBuffer bbuffer, int offset, char[] xlat) {
 
-             System.err.println("WARNING: CMapFormat8 is untested.");
              bbuffer.position(offset+6);
              CharBuffer buffer = bbuffer.asCharBuffer();
              firstCode = buffer.get();
@@ -884,7 +883,6 @@
 
          CMapFormat8(ByteBuffer bbuffer, int offset, char[] xlat) {
 
-             System.err.println("WARNING: CMapFormat8 is untested.");
              bbuffer.position(12);
              bbuffer.get(is32);
              nGroups = bbuffer.getInt();
@@ -915,7 +913,6 @@
 
          CMapFormat10(ByteBuffer bbuffer, int offset, char[] xlat) {
 
-             System.err.println("WARNING: CMapFormat10 is untested.");
              firstCode = bbuffer.getInt() & INTMASK;
              entryCount = bbuffer.getInt() & INTMASK;
              bbuffer.position(offset+20);
--- jdk/src/share/classes/sun/font/FontUtilities.java	2012-08-10 10:28:29.000000000 -0700
+++ jdk/src/share/classes/sun/font/FontUtilities.java	2013-05-05 09:38:29.000000000 -0700
@@ -48,6 +48,8 @@
 
     public static boolean isLinux;
 
+    public static boolean isBSD;
+
     public static boolean isMacOSX;
 
     public static boolean isSolaris8;
@@ -78,6 +80,11 @@
 
                 isLinux = osName.startsWith("Linux");
 
+
+                isBSD = (osName.startsWith("FreeBSD") ||
+                         osName.startsWith("NetBSD") ||
+                         osName.startsWith("OpenBSD"));
+
                 isMacOSX = osName.contains("OS X"); // TODO: MacOSX
 
                 String t2kStr = System.getProperty("sun.java2d.font.scaler");
--- jdk/src/share/classes/sun/font/SunFontManager.java	2012-08-10 10:28:31.000000000 -0700
+++ jdk/src/share/classes/sun/font/SunFontManager.java	2013-05-05 09:38:29.000000000 -0700
@@ -417,7 +417,7 @@
                          * registerFonts method as on-screen these JRE fonts
                          * always go through the T2K rasteriser.
                          */
-                        if (FontUtilities.isLinux) {
+                        if (FontUtilities.isLinux || FontUtilities.isBSD) {
                             /* Linux font configuration uses these fonts */
                             registerFontDir(jreFontDirName);
                         }
--- jdk/src/share/classes/sun/invoke/anon/AnonymousClassLoader.java	2012-08-10 10:28:31.000000000 -0700
+++ jdk/src/share/classes/sun/invoke/anon/AnonymousClassLoader.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -73,74 +73,14 @@
 public class AnonymousClassLoader {
     final Class<?> hostClass;
 
-    // Note: Do not refactor the calls to checkHostClass unless you
-    //       also adjust this constant:
-    private static int CHC_CALLERS = 3;
-
-    public AnonymousClassLoader() {
-        this.hostClass = checkHostClass(null);
-    }
-    public AnonymousClassLoader(Class<?> hostClass) {
-        this.hostClass = checkHostClass(hostClass);
-    }
-
-    private static Class<?> getTopLevelClass(Class<?> clazz) {
-      for(Class<?> outer = clazz.getDeclaringClass(); outer != null;
-          outer = outer.getDeclaringClass()) {
-        clazz = outer;
-      }
-      return clazz;
+    // Privileged constructor.
+    private AnonymousClassLoader(Class<?> hostClass) {
+        this.hostClass = hostClass;
     }
 
-    private static Class<?> checkHostClass(Class<?> hostClass) {
-        // called only from the constructor
-        // does a context-sensitive check on caller class
-        // CC[0..3] = {Reflection, this.checkHostClass, this.<init>, caller}
-        Class<?> caller = sun.reflect.Reflection.getCallerClass(CHC_CALLERS);
-
-        if (caller == null) {
-            // called from the JVM directly
-            if (hostClass == null)
-                return AnonymousClassLoader.class; // anything central will do
-            return hostClass;
-        }
-
-        if (hostClass == null)
-            hostClass = caller; // default value is caller itself
-
-        // anonymous class will access hostClass on behalf of caller
-        Class<?> callee = hostClass;
-
-        if (caller == callee)
-            // caller can always nominate itself to grant caller's own access rights
-            return hostClass;
-
-        // normalize caller and callee to their top-level classes:
-        caller = getTopLevelClass(caller);
-        callee = getTopLevelClass(callee);
-        if (caller == callee)
-            return caller;
-
-        ClassLoader callerCL = caller.getClassLoader();
-        if (callerCL == null) {
-            // caller is trusted code, so accept the proposed hostClass
-            return hostClass;
-        }
-
-        // %%% should do something with doPrivileged, because trusted
-        // code should have a way to execute on behalf of
-        // partially-trusted clients
-
-        // Does the caller have the right to access the private
-        // members of the callee?  If not, raise an error.
-        final int ACC_PRIVATE = 2;
-        try {
-            sun.reflect.Reflection.ensureMemberAccess(caller, callee, null, ACC_PRIVATE);
-        } catch (IllegalAccessException ee) {
-            throw new IllegalArgumentException(ee);
-        }
-
-        return hostClass;
+    public static AnonymousClassLoader make(sun.misc.Unsafe unsafe, Class<?> hostClass) {
+        if (unsafe == null)  throw new NullPointerException();
+        return new AnonymousClassLoader(hostClass);
     }
 
     public Class<?> loadClass(byte[] classFile) {
@@ -249,7 +189,7 @@
     private static int fakeNameCounter = 99999;
 
     // ignore two warnings on this line:
-    static sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
+    private static sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
     // preceding line requires that this class be on the boot class path
 
     static private final Method defineAnonymousClass;
--- jdk/src/share/classes/sun/invoke/util/Wrapper.java	2012-08-10 10:28:32.000000000 -0700
+++ jdk/src/share/classes/sun/invoke/util/Wrapper.java	2013-05-05 09:38:29.000000000 -0700
@@ -456,6 +456,9 @@
             // If the target type is an interface, perform no runtime check.
             // (This loophole is safe, and is allowed by the JVM verifier.)
             // If the target type is a primitive, change it to a wrapper.
+            assert(!type.isPrimitive());
+            if (!type.isInterface())
+                type.cast(x);
             @SuppressWarnings("unchecked")
             T result = (T) x;  // unchecked warning is expected here
             return result;
--- jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSImageLayout.java	2012-08-10 10:28:43.000000000 -0700
+++ jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSImageLayout.java	2013-05-05 09:38:29.000000000 -0700
@@ -99,50 +99,75 @@
     int offset;
 
     Object dataArray;
-    private LCMSImageLayout(int np, int pixelType, int pixelSize) {
+    private int dataArrayLength; /* in bytes */
+
+    private LCMSImageLayout(int np, int pixelType, int pixelSize)
+            throws ImageLayoutException
+    {
         this.pixelType = pixelType;
         width = np;
         height = 1;
-        nextRowOffset = np*pixelSize;
+        nextRowOffset = safeMult(pixelSize, np);
         offset = 0;
     }
 
     private LCMSImageLayout(int width, int height, int pixelType,
-                            int pixelSize) {
+                            int pixelSize)
+            throws ImageLayoutException
+    {
         this.pixelType = pixelType;
         this.width = width;
         this.height = height;
-        nextRowOffset = width*pixelSize;
+        nextRowOffset = safeMult(pixelSize, width);
         offset = 0;
     }
 
 
-    public LCMSImageLayout(byte[] data, int np, int pixelType, int pixelSize) {
+    public LCMSImageLayout(byte[] data, int np, int pixelType, int pixelSize)
+            throws ImageLayoutException
+    {
         this(np, pixelType, pixelSize);
         dataType = DT_BYTE;
         dataArray = data;
+        dataArrayLength = data.length;
+
+        verify();
     }
 
-    public LCMSImageLayout(short[] data, int np, int pixelType, int pixelSize) {
+    public LCMSImageLayout(short[] data, int np, int pixelType, int pixelSize)
+            throws ImageLayoutException
+    {
         this(np, pixelType, pixelSize);
         dataType = DT_SHORT;
         dataArray = data;
+        dataArrayLength = 2 * data.length;
+
+        verify();
     }
 
-    public LCMSImageLayout(int[] data, int np, int pixelType, int pixelSize) {
+    public LCMSImageLayout(int[] data, int np, int pixelType, int pixelSize)
+            throws ImageLayoutException
+    {
         this(np, pixelType, pixelSize);
         dataType = DT_INT;
         dataArray = data;
+        dataArrayLength = 4 * data.length;
+
+        verify();
     }
 
     public LCMSImageLayout(double[] data, int np, int pixelType, int pixelSize)
+            throws ImageLayoutException
     {
         this(np, pixelType, pixelSize);
         dataType = DT_DOUBLE;
         dataArray = data;
+        dataArrayLength = 8 * data.length;
+
+        verify();
     }
 
-    public LCMSImageLayout(BufferedImage image) {
+    public LCMSImageLayout(BufferedImage image) throws ImageLayoutException {
         ShortComponentRaster shortRaster;
         IntegerComponentRaster intRaster;
         ByteComponentRaster byteRaster;
@@ -186,9 +211,13 @@
             case BufferedImage.TYPE_INT_ARGB:
             case BufferedImage.TYPE_INT_BGR:
                 intRaster = (IntegerComponentRaster)image.getRaster();
-                nextRowOffset = intRaster.getScanlineStride()*4;
-                offset = intRaster.getDataOffset(0)*4;
+
+                nextRowOffset = safeMult(4, intRaster.getScanlineStride());
+
+                offset = safeMult(4, intRaster.getDataOffset(0));
+
                 dataArray = intRaster.getDataStorage();
+                dataArrayLength = 4 * intRaster.getDataStorage().length;
                 dataType = DT_INT;
                 break;
 
@@ -196,8 +225,10 @@
             case BufferedImage.TYPE_4BYTE_ABGR:
                 byteRaster = (ByteComponentRaster)image.getRaster();
                 nextRowOffset = byteRaster.getScanlineStride();
-                offset = byteRaster.getDataOffset(0);
+                int firstBand = image.getSampleModel().getNumBands() - 1;
+                offset = byteRaster.getDataOffset(firstBand);
                 dataArray = byteRaster.getDataStorage();
+                dataArrayLength = byteRaster.getDataStorage().length;
                 dataType = DT_BYTE;
                 break;
 
@@ -206,17 +237,20 @@
                 nextRowOffset = byteRaster.getScanlineStride();
                 offset = byteRaster.getDataOffset(0);
                 dataArray = byteRaster.getDataStorage();
+                dataArrayLength = byteRaster.getDataStorage().length;
                 dataType = DT_BYTE;
                 break;
 
             case BufferedImage.TYPE_USHORT_GRAY:
                 shortRaster = (ShortComponentRaster)image.getRaster();
-                nextRowOffset = shortRaster.getScanlineStride()*2;
-                offset = shortRaster.getDataOffset(0) * 2;
+                nextRowOffset = safeMult(2, shortRaster.getScanlineStride());
+                offset = safeMult(2, shortRaster.getDataOffset(0));
                 dataArray = shortRaster.getDataStorage();
+                dataArrayLength = 2 * shortRaster.getDataStorage().length;
                 dataType = DT_SHORT;
                 break;
         }
+        verify();
     }
 
     public static boolean isSupported(BufferedImage image) {
@@ -232,4 +266,45 @@
         }
         return false;
     }
+
+    private void verify() throws ImageLayoutException {
+
+        if (offset < 0 || offset >= dataArrayLength) {
+            throw new ImageLayoutException("Invalid image layout");
+        }
+
+        int lastPixelOffset = safeMult(nextRowOffset, (height - 1));
+
+        lastPixelOffset = safeAdd(lastPixelOffset, (width - 1));
+
+        int off = safeAdd(offset, lastPixelOffset);
+
+        if (off < 0 || off >= dataArrayLength) {
+            throw new ImageLayoutException("Invalid image layout");
+        }
+    }
+
+    static int safeAdd(int a, int b) throws ImageLayoutException {
+        long res = a;
+        res += b;
+        if (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) {
+            throw new ImageLayoutException("Invalid image layout");
+        }
+        return (int)res;
+    }
+
+    static int safeMult(int a, int b) throws ImageLayoutException {
+        long res = a;
+        res *= b;
+        if (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) {
+            throw new ImageLayoutException("Invalid image layout");
+        }
+        return (int)res;
+    }
+
+    public static class ImageLayoutException extends Exception {
+        public ImageLayoutException(String message) {
+            super(message);
+        }
+    }
 }
--- jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSTransform.java	2012-08-10 10:28:43.000000000 -0700
+++ jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSTransform.java	2013-05-05 09:38:29.000000000 -0700
@@ -51,6 +51,7 @@
 import java.awt.image.ComponentSampleModel;
 import sun.java2d.cmm.*;
 import sun.java2d.cmm.lcms.*;
+import static sun.java2d.cmm.lcms.LCMSImageLayout.ImageLayoutException;
 
 
 public class LCMSTransform implements ColorTransform {
@@ -157,8 +158,12 @@
         if (LCMSImageLayout.isSupported(src) &&
             LCMSImageLayout.isSupported(dst))
         {
-            doTransform(new LCMSImageLayout(src), new LCMSImageLayout(dst));
-            return;
+            try {
+                doTransform(new LCMSImageLayout(src), new LCMSImageLayout(dst));
+                return;
+            } catch (ImageLayoutException e) {
+                throw new CMMException("Unable to convert images");
+            }
         }
         LCMSImageLayout srcIL, dstIL;
         Raster srcRas = src.getRaster();
@@ -216,14 +221,18 @@
             }
             int idx;
             // TODO check for src npixels = dst npixels
-            srcIL = new LCMSImageLayout(
-                srcLine, srcLine.length/getNumInComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-                LCMSImageLayout.BYTES_SH(1), getNumInComponents());
-            dstIL = new LCMSImageLayout(
-                dstLine, dstLine.length/getNumOutComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-                LCMSImageLayout.BYTES_SH(1), getNumOutComponents());
+            try {
+                srcIL = new LCMSImageLayout(
+                        srcLine, srcLine.length/getNumInComponents(),
+                        LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                        LCMSImageLayout.BYTES_SH(1), getNumInComponents());
+                dstIL = new LCMSImageLayout(
+                        dstLine, dstLine.length/getNumOutComponents(),
+                        LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                        LCMSImageLayout.BYTES_SH(1), getNumOutComponents());
+            } catch (ImageLayoutException e) {
+                throw new CMMException("Unable to convert images");
+            }
             // process each scanline
             for (int y = 0; y < h; y++) {
                 // convert src scanline
@@ -272,16 +281,19 @@
                 alpha = new float[w];
             }
             int idx;
-            srcIL = new LCMSImageLayout(
-                srcLine, srcLine.length/getNumInComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-                LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
-
-            dstIL = new LCMSImageLayout(
-                dstLine, dstLine.length/getNumOutComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-                LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
-
+            try {
+                srcIL = new LCMSImageLayout(
+                    srcLine, srcLine.length/getNumInComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                    LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
+
+                dstIL = new LCMSImageLayout(
+                    dstLine, dstLine.length/getNumOutComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                    LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
+            } catch (ImageLayoutException e) {
+                throw new CMMException("Unable to convert images");
+            }
             // process each scanline
             for (int y = 0; y < h; y++) {
                 // convert src scanline
@@ -390,16 +402,19 @@
         short[] srcLine = new short[w * srcNumBands];
         short[] dstLine = new short[w * dstNumBands];
         int idx;
-        srcIL = new LCMSImageLayout(
-            srcLine, srcLine.length/getNumInComponents(),
-            LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-            LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
-
-        dstIL = new LCMSImageLayout(
-            dstLine, dstLine.length/getNumOutComponents(),
-            LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-            LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
+        try {
+            srcIL = new LCMSImageLayout(
+                    srcLine, srcLine.length/getNumInComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                    LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
 
+            dstIL = new LCMSImageLayout(
+                    dstLine, dstLine.length/getNumOutComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                    LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
+        } catch (ImageLayoutException e) {
+            throw new CMMException("Unable to convert rasters");
+        }
         // process each scanline
         for (int y = 0; y < h; y++, ys++, yd++) {
             // get src scanline
@@ -482,15 +497,18 @@
             byte[] dstLine = new byte[w * dstNumBands];
             int idx;
             // TODO check for src npixels = dst npixels
-            srcIL = new LCMSImageLayout(
-                srcLine, srcLine.length/getNumInComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-                LCMSImageLayout.BYTES_SH(1), getNumInComponents());
-            dstIL = new LCMSImageLayout(
-                dstLine, dstLine.length/getNumOutComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-                LCMSImageLayout.BYTES_SH(1), getNumOutComponents());
-
+            try {
+                srcIL = new LCMSImageLayout(
+                        srcLine, srcLine.length/getNumInComponents(),
+                        LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                        LCMSImageLayout.BYTES_SH(1), getNumInComponents());
+                dstIL = new LCMSImageLayout(
+                        dstLine, dstLine.length/getNumOutComponents(),
+                        LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                        LCMSImageLayout.BYTES_SH(1), getNumOutComponents());
+            } catch (ImageLayoutException e) {
+                throw new CMMException("Unable to convert rasters");
+            }
             // process each scanline
             for (int y = 0; y < h; y++, ys++, yd++) {
                 // get src scanline
@@ -522,16 +540,20 @@
             short[] srcLine = new short[w * srcNumBands];
             short[] dstLine = new short[w * dstNumBands];
             int idx;
-            srcIL = new LCMSImageLayout(
-                srcLine, srcLine.length/getNumInComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-                LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
-
-            dstIL = new LCMSImageLayout(
-                dstLine, dstLine.length/getNumOutComponents(),
-                LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-                LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
 
+            try {
+                srcIL = new LCMSImageLayout(
+                        srcLine, srcLine.length/getNumInComponents(),
+                        LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                        LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
+
+                dstIL = new LCMSImageLayout(
+                        dstLine, dstLine.length/getNumOutComponents(),
+                        LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                        LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
+            } catch (ImageLayoutException e) {
+                throw new CMMException("Unable to convert rasters");
+            }
             // process each scanline
             for (int y = 0; y < h; y++, ys++, yd++) {
                 // get src scanline
@@ -572,19 +594,23 @@
             dst = new short [(src.length/getNumInComponents())*getNumOutComponents()];
         }
 
-        LCMSImageLayout srcIL = new LCMSImageLayout(
-            src, src.length/getNumInComponents(),
-            LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-            LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
-
-        LCMSImageLayout dstIL = new LCMSImageLayout(
-            dst, dst.length/getNumOutComponents(),
-            LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-            LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
+        try {
+            LCMSImageLayout srcIL = new LCMSImageLayout(
+                    src, src.length/getNumInComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                    LCMSImageLayout.BYTES_SH(2), getNumInComponents()*2);
+
+            LCMSImageLayout dstIL = new LCMSImageLayout(
+                    dst, dst.length/getNumOutComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                    LCMSImageLayout.BYTES_SH(2), getNumOutComponents()*2);
 
-        doTransform(srcIL, dstIL);
+            doTransform(srcIL, dstIL);
 
-        return dst;
+            return dst;
+        } catch (ImageLayoutException e) {
+            throw new CMMException("Unable to convert data");
+        }
     }
 
     public byte[] colorConvert(byte[] src, byte[] dst) {
@@ -592,18 +618,22 @@
             dst = new byte [(src.length/getNumInComponents())*getNumOutComponents()];
         }
 
-        LCMSImageLayout srcIL = new LCMSImageLayout(
-            src, src.length/getNumInComponents(),
-            LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
-            LCMSImageLayout.BYTES_SH(1), getNumInComponents());
-
-        LCMSImageLayout dstIL = new LCMSImageLayout(
-            dst, dst.length/getNumOutComponents(),
-            LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
-            LCMSImageLayout.BYTES_SH(1), getNumOutComponents());
+        try {
+            LCMSImageLayout srcIL = new LCMSImageLayout(
+                    src, src.length/getNumInComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumInComponents()) |
+                    LCMSImageLayout.BYTES_SH(1), getNumInComponents());
+
+            LCMSImageLayout dstIL = new LCMSImageLayout(
+                    dst, dst.length/getNumOutComponents(),
+                    LCMSImageLayout.CHANNELS_SH(getNumOutComponents()) |
+                    LCMSImageLayout.BYTES_SH(1), getNumOutComponents());
 
-        doTransform(srcIL, dstIL);
+            doTransform(srcIL, dstIL);
 
-        return dst;
+            return dst;
+        } catch (ImageLayoutException e) {
+            throw new CMMException("Unable to convert data");
+        }
     }
 }
--- jdk/src/share/classes/sun/java2d/opengl/OGLBlitLoops.java	2012-08-10 10:28:44.000000000 -0700
+++ jdk/src/share/classes/sun/java2d/opengl/OGLBlitLoops.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,7 @@
 
 package sun.java2d.opengl;
 
+import java.awt.AlphaComposite;
 import java.awt.Composite;
 import java.awt.Transparency;
 import java.awt.geom.AffineTransform;
@@ -96,6 +97,8 @@
                                CompositeType.AnyAlpha,
                                blitIntArgbPreToSurface),
 
+            new OGLAnyCompositeBlit(OGLSurfaceData.OpenGLSurface),
+
             new OGLSwToSurfaceScale(SurfaceType.IntRgb,
                                     OGLSurfaceData.PF_INT_RGB),
             new OGLSwToSurfaceScale(SurfaceType.IntRgbx,
@@ -172,6 +175,9 @@
             new OGLGeneralBlit(OGLSurfaceData.OpenGLTexture,
                                CompositeType.SrcNoEa,
                                blitIntArgbPreToTexture),
+
+            new OGLAnyCompositeBlit(OGLSurfaceData.OpenGLTexture),
+
         };
         GraphicsPrimitiveMgr.register(primitives);
     }
@@ -760,3 +766,49 @@
         }
     }
 }
+
+class OGLAnyCompositeBlit extends Blit {
+    private WeakReference<SurfaceData> dstTmp;
+
+    public OGLAnyCompositeBlit(SurfaceType dstType) {
+        super(SurfaceType.Any, CompositeType.Any, dstType);
+    }
+    public synchronized void Blit(SurfaceData src, SurfaceData dst,
+                                  Composite comp, Region clip,
+                                  int sx, int sy, int dx, int dy,
+                                  int w, int h)
+    {
+        Blit convertdst = Blit.getFromCache(dst.getSurfaceType(),
+                                            CompositeType.SrcNoEa,
+                                            SurfaceType.IntArgbPre);
+
+        SurfaceData cachedDst = null;
+
+        if (dstTmp != null) {
+            // use cached intermediate surface, if available
+            cachedDst = dstTmp.get();
+        }
+
+        // convert source to IntArgbPre
+        SurfaceData dstBuffer = convertFrom(convertdst, dst, dx, dy, w, h,
+                                            cachedDst, BufferedImage.TYPE_INT_ARGB_PRE);
+
+        Blit performop = Blit.getFromCache(src.getSurfaceType(),
+        CompositeType.Any, dstBuffer.getSurfaceType());
+
+        performop.Blit(src, dstBuffer, comp, clip,
+                       sx, sy, 0, 0, w, h);
+
+        if (dstBuffer != cachedDst) {
+            // cache the intermediate surface
+            dstTmp = new WeakReference(dstBuffer);
+        }
+
+        // now blit the buffer back to the destination
+        convertdst = Blit.getFromCache(dstBuffer.getSurfaceType(),
+                                       CompositeType.SrcNoEa,
+                                       dst.getSurfaceType());
+        convertdst.Blit(dstBuffer, dst, AlphaComposite.Src,
+                        clip, 0, 0, dx, dy, w, h);
+    }
+}
--- jdk/src/share/classes/sun/java2d/opengl/OGLSurfaceDataProxy.java	2012-08-10 10:28:44.000000000 -0700
+++ jdk/src/share/classes/sun/java2d/opengl/OGLSurfaceDataProxy.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -76,6 +76,7 @@
                                         CompositeType comp,
                                         Color bgColor)
     {
-        return (bgColor == null || transparency == Transparency.OPAQUE);
+        return comp.isDerivedFrom(CompositeType.AnyAlpha) &&
+               (bgColor == null || transparency == Transparency.OPAQUE);
     }
 }
--- jdk/src/share/classes/sun/launcher/LauncherHelper.java	2012-08-10 10:28:48.000000000 -0700
+++ jdk/src/share/classes/sun/launcher/LauncherHelper.java	2013-05-05 09:38:29.000000000 -0700
@@ -48,6 +48,9 @@
 import java.math.BigDecimal;
 import java.math.RoundingMode;
 import java.nio.charset.Charset;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ResourceBundle;
 import java.text.MessageFormat;
 import java.util.ArrayList;
@@ -69,8 +72,6 @@
 
     private static StringBuilder outBuf = new StringBuilder();
 
-    private static ResourceBundle javarb = null;
-
     private static final String INDENT = "    ";
     private static final String VM_SETTINGS     = "VM settings:";
     private static final String PROP_SETTINGS   = "Property settings:";
@@ -78,6 +79,7 @@
 
     // sync with java.c and sun.misc.VM
     private static final String diagprop = "sun.java.launcher.diag";
+    final static boolean trace = sun.misc.VM.getSavedProperty(diagprop) != null;
 
     private static final String defaultBundleName =
             "sun.launcher.resources.launcher";
@@ -428,11 +430,11 @@
         if (msgKey != null) {
             ostream.println(getLocalizedMessage(msgKey, args));
         }
-        if (sun.misc.VM.getSavedProperty(diagprop) != null) {
+        if (trace) {
             if (t != null) {
                 t.printStackTrace();
             } else {
-                Thread.currentThread().dumpStack();
+                Thread.dumpStack();
             }
         }
         System.exit(1);
@@ -532,4 +534,82 @@
         }
         return null; // keep the compiler happy
     }
+
+    static String[] expandArgs(String[] argArray) {
+        List<StdArg> aList = new ArrayList<>();
+        for (String x : argArray) {
+            aList.add(new StdArg(x));
+        }
+        return expandArgs(aList);
+    }
+
+    static String[] expandArgs(List<StdArg> argList) {
+        ArrayList<String> out = new ArrayList<>();
+        if (trace) {
+            System.err.println("Incoming arguments:");
+        }
+        for (StdArg a : argList) {
+            if (trace) {
+                System.err.println(a);
+            }
+            if (a.needsExpansion) {
+                File x = new File(a.arg);
+                File parent = x.getParentFile();
+                String glob = x.getName();
+                if (parent == null) {
+                    parent = new File(".");
+                }
+                try (DirectoryStream<Path> dstream =
+                        Files.newDirectoryStream(parent.toPath(), glob)) {
+                    int entries = 0;
+                    for (Path p : dstream) {
+                        out.add(p.normalize().toString());
+                        entries++;
+                    }
+                    if (entries == 0) {
+                        out.add(a.arg);
+                    }
+                } catch (Exception e) {
+                    out.add(a.arg);
+                    if (trace) {
+                        System.err.println("Warning: passing argument as-is " + a);
+                        System.err.print(e);
+                    }
+                }
+            } else {
+                out.add(a.arg);
+            }
+        }
+        String[] oarray = new String[out.size()];
+        out.toArray(oarray);
+
+        if (trace) {
+            System.err.println("Expanded arguments:");
+            for (String x : oarray) {
+                System.err.println(x);
+            }
+        }
+        return oarray;
+    }
+
+    /* duplicate of the native StdArg struct */
+    private static class StdArg {
+        final String arg;
+        final boolean needsExpansion;
+        StdArg(String arg, boolean expand) {
+            this.arg = arg;
+            this.needsExpansion = expand;
+        }
+        // protocol: first char indicates whether expansion is required
+        // 'T' = true ; needs expansion
+        // 'F' = false; needs no expansion
+        StdArg(String in) {
+            this.arg = in.substring(1);
+            needsExpansion = in.charAt(0) == 'T';
+        }
+        public String toString() {
+            return "StdArg{" + "arg=" + arg + ", needsExpansion=" + needsExpansion + '}';
+        }
+    }
 }
+
--- jdk/src/share/classes/sun/launcher/resources/launcher.properties	2012-08-10 10:28:48.000000000 -0700
+++ jdk/src/share/classes/sun/launcher/resources/launcher.properties	2013-05-05 09:38:29.000000000 -0700
@@ -43,7 +43,7 @@
 \                  and ZIP archives to search for class files.\n\
 \    -D<name>=<value>\n\
 \                  set a system property\n\
-\    -verbose[:class|gc|jni]\n\
+\    -verbose:[class|gc|jni]\n\
 \                  enable verbose output\n\
 \    -version      print product version and exit\n\
 \    -version:<value>\n\
@@ -136,3 +136,4 @@
     Error: An unexpected error occurred while trying to open file {0}
 java.launcher.jar.error2=manifest not found in {0}
 java.launcher.jar.error3=no main manifest attribute, in {0}
+java.launcher.init.error=initialization error
--- jdk/src/share/classes/sun/management/LockDataConverter.java	2012-08-10 10:28:49.000000000 -0700
+++ jdk/src/share/classes/sun/management/LockDataConverter.java	2013-05-05 09:38:28.000000000 -0700
@@ -27,6 +27,8 @@
 
 import java.lang.management.LockInfo;
 import java.lang.management.ThreadInfo;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import javax.management.Attribute;
 import javax.management.StandardMBean;
 import javax.management.openmbean.CompositeData;
@@ -40,13 +42,13 @@
     private LockInfo      lockInfo;
     private LockInfo[]    lockedSyncs;
 
-    LockDataConverter() {
+    private LockDataConverter() {
         super(LockDataConverterMXBean.class, true);
         this.lockInfo = null;
         this.lockedSyncs = null;
     }
 
-    LockDataConverter(ThreadInfo ti) {
+    private LockDataConverter(ThreadInfo ti) {
         super(LockDataConverterMXBean.class, true);
         this.lockInfo = ti.getLockInfo();
         this.lockedSyncs = ti.getLockedSynchronizers();
@@ -104,8 +106,24 @@
     }
 
     static CompositeData toLockInfoCompositeData(LockInfo l) {
-        LockDataConverter ldc = new LockDataConverter();
+        LockDataConverter ldc = newLockDataConverter();
         ldc.setLockInfo(l);
         return ldc.toLockInfoCompositeData();
     }
+
+   static LockDataConverter newLockDataConverter() {
+        return AccessController.doPrivileged(new PrivilegedAction<LockDataConverter>() {
+               public LockDataConverter run() {
+                   return new LockDataConverter();
+               }
+        });
+   }
+
+   static LockDataConverter newLockDataConverter(final ThreadInfo ti) {
+        LockDataConverter result = newLockDataConverter();
+        result.lockInfo = ti.getLockInfo();
+        result.lockedSyncs = ti.getLockedSynchronizers();
+        return result;
+   }
 }
+
--- jdk/src/share/classes/sun/management/ThreadInfoCompositeData.java	2012-08-10 10:28:50.000000000 -0700
+++ jdk/src/share/classes/sun/management/ThreadInfoCompositeData.java	2013-05-05 09:38:28.000000000 -0700
@@ -85,7 +85,7 @@
         }
 
         // Convert MonitorInfo[] and LockInfo[] to CompositeData[]
-        LockDataConverter converter = new LockDataConverter(threadInfo);
+        LockDataConverter converter = LockDataConverter.newLockDataConverter(threadInfo);
         CompositeData lockInfoData = converter.toLockInfoCompositeData();
         CompositeData[] lockedSyncsData = converter.toLockedSynchronizersCompositeData();
 
@@ -315,7 +315,7 @@
 
     // 6.0 new attributes
     public LockInfo lockInfo() {
-        LockDataConverter converter = new LockDataConverter();
+        LockDataConverter converter = LockDataConverter.newLockDataConverter();
         CompositeData lockInfoData = (CompositeData) cdata.get(LOCK_INFO);
         return converter.toLockInfo(lockInfoData);
     }
@@ -336,7 +336,7 @@
     }
 
     public LockInfo[] lockedSynchronizers() {
-        LockDataConverter converter = new LockDataConverter();
+        LockDataConverter converter = LockDataConverter.newLockDataConverter();
         CompositeData[] lockedSyncsData =
             (CompositeData[]) cdata.get(LOCKED_SYNCS);
 
--- jdk/src/share/classes/sun/misc/JavaAWTAccess.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/sun/misc/JavaAWTAccess.java	2013-05-05 09:38:29.000000000 -0700
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.misc;
+
+public interface JavaAWTAccess {
+    public Object getContext();
+    public Object getExecutionContext();
+
+    public Object get(Object context, Object key);
+    public void put(Object context, Object key, Object value);
+    public void remove(Object context, Object key);
+
+    // convenience methods whose context is the object returned by getContext()
+    public Object get(Object key);
+    public void put(Object key, Object value);
+    public void remove(Object key);
+    public boolean isDisposed();
+    public boolean isMainAppContext();
+}
--- jdk/src/share/classes/sun/misc/Service.java	2012-08-10 10:28:57.000000000 -0700
+++ jdk/src/share/classes/sun/misc/Service.java	2013-05-05 09:38:29.000000000 -0700
@@ -284,12 +284,20 @@
             }
             String cn = nextName;
             nextName = null;
+            Class<?> c = null;
             try {
-                return Class.forName(cn, true, loader).newInstance();
+                c = Class.forName(cn, false, loader);
             } catch (ClassNotFoundException x) {
                 fail(service,
                      "Provider " + cn + " not found");
-            } catch (Exception x) {
+            }
+            if (!service.isAssignableFrom(c)) {
+                fail(service,
+                     "Provider " + cn  + " not a subtype");
+            }
+            try {
+                return service.cast(c.newInstance());
+            } catch (Throwable x) {
                 fail(service,
                      "Provider " + cn + " could not be instantiated: " + x,
                      x);
--- jdk/src/share/classes/sun/misc/SharedSecrets.java	2012-08-10 10:28:57.000000000 -0700
+++ jdk/src/share/classes/sun/misc/SharedSecrets.java	2013-05-05 09:38:29.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,6 +56,7 @@
     private static JavaSecurityAccess javaSecurityAccess;
     private static JavaxSecurityAuthKerberosAccess javaxSecurityAuthKerberosAccess;
     private static JavaUtilZipAccess javaUtilZipAccess;
+    private static JavaAWTAccess javaAWTAccess;
 
     public static JavaUtilJarAccess javaUtilJarAccess() {
         if (javaUtilJarAccess == null) {
@@ -177,4 +178,14 @@
         }
         return javaUtilZipAccess;
     }
+
+    public static void setJavaAWTAccess(JavaAWTAccess jaa) {
+        javaAWTAccess = jaa;
+    }
+
+    public static JavaAWTAccess getJavaAWTAccess() {
+        // this may return null in which case calling code needs to
+        // provision for.
+        return javaAWTAccess;
+    }
 }
--- jdk/src/share/classes/sun/net/httpserver/ChunkedInputStream.java	2012-08-10 10:28:59.000000000 -0700
+++ jdk/src/share/classes/sun/net/httpserver/ChunkedInputStream.java	2013-05-05 09:38:29.000000000 -0700
@@ -41,8 +41,12 @@
 
     private boolean needToReadHeader = true;
 
-    static char CR = '\r';
-    static char LF = '\n';
+    final static char CR = '\r';
+    final static char LF = '\n';
+    /*
+     * Maximum chunk header size of 2KB + 2 bytes for CRLF
+     */
+    private final static int MAX_CHUNK_HEADER_SIZE = 2050;
 
     private int numeric (char[] arr, int nchars) throws IOException {
         assert arr.length >= nchars;
@@ -73,10 +77,14 @@
         char[] len_arr = new char [16];
         int len_size = 0;
         boolean end_of_len = false;
+        int read = 0;
 
         while ((c=in.read())!= -1) {
             char ch = (char) c;
-            if (len_size == len_arr.length -1) {
+            read++;
+            if ((len_size == len_arr.length -1) ||
+                (read > MAX_CHUNK_HEADER_SIZE))
+            {
                 throw new IOException ("invalid chunk header");
             }
             if (gotCR) {
--- jdk/src/share/classes/sun/net/www/MessageHeader.java	2012-08-10 10:29:01.000000000 -0700
+++ jdk/src/share/classes/sun/net/www/MessageHeader.java	2013-05-05 09:38:30.000000000 -0700
@@ -138,6 +138,43 @@
         return null;
     }
 
+    /**
+     * Removes bare Negotiate and Kerberos headers when an "NTLM ..."
+     * appears. All Performed on headers with key being k.
+     * @return true if there is a change
+     */
+    public boolean filterNTLMResponses(String k) {
+        boolean found = false;
+        for (int i=0; i<nkeys; i++) {
+            if (k.equalsIgnoreCase(keys[i])
+                    && values[i] != null && values[i].length() > 5
+                    && values[i].substring(0, 5).equalsIgnoreCase("NTLM ")) {
+                found = true;
+                break;
+            }
+        }
+        if (found) {
+            int j = 0;
+            for (int i=0; i<nkeys; i++) {
+                if (k.equalsIgnoreCase(keys[i]) && (
+                        "Negotiate".equalsIgnoreCase(values[i]) ||
+                        "Kerberos".equalsIgnoreCase(values[i]))) {
+                    continue;
+                }
+                if (i != j) {
+                    keys[j] = keys[i];
+                    values[j] = values[i];
+                }
+                j++;
+            }
+            if (j != nkeys) {
+                nkeys = j;
+                return true;
+            }
+        }
+        return false;
+    }
+
     class HeaderIterator implements Iterator<String> {
         int index = 0;
         int next = -1;
--- jdk/src/share/classes/sun/net/www/http/ChunkedInputStream.java	2012-08-10 10:29:01.000000000 -0700
+++ jdk/src/share/classes/sun/net/www/http/ChunkedInputStream.java	2013-05-05 09:38:29.000000000 -0700
@@ -125,6 +125,11 @@
      */
     private boolean closed;
 
+    /*
+     * Maximum chunk header size of 2KB + 2 bytes for CRLF
+     */
+    private final static int MAX_CHUNK_HEADER_SIZE = 2050;
+
     /**
      * State to indicate that next field should be :-
      *  chunk-size [ chunk-extension ] CRLF
@@ -290,6 +295,10 @@
                             break;
                         }
                         pos++;
+                        if ((pos - rawPos) >= MAX_CHUNK_HEADER_SIZE) {
+                            error = true;
+                            throw new IOException("Chunk header too long");
+                        }
                     }
                     if (pos >= rawCount) {
                         return;
--- jdk/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java	2012-08-10 10:29:02.000000000 -0700
+++ jdk/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java	2013-05-05 09:38:30.000000000 -0700
@@ -1323,6 +1323,16 @@
                 if (logger.isLoggable(PlatformLogger.FINE)) {
                     logger.fine(responses.toString());
                 }
+
+                boolean b1 = responses.filterNTLMResponses("WWW-Authenticate");
+                boolean b2 = responses.filterNTLMResponses("Proxy-Authenticate");
+                if (b1 || b2) {
+                    if (logger.isLoggable(PlatformLogger.FINE)) {
+                        logger.fine(">>>> Headers are filtered");
+                        logger.fine(responses.toString());
+                    }
+                }
+
                 inputStream = http.getInputStream();
 
                 respCode = getResponseCode();
@@ -1782,6 +1792,13 @@
                     logger.fine(responses.toString());
                 }
 
+                if (responses.filterNTLMResponses("Proxy-Authenticate")) {
+                    if (logger.isLoggable(PlatformLogger.FINE)) {
+                        logger.fine(">>>> Headers are filtered");
+                        logger.fine(responses.toString());
+                    }
+                }
+
                 statusLine = responses.getValue(0);
                 StringTokenizer st = new StringTokenizer(statusLine);
                 st.nextToken();
--- jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java	2012-08-10 10:29:03.000000000 -0700
+++ jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java	2013-05-05 09:38:30.000000000 -0700
@@ -419,7 +419,7 @@
 
         synchronized (writeLock) {
             ensureOpen();
-            InetSocketAddress isa = (InetSocketAddress)target;
+            InetSocketAddress isa = Net.checkAddress(target);
             InetAddress ia = isa.getAddress();
             if (ia == null)
                 throw new IOException("Target address not resolved");
@@ -430,9 +430,9 @@
                     SecurityManager sm = System.getSecurityManager();
                     if (sm != null) {
                         if (ia.isMulticastAddress()) {
-                            sm.checkMulticast(isa.getAddress());
+                            sm.checkMulticast(ia);
                         } else {
-                            sm.checkConnect(isa.getAddress().getHostAddress(),
+                            sm.checkConnect(ia.getHostAddress(),
                                             isa.getPort());
                         }
                     }
@@ -452,7 +452,7 @@
                     return 0;
                 writerThread = NativeThread.current();
                 do {
-                    n = send(fd, src, target);
+                    n = send(fd, src, isa);
                 } while ((n == IOStatus.INTERRUPTED) && isOpen());
 
                 synchronized (stateLock) {
@@ -469,7 +469,7 @@
         }
     }
 
-    private int send(FileDescriptor fd, ByteBuffer src, SocketAddress target)
+    private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
         throws IOException
     {
         if (src instanceof DirectBuffer)
@@ -500,7 +500,7 @@
     }
 
     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
-                                            SocketAddress target)
+                                     InetSocketAddress target)
         throws IOException
     {
         int pos = bb.position();
@@ -512,7 +512,7 @@
         int written;
         try {
             written = send0(preferIPv6, fd, ((DirectBuffer)bb).address() + pos,
-                            rem, target);
+                            rem, target.getAddress(), target.getPort());
         } catch (PortUnreachableException pue) {
             if (isConnected())
                 throw pue;
@@ -749,8 +749,7 @@
                     if (sm != null)
                         sm.checkConnect(isa.getAddress().getHostAddress(),
                                         isa.getPort());
-                    boolean isIPv6 = (family == StandardProtocolFamily.INET6);
-                    disconnect0(fd, isIPv6);
+                    disconnect0(fd);
                     remoteAddress = null;
                     state = ST_UNCONNECTED;
 
@@ -1085,15 +1084,15 @@
 
     private static native void initIDs();
 
-    private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
+    private static native void disconnect0(FileDescriptor fd)
         throws IOException;
 
     private native int receive0(FileDescriptor fd, long address, int len,
                                 boolean connected)
         throws IOException;
 
-    private native int send0(boolean preferIPv6, FileDescriptor fd, long address, int len,
-                             SocketAddress sa)
+    private native int send0(boolean preferIPv6, FileDescriptor fd, long address,
+                             int len, InetAddress addr, int port)
         throws IOException;
 
     static {
--- jdk/src/share/classes/sun/print/PSPrinterJob.java	2012-08-10 10:29:08.000000000 -0700
+++ jdk/src/share/classes/sun/print/PSPrinterJob.java	2013-05-05 09:38:30.000000000 -0700
@@ -1537,7 +1537,7 @@
         }
 
        String osname = System.getProperty("os.name");
-       if (osname.equals("Linux") || osname.contains("OS X")) {
+       if (osname.equals("Linux") || osname.equals("FreeBSD") || osname.equals("NetBSD") || osname.equals("OpenBSD") || osname.equals("OS X")) {
             execCmd = new String[ncomps];
             execCmd[n++] = "/usr/bin/lpr";
             if ((pFlags & PRINTER) != 0) {
--- jdk/src/share/classes/sun/reflect/misc/MethodUtil.java	2012-08-10 10:29:15.000000000 -0700
+++ jdk/src/share/classes/sun/reflect/misc/MethodUtil.java	2013-05-05 09:38:30.000000000 -0700
@@ -50,8 +50,28 @@
 
 
 class Trampoline {
+    static {
+        if (Trampoline.class.getClassLoader() == null) {
+            throw new Error(
+                "Trampoline must not be defined by the bootstrap classloader");
+        }
+    }
+
+    private static void ensureInvocableMethod(Method m)
+        throws InvocationTargetException
+    {
+        Class<?> clazz = m.getDeclaringClass();
+        if (clazz.equals(AccessController.class) ||
+            clazz.equals(Method.class) ||
+            clazz.getName().startsWith("java.lang.invoke."))
+            throw new InvocationTargetException(
+                new UnsupportedOperationException("invocation not supported"));
+    }
+
     private static Object invoke(Method m, Object obj, Object[] params)
-        throws InvocationTargetException, IllegalAccessException {
+        throws InvocationTargetException, IllegalAccessException
+    {
+        ensureInvocableMethod(m);
         return m.invoke(obj, params);
     }
 }
@@ -255,10 +275,6 @@
      */
     public static Object invoke(Method m, Object obj, Object[] params)
         throws InvocationTargetException, IllegalAccessException {
-        if (m.getDeclaringClass().equals(AccessController.class) ||
-            m.getDeclaringClass().equals(Method.class))
-            throw new InvocationTargetException(
-                new UnsupportedOperationException("invocation not supported"));
         try {
             return bounce.invoke(null, new Object[] {m, obj, params});
         } catch (InvocationTargetException ie) {
@@ -291,10 +307,10 @@
                             Method.class, Object.class, Object[].class
                         };
                         Method b = t.getDeclaredMethod("invoke", types);
-                    ((AccessibleObject)b).setAccessible(true);
-                    return b;
-                }
-            });
+                        b.setAccessible(true);
+                        return b;
+                    }
+                });
         } catch (Exception e) {
             throw new InternalError("bouncer cannot be found");
         }
--- jdk/src/share/classes/sun/reflect/misc/ReflectUtil.java	2012-08-10 10:29:15.000000000 -0700
+++ jdk/src/share/classes/sun/reflect/misc/ReflectUtil.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2013 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -144,4 +144,63 @@
         }
         return true;
     }
+
+    // Returns true if p is an ancestor of cl i.e. class loader 'p' can
+    // be found in the cl's delegation chain
+    private static boolean isAncestor(ClassLoader p, ClassLoader cl) {
+        ClassLoader acl = cl;
+        do {
+            acl = acl.getParent();
+            if (p == acl) {
+                return true;
+            }
+        } while (acl != null);
+        return false;
+    }
+
+    /**
+     * Returns true if package access check is needed for reflective
+     * access from a class loader 'from' to classes or members in
+     * a class defined by class loader 'to'.  This method returns true
+     * if 'from' is not the same as or an ancestor of 'to'.  All code
+     * in a system domain are granted with all permission and so this
+     * method returns false if 'from' class loader is a class loader
+     * loading system classes.  On the other hand, if a class loader
+     * attempts to access system domain classes, it requires package
+     * access check and this method will return true.
+     */
+    public static boolean needsPackageAccessCheck(ClassLoader from, ClassLoader to) {
+        if (from == null || from == to)
+            return false;
+
+        if (to == null)
+            return true;
+
+        return !isAncestor(from, to);
+    }
+
+    /**
+     * Access check on the interfaces that a proxy class implements and throw
+     * {@code SecurityException} if it accesses a restricted package.
+     *
+     * @param ccl the caller's class loader
+     * @param interfaces the list of interfaces that a proxy class implements
+     *
+     * @see Proxy#checkProxyAccess
+     */
+    public static void checkProxyPackageAccess(ClassLoader ccl,
+                                               Class<?>... interfaces)
+    {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            for (Class<?> intf : interfaces) {
+                ClassLoader cl = intf.getClassLoader();
+                if (needsPackageAccessCheck(ccl, cl)) {
+                    checkPackageAccess(intf);
+                }
+            }
+        }
+    }
+
+    public static final String PROXY_PACKAGE = "com.sun.proxy";
 }
--- jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java	2012-08-10 10:29:15.000000000 -0700
+++ jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java	2013-05-05 09:38:30.000000000 -0700
@@ -405,7 +405,8 @@
          */
         perms.add(new SocketPermission("*", "connect,accept"));
 
-        perms.add(new RuntimePermission("accessClassInPackage.sun.*"));
+        perms.add(new RuntimePermission("accessClassInPackage.sun.jvmstat.*"));
+        perms.add(new RuntimePermission("accessClassInPackage.sun.jvm.hotspot.*"));
 
         perms.add(new FilePermission("<<ALL FILES>>", "read"));
 
--- jdk/src/share/classes/sun/rmi/server/MarshalInputStream.java	2012-08-10 10:29:16.000000000 -0700
+++ jdk/src/share/classes/sun/rmi/server/MarshalInputStream.java	2013-05-05 09:38:30.000000000 -0700
@@ -55,13 +55,19 @@
 public class MarshalInputStream extends ObjectInputStream {
 
     /**
-     * value of "java.rmi.server.useCodebaseOnly" property,
+     * Value of "java.rmi.server.useCodebaseOnly" property,
      * as cached at class initialization time.
+     *
+     * The default value is true. That is, the value is true
+     * if the property is absent or is not equal to "false".
+     * The value is only false when the property is present
+     * and is equal to "false".
      */
     private static final boolean useCodebaseOnlyProperty =
-        java.security.AccessController.doPrivileged(
-            new sun.security.action.GetBooleanAction(
-                "java.rmi.server.useCodebaseOnly")).booleanValue();
+        ! java.security.AccessController.doPrivileged(
+            new sun.security.action.GetPropertyAction(
+                "java.rmi.server.useCodebaseOnly", "true"))
+            .equalsIgnoreCase("false");
 
     /** table to hold sun classes to which access is explicitly permitted */
     protected static Map<String, Class<?>> permittedSunClasses
--- jdk/src/share/classes/sun/rmi/transport/proxy/CGIHandler.java	2012-08-10 10:29:17.000000000 -0700
+++ jdk/src/share/classes/sun/rmi/transport/proxy/CGIHandler.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -150,7 +150,7 @@
                     returnServerError(e.getMessage());
                 }
             else
-                returnClientError("invalid command: " + command);
+                returnClientError("invalid command.");
         } catch (Exception e) {
             returnServerError("internal error: " + e.getMessage());
         }
@@ -217,7 +217,7 @@
         try {
             port = Integer.parseInt(param);
         } catch (NumberFormatException e) {
-            throw new CGIClientException("invalid port number: " + param);
+            throw new CGIClientException("invalid port number.");
         }
         if (port <= 0 || port > 0xFFFF)
             throw new CGIClientException("invalid port: " + port);
@@ -285,11 +285,14 @@
                     "unexpected EOF reading server response");
 
             if (line.toLowerCase().startsWith(key)) {
-                if (contentLengthFound)
-                    ; // what would we want to do in this case??
-                responseContentLength =
-                    Integer.parseInt(line.substring(key.length()).trim());
-                contentLengthFound = true;
+                if (contentLengthFound) {
+                    throw new CGIServerException(
+                            "Multiple Content-length entries found.");
+                } else {
+                    responseContentLength =
+                        Integer.parseInt(line.substring(key.length()).trim());
+                    contentLengthFound = true;
+                }
             }
         } while ((line.length() != 0) &&
                  (line.charAt(0) != '\r') && (line.charAt(0) != '\n'));
--- jdk/src/share/classes/sun/rmi/transport/proxy/HttpInputStream.java	2012-08-10 10:29:17.000000000 -0700
+++ jdk/src/share/classes/sun/rmi/transport/proxy/HttpInputStream.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -70,11 +70,14 @@
                 throw new EOFException();
 
             if (line.toLowerCase().startsWith(key)) {
-                if (contentLengthFound)
-                    ; // what would we want to do in this case??
-                bytesLeft =
-                    Integer.parseInt(line.substring(key.length()).trim());
-                contentLengthFound = true;
+                if (contentLengthFound) {
+                    throw new IOException(
+                            "Multiple Content-length entries found.");
+                } else {
+                    bytesLeft =
+                        Integer.parseInt(line.substring(key.length()).trim());
+                    contentLengthFound = true;
+                }
             }
 
             // The idea here is to go past the first blank line.
--- jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	2012-08-10 10:29:20.000000000 -0700
+++ jdk/src/share/classes/sun/security/jgss/wrapper/SunNativeProvider.java	2013-05-05 09:38:30.000000000 -0700
@@ -83,7 +83,8 @@
                             String osname = System.getProperty("os.name");
                             if (osname.startsWith("SunOS")) {
                                 gssLibs = new String[]{ "libgss.so" };
-                            } else if (osname.startsWith("Linux")) {
+                            } else if (osname.startsWith("Linux") ||
+                                       osname.endsWith("BSD")) {
                                 gssLibs = new String[]{
                                     "libgssapi.so",
                                     "libgssapi_krb5.so",
--- jdk/src/share/classes/sun/security/pkcs11/P11KeyAgreement.java	2012-08-10 10:29:23.000000000 -0700
+++ jdk/src/share/classes/sun/security/pkcs11/P11KeyAgreement.java	2013-05-05 09:38:30.000000000 -0700
@@ -37,6 +37,7 @@
 import static sun.security.pkcs11.TemplateManager.*;
 import sun.security.pkcs11.wrapper.*;
 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
+import sun.security.util.KeyUtil;
 
 /**
  * KeyAgreement implementation class. This class currently supports
@@ -134,6 +135,10 @@
         BigInteger p, g, y;
         if (key instanceof DHPublicKey) {
             DHPublicKey dhKey = (DHPublicKey)key;
+
+            // validate the Diffie-Hellman public key
+            KeyUtil.validate(dhKey);
+
             y = dhKey.getY();
             DHParameterSpec params = dhKey.getParams();
             p = params.getP();
@@ -145,6 +150,10 @@
             try {
                 DHPublicKeySpec spec = (DHPublicKeySpec)kf.engineGetKeySpec
                                                 (key, DHPublicKeySpec.class);
+
+                // validate the Diffie-Hellman public key
+                KeyUtil.validate(spec);
+
                 y = spec.getY();
                 p = spec.getP();
                 g = spec.getG();
--- jdk/src/share/classes/sun/security/provider/SecureRandom.java	2012-08-10 10:29:25.000000000 -0700
+++ jdk/src/share/classes/sun/security/provider/SecureRandom.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,12 +56,6 @@
 
     private static final long serialVersionUID = 3581829991155417889L;
 
-    /**
-     * This static object will be seeded by SeedGenerator, and used
-     * to seed future instances of SecureRandom
-     */
-    private static SecureRandom seeder;
-
     private static final int DIGEST_SIZE = 20;
     private transient MessageDigest digest;
     private byte[] state;
@@ -173,6 +167,28 @@
     }
 
     /**
+     * This static object will be seeded by SeedGenerator, and used
+     * to seed future instances of SHA1PRNG SecureRandoms.
+     *
+     * Bloch, Effective Java Second Edition: Item 71
+     */
+    private static class SeederHolder {
+
+        private static final SecureRandom seeder;
+
+        static {
+            /*
+             * Call to SeedGenerator.generateSeed() to add additional
+             * seed material (likely from the Native implementation).
+             */
+            seeder = new SecureRandom(SeedGenerator.getSystemEntropy());
+            byte [] b = new byte[DIGEST_SIZE];
+            SeedGenerator.generateSeed(b);
+            seeder.engineSetSeed(b);
+        }
+    }
+
+    /**
      * Generates a user-specified number of random bytes.
      *
      * @param bytes the array to be filled in with random bytes.
@@ -183,13 +199,8 @@
         byte[] output = remainder;
 
         if (state == null) {
-            if (seeder == null) {
-                seeder = new SecureRandom(SeedGenerator.getSystemEntropy());
-                seeder.engineSetSeed(engineGenerateSeed(DIGEST_SIZE));
-            }
-
             byte[] seed = new byte[DIGEST_SIZE];
-            seeder.engineNextBytes(seed);
+            SeederHolder.seeder.engineNextBytes(seed);
             state = digest.digest(seed);
         }
 
--- jdk/src/share/classes/sun/security/provider/certpath/OCSPChecker.java	2012-08-10 10:29:26.000000000 -0700
+++ jdk/src/share/classes/sun/security/provider/certpath/OCSPChecker.java	2013-05-05 09:38:30.000000000 -0700
@@ -257,18 +257,21 @@
                         }
                     }
 
-                    // Check that the key identifiers match
+                    // Check that the key identifiers match, if both are present
+                    byte[] anchorKeyId = null;
                     if (certIssuerKeyId != null &&
-                        !Arrays.equals(certIssuerKeyId, getKeyId(anchorCert))) {
-
-                        continue; // try next cert
-                    }
+                        (anchorKeyId =
+                            OCSPChecker.getKeyId(anchorCert)) != null) {
+                        if (!Arrays.equals(certIssuerKeyId, anchorKeyId)) {
+                            continue; // try next cert
+                        }
 
-                    if (DEBUG != null && certIssuerKeyId != null) {
-                        DEBUG.println("Issuer certificate key ID: " +
-                            String.format("0x%0" +
-                                (certIssuerKeyId.length * 2) + "x",
-                                    new BigInteger(1, certIssuerKeyId)));
+                        if (DEBUG != null) {
+                            DEBUG.println("Issuer certificate key ID: " +
+                                String.format("0x%0" +
+                                    (certIssuerKeyId.length * 2) + "x",
+                                        new BigInteger(1, certIssuerKeyId)));
+                        }
                     }
 
                     issuerCert = anchorCert;
--- jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java	2012-08-10 10:29:26.000000000 -0700
+++ jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java	2013-05-05 09:38:30.000000000 -0700
@@ -264,6 +264,7 @@
                 DEBUG.println("OCSP Responder name: " + responderName);
             }
         } else if (tag == KEY_TAG) {
+            seq = seq.data.getDerValue(); // consume tag and length
             if (DEBUG != null) {
                 byte[] responderKeyId = seq.getOctetString();
                 DEBUG.println("OCSP Responder key ID: " +
@@ -392,21 +393,29 @@
                     // Retrieve the issuer's key identifier
                     if (certIssuerKeyId == null) {
                         certIssuerKeyId = signerCert.getIssuerKeyIdentifier();
+                        if (certIssuerKeyId == null) {
+                            if (DEBUG != null) {
+                                DEBUG.println("No issuer key identifier (AKID) "
+                                    + "in the signer certificate");
+                            }
+                        }
                     }
 
-                    // Check that the key identifiers match
-                    if (certIssuerKeyId == null ||
-                        !Arrays.equals(certIssuerKeyId,
-                            OCSPChecker.getKeyId(responderCert))) {
-
-                        continue; // try next cert
-                    }
+                    // Check that the key identifiers match, if both are present
+                    byte[] responderKeyId = null;
+                    if (certIssuerKeyId != null &&
+                        (responderKeyId =
+                            OCSPChecker.getKeyId(responderCert)) != null) {
+                        if (!Arrays.equals(certIssuerKeyId, responderKeyId)) {
+                            continue; // try next cert
+                        }
 
-                    if (DEBUG != null) {
-                        DEBUG.println("Issuer certificate key ID: " +
-                            String.format("0x%0" +
-                                (certIssuerKeyId.length * 2) + "x",
-                                    new BigInteger(1, certIssuerKeyId)));
+                        if (DEBUG != null) {
+                            DEBUG.println("Issuer certificate key ID: " +
+                                String.format("0x%0" +
+                                    (certIssuerKeyId.length * 2) + "x",
+                                        new BigInteger(1, certIssuerKeyId)));
+                        }
                     }
 
                     // Check for the OCSPSigning key purpose
@@ -433,15 +442,11 @@
 
                     // Check the date validity
                     try {
-                        if (dateCheckedAgainst == null) {
-                            signerCert.checkValidity();
-                        } else {
-                            signerCert.checkValidity(dateCheckedAgainst);
-                        }
+                        signerCert.checkValidity();
                     } catch (GeneralSecurityException e) {
                         if (DEBUG != null) {
                             DEBUG.println("Responder's certificate not within" +
-                            " the validity period" + e);
+                            " the validity period " + e);
                         }
                         continue; // try next cert
                     }
--- jdk/src/share/classes/sun/security/ssl/CipherBox.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/CipherBox.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -393,7 +393,8 @@
      * uniformly use the bad_record_mac alert to hide the specific type of
      * the error.
      */
-    int decrypt(byte[] buf, int offset, int len) throws BadPaddingException {
+    int decrypt(byte[] buf, int offset, int len,
+            int tagLen) throws BadPaddingException {
         if (cipher == null) {
             return len;
         }
@@ -417,9 +418,10 @@
                         System.out);
                 } catch (IOException e) { }
             }
+
             if (blockSize != 0) {
-                newLen = removePadding(buf, offset, newLen,
-                             blockSize, protocolVersion);
+                newLen = removePadding(
+                    buf, offset, newLen, tagLen, blockSize, protocolVersion);
 
                 if (protocolVersion.v >= ProtocolVersion.TLS11.v) {
                     if (newLen < blockSize) {
@@ -449,7 +451,7 @@
      *
      *  @see decrypt(byte[], int, int)
      */
-    int decrypt(ByteBuffer bb) throws BadPaddingException {
+    int decrypt(ByteBuffer bb, int tagLen) throws BadPaddingException {
 
         int len = bb.remaining();
 
@@ -472,7 +474,6 @@
             }
 
             if (debug != null && Debug.isOn("plaintext")) {
-                bb.position(pos);
                 try {
                     HexDumpEncoder hd = new HexDumpEncoder();
 
@@ -480,7 +481,8 @@
                         "Padded plaintext after DECRYPTION:  len = "
                         + newLen);
 
-                    hd.encodeBuffer(bb, System.out);
+                    hd.encodeBuffer(
+                        (ByteBuffer)bb.duplicate().position(pos), System.out);
                 } catch (IOException e) { }
             }
 
@@ -489,7 +491,8 @@
              */
             if (blockSize != 0) {
                 bb.position(pos);
-                newLen = removePadding(bb, blockSize, protocolVersion);
+                newLen = removePadding(
+                    bb, tagLen, blockSize, protocolVersion);
 
                 if (protocolVersion.v >= ProtocolVersion.TLS11.v) {
                     if (newLen < blockSize) {
@@ -591,6 +594,65 @@
         return newlen;
     }
 
+    /*
+     * A constant-time check of the padding.
+     *
+     * NOTE that we are checking both the padding and the padLen bytes here.
+     *
+     * The caller MUST ensure that the len parameter is a positive number.
+     */
+    private static int[] checkPadding(
+            byte[] buf, int offset, int len, byte pad) {
+
+        if (len <= 0) {
+            throw new RuntimeException("padding len must be positive");
+        }
+
+        // An array of hits is used to prevent Hotspot optimization for
+        // the purpose of a constant-time check.
+        int[] results = {0, 0};    // {missed #, matched #}
+        for (int i = 0; i <= 256;) {
+            for (int j = 0; j < len && i <= 256; j++, i++) {     // j <= i
+                if (buf[offset + j] != pad) {
+                    results[0]++;       // mismatched padding data
+                } else {
+                    results[1]++;       // matched padding data
+                }
+            }
+        }
+
+        return results;
+    }
+
+    /*
+     * A constant-time check of the padding.
+     *
+     * NOTE that we are checking both the padding and the padLen bytes here.
+     *
+     * The caller MUST ensure that the bb parameter has remaining.
+     */
+    private static int[] checkPadding(ByteBuffer bb, byte pad) {
+
+        if (!bb.hasRemaining()) {
+            throw new RuntimeException("hasRemaining() must be positive");
+        }
+
+        // An array of hits is used to prevent Hotspot optimization for
+        // the purpose of a constant-time check.
+        int[] results = {0, 0};    // {missed #, matched #}
+        bb.mark();
+        for (int i = 0; i <= 256; bb.reset()) {
+            for (; bb.hasRemaining() && i <= 256; i++) {
+                if (bb.get() != pad) {
+                    results[0]++;       // mismatched padding data
+                } else {
+                    results[1]++;       // matched padding data
+                }
+            }
+        }
+
+        return results;
+    }
 
     /*
      * Typical TLS padding format for a 64 bit block cipher is as follows:
@@ -603,86 +665,95 @@
      * as it makes the data a multiple of the block size
      */
     private static int removePadding(byte[] buf, int offset, int len,
-            int blockSize, ProtocolVersion protocolVersion)
-            throws BadPaddingException {
+            int tagLen, int blockSize,
+            ProtocolVersion protocolVersion) throws BadPaddingException {
+
         // last byte is length byte (i.e. actual padding length - 1)
         int padOffset = offset + len - 1;
-        int pad = buf[padOffset] & 0x0ff;
-
-        int newlen = len - (pad + 1);
-        if (newlen < 0) {
-            throw new BadPaddingException("Padding length invalid: " + pad);
-        }
+        int padLen = buf[padOffset] & 0xFF;
 
+        int newLen = len - (padLen + 1);
+        if ((newLen - tagLen) < 0) {
+            // If the buffer is not long enough to contain the padding plus
+            // a MAC tag, do a dummy constant-time padding check.
+            //
+            // Note that it is a dummy check, so we won't care about what is
+            // the actual padding data.
+            checkPadding(buf, offset, len, (byte)(padLen & 0xFF));
+
+            throw new BadPaddingException("Invalid Padding length: " + padLen);
+        }
+
+        // The padding data should be filled with the padding length value.
+        int[] results = checkPadding(buf, offset + newLen,
+                        padLen + 1, (byte)(padLen & 0xFF));
         if (protocolVersion.v >= ProtocolVersion.TLS10.v) {
-            for (int i = 1; i <= pad; i++) {
-                int val = buf[padOffset - i] & 0xff;
-                if (val != pad) {
-                    throw new BadPaddingException
-                                        ("Invalid TLS padding: " + val);
-                }
+            if (results[0] != 0) {          // padding data has invalid bytes
+                throw new BadPaddingException("Invalid TLS padding data");
             }
         } else { // SSLv3
             // SSLv3 requires 0 <= length byte < block size
             // some implementations do 1 <= length byte <= block size,
             // so accept that as well
             // v3 does not require any particular value for the other bytes
-            if (pad > blockSize) {
-                throw new BadPaddingException("Invalid SSLv3 padding: " + pad);
+            if (padLen > blockSize) {
+                throw new BadPaddingException("Invalid SSLv3 padding");
             }
         }
-        return newlen;
+        return newLen;
     }
 
     /*
      * Position/limit is equal the removed padding.
      */
     private static int removePadding(ByteBuffer bb,
-            int blockSize, ProtocolVersion protocolVersion)
-            throws BadPaddingException {
+            int tagLen, int blockSize,
+            ProtocolVersion protocolVersion) throws BadPaddingException {
 
         int len = bb.remaining();
         int offset = bb.position();
 
         // last byte is length byte (i.e. actual padding length - 1)
         int padOffset = offset + len - 1;
-        int pad = bb.get(padOffset) & 0x0ff;
+        int padLen = bb.get(padOffset) & 0xFF;
 
-        int newlen = len - (pad + 1);
-        if (newlen < 0) {
-            throw new BadPaddingException("Padding length invalid: " + pad);
-        }
-
-        /*
-         * We could zero the padding area, but not much useful
-         * information there.
-         */
+        int newLen = len - (padLen + 1);
+        if ((newLen - tagLen) < 0) {
+            // If the buffer is not long enough to contain the padding plus
+            // a MAC tag, do a dummy constant-time padding check.
+            //
+            // Note that it is a dummy check, so we won't care about what is
+            // the actual padding data.
+            checkPadding(bb.duplicate(), (byte)(padLen & 0xFF));
+
+            throw new BadPaddingException("Invalid Padding length: " + padLen);
+        }
+
+        // The padding data should be filled with the padding length value.
+        int[] results = checkPadding(
+                (ByteBuffer)bb.duplicate().position(offset + newLen),
+                (byte)(padLen & 0xFF));
         if (protocolVersion.v >= ProtocolVersion.TLS10.v) {
-            bb.put(padOffset, (byte)0);         // zero the padding.
-            for (int i = 1; i <= pad; i++) {
-                int val = bb.get(padOffset - i) & 0xff;
-                if (val != pad) {
-                    throw new BadPaddingException
-                                        ("Invalid TLS padding: " + val);
-                }
+            if (results[0] != 0) {          // padding data has invalid bytes
+                throw new BadPaddingException("Invalid TLS padding data");
             }
         } else { // SSLv3
             // SSLv3 requires 0 <= length byte < block size
             // some implementations do 1 <= length byte <= block size,
             // so accept that as well
             // v3 does not require any particular value for the other bytes
-            if (pad > blockSize) {
-                throw new BadPaddingException("Invalid SSLv3 padding: " + pad);
+            if (padLen > blockSize) {
+                throw new BadPaddingException("Invalid SSLv3 padding");
             }
         }
 
         /*
          * Reset buffer limit to remove padding.
          */
-        bb.position(offset + newlen);
-        bb.limit(offset + newlen);
+        bb.position(offset + newLen);
+        bb.limit(offset + newLen);
 
-        return newlen;
+        return newLen;
     }
 
     /*
@@ -709,4 +780,45 @@
     boolean isCBCMode() {
         return isCBCMode;
     }
+
+    /**
+     * Is the cipher null?
+     *
+     * @return true if the cipher is null, false otherwise.
+     */
+    boolean isNullCipher() {
+        return cipher == null;
+    }
+
+    /**
+     * Sanity check the length of a fragment before decryption.
+     *
+     * In CBC mode, check that the fragment length is one or multiple times
+     * of the block size of the cipher suite, and is at least one (one is the
+     * smallest size of padding in CBC mode) bigger than the tag size of the
+     * MAC algorithm except the explicit IV size for TLS 1.1 or later.
+     *
+     * In non-CBC mode, check that the fragment length is not less than the
+     * tag size of the MAC algorithm.
+     *
+     * @return true if the length of a fragment matches above requirements
+     */
+    boolean sanityCheck(int tagLen, int fragmentLen) {
+        if (!isCBCMode) {
+            return fragmentLen >= tagLen;
+        }
+
+        if ((fragmentLen % blockSize) == 0) {
+            int minimal = tagLen + 1;
+            minimal = (minimal >= blockSize) ? minimal : blockSize;
+            if (protocolVersion.v >= ProtocolVersion.TLS11.v) {
+                minimal += blockSize;   // plus the size of the explicit IV
+            }
+
+            return (fragmentLen >= minimal);
+        }
+
+        return false;
+    }
+
 }
--- jdk/src/share/classes/sun/security/ssl/CipherSuite.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/CipherSuite.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -534,9 +534,18 @@
         // size of the MAC value (and MAC key) in bytes
         final int size;
 
-        MacAlg(String name, int size) {
+        // block size of the underlying hash algorithm
+        final int hashBlockSize;
+
+        // minimal padding size of the underlying hash algorithm
+        final int minimalPaddingSize;
+
+        MacAlg(String name, int size,
+                int hashBlockSize, int minimalPaddingSize) {
             this.name = name;
             this.size = size;
+            this.hashBlockSize = hashBlockSize;
+            this.minimalPaddingSize = minimalPaddingSize;
         }
 
         /**
@@ -580,11 +589,11 @@
                         new BulkCipher(CIPHER_AES,     32, 16, true);
 
     // MACs
-    final static MacAlg M_NULL = new MacAlg("NULL", 0);
-    final static MacAlg M_MD5  = new MacAlg("MD5", 16);
-    final static MacAlg M_SHA  = new MacAlg("SHA", 20);
-    final static MacAlg M_SHA256  = new MacAlg("SHA256", 32);
-    final static MacAlg M_SHA384  = new MacAlg("SHA384", 48);
+    final static MacAlg M_NULL    = new MacAlg("NULL",     0,   0,   0);
+    final static MacAlg M_MD5     = new MacAlg("MD5",     16,  64,   9);
+    final static MacAlg M_SHA     = new MacAlg("SHA",     20,  64,   9);
+    final static MacAlg M_SHA256  = new MacAlg("SHA256",  32,  64,   9);
+    final static MacAlg M_SHA384  = new MacAlg("SHA384",  48, 128,  17);
 
     /**
      * PRFs (PseudoRandom Function) from TLS specifications.
--- jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	2013-05-05 09:38:30.000000000 -0700
@@ -128,9 +128,8 @@
      * in the constructor.
      */
     void processMessage(byte type, int messageLen) throws IOException {
-        if (state > type
-                && (type != HandshakeMessage.ht_hello_request
-                    && state != HandshakeMessage.ht_client_hello)) {
+        if (state >= type
+                && (type != HandshakeMessage.ht_hello_request)) {
             throw new SSLProtocolException(
                     "Handshake message sequence violation, " + type);
         }
@@ -193,8 +192,12 @@
                 }
                 break;
             case K_DH_ANON:
-                this.serverKeyExchange(new DH_ServerKeyExchange(
+                try {
+                    this.serverKeyExchange(new DH_ServerKeyExchange(
                                                 input, protocolVersion));
+                } catch (GeneralSecurityException e) {
+                    throwSSLException("Server key", e);
+                }
                 break;
             case K_DHE_DSS:
             case K_DHE_RSA:
@@ -922,7 +925,7 @@
         case K_DHE_RSA:
         case K_DHE_DSS:
         case K_DH_ANON:
-            preMasterSecret = dh.getAgreedSecret(serverDH);
+            preMasterSecret = dh.getAgreedSecret(serverDH, true);
             break;
         case K_ECDHE_RSA:
         case K_ECDHE_ECDSA:
--- jdk/src/share/classes/sun/security/ssl/DHClientKeyExchange.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/DHClientKeyExchange.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,7 +29,7 @@
 import java.io.IOException;
 import java.io.PrintStream;
 import java.math.BigInteger;
-
+import javax.net.ssl.SSLHandshakeException;
 
 /*
  * Message used by clients to send their Diffie-Hellman public
@@ -50,7 +50,7 @@
     private byte dh_Yc[];               // 1 to 2^16 -1 bytes
 
     BigInteger getClientPublicKey() {
-        return new BigInteger(1, dh_Yc);
+        return dh_Yc == null ? null : new BigInteger(1, dh_Yc);
     }
 
     /*
@@ -72,7 +72,14 @@
      * but that's what the protocol spec requires.)
      */
     DHClientKeyExchange(HandshakeInStream input) throws IOException {
-        dh_Yc = input.getBytes16();
+        if (input.available() >= 2) {
+            dh_Yc = input.getBytes16();
+        } else {
+            // currently, we don't support cipher suites that requires
+            // implicit public key of client.
+            throw new SSLHandshakeException(
+                    "Unsupported implicit client DiffieHellman public key");
+        }
     }
 
     int messageLength() {
@@ -84,7 +91,9 @@
     }
 
     void send(HandshakeOutStream s) throws IOException {
-        s.putBytes16(dh_Yc);
+        if (dh_Yc != null && dh_Yc.length != 0) {
+            s.putBytes16(dh_Yc);
+        }
     }
 
     void print(PrintStream s) throws IOException {
--- jdk/src/share/classes/sun/security/ssl/DHCrypt.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/DHCrypt.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,12 +28,15 @@
 
 import java.math.BigInteger;
 import java.security.*;
-
+import java.io.IOException;
+import javax.net.ssl.SSLHandshakeException;
 import javax.crypto.SecretKey;
 import javax.crypto.KeyAgreement;
 import javax.crypto.interfaces.DHPublicKey;
 import javax.crypto.spec.*;
 
+import sun.security.util.KeyUtil;
+
 /**
  * This class implements the Diffie-Hellman key exchange algorithm.
  * D-H means combining your private key with your partners public key to
@@ -54,7 +57,8 @@
  *  . if we are server, call DHCrypt(keyLength,random). This generates
  *    an ephemeral keypair of the request length.
  *  . if we are client, call DHCrypt(modulus, base, random). This
- *    generates an ephemeral keypair using the parameters specified by the server.
+ *    generates an ephemeral keypair using the parameters specified by
+ *    the server.
  *  . send parameters and public value to remote peer
  *  . receive peers ephemeral public key
  *  . call getAgreedSecret() to calculate the shared secret
@@ -83,6 +87,9 @@
     // public component of our key, X = (g ^ x) mod p
     private BigInteger publicValue;             // X (aka y)
 
+    // the times to recove from failure if public key validation
+    private static int MAX_FAILOVER_TIMES = 2;
+
     /**
      * Generate a Diffie-Hellman keypair of the specified size.
      */
@@ -90,9 +97,12 @@
         try {
             KeyPairGenerator kpg = JsseJce.getKeyPairGenerator("DiffieHellman");
             kpg.initialize(keyLength, random);
-            KeyPair kp = kpg.generateKeyPair();
-            privateKey = kp.getPrivate();
-            DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
+
+            DHPublicKeySpec spec = generateDHPublicKeySpec(kpg);
+            if (spec == null) {
+                throw new RuntimeException("Could not generate DH keypair");
+            }
+
             publicValue = spec.getY();
             modulus = spec.getP();
             base = spec.getG();
@@ -115,20 +125,25 @@
             KeyPairGenerator kpg = JsseJce.getKeyPairGenerator("DiffieHellman");
             DHParameterSpec params = new DHParameterSpec(modulus, base);
             kpg.initialize(params, random);
-            KeyPair kp = kpg.generateKeyPair();
-            privateKey = kp.getPrivate();
-            DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
+
+            DHPublicKeySpec spec = generateDHPublicKeySpec(kpg);
+            if (spec == null) {
+                throw new RuntimeException("Could not generate DH keypair");
+            }
+
             publicValue = spec.getY();
         } catch (GeneralSecurityException e) {
             throw new RuntimeException("Could not generate DH keypair", e);
         }
     }
 
+
     static DHPublicKeySpec getDHPublicKeySpec(PublicKey key) {
         if (key instanceof DHPublicKey) {
             DHPublicKey dhKey = (DHPublicKey)key;
             DHParameterSpec params = dhKey.getParams();
-            return new DHPublicKeySpec(dhKey.getY(), params.getP(), params.getG());
+            return new DHPublicKeySpec(dhKey.getY(),
+                                    params.getP(), params.getG());
         }
         try {
             KeyFactory factory = JsseJce.getKeyFactory("DH");
@@ -166,17 +181,32 @@
      * <P>It is illegal to call this member function if the private key
      * has not been set (or generated).
      *
-     * @param peerPublicKey the peer's public key.
-     * @returns the secret, which is an unsigned big-endian integer
-     *  the same size as the Diffie-Hellman modulus.
+     * @param  peerPublicKey the peer's public key.
+     * @param  keyIsValidated whether the {@code peerPublicKey} has beed
+     *         validated
+     * @return the secret, which is an unsigned big-endian integer
+     *         the same size as the Diffie-Hellman modulus.
      */
-    SecretKey getAgreedSecret(BigInteger peerPublicValue) {
+    SecretKey getAgreedSecret(BigInteger peerPublicValue,
+            boolean keyIsValidated) throws IOException {
         try {
             KeyFactory kf = JsseJce.getKeyFactory("DiffieHellman");
             DHPublicKeySpec spec =
                         new DHPublicKeySpec(peerPublicValue, modulus, base);
             PublicKey publicKey = kf.generatePublic(spec);
             KeyAgreement ka = JsseJce.getKeyAgreement("DiffieHellman");
+
+            // validate the Diffie-Hellman public key
+            if (!keyIsValidated &&
+                    !KeyUtil.isOracleJCEProvider(ka.getProvider().getName())) {
+                try {
+                    KeyUtil.validate(spec);
+                } catch (InvalidKeyException ike) {
+                    // prefer handshake_failure alert to internal_error alert
+                    throw new SSLHandshakeException(ike.getMessage());
+                }
+            }
+
             ka.init(privateKey);
             ka.doPhase(publicKey, true);
             return ka.generateSecret("TlsPremasterSecret");
@@ -185,4 +215,33 @@
         }
     }
 
+    // Generate and validate DHPublicKeySpec
+    private DHPublicKeySpec generateDHPublicKeySpec(KeyPairGenerator kpg)
+            throws GeneralSecurityException {
+
+        boolean doExtraValiadtion =
+                    (!KeyUtil.isOracleJCEProvider(kpg.getProvider().getName()));
+        for (int i = 0; i <= MAX_FAILOVER_TIMES; i++) {
+            KeyPair kp = kpg.generateKeyPair();
+            privateKey = kp.getPrivate();
+            DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
+
+            // validate the Diffie-Hellman public key
+            if (doExtraValiadtion) {
+                try {
+                    KeyUtil.validate(spec);
+                } catch (InvalidKeyException ivke) {
+                    if (i == MAX_FAILOVER_TIMES) {
+                        throw ivke;
+                    }
+                    // otherwise, ignore the exception and try the next one
+                    continue;
+                }
+            }
+
+            return spec;
+        }
+
+        return null;
+    }
 }
--- jdk/src/share/classes/sun/security/ssl/EngineInputRecord.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/EngineInputRecord.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -177,91 +177,169 @@
     }
 
     /*
-     * Verifies and removes the MAC value.  Returns true if
-     * the MAC checks out OK.
+     * Pass the data down if it's internally cached, otherwise
+     * do it here.
      *
-     * On entry:
-     *     position = beginning of app/MAC data
-     *     limit = end of MAC data.
+     * If internal data, data is decrypted internally.
      *
-     * On return:
-     *     position = beginning of app data
-     *     limit = end of app data
+     * If external data(app), return a new ByteBuffer with data to
+     * process.
      */
-    boolean checkMAC(MAC signer, ByteBuffer bb) {
+    ByteBuffer decrypt(MAC signer,
+            CipherBox box, ByteBuffer bb) throws BadPaddingException {
+
         if (internalData) {
-            return checkMAC(signer);
+            decrypt(signer, box);   // MAC is checked during decryption
+            return tmpBB;
         }
 
-        int len = signer.MAClen();
-        if (len == 0) { // no mac
-            return true;
+        BadPaddingException reservedBPE = null;
+        int tagLen = signer.MAClen();
+        int cipheredLength = bb.remaining();
+
+        if (!box.isNullCipher()) {
+            // sanity check length of the ciphertext
+            if (!box.sanityCheck(tagLen, cipheredLength)) {
+                throw new BadPaddingException(
+                    "ciphertext sanity check failed");
+            }
+
+            try {
+                // Note that the CipherBox.decrypt() does not change
+                // the capacity of the buffer.
+                box.decrypt(bb, tagLen);
+            } catch (BadPaddingException bpe) {
+                // RFC 2246 states that decryption_failed should be used
+                // for this purpose. However, that allows certain attacks,
+                // so we just send bad record MAC. We also need to make
+                // sure to always check the MAC to avoid a timing attack
+                // for the same issue. See paper by Vaudenay et al and the
+                // update in RFC 4346/5246.
+                //
+                // Failover to message authentication code checking.
+                reservedBPE = bpe;
+            } finally {
+                bb.rewind();
+            }
         }
 
-        /*
-         * Grab the original limit
-         */
-        int lim = bb.limit();
+        if (tagLen != 0) {
+            int macOffset = bb.limit() - tagLen;
 
-        /*
-         * Delineate the area to apply a MAC on.
-         */
-        int macData = lim - len;
-        bb.limit(macData);
+            // Note that although it is not necessary, we run the same MAC
+            // computation and comparison on the payload for both stream
+            // cipher and CBC block cipher.
+            if (bb.remaining() < tagLen) {
+                // negative data length, something is wrong
+                if (reservedBPE == null) {
+                    reservedBPE = new BadPaddingException("bad record");
+                }
+
+                // set offset of the dummy MAC
+                macOffset = cipheredLength - tagLen;
+                bb.limit(cipheredLength);
+            }
+
+            // Run MAC computation and comparison on the payload.
+            if (checkMacTags(contentType(), bb, signer, false)) {
+                if (reservedBPE == null) {
+                    reservedBPE = new BadPaddingException("bad record MAC");
+                }
+            }
 
-        byte[] mac = signer.compute(contentType(), bb);
+            // Run MAC computation and comparison on the remainder.
+            //
+            // It is only necessary for CBC block cipher.  It is used to get a
+            // constant time of MAC computation and comparison on each record.
+            if (box.isCBCMode()) {
+                int remainingLen = calculateRemainingLen(
+                                        signer, cipheredLength, macOffset);
+
+                // NOTE: here we use the InputRecord.buf because I did not find
+                // an effective way to work on ByteBuffer when its capacity is
+                // less than remainingLen.
+
+                // NOTE: remainingLen may be bigger (less than 1 block of the
+                // hash algorithm of the MAC) than the cipheredLength. However,
+                // We won't need to worry about it because we always use a
+                // maximum buffer for every record.  We need a change here if
+                // we use small buffer size in the future.
+                if (remainingLen > buf.length) {
+                    // unlikely to happen, just a placehold
+                    throw new RuntimeException(
+                        "Internal buffer capacity error");
+                }
+
+                // Won't need to worry about the result on the remainder. And
+                // then we won't need to worry about what's actual data to
+                // check MAC tag on.  We start the check from the header of the
+                // buffer so that we don't need to construct a new byte buffer.
+                checkMacTags(contentType(), buf, 0, remainingLen, signer, true);
+            }
+
+            bb.limit(macOffset);
+        }
+
+        // Is it a failover?
+        if (reservedBPE != null) {
+            throw reservedBPE;
+        }
 
-        if (len != mac.length) {
+        return bb.slice();
+    }
+
+    /*
+     * Run MAC computation and comparison
+     *
+     * Please DON'T change the content of the ByteBuffer parameter!
+     */
+    private static boolean checkMacTags(byte contentType, ByteBuffer bb,
+            MAC signer, boolean isSimulated) {
+
+        int tagLen = signer.MAClen();
+        int lim = bb.limit();
+        int macData = lim - tagLen;
+
+        bb.limit(macData);
+        byte[] hash = signer.compute(contentType, bb, isSimulated);
+        if (hash == null || tagLen != hash.length) {
+            // Something is wrong with MAC implementation.
             throw new RuntimeException("Internal MAC error");
         }
 
-        /*
-         * Delineate the MAC values, position was already set
-         * by doing the compute above.
-         *
-         * We could zero the MAC area, but not much useful information
-         * there anyway.
-         */
         bb.position(macData);
         bb.limit(lim);
-
         try {
-            for (int i = 0; i < len; i++) {
-                if (bb.get() != mac[i]) {  // No BB.equals(byte []); !
-                    return false;
-                }
-            }
-            return true;
+            int[] results = compareMacTags(bb, hash);
+            return (results[0] != 0);
         } finally {
-            /*
-             * Position to the data.
-             */
             bb.rewind();
             bb.limit(macData);
         }
     }
 
     /*
-     * Pass the data down if it's internally cached, otherwise
-     * do it here.
+     * A constant-time comparison of the MAC tags.
      *
-     * If internal data, data is decrypted internally.
-     *
-     * If external data(app), return a new ByteBuffer with data to
-     * process.
+     * Please DON'T change the content of the ByteBuffer parameter!
      */
-    ByteBuffer decrypt(CipherBox box, ByteBuffer bb)
-            throws BadPaddingException {
+    private static int[] compareMacTags(ByteBuffer bb, byte[] tag) {
 
-        if (internalData) {
-            decrypt(box);
-            return tmpBB;
+        // An array of hits is used to prevent Hotspot optimization for
+        // the purpose of a constant-time check.
+        int[] results = {0, 0};     // {missed #, matched #}
+
+        // The caller ensures there are enough bytes available in the buffer.
+        // So we won't need to check the remaining of the buffer.
+        for (int i = 0; i < tag.length; i++) {
+            if (bb.get() != tag[i]) {
+                results[0]++;       // mismatched bytes
+            } else {
+                results[1]++;       // matched bytes
+            }
         }
 
-        box.decrypt(bb);
-        bb.rewind();
-
-        return bb.slice();
+        return results;
     }
 
     /*
--- jdk/src/share/classes/sun/security/ssl/EngineOutputRecord.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/EngineOutputRecord.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -120,7 +120,7 @@
             throws IOException {
 
         if (signer.MAClen() != 0) {
-            byte[] hash = signer.compute(contentType(), bb);
+            byte[] hash = signer.compute(contentType(), bb, false);
 
             /*
              * position was advanced to limit in compute above.
--- jdk/src/share/classes/sun/security/ssl/HandshakeInStream.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/HandshakeInStream.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -190,6 +190,7 @@
 
     byte[] getBytes8() throws IOException {
         int len = getInt8();
+        verifyLength(len);
         byte b[] = new byte[len];
 
         read(b, 0, len);
@@ -198,6 +199,7 @@
 
     public byte[] getBytes16() throws IOException {
         int len = getInt16();
+        verifyLength(len);
         byte b[] = new byte[len];
 
         read(b, 0, len);
@@ -206,10 +208,19 @@
 
     byte[] getBytes24() throws IOException {
         int len = getInt24();
+        verifyLength(len);
         byte b[] = new byte[len];
 
         read(b, 0, len);
         return b;
     }
 
+    // Is a length greater than available bytes in the record?
+    private void verifyLength(int len) throws SSLException {
+        if (len > available()) {
+            throw new SSLException(
+                        "Not enough data to fill declared vector size");
+        }
+    }
+
 }
--- jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,12 +41,14 @@
 
 import javax.crypto.KeyGenerator;
 import javax.crypto.SecretKey;
+import javax.crypto.spec.DHPublicKeySpec;
 
 import javax.net.ssl.*;
 
 import sun.security.internal.spec.TlsPrfParameterSpec;
 import sun.security.ssl.CipherSuite.*;
 import static sun.security.ssl.CipherSuite.PRF.*;
+import sun.security.util.KeyUtil;
 
 /**
  * Many data structures are involved in the handshake messages.  These
@@ -702,6 +704,7 @@
         this.protocolVersion = protocolVersion;
         this.preferableSignatureAlgorithm = null;
 
+        // The DH key has been validated in the constructor of DHCrypt.
         setValues(obj);
         signature = null;
     }
@@ -718,6 +721,7 @@
 
         this.protocolVersion = protocolVersion;
 
+        // The DH key has been validated in the constructor of DHCrypt.
         setValues(obj);
 
         Signature sig;
@@ -744,7 +748,8 @@
      * DH_anon key exchange
      */
     DH_ServerKeyExchange(HandshakeInStream input,
-            ProtocolVersion protocolVersion) throws IOException {
+            ProtocolVersion protocolVersion)
+            throws IOException, GeneralSecurityException {
 
         this.protocolVersion = protocolVersion;
         this.preferableSignatureAlgorithm = null;
@@ -752,6 +757,10 @@
         dh_p = input.getBytes16();
         dh_g = input.getBytes16();
         dh_Ys = input.getBytes16();
+        KeyUtil.validate(new DHPublicKeySpec(new BigInteger(1, dh_Ys),
+                                             new BigInteger(1, dh_p),
+                                             new BigInteger(1, dh_g)));
+
         signature = null;
     }
 
@@ -772,6 +781,9 @@
         dh_p = input.getBytes16();
         dh_g = input.getBytes16();
         dh_Ys = input.getBytes16();
+        KeyUtil.validate(new DHPublicKeySpec(new BigInteger(1, dh_Ys),
+                                             new BigInteger(1, dh_p),
+                                             new BigInteger(1, dh_g)));
 
         // read the signature and hash algorithm
         if (protocolVersion.v >= ProtocolVersion.TLS12.v) {
--- jdk/src/share/classes/sun/security/ssl/Handshaker.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/Handshaker.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1063,7 +1063,6 @@
             if (debug != null && Debug.isOn("handshake")) {
                 System.out.println("RSA master secret generation error:");
                 e.printStackTrace(System.out);
-                System.out.println("Generating new random premaster secret");
             }
 
             if (requestedVersion != null) {
@@ -1130,7 +1129,6 @@
             System.out.println("RSA PreMasterSecret version error: expected"
                 + protocolVersion + " or " + requestedVersion + ", decrypted: "
                 + premasterVersion);
-            System.out.println("Generating new random premaster secret");
         }
         preMasterSecret =
             RSAClientKeyExchange.generateDummySecret(requestedVersion);
--- jdk/src/share/classes/sun/security/ssl/InputRecord.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/InputRecord.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -135,43 +135,173 @@
         return handshakeHash;
     }
 
-    /*
-     * Verify and remove the MAC ... used for all records.
-     */
-    boolean checkMAC(MAC signer) {
-        int len = signer.MAClen();
-        if (len == 0) { // no mac
-            return true;
+    void decrypt(MAC signer, CipherBox box) throws BadPaddingException {
+
+        BadPaddingException reservedBPE = null;
+        int tagLen = signer.MAClen();
+        int cipheredLength = count - headerSize;
+
+        if (!box.isNullCipher()) {
+            // sanity check length of the ciphertext
+            if (!box.sanityCheck(tagLen, cipheredLength)) {
+                throw new BadPaddingException(
+                    "ciphertext sanity check failed");
+            }
+
+            try {
+                // Note that the CipherBox.decrypt() does not change
+                // the capacity of the buffer.
+                count = headerSize +
+                        box.decrypt(buf, headerSize, cipheredLength, tagLen);
+            } catch (BadPaddingException bpe) {
+                // RFC 2246 states that decryption_failed should be used
+                // for this purpose. However, that allows certain attacks,
+                // so we just send bad record MAC. We also need to make
+                // sure to always check the MAC to avoid a timing attack
+                // for the same issue. See paper by Vaudenay et al and the
+                // update in RFC 4346/5246.
+                //
+                // Failover to message authentication code checking.
+                reservedBPE = bpe;
+            }
         }
 
-        int offset = count - len;
+        if (tagLen != 0) {
+            int macOffset = count - tagLen;
+            int contentLen = macOffset - headerSize;
+
+            // Note that although it is not necessary, we run the same MAC
+            // computation and comparison on the payload for both stream
+            // cipher and CBC block cipher.
+            if (contentLen < 0) {
+                // negative data length, something is wrong
+                if (reservedBPE == null) {
+                    reservedBPE = new BadPaddingException("bad record");
+                }
 
-        if (offset < headerSize) {
-            // data length would be negative, something is wrong
-            return false;
+                // set offset of the dummy MAC
+                macOffset = headerSize + cipheredLength - tagLen;
+                contentLen = macOffset - headerSize;
+            }
+
+            count -= tagLen;  // Set the count before any MAC checking
+                              // exception occurs, so that the following
+                              // process can read the actual decrypted
+                              // content (minus the MAC) in the fragment
+                              // if necessary.
+
+            // Run MAC computation and comparison on the payload.
+            if (checkMacTags(contentType(),
+                    buf, headerSize, contentLen, signer, false)) {
+                if (reservedBPE == null) {
+                    reservedBPE = new BadPaddingException("bad record MAC");
+                }
+            }
+
+            // Run MAC computation and comparison on the remainder.
+            //
+            // It is only necessary for CBC block cipher.  It is used to get a
+            // constant time of MAC computation and comparison on each record.
+            if (box.isCBCMode()) {
+                int remainingLen = calculateRemainingLen(
+                                        signer, cipheredLength, contentLen);
+
+                // NOTE: remainingLen may be bigger (less than 1 block of the
+                // hash algorithm of the MAC) than the cipheredLength. However,
+                // We won't need to worry about it because we always use a
+                // maximum buffer for every record.  We need a change here if
+                // we use small buffer size in the future.
+                if (remainingLen > buf.length) {
+                    // unlikely to happen, just a placehold
+                    throw new RuntimeException(
+                        "Internal buffer capacity error");
+                }
+
+                // Won't need to worry about the result on the remainder. And
+                // then we won't need to worry about what's actual data to
+                // check MAC tag on.  We start the check from the header of the
+                // buffer so that we don't need to construct a new byte buffer.
+                checkMacTags(contentType(), buf, 0, remainingLen, signer, true);
+            }
+        }
+
+        // Is it a failover?
+        if (reservedBPE != null) {
+            throw reservedBPE;
         }
+    }
 
-        byte[] mac = signer.compute(contentType(), buf,
-            headerSize, offset - headerSize);
+    /*
+     * Run MAC computation and comparison
+     *
+     * Please DON'T change the content of the byte buffer parameter!
+     */
+    static boolean checkMacTags(byte contentType, byte[] buffer,
+            int offset, int contentLen, MAC signer, boolean isSimulated) {
 
-        if (len != mac.length) {
+        int tagLen = signer.MAClen();
+        byte[] hash = signer.compute(
+                contentType, buffer, offset, contentLen, isSimulated);
+        if (hash == null || tagLen != hash.length) {
+            // Something is wrong with MAC implementation.
             throw new RuntimeException("Internal MAC error");
         }
 
-        for (int i = 0; i < len; i++) {
-            if (buf[offset + i] != mac[i]) {
-                return false;
+        int[] results = compareMacTags(buffer, offset + contentLen, hash);
+        return (results[0] != 0);
+    }
+
+    /*
+     * A constant-time comparison of the MAC tags.
+     *
+     * Please DON'T change the content of the byte buffer parameter!
+     */
+    private static int[] compareMacTags(
+            byte[] buffer, int offset, byte[] tag) {
+
+        // An array of hits is used to prevent Hotspot optimization for
+        // the purpose of a constant-time check.
+        int[] results = {0, 0};    // {missed #, matched #}
+
+        // The caller ensures there are enough bytes available in the buffer.
+        // So we won't need to check the length of the buffer.
+        for (int i = 0; i < tag.length; i++) {
+            if (buffer[offset + i] != tag[i]) {
+                results[0]++;       // mismatched bytes
+            } else {
+                results[1]++;       // matched bytes
             }
         }
-        count -= len;
-        return true;
-    }
 
-    void decrypt(CipherBox box) throws BadPaddingException {
-        int len = count - headerSize;
-        count = headerSize + box.decrypt(buf, headerSize, len);
+        return results;
     }
 
+    /*
+     * Calculate the length of a dummy buffer to run MAC computation
+     * and comparison on the remainder.
+     *
+     * The caller MUST ensure that the fullLen is not less than usedLen.
+     */
+    static int calculateRemainingLen(
+            MAC signer, int fullLen, int usedLen) {
+
+        int blockLen = signer.hashBlockLen();
+        int minimalPaddingLen = signer.minimalPaddingLen();
+
+        // (blockLen - minimalPaddingLen) is the maximum message size of
+        // the last block of hash function operation. See FIPS 180-4, or
+        // MD5 specification.
+        fullLen += 13 - (blockLen - minimalPaddingLen);
+        usedLen += 13 - (blockLen - minimalPaddingLen);
+
+        // Note: fullLen is always not less than usedLen, and blockLen
+        // is always bigger than minimalPaddingLen, so we don't worry
+        // about negative values. 0x01 is added to the result to ensure
+        // that the return value is positive.  The extra one byte does
+        // not impact the overall MAC compression function evaluations.
+        return 0x01 + (int)(Math.ceil(fullLen/(1.0d * blockLen)) -
+                Math.ceil(usedLen/(1.0d * blockLen))) * signer.hashBlockLen();
+    }
 
     /*
      * Well ... hello_request messages are _never_ hashed since we can't
--- jdk/src/share/classes/sun/security/ssl/MAC.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/MAC.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,8 +43,8 @@
  * provide integrity protection for SSL messages.  The MAC is actually
  * one of several keyed hashes, as associated with the cipher suite and
  * protocol version.  (SSL v3.0 uses one construct, TLS uses another.)
- *
- * <P>NOTE: MAC computation is the only place in the SSL protocol that the
+ * <P>
+ * NOTE: MAC computation is the only place in the SSL protocol that the
  * sequence number is used.  It's also reset to zero with each change of
  * a cipher spec, so this is the only place this state is needed.
  *
@@ -133,15 +133,31 @@
     }
 
     /**
+     * Returns the hash function block length of the MAC alorithm.
+     */
+    int hashBlockLen() {
+        return macAlg.hashBlockSize;
+    }
+
+    /**
+     * Returns the hash function minimal padding length of the MAC alorithm.
+     */
+    int minimalPaddingLen() {
+        return macAlg.minimalPaddingSize;
+    }
+
+    /**
      * Computes and returns the MAC for the data in this byte array.
      *
      * @param type record type
      * @param buf compressed record on which the MAC is computed
      * @param offset start of compressed record data
      * @param len the size of the compressed record
+     * @param isSimulated if true, simulate the the MAC computation
      */
-    final byte[] compute(byte type, byte buf[], int offset, int len) {
-        return compute(type, null, buf, offset, len);
+    final byte[] compute(byte type, byte buf[],
+            int offset, int len, boolean isSimulated) {
+        return compute(type, null, buf, offset, len, isSimulated);
     }
 
     /**
@@ -154,9 +170,10 @@
      * @param type record type
      * @param bb a ByteBuffer in which the position and limit
      *          demarcate the data to be MAC'd.
+     * @param isSimulated if true, simulate the the MAC computation
      */
-    final byte[] compute(byte type, ByteBuffer bb) {
-        return compute(type, bb, null, 0, bb.remaining());
+    final byte[] compute(byte type, ByteBuffer bb, boolean isSimulated) {
+        return compute(type, bb, null, 0, bb.remaining(), isSimulated);
     }
 
     /**
@@ -209,18 +226,21 @@
      * or buf/offset/len.
      */
     private byte[] compute(byte type, ByteBuffer bb, byte[] buf,
-            int offset, int len) {
+            int offset, int len, boolean isSimulated) {
 
         if (macSize == 0) {
             return nullMAC;
         }
 
-        block[BLOCK_OFFSET_TYPE] = type;
-        block[block.length - 2]  = (byte)(len >> 8);
-        block[block.length - 1]  = (byte)(len     );
+        // MUST NOT increase the sequence number for a simulated computation.
+        if (!isSimulated) {
+            block[BLOCK_OFFSET_TYPE] = type;
+            block[block.length - 2]  = (byte)(len >> 8);
+            block[block.length - 1]  = (byte)(len     );
 
-        mac.update(block);
-        incrementSequenceNumber();
+            mac.update(block);
+            incrementSequenceNumber();
+        }
 
         // content
         if (bb != null) {
--- jdk/src/share/classes/sun/security/ssl/OutputRecord.java	2012-08-10 10:29:27.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/OutputRecord.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -204,7 +204,7 @@
         }
         if (signer.MAClen() != 0) {
             byte[] hash = signer.compute(contentType, buf,
-                    headerSize, count - headerSize);
+                    headerSize, count - headerSize, false);
             write(hash);
         }
     }
--- jdk/src/share/classes/sun/security/ssl/RSAClientKeyExchange.java	2012-08-10 10:29:28.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/RSAClientKeyExchange.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,7 @@
 import javax.net.ssl.*;
 
 import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;
+import sun.security.util.KeyUtil;
 
 /**
  * This is the client key exchange message (CLIENT --> SERVER) used with
@@ -192,26 +193,38 @@
                         "unable to get the plaintext of the premaster secret");
                 }
 
-                // We are not always able to get the encoded key of the
-                // premaster secret. Pass the cheking to master secret
+                int keySize = KeyUtil.getKeySize(secretKey);
+                if (keySize > 0 && keySize != 384) {       // 384 = 48 * 8
+                    if (debug != null && Debug.isOn("handshake")) {
+                        System.out.println(
+                            "incorrect length of premaster secret: " +
+                            (keySize/8));
+                    }
+
+                    return generateDummySecret(clientHelloVersion);
+                }
+
+                // The key size is exactly 48 bytes or not accessible.
+                //
+                // Conservatively, pass the checking to master secret
                 // calculation.
                 return secretKey;
             } else if (encoded.length == 48) {
                 // check the version
                 if (clientHelloVersion.major == encoded[0] &&
                     clientHelloVersion.minor == encoded[1]) {
+
                     return secretKey;
-                } else if (clientHelloVersion.v <= ProtocolVersion.TLS10.v) {
+                } else if (clientHelloVersion.v <= ProtocolVersion.TLS10.v &&
+                           currentVersion.major == encoded[0] &&
+                           currentVersion.minor == encoded[1]) {
                     /*
-                     * we never checked the client_version in server side
-                     * for TLS v1.0 and SSL v3.0. For compatibility, we
-                     * maintain this behavior.
+                     * For compatibility, we maintain the behavior that the
+                     * version in pre_master_secret can be the negotiated
+                     * version for TLS v1.0 and SSL v3.0.
                      */
-                    if (currentVersion.major == encoded[0] &&
-                        currentVersion.minor == encoded[1]) {
-                        this.protocolVersion = currentVersion;
-                        return secretKey;
-                    }
+                    this.protocolVersion = currentVersion;
+                    return secretKey;
                 }
 
                 if (debug != null && Debug.isOn("handshake")) {
@@ -220,22 +233,23 @@
                         ", while PreMasterSecret.client_version is " +
                         ProtocolVersion.valueOf(encoded[0], encoded[1]));
                 }
+
+                return generateDummySecret(clientHelloVersion);
             } else {
                 if (debug != null && Debug.isOn("handshake")) {
                     System.out.println(
                         "incorrect length of premaster secret: " +
                         encoded.length);
                 }
-            }
-        }
 
-        if (debug != null && Debug.isOn("handshake")) {
-            if (failoverException != null) {
-                System.out.println("Error decrypting premaster secret:");
-                failoverException.printStackTrace(System.out);
+                return generateDummySecret(clientHelloVersion);
             }
+        }
 
-            System.out.println("Generating random secret");
+        if (debug != null && Debug.isOn("handshake") &&
+                    failoverException != null) {
+            System.out.println("Error decrypting premaster secret:");
+            failoverException.printStackTrace(System.out);
         }
 
         return generateDummySecret(clientHelloVersion);
@@ -243,6 +257,10 @@
 
     // generate a premaster secret with the specified version number
     static SecretKey generateDummySecret(ProtocolVersion version) {
+        if (debug != null && Debug.isOn("handshake")) {
+            System.out.println("Generating a random fake premaster secret");
+        }
+
         try {
             String s = ((version.v >= ProtocolVersion.TLS12.v) ?
                 "SunTls12RsaPremasterSecret" : "SunTlsRsaPremasterSecret");
--- jdk/src/share/classes/sun/security/ssl/SSLEngineImpl.java	2012-08-10 10:29:28.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/SSLEngineImpl.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -950,35 +950,15 @@
              * throw a fatal alert if the integrity check fails.
              */
             try {
-                decryptedBB = inputRecord.decrypt(readCipher, readBB);
+                decryptedBB = inputRecord.decrypt(readMAC, readCipher, readBB);
             } catch (BadPaddingException e) {
-                // RFC 2246 states that decryption_failed should be used
-                // for this purpose. However, that allows certain attacks,
-                // so we just send bad record MAC. We also need to make
-                // sure to always check the MAC to avoid a timing attack
-                // for the same issue. See paper by Vaudenay et al.
-                //
-                // rewind the BB if necessary.
-                readBB.rewind();
-
-                inputRecord.checkMAC(readMAC, readBB);
-
-                // use the same alert types as for MAC failure below
                 byte alertType = (inputRecord.contentType() ==
                     Record.ct_handshake) ?
                         Alerts.alert_handshake_failure :
                         Alerts.alert_bad_record_mac;
-                fatal(alertType, "Invalid padding", e);
+                fatal(alertType, e.getMessage(), e);
             }
 
-            if (!inputRecord.checkMAC(readMAC, decryptedBB)) {
-                if (inputRecord.contentType() == Record.ct_handshake) {
-                    fatal(Alerts.alert_handshake_failure,
-                        "bad handshake record MAC");
-                } else {
-                    fatal(Alerts.alert_bad_record_mac, "bad record MAC");
-                }
-            }
 
             // if (!inputRecord.decompress(c))
             //     fatal(Alerts.alert_decompression_failure,
--- jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java	2012-08-10 10:29:28.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java	2013-05-05 09:38:30.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -966,29 +966,13 @@
              * throw a fatal alert if the integrity check fails.
              */
             try {
-                r.decrypt(readCipher);
+                r.decrypt(readMAC, readCipher);
             } catch (BadPaddingException e) {
-                // RFC 2246 states that decryption_failed should be used
-                // for this purpose. However, that allows certain attacks,
-                // so we just send bad record MAC. We also need to make
-                // sure to always check the MAC to avoid a timing attack
-                // for the same issue. See paper by Vaudenay et al.
-                r.checkMAC(readMAC);
-                // use the same alert types as for MAC failure below
                 byte alertType = (r.contentType() == Record.ct_handshake)
                                         ? Alerts.alert_handshake_failure
                                         : Alerts.alert_bad_record_mac;
-                fatal(alertType, "Invalid padding", e);
+                fatal(alertType, e.getMessage(), e);
             }
-            if (!r.checkMAC(readMAC)) {
-                if (r.contentType() == Record.ct_handshake) {
-                    fatal(Alerts.alert_handshake_failure,
-                        "bad handshake record MAC");
-                } else {
-                    fatal(Alerts.alert_bad_record_mac, "bad record MAC");
-                }
-            }
-
 
             // if (!r.decompress(c))
             //     fatal(Alerts.alert_decompression_failure,
--- jdk/src/share/classes/sun/security/ssl/ServerHandshaker.java	2012-08-10 10:29:28.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/ServerHandshaker.java	2013-05-05 09:38:30.000000000 -0700
@@ -150,7 +150,7 @@
         // In SSLv3 and TLS, messages follow strictly increasing
         // numerical order _except_ for one annoying special case.
         //
-        if ((state > type)
+        if ((state >= type)
                 && (state != HandshakeMessage.ht_client_key_exchange
                     && type != HandshakeMessage.ht_certificate_verify)) {
             throw new SSLProtocolException(
@@ -250,13 +250,15 @@
         }
 
         //
-        // Move the state machine forward except for that annoying
-        // special case.  This means that clients could send extra
-        // cert verify messages; not a problem so long as all of
-        // them actually check out.
+        // Move state machine forward if the message handling
+        // code didn't already do so
         //
-        if (state < type && type != HandshakeMessage.ht_certificate_verify) {
-            state = type;
+        if (state < type) {
+            if(type == HandshakeMessage.ht_certificate_verify) {
+                state = type + 2;    // an annoying special case
+            } else {
+                state = type;
+            }
         }
     }
 
@@ -1363,7 +1365,7 @@
         if (debug != null && Debug.isOn("handshake")) {
             mesg.print(System.out);
         }
-        return dh.getAgreedSecret(mesg.getClientPublicKey());
+        return dh.getAgreedSecret(mesg.getClientPublicKey(), false);
     }
 
     private SecretKey clientKeyExchange(ECDHClientKeyExchange mesg)
--- jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	2012-08-10 10:29:28.000000000 -0700
+++ jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	2013-05-05 09:38:30.000000000 -0700
@@ -38,7 +38,7 @@
 import java.util.Collections;
 import java.util.ArrayList;
 
-import sun.security.util.KeyLength;
+import sun.security.util.KeyUtil;
 
 /**
  * Signature and hash algorithm.
@@ -279,7 +279,7 @@
              * If key size is less than 512, the  digest length should be
              * less than or equal to 20 bytes.
              */
-            int keySize = KeyLength.getKeySize(signingKey);
+            int keySize = KeyUtil.getKeySize(signingKey);
             if (keySize >= 768) {
                 maxDigestLength = HashAlgorithm.SHA512.length;
             } else if ((keySize >= 512) && (keySize < 768)) {
--- jdk/src/share/classes/sun/security/util/DerIndefLenConverter.java	2012-08-10 10:29:30.000000000 -0700
+++ jdk/src/share/classes/sun/security/util/DerIndefLenConverter.java	2013-05-05 09:38:31.000000000 -0700
@@ -325,6 +325,10 @@
             }
         }
 
+        if (unresolved != 0) {
+            throw new IOException("not all indef len BER resolved");
+        }
+
         newData = new byte[dataSize + numOfTotalLenBytes + unused];
         dataPos=0; newDataPos=0; index=0;
 
--- jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java	2012-08-10 10:29:30.000000000 -0700
+++ jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java	2013-05-05 09:38:31.000000000 -0700
@@ -438,7 +438,7 @@
 
         // Does this key constraint disable the specified key?
         public boolean disables(Key key) {
-            int size = KeyLength.getKeySize(key);
+            int size = KeyUtil.getKeySize(key);
 
             if (size == 0) {
                 return true;    // we don't allow any key of size 0.
--- jdk/src/share/classes/sun/security/util/KeyLength.java	2012-08-10 10:29:30.000000000 -0700
+++ jdk/src/share/classes/sun/security/util/KeyLength.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.util;
-
-import java.security.Key;
-import java.security.PrivilegedAction;
-import java.security.AccessController;
-import java.security.interfaces.ECKey;
-import java.security.interfaces.RSAKey;
-import java.security.interfaces.DSAKey;
-import javax.crypto.SecretKey;
-import javax.crypto.interfaces.DHKey;
-
-/**
- * A utility class to get key length
- */
-public final class KeyLength {
-
-    /**
-     * Returns the key size of the given key object in bits.
-     *
-     * @param key the key object, cannot be null
-     * @return the key size of the given key object in bits, or -1 if the
-     *       key size is not accessible
-     */
-    final public static int getKeySize(Key key) {
-        int size = -1;
-
-        if (key instanceof Length) {
-            try {
-                Length ruler = (Length)key;
-                size = ruler.length();
-            } catch (UnsupportedOperationException usoe) {
-                // ignore the exception
-            }
-
-            if (size >= 0) {
-                return size;
-            }
-        }
-
-        // try to parse the length from key specification
-        if (key instanceof SecretKey) {
-            SecretKey sk = (SecretKey)key;
-            String format = sk.getFormat();
-            if ("RAW".equals(format) && sk.getEncoded() != null) {
-                size = (sk.getEncoded().length * 8);
-            }   // Otherwise, it may be a unextractable key of PKCS#11, or
-                // a key we are not able to handle.
-        } else if (key instanceof RSAKey) {
-            RSAKey pubk = (RSAKey)key;
-            size = pubk.getModulus().bitLength();
-        } else if (key instanceof ECKey) {
-            ECKey pubk = (ECKey)key;
-            size = pubk.getParams().getOrder().bitLength();
-        } else if (key instanceof DSAKey) {
-            DSAKey pubk = (DSAKey)key;
-            size = pubk.getParams().getP().bitLength();
-        } else if (key instanceof DHKey) {
-            DHKey pubk = (DHKey)key;
-            size = pubk.getParams().getP().bitLength();
-        }   // Otherwise, it may be a unextractable key of PKCS#11, or
-            // a key we are not able to handle.
-
-        return size;
-    }
-}
-
--- jdk/src/share/classes/sun/security/util/KeyUtil.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/classes/sun/security/util/KeyUtil.java	2013-05-05 09:38:31.000000000 -0700
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.security.util;
+
+import java.security.Key;
+import java.security.PrivilegedAction;
+import java.security.AccessController;
+import java.security.InvalidKeyException;
+import java.security.interfaces.ECKey;
+import java.security.interfaces.RSAKey;
+import java.security.interfaces.DSAKey;
+import java.security.spec.KeySpec;
+import javax.crypto.SecretKey;
+import javax.crypto.interfaces.DHKey;
+import javax.crypto.interfaces.DHPublicKey;
+import javax.crypto.spec.DHParameterSpec;
+import javax.crypto.spec.DHPublicKeySpec;
+import java.math.BigInteger;
+
+/**
+ * A utility class to get key length, valiate keys, etc.
+ */
+public final class KeyUtil {
+
+    /**
+     * Returns the key size of the given key object in bits.
+     *
+     * @param key the key object, cannot be null
+     * @return the key size of the given key object in bits, or -1 if the
+     *       key size is not accessible
+     */
+    public static final int getKeySize(Key key) {
+        int size = -1;
+
+        if (key instanceof Length) {
+            try {
+                Length ruler = (Length)key;
+                size = ruler.length();
+            } catch (UnsupportedOperationException usoe) {
+                // ignore the exception
+            }
+
+            if (size >= 0) {
+                return size;
+            }
+        }
+
+        // try to parse the length from key specification
+        if (key instanceof SecretKey) {
+            SecretKey sk = (SecretKey)key;
+            String format = sk.getFormat();
+            if ("RAW".equals(format) && sk.getEncoded() != null) {
+                size = (sk.getEncoded().length * 8);
+            }   // Otherwise, it may be a unextractable key of PKCS#11, or
+                // a key we are not able to handle.
+        } else if (key instanceof RSAKey) {
+            RSAKey pubk = (RSAKey)key;
+            size = pubk.getModulus().bitLength();
+        } else if (key instanceof ECKey) {
+            ECKey pubk = (ECKey)key;
+            size = pubk.getParams().getOrder().bitLength();
+        } else if (key instanceof DSAKey) {
+            DSAKey pubk = (DSAKey)key;
+            size = pubk.getParams().getP().bitLength();
+        } else if (key instanceof DHKey) {
+            DHKey pubk = (DHKey)key;
+            size = pubk.getParams().getP().bitLength();
+        }   // Otherwise, it may be a unextractable key of PKCS#11, or
+            // a key we are not able to handle.
+
+        return size;
+    }
+
+    /**
+     * Returns whether the key is valid or not.
+     * <P>
+     * Note that this method is only apply to DHPublicKey at present.
+     *
+     * @param  publicKey
+     *         the key object, cannot be null
+     *
+     * @throws NullPointerException if {@code publicKey} is null
+     * @throws InvalidKeyException if {@code publicKey} is invalid
+     */
+    public static final void validate(Key key)
+            throws InvalidKeyException {
+        if (key == null) {
+            throw new NullPointerException(
+                "The key to be validated cannot be null");
+        }
+
+        if (key instanceof DHPublicKey) {
+            validateDHPublicKey((DHPublicKey)key);
+        }
+    }
+
+
+    /**
+     * Returns whether the key spec is valid or not.
+     * <P>
+     * Note that this method is only apply to DHPublicKeySpec at present.
+     *
+     * @param  keySpec
+     *         the key spec object, cannot be null
+     *
+     * @throws NullPointerException if {@code keySpec} is null
+     * @throws InvalidKeyException if {@code keySpec} is invalid
+     */
+    public static final void validate(KeySpec keySpec)
+            throws InvalidKeyException {
+        if (keySpec == null) {
+            throw new NullPointerException(
+                "The key spec to be validated cannot be null");
+        }
+
+        if (keySpec instanceof DHPublicKeySpec) {
+            validateDHPublicKey((DHPublicKeySpec)keySpec);
+        }
+    }
+
+    /**
+     * Returns whether the specified provider is Oracle provider or not.
+     * <P>
+     * Note that this method is only apply to SunJCE and SunPKCS11 at present.
+     *
+     * @param  providerName
+     *         the provider name
+     * @return true if, and only if, the provider of the specified
+     *         {@code providerName} is Oracle provider
+     */
+    public static final boolean isOracleJCEProvider(String providerName) {
+        return providerName != null && (providerName.equals("SunJCE") ||
+                                        providerName.startsWith("SunPKCS11"));
+    }
+
+    /**
+     * Returns whether the Diffie-Hellman public key is valid or not.
+     *
+     * Per RFC 2631 and NIST SP800-56A, the following algorithm is used to
+     * validate Diffie-Hellman public keys:
+     * 1. Verify that y lies within the interval [2,p-1]. If it does not,
+     *    the key is invalid.
+     * 2. Compute y^q mod p. If the result == 1, the key is valid.
+     *    Otherwise the key is invalid.
+     */
+    private static void validateDHPublicKey(DHPublicKey publicKey)
+            throws InvalidKeyException {
+        DHParameterSpec paramSpec = publicKey.getParams();
+
+        BigInteger p = paramSpec.getP();
+        BigInteger g = paramSpec.getG();
+        BigInteger y = publicKey.getY();
+
+        validateDHPublicKey(p, g, y);
+    }
+
+    private static void validateDHPublicKey(DHPublicKeySpec publicKeySpec)
+            throws InvalidKeyException {
+        validateDHPublicKey(publicKeySpec.getP(),
+            publicKeySpec.getG(), publicKeySpec.getY());
+    }
+
+    private static void validateDHPublicKey(BigInteger p,
+            BigInteger g, BigInteger y) throws InvalidKeyException {
+
+        // For better interoperability, the interval is limited to [2, p-2].
+        BigInteger leftOpen = BigInteger.ONE;
+        BigInteger rightOpen = p.subtract(BigInteger.ONE);
+        if (y.compareTo(leftOpen) <= 0) {
+            throw new InvalidKeyException(
+                    "Diffie-Hellman public key is too small");
+        }
+        if (y.compareTo(rightOpen) >= 0) {
+            throw new InvalidKeyException(
+                    "Diffie-Hellman public key is too large");
+        }
+
+        // Don't bother to check against the y^q mod p if safe primes are used.
+    }
+}
+
--- jdk/src/share/classes/sun/security/util/UntrustedCertificates.java	2012-08-10 10:29:31.000000000 -0700
+++ jdk/src/share/classes/sun/security/util/UntrustedCertificates.java	2013-05-05 09:38:31.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -737,5 +737,158 @@
         "B8WfedLHjFW/TMcnXlEWKz4=\n" +
         "-----END CERTIFICATE-----");
 
+        //
+        // Revoked DigiCert code signing certificates used to sign malware
+        //
+
+        // Subject: CN=Buster Paper Comercial Ltda,
+        //          O=Buster Paper Comercial Ltda,
+        //          L=S?o Jos? Dos Campos,
+        //          ST=S?o Paulo,
+        //          C=BR
+        // Issuer:  CN=DigiCert Assured ID Code Signing CA-1,
+        //          OU=www.digicert.com,
+        //          O=DigiCert Inc,
+        //          C=US
+        // Serial:  07:b4:4c:db:ff:fb:78:de:05:f4:26:16:72:a6:73:12
+        add("buster-paper-comercial-ltda-72A67312",
+        "-----BEGIN CERTIFICATE-----\n" +
+        "MIIGwzCCBaugAwIBAgIQB7RM2//7eN4F9CYWcqZzEjANBgkqhkiG9w0BAQUFADBv\n" +
+        "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
+        "d3cuZGlnaWNlcnQuY29tMS4wLAYDVQQDEyVEaWdpQ2VydCBBc3N1cmVkIElEIENv\n" +
+        "ZGUgU2lnbmluZyBDQS0xMB4XDTEzMDExNzAwMDAwMFoXDTE0MDEyMjEyMDAwMFow\n" +
+        "gY4xCzAJBgNVBAYTAkJSMRMwEQYDVQQIDApTw6NvIFBhdWxvMR4wHAYDVQQHDBVT\n" +
+        "w6NvIEpvc8OpIERvcyBDYW1wb3MxJDAiBgNVBAoTG0J1c3RlciBQYXBlciBDb21l\n" +
+        "cmNpYWwgTHRkYTEkMCIGA1UEAxMbQnVzdGVyIFBhcGVyIENvbWVyY2lhbCBMdGRh\n" +
+        "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzO0l6jWIpEfO2oUpVHpL\n" +
+        "HETj5lzivNb0S9jKHgGJax917czh81PnGTxwxFXd6gLJuy/XFHvmiSi8g8jzlymn\n" +
+        "2Ji5zQ3CPaz7nomJokSUDlMVJ2qYWtctw4jrdjuI4qtn+koXXUFkWjkf8h8251I4\n" +
+        "tUs7S49HE2Go5owCYP3byajj7fsFAYR/Xb7TdVtndkZsUB/YgOjHovyACjouaNCi\n" +
+        "mDiRyQ6zLLjZGiyeD65Yiseuhp5b8/BL5h1p7w76QYMYMVQNAdtDKut2R8MBpuWf\n" +
+        "Ny7Eoi0x/gm1p9X5Rcl5aN7K0G4UtTAJKbkuUfXddsyFoM0Nx8uo8SgNQ8Y/X5Jx\n" +
+        "BwIDAQABo4IDOTCCAzUwHwYDVR0jBBgwFoAUe2jOKarAF75JeuHlP9an90WPNTIw\n" +
+        "HQYDVR0OBBYEFFLZ3n5nt/Eer7n1bvtOqMb1qKO5MA4GA1UdDwEB/wQEAwIHgDAT\n" +
+        "BgNVHSUEDDAKBggrBgEFBQcDAzBzBgNVHR8EbDBqMDOgMaAvhi1odHRwOi8vY3Js\n" +
+        "My5kaWdpY2VydC5jb20vYXNzdXJlZC1jcy0yMDExYS5jcmwwM6AxoC+GLWh0dHA6\n" +
+        "Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9hc3N1cmVkLWNzLTIwMTFhLmNybDCCAcQGA1Ud\n" +
+        "IASCAbswggG3MIIBswYJYIZIAYb9bAMBMIIBpDA6BggrBgEFBQcCARYuaHR0cDov\n" +
+        "L3d3dy5kaWdpY2VydC5jb20vc3NsLWNwcy1yZXBvc2l0b3J5Lmh0bTCCAWQGCCsG\n" +
+        "AQUFBwICMIIBVh6CAVIAQQBuAHkAIAB1AHMAZQAgAG8AZgAgAHQAaABpAHMAIABD\n" +
+        "AGUAcgB0AGkAZgBpAGMAYQB0AGUAIABjAG8AbgBzAHQAaQB0AHUAdABlAHMAIABh\n" +
+        "AGMAYwBlAHAAdABhAG4AYwBlACAAbwBmACAAdABoAGUAIABEAGkAZwBpAEMAZQBy\n" +
+        "AHQAIABDAFAALwBDAFAAUwAgAGEAbgBkACAAdABoAGUAIABSAGUAbAB5AGkAbgBn\n" +
+        "ACAAUABhAHIAdAB5ACAAQQBnAHIAZQBlAG0AZQBuAHQAIAB3AGgAaQBjAGgAIABs\n" +
+        "AGkAbQBpAHQAIABsAGkAYQBiAGkAbABpAHQAeQAgAGEAbgBkACAAYQByAGUAIABp\n" +
+        "AG4AYwBvAHIAcABvAHIAYQB0AGUAZAAgAGgAZQByAGUAaQBuACAAYgB5ACAAcgBl\n" +
+        "AGYAZQByAGUAbgBjAGUALjCBggYIKwYBBQUHAQEEdjB0MCQGCCsGAQUFBzABhhho\n" +
+        "dHRwOi8vb2NzcC5kaWdpY2VydC5jb20wTAYIKwYBBQUHMAKGQGh0dHA6Ly9jYWNl\n" +
+        "cnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEFzc3VyZWRJRENvZGVTaWduaW5nQ0Et\n" +
+        "MS5jcnQwDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQUFAAOCAQEAPTTQvpOIikXI\n" +
+        "hTLnNbajaFRR5GhQpTzUNgBfF9VYSlNw/wMjpGsrh5RxaJCip52jbehmTgjMRhft\n" +
+        "jRYyml44PAVsCcR9uEoDpCZYpI1fHI1R+F8jd1C9rqprbSwwOG4xlg4SmvTHYs6e\n" +
+        "gBItQ/1p9XY+Sf4Wv1qOuOFL1qvV/5VyR2zdlOQCmKCeMgxt6a/tHLBDiAA67D44\n" +
+        "/vfdoNJl0CU2It0PO60jdCPFNWIRcxL+OSDqAoePeUC7xQ+JsTEIxuUE8+d6w6fc\n" +
+        "BV2mYb1flh22t46GLjh4gyo7xw3aL6L0L0jzlTT6IcEw6NIbaPbIKj/npQnHobYj\n" +
+        "XMuKLxbh7g==\n" +
+        "-----END CERTIFICATE-----");
+
+        // Subject: CN=BUSTER ASSISTENCIA TECNICA ELETRONICA LTDA - ME,
+        //          O=BUSTER ASSISTENCIA TECNICA ELETRONICA LTDA - ME,
+        //          L=S?o Paulo,
+        //          ST=S?o Paulo,
+        //          C=BR
+        // Issuer:  CN=DigiCert Assured ID Code Signing CA-1,
+        //          OU=www.digicert.com,
+        //          O=DigiCert Inc,
+        //          C=US
+        // Serial:  0a:38:9b:95:ee:73:6d:d1:3b:c0:ed:74:3f:d7:4d:2f
+        add("buster-assistencia-tecnica-electronica-ltda-3FD74D2F",
+        "-----BEGIN CERTIFICATE-----\n" +
+        "MIIG4DCCBcigAwIBAgIQCjible5zbdE7wO10P9dNLzANBgkqhkiG9w0BAQUFADBv\n" +
+        "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
+        "d3cuZGlnaWNlcnQuY29tMS4wLAYDVQQDEyVEaWdpQ2VydCBBc3N1cmVkIElEIENv\n" +
+        "ZGUgU2lnbmluZyBDQS0xMB4XDTEyMTEwOTAwMDAwMFoXDTEzMTExNDEyMDAwMFow\n" +
+        "gasxCzAJBgNVBAYTAkJSMRMwEQYDVQQIDApTw6NvIFBhdWxvMRMwEQYDVQQHDApT\n" +
+        "w6NvIFBhdWxvMTgwNgYDVQQKEy9CVVNURVIgQVNTSVNURU5DSUEgVEVDTklDQSBF\n" +
+        "TEVUUk9OSUNBIExUREEgLSBNRTE4MDYGA1UEAxMvQlVTVEVSIEFTU0lTVEVOQ0lB\n" +
+        "IFRFQ05JQ0EgRUxFVFJPTklDQSBMVERBIC0gTUUwggEiMA0GCSqGSIb3DQEBAQUA\n" +
+        "A4IBDwAwggEKAoIBAQDAqNeEs5/B2CTXGjTOkUIdu6jV6qulOZwdw4sefHWYj1UR\n" +
+        "4z6zPk9kjpUgbnb402RFq88QtfInwddZ/wXn9OxMtDd/3TnC7HrhNS7ga79ZFL2V\n" +
+        "JnmzKHum2Yvh0q82QEJ9tHBR2X9VdKpUIH08Zs3k6cWWM1H0YX0cxA/HohhesQJW\n" +
+        "kwJ3urOIJiH/HeByDk8a1NS8safcCxk5vxvW4WvCg43iT09LeHY5Aa8abKw8lqVb\n" +
+        "0tD5ZSIjdmdj3TT1U37iAHLLRM2DXbxfdbhouUX1c5U1ZHAMA67HwjKiseOiDaHj\n" +
+        "NUGbC37C+cgbc9VVM/cURD8WvS0Kj6fQv7F2QtJDAgMBAAGjggM5MIIDNTAfBgNV\n" +
+        "HSMEGDAWgBR7aM4pqsAXvkl64eU/1qf3RY81MjAdBgNVHQ4EFgQU88EXKAyDsh30\n" +
+        "o9+Gu9a4xUy+FSMwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoGCCsGAQUFBwMD\n" +
+        "MHMGA1UdHwRsMGowM6AxoC+GLWh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9hc3N1\n" +
+        "cmVkLWNzLTIwMTFhLmNybDAzoDGgL4YtaHR0cDovL2NybDQuZGlnaWNlcnQuY29t\n" +
+        "L2Fzc3VyZWQtY3MtMjAxMWEuY3JsMIIBxAYDVR0gBIIBuzCCAbcwggGzBglghkgB\n" +
+        "hv1sAwEwggGkMDoGCCsGAQUFBwIBFi5odHRwOi8vd3d3LmRpZ2ljZXJ0LmNvbS9z\n" +
+        "c2wtY3BzLXJlcG9zaXRvcnkuaHRtMIIBZAYIKwYBBQUHAgIwggFWHoIBUgBBAG4A\n" +
+        "eQAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAgAEMAZQByAHQAaQBmAGkAYwBhAHQA\n" +
+        "ZQAgAGMAbwBuAHMAdABpAHQAdQB0AGUAcwAgAGEAYwBjAGUAcAB0AGEAbgBjAGUA\n" +
+        "IABvAGYAIAB0AGgAZQAgAEQAaQBnAGkAQwBlAHIAdAAgAEMAUAAvAEMAUABTACAA\n" +
+        "YQBuAGQAIAB0AGgAZQAgAFIAZQBsAHkAaQBuAGcAIABQAGEAcgB0AHkAIABBAGcA\n" +
+        "cgBlAGUAbQBlAG4AdAAgAHcAaABpAGMAaAAgAGwAaQBtAGkAdAAgAGwAaQBhAGIA\n" +
+        "aQBsAGkAdAB5ACAAYQBuAGQAIABhAHIAZQAgAGkAbgBjAG8AcgBwAG8AcgBhAHQA\n" +
+        "ZQBkACAAaABlAHIAZQBpAG4AIABiAHkAIAByAGUAZgBlAHIAZQBuAGMAZQAuMIGC\n" +
+        "BggrBgEFBQcBAQR2MHQwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0\n" +
+        "LmNvbTBMBggrBgEFBQcwAoZAaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0Rp\n" +
+        "Z2lDZXJ0QXNzdXJlZElEQ29kZVNpZ25pbmdDQS0xLmNydDAMBgNVHRMBAf8EAjAA\n" +
+        "MA0GCSqGSIb3DQEBBQUAA4IBAQAei1QmiXepje8OIfo/WonD4MIXgpPr2dfRaquQ\n" +
+        "A8q63OpTRSveyqdQDCSPpDRF/nvO1Y30yksZvIH1tNBsW5LBdxAKN3lFdBlqBwtE\n" +
+        "Q3jHc0KVVYRJ0FBaGE/PJHmRajscdAhYIcMPhTga0u0tDK+wOHEq3993dfl6yHjA\n" +
+        "XHU2iW5pnk75ZoE39zALD5eKXT8ZXrET5c3XUFJKWA+XuGmdmyzqo0Au49PanBv9\n" +
+        "UlZnabYfqoMArqMS0tGSX4cGgi9/2E+pHG9BX4sFW+ZDumroOA2pxyMWEKjxePEL\n" +
+        "zCOfhbsRWdMLYepauaNZOIMZXmFwcrIl0TGMkTAtATz+XmZc\n" +
+        "-----END CERTIFICATE-----");
+
+        //
+        // Revoked code signing certificate w/ a stolen key issued by GoDaddy
+        // used to sign malware
+        //
+
+        // Subject: CN=CLEARESULT CONSULTING INC., OU=Corporate IT,
+        //          O=CLEARESULT CONSULTING INC., L=Austin, ST=TX, C=US
+        // Issuer:  SERIALNUMBER=07969287,
+        //          CN=Go Daddy Secure Certification Authority,
+        //          OU=http://certificates.godaddy.com/repository,
+        //          O="GoDaddy.com, Inc.",
+        //          L=Scottsdale,
+        //          ST=Arizona,
+        //          C=US
+        // Serial:  2b:73:43:2a:a8:4f:44
+        add("clearesult-consulting-inc-2AA84F44",
+        "-----BEGIN CERTIFICATE-----\n" +
+        "MIIFYjCCBEqgAwIBAgIHK3NDKqhPRDANBgkqhkiG9w0BAQUFADCByjELMAkGA1UE\n" +
+        "BhMCVVMxEDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAY\n" +
+        "BgNVBAoTEUdvRGFkZHkuY29tLCBJbmMuMTMwMQYDVQQLEypodHRwOi8vY2VydGlm\n" +
+        "aWNhdGVzLmdvZGFkZHkuY29tL3JlcG9zaXRvcnkxMDAuBgNVBAMTJ0dvIERhZGR5\n" +
+        "IFNlY3VyZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTERMA8GA1UEBRMIMDc5Njky\n" +
+        "ODcwHhcNMTIwMjE1MjEwOTA2WhcNMTQwMjE1MjEwOTA2WjCBjDELMAkGA1UEBgwC\n" +
+        "VVMxCzAJBgNVBAgMAlRYMQ8wDQYDVQQHDAZBdXN0aW4xIzAhBgNVBAoMGkNMRUFS\n" +
+        "RVNVTFQgQ09OU1VMVElORyBJTkMuMRUwEwYDVQQLDAxDb3Jwb3JhdGUgSVQxIzAh\n" +
+        "BgNVBAMMGkNMRUFSRVNVTFQgQ09OU1VMVElORyBJTkMuMIIBIjANBgkqhkiG9w0B\n" +
+        "AQEFAAOCAQ8AMIIBCgKCAQEAtIOjCKeAicull+7ZIzt0/4ya3IeXUFlfypqKMLkU\n" +
+        "IbKjn0P5uMj6VE3rlbZr44RCegxvdnR6umBh1c0ZXoN3o+yc0JKcKcLiApmJJ277\n" +
+        "p7IbLwYDhBXRQNoIJm187IOMRPIxsKN4hL91txn9jGBmW+9zKlJlNhR5R7vjwU2E\n" +
+        "jrH/6oqsc9EM2yYpfjlNv6+3jSwAYZCkSWr+27PQOV+YHKmIxtJjX0upFz5FdIrV\n" +
+        "9CCX+L2Kji1THOkSgG4QTbYxmEcHqGViWz8hXLeNXjcbEsPuIiAu3hknxRHfUTE/\n" +
+        "U0Lh0Ug1e3LrJu+WnxM2SmUY4krsZ22c0yWUW9hzWITIjQIDAQABo4IBhzCCAYMw\n" +
+        "DwYDVR0TAQH/BAUwAwEBADATBgNVHSUEDDAKBggrBgEFBQcDAzAOBgNVHQ8BAf8E\n" +
+        "BAMCB4AwMwYDVR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5nb2RhZGR5LmNvbS9n\n" +
+        "ZHM1LTE2LmNybDBTBgNVHSAETDBKMEgGC2CGSAGG/W0BBxcCMDkwNwYIKwYBBQUH\n" +
+        "AgEWK2h0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5jb20vcmVwb3NpdG9yeS8w\n" +
+        "gYAGCCsGAQUFBwEBBHQwcjAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZ29kYWRk\n" +
+        "eS5jb20vMEoGCCsGAQUFBzAChj5odHRwOi8vY2VydGlmaWNhdGVzLmdvZGFkZHku\n" +
+        "Y29tL3JlcG9zaXRvcnkvZ2RfaW50ZXJtZWRpYXRlLmNydDAfBgNVHSMEGDAWgBT9\n" +
+        "rGEyk2xF1uLuhV+auud2mWjM5zAdBgNVHQ4EFgQUDtdeKqeN2QkcbEp1HovFieNB\n" +
+        "XiowDQYJKoZIhvcNAQEFBQADggEBAD74Agw5tvi2aBl4/f/s7/VE/BClzDsKMb9K\n" +
+        "v9qpeC45ZA/jelxV11HKbQnVF194gDb7D2H9OsAsRUy8HVKbXEcc/8dKvwOqb+BC\n" +
+        "2i/EmfjLgmCfezNFtLq8xcPxF3zIRc44vPrK0z4YZsaHdH+yTEJ51p5EMdTqaLaP\n" +
+        "4n5m8LX3RfqlQB9dYFe6dUoYZjKm9d/pIRww3VqfOzjl42Edi1w6dWmBVMx1NZuR\n" +
+        "DBabJH1vJ9Gd+KwxMCmBZ6pQPl28JDimhJhI2LNqU349uADQVV0HJosddN/ARyyI\n" +
+        "LSIQO7BnNVKVG9Iujf33bvPNeg0qNz5qw+rKKq97Pqeum+L5oKU=\n" +
+        "-----END CERTIFICATE-----");
     }
 }
--- jdk/src/share/classes/sun/swing/FilePane.java	2012-08-10 10:29:34.000000000 -0700
+++ jdk/src/share/classes/sun/swing/FilePane.java	2013-05-05 09:38:31.000000000 -0700
@@ -35,7 +35,6 @@
 import java.util.List;
 import java.util.concurrent.Callable;
 
-import javax.accessibility.AccessibleContext;
 import javax.swing.*;
 import javax.swing.border.*;
 import javax.swing.event.*;
@@ -83,9 +82,6 @@
     private JPanel currentViewPanel;
     private String[] viewTypeActionNames;
 
-    private String filesListAccessibleName = null;
-    private String filesDetailsAccessibleName = null;
-
     private JPopupMenu contextMenu;
     private JMenu viewMenu;
 
@@ -454,9 +450,6 @@
         gigaByteString = UIManager.getString("FileChooser.fileSizeGigaBytes", l);
         fullRowSelection = UIManager.getBoolean("FileView.fullRowSelection");
 
-        filesListAccessibleName = UIManager.getString("FileChooser.filesListAccessibleName", l);
-        filesDetailsAccessibleName = UIManager.getString("FileChooser.filesDetailsAccessibleName", l);
-
         renameErrorTitleText = UIManager.getString("FileChooser.renameErrorTitleText", l);
         renameErrorText = UIManager.getString("FileChooser.renameErrorText", l);
         renameErrorFileExistsText = UIManager.getString("FileChooser.renameErrorFileExistsText", l);
@@ -641,9 +634,6 @@
         if (listViewBorder != null) {
             scrollpane.setBorder(listViewBorder);
         }
-
-        list.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesListAccessibleName);
-
         p.add(scrollpane, BorderLayout.CENTER);
         return p;
     }
@@ -1238,8 +1228,6 @@
 
         detailsTableModel.fireTableStructureChanged();
 
-        detailsTable.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesDetailsAccessibleName);
-
         return p;
     } // createDetailsView
 
--- jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	2012-08-10 10:29:42.000000000 -0700
+++ jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	2013-05-05 09:38:31.000000000 -0700
@@ -30,4 +30,5 @@
 #[solaris]sun.tools.attach.SolarisAttachProvider
 #[windows]sun.tools.attach.WindowsAttachProvider
 #[linux]sun.tools.attach.LinuxAttachProvider
+#[bsd]sun.tools.attach.BsdAttachProvider
 #[macosx]sun.tools.attach.BsdAttachProvider
--- jdk/src/share/classes/sun/tools/jar/Main.java	2012-08-10 10:29:42.000000000 -0700
+++ jdk/src/share/classes/sun/tools/jar/Main.java	2013-05-05 09:38:31.000000000 -0700
@@ -51,6 +51,7 @@
     String zname = "";
     String[] files;
     String rootjar = null;
+    String cwd;
 
     // An entryName(path)->File map generated during "expand", it helps to
     // decide whether or not an existing entry in a jar file needs to be
@@ -867,6 +868,19 @@
      * Extracts specified entries from JAR file.
      */
     void extract(InputStream in, String files[]) throws IOException {
+        // Current working directory
+
+        cwd = System.getProperty("user.dir");
+        if (cwd == null) {
+            fatalError(getMsg("error.no.cwd"));
+        }
+        cwd = (new File(cwd)).getCanonicalPath();
+        if (!cwd.endsWith(File.separator)) {
+            cwd += File.separator;
+        }
+
+        // Extract the files
+
         ZipInputStream zis = new ZipInputStream(in);
         ZipEntry e;
         // Set of all directory entries specified in archive.  Disallows
@@ -897,6 +911,19 @@
      * Extracts specified entries from JAR file, via ZipFile.
      */
     void extract(String fname, String files[]) throws IOException {
+        // Current working directory
+
+        cwd = System.getProperty("user.dir");
+        if (cwd == null) {
+             fatalError(getMsg("error.no.cwd"));
+        }
+        cwd = (new File(cwd)).getCanonicalPath();
+        if (!cwd.endsWith(File.separator)) {
+            cwd += File.separator;
+        }
+
+        // Extract the files
+
         ZipFile zf = new ZipFile(fname);
         Set<ZipEntry> dirs = newDirSet();
         Enumeration<? extends ZipEntry> zes = zf.entries();
@@ -928,6 +955,10 @@
         ZipEntry rc = null;
         String name = e.getName();
         File f = new File(e.getName().replace('/', File.separatorChar));
+        if (!f.getCanonicalPath().startsWith(cwd)) {
+            output(formatMsg("out.ignore.entry", name));
+            return null;
+        }
         if (e.isDirectory()) {
             if (f.exists()) {
                 if (!f.isDirectory()) {
@@ -949,6 +980,10 @@
         } else {
             if (f.getParent() != null) {
                 File d = new File(f.getParent());
+                if (!d.getCanonicalPath().startsWith(cwd)) {
+                    output(formatMsg("out.ignore.entry", name));
+                    return null;
+                }
                 if (!d.exists() && !d.mkdirs() || !d.isDirectory()) {
                     throw new IOException(formatMsg(
                         "error.create.dir", d.getPath()));
--- jdk/src/share/classes/sun/tools/jar/resources/jar.properties	2012-08-10 10:29:42.000000000 -0700
+++ jdk/src/share/classes/sun/tools/jar/resources/jar.properties	2013-05-05 09:38:31.000000000 -0700
@@ -44,6 +44,8 @@
         {0} : could not create directory
 error.incorrect.length=\
         incorrect length while processing: {0}
+error.no.cwd=\
+	{0} : could not determine current working directory
 out.added.manifest=\
         added manifest
 out.update.manifest=\
--- jdk/src/share/demo/jvmti/compiledMethodLoad/sample.makefile.txt	2012-08-10 10:30:07.000000000 -0700
+++ jdk/src/share/demo/jvmti/compiledMethodLoad/sample.makefile.txt	2013-05-05 09:38:38.000000000 -0700
@@ -38,6 +38,7 @@
 #       gnumake JDK=<java_home> OSNAME=solaris [OPT=true] [LIBARCH=sparcv9]
 #       gnumake JDK=<java_home> OSNAME=linux   [OPT=true]
 #       gnumake JDK=<java_home> OSNAME=win32   [OPT=true]
+#       gnumake JDK=<java_home> OSNAME=bsd     [OPT=true]
 #
 ########################################################################
 
@@ -120,6 +121,29 @@
     LINK_SHARED=link -dll -out:$@
 endif
 
+# BSD GNU C Compiler
+ifeq ($(OSNAME), bsd)
+    # GNU Compiler options needed to build it
+    COMMON_FLAGS=-fno-strict-aliasing -fPIC -fno-omit-frame-pointer
+    # Options that help find errors
+    COMMON_FLAGS+= -W -Wall  -Wno-unused -Wno-parentheses
+    ifeq ($(OPT), true)
+        CFLAGS=-O2 $(COMMON_FLAGS)
+    else
+        CFLAGS=-g $(COMMON_FLAGS)
+    endif
+    # Object files needed to create library
+    OBJECTS=$(SOURCES:%.c=%.o)
+    # Library name and options needed to build it
+    # XXX: Needs to be fixed for MacOS X
+    LIBRARY=lib$(LIBNAME).so
+    LDFLAGS=-Wl,-soname=$(LIBRARY) -static-libgcc -mimpure-text
+    # Libraries we are dependent on
+    LIBRARIES=-lc
+    # Building a shared library
+    LINK_SHARED=$(LINK.c) -shared -o $@
+endif
+
 # Common -I options
 CFLAGS += -I.
 CFLAGS += -I../agent_util
--- jdk/src/share/lib/security/java.security	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/lib/security/java.security	2013-05-05 09:38:38.000000000 -0700
@@ -123,7 +123,30 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.access=sun.,\
+               com.sun.xml.internal.,\
+               com.sun.imageio.,\
+               com.sun.istack.internal.,\
+               com.sun.jmx.,\
+               com.sun.proxy.,\
+               com.sun.org.apache.bcel.internal.,\
+               com.sun.org.apache.regexp.internal.,\
+               com.sun.org.apache.xerces.internal.,\
+               com.sun.org.apache.xpath.internal.,\
+               com.sun.org.apache.xalan.internal.extensions.,\
+               com.sun.org.apache.xalan.internal.lib.,\
+               com.sun.org.apache.xalan.internal.res.,\
+               com.sun.org.apache.xalan.internal.templates.,\
+               com.sun.org.apache.xalan.internal.utils.,\
+               com.sun.org.apache.xalan.internal.xslt.,\
+               com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+               com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+               com.sun.org.apache.xalan.internal.xsltc.trax.,\
+               com.sun.org.apache.xalan.internal.xsltc.util.,\
+               com.sun.org.apache.xml.internal.res.,\
+               com.sun.org.apache.xml.internal.serializer.utils.,\
+               com.sun.org.apache.xml.internal.utils.,\
+               com.sun.org.glassfish.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -135,7 +158,30 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.definition=sun.,\
+                   com.sun.xml.internal.,\
+                   com.sun.imageio.,\
+                   com.sun.istack.internal.,\
+                   com.sun.jmx.,\
+                   com.sun.proxy.,\
+                   com.sun.org.apache.bcel.internal.,\
+                   com.sun.org.apache.regexp.internal.,\
+                   com.sun.org.apache.xerces.internal.,\
+                   com.sun.org.apache.xpath.internal.,\
+                   com.sun.org.apache.xalan.internal.extensions.,\
+                   com.sun.org.apache.xalan.internal.lib.,\
+                   com.sun.org.apache.xalan.internal.res.,\
+                   com.sun.org.apache.xalan.internal.templates.,\
+                   com.sun.org.apache.xalan.internal.utils.,\
+                   com.sun.org.apache.xalan.internal.xslt.,\
+                   com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+                   com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+                   com.sun.org.apache.xalan.internal.xsltc.trax.,\
+                   com.sun.org.apache.xalan.internal.xsltc.util.,\
+                   com.sun.org.apache.xml.internal.res.,\
+                   com.sun.org.apache.xml.internal.serializer.utils.,\
+                   com.sun.org.apache.xml.internal.utils.,\
+                   com.sun.org.glassfish.
 
 #
 # Determines whether this properties file can be appended to
--- jdk/src/share/lib/security/java.security-macosx	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/lib/security/java.security-macosx	2013-05-05 09:38:38.000000000 -0700
@@ -124,7 +124,31 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,apple.
+package.access=sun.,\
+               com.sun.xml.internal.,\
+               com.sun.imageio.,\
+               com.sun.istack.internal.,\
+               com.sun.jmx.,\
+               com.sun.proxy.,\
+               com.sun.org.apache.bcel.internal.,\
+               com.sun.org.apache.regexp.internal.,\
+               com.sun.org.apache.xerces.internal.,\
+               com.sun.org.apache.xpath.internal.,\
+               com.sun.org.apache.xalan.internal.extensions.,\
+               com.sun.org.apache.xalan.internal.lib.,\
+               com.sun.org.apache.xalan.internal.res.,\
+               com.sun.org.apache.xalan.internal.templates.,\
+               com.sun.org.apache.xalan.internal.utils.,\
+               com.sun.org.apache.xalan.internal.xslt.,\
+               com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+               com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+               com.sun.org.apache.xalan.internal.xsltc.trax.,\
+               com.sun.org.apache.xalan.internal.xsltc.util.,\
+               com.sun.org.apache.xml.internal.res.,\
+               com.sun.org.apache.xml.internal.serializer.utils.,\
+               com.sun.org.apache.xml.internal.utils.,\
+               com.sun.org.glassfish.,\
+               apple.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -136,7 +160,31 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,apple.
+package.definition=sun.,\
+                   com.sun.xml.internal.,\
+                   com.sun.imageio.,\
+                   com.sun.istack.internal.,\
+                   com.sun.jmx.,\
+                   com.sun.proxy.,\
+                   com.sun.org.apache.bcel.internal.,\
+                   com.sun.org.apache.regexp.internal.,\
+                   com.sun.org.apache.xerces.internal.,\
+                   com.sun.org.apache.xpath.internal.,\
+                   com.sun.org.apache.xalan.internal.extensions.,\
+                   com.sun.org.apache.xalan.internal.lib.,\
+                   com.sun.org.apache.xalan.internal.res.,\
+                   com.sun.org.apache.xalan.internal.templates.,\
+                   com.sun.org.apache.xalan.internal.utils.,\
+                   com.sun.org.apache.xalan.internal.xslt.,\
+                   com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+                   com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+                   com.sun.org.apache.xalan.internal.xsltc.trax.,\
+                   com.sun.org.apache.xalan.internal.xsltc.util.,\
+                   com.sun.org.apache.xml.internal.res.,\
+                   com.sun.org.apache.xml.internal.serializer.utils.,\
+                   com.sun.org.apache.xml.internal.utils.,\
+                   com.sun.org.glassfish.,\
+                   apple.
 
 #
 # Determines whether this properties file can be appended to
--- jdk/src/share/lib/security/java.security-solaris	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/lib/security/java.security-solaris	2013-05-05 09:38:38.000000000 -0700
@@ -125,7 +125,30 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.access=sun.,\
+               com.sun.xml.internal.,\
+               com.sun.imageio.,\
+               com.sun.istack.internal.,\
+               com.sun.jmx.,\
+               com.sun.proxy.,\
+               com.sun.org.apache.bcel.internal.,\
+               com.sun.org.apache.regexp.internal.,\
+               com.sun.org.apache.xerces.internal.,\
+               com.sun.org.apache.xpath.internal.,\
+               com.sun.org.apache.xalan.internal.extensions.,\
+               com.sun.org.apache.xalan.internal.lib.,\
+               com.sun.org.apache.xalan.internal.res.,\
+               com.sun.org.apache.xalan.internal.templates.,\
+               com.sun.org.apache.xalan.internal.utils.,\
+               com.sun.org.apache.xalan.internal.xslt.,\
+               com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+               com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+               com.sun.org.apache.xalan.internal.xsltc.trax.,\
+               com.sun.org.apache.xalan.internal.xsltc.util.,\
+               com.sun.org.apache.xml.internal.res.,\
+               com.sun.org.apache.xml.internal.serializer.utils.,\
+               com.sun.org.apache.xml.internal.utils.,\
+               com.sun.org.glassfish.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -137,7 +160,30 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.definition=sun.,\
+                   com.sun.xml.internal.,\
+                   com.sun.imageio.,\
+                   com.sun.istack.internal.,\
+                   com.sun.jmx.,\
+                   com.sun.proxy.,\
+                   com.sun.org.apache.bcel.internal.,\
+                   com.sun.org.apache.regexp.internal.,\
+                   com.sun.org.apache.xerces.internal.,\
+                   com.sun.org.apache.xpath.internal.,\
+                   com.sun.org.apache.xalan.internal.extensions.,\
+                   com.sun.org.apache.xalan.internal.lib.,\
+                   com.sun.org.apache.xalan.internal.res.,\
+                   com.sun.org.apache.xalan.internal.templates.,\
+                   com.sun.org.apache.xalan.internal.utils.,\
+                   com.sun.org.apache.xalan.internal.xslt.,\
+                   com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+                   com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+                   com.sun.org.apache.xalan.internal.xsltc.trax.,\
+                   com.sun.org.apache.xalan.internal.xsltc.util.,\
+                   com.sun.org.apache.xml.internal.res.,\
+                   com.sun.org.apache.xml.internal.serializer.utils.,\
+                   com.sun.org.apache.xml.internal.utils.,\
+                   com.sun.org.glassfish.
 
 #
 # Determines whether this properties file can be appended to
--- jdk/src/share/lib/security/java.security-windows	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/lib/security/java.security-windows	2013-05-05 09:38:38.000000000 -0700
@@ -124,7 +124,31 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.access=sun.,\
+               com.sun.xml.internal.,\
+               com.sun.imageio.,\
+               com.sun.istack.internal.,\
+               com.sun.jmx.,\
+               com.sun.proxy.,\
+               com.sun.org.apache.bcel.internal.,\
+               com.sun.org.apache.regexp.internal.,\
+               com.sun.org.apache.xerces.internal.,\
+               com.sun.org.apache.xpath.internal.,\
+               com.sun.org.apache.xalan.internal.extensions.,\
+               com.sun.org.apache.xalan.internal.lib.,\
+               com.sun.org.apache.xalan.internal.res.,\
+               com.sun.org.apache.xalan.internal.templates.,\
+               com.sun.org.apache.xalan.internal.utils.,\
+               com.sun.org.apache.xalan.internal.xslt.,\
+               com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+               com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+               com.sun.org.apache.xalan.internal.xsltc.trax.,\
+               com.sun.org.apache.xalan.internal.xsltc.util.,\
+               com.sun.org.apache.xml.internal.res.,\
+               com.sun.org.apache.xml.internal.serializer.utils.,\
+               com.sun.org.apache.xml.internal.utils.,\
+               com.sun.org.glassfish.,\
+               com.sun.java.accessibility.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -136,7 +160,31 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.definition=sun.,\
+                   com.sun.xml.internal.,\
+                   com.sun.imageio.,\
+                   com.sun.istack.internal.,\
+                   com.sun.jmx.,\
+                   com.sun.proxy.,\
+                   com.sun.org.apache.bcel.internal.,\
+                   com.sun.org.apache.regexp.internal.,\
+                   com.sun.org.apache.xerces.internal.,\
+                   com.sun.org.apache.xpath.internal.,\
+                   com.sun.org.apache.xalan.internal.extensions.,\
+                   com.sun.org.apache.xalan.internal.lib.,\
+                   com.sun.org.apache.xalan.internal.res.,\
+                   com.sun.org.apache.xalan.internal.templates.,\
+                   com.sun.org.apache.xalan.internal.utils.,\
+                   com.sun.org.apache.xalan.internal.xslt.,\
+                   com.sun.org.apache.xalan.internal.xsltc.cmdline.,\
+                   com.sun.org.apache.xalan.internal.xsltc.compiler.,\
+                   com.sun.org.apache.xalan.internal.xsltc.trax.,\
+                   com.sun.org.apache.xalan.internal.xsltc.util.,\
+                   com.sun.org.apache.xml.internal.res.,\
+                   com.sun.org.apache.xml.internal.serializer.utils.,\
+                   com.sun.org.apache.xml.internal.utils.,\
+                   com.sun.org.glassfish.,\
+                   com.sun.java.accessibility.
 
 #
 # Determines whether this properties file can be appended to
--- jdk/src/share/native/com/sun/java/util/jar/pack/bands.cpp	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/native/com/sun/java/util/jar/pack/bands.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -187,6 +187,10 @@
 
 entry* band::getRefCommon(cpindex* ix_, bool nullOKwithCaller) {
   CHECK_0;
+  if (ix_ == NULL) {
+      abort("no index");
+      return NULL;
+  }
   assert(ix_->ixTag == ixTag
          || (ixTag == CONSTANT_Literal
              && ix_->ixTag >= CONSTANT_Integer
--- jdk/src/share/native/com/sun/java/util/jar/pack/bands.h	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/native/com/sun/java/util/jar/pack/bands.h	2013-05-05 09:38:38.000000000 -0700
@@ -101,8 +101,8 @@
 
   int    getByte()  { assert(ix == null); return vs[0].getByte(); }
   int    getInt()   { assert(ix == null); return vs[0].getInt(); }
-  entry* getRefN()  { assert(ix != null); return getRefCommon(ix, true); }
-  entry* getRef()   { assert(ix != null); return getRefCommon(ix, false); }
+  entry* getRefN()  { return getRefCommon(ix, true); }
+  entry* getRef()   { return getRefCommon(ix, false); }
   entry* getRefUsing(cpindex* ix2)
                     { assert(ix == null); return getRefCommon(ix2, true); }
   entry* getRefCommon(cpindex* ix, bool nullOK);
--- jdk/src/share/native/com/sun/java/util/jar/pack/defines.h	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/native/com/sun/java/util/jar/pack/defines.h	2013-05-05 09:38:38.000000000 -0700
@@ -93,7 +93,7 @@
 // bytes and byte arrays
 
 typedef unsigned int uint;
-#if !defined(MACOSX) || (defined(MACOSX) && defined(NO_ZLIB))
+#if !defined(_ALLBSD_SOURCE) || (defined(_ALLBSD_SOURCE) && defined(NO_ZLIB))
 #ifdef _LP64
 typedef unsigned int uLong; // Historical zlib, should be 32-bit.
 #else
--- jdk/src/share/native/com/sun/java/util/jar/pack/jni.cpp	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/native/com/sun/java/util/jar/pack/jni.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -50,6 +50,7 @@
 static jmethodID currentInstMID;
 static jmethodID readInputMID;
 static jclass    NIclazz;
+static jmethodID getUnpackerPtrMID;
 
 static char* dbg = null;
 
@@ -60,8 +61,8 @@
 
 static unpacker* get_unpacker(JNIEnv *env, jobject pObj, bool noCreate=false) {
   unpacker* uPtr;
-  uPtr = (unpacker*)jlong2ptr(env->GetLongField(pObj, unpackerPtrFID));
-  //fprintf(stderr, "get_unpacker(%p) uPtr=%p\n", pObj, uPtr);
+  jlong p = env->CallLongMethod(pObj, getUnpackerPtrMID);
+  uPtr = (unpacker*)jlong2ptr(p);
   if (uPtr == null) {
     if (noCreate)  return null;
     uPtr = new unpacker();
@@ -90,11 +91,15 @@
   if (env == null)
     return null;
   jobject pObj = env->CallStaticObjectMethod(NIclazz, currentInstMID);
-  //fprintf(stderr, "get_unpacker() pObj=%p\n", pObj);
-  if (pObj == null)
-    return null;
-  // Got pObj and env; now do it the easy way.
-  return get_unpacker(env, pObj);
+  //fprintf(stderr, "get_unpacker0() pObj=%p\n", pObj);
+  if (pObj != null) {
+    // Got pObj and env; now do it the easy way.
+    return get_unpacker(env, pObj);
+  }
+  // this should really not happen, if it does something is seriously
+  // wrong throw an exception
+  THROW_IOE(ERROR_INTERNAL);
+  return null;
 }
 
 static void free_unpacker(JNIEnv *env, jobject pObj, unpacker* uPtr) {
@@ -123,18 +128,23 @@
 
 JNIEXPORT void JNICALL
 Java_com_sun_java_util_jar_pack_NativeUnpack_initIDs(JNIEnv *env, jclass clazz) {
+#ifndef PRODUCT
   dbg = getenv("DEBUG_ATTACH");
   while( dbg != null) { sleep(10); }
+#endif
   NIclazz = (jclass) env->NewGlobalRef(clazz);
   unpackerPtrFID = env->GetFieldID(clazz, "unpackerPtr", "J");
   currentInstMID = env->GetStaticMethodID(clazz, "currentInstance",
                                           "()Ljava/lang/Object;");
   readInputMID = env->GetMethodID(clazz, "readInputFn",
                                   "(Ljava/nio/ByteBuffer;J)J");
+  getUnpackerPtrMID = env->GetMethodID(clazz, "getUnpackerPtr", "()J");
+
   if (unpackerPtrFID == null ||
       currentInstMID == null ||
       readInputMID == null ||
-      NIclazz == null) {
+      NIclazz == null ||
+      getUnpackerPtrMID == null) {
     THROW_IOE("cannot init class members");
   }
 }
@@ -142,8 +152,13 @@
 JNIEXPORT jlong JNICALL
 Java_com_sun_java_util_jar_pack_NativeUnpack_start(JNIEnv *env, jobject pObj,
                                    jobject pBuf, jlong offset) {
-  unpacker* uPtr = get_unpacker(env, pObj);
-
+  // try to get the unpacker pointer the hard way first, we do this to ensure
+  // valid object pointers and env is intact, if not now is good time to bail.
+  unpacker* uPtr = get_unpacker();
+  //fprintf(stderr, "start(%p) uPtr=%p initializing\n", pObj, uPtr);
+  if (uPtr == null) {
+      return -1;
+  }
   // redirect our io to the default log file or whatever.
   uPtr->redirect_stdio();
 
@@ -159,7 +174,12 @@
     else
       { buf = (char*)buf + (size_t)offset; buflen -= (size_t)offset; }
   }
-
+  // before we start off we make sure there is no other error by the time we
+  // get here
+  if (uPtr->aborting()) {
+    THROW_IOE(uPtr->get_abort_message());
+    return 0;
+  }
   uPtr->start(buf, buflen);
   if (uPtr->aborting()) {
     THROW_IOE(uPtr->get_abort_message());
@@ -226,11 +246,14 @@
 
   // We have fetched all the files.
   // Now swallow up any remaining input.
-  if (uPtr->input_remaining() == 0)
+  if (uPtr->input_remaining() == 0) {
     return null;
-  else
-    return env->NewDirectByteBuffer(uPtr->input_scan(),
-                                    uPtr->input_remaining());
+  } else {
+    bytes remaining_bytes;
+    remaining_bytes.malloc(uPtr->input_remaining());
+    remaining_bytes.copyFrom(uPtr->input_scan(), uPtr->input_remaining());
+    return env->NewDirectByteBuffer(remaining_bytes.ptr, remaining_bytes.len);
+  }
 }
 
 JNIEXPORT jlong JNICALL
--- jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp	2012-08-10 10:30:16.000000000 -0700
+++ jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -267,11 +267,13 @@
 }
 
 inline cpindex* cpool::getFieldIndex(entry* classRef) {
+  if (classRef == NULL) { abort("missing class reference"); return NULL; }
   assert(classRef->tagMatches(CONSTANT_Class));
   assert((uint)classRef->inord < (uint)tag_count[CONSTANT_Class]);
   return &member_indexes[classRef->inord*2+0];
 }
 inline cpindex* cpool::getMethodIndex(entry* classRef) {
+  if (classRef == NULL) { abort("missing class reference"); return NULL; }
   assert(classRef->tagMatches(CONSTANT_Class));
   assert((uint)classRef->inord < (uint)tag_count[CONSTANT_Class]);
   return &member_indexes[classRef->inord*2+1];
@@ -1238,6 +1240,7 @@
     entry& e = cpMap[i];
     e.refs = U_NEW(entry*, e.nrefs = 2);
     e.refs[0] = cp_band1.getRef();
+    CHECK;
     e.refs[1] = cp_band2.getRef();
     CHECK;
   }
@@ -1963,6 +1966,7 @@
     int    attrc   = ADH_BYTE_CONTEXT(header);
     int    idx     = ADH_BYTE_INDEX(header);
     entry* name    = attr_definition_name.getRef();
+    CHECK;
     entry* layout  = attr_definition_layout.getRef();
     CHECK;
     attr_defs[attrc].defineLayout(idx, name, layout->value.b.strval());
@@ -2067,7 +2071,9 @@
     if (ics[i].name == NO_ENTRY_YET) {
       // Long form.
       ics[i].outer = ic_outer_class.getRefN();
+      CHECK;
       ics[i].name  = ic_name.getRefN();
+      CHECK;
     } else {
       // Fill in outer and name based on inner.
       bytes& n = ics[i].inner->value.b;
@@ -2583,6 +2589,7 @@
           e = b.getRefUsing(cp.getKQIndex());
         else
           e = b.getRefN();
+        CHECK;
         switch (b.le_len) {
         case 0: break;
         case 1: putu1ref(e); break;
@@ -2964,7 +2971,7 @@
 
 void unpacker::read_bands() {
   byte* rp0 = rp;
-
+  CHECK;
   read_file_header();
   CHECK;
 
@@ -3632,10 +3639,12 @@
 // packed file and len is the length of the buffer.
 // If null, the callback is used to fill an internal buffer.
 void unpacker::start(void* packptr, size_t len) {
+  CHECK;
   NOT_PRODUCT(debug_u = this);
   if (packptr != null && len != 0) {
     inbytes.set((byte*) packptr, len);
   }
+  CHECK;
   read_bands();
 }
 
@@ -3766,6 +3775,7 @@
     NOT_PRODUCT(bc_superfield.setIndex(null));
     NOT_PRODUCT(bc_supermethod.setIndex(null));
   }
+  CHECK;
 
   for (int curIP = 0; ; curIP++) {
     int curPC = (int)(wpoffset() - codeBase);
@@ -3879,7 +3889,8 @@
         int coding = bc_initref.getInt();
         // Find the nth overloading of <init> in classRef.
         entry*   ref = null;
-        cpindex* ix = (classRef == null)? null: cp.getMethodIndex(classRef);
+        cpindex* ix = cp.getMethodIndex(classRef);
+        CHECK;
         for (int j = 0, which_init = 0; ; j++) {
           ref = (ix == null)? null: ix->get(j);
           if (ref == null)  break;  // oops, bad input
@@ -4150,6 +4161,7 @@
       case ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_EnclosingMethod):
         aname = cp.sym[cpool::s_EnclosingMethod];
         putref(class_EnclosingMethod_RC.getRefN());
+        CHECK_0;
         putref(class_EnclosingMethod_RDN.getRefN());
         break;
 
@@ -4168,6 +4180,7 @@
         putu2(count = method_Exceptions_N.getInt());
         for (j = 0; j < count; j++) {
           putref(method_Exceptions_RC.getRefN());
+          CHECK_0;
         }
         break;
 
@@ -4191,16 +4204,18 @@
             // (253)     [(1)(2)(2)]
             // (254)     [(1)(2)(2)(2)]
             putu2(code_StackMapTable_offset.getInt());
+            CHECK_0;
             for (int k = (tag - 251); k > 0; k--) {
               put_stackmap_type();
+              CHECK_0;
             }
           } else {
             // (255)     [(1)NH[(2)]NH[(2)]]
             putu2(code_StackMapTable_offset.getInt());
             putu2(j2 = code_StackMapTable_local_N.getInt());
-            while (j2-- > 0)  put_stackmap_type();
+            while (j2-- > 0) {put_stackmap_type(); CHECK_0;}
             putu2(j2 = code_StackMapTable_stack_N.getInt());
-            while (j2-- > 0)  put_stackmap_type();
+            while (j2-- > 0)  {put_stackmap_type(); CHECK_0;}
           }
         }
         break;
@@ -4224,7 +4239,9 @@
           bii    += code_LocalVariableTable_span_O.getInt();
           putu2(to_bci(bii) - bci);
           putref(code_LocalVariableTable_name_RU.getRefN());
+          CHECK_0;
           putref(code_LocalVariableTable_type_RS.getRefN());
+          CHECK_0;
           putu2(code_LocalVariableTable_slot.getInt());
         }
         break;
@@ -4239,7 +4256,9 @@
           bii    += code_LocalVariableTypeTable_span_O.getInt();
           putu2(to_bci(bii) - bci);
           putref(code_LocalVariableTypeTable_name_RU.getRefN());
+          CHECK_0;
           putref(code_LocalVariableTypeTable_type_RS.getRefN());
+          CHECK_0;
           putu2(code_LocalVariableTypeTable_slot.getInt());
         }
         break;
@@ -4267,7 +4286,7 @@
         break;
       }
     }
-
+    CHECK_0;
     if (aname == null) {
       // Unparse a compressor-defined attribute.
       layout_definition* lo = ad.getLayout(idx);
@@ -4366,6 +4385,7 @@
   julong indexMask = ad.flagIndexMask();
 
   cur_class = class_this.getRef();
+  CHECK;
   cur_super = class_super.getRef();
 
   CHECK;
@@ -4380,6 +4400,7 @@
   putu2(num = class_interface_count.getInt());
   for (i = 0; i < num; i++) {
     putref(class_interface.getRef());
+    CHECK;
   }
 
   write_members(class_field_count.getInt(),  ATTR_CONTEXT_FIELD);
@@ -4460,7 +4481,9 @@
       flags &= ~ACC_IC_LONG_FORM;  // clear high bit if set to get clean zero
       extra_ic.flags = flags;
       extra_ic.outer = class_InnerClasses_outer_RCN.getRefN();
+      CHECK;
       extra_ic.name  = class_InnerClasses_name_RUN.getRefN();
+      CHECK;
       // Detect if this is an exact copy of the global tuple.
       if (global_ic != null) {
         if (global_ic->flags != extra_ic.flags ||
--- jdk/src/share/native/com/sun/media/sound/SoundDefs.h	2012-08-10 10:30:18.000000000 -0700
+++ jdk/src/share/native/com/sun/media/sound/SoundDefs.h	2013-05-05 09:38:38.000000000 -0700
@@ -64,7 +64,7 @@
 
 
 // following is needed for _LP64
-#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX) || (X_PLATFORM == X_MACOSX))
+#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX) || (X_PLATFORM == X_BSD) || (X_PLATFORM == X_MACOSX))
 #include <sys/types.h>
 #endif
 
--- jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	2012-08-10 10:30:19.000000000 -0700
+++ jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	2013-05-05 09:38:38.000000000 -0700
@@ -24,6 +24,9 @@
  * questions.
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
 #ifdef _ALLBSD_SOURCE
 #include <machine/endian.h>
 #elif __linux__
@@ -32,6 +35,12 @@
 #endif
 #include "jfdlibm.h"
 
+/* BSD's always define both _LITTLE_ENDIAN && _BIG_ENDIAN */
+#if defined(_LITTLE_ENDIAN) && defined(_BIG_ENDIAN) && \
+    _BYTE_ORDER == _BIG_ENDIAN
+#undef _LITTLE_ENDIAN
+#endif
+
 #ifdef __NEWVALID       /* special setup for Sun test regime */
 #if defined(i386) || defined(i486) || \
     defined(intel) || defined(x86) || defined(arm) || \
--- jdk/src/share/native/java/net/InetAddress.c	2012-08-10 10:30:21.000000000 -0700
+++ jdk/src/share/native/java/net/InetAddress.c	2013-05-05 09:38:38.000000000 -0700
@@ -33,8 +33,11 @@
  */
 
 jclass ia_class;
-jfieldID ia_addressID;
-jfieldID ia_familyID;
+jclass iac_class;
+jfieldID ia_holderID;
+jfieldID iac_addressID;
+jfieldID iac_familyID;
+jfieldID iac_hostNameID;
 jfieldID ia_preferIPv6AddressID;
 
 /*
@@ -48,10 +51,18 @@
     CHECK_NULL(c);
     ia_class = (*env)->NewGlobalRef(env, c);
     CHECK_NULL(ia_class);
-    ia_addressID = (*env)->GetFieldID(env, ia_class, "address", "I");
-    CHECK_NULL(ia_addressID);
-    ia_familyID = (*env)->GetFieldID(env, ia_class, "family", "I");
-    CHECK_NULL(ia_familyID);
+    c = (*env)->FindClass(env,"java/net/InetAddress$InetAddressHolder");
+    CHECK_NULL(c);
+    iac_class = (*env)->NewGlobalRef(env, c);
+    ia_holderID = (*env)->GetFieldID(env, ia_class, "holder", "Ljava/net/InetAddress$InetAddressHolder;");
+    CHECK_NULL(ia_holderID);
     ia_preferIPv6AddressID = (*env)->GetStaticFieldID(env, ia_class, "preferIPv6Address", "Z");
     CHECK_NULL(ia_preferIPv6AddressID);
+
+    iac_addressID = (*env)->GetFieldID(env, iac_class, "address", "I");
+    CHECK_NULL(iac_addressID);
+    iac_familyID = (*env)->GetFieldID(env, iac_class, "family", "I");
+    CHECK_NULL(iac_familyID);
+    iac_hostNameID = (*env)->GetFieldID(env, iac_class, "hostName", "Ljava/lang/String;");
+    CHECK_NULL(iac_hostNameID);
 }
--- jdk/src/share/native/java/net/net_util.c	2012-08-10 10:30:21.000000000 -0700
+++ jdk/src/share/native/java/net/net_util.c	2013-05-05 09:38:38.000000000 -0700
@@ -84,6 +84,58 @@
     }
 }
 
+/* The address, and family fields used to be in InetAddress
+ * but are now in an implementation object. So, there is an extra
+ * level of indirection to access them now.
+ */
+
+extern jclass iac_class;
+extern jfieldID ia_holderID;
+extern jfieldID iac_addressID;
+extern jfieldID iac_familyID;
+
+void setInetAddress_addr(JNIEnv *env, jobject iaObj, int address) {
+    jobject holder;
+    init(env);
+    holder = (*env)->GetObjectField(env, iaObj, ia_holderID);
+    (*env)->SetIntField(env, holder, iac_addressID, address);
+}
+
+void setInetAddress_family(JNIEnv *env, jobject iaObj, int family) {
+    jobject holder;
+    init(env);
+    holder = (*env)->GetObjectField(env, iaObj, ia_holderID);
+    (*env)->SetIntField(env, holder, iac_familyID, family);
+}
+
+void setInetAddress_hostName(JNIEnv *env, jobject iaObj, jobject host) {
+    jobject holder;
+    init(env);
+    holder = (*env)->GetObjectField(env, iaObj, ia_holderID);
+    (*env)->SetObjectField(env, holder, iac_hostNameID, host);
+}
+
+int getInetAddress_addr(JNIEnv *env, jobject iaObj) {
+    jobject holder;
+    init(env);
+    holder = (*env)->GetObjectField(env, iaObj, ia_holderID);
+    return (*env)->GetIntField(env, holder, iac_addressID);
+}
+
+int getInetAddress_family(JNIEnv *env, jobject iaObj) {
+    jobject holder;
+    init(env);
+    holder = (*env)->GetObjectField(env, iaObj, ia_holderID);
+    return (*env)->GetIntField(env, holder, iac_familyID);
+}
+
+jobject getInetAddress_hostName(JNIEnv *env, jobject iaObj) {
+    jobject holder;
+    init(env);
+    holder = (*env)->GetObjectField(env, iaObj, ia_holderID);
+    return (*env)->GetObjectField(env, holder, iac_hostNameID);
+}
+
 JNIEXPORT jobject JNICALL
 NET_SockaddrToInetAddress(JNIEnv *env, struct sockaddr *him, int *port) {
     jobject iaObj;
@@ -110,8 +162,8 @@
             iaObj = (*env)->NewObject(env, inet4Cls, ia4_ctrID);
             CHECK_NULL_RETURN(iaObj, NULL);
             address = NET_IPv4MappedToIPv4(caddr);
-            (*env)->SetIntField(env, iaObj, ia_addressID, address);
-            (*env)->SetIntField(env, iaObj, ia_familyID, IPv4);
+            setInetAddress_addr(env, iaObj, address);
+            setInetAddress_family(env, iaObj, IPv4);
         } else {
             static jclass inet6Cls = 0;
             jint scope;
@@ -131,7 +183,7 @@
 
             (*env)->SetObjectField(env, iaObj, ia6_ipaddressID, ipaddress);
 
-            (*env)->SetIntField(env, iaObj, ia_familyID, IPv6);
+            setInetAddress_family(env, iaObj, IPv6);
             scope = getScopeID(him);
             (*env)->SetIntField(env, iaObj, ia6_scopeidID, scope);
             if (scope > 0)
@@ -153,9 +205,8 @@
             }
             iaObj = (*env)->NewObject(env, inet4Cls, ia4_ctrID);
             CHECK_NULL_RETURN(iaObj, NULL);
-            (*env)->SetIntField(env, iaObj, ia_familyID, IPv4);
-            (*env)->SetIntField(env, iaObj, ia_addressID,
-                                ntohl(him4->sin_addr.s_addr));
+            setInetAddress_family(env, iaObj, IPv4);
+            setInetAddress_addr(env, iaObj, ntohl(him4->sin_addr.s_addr));
             *port = ntohs(him4->sin_port);
         }
     return iaObj;
@@ -167,8 +218,7 @@
     jint family = AF_INET;
 
 #ifdef AF_INET6
-    family = (*env)->GetIntField(env, iaObj, ia_familyID) == IPv4?
-        AF_INET : AF_INET6;
+    family = getInetAddress_family(env, iaObj) == IPv4? AF_INET : AF_INET6;
     if (him->sa_family == AF_INET6) {
 #ifdef WIN32
         struct SOCKADDR_IN6 *him6 = (struct SOCKADDR_IN6 *)him;
@@ -183,7 +233,7 @@
                 return JNI_FALSE;
             }
             addrNew = NET_IPv4MappedToIPv4(caddrNew);
-            addrCur = (*env)->GetIntField(env, iaObj, ia_addressID);
+            addrCur = getInetAddress_addr(env, iaObj);
             if (addrNew == addrCur) {
                 return JNI_TRUE;
             } else {
@@ -215,7 +265,7 @@
                 return JNI_FALSE;
             }
             addrNew = ntohl(him4->sin_addr.s_addr);
-            addrCur = (*env)->GetIntField(env, iaObj, ia_addressID);
+            addrCur = getInetAddress_addr(env, iaObj);
             if (addrNew == addrCur) {
                 return JNI_TRUE;
             } else {
--- jdk/src/share/native/java/net/net_util.h	2012-08-10 10:30:21.000000000 -0700
+++ jdk/src/share/native/java/net/net_util.h	2013-05-05 09:38:38.000000000 -0700
@@ -53,10 +53,18 @@
  * i.e. psi_timeoutID is PlainSocketImpl's timeout field's ID.
  */
 extern jclass ia_class;
-extern jfieldID ia_addressID;
-extern jfieldID ia_familyID;
+extern jfieldID iac_addressID;
+extern jfieldID iac_familyID;
+extern jfieldID iac_hostNameID;
 extern jfieldID ia_preferIPv6AddressID;
 
+extern void setInetAddress_addr(JNIEnv *env, jobject iaObj, int address);
+extern void setInetAddress_family(JNIEnv *env, jobject iaObj, int family);
+extern void setInetAddress_hostName(JNIEnv *env, jobject iaObj, jobject h);
+extern int getInetAddress_addr(JNIEnv *env, jobject iaObj);
+extern int getInetAddress_family(JNIEnv *env, jobject iaObj);
+extern jobject getInetAddress_hostName(JNIEnv *env, jobject iaObj);
+
 extern jclass ia4_class;
 extern jmethodID ia4_ctrID;
 
--- jdk/src/share/native/sun/awt/image/awt_ImageRep.c	2012-08-10 10:30:22.000000000 -0700
+++ jdk/src/share/native/sun/awt/image/awt_ImageRep.c	2013-05-05 09:38:39.000000000 -0700
@@ -45,6 +45,53 @@
 #  define TRUE 1
 #endif
 
+#define CHECK_STRIDE(yy, hh, ss)                            \
+    if ((ss) != 0) {                                        \
+        int limit = 0x7fffffff / ((ss) > 0 ? (ss) : -(ss)); \
+        if (limit < (yy) || limit < ((yy) + (hh) - 1)) {    \
+            /* integer oveflow */                           \
+            return JNI_FALSE;                               \
+        }                                                   \
+    }                                                       \
+
+#define CHECK_SRC()                                      \
+    do {                                                 \
+        int pixeloffset;                                 \
+        if (off < 0 || off >= srcDataLength) {           \
+            return JNI_FALSE;                            \
+        }                                                \
+        CHECK_STRIDE(0, h, scansize);                    \
+                                                         \
+        /* check scansize */                             \
+        pixeloffset = scansize * (h - 1);                \
+        if ((w - 1) > (0x7fffffff - pixeloffset)) {      \
+            return JNI_FALSE;                            \
+        }                                                \
+        pixeloffset += (w - 1);                          \
+                                                         \
+        if (off > (0x7fffffff - pixeloffset)) {          \
+            return JNI_FALSE;                            \
+        }                                                \
+    } while (0)                                          \
+
+#define CHECK_DST(xx, yy)                                \
+    do {                                                 \
+        int soffset = (yy) * sStride;                    \
+        int poffset = (xx) * pixelStride;                \
+        if (poffset > (0x7fffffff - soffset)) {          \
+            return JNI_FALSE;                            \
+        }                                                \
+        poffset += soffset;                              \
+        if (dstDataOff > (0x7fffffff - poffset)) {       \
+            return JNI_FALSE;                            \
+        }                                                \
+        poffset += dstDataOff;                           \
+                                                         \
+        if (poffset < 0 || poffset >= dstDataLength) {   \
+            return JNI_FALSE;                            \
+        }                                                \
+    } while (0)                                          \
+
 static jfieldID s_JnumSrcLUTID;
 static jfieldID s_JsrcLUTtransIndexID;
 
@@ -58,7 +105,7 @@
 /*
  * This routine is used to draw ICM pixels into a default color model
  */
-JNIEXPORT void JNICALL
+JNIEXPORT jboolean JNICALL
 Java_sun_awt_image_ImageRepresentation_setICMpixels(JNIEnv *env, jclass cls,
                                                     jint x, jint y, jint w,
                                                     jint h, jintArray jlut,
@@ -67,7 +114,10 @@
                                                     jobject jict)
 {
     unsigned char *srcData = NULL;
+    jint srcDataLength;
     int *dstData;
+    jint dstDataLength;
+    jint dstDataOff;
     int *dstP, *dstyP;
     unsigned char *srcyP, *srcP;
     int *srcLUT = NULL;
@@ -80,12 +130,20 @@
 
     if (JNU_IsNull(env, jlut)) {
         JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
+        return JNI_FALSE;
     }
 
     if (JNU_IsNull(env, jpix)) {
         JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
+        return JNI_FALSE;
+    }
+
+    if (x < 0 || w < 1 || (0x7fffffff - x) < w) {
+        return JNI_FALSE;
+    }
+
+    if (y < 0 || h < 1 || (0x7fffffff - y) < h) {
+        return JNI_FALSE;
     }
 
     sStride = (*env)->GetIntField(env, jict, g_ICRscanstrID);
@@ -93,10 +151,47 @@
     joffs = (*env)->GetObjectField(env, jict, g_ICRdataOffsetsID);
     jdata = (*env)->GetObjectField(env, jict, g_ICRdataID);
 
+    if (JNU_IsNull(env, jdata)) {
+        /* no destination buffer */
+        return JNI_FALSE;
+    }
+
+    if (JNU_IsNull(env, joffs) || (*env)->GetArrayLength(env, joffs) < 1) {
+        /* invalid data offstes in raster */
+        return JNI_FALSE;
+    }
+
+    srcDataLength = (*env)->GetArrayLength(env, jpix);
+    dstDataLength = (*env)->GetArrayLength(env, jdata);
+
+    cOffs = (int *) (*env)->GetPrimitiveArrayCritical(env, joffs, NULL);
+    if (cOffs == NULL) {
+        JNU_ThrowNullPointerException(env, "Null channel offset array");
+        return JNI_FALSE;
+    }
+
+    dstDataOff = cOffs[0];
+
+    /* the offset array is not needed anymore and can be released */
+    (*env)->ReleasePrimitiveArrayCritical(env, joffs, cOffs, JNI_ABORT);
+    joffs = NULL;
+    cOffs = NULL;
+
+    /* do basic validation: make sure that offsets for
+    * first pixel and for last pixel are safe to calculate and use */
+    CHECK_STRIDE(y, h, sStride);
+    CHECK_STRIDE(x, w, pixelStride);
+
+    CHECK_DST(x, y);
+    CHECK_DST(x + w -1, y + h - 1);
+
+    /* check source array */
+    CHECK_SRC();
+
     srcLUT = (int *) (*env)->GetPrimitiveArrayCritical(env, jlut, NULL);
     if (srcLUT == NULL) {
         JNU_ThrowNullPointerException(env, "Null IndexColorModel LUT");
-        return;
+        return JNI_FALSE;
     }
 
     srcData = (unsigned char *) (*env)->GetPrimitiveArrayCritical(env, jpix,
@@ -104,27 +199,18 @@
     if (srcData == NULL) {
         (*env)->ReleasePrimitiveArrayCritical(env, jlut, srcLUT, JNI_ABORT);
         JNU_ThrowNullPointerException(env, "Null data array");
-        return;
-    }
-
-    cOffs = (int *) (*env)->GetPrimitiveArrayCritical(env, joffs, NULL);
-    if (cOffs == NULL) {
-        (*env)->ReleasePrimitiveArrayCritical(env, jlut, srcLUT, JNI_ABORT);
-        (*env)->ReleasePrimitiveArrayCritical(env, jpix, srcData, JNI_ABORT);
-        JNU_ThrowNullPointerException(env, "Null channel offset array");
-        return;
+        return JNI_FALSE;
     }
 
     dstData = (int *) (*env)->GetPrimitiveArrayCritical(env, jdata, NULL);
     if (dstData == NULL) {
         (*env)->ReleasePrimitiveArrayCritical(env, jlut, srcLUT, JNI_ABORT);
         (*env)->ReleasePrimitiveArrayCritical(env, jpix, srcData, JNI_ABORT);
-        (*env)->ReleasePrimitiveArrayCritical(env, joffs, cOffs, JNI_ABORT);
         JNU_ThrowNullPointerException(env, "Null tile data array");
-        return;
+        return JNI_FALSE;
     }
 
-    dstyP = dstData + cOffs[0] + y*sStride + x*pixelStride;
+    dstyP = dstData + dstDataOff + y*sStride + x*pixelStride;
     srcyP = srcData + off;
     for (yIdx = 0; yIdx < h; yIdx++, srcyP += scansize, dstyP+=sStride) {
         srcP = srcyP;
@@ -137,12 +223,12 @@
     /* Release the locked arrays */
     (*env)->ReleasePrimitiveArrayCritical(env, jlut, srcLUT,  JNI_ABORT);
     (*env)->ReleasePrimitiveArrayCritical(env, jpix, srcData, JNI_ABORT);
-    (*env)->ReleasePrimitiveArrayCritical(env, joffs, cOffs, JNI_ABORT);
     (*env)->ReleasePrimitiveArrayCritical(env, jdata, dstData, JNI_ABORT);
 
+    return JNI_TRUE;
 }
 
-JNIEXPORT jint JNICALL
+JNIEXPORT jboolean JNICALL
 Java_sun_awt_image_ImageRepresentation_setDiffICM(JNIEnv *env, jclass cls,
                                                   jint x, jint y, jint w,
                                                   jint h, jintArray jlut,
@@ -150,7 +236,7 @@
                                                   jobject jicm,
                                                   jbyteArray jpix, jint off,
                                                   jint scansize,
-                                                  jobject jbct, jint chanOff)
+                                                  jobject jbct, jint dstDataOff)
 {
     unsigned int *srcLUT = NULL;
     unsigned int *newLUT = NULL;
@@ -159,6 +245,8 @@
     int mapSize;
     jobject jdata = NULL;
     jobject jnewlut = NULL;
+    jint srcDataLength;
+    jint dstDataLength;
     unsigned char *srcData;
     unsigned char *dstData;
     unsigned char *dataP;
@@ -174,14 +262,23 @@
 
     if (JNU_IsNull(env, jlut)) {
         JNU_ThrowNullPointerException(env, "NullPointerException");
-        return 0;
+        return JNI_FALSE;
     }
 
     if (JNU_IsNull(env, jpix)) {
         JNU_ThrowNullPointerException(env, "NullPointerException");
-        return 0;
+        return JNI_FALSE;
+    }
+
+    if (x < 0 || w < 1 || (0x7fffffff - x) < w) {
+        return JNI_FALSE;
     }
 
+    if (y < 0 || h < 1 || (0x7fffffff - y) < h) {
+        return JNI_FALSE;
+    }
+
+
     sStride = (*env)->GetIntField(env, jbct, g_BCRscanstrID);
     pixelStride =(*env)->GetIntField(env, jbct, g_BCRpixstrID);
     jdata = (*env)->GetObjectField(env, jbct, g_BCRdataID);
@@ -193,13 +290,31 @@
            of byte data type, so we have to convert the image data
            to default representation.
         */
-        return 0;
+        return JNI_FALSE;
+    }
+
+    if (JNU_IsNull(env, jdata)) {
+        /* no destination buffer */
+        return JNI_FALSE;
     }
+
+    srcDataLength = (*env)->GetArrayLength(env, jpix);
+    dstDataLength = (*env)->GetArrayLength(env, jdata);
+
+    CHECK_STRIDE(y, h, sStride);
+    CHECK_STRIDE(x, w, pixelStride);
+
+    CHECK_DST(x, y);
+    CHECK_DST(x + w -1, y + h - 1);
+
+    /* check source array */
+    CHECK_SRC();
+
     srcLUT = (unsigned int *) (*env)->GetPrimitiveArrayCritical(env, jlut,
                                                                 NULL);
     if (srcLUT == NULL) {
         /* out of memory error already thrown */
-        return 0;
+        return JNI_FALSE;
     }
 
     newLUT = (unsigned int *) (*env)->GetPrimitiveArrayCritical(env, jnewlut,
@@ -208,7 +323,7 @@
         (*env)->ReleasePrimitiveArrayCritical(env, jlut, srcLUT,
                                               JNI_ABORT);
         /* out of memory error already thrown */
-        return 0;
+        return JNI_FALSE;
     }
 
     newNumLut = numLut;
@@ -219,7 +334,7 @@
         (*env)->ReleasePrimitiveArrayCritical(env, jlut, srcLUT,
                                               JNI_ABORT);
         (*env)->ReleasePrimitiveArrayCritical(env, jnewlut, newLUT, JNI_ABORT);
-        return 0;
+        return JNI_FALSE;
     }
 
     /* Don't need these any more */
@@ -239,7 +354,7 @@
                                                                   NULL);
     if (srcData == NULL) {
         /* out of memory error already thrown */
-        return 0;
+        return JNI_FALSE;
     }
 
     dstData = (unsigned char *) (*env)->GetPrimitiveArrayCritical(env, jdata,
@@ -247,10 +362,10 @@
     if (dstData == NULL) {
         (*env)->ReleasePrimitiveArrayCritical(env, jpix, srcData, JNI_ABORT);
         /* out of memory error already thrown */
-        return 0;
+        return JNI_FALSE;
     }
 
-    ydataP = dstData + chanOff + y*sStride + x*pixelStride;
+    ydataP = dstData + dstDataOff + y*sStride + x*pixelStride;
     ypixP  = srcData + off;
 
     for (i=0; i < h; i++) {
@@ -268,7 +383,7 @@
     (*env)->ReleasePrimitiveArrayCritical(env, jpix, srcData, JNI_ABORT);
     (*env)->ReleasePrimitiveArrayCritical(env, jdata, dstData, JNI_ABORT);
 
-    return 1;
+    return JNI_TRUE;
 }
 
 static int compareLUTs(unsigned int *lut1, int numLut1, int transIdx,
--- jdk/src/share/native/sun/awt/image/awt_parseImage.c	2012-08-10 10:30:22.000000000 -0700
+++ jdk/src/share/native/sun/awt/image/awt_parseImage.c	2013-05-05 09:38:39.000000000 -0700
@@ -34,6 +34,7 @@
 #include "java_awt_color_ColorSpace.h"
 #include "awt_Mlib.h"
 #include "safe_alloc.h"
+#include "safe_math.h"
 
 static int setHints(JNIEnv *env, BufImageS_t *imageP);
 
@@ -114,6 +115,62 @@
     return status;
 }
 
+/* Verifies whether the channel offsets are sane and correspond to the type of
+ * the raster.
+ *
+ * Return value:
+ *     0: Failure: channel offsets are invalid
+ *     1: Success
+ */
+static int checkChannelOffsets(RasterS_t *rasterP, int dataArrayLength) {
+    int i, lastPixelOffset, lastScanOffset;
+    switch (rasterP->rasterType) {
+    case COMPONENT_RASTER_TYPE:
+        if (!SAFE_TO_MULT(rasterP->height, rasterP->scanlineStride)) {
+            return 0;
+        }
+        if (!SAFE_TO_MULT(rasterP->width, rasterP->pixelStride)) {
+            return 0;
+        }
+
+        lastScanOffset = (rasterP->height - 1) * rasterP->scanlineStride;
+        lastPixelOffset = (rasterP->width - 1) * rasterP->pixelStride;
+
+
+        if (!SAFE_TO_ADD(lastPixelOffset, lastScanOffset)) {
+            return 0;
+        }
+
+        lastPixelOffset += lastScanOffset;
+
+        for (i = 0; i < rasterP->numDataElements; i++) {
+            int off = rasterP->chanOffsets[i];
+            int size = lastPixelOffset + off;
+
+            if (off < 0 || !SAFE_TO_ADD(lastPixelOffset, off)) {
+                return 0;
+            }
+
+            if (size < lastPixelOffset || size >= dataArrayLength) {
+                // an overflow, or insufficient buffer capacity
+                return 0;
+            }
+        }
+        return 1;
+    case BANDED_RASTER_TYPE:
+        // NB:caller does not support the banded rasters yet,
+        // so this branch of the code must be re-defined in
+        // order to provide valid criteria for the data offsets
+        // verification, when/if banded rasters will be supported.
+        // At the moment, we prohibit banded rasters as well.
+        return 0;
+    default:
+        // PACKED_RASTER_TYPE: does not support channel offsets
+        // UNKNOWN_RASTER_TYPE: should not be used, likely indicates an error
+        return 0;
+    }
+}
+
 /* Parse the raster.  All of the raster information is returned in the
  * rasterP structure.
  *
@@ -125,7 +182,6 @@
 int awt_parseRaster(JNIEnv *env, jobject jraster, RasterS_t *rasterP) {
     jobject joffs = NULL;
     /* int status;*/
-    int isDiscrete = TRUE;
 
     if (JNU_IsNull(env, jraster)) {
         JNU_ThrowNullPointerException(env, "null Raster object");
@@ -155,6 +211,9 @@
         return -1;
     }
 
+    // make sure that the raster type is initialized
+    rasterP->rasterType = UNKNOWN_RASTER_TYPE;
+
     if (rasterP->numBands <= 0 ||
         rasterP->numBands > MAX_NUMBANDS)
     {
@@ -165,9 +224,14 @@
         return 0;
     }
 
+    rasterP->sppsm.isUsed = 0;
+
     if ((*env)->IsInstanceOf(env, rasterP->jsampleModel,
        (*env)->FindClass(env,"java/awt/image/SinglePixelPackedSampleModel"))) {
         jobject jmask, joffs, jnbits;
+
+        rasterP->sppsm.isUsed = 1;
+
         rasterP->sppsm.maxBitSize = (*env)->GetIntField(env,
                                                         rasterP->jsampleModel,
                                                         g_SPPSMmaxBitID);
@@ -254,7 +318,6 @@
         }
         rasterP->chanOffsets[0] = (*env)->GetIntField(env, jraster, g_BPRdataBitOffsetID);
         rasterP->dataType = BYTE_DATA_TYPE;
-        isDiscrete = FALSE;
     }
     else {
         rasterP->type = sun_awt_image_IntegerComponentRaster_TYPE_CUSTOM;
@@ -265,7 +328,19 @@
         return 0;
     }
 
-    if (isDiscrete) {
+    // do basic validation of the raster structure
+    if (rasterP->width <= 0 || rasterP->height <= 0 ||
+        rasterP->pixelStride <= 0 || rasterP->scanlineStride <= 0)
+    {
+        // invalid raster
+        return -1;
+    }
+
+    // channel (data) offsets
+    switch (rasterP->rasterType) {
+    case COMPONENT_RASTER_TYPE:
+    case BANDED_RASTER_TYPE: // note that this routine does not support banded rasters at the moment
+        // get channel (data) offsets
         rasterP->chanOffsets = NULL;
         if (SAFE_TO_ALLOC_2(rasterP->numDataElements, sizeof(jint))) {
             rasterP->chanOffsets =
@@ -278,10 +353,21 @@
         }
         (*env)->GetIntArrayRegion(env, joffs, 0, rasterP->numDataElements,
                                   rasterP->chanOffsets);
+        if (rasterP->jdata == NULL) {
+            // unable to verify the raster
+            return -1;
+        }
+        // verify whether channel offsets look sane
+        if (!checkChannelOffsets(rasterP, (*env)->GetArrayLength(env, rasterP->jdata))) {
+            return -1;
+        }
+        break;
+    default:
+        ; // PACKED_RASTER_TYPE does not use the channel offsets.
     }
 
-    /* additioanl check for sppsm fields validity: make sure that
-     * size of raster samples doesn't exceed the data type cpacity.
+    /* additional check for sppsm fields validity: make sure that
+     * size of raster samples doesn't exceed the data type capacity.
      */
     if (rasterP->dataType > UNKNOWN_DATA_TYPE && /* data type has been recognized */
         rasterP->sppsm.maxBitSize > 0 && /* raster has SPP sample model */
@@ -631,6 +717,21 @@
     }
     else if (cmodelP->cmType == DIRECT_CM_TYPE || cmodelP->cmType == PACKED_CM_TYPE) {
         int i;
+
+        /* do some sanity check first: make sure that
+         * - sample model is SinglePixelPackedSampleModel
+         * - number of bands in the raster corresponds to the number
+         *   of color components in the color model
+         */
+        if (!rasterP->sppsm.isUsed ||
+            rasterP->numBands != cmodelP->numComponents)
+        {
+            /* given raster is not compatible with the color model,
+             * so the operation has to be aborted.
+             */
+            return -1;
+        }
+
         if (cmodelP->maxNbits > 8) {
             hintP->needToExpand = TRUE;
             hintP->expandToNbits = cmodelP->maxNbits;
--- jdk/src/share/native/sun/awt/image/awt_parseImage.h	2012-08-10 10:30:22.000000000 -0700
+++ jdk/src/share/native/sun/awt/image/awt_parseImage.h	2013-05-05 09:38:39.000000000 -0700
@@ -95,6 +95,7 @@
     jint offsets[MAX_NUMBANDS];
     jint nBits[MAX_NUMBANDS];
     jint  maxBitSize;
+    jint isUsed; // flag to indicate whether the raster sample model is SPPSM
 } SPPSampleModelS_t;
 
 /* Struct that holds information for the Raster object */
--- jdk/src/share/native/sun/awt/image/jpeg/imageioJPEG.c	2012-08-10 10:30:23.000000000 -0700
+++ jdk/src/share/native/sun/awt/image/jpeg/imageioJPEG.c	2013-05-05 09:38:39.000000000 -0700
@@ -57,8 +57,8 @@
 #define MAX(a,b)        ((a) > (b) ? (a) : (b))
 
 /* Cached Java method ids */
-static jmethodID ImageInputStream_readID;
-static jmethodID ImageInputStream_skipBytesID;
+static jmethodID JPEGImageReader_readInputDataID;
+static jmethodID JPEGImageReader_skipInputBytesID;
 static jmethodID JPEGImageReader_warningOccurredID;
 static jmethodID JPEGImageReader_warningWithMessageID;
 static jmethodID JPEGImageReader_setImageDataID;
@@ -66,7 +66,7 @@
 static jmethodID JPEGImageReader_pushBackID;
 static jmethodID JPEGImageReader_passStartedID;
 static jmethodID JPEGImageReader_passCompleteID;
-static jmethodID ImageOutputStream_writeID;
+static jmethodID JPEGImageWriter_writeOutputDataID;
 static jmethodID JPEGImageWriter_warningOccurredID;
 static jmethodID JPEGImageWriter_warningWithMessageID;
 static jmethodID JPEGImageWriter_writeMetadataID;
@@ -923,7 +923,7 @@
     RELEASE_ARRAYS(env, data, src->next_input_byte);
     ret = (*env)->CallIntMethod(env,
                                 sb->stream,
-                                ImageInputStream_readID,
+                                JPEGImageReader_readInputDataID,
                                 sb->hstreamBuffer, 0,
                                 sb->bufferLength);
     if ((*env)->ExceptionOccurred(env)
@@ -1013,7 +1013,7 @@
     }
 
     ret = (*env)->CallIntMethod(env, sb->stream,
-                                ImageInputStream_readID,
+                                JPEGImageReader_readInputDataID,
                                 sb->hstreamBuffer,
                                 offset, buflen);
     if ((*env)->ExceptionOccurred(env)
@@ -1107,7 +1107,7 @@
     RELEASE_ARRAYS(env, data, src->next_input_byte);
     ret = (*env)->CallLongMethod(env,
                                  sb->stream,
-                                 ImageInputStream_skipBytesID,
+                                 JPEGImageReader_skipInputBytesID,
                                  (jlong) num_bytes);
     if ((*env)->ExceptionOccurred(env)
         || !GET_ARRAYS(env, data, &(src->next_input_byte))) {
@@ -1382,13 +1382,13 @@
      jclass qTableClass,
      jclass huffClass) {
 
-    ImageInputStream_readID = (*env)->GetMethodID(env,
-                                                  ImageInputStreamClass,
-                                                  "read",
+    JPEGImageReader_readInputDataID = (*env)->GetMethodID(env,
+                                                  cls,
+                                                  "readInputData",
                                                   "([BII)I");
-    ImageInputStream_skipBytesID = (*env)->GetMethodID(env,
-                                                       ImageInputStreamClass,
-                                                       "skipBytes",
+    JPEGImageReader_skipInputBytesID = (*env)->GetMethodID(env,
+                                                       cls,
+                                                       "skipInputBytes",
                                                        "(J)J");
     JPEGImageReader_warningOccurredID = (*env)->GetMethodID(env,
                                                             cls,
@@ -1531,8 +1531,7 @@
 Java_com_sun_imageio_plugins_jpeg_JPEGImageReader_setSource
     (JNIEnv *env,
      jobject this,
-     jlong ptr,
-     jobject source) {
+     jlong ptr) {
 
     imageIODataPtr data = (imageIODataPtr)jlong_to_ptr(ptr);
     j_common_ptr cinfo;
@@ -1546,7 +1545,7 @@
 
     cinfo = data->jpegObj;
 
-    imageio_set_stream(env, cinfo, data, source);
+    imageio_set_stream(env, cinfo, data, this);
 
     imageio_init_source((j_decompress_ptr) cinfo);
 }
@@ -2291,7 +2290,7 @@
 
     (*env)->CallVoidMethod(env,
                            sb->stream,
-                           ImageOutputStream_writeID,
+                           JPEGImageWriter_writeOutputDataID,
                            sb->hstreamBuffer,
                            0,
                            sb->bufferLength);
@@ -2328,7 +2327,7 @@
 
         (*env)->CallVoidMethod(env,
                                sb->stream,
-                               ImageOutputStream_writeID,
+                               JPEGImageWriter_writeOutputDataID,
                                sb->hstreamBuffer,
                                0,
                                datacount);
@@ -2366,13 +2365,12 @@
 Java_com_sun_imageio_plugins_jpeg_JPEGImageWriter_initWriterIDs
     (JNIEnv *env,
      jclass cls,
-     jclass IOSClass,
      jclass qTableClass,
      jclass huffClass) {
 
-    ImageOutputStream_writeID = (*env)->GetMethodID(env,
-                                                    IOSClass,
-                                                    "write",
+    JPEGImageWriter_writeOutputDataID = (*env)->GetMethodID(env,
+                                                    cls,
+                                                    "writeOutputData",
                                                     "([BII)V");
 
     JPEGImageWriter_warningOccurredID = (*env)->GetMethodID(env,
@@ -2496,8 +2494,7 @@
 Java_com_sun_imageio_plugins_jpeg_JPEGImageWriter_setDest
     (JNIEnv *env,
      jobject this,
-     jlong ptr,
-     jobject destination) {
+     jlong ptr) {
 
     imageIODataPtr data = (imageIODataPtr)jlong_to_ptr(ptr);
     j_compress_ptr cinfo;
@@ -2511,7 +2508,7 @@
 
     cinfo = (j_compress_ptr) data->jpegObj;
 
-    imageio_set_stream(env, data->jpegObj, data, destination);
+    imageio_set_stream(env, data->jpegObj, data, this);
 
 
     // Don't call the init method, as that depends on pinned arrays
--- jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	2012-08-10 10:30:26.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	2013-05-05 09:38:39.000000000 -0700
@@ -42,6 +42,7 @@
 #include "awt_Mlib.h"
 #include "gdefs.h"
 #include "safe_alloc.h"
+#include "safe_math.h"
 
 /***************************************************************************
  *                               Definitions                               *
@@ -1993,13 +1994,23 @@
     unsigned char *dP = dataP;
 #define NUM_LINES    10
     int numLines = NUM_LINES;
-    int nbytes = rasterP->width*4*NUM_LINES;
+    /* it is safe to calculate the scan length, because width has been verified
+     * on creation of the mlib image
+     */
+    int scanLength = rasterP->width * 4;
+
+    int nbytes = 0;
+    if (!SAFE_TO_MULT(numLines, scanLength)) {
+        return -1;
+    }
+
+    nbytes = numLines * scanLength;
 
     for (y=0; y < rasterP->height; y+=numLines) {
         /* getData, one scanline at a time */
         if (y+numLines > rasterP->height) {
             numLines = rasterP->height - y;
-            nbytes = rasterP->width*4*numLines;
+            nbytes = numLines * scanLength;
         }
         jpixels = (*env)->CallObjectMethod(env, imageP->jimage,
                                            g_BImgGetRGBMID, 0, y,
@@ -2129,8 +2140,14 @@
     if (cvtToDefault) {
         int status = 0;
         *mlibImagePP = (*sMlibSysFns.createFP)(MLIB_BYTE, 4, width, height);
+        if (*mlibImagePP == NULL) {
+            return -1;
+        }
         cDataP  = (unsigned char *) mlib_ImageGetData(*mlibImagePP);
-        /* Make sure the image is cleared */
+        /* Make sure the image is cleared.
+         * NB: the image dimension is already verified, so we can
+         * safely calculate the length of the buffer.
+         */
         memset(cDataP, 0, width*height*4);
 
         if (!isSrc) {
@@ -2380,6 +2397,9 @@
     case sun_awt_image_IntegerComponentRaster_TYPE_BYTE_PACKED_SAMPLES:
         *mlibImagePP = (*sMlibSysFns.createFP)(MLIB_BYTE, rasterP->numBands,
                                         width, height);
+        if (*mlibImagePP == NULL) {
+            return -1;
+        }
         if (!isSrc) return 0;
         cDataP  = (unsigned char *) mlib_ImageGetData(*mlibImagePP);
         return expandPackedBCR(env, rasterP, -1, cDataP);
@@ -2388,6 +2408,9 @@
         if (rasterP->sppsm.maxBitSize <= 8) {
             *mlibImagePP = (*sMlibSysFns.createFP)(MLIB_BYTE, rasterP->numBands,
                                             width, height);
+            if (*mlibImagePP == NULL) {
+                return -1;
+            }
             if (!isSrc) return 0;
             cDataP  = (unsigned char *) mlib_ImageGetData(*mlibImagePP);
             return expandPackedSCR(env, rasterP, -1, cDataP);
@@ -2397,6 +2420,9 @@
         if (rasterP->sppsm.maxBitSize <= 8) {
             *mlibImagePP = (*sMlibSysFns.createFP)(MLIB_BYTE, rasterP->numBands,
                                             width, height);
+            if (*mlibImagePP == NULL) {
+                return -1;
+            }
             if (!isSrc) return 0;
             cDataP  = (unsigned char *) mlib_ImageGetData(*mlibImagePP);
             return expandPackedICR(env, rasterP, -1, cDataP);
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	2012-08-10 10:30:27.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	2013-05-05 09:38:39.000000000 -0700
@@ -86,7 +86,7 @@
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	2012-08-10 10:30:27.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	2013-05-05 09:38:39.000000000 -0700
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	2012-08-10 10:30:27.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	2013-05-05 09:38:39.000000000 -0700
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	2013-05-05 09:38:39.000000000 -0700
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	2013-05-05 09:38:39.000000000 -0700
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	2013-05-05 09:38:39.000000000 -0700
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	2013-05-05 09:38:39.000000000 -0700
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	2013-05-05 09:38:39.000000000 -0700
@@ -95,7 +95,7 @@
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageCreate.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageCreate.c	2013-05-05 09:38:39.000000000 -0700
@@ -120,6 +120,7 @@
 #include "mlib_image.h"
 #include "mlib_ImageRowTable.h"
 #include "mlib_ImageCreate.h"
+#include "safe_math.h"
 
 /***************************************************************/
 mlib_image* mlib_ImageSet(mlib_image *image,
@@ -247,28 +248,50 @@
     return NULL;
   };
 
+  if (!SAFE_TO_MULT(width, channels)) {
+    return NULL;
+  }
+
+  wb = width * channels;
+
   switch (type) {
     case MLIB_DOUBLE:
-      wb = width * channels * 8;
+      if (!SAFE_TO_MULT(wb, 8)) {
+        return NULL;
+      }
+      wb *= 8;
       break;
     case MLIB_FLOAT:
     case MLIB_INT:
-      wb = width * channels * 4;
+      if (!SAFE_TO_MULT(wb, 4)) {
+        return NULL;
+      }
+      wb *= 4;
       break;
     case MLIB_USHORT:
     case MLIB_SHORT:
-      wb = width * channels * 2;
+      if (!SAFE_TO_MULT(wb, 4)) {
+        return NULL;
+      }
+      wb *= 2;
       break;
     case MLIB_BYTE:
-      wb = width * channels;
+      // wb is ready
       break;
     case MLIB_BIT:
-      wb = (width * channels + 7) / 8;
+      if (!SAFE_TO_ADD(7, wb)) {
+        return NULL;
+      }
+      wb = (wb + 7) / 8;
       break;
     default:
       return NULL;
   }
 
+  if (!SAFE_TO_MULT(wb, height)) {
+      return NULL;
+  }
+
   data = mlib_malloc(wb * height);
   if (data == NULL) {
     return NULL;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	2013-05-05 09:38:39.000000000 -0700
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -613,7 +613,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -623,12 +623,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -638,7 +638,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -646,7 +646,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -656,12 +656,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -671,7 +671,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -719,7 +719,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -733,14 +733,14 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -754,7 +754,7 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -764,7 +764,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -778,14 +778,14 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -799,7 +799,7 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -852,7 +852,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -862,12 +862,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -877,12 +877,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -892,12 +892,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -907,7 +907,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -915,7 +915,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -925,12 +925,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -940,12 +940,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -955,12 +955,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -970,7 +970,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	2013-05-05 09:38:39.000000000 -0700
@@ -88,7 +88,7 @@
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
--- jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	2012-08-10 10:30:28.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	2013-05-05 09:38:39.000000000 -0700
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
--- jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	2012-08-10 10:30:29.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	2013-05-05 09:38:39.000000000 -0700
@@ -275,11 +275,11 @@
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
--- jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	2012-08-10 10:30:29.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	2013-05-05 09:38:39.000000000 -0700
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* BYTE_ORDER == ... */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- jdk/src/share/native/sun/awt/medialib/mlib_image.h	2012-08-10 10:30:29.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_image.h	2013-05-05 09:38:39.000000000 -0700
@@ -27,9 +27,21 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
-#ifdef MACOSX
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+
+#ifdef _ALLBSD_SOURCE
 #include <machine/endian.h>
+
+/* BSD's always define both _LITTLE_ENDIAN && _BIG_ENDIAN */
+#if defined(_LITTLE_ENDIAN) && defined(_BIG_ENDIAN) && \
+    _BYTE_ORDER == _BIG_ENDIAN
+#undef _LITTLE_ENDIAN
 #endif
+
+#endif /* _ALLBSD_SOURCE */
+
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
--- jdk/src/share/native/sun/awt/medialib/mlib_sys.c	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_sys.c	2013-05-05 09:38:39.000000000 -0700
@@ -26,7 +26,7 @@
 
 #include <stdlib.h>
 #include <string.h>
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #include <unistd.h>
 #include <sys/param.h>
 #endif
@@ -90,7 +90,10 @@
    * alignment. -- from stdlib.h of MS VC++5.0.
    */
   return (void *) malloc(size);
-#elif defined(MACOSX)
+#elif defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
+#elif defined(_ALLBSD_SOURCE)
   return valloc(size);
 #else
   return (void *) memalign(8, size);
--- jdk/src/share/native/sun/awt/medialib/mlib_types.h	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/mlib_types.h	2013-05-05 09:38:39.000000000 -0700
@@ -59,8 +59,16 @@
 
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(__GNUC__)
 
+#if defined(_ALLBSD_SOURCE)
 #include <stddef.h>                     /* for ptrdiff_t */
 #include <stdint.h>                     /* for uintptr_t */
+#elif defined(__linux__)
+#include <stdint.h>                     /* for uintptr_t */
+#include <malloc.h>                     /* for ptrdiff_t */
+#else
+#include <link.h>                       /* for uintptr_t */
+#include <stddef.h>                     /* for ptrdiff_t */
+#endif  /* __linux__ */
 
 #if defined(MLIB_OS64BIT) || (defined(MACOSX) && defined(_LP64))
 
--- jdk/src/share/native/sun/awt/medialib/safe_alloc.h	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/awt/medialib/safe_alloc.h	2013-05-05 09:38:39.000000000 -0700
@@ -41,5 +41,4 @@
     (((w) > 0) && ((h) > 0) && ((sz) > 0) &&                               \
      (((0xffffffffu / ((juint)(w))) / ((juint)(h))) > ((juint)(sz))))
 
-
 #endif // __SAFE_ALLOC_H__
--- jdk/src/share/native/sun/awt/medialib/safe_math.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/awt/medialib/safe_math.h	2013-05-05 09:38:39.000000000 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef __SAFE_MATH_H__
+#define __SAFE_MATH_H__
+
+#define SAFE_TO_MULT(a, b) \
+    (((a) > 0) && ((b) >= 0) && ((0x7fffffff / (a)) > (b)))
+
+#define SAFE_TO_ADD(a, b) \
+    (((a) >= 0) && ((b) >= 0) && ((0x7fffffff - (a)) > (b)))
+
+#endif // __SAFE_MATH_H__
--- jdk/src/share/native/sun/awt/splashscreen/splashscreen_jpeg.c	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/awt/splashscreen/splashscreen_jpeg.c	2013-05-05 09:38:39.000000000 -0700
@@ -133,6 +133,10 @@
     ImageFormat srcFormat;
 
     jpeg_read_header(cinfo, TRUE);
+
+    // SplashScreen jpeg converter expects data in RGB format only
+    cinfo->out_color_space = JCS_RGB;
+
     jpeg_start_decompress(cinfo);
 
     SplashCleanup(splash);
--- jdk/src/share/native/sun/font/FontInstanceAdapter.cpp	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/font/FontInstanceAdapter.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -66,8 +66,21 @@
     yScalePixelsToUnits = upem / yppem;
 };
 
+
 const void *FontInstanceAdapter::getFontTable(LETag tableTag) const
 {
+  size_t ignored = 0;
+  return getFontTable(tableTag, ignored);
+}
+
+static const LETag cacheMap[LAYOUTCACHE_ENTRIES] = {
+  GPOS_TAG, GDEF_TAG, GSUB_TAG, MORT_TAG, MORX_TAG, KERN_TAG
+};
+
+const void *FontInstanceAdapter::getFontTable(LETag tableTag, size_t &length) const
+{
+  length = 0;
+
   if (!layoutTables) { // t1 font
     return 0;
   }
@@ -75,14 +88,19 @@
   // cache in font's pscaler object
   // font disposer will handle for us
 
-  switch(tableTag) {
-  case GSUB_TAG: if (layoutTables->gsub_len != -1) return (void*)layoutTables->gsub; break;
-  case GPOS_TAG: if (layoutTables->gpos_len != -1) return (void*)layoutTables->gpos; break;
-  case GDEF_TAG: if (layoutTables->gdef_len != -1) return (void*)layoutTables->gdef; break;
-  case MORT_TAG: if (layoutTables->mort_len != -1) return (void*)layoutTables->mort; break;
-  case KERN_TAG: if (layoutTables->kern_len != -1) return (void*)layoutTables->kern; break;
-  default:
-   //fprintf(stderr, "unexpected table request from font instance adapter: %x\n", tableTag);
+  int cacheIdx;
+  for (cacheIdx=0;cacheIdx<LAYOUTCACHE_ENTRIES;cacheIdx++) {
+    if (tableTag==cacheMap[cacheIdx]) break;
+  }
+
+  if (cacheIdx<LAYOUTCACHE_ENTRIES) { // if found
+    if (layoutTables->entries[cacheIdx].len != -1) {
+      length = layoutTables->entries[cacheIdx].len;
+      return layoutTables->entries[cacheIdx].ptr;
+    }
+  } else {
+    //fprintf(stderr, "unexpected table request from font instance adapter: %x\n", tableTag);
+    // (don't load any other tables)
     return 0;
   }
 
@@ -96,16 +114,13 @@
     env->GetByteArrayRegion(tableBytes, 0, len, result);
   }
 
-  switch(tableTag) {
-  case GSUB_TAG: layoutTables->gsub = (void*)result; layoutTables->gsub_len = len; break;
-  case GPOS_TAG: layoutTables->gpos = (void*)result; layoutTables->gpos_len = len; break;
-  case GDEF_TAG: layoutTables->gdef = (void*)result; layoutTables->gdef_len = len; break;
-  case MORT_TAG: layoutTables->mort = (void*)result; layoutTables->mort_len = len; break;
-  case KERN_TAG: layoutTables->kern = (void*)result; layoutTables->kern_len = len; break;
-  default: break;
+  if (cacheIdx<LAYOUTCACHE_ENTRIES) { // if cacheable table
+    layoutTables->entries[cacheIdx].len = len;
+    layoutTables->entries[cacheIdx].ptr = (const void*)result;
   }
 
-  return (void*)result;
+  length = len;
+  return (const void*)result;
 };
 
 LEGlyphID FontInstanceAdapter::mapCharToGlyph(LEUnicode32 ch, const LECharMapper *mapper) const
--- jdk/src/share/native/sun/font/FontInstanceAdapter.h	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/font/FontInstanceAdapter.h	2013-05-05 09:38:38.000000000 -0700
@@ -86,6 +86,7 @@
     // tables are cached with the native font scaler data
     // only supports gsub, gpos, gdef, mort tables at present
     virtual const void *getFontTable(LETag tableTag) const;
+    virtual const void *getFontTable(LETag tableTag, size_t &len) const;
 
     virtual void *getKernPairs() const {
         return layoutTables->kernPairs;
--- jdk/src/share/native/sun/font/fontscalerdefs.h	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/font/fontscalerdefs.h	2013-05-05 09:38:38.000000000 -0700
@@ -120,20 +120,19 @@
 #define GPOS_TAG 0x47504F53 /* 'GPOS' */
 #define GDEF_TAG 0x47444546 /* 'GDEF' */
 #define MORT_TAG 0x6D6F7274 /* 'mort' */
+#define MORX_TAG 0x6D6F7278 /* 'morx' */
 #define KERN_TAG 0x6B65726E /* 'kern' */
 
+typedef struct TTLayoutTableCacheEntry {
+  const void* ptr;
+  int   len;
+} TTLayoutTableCacheEntry;
+
+#define LAYOUTCACHE_ENTRIES 6
+
 typedef struct TTLayoutTableCache {
-    void* gsub;
-    void* gpos;
-    void* gdef;
-    void* mort;
-    void* kern;
-    void* kernPairs;
-    int gsub_len;
-    int gpos_len;
-    int gdef_len;
-    int mort_len;
-    int kern_len;
+  TTLayoutTableCacheEntry entries[LAYOUTCACHE_ENTRIES];
+  void* kernPairs;
 } TTLayoutTableCache;
 
 #include "sunfontids.h"
--- jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.cpp	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -39,19 +39,20 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 AlternateSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
+le_uint32 AlternateSubstitutionSubtable::process(const LEReferenceTo<AlternateSubstitutionSubtable> &base,
+                                       GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter) const
 {
     // NOTE: For now, we'll just pick the first alternative...
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, glyph, success);
 
-    if (coverageIndex >= 0) {
+    if (coverageIndex >= 0 && LE_SUCCESS(success)) {
         le_uint16 altSetCount = SWAPW(alternateSetCount);
 
         if (coverageIndex < altSetCount) {
             Offset alternateSetTableOffset = SWAPW(alternateSetTableOffsetArray[coverageIndex]);
-            const AlternateSetTable *alternateSetTable =
-                (const AlternateSetTable *) ((char *) this + alternateSetTableOffset);
+            const LEReferenceTo<AlternateSetTable> alternateSetTable(base, success,
+                                  (const AlternateSetTable *) ((char *) this + alternateSetTableOffset));
             TTGlyphID alternate = SWAPW(alternateSetTable->alternateArray[0]);
 
             if (filter == NULL || filter->accept(LE_SET_GLYPH(glyph, alternate))) {
--- jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.h	2012-08-10 10:30:30.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -51,13 +51,17 @@
     TTGlyphID alternateArray[ANY_NUMBER];
 };
 
+LE_VAR_ARRAY(AlternateSetTable, alternateArray)
+
 struct AlternateSubstitutionSubtable : GlyphSubstitutionSubtable
 {
     le_uint16 alternateSetCount;
     Offset    alternateSetTableOffsetArray[ANY_NUMBER];
 
-    le_uint32 process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
+    le_uint32 process(const LEReferenceTo<AlternateSubstitutionSubtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter = NULL) const;
 };
 
+LE_VAR_ARRAY(AlternateSubstitutionSubtable, alternateSetTableOffsetArray)
+
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -26,7 +26,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -58,15 +58,18 @@
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ArabicOpenTypeLayoutEngine)
 
-ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
+                                                       le_int32 languageCode, le_int32 typoFlags,
+                                                       const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable,
+                                                       LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success)
 {
     fFeatureMap = ArabicShaping::getFeatureMap(fFeatureMapCount);
     fFeatureOrder = TRUE;
 }
 
-ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
+                                                       le_int32 languageCode,
                                                        le_int32 typoFlags, LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success)
 {
@@ -88,8 +91,9 @@
 // Input: characters
 // Output: characters, char indices, tags
 // Returns: output character count
-le_int32 ArabicOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 ArabicOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count,
+                                                         le_int32 max, le_bool rightToLeft, LEUnicode *&outChars,
+                                                         LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -137,32 +141,30 @@
         return;
     }
 
-    if (fGPOSTable != NULL) {
+    if (!fGPOSTable.isEmpty()) {
         OpenTypeLayoutEngine::adjustGlyphPositions(chars, offset, count, reverse, glyphStorage, success);
-    } else if (fGDEFTable != NULL) {
-        GDEFMarkFilter filter(fGDEFTable);
-
+    } else if (!fGDEFTable.isEmpty()) {
+        GDEFMarkFilter filter(fGDEFTable, success);
         adjustMarkGlyphs(glyphStorage, &filter, success);
     } else {
-        GlyphDefinitionTableHeader *gdefTable = (GlyphDefinitionTableHeader *) CanonShaping::glyphDefinitionTable;
-        GDEFMarkFilter filter(gdefTable);
+        LEReferenceTo<GlyphDefinitionTableHeader> gdefTable(CanonShaping::glyphDefinitionTable, CanonShaping::glyphDefinitionTableLen);
+        GDEFMarkFilter filter(gdefTable, success);
 
         adjustMarkGlyphs(&chars[offset], count, reverse, glyphStorage, &filter, success);
     }
 }
 
 UnicodeArabicOpenTypeLayoutEngine::UnicodeArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags, LEErrorCode &success)
-    : ArabicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success)
+  : ArabicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags | LE_CHAR_FILTER_FEATURE_FLAG, success)
 {
     fGSUBTable = (const GlyphSubstitutionTableHeader *) CanonShaping::glyphSubstitutionTable;
     fGDEFTable = (const GlyphDefinitionTableHeader *) CanonShaping::glyphDefinitionTable;
-
-    fSubstitutionFilter = new CharSubstitutionFilter(fontInstance);
+    /* OpenTypeLayoutEngine will allocate a substitution filter */
 }
 
 UnicodeArabicOpenTypeLayoutEngine::~UnicodeArabicOpenTypeLayoutEngine()
 {
-    delete fSubstitutionFilter;
+    /* OpenTypeLayoutEngine will cleanup the substitution filter */
 }
 
 // "glyphs", "indices" -> glyphs, indices
@@ -233,7 +235,7 @@
         return;
     }
 
-    GDEFMarkFilter filter(fGDEFTable);
+    GDEFMarkFilter filter(fGDEFTable, success);
 
     adjustMarkGlyphs(&chars[offset], count, reverse, glyphStorage, &filter, success);
 }
--- jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -75,7 +75,7 @@
      * @internal
      */
     ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success);
+                            le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
--- jdk/src/share/native/sun/font/layout/ArabicShaping.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ArabicShaping.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -58,14 +58,16 @@
 */
 ArabicShaping::ShapeType ArabicShaping::getShapeType(LEUnicode c)
 {
-    const ClassDefinitionTable *joiningTypes = (const ClassDefinitionTable *) ArabicShaping::shapingTypeTable;
-    le_int32 joiningType = joiningTypes->getGlyphClass(c);
+  LEErrorCode success = LE_NO_ERROR;
+  const LEReferenceTo<ClassDefinitionTable> joiningTypes((const ClassDefinitionTable *) ArabicShaping::shapingTypeTable,
+                                                         ArabicShaping::shapingTypeTableLen);
+  le_int32 joiningType = joiningTypes->getGlyphClass(joiningTypes, c, success);
+
+  if (joiningType >= 0 && joiningType < ArabicShaping::JT_COUNT && LE_SUCCESS(success)) {
+    return ArabicShaping::shapeTypes[joiningType];
+  }
 
-    if (joiningType >= 0 && joiningType < ArabicShaping::JT_COUNT) {
-        return ArabicShaping::shapeTypes[joiningType];
-    }
-
-    return ArabicShaping::ST_NOSHAPE_NONE;
+  return ArabicShaping::ST_NOSHAPE_NONE;
 }
 
 #define isolFeatureTag LE_ISOL_FEATURE_TAG
--- jdk/src/share/native/sun/font/layout/ArabicShaping.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ArabicShaping.h	2013-05-05 09:38:38.000000000 -0700
@@ -93,6 +93,8 @@
     static ShapeType getShapeType(LEUnicode c);
 
     static const le_uint8 shapingTypeTable[];
+    static const size_t   shapingTypeTableLen;
+
     static const ShapeType shapeTypes[];
 
     static void adjustTags(le_int32 outIndex, le_int32 shapeOffset, LEGlyphStorage &glyphStorage);
--- jdk/src/share/native/sun/font/layout/AttachmentPosnSubtables.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/AttachmentPosnSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -52,14 +52,14 @@
     Offset    markArrayOffset;
     Offset    baseArrayOffset;
 
-    inline le_int32  getBaseCoverage(LEGlyphID baseGlyphId) const;
+    inline le_int32  getBaseCoverage(const LETableReference &base, LEGlyphID baseGlyphId, LEErrorCode &success) const;
 
     le_uint32 process(GlyphIterator *glyphIterator) const;
 };
 
-inline le_int32 AttachmentPositioningSubtable::getBaseCoverage(LEGlyphID baseGlyphID) const
+inline le_int32 AttachmentPositioningSubtable::getBaseCoverage(const LETableReference &base, LEGlyphID baseGlyphID, LEErrorCode &success) const
 {
-    return getGlyphCoverage(baseCoverageTableOffset, baseGlyphID);
+  return getGlyphCoverage(base, baseCoverageTableOffset, baseGlyphID, success);
 }
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/CanonData.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/CanonData.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -3641,4 +3641,9 @@
     0x00, 0xE6, 0xD2, 0x42, 0xD2, 0x44, 0x00, 0xE6
 };
 
+
+const size_t CanonShaping::glyphSubstitutionTableLen = sizeof(glyphSubstitutionTable)/sizeof(glyphSubstitutionTable[0]);
+
+const size_t CanonShaping::glyphDefinitionTableLen = sizeof(glyphDefinitionTable)/sizeof(glyphDefinitionTable[0]);
+
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/CanonShaping.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/CanonShaping.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -59,15 +59,15 @@
 void CanonShaping::reorderMarks(const LEUnicode *inChars, le_int32 charCount, le_bool rightToLeft,
                                 LEUnicode *outChars, LEGlyphStorage &glyphStorage)
 {
-    const GlyphDefinitionTableHeader *gdefTable = (const GlyphDefinitionTableHeader *) glyphDefinitionTable;
-    const ClassDefinitionTable *classTable = gdefTable->getMarkAttachClassDefinitionTable();
+    LEErrorCode success = LE_NO_ERROR;
+    LEReferenceTo<GlyphDefinitionTableHeader> gdefTable(CanonShaping::glyphDefinitionTable, CanonShaping::glyphDefinitionTableLen);
+    LEReferenceTo<ClassDefinitionTable> classTable = gdefTable->getMarkAttachClassDefinitionTable(gdefTable, success);
     le_int32 *combiningClasses = LE_NEW_ARRAY(le_int32, charCount);
     le_int32 *indices = LE_NEW_ARRAY(le_int32, charCount);
-    LEErrorCode status = LE_NO_ERROR;
     le_int32 i;
 
     for (i = 0; i < charCount; i += 1) {
-        combiningClasses[i] = classTable->getGlyphClass((LEGlyphID) inChars[i]);
+      combiningClasses[i] = classTable->getGlyphClass(classTable, (LEGlyphID) inChars[i], success);
         indices[i] = i;
     }
 
@@ -96,7 +96,7 @@
         le_int32 index = indices[i];
 
         outChars[i] = inChars[index];
-        glyphStorage.setCharIndex(out, index, status);
+        glyphStorage.setCharIndex(out, index, success);
     }
 
     LE_DELETE_ARRAY(indices);
--- jdk/src/share/native/sun/font/layout/CanonShaping.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/CanonShaping.h	2013-05-05 09:38:38.000000000 -0700
@@ -42,7 +42,9 @@
 {
 public:
     static const le_uint8 glyphSubstitutionTable[];
+    static const size_t   glyphSubstitutionTableLen;
     static const le_uint8 glyphDefinitionTable[];
+    static const size_t   glyphDefinitionTableLen;
 
     static void reorderMarks(const LEUnicode *inChars, le_int32 charCount, le_bool rightToLeft,
                                    LEUnicode *outChars, LEGlyphStorage &glyphStorage);
--- jdk/src/share/native/sun/font/layout/ClassDefinitionTables.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ClassDefinitionTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -37,49 +37,51 @@
 
 U_NAMESPACE_BEGIN
 
-le_int32 ClassDefinitionTable::getGlyphClass(LEGlyphID glyphID) const
+le_int32 ClassDefinitionTable::getGlyphClass(const LETableReference& base, LEGlyphID glyphID, LEErrorCode &success) const
 {
-    switch(SWAPW(classFormat)) {
+  LEReferenceTo<ClassDefinitionTable> thisRef(base, success);
+  if (LE_FAILURE(success)) return 0;
+
+  switch(SWAPW(classFormat)) {
     case 0:
         return 0;
 
     case 1:
     {
-        const ClassDefFormat1Table *f1Table = (const ClassDefFormat1Table *) this;
-
-        return f1Table->getGlyphClass(glyphID);
+      const LEReferenceTo<ClassDefFormat1Table> f1Table(thisRef, success);
+      return f1Table->getGlyphClass(f1Table, glyphID, success);
     }
 
     case 2:
     {
-        const ClassDefFormat2Table *f2Table = (const ClassDefFormat2Table *) this;
-
-        return f2Table->getGlyphClass(glyphID);
+      const LEReferenceTo<ClassDefFormat2Table> f2Table(thisRef, success);
+      return  f2Table->getGlyphClass(f2Table, glyphID, success);
     }
 
     default:
         return 0;
-    }
+  }
 }
 
-le_bool ClassDefinitionTable::hasGlyphClass(le_int32 glyphClass) const
+le_bool ClassDefinitionTable::hasGlyphClass(const LETableReference &base, le_int32 glyphClass, LEErrorCode &success) const
 {
+    LEReferenceTo<ClassDefinitionTable> thisRef(base, success);
+    if (LE_FAILURE(success)) return 0;
+
     switch(SWAPW(classFormat)) {
     case 0:
         return 0;
 
     case 1:
     {
-        const ClassDefFormat1Table *f1Table = (const ClassDefFormat1Table *) this;
-
-        return f1Table->hasGlyphClass(glyphClass);
+      const LEReferenceTo<ClassDefFormat1Table> f1Table(thisRef, success);
+      return f1Table->hasGlyphClass(f1Table, glyphClass, success);
     }
 
     case 2:
     {
-        const ClassDefFormat2Table *f2Table = (const ClassDefFormat2Table *) this;
-
-        return f2Table->hasGlyphClass(glyphClass);
+      const LEReferenceTo<ClassDefFormat2Table> f2Table(thisRef, success);
+      return f2Table->hasGlyphClass(f2Table, glyphClass, success);
     }
 
     default:
@@ -87,26 +89,32 @@
     }
 }
 
-le_int32 ClassDefFormat1Table::getGlyphClass(LEGlyphID glyphID) const
+le_int32 ClassDefFormat1Table::getGlyphClass(const LETableReference& base, LEGlyphID glyphID, LEErrorCode &success) const
 {
+    if(LE_FAILURE(success)) return 0;
+
+    le_uint16 count = SWAPW(glyphCount);
+    LEReferenceToArrayOf<le_uint16> classValueArrayRef(base, success, &classValueArray[0], count);
     TTGlyphID ttGlyphID  = (TTGlyphID) LE_GET_GLYPH(glyphID);
     TTGlyphID firstGlyph = SWAPW(startGlyph);
-    TTGlyphID lastGlyph  = firstGlyph + SWAPW(glyphCount);
+    TTGlyphID lastGlyph  = firstGlyph + count;
 
-    if (ttGlyphID >= firstGlyph && ttGlyphID < lastGlyph) {
-        return SWAPW(classValueArray[ttGlyphID - firstGlyph]);
+    if (LE_SUCCESS(success) && ttGlyphID >= firstGlyph && ttGlyphID < lastGlyph) {
+      return SWAPW( classValueArrayRef(ttGlyphID - firstGlyph, success) );
     }
 
     return 0;
 }
 
-le_bool ClassDefFormat1Table::hasGlyphClass(le_int32 glyphClass) const
+le_bool ClassDefFormat1Table::hasGlyphClass(const LETableReference &base, le_int32 glyphClass, LEErrorCode &success) const
 {
-    le_uint16 count  = SWAPW(glyphCount);
+    if(LE_FAILURE(success)) return 0;
+    le_uint16 count = SWAPW(glyphCount);
+    LEReferenceToArrayOf<le_uint16> classValueArrayRef(base, success, &classValueArray[0], count);
     int i;
 
-    for (i = 0; i < count; i += 1) {
-        if (SWAPW(classValueArray[i]) == glyphClass) {
+    for (i = 0; LE_SUCCESS(success)&& (i < count); i += 1) {
+      if (SWAPW(classValueArrayRef(i,success)) == glyphClass) {
             return TRUE;
         }
     }
@@ -114,27 +122,31 @@
     return FALSE;
 }
 
-le_int32 ClassDefFormat2Table::getGlyphClass(LEGlyphID glyphID) const
+le_int32 ClassDefFormat2Table::getGlyphClass(const LETableReference& base, LEGlyphID glyphID, LEErrorCode &success) const
 {
+    if(LE_FAILURE(success)) return 0;
     TTGlyphID ttGlyph    = (TTGlyphID) LE_GET_GLYPH(glyphID);
     le_uint16 rangeCount = SWAPW(classRangeCount);
+    LEReferenceToArrayOf<GlyphRangeRecord> classRangeRecordArrayRef(base, success, &classRangeRecordArray[0], rangeCount);
     le_int32  rangeIndex =
-        OpenTypeUtilities::getGlyphRangeIndex(ttGlyph, classRangeRecordArray, rangeCount);
+      OpenTypeUtilities::getGlyphRangeIndex(ttGlyph, classRangeRecordArrayRef, success);
 
-    if (rangeIndex < 0) {
+    if (rangeIndex < 0 || LE_FAILURE(success)) {
         return 0;
     }
 
-    return SWAPW(classRangeRecordArray[rangeIndex].rangeValue);
+    return SWAPW(classRangeRecordArrayRef(rangeIndex, success).rangeValue);
 }
 
-le_bool ClassDefFormat2Table::hasGlyphClass(le_int32 glyphClass) const
+le_bool ClassDefFormat2Table::hasGlyphClass(const LETableReference &base, le_int32 glyphClass, LEErrorCode &success) const
 {
+    if(LE_FAILURE(success)) return 0;
     le_uint16 rangeCount = SWAPW(classRangeCount);
+    LEReferenceToArrayOf<GlyphRangeRecord> classRangeRecordArrayRef(base, success, &classRangeRecordArray[0], rangeCount);
     int i;
 
-    for (i = 0; i < rangeCount; i += 1) {
-        if (SWAPW(classRangeRecordArray[i].rangeValue) == glyphClass) {
+    for (i = 0; i < rangeCount && LE_SUCCESS(success); i += 1) {
+      if (SWAPW(classRangeRecordArrayRef(i,success).rangeValue) == glyphClass) {
             return TRUE;
         }
     }
--- jdk/src/share/native/sun/font/layout/ClassDefinitionTables.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ClassDefinitionTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -46,8 +46,20 @@
 {
     le_uint16 classFormat;
 
-    le_int32  getGlyphClass(LEGlyphID glyphID) const;
-    le_bool   hasGlyphClass(le_int32 glyphClass) const;
+    le_int32  getGlyphClass(const LETableReference &base, LEGlyphID glyphID, LEErrorCode &success) const;
+    le_bool   hasGlyphClass(const LETableReference &base, le_int32 glyphClass, LEErrorCode &success) const;
+
+  le_int32 getGlyphClass(LEGlyphID glyphID) const {
+    LETableReference base((const le_uint8*)this);
+    LEErrorCode ignored = LE_NO_ERROR;
+    return getGlyphClass(base,glyphID,ignored);
+  }
+
+  le_bool hasGlyphClass(le_int32 glyphClass) const {
+    LETableReference base((const le_uint8*)this);
+    LEErrorCode ignored = LE_NO_ERROR;
+    return hasGlyphClass(base,glyphClass,ignored);
+  }
 };
 
 struct ClassDefFormat1Table : ClassDefinitionTable
@@ -56,9 +68,11 @@
     le_uint16  glyphCount;
     le_uint16  classValueArray[ANY_NUMBER];
 
-    le_int32 getGlyphClass(LEGlyphID glyphID) const;
-    le_bool  hasGlyphClass(le_int32 glyphClass) const;
+    le_int32 getGlyphClass(const LETableReference &base, LEGlyphID glyphID, LEErrorCode &success) const;
+    le_bool  hasGlyphClass(const LETableReference &base, le_int32 glyphClass, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(ClassDefFormat1Table, classValueArray)
+
 
 struct ClassRangeRecord
 {
@@ -72,9 +86,10 @@
     le_uint16        classRangeCount;
     GlyphRangeRecord classRangeRecordArray[ANY_NUMBER];
 
-    le_int32 getGlyphClass(LEGlyphID glyphID) const;
-    le_bool hasGlyphClass(le_int32 glyphClass) const;
+    le_int32 getGlyphClass(const LETableReference &base, LEGlyphID glyphID, LEErrorCode &success) const;
+    le_bool hasGlyphClass(const LETableReference &base, le_int32 glyphClass, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(ClassDefFormat2Table, classRangeRecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ContextualGlyphInsertion.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphInsertion.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -49,6 +49,11 @@
 {
 };
 
+struct ContextualGlyphInsertionHeader2 : MorphStateTableHeader2
+{
+    le_uint32 insertionTableOffset;
+};
+
 enum ContextualGlyphInsertionFlags
 {
     cgiSetMark                  = 0x8000,
@@ -61,11 +66,17 @@
     cgiMarkedInsertCountMask    = 0x001F
 };
 
-struct LigatureSubstitutionStateEntry : StateEntry
+struct ContextualGlyphInsertionStateEntry : StateEntry
 {
     ByteOffset currentInsertionListOffset;
     ByteOffset markedInsertionListOffset;
 };
 
+struct ContextualGlyphInsertionStateEntry2 : StateEntry2
+{
+    le_uint16 currentInsertionListIndex;
+    le_uint16 markedInsertionListIndex;
+};
+
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ContextualGlyphInsertionProc2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphInsertionProc2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,139 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "StateTables.h"
+#include "MorphStateTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "ContextualGlyphInsertionProc2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ContextualGlyphInsertionProcessor2)
+
+ContextualGlyphInsertionProcessor2::ContextualGlyphInsertionProcessor2(
+         const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : StateTableProcessor2(morphSubtableHeader, success)
+{
+  contextualGlyphHeader = LEReferenceTo<ContextualGlyphInsertionHeader2>(morphSubtableHeader, success);
+  if(LE_FAILURE(success) || !contextualGlyphHeader.isValid()) return;
+  le_uint32 insertionTableOffset = SWAPL(contextualGlyphHeader->insertionTableOffset);
+  insertionTable = LEReferenceToArrayOf<le_uint16>(stHeader, success, insertionTableOffset, LE_UNBOUNDED_ARRAY);
+  entryTable = LEReferenceToArrayOf<ContextualGlyphInsertionStateEntry2>(stHeader, success, entryTableOffset, LE_UNBOUNDED_ARRAY);
+}
+
+ContextualGlyphInsertionProcessor2::~ContextualGlyphInsertionProcessor2()
+{
+}
+
+void ContextualGlyphInsertionProcessor2::beginStateTable()
+{
+    markGlyph = 0;
+}
+
+void ContextualGlyphInsertionProcessor2::doInsertion(LEGlyphStorage &glyphStorage,
+                                                     le_int16 atGlyph,
+                                                     le_int16 &index,
+                                                     le_int16 count,
+                                                     le_bool /* isKashidaLike */,
+                                                     le_bool isBefore,
+                                                     LEErrorCode &success) {
+  LEGlyphID *insertGlyphs = glyphStorage.insertGlyphs(atGlyph, count + 1, success);
+
+  if(LE_FAILURE(success) || insertGlyphs==NULL) {
+    return;
+  }
+
+  // Note: Kashida vs Split Vowel seems to only affect selection and highlighting.
+  // We note the flag, but do not layout different.
+  // https://developer.apple.com/fonts/TTRefMan/RM06/Chap6mort.html
+
+  le_int16 targetIndex = 0;
+  if(isBefore) {
+    // insert at beginning
+    insertGlyphs[targetIndex++] = glyphStorage[atGlyph];
+  } else {
+    // insert at end
+    insertGlyphs[count] = glyphStorage[atGlyph];
+  }
+
+  while(count--) {
+    insertGlyphs[targetIndex++] = insertionTable.getObject(index++, success);
+  }
+  glyphStorage.applyInsertions();
+}
+
+le_uint16 ContextualGlyphInsertionProcessor2::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph,
+                                                                EntryTableIndex2 index, LEErrorCode &success)
+{
+    const ContextualGlyphInsertionStateEntry2 *entry = entryTable.getAlias(index, success);
+
+    if(LE_FAILURE(success)) return 0; // TODO- which state?
+
+    le_uint16 newState = SWAPW(entry->newStateIndex);
+    le_uint16 flags = SWAPW(entry->flags);
+
+    le_int16 markIndex = SWAPW(entry->markedInsertionListIndex);
+    if (markIndex > 0) {
+        le_int16 count = (flags & cgiMarkedInsertCountMask) >> 5;
+        le_bool isKashidaLike = (flags & cgiMarkedIsKashidaLike);
+        le_bool isBefore = (flags & cgiMarkInsertBefore);
+        doInsertion(glyphStorage, markGlyph, markIndex, count, isKashidaLike, isBefore, success);
+    }
+
+    le_int16 currIndex = SWAPW(entry->currentInsertionListIndex);
+    if (currIndex > 0) {
+        le_int16 count = flags & cgiCurrentInsertCountMask;
+        le_bool isKashidaLike = (flags & cgiCurrentIsKashidaLike);
+        le_bool isBefore = (flags & cgiCurrentInsertBefore);
+        doInsertion(glyphStorage, currGlyph, currIndex, count, isKashidaLike, isBefore, success);
+    }
+
+    if (flags & cgiSetMark) {
+        markGlyph = currGlyph;
+    }
+
+    if (!(flags & cgiDontAdvance)) {
+        currGlyph += dir;
+    }
+
+    return newState;
+}
+
+void ContextualGlyphInsertionProcessor2::endStateTable()
+{
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/ContextualGlyphInsertionProc2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphInsertionProc2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,106 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __CONTEXTUALGLYPHINSERTIONPROCESSOR2_H
+#define __CONTEXTUALGLYPHINSERTIONPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "ContextualGlyphInsertionProc2.h"
+#include "ContextualGlyphInsertion.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class ContextualGlyphInsertionProcessor2 : public StateTableProcessor2
+{
+public:
+    virtual void beginStateTable();
+
+    virtual le_uint16 processStateEntry(LEGlyphStorage &glyphStorage,
+                                        le_int32 &currGlyph, EntryTableIndex2 index, LEErrorCode &success);
+
+    virtual void endStateTable();
+
+    ContextualGlyphInsertionProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+    virtual ~ContextualGlyphInsertionProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    ContextualGlyphInsertionProcessor2();
+
+    /**
+     * Perform the actual insertion
+     * @param atGlyph index of glyph to insert at
+     * @param index index into the insertionTable (in/out)
+     * @param count number of insertions
+     * @param isKashidaLike Kashida like (vs Split Vowel like). No effect currently.
+     * @param isBefore if true, insert extra glyphs before the marked glyph
+     */
+    void doInsertion(LEGlyphStorage &glyphStorage,
+                              le_int16 atGlyph,
+                              le_int16 &index,
+                              le_int16 count,
+                              le_bool isKashidaLike,
+                              le_bool isBefore,
+                              LEErrorCode &success);
+
+
+protected:
+    le_int32 markGlyph;
+    LEReferenceToArrayOf<le_uint16> insertionTable;
+    LEReferenceToArrayOf<ContextualGlyphInsertionStateEntry2> entryTable;
+    LEReferenceTo<ContextualGlyphInsertionHeader2> contextualGlyphHeader;
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -43,13 +43,18 @@
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ContextualGlyphSubstitutionProcessor)
 
-ContextualGlyphSubstitutionProcessor::ContextualGlyphSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : StateTableProcessor(morphSubtableHeader)
+ContextualGlyphSubstitutionProcessor::ContextualGlyphSubstitutionProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : StateTableProcessor(morphSubtableHeader, success), entryTable(), contextualGlyphSubstitutionHeader(morphSubtableHeader, success)
 {
-    contextualGlyphSubstitutionHeader = (const ContextualGlyphSubstitutionHeader *) morphSubtableHeader;
-    substitutionTableOffset = SWAPW(contextualGlyphSubstitutionHeader->substitutionTableOffset);
+  contextualGlyphSubstitutionHeader.orphan();
+  substitutionTableOffset = SWAPW(contextualGlyphSubstitutionHeader->substitutionTableOffset);
 
-    entryTable = (const ContextualGlyphSubstitutionStateEntry *) ((char *) &stateTableHeader->stHeader + entryTableOffset);
+
+  entryTable = LEReferenceToArrayOf<ContextualGlyphSubstitutionStateEntry>(stateTableHeader, success,
+                                                                           (const ContextualGlyphSubstitutionStateEntry*)(&stateTableHeader->stHeader),
+                                                                           entryTableOffset, LE_UNBOUNDED_ARRAY);
+  int16Table = LEReferenceToArrayOf<le_int16>(stateTableHeader, success, (const le_int16*)(&stateTableHeader->stHeader),
+                                              0, LE_UNBOUNDED_ARRAY); // rest of the table as le_int16s
 }
 
 ContextualGlyphSubstitutionProcessor::~ContextualGlyphSubstitutionProcessor()
@@ -63,27 +68,26 @@
 
 ByteOffset ContextualGlyphSubstitutionProcessor::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex index)
 {
-    const ContextualGlyphSubstitutionStateEntry *entry = &entryTable[index];
-    ByteOffset newState = SWAPW(entry->newStateOffset);
-    le_int16 flags = SWAPW(entry->flags);
-    WordOffset markOffset = SWAPW(entry->markOffset);
-    WordOffset currOffset = SWAPW(entry->currOffset);
-
-    if (markOffset != 0) {
-        const le_int16 *table = (const le_int16 *) ((char *) &stateTableHeader->stHeader + markOffset * 2);
-        LEGlyphID mGlyph = glyphStorage[markGlyph];
-        TTGlyphID newGlyph = SWAPW(table[LE_GET_GLYPH(mGlyph)]);
-
-         glyphStorage[markGlyph] = LE_SET_GLYPH(mGlyph, newGlyph);
-    }
+  LEErrorCode success = LE_NO_ERROR;
+  const ContextualGlyphSubstitutionStateEntry *entry = entryTable.getAlias(index, success);
+  ByteOffset newState = SWAPW(entry->newStateOffset);
+  le_int16 flags = SWAPW(entry->flags);
+  WordOffset markOffset = SWAPW(entry->markOffset);
+  WordOffset currOffset = SWAPW(entry->currOffset);
+
+  if (markOffset != 0 && LE_SUCCESS(success)) {
+    LEGlyphID mGlyph = glyphStorage[markGlyph];
+    TTGlyphID newGlyph = SWAPW(int16Table.getObject(markOffset + LE_GET_GLYPH(mGlyph), success)); // whew.
+
+    glyphStorage[markGlyph] = LE_SET_GLYPH(mGlyph, newGlyph);
+  }
+
+  if (currOffset != 0) {
+    LEGlyphID thisGlyph = glyphStorage[currGlyph];
+    TTGlyphID newGlyph = SWAPW(int16Table.getObject(currOffset + LE_GET_GLYPH(thisGlyph), success)); // whew.
 
-    if (currOffset != 0) {
-        const le_int16 *table = (const le_int16 *) ((char *) &stateTableHeader->stHeader + currOffset * 2);
-        LEGlyphID thisGlyph = glyphStorage[currGlyph];
-        TTGlyphID newGlyph = SWAPW(table[LE_GET_GLYPH(thisGlyph)]);
-
-        glyphStorage[currGlyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
-    }
+    glyphStorage[currGlyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+  }
 
     if (flags & cgsSetMark) {
         markGlyph = currGlyph;
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.h	2013-05-05 09:38:38.000000000 -0700
@@ -56,7 +56,7 @@
 
     virtual void endStateTable();
 
-    ContextualGlyphSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    ContextualGlyphSubstitutionProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
     virtual ~ContextualGlyphSubstitutionProcessor();
 
     /**
@@ -78,11 +78,11 @@
 
 protected:
     ByteOffset substitutionTableOffset;
-    const ContextualGlyphSubstitutionStateEntry *entryTable;
-
+    LEReferenceToArrayOf<ContextualGlyphSubstitutionStateEntry> entryTable;
+    LEReferenceToArrayOf<le_int16> int16Table;
     le_int32 markGlyph;
 
-    const ContextualGlyphSubstitutionHeader *contextualGlyphSubstitutionHeader;
+    LEReferenceTo<ContextualGlyphSubstitutionHeader> contextualGlyphSubstitutionHeader;
 
 };
 
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,170 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "StateTables.h"
+#include "MorphStateTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "ContextualGlyphSubstProc2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ContextualGlyphSubstitutionProcessor2)
+
+ContextualGlyphSubstitutionProcessor2::ContextualGlyphSubstitutionProcessor2(
+                                  const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : StateTableProcessor2(morphSubtableHeader, success), contextualGlyphHeader(morphSubtableHeader, success)
+{
+    if(LE_FAILURE(success)) return;
+    le_uint32 perGlyphTableOffset = SWAPL(contextualGlyphHeader->perGlyphTableOffset);
+    perGlyphTable = LEReferenceToArrayOf<le_uint32> (stHeader, success, perGlyphTableOffset, LE_UNBOUNDED_ARRAY);
+    entryTable = LEReferenceToArrayOf<ContextualGlyphStateEntry2>(stHeader, success, entryTableOffset, LE_UNBOUNDED_ARRAY);
+}
+
+ContextualGlyphSubstitutionProcessor2::~ContextualGlyphSubstitutionProcessor2()
+{
+}
+
+void ContextualGlyphSubstitutionProcessor2::beginStateTable()
+{
+    markGlyph = 0;
+}
+
+le_uint16 ContextualGlyphSubstitutionProcessor2::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph,
+    EntryTableIndex2 index, LEErrorCode &success)
+{
+    if(LE_FAILURE(success)) return 0;
+    const ContextualGlyphStateEntry2 *entry = entryTable.getAlias(index, success);
+    if(LE_FAILURE(success)) return 0;
+    le_uint16 newState = SWAPW(entry->newStateIndex);
+    le_uint16 flags = SWAPW(entry->flags);
+    le_int16 markIndex = SWAPW(entry->markIndex);
+    le_int16 currIndex = SWAPW(entry->currIndex);
+
+    if (markIndex != -1) {
+        le_uint32 offset = SWAPL(perGlyphTable(markIndex, success));
+        LEGlyphID mGlyph = glyphStorage[markGlyph];
+        TTGlyphID newGlyph = lookup(offset, mGlyph, success);
+        glyphStorage[markGlyph] = LE_SET_GLYPH(mGlyph, newGlyph);
+    }
+
+    if (currIndex != -1) {
+        le_uint32 offset = SWAPL(perGlyphTable(currIndex, success));
+        LEGlyphID thisGlyph = glyphStorage[currGlyph];
+        TTGlyphID newGlyph = lookup(offset, thisGlyph, success);
+        glyphStorage[currGlyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+    }
+
+    if (flags & cgsSetMark) {
+        markGlyph = currGlyph;
+    }
+
+    if (!(flags & cgsDontAdvance)) {
+        currGlyph += dir;
+    }
+
+    return newState;
+}
+
+TTGlyphID ContextualGlyphSubstitutionProcessor2::lookup(le_uint32 offset, LEGlyphID gid, LEErrorCode &success)
+{
+    TTGlyphID newGlyph = 0xFFFF;
+    if(LE_FAILURE(success))  return newGlyph;
+    LEReferenceTo<LookupTable> lookupTable(perGlyphTable, success, offset);
+    if(LE_FAILURE(success))  return newGlyph;
+    le_int16 format = SWAPW(lookupTable->format);
+
+    switch (format) {
+        case ltfSimpleArray: {
+#ifdef TEST_FORMAT
+            // Disabled pending for design review
+            LEReferenceTo<SimpleArrayLookupTable> lookupTable0(lookupTable, success);
+            LEReferenceToArrayOf<LookupValue> valueArray(lookupTable0, success, &lookupTable0->valueArray[0], LE_UNBOUNDED_ARRAY);
+            if(LE_FAILURE(success))  return newGlyph;
+            TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
+            newGlyph = SWAPW(lookupTable0->valueArray(glyphCode, success));
+#endif
+            break;
+        }
+        case ltfSegmentSingle: {
+#ifdef TEST_FORMAT
+            // Disabled pending for design review
+            LEReferenceTo<SegmentSingleLookupTable> lookupTable2 = (SegmentSingleLookupTable *) lookupTable;
+            const LookupSegment *segment = lookupTable2->lookupSegment(lookupTable2->segments, gid);
+            if (segment != NULL) {
+                newGlyph = SWAPW(segment->value);
+            }
+#endif
+            break;
+        }
+        case ltfSegmentArray: {
+            //printf("Context Lookup Table Format4: specific interpretation needed!\n");
+            break;
+        }
+        case ltfSingleTable:
+        {
+#ifdef TEST_FORMAT
+            // Disabled pending for design review
+            LEReferenceTo<SingleTableLookupTable> lookupTable6 = (SingleTableLookupTable *) lookupTable;
+            const LEReferenceTo<LookupSingle> segment = lookupTable6->lookupSingle(lookupTable6->entries, gid);
+            if (segment != NULL) {
+                newGlyph = SWAPW(segment->value);
+            }
+#endif
+            break;
+        }
+        case ltfTrimmedArray: {
+            LEReferenceTo<TrimmedArrayLookupTable> lookupTable8(lookupTable, success);
+            if (LE_FAILURE(success)) return newGlyph;
+            TTGlyphID firstGlyph = SWAPW(lookupTable8->firstGlyph);
+            TTGlyphID glyphCount = SWAPW(lookupTable8->glyphCount);
+            TTGlyphID lastGlyph  = firstGlyph + glyphCount;
+            TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
+            if ((glyphCode >= firstGlyph) && (glyphCode < lastGlyph)) {
+              LEReferenceToArrayOf<LookupValue> valueArray(lookupTable8, success, &lookupTable8->valueArray[0], glyphCount);
+              newGlyph = SWAPW(valueArray(glyphCode - firstGlyph, success));
+            }
+        }
+        default:
+            break;
+    }
+    return newGlyph;
+}
+
+void ContextualGlyphSubstitutionProcessor2::endStateTable()
+{
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,92 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __CONTEXTUALGLYPHSUBSTITUTIONPROCESSOR2_H
+#define __CONTEXTUALGLYPHSUBSTITUTIONPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "ContextualGlyphSubstitution.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class ContextualGlyphSubstitutionProcessor2 : public StateTableProcessor2
+{
+public:
+    virtual void beginStateTable();
+
+    virtual le_uint16 processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex2 index, LEErrorCode &success);
+
+    virtual void endStateTable();
+
+    ContextualGlyphSubstitutionProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+    virtual ~ContextualGlyphSubstitutionProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    ContextualGlyphSubstitutionProcessor2();
+    TTGlyphID lookup(le_uint32 offset, LEGlyphID gid, LEErrorCode &success);
+
+protected:
+    LEReferenceToArrayOf<le_uint32>           perGlyphTable;
+    LEReferenceToArrayOf<ContextualGlyphStateEntry2> entryTable;
+
+    le_int16 perGlyphTableFormat;
+    le_int32 markGlyph;
+
+    LEReferenceTo<ContextualGlyphHeader2> contextualGlyphHeader;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstitution.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstitution.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -49,6 +49,11 @@
     ByteOffset  substitutionTableOffset;
 };
 
+struct ContextualGlyphHeader2 : MorphStateTableHeader2
+{
+    le_uint32  perGlyphTableOffset; // no more substitution tables
+};
+
 enum ContextualGlyphSubstitutionFlags
 {
     cgsSetMark      = 0x8000,
@@ -62,5 +67,11 @@
     WordOffset currOffset;
 };
 
+struct ContextualGlyphStateEntry2 : StateEntry2
+{
+    le_uint16 markIndex;
+    le_uint16 currIndex;
+};
+
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -217,7 +217,7 @@
     }
 
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(lookupProcessor->getReference(), glyph, success);
 
     if (coverageIndex >= 0) {
         le_uint16 srSetCount = SWAPW(subRuleSetCount);
@@ -266,7 +266,7 @@
     }
 
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(lookupProcessor->getReference(), glyph, success);
 
     if (coverageIndex >= 0) {
         const ClassDefinitionTable *classDefinitionTable =
@@ -394,7 +394,7 @@
     }
 
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(lookupProcessor->getReference(), glyph, success);
 
     if (coverageIndex >= 0) {
         le_uint16 srSetCount = SWAPW(chainSubRuleSetCount);
@@ -465,7 +465,7 @@
     }
 
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(lookupProcessor->getReference(), glyph, success);
 
     if (coverageIndex >= 0) {
         const ClassDefinitionTable *backtrackClassDefinitionTable =
--- jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -43,6 +43,7 @@
 #include "GlyphSubstitutionTables.h"
 #include "GlyphIterator.h"
 #include "LookupProcessor.h"
+#include "LETableReference.h"
 
 U_NAMESPACE_BEGIN
 
@@ -88,6 +89,8 @@
 
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 };
+LE_VAR_ARRAY(ContextualSubstitutionFormat1Subtable, subRuleSetTableOffsetArray)
+
 
 struct SubRuleSetTable
 {
@@ -95,6 +98,7 @@
     Offset  subRuleTableOffsetArray[ANY_NUMBER];
 
 };
+LE_VAR_ARRAY(SubRuleSetTable, subRuleTableOffsetArray)
 
 // NOTE: Multiple variable size arrays!!
 struct SubRuleTable
@@ -104,6 +108,7 @@
     TTGlyphID inputGlyphArray[ANY_NUMBER];
   //SubstitutionLookupRecord substLookupRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SubRuleTable, inputGlyphArray)
 
 struct ContextualSubstitutionFormat2Subtable : ContextualSubstitutionSubtable
 {
@@ -113,12 +118,16 @@
 
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 };
+LE_VAR_ARRAY(ContextualSubstitutionFormat2Subtable, subClassSetTableOffsetArray)
+
 
 struct SubClassSetTable
 {
     le_uint16  subClassRuleCount;
     Offset  subClassRuleTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SubClassSetTable, subClassRuleTableOffsetArray)
+
 
 // NOTE: Multiple variable size arrays!!
 struct SubClassRuleTable
@@ -128,6 +137,8 @@
     le_uint16  classArray[ANY_NUMBER];
   //SubstitutionLookupRecord substLookupRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SubClassRuleTable, classArray)
+
 
 // NOTE: This isn't a subclass of GlyphSubstitutionSubtable 'cause
 // it has an array of coverage tables instead of a single coverage table...
@@ -143,6 +154,7 @@
 
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 };
+LE_VAR_ARRAY(ContextualSubstitutionFormat3Subtable, coverageTableOffsetArray)
 
 struct ChainingContextualSubstitutionSubtable : ContextualSubstitutionBase
 {
@@ -156,6 +168,8 @@
 
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 };
+LE_VAR_ARRAY(ChainingContextualSubstitutionFormat1Subtable, chainSubRuleSetTableOffsetArray)
+
 
 struct ChainSubRuleSetTable
 {
@@ -163,6 +177,7 @@
     Offset  chainSubRuleTableOffsetArray[ANY_NUMBER];
 
 };
+LE_VAR_ARRAY(ChainSubRuleSetTable, chainSubRuleTableOffsetArray)
 
 // NOTE: Multiple variable size arrays!!
 struct ChainSubRuleTable
@@ -176,6 +191,7 @@
   //le_uint16  substCount;
   //SubstitutionLookupRecord substLookupRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(ChainSubRuleTable, backtrackGlyphArray)
 
 struct ChainingContextualSubstitutionFormat2Subtable : ChainingContextualSubstitutionSubtable
 {
@@ -187,12 +203,15 @@
 
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 };
+LE_VAR_ARRAY(ChainingContextualSubstitutionFormat2Subtable, chainSubClassSetTableOffsetArray)
 
 struct ChainSubClassSetTable
 {
     le_uint16  chainSubClassRuleCount;
     Offset  chainSubClassRuleTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(ChainSubClassSetTable, chainSubClassRuleTableOffsetArray)
+
 
 // NOTE: Multiple variable size arrays!!
 struct ChainSubClassRuleTable
@@ -206,6 +225,7 @@
   //le_uint16  substCount;
   //SubstitutionLookupRecord substLookupRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(ChainSubClassRuleTable, backtrackClassArray)
 
 // NOTE: This isn't a subclass of GlyphSubstitutionSubtable 'cause
 // it has arrays of coverage tables instead of a single coverage table...
@@ -225,6 +245,8 @@
 
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 };
+LE_VAR_ARRAY(ChainingContextualSubstitutionFormat3Subtable, backtrackCoverageTableOffsetArray)
+
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/CoverageTables.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/CoverageTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -56,6 +56,8 @@
 
     le_int32 getGlyphCoverage(LEGlyphID glyphID) const;
 };
+LE_VAR_ARRAY(CoverageFormat1Table, glyphArray)
+
 
 struct CoverageFormat2Table : CoverageTable
 {
@@ -64,6 +66,7 @@
 
     le_int32 getGlyphCoverage(LEGlyphID glyphID) const;
 };
+LE_VAR_ARRAY(CoverageFormat2Table, rangeRecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.cpp	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -39,10 +39,10 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 CursiveAttachmentSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 CursiveAttachmentSubtable::process(const LEReferenceTo<CursiveAttachmentSubtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID glyphID       = glyphIterator->getCurrGlyphID();
-    le_int32  coverageIndex = getGlyphCoverage(glyphID);
+    le_int32  coverageIndex = getGlyphCoverage(base, glyphID, success);
     le_uint16 eeCount       = SWAPW(entryExitCount);
 
     if (coverageIndex < 0 || coverageIndex >= eeCount) {
@@ -51,7 +51,7 @@
     }
 
     LEPoint entryAnchor, exitAnchor;
-    Offset entryOffset = SWAPW(entryExitRecords[coverageIndex].entryAnchor);
+    Offset entryOffset = SWAPW(entryExitRecords[coverageIndex].entryAnchor); // TODO
     Offset exitOffset  = SWAPW(entryExitRecords[coverageIndex].exitAnchor);
 
     if (entryOffset != 0) {
--- jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.h	2012-08-10 10:30:31.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -57,8 +57,9 @@
     le_uint16 entryExitCount;
     EntryExitRecord entryExitRecords[ANY_NUMBER];
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<CursiveAttachmentSubtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(CursiveAttachmentSubtable, entryExitRecords)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/DeviceTables.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/DeviceTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -57,6 +57,7 @@
     static const le_uint16 fieldSignBits[];
     static const le_uint16 fieldBits[];
 };
+LE_VAR_ARRAY(DeviceTable, deltaValues)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ExtensionSubtables.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ExtensionSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -47,6 +47,8 @@
 le_uint32 ExtensionSubtable::process(const LookupProcessor *lookupProcessor, le_uint16 lookupType,
                                       GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const
 {
+    const LEReferenceTo<ExtensionSubtable> thisRef(lookupProcessor->getReference(), success); // create a reference to this
+
     if (LE_FAILURE(success)) {
         return 0;
     }
@@ -55,9 +57,11 @@
 
     if (elt != lookupType) {
         le_uint32 extOffset = READ_LONG(extensionOffset);
-        LookupSubtable *subtable = (LookupSubtable *) ((char *) this + extOffset);
+        LEReferenceTo<LookupSubtable> subtable(thisRef, success, extOffset);
 
-        return lookupProcessor->applySubtable(subtable, elt, glyphIterator, fontInstance, success);
+        if(LE_SUCCESS(success)) {
+          return lookupProcessor->applySubtable(subtable, elt, glyphIterator, fontInstance, success);
+        }
     }
 
     return 0;
--- jdk/src/share/native/sun/font/layout/Features.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/Features.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -38,19 +38,20 @@
 
 U_NAMESPACE_BEGIN
 
-const FeatureTable *FeatureListTable::getFeatureTable(le_uint16 featureIndex, LETag *featureTag) const
+LEReferenceTo<FeatureTable> FeatureListTable::getFeatureTable(const LETableReference &base, le_uint16 featureIndex, LETag *featureTag, LEErrorCode &success) const
 {
-    if (featureIndex >= SWAPW(featureCount)) {
-        return 0;
-    }
+  if (featureIndex >= SWAPW(featureCount) || LE_FAILURE(success)) {
+    return LEReferenceTo<FeatureTable>();
+  }
 
     Offset featureTableOffset = featureRecordArray[featureIndex].featureTableOffset;
 
     *featureTag = SWAPT(featureRecordArray[featureIndex].featureTag);
 
-    return (const FeatureTable *) ((char *) this + SWAPW(featureTableOffset));
+    return LEReferenceTo<FeatureTable>(base, success, SWAPW(featureTableOffset));
 }
 
+#if 0
 /*
  * Note: according to the OpenType Spec. v 1.4, the entries in the Feature
  * List Table are sorted alphabetically by feature tag; however, there seem
@@ -82,5 +83,6 @@
     return 0;
 #endif
 }
+#endif
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/GDEFMarkFilter.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GDEFMarkFilter.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -36,9 +36,12 @@
 
 U_NAMESPACE_BEGIN
 
-GDEFMarkFilter::GDEFMarkFilter(const GlyphDefinitionTableHeader *gdefTable)
+GDEFMarkFilter::GDEFMarkFilter(const LEReferenceTo<GlyphDefinitionTableHeader> &gdefTable, LEErrorCode &success)
+  : classDefTable(gdefTable->getGlyphClassDefinitionTable(gdefTable, success))
 {
-    classDefTable = gdefTable->getGlyphClassDefinitionTable();
+  if(!classDefTable.isValid()) {
+    success = LE_INTERNAL_ERROR;
+  }
 }
 
 GDEFMarkFilter::~GDEFMarkFilter()
--- jdk/src/share/native/sun/font/layout/GDEFMarkFilter.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GDEFMarkFilter.h	2013-05-05 09:38:38.000000000 -0700
@@ -46,13 +46,13 @@
 class GDEFMarkFilter : public UMemory, public LEGlyphFilter
 {
 private:
-    const GlyphClassDefinitionTable *classDefTable;
+    const LEReferenceTo<GlyphClassDefinitionTable> classDefTable;
 
     GDEFMarkFilter(const GDEFMarkFilter &other); // forbid copying of this class
     GDEFMarkFilter &operator=(const GDEFMarkFilter &other); // forbid copying of this class
 
 public:
-    GDEFMarkFilter(const GlyphDefinitionTableHeader *gdefTable);
+    GDEFMarkFilter(const LEReferenceTo<GlyphDefinitionTableHeader> &gdefTable, LEErrorCode &success);
     virtual ~GDEFMarkFilter();
 
     virtual le_bool accept(LEGlyphID glyph) const;
--- jdk/src/share/native/sun/font/layout/GXLayoutEngine.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GXLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -41,9 +41,10 @@
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(GXLayoutEngine)
 
-GXLayoutEngine::GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const MorphTableHeader *morphTable, LEErrorCode &success)
+  GXLayoutEngine::GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const LEReferenceTo<MorphTableHeader> &morphTable, LEErrorCode &success)
     : LayoutEngine(fontInstance, scriptCode, languageCode, 0, success), fMorphTable(morphTable)
 {
+  fMorphTable.orphan();
     // nothing else to do?
 }
 
@@ -70,7 +71,7 @@
         return 0;
     }
 
-    fMorphTable->process(glyphStorage);
+    fMorphTable->process(fMorphTable, glyphStorage, success);
 
     return count;
 }
--- jdk/src/share/native/sun/font/layout/GXLayoutEngine.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GXLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -74,7 +74,7 @@
      *
      * @internal
      */
-    GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const MorphTableHeader *morphTable, LEErrorCode &success);
+    GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const LEReferenceTo<MorphTableHeader> &morphTable, LEErrorCode &success);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -104,7 +104,7 @@
      *
      * @internal
      */
-    const MorphTableHeader *fMorphTable;
+    LEReferenceTo<MorphTableHeader> fMorphTable;
 
     /**
      * This method does GX layout using the font's 'mort' table. It converts the
--- jdk/src/share/native/sun/font/layout/GXLayoutEngine2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/GXLayoutEngine2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,91 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "LayoutEngine.h"
+#include "GXLayoutEngine2.h"
+#include "LEGlyphStorage.h"
+#include "MorphTables.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(GXLayoutEngine2)
+
+GXLayoutEngine2::GXLayoutEngine2(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const LEReferenceTo<MorphTableHeader2> &morphTable, le_int32 typoFlags, LEErrorCode &success)
+  : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success), fMorphTable(morphTable)
+{
+  // nothing else to do?
+}
+
+GXLayoutEngine2::~GXLayoutEngine2()
+{
+    reset();
+}
+
+// apply 'morx' table
+le_int32 GXLayoutEngine2::computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+    if (LE_FAILURE(success)) {
+        return 0;
+    }
+
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
+        success = LE_ILLEGAL_ARGUMENT_ERROR;
+        return 0;
+    }
+
+    mapCharsToGlyphs(chars, offset, count, rightToLeft, rightToLeft, glyphStorage, success);
+
+    if (LE_FAILURE(success)) {
+        return 0;
+    }
+
+    fMorphTable->process(fMorphTable, glyphStorage, fTypoFlags, success);
+    return count;
+}
+
+// apply positional tables
+void GXLayoutEngine2::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool /*reverse*/,
+                                          LEGlyphStorage &/*glyphStorage*/, LEErrorCode &success)
+{
+    if (LE_FAILURE(success)) {
+        return;
+    }
+
+    if (chars == NULL || offset < 0 || count < 0) {
+        success = LE_ILLEGAL_ARGUMENT_ERROR;
+        return;
+    }
+
+    // FIXME: no positional processing yet...
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/GXLayoutEngine2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/GXLayoutEngine2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,149 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __GXLAYOUTENGINE2_H
+#define __GXLAYOUTENGINE2_H
+
+#include "LETypes.h"
+#include "LayoutEngine.h"
+
+#include "MorphTables.h"
+
+U_NAMESPACE_BEGIN
+
+class LEFontInstance;
+class LEGlyphStorage;
+
+/**
+ * This class implements layout for QuickDraw GX or Apple Advanced Typograyph (AAT)
+ * fonts. A font is a GX or AAT font if it contains a 'mort' table. See Apple's
+ * TrueType Reference Manual (http://fonts.apple.com/TTRefMan/index.html) for details.
+ * Information about 'mort' tables is in the chapter titled "Font Files."
+ *
+ * @internal
+ */
+class GXLayoutEngine2 : public LayoutEngine
+{
+public:
+    /**
+     * This is the main constructor. It constructs an instance of GXLayoutEngine for
+     * a particular font, script and language. It takes the 'mort' table as a parameter since
+     * LayoutEngine::layoutEngineFactory has to read the 'mort' table to know that it has a
+     * GX font.
+     *
+     * Note: GX and AAT fonts don't contain any script and language specific tables, so
+     * the script and language are ignored.
+     *
+     * @param fontInstance - the font
+     * @param scriptCode - the script
+     * @param langaugeCode - the language
+     * @param morphTable - the 'mort' table
+     * @param success - set to an error code if the operation fails
+     *
+     * @see LayoutEngine::layoutEngineFactory
+     * @see ScriptAndLangaugeTags.h for script and language codes
+     *
+     * @internal
+     */
+    GXLayoutEngine2(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const LEReferenceTo<MorphTableHeader2> &morphTable, le_int32 typoFlags, LEErrorCode &success);
+
+    /**
+     * The destructor, virtual for correct polymorphic invocation.
+     *
+     * @internal
+     */
+    virtual ~GXLayoutEngine2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+protected:
+
+    /**
+     * The address of the 'mort' table
+     *
+     * @internal
+     */
+    const LEReferenceTo<MorphTableHeader2> fMorphTable;
+
+    /**
+     * This method does GX layout using the font's 'mort' table. It converts the
+     * input character codes to glyph indices using mapCharsToGlyphs, and then
+     * applies the 'mort' table.
+     *
+     * Input parameters:
+     * @param chars - the input character context
+     * @param offset - the index of the first character to process
+     * @param count - the number of characters to process
+     * @param max - the number of characters in the input context
+     * @param rightToLeft - <code>TRUE</code> if the text is in a right to left directional run
+     * @param glyphStorage - the glyph storage object. The glyph and char index arrays will be set.
+     *
+     * Output parameters:
+     * @param success - set to an error code if the operation fails
+     *
+     * @return the number of glyphs in the glyph index array
+     *
+     * @internal
+     */
+    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    /**
+     * This method adjusts the glyph positions using the font's
+     * 'kern', 'trak', 'bsln', 'opbd' and 'just' tables.
+     *
+     * Input parameters:
+     * @param glyphStorage - the object holding the glyph storage. The positions will be updated as needed.
+     *
+     * Output parameters:
+     * @param success - set to an error code if the operation fails
+     *
+     * @internal
+     */
+    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse,
+                                      LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -36,24 +36,36 @@
 
 U_NAMESPACE_BEGIN
 
-const GlyphClassDefinitionTable *GlyphDefinitionTableHeader::getGlyphClassDefinitionTable() const
+const LEReferenceTo<GlyphClassDefinitionTable>
+GlyphDefinitionTableHeader::getGlyphClassDefinitionTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                                                         LEErrorCode &success) const
 {
-    return (const GlyphClassDefinitionTable *) ((char *) this + SWAPW(glyphClassDefOffset));
+  if(LE_FAILURE(success)) return LEReferenceTo<GlyphClassDefinitionTable>();
+  return LEReferenceTo<GlyphClassDefinitionTable>(base, success, SWAPW(glyphClassDefOffset));
 }
 
-const AttachmentListTable *GlyphDefinitionTableHeader::getAttachmentListTable() const
+const LEReferenceTo<AttachmentListTable>
+GlyphDefinitionTableHeader::getAttachmentListTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                                                         LEErrorCode &success) const
 {
-    return (const AttachmentListTable *) ((char *) this + SWAPW(attachListOffset));
+    if(LE_FAILURE(success)) return LEReferenceTo<AttachmentListTable>();
+    return LEReferenceTo<AttachmentListTable>(base, success, SWAPW(attachListOffset));
 }
 
-const LigatureCaretListTable *GlyphDefinitionTableHeader::getLigatureCaretListTable() const
+const LEReferenceTo<LigatureCaretListTable>
+GlyphDefinitionTableHeader::getLigatureCaretListTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                                                         LEErrorCode &success) const
 {
-    return (const LigatureCaretListTable *) ((char *) this + SWAPW(ligCaretListOffset));
+    if(LE_FAILURE(success)) return LEReferenceTo<LigatureCaretListTable>();
+    return LEReferenceTo<LigatureCaretListTable>(base, success, SWAPW(ligCaretListOffset));
 }
 
-const MarkAttachClassDefinitionTable *GlyphDefinitionTableHeader::getMarkAttachClassDefinitionTable() const
+const LEReferenceTo<MarkAttachClassDefinitionTable>
+GlyphDefinitionTableHeader::getMarkAttachClassDefinitionTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                                                         LEErrorCode &success) const
 {
-    return (const MarkAttachClassDefinitionTable *) ((char *) this + SWAPW(MarkAttachClassDefOffset));
+    if(LE_FAILURE(success)) return LEReferenceTo<MarkAttachClassDefinitionTable>();
+    return LEReferenceTo<MarkAttachClassDefinitionTable>(base, success, SWAPW(MarkAttachClassDefOffset));
 }
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -60,12 +60,14 @@
     le_uint16  glyphCount;
     Offset  attachPointTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(AttachmentListTable, attachPointTableOffsetArray)
 
 struct AttachPointTable
 {
     le_uint16  pointCount;
     le_uint16  pointIndexArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(AttachPointTable, pointIndexArray)
 
 struct LigatureCaretListTable
 {
@@ -73,12 +75,14 @@
     le_uint16  ligGlyphCount;
     Offset  ligGlyphTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LigatureCaretListTable, ligGlyphTableOffsetArray)
 
 struct LigatureGlyphTable
 {
     le_uint16  caretCount;
     Offset  caretValueTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LigatureGlyphTable, caretValueTableOffsetArray)
 
 struct CaretValueTable
 {
@@ -111,10 +115,18 @@
     Offset  ligCaretListOffset;
     Offset  MarkAttachClassDefOffset;
 
-    const GlyphClassDefinitionTable *getGlyphClassDefinitionTable() const;
-    const AttachmentListTable *getAttachmentListTable()const ;
-    const LigatureCaretListTable *getLigatureCaretListTable() const;
-    const MarkAttachClassDefinitionTable *getMarkAttachClassDefinitionTable() const;
+    const LEReferenceTo<GlyphClassDefinitionTable>
+    getGlyphClassDefinitionTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                                 LEErrorCode &success) const;
+    const LEReferenceTo<AttachmentListTable>
+    getAttachmentListTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                           LEErrorCode &success)const ;
+    const LEReferenceTo<LigatureCaretListTable>
+    getLigatureCaretListTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                              LEErrorCode &success) const;
+    const LEReferenceTo<MarkAttachClassDefinitionTable>
+    getMarkAttachClassDefinitionTable(const LEReferenceTo<GlyphDefinitionTableHeader>& base,
+                                      LEErrorCode &success) const;
 };
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/GlyphIterator.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphIterator.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -41,18 +41,21 @@
 U_NAMESPACE_BEGIN
 
 GlyphIterator::GlyphIterator(LEGlyphStorage &theGlyphStorage, GlyphPositionAdjustments *theGlyphPositionAdjustments, le_bool rightToLeft, le_uint16 theLookupFlags,
-                             FeatureMask theFeatureMask, const GlyphDefinitionTableHeader *theGlyphDefinitionTableHeader)
+                             FeatureMask theFeatureMask, const LEReferenceTo<GlyphDefinitionTableHeader> &theGlyphDefinitionTableHeader)
   : direction(1), position(-1), nextLimit(-1), prevLimit(-1),
     glyphStorage(theGlyphStorage), glyphPositionAdjustments(theGlyphPositionAdjustments),
     srcIndex(-1), destIndex(-1), lookupFlags(theLookupFlags), featureMask(theFeatureMask), glyphGroup(0),
-    glyphClassDefinitionTable(NULL), markAttachClassDefinitionTable(NULL)
+    glyphClassDefinitionTable(), markAttachClassDefinitionTable()
 
 {
+  LEErrorCode success = LE_NO_ERROR; // TODO
     le_int32 glyphCount = glyphStorage.getGlyphCount();
 
-    if (theGlyphDefinitionTableHeader != NULL) {
-        glyphClassDefinitionTable = theGlyphDefinitionTableHeader->getGlyphClassDefinitionTable();
-        markAttachClassDefinitionTable = theGlyphDefinitionTableHeader->getMarkAttachClassDefinitionTable();
+    if (theGlyphDefinitionTableHeader.isValid()) {
+      glyphClassDefinitionTable = theGlyphDefinitionTableHeader
+        -> getGlyphClassDefinitionTable(theGlyphDefinitionTableHeader, success);
+      markAttachClassDefinitionTable = theGlyphDefinitionTableHeader
+        ->getMarkAttachClassDefinitionTable(theGlyphDefinitionTableHeader, success);
     }
 
     nextLimit = glyphCount;
@@ -380,6 +383,7 @@
 
 le_bool GlyphIterator::filterGlyph(le_uint32 index) const
 {
+    LEErrorCode success = LE_NO_ERROR;
     LEGlyphID glyphID = glyphStorage[index];
     le_int32 glyphClass = gcdNoGlyphClass;
 
@@ -387,8 +391,8 @@
         return TRUE;
     }
 
-    if (glyphClassDefinitionTable != NULL) {
-        glyphClass = glyphClassDefinitionTable->getGlyphClass(glyphID);
+    if (glyphClassDefinitionTable.isValid()) {
+      glyphClass = glyphClassDefinitionTable->getGlyphClass(glyphClassDefinitionTable, glyphID, success);
     }
 
     switch (glyphClass)
@@ -410,8 +414,9 @@
 
         le_uint16 markAttachType = (lookupFlags & lfMarkAttachTypeMask) >> lfMarkAttachTypeShift;
 
-        if ((markAttachType != 0) && (markAttachClassDefinitionTable != NULL)) {
-            return markAttachClassDefinitionTable->getGlyphClass(glyphID) != markAttachType;
+        if ((markAttachType != 0) && (markAttachClassDefinitionTable.isValid())) {
+          return markAttachClassDefinitionTable
+            -> getGlyphClass(markAttachClassDefinitionTable, glyphID, success) != markAttachType;
         }
 
         return FALSE;
@@ -461,6 +466,7 @@
     while (newPosition != nextLimit && delta > 0) {
         do {
             newPosition += direction;
+            //fprintf(stderr,"%s:%d:%s: newPosition = %d, delta = %d\n", __FILE__, __LINE__, __FUNCTION__, newPosition, delta);
         } while (newPosition != nextLimit && filterGlyph(newPosition));
 
         delta -= 1;
@@ -468,6 +474,7 @@
 
     position = newPosition;
 
+    //fprintf(stderr,"%s:%d:%s: exit position = %d, delta = %d\n", __FILE__, __LINE__, __FUNCTION__, position, delta);
     return position != nextLimit;
 }
 
@@ -483,6 +490,7 @@
     while (newPosition != prevLimit && delta > 0) {
         do {
             newPosition -= direction;
+            //fprintf(stderr,"%s:%d:%s: newPosition = %d, delta = %d\n", __FILE__, __LINE__, __FUNCTION__, newPosition, delta);
         } while (newPosition != prevLimit && filterGlyph(newPosition));
 
         delta -= 1;
@@ -490,6 +498,7 @@
 
     position = newPosition;
 
+    //fprintf(stderr,"%s:%d:%s: exit position = %d, delta = %d\n", __FILE__, __LINE__, __FUNCTION__, position, delta);
     return position != prevLimit;
 }
 
--- jdk/src/share/native/sun/font/layout/GlyphIterator.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphIterator.h	2013-05-05 09:38:38.000000000 -0700
@@ -49,7 +49,7 @@
 class GlyphIterator : public UMemory {
 public:
     GlyphIterator(LEGlyphStorage &theGlyphStorage, GlyphPositionAdjustments *theGlyphPositionAdjustments, le_bool rightToLeft, le_uint16 theLookupFlags,
-        FeatureMask theFeatureMask, const GlyphDefinitionTableHeader *theGlyphDefinitionTableHeader);
+                  FeatureMask theFeatureMask, const LEReferenceTo<GlyphDefinitionTableHeader> &theGlyphDefinitionTableHeader);
 
     GlyphIterator(GlyphIterator &that);
 
@@ -117,8 +117,8 @@
     FeatureMask featureMask;
     le_int32    glyphGroup;
 
-    const GlyphClassDefinitionTable *glyphClassDefinitionTable;
-    const MarkAttachClassDefinitionTable *markAttachClassDefinitionTable;
+    LEReferenceTo<GlyphClassDefinitionTable> glyphClassDefinitionTable;
+    LEReferenceTo<MarkAttachClassDefinitionTable> markAttachClassDefinitionTable;
 
     GlyphIterator &operator=(const GlyphIterator &other); // forbid copying of this class
 };
--- jdk/src/share/native/sun/font/layout/GlyphLookupTables.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphLookupTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -37,21 +37,22 @@
 
 U_NAMESPACE_BEGIN
 
-le_bool GlyphLookupTableHeader::coversScript(LETag scriptTag) const
+le_bool GlyphLookupTableHeader::coversScript(const LETableReference &base, LETag scriptTag, LEErrorCode &success) const
 {
-    const ScriptListTable *scriptListTable = (const ScriptListTable *) ((char *)this + SWAPW(scriptListOffset));
+  LEReferenceTo<ScriptListTable> scriptListTable(base, success, SWAPW(scriptListOffset));
 
-    return scriptListOffset != 0 && scriptListTable->findScript(scriptTag) != NULL;
+  return (scriptListOffset != 0) && scriptListTable->findScript(scriptListTable, scriptTag, success) .isValid();
 }
 
-le_bool GlyphLookupTableHeader::coversScriptAndLanguage(LETag scriptTag, LETag languageTag, le_bool exactMatch) const
+le_bool GlyphLookupTableHeader::coversScriptAndLanguage(const LETableReference &base, LETag scriptTag, LETag languageTag, LEErrorCode &success, le_bool exactMatch) const
 {
-    const ScriptListTable *scriptListTable = (const ScriptListTable *) ((char *)this + SWAPW(scriptListOffset));
-    const LangSysTable    *langSysTable    = scriptListTable->findLanguage(scriptTag, languageTag, exactMatch);
+  LEReferenceTo<ScriptListTable> scriptListTable(base, success, SWAPW(scriptListOffset));
+  LEReferenceTo<LangSysTable> langSysTable = scriptListTable->findLanguage(scriptListTable,
+                                    scriptTag, languageTag, success, exactMatch);
 
     // FIXME: could check featureListOffset, lookupListOffset, and lookup count...
     // Note: don't have to SWAPW langSysTable->featureCount to check for non-zero.
-    return langSysTable != NULL && langSysTable->featureCount != 0;
+  return LE_SUCCESS(success)&&langSysTable.isValid() && langSysTable->featureCount != 0;
 }
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/GlyphLookupTables.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphLookupTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -49,8 +49,8 @@
     Offset  featureListOffset;
     Offset  lookupListOffset;
 
-    le_bool coversScript(LETag scriptTag) const;
-    le_bool coversScriptAndLanguage(LETag scriptTag, LETag languageTag, le_bool exactMatch = FALSE) const;
+  le_bool coversScript(const LETableReference &base, LETag scriptTag, LEErrorCode &success) const;
+  le_bool coversScriptAndLanguage(const LETableReference &base, LETag scriptTag, LETag languageTag, LEErrorCode &success, le_bool exactMatch = FALSE) const;
 };
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/GlyphPositioningTables.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphPositioningTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -41,16 +41,16 @@
 
 U_NAMESPACE_BEGIN
 
-void GlyphPositioningTableHeader::process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments, le_bool rightToLeft,
+void GlyphPositioningTableHeader::process(const LEReferenceTo<GlyphPositioningTableHeader> &base, LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments, le_bool rightToLeft,
                                           LETag scriptTag, LETag languageTag,
-                                          const GlyphDefinitionTableHeader *glyphDefinitionTableHeader, LEErrorCode &success,
+                                          const LEReferenceTo<GlyphDefinitionTableHeader> &glyphDefinitionTableHeader, LEErrorCode &success,
                                           const LEFontInstance *fontInstance, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const
 {
     if (LE_FAILURE(success)) {
         return;
     }
 
-    GlyphPositioningLookupProcessor processor(this, scriptTag, languageTag, featureMap, featureMapCount, featureOrder, success);
+    GlyphPositioningLookupProcessor processor(base, scriptTag, languageTag, featureMap, featureMapCount, featureOrder, success);
     if (LE_FAILURE(success)) {
         return;
     }
--- jdk/src/share/native/sun/font/layout/GlyphPositioningTables.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphPositioningTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -40,6 +40,7 @@
 #include "OpenTypeTables.h"
 #include "Lookups.h"
 #include "GlyphLookupTables.h"
+#include "LETableReference.h"
 
 U_NAMESPACE_BEGIN
 
@@ -51,9 +52,9 @@
 
 struct GlyphPositioningTableHeader : public GlyphLookupTableHeader
 {
-    void    process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
+  void    process(const LEReferenceTo<GlyphPositioningTableHeader> &base, LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
                 le_bool rightToLeft, LETag scriptTag, LETag languageTag,
-                const GlyphDefinitionTableHeader *glyphDefinitionTableHeader, LEErrorCode &success,
+                const LEReferenceTo<GlyphDefinitionTableHeader> &glyphDefinitionTableHeader, LEErrorCode &success,
                 const LEFontInstance *fontInstance, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const;
 };
 
--- jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -57,7 +57,7 @@
 typedef ChainingContextualSubstitutionSubtable ChainingContextualPositioningSubtable;
 
 GlyphPositioningLookupProcessor::GlyphPositioningLookupProcessor(
-        const GlyphPositioningTableHeader *glyphPositioningTableHeader,
+        const LEReferenceTo<GlyphPositioningTableHeader> &glyphPositioningTableHeader,
         LETag scriptTag,
         LETag languageTag,
         const FeatureMap *featureMap,
@@ -65,7 +65,7 @@
         le_bool featureOrder,
         LEErrorCode& success)
     : LookupProcessor(
-                      (char *) glyphPositioningTableHeader,
+                      glyphPositioningTableHeader,
                       SWAPW(glyphPositioningTableHeader->scriptListOffset),
                       SWAPW(glyphPositioningTableHeader->featureListOffset),
                       SWAPW(glyphPositioningTableHeader->lookupListOffset),
@@ -84,7 +84,7 @@
 {
 }
 
-le_uint32 GlyphPositioningLookupProcessor::applySubtable(const LookupSubtable *lookupSubtable, le_uint16 lookupType,
+le_uint32 GlyphPositioningLookupProcessor::applySubtable(const LEReferenceTo<LookupSubtable> &lookupSubtable, le_uint16 lookupType,
                                                        GlyphIterator *glyphIterator,
                                                        const LEFontInstance *fontInstance,
                                                        LEErrorCode& success) const
@@ -102,55 +102,55 @@
 
     case gpstSingle:
     {
-        const SinglePositioningSubtable *subtable = (const SinglePositioningSubtable *) lookupSubtable;
+      LEReferenceTo<SinglePositioningSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fontInstance);
+        delta = subtable->process(subtable, glyphIterator, fontInstance, success);
         break;
     }
 
     case gpstPair:
     {
-        const PairPositioningSubtable *subtable = (const PairPositioningSubtable *) lookupSubtable;
+        LEReferenceTo<PairPositioningSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fontInstance);
+        delta = subtable->process(subtable, glyphIterator, fontInstance, success);
         break;
     }
 
     case gpstCursive:
     {
-        const CursiveAttachmentSubtable *subtable = (const CursiveAttachmentSubtable *) lookupSubtable;
+        LEReferenceTo<CursiveAttachmentSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fontInstance);
+        delta = subtable->process(subtable, glyphIterator, fontInstance, success);
         break;
     }
 
     case gpstMarkToBase:
     {
-        const MarkToBasePositioningSubtable *subtable = (const MarkToBasePositioningSubtable *) lookupSubtable;
+        LEReferenceTo<MarkToBasePositioningSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fontInstance);
+        delta = subtable->process(subtable, glyphIterator, fontInstance, success);
         break;
     }
 
      case gpstMarkToLigature:
     {
-        const MarkToLigaturePositioningSubtable *subtable = (const MarkToLigaturePositioningSubtable *) lookupSubtable;
+        LEReferenceTo<MarkToLigaturePositioningSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fontInstance);
+        delta = subtable->process(subtable, glyphIterator, fontInstance, success);
         break;
     }
 
     case gpstMarkToMark:
     {
-        const MarkToMarkPositioningSubtable *subtable = (const MarkToMarkPositioningSubtable *) lookupSubtable;
+        LEReferenceTo<MarkToMarkPositioningSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fontInstance);
+        delta = subtable->process(subtable, glyphIterator, fontInstance, success);
         break;
     }
 
    case gpstContext:
     {
-        const ContextualPositioningSubtable *subtable = (const ContextualPositioningSubtable *) lookupSubtable;
+        LEReferenceTo<ContextualPositioningSubtable> subtable(lookupSubtable, success);
 
         delta = subtable->process(this, glyphIterator, fontInstance, success);
         break;
@@ -158,7 +158,7 @@
 
     case gpstChainedContext:
     {
-        const ChainingContextualPositioningSubtable *subtable = (const ChainingContextualPositioningSubtable *) lookupSubtable;
+        LEReferenceTo<ChainingContextualPositioningSubtable> subtable(lookupSubtable, success);
 
         delta = subtable->process(this, glyphIterator, fontInstance, success);
         break;
@@ -166,7 +166,7 @@
 
     case gpstExtension:
     {
-        const ExtensionSubtable *subtable = (const ExtensionSubtable *) lookupSubtable;
+        LEReferenceTo<ExtensionSubtable> subtable(lookupSubtable, success);
 
         delta = subtable->process(this, lookupType, glyphIterator, fontInstance, success);
         break;
--- jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.h	2013-05-05 09:38:38.000000000 -0700
@@ -51,7 +51,7 @@
 class GlyphPositioningLookupProcessor : public LookupProcessor
 {
 public:
-    GlyphPositioningLookupProcessor(const GlyphPositioningTableHeader *glyphPositioningTableHeader,
+    GlyphPositioningLookupProcessor(const LEReferenceTo<GlyphPositioningTableHeader> &glyphPositioningTableHeader,
         LETag scriptTag,
         LETag languageTag,
         const FeatureMap *featureMap,
@@ -61,7 +61,7 @@
 
     virtual ~GlyphPositioningLookupProcessor();
 
-    virtual le_uint32 applySubtable(const LookupSubtable *lookupSubtable, le_uint16 lookupType, GlyphIterator *glyphIterator,
+    virtual le_uint32 applySubtable(const LEReferenceTo<LookupSubtable> &lookupSubtable, le_uint16 lookupType, GlyphIterator *glyphIterator,
         const LEFontInstance *fontInstance, LEErrorCode& success) const;
 
 protected:
--- jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -51,7 +51,7 @@
 U_NAMESPACE_BEGIN
 
 GlyphSubstitutionLookupProcessor::GlyphSubstitutionLookupProcessor(
-        const GlyphSubstitutionTableHeader *glyphSubstitutionTableHeader,
+        const LEReferenceTo<GlyphSubstitutionTableHeader> &glyphSubstitutionTableHeader,
         LETag scriptTag,
         LETag languageTag,
         const LEGlyphFilter *filter,
@@ -60,7 +60,7 @@
         le_bool featureOrder,
         LEErrorCode& success)
     : LookupProcessor(
-                      (char *) glyphSubstitutionTableHeader,
+                      glyphSubstitutionTableHeader,
                       SWAPW(glyphSubstitutionTableHeader->scriptListOffset),
                       SWAPW(glyphSubstitutionTableHeader->featureListOffset),
                       SWAPW(glyphSubstitutionTableHeader->lookupListOffset),
@@ -73,7 +73,7 @@
 {
 }
 
-le_uint32 GlyphSubstitutionLookupProcessor::applySubtable(const LookupSubtable *lookupSubtable, le_uint16 lookupType,
+le_uint32 GlyphSubstitutionLookupProcessor::applySubtable(const LEReferenceTo<LookupSubtable> &lookupSubtable, le_uint16 lookupType,
                                                        GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const
 {
     if (LE_FAILURE(success)) {
@@ -89,39 +89,39 @@
 
     case gsstSingle:
     {
-        const SingleSubstitutionSubtable *subtable = (const SingleSubstitutionSubtable *) lookupSubtable;
+        const LEReferenceTo<SingleSubstitutionSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fFilter);
+        delta = subtable->process(subtable, glyphIterator, success, fFilter);
         break;
     }
 
     case gsstMultiple:
     {
-        const MultipleSubstitutionSubtable *subtable = (const MultipleSubstitutionSubtable *) lookupSubtable;
+        const LEReferenceTo<MultipleSubstitutionSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, success, fFilter);
+        delta = subtable->process(subtable, glyphIterator, success, fFilter);
         break;
     }
 
     case gsstAlternate:
     {
-        const AlternateSubstitutionSubtable *subtable = (const AlternateSubstitutionSubtable *) lookupSubtable;
+        const LEReferenceTo<AlternateSubstitutionSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fFilter);
+        delta = subtable->process(subtable, glyphIterator, success, fFilter);
         break;
     }
 
     case gsstLigature:
     {
-        const LigatureSubstitutionSubtable *subtable = (const LigatureSubstitutionSubtable *) lookupSubtable;
+        const LEReferenceTo<LigatureSubstitutionSubtable> subtable(lookupSubtable, success);
 
-        delta = subtable->process(glyphIterator, fFilter);
+        delta = subtable->process(subtable, glyphIterator, success, fFilter);
         break;
     }
 
     case gsstContext:
     {
-        const ContextualSubstitutionSubtable *subtable = (const ContextualSubstitutionSubtable *) lookupSubtable;
+        const LEReferenceTo<ContextualSubstitutionSubtable> subtable(lookupSubtable, success);
 
         delta = subtable->process(this, glyphIterator, fontInstance, success);
         break;
@@ -129,7 +129,7 @@
 
     case gsstChainingContext:
     {
-        const ChainingContextualSubstitutionSubtable *subtable = (const ChainingContextualSubstitutionSubtable *) lookupSubtable;
+        const LEReferenceTo<ChainingContextualSubstitutionSubtable> subtable(lookupSubtable, success);
 
         delta = subtable->process(this, glyphIterator, fontInstance, success);
         break;
@@ -137,7 +137,7 @@
 
     case gsstExtension:
     {
-        const ExtensionSubtable *subtable = (const ExtensionSubtable *) lookupSubtable;
+        const LEReferenceTo<ExtensionSubtable> subtable(lookupSubtable, success);
 
         delta = subtable->process(this, lookupType, glyphIterator, fontInstance, success);
         break;
--- jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.h	2013-05-05 09:38:38.000000000 -0700
@@ -52,7 +52,7 @@
 class GlyphSubstitutionLookupProcessor : public LookupProcessor
 {
 public:
-    GlyphSubstitutionLookupProcessor(const GlyphSubstitutionTableHeader *glyphSubstitutionTableHeader,
+    GlyphSubstitutionLookupProcessor(const LEReferenceTo<GlyphSubstitutionTableHeader> &glyphSubstitutionTableHeader,
         LETag scriptTag,
         LETag languageTag,
         const LEGlyphFilter *filter,
@@ -63,7 +63,7 @@
 
     virtual ~GlyphSubstitutionLookupProcessor();
 
-    virtual le_uint32 applySubtable(const LookupSubtable *lookupSubtable, le_uint16 lookupType, GlyphIterator *glyphIterator,
+    virtual le_uint32 applySubtable(const LEReferenceTo<LookupSubtable> &lookupSubtable, le_uint16 lookupType, GlyphIterator *glyphIterator,
         const LEFontInstance *fontInstance, LEErrorCode& success) const;
 
 protected:
--- jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -42,11 +42,12 @@
 
 U_NAMESPACE_BEGIN
 
-le_int32 GlyphSubstitutionTableHeader::process(LEGlyphStorage &glyphStorage,
+le_int32 GlyphSubstitutionTableHeader::process(const LEReferenceTo<GlyphSubstitutionTableHeader> &base,
+                                               LEGlyphStorage &glyphStorage,
                                                le_bool rightToLeft,
                                                LETag scriptTag,
                                                LETag languageTag,
-                                           const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
+                                               const LEReferenceTo<GlyphDefinitionTableHeader> &glyphDefinitionTableHeader,
                                                const LEGlyphFilter *filter,
                                                const FeatureMap *featureMap,
                                                le_int32 featureMapCount,
@@ -57,7 +58,7 @@
         return 0;
     }
 
-    GlyphSubstitutionLookupProcessor processor(this, scriptTag, languageTag, filter, featureMap, featureMapCount, featureOrder, success);
+    GlyphSubstitutionLookupProcessor processor(base, scriptTag, languageTag, filter, featureMap, featureMapCount, featureOrder, success);
     return processor.process(glyphStorage, NULL, rightToLeft, glyphDefinitionTableHeader, NULL, success);
 }
 
--- jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,11 +50,12 @@
 
 struct GlyphSubstitutionTableHeader : public GlyphLookupTableHeader
 {
-    le_int32    process(LEGlyphStorage &glyphStorage,
+  le_int32    process(const LEReferenceTo<GlyphSubstitutionTableHeader> &base,
+                      LEGlyphStorage &glyphStorage,
                         le_bool rightToLeft,
                         LETag scriptTag,
                         LETag languageTag,
-                        const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
+                        const LEReferenceTo<GlyphDefinitionTableHeader> &glyphDefinitionTableHeader,
                         const LEGlyphFilter *filter,
                         const FeatureMap *featureMap,
                         le_int32 featureMapCount,
--- jdk/src/share/native/sun/font/layout/HanLayoutEngine.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/HanLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -64,7 +64,7 @@
 #define features (loclFeatureMask)
 
 HanOpenTypeLayoutEngine::HanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+                                                 le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success)
 {
     fFeatureMap      = featureMap;
--- jdk/src/share/native/sun/font/layout/HanLayoutEngine.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/HanLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -73,7 +73,7 @@
      * @internal
      */
     HanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTablem, LEErrorCode &success);
+                            le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTablem, LEErrorCode &success);
 
 
     /**
--- jdk/src/share/native/sun/font/layout/HangulLayoutEngine.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/HangulLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -209,7 +209,7 @@
 }
 
 HangulOpenTypeLayoutEngine::HangulOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 /*languageCode*/,
-                                       le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+                                                       le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, korLanguageCode, typoFlags, gsubTable, success)
 {
     fFeatureMap = featureMap;
--- jdk/src/share/native/sun/font/layout/HangulLayoutEngine.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/HangulLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -79,7 +79,7 @@
      * @internal
      */
     HangulOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success);
+                               le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
--- jdk/src/share/native/sun/font/layout/ICUFeatures.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ICUFeatures.h	2013-05-05 09:38:38.000000000 -0700
@@ -54,16 +54,21 @@
     le_uint16   lookupCount;
     le_uint16   lookupListIndexArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(FeatureTable, lookupListIndexArray)
 
 struct FeatureListTable
 {
     le_uint16           featureCount;
     FeatureRecord       featureRecordArray[ANY_NUMBER];
 
-    const FeatureTable  *getFeatureTable(le_uint16 featureIndex, LETag *featureTag) const;
+  LEReferenceTo<FeatureTable>  getFeatureTable(const LETableReference &base, le_uint16 featureIndex, LETag *featureTag, LEErrorCode &success) const;
 
-    const FeatureTable *getFeatureTable(LETag featureTag) const;
+#if 0
+  const LEReferenceTo<FeatureTable>  getFeatureTable(const LETableReference &base, LETag featureTag, LEErrorCode &success) const;
+#endif
 };
 
+LE_VAR_ARRAY(FeatureListTable, featureRecordArray)
+
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/IndicClassTables.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicClassTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -186,13 +186,15 @@
 };
 
 // FIXME: Should some of the bb's be pb's? (KA, NA, MA, YA, VA, etc. (approx 13))
+// U+C43 and U+C44 are _lm here not _dr.  Similar to the situation with U+CC3 and
+// U+CC4 in Kannada below.
 static const IndicClassTable::CharClass teluCharClasses[] =
 {
     _xx, _mp, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, // 0C00 - 0C0F
     _iv, _xx, _iv, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, // 0C10 - 0C1F
     _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _bb, // 0C20 - 0C2F
     _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _xx, _xx, _da, _da, // 0C30 - 0C3F
-    _da, _dr, _dr, _dr, _dr, _xx, _a1, _da, _s1, _xx, _da, _da, _da, _vr, _xx, _xx, // 0C40 - 0C4F
+    _da, _dr, _dr, _lm, _lm, _xx, _a1, _da, _s1, _xx, _da, _da, _da, _vr, _xx, _xx, // 0C40 - 0C4F
     _xx, _xx, _xx, _xx, _xx, _da, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0C50 - 0C5F
     _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0C60 - 0C6F
 };
--- jdk/src/share/native/sun/font/layout/IndicLayoutEngine.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -50,7 +50,7 @@
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndicOpenTypeLayoutEngine)
 
 IndicOpenTypeLayoutEngine::IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                    le_int32 typoFlags, le_bool version2, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+                                                     le_int32 typoFlags, le_bool version2, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success), fMPreFixups(NULL)
 {
         if ( version2 ) {
--- jdk/src/share/native/sun/font/layout/IndicLayoutEngine.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -81,7 +81,7 @@
      * @internal
      */
     IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, le_bool version2, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success);
+                            le_int32 typoFlags, le_bool version2, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
--- jdk/src/share/native/sun/font/layout/IndicRearrangement.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicRearrangement.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -49,6 +49,10 @@
 {
 };
 
+struct IndicRearrangementSubtableHeader2 : MorphStateTableHeader2
+{
+};
+
 enum IndicRearrangementFlags
 {
     irfMarkFirst    = 0x8000,
@@ -85,6 +89,10 @@
 {
 };
 
+struct IndicRearrangementStateEntry2 : StateEntry2
+{
+};
+
 U_NAMESPACE_END
 #endif
 
--- jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -43,11 +43,14 @@
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndicRearrangementProcessor)
 
-IndicRearrangementProcessor::IndicRearrangementProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : StateTableProcessor(morphSubtableHeader)
+  IndicRearrangementProcessor::IndicRearrangementProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : StateTableProcessor(morphSubtableHeader, success),
+  indicRearrangementSubtableHeader(morphSubtableHeader, success),
+  entryTable(stateTableHeader, success, (const IndicRearrangementStateEntry*)(&stateTableHeader->stHeader),
+             entryTableOffset, LE_UNBOUNDED_ARRAY),
+  int16Table(stateTableHeader, success, (const le_int16*)entryTable.getAlias(), 0, LE_UNBOUNDED_ARRAY)
+
 {
-    indicRearrangementSubtableHeader = (const IndicRearrangementSubtableHeader *) morphSubtableHeader;
-    entryTable = (const IndicRearrangementStateEntry *) ((char *) &stateTableHeader->stHeader + entryTableOffset);
 }
 
 IndicRearrangementProcessor::~IndicRearrangementProcessor()
@@ -62,7 +65,8 @@
 
 ByteOffset IndicRearrangementProcessor::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex index)
 {
-    const IndicRearrangementStateEntry *entry = &entryTable[index];
+  LEErrorCode success = LE_NO_ERROR; // todo- make a param?
+  const IndicRearrangementStateEntry *entry = entryTable.getAlias(index,success);
     ByteOffset newState = SWAPW(entry->newStateOffset);
     IndicRearrangementFlags flags = (IndicRearrangementFlags) SWAPW(entry->flags);
 
--- jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -58,7 +58,7 @@
 
     void doRearrangementAction(LEGlyphStorage &glyphStorage, IndicRearrangementVerb verb) const;
 
-    IndicRearrangementProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    IndicRearrangementProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
     virtual ~IndicRearrangementProcessor();
 
     /**
@@ -79,8 +79,9 @@
     le_int32 firstGlyph;
     le_int32 lastGlyph;
 
-    const IndicRearrangementStateEntry *entryTable;
-    const IndicRearrangementSubtableHeader *indicRearrangementSubtableHeader;
+    LEReferenceTo<IndicRearrangementSubtableHeader> indicRearrangementSubtableHeader;
+    LEReferenceToArrayOf<IndicRearrangementStateEntry> entryTable;
+    LEReferenceToArrayOf<le_int16> int16Table;
 
 };
 
--- jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,425 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "StateTables.h"
+#include "MorphStateTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "IndicRearrangementProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndicRearrangementProcessor2)
+
+IndicRearrangementProcessor2::IndicRearrangementProcessor2(
+      const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : StateTableProcessor2(morphSubtableHeader, success), indicRearrangementSubtableHeader(morphSubtableHeader, success),
+  entryTable(stHeader, success, entryTableOffset, LE_UNBOUNDED_ARRAY)
+{
+}
+
+IndicRearrangementProcessor2::~IndicRearrangementProcessor2()
+{
+}
+
+void IndicRearrangementProcessor2::beginStateTable()
+{
+    firstGlyph = 0;
+    lastGlyph = 0;
+}
+
+le_uint16 IndicRearrangementProcessor2::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph,
+                                                          EntryTableIndex2 index, LEErrorCode &success)
+{
+    const IndicRearrangementStateEntry2 *entry = entryTable.getAlias(index, success);
+    if (LE_FAILURE(success)) return 0; // TODO - what to return in bad state?
+    le_uint16 newState = SWAPW(entry->newStateIndex); // index to the new state
+    IndicRearrangementFlags  flags =  (IndicRearrangementFlags) SWAPW(entry->flags);
+
+    if (flags & irfMarkFirst) {
+        firstGlyph = currGlyph;
+    }
+
+    if (flags & irfMarkLast) {
+        lastGlyph = currGlyph;
+    }
+
+    doRearrangementAction(glyphStorage, (IndicRearrangementVerb) (flags & irfVerbMask));
+
+    if (!(flags & irfDontAdvance)) {
+        currGlyph += dir;
+    }
+
+    return newState; // index to new state
+}
+
+void IndicRearrangementProcessor2::endStateTable()
+{
+}
+
+void IndicRearrangementProcessor2::doRearrangementAction(LEGlyphStorage &glyphStorage, IndicRearrangementVerb verb) const
+{
+    LEGlyphID a, b, c, d;
+    le_int32 ia, ib, ic, id, ix, x;
+    LEErrorCode success = LE_NO_ERROR;
+
+    switch(verb)
+    {
+    case irvNoAction:
+        break;
+
+    case irvxA:
+        a = glyphStorage[firstGlyph];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        x = firstGlyph + 1;
+
+        while (x <= lastGlyph) {
+            glyphStorage[x - 1] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x - 1, ix, success);
+            x += 1;
+        }
+
+        glyphStorage[lastGlyph] = a;
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    case irvDx:
+        d = glyphStorage[lastGlyph];
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = lastGlyph - 1;
+
+        while (x >= firstGlyph) {
+            glyphStorage[x + 1] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x + 1, ix, success);
+            x -= 1;
+        }
+
+        glyphStorage[firstGlyph] = d;
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        break;
+
+    case irvDxA:
+        a = glyphStorage[firstGlyph];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        id = glyphStorage.getCharIndex(lastGlyph,  success);
+
+        glyphStorage[firstGlyph] = glyphStorage[lastGlyph];
+        glyphStorage[lastGlyph] = a;
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(lastGlyph,  ia, success);
+        break;
+
+    case irvxAB:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        x = firstGlyph + 2;
+
+        while (x <= lastGlyph) {
+            glyphStorage[x - 2] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x - 2, ix, success);
+            x += 1;
+        }
+
+        glyphStorage[lastGlyph - 1] = a;
+        glyphStorage[lastGlyph] = b;
+
+        glyphStorage.setCharIndex(lastGlyph - 1, ia, success);
+        glyphStorage.setCharIndex(lastGlyph, ib, success);
+        break;
+
+    case irvxBA:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        x = firstGlyph + 2;
+
+        while (x <= lastGlyph) {
+            glyphStorage[x - 2] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x - 2, ix, success);
+            x += 1;
+        }
+
+        glyphStorage[lastGlyph - 1] = b;
+        glyphStorage[lastGlyph] = a;
+
+        glyphStorage.setCharIndex(lastGlyph - 1, ib, success);
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    case irvCDx:
+        c = glyphStorage[lastGlyph - 1];
+        d = glyphStorage[lastGlyph];
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = lastGlyph - 2;
+
+        while (x >= firstGlyph) {
+            glyphStorage[x + 2] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x + 2, ix, success);
+            x -= 1;
+        }
+
+        glyphStorage[firstGlyph] = c;
+        glyphStorage[firstGlyph + 1] = d;
+
+        glyphStorage.setCharIndex(firstGlyph, ic, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, id, success);
+        break;
+
+    case irvDCx:
+        c = glyphStorage[lastGlyph - 1];
+        d = glyphStorage[lastGlyph];
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = lastGlyph - 2;
+
+        while (x >= firstGlyph) {
+            glyphStorage[x + 2] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x + 2, ix, success);
+            x -= 1;
+        }
+
+        glyphStorage[firstGlyph] = d;
+        glyphStorage[firstGlyph + 1] = c;
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, ic, success);
+        break;
+
+    case irvCDxA:
+        a = glyphStorage[firstGlyph];
+        c = glyphStorage[lastGlyph - 1];
+        d = glyphStorage[lastGlyph];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = lastGlyph - 2;
+
+        while (x > firstGlyph) {
+            glyphStorage[x + 1] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x + 1, ix, success);
+            x -= 1;
+        }
+
+        glyphStorage[firstGlyph] = c;
+        glyphStorage[firstGlyph + 1] = d;
+        glyphStorage[lastGlyph] = a;
+
+        glyphStorage.setCharIndex(firstGlyph, ic, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, id, success);
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    case irvDCxA:
+        a = glyphStorage[firstGlyph];
+        c = glyphStorage[lastGlyph - 1];
+        d = glyphStorage[lastGlyph];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = lastGlyph - 2;
+
+        while (x > firstGlyph) {
+            glyphStorage[x + 1] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x + 1, ix, success);
+            x -= 1;
+        }
+
+        glyphStorage[firstGlyph] = d;
+        glyphStorage[firstGlyph + 1] = c;
+        glyphStorage[lastGlyph] = a;
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, ic, success);
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    case irvDxAB:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+        d = glyphStorage[lastGlyph];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = firstGlyph + 2;
+
+        while (x < lastGlyph) {
+            glyphStorage[x - 2] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x - 2, ix, success);
+            x += 1;
+        }
+
+        glyphStorage[firstGlyph] = d;
+        glyphStorage[lastGlyph - 1] = a;
+        glyphStorage[lastGlyph] = b;
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(lastGlyph - 1, ia, success);
+        glyphStorage.setCharIndex(lastGlyph, ib, success);
+        break;
+
+    case irvDxBA:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+        d = glyphStorage[lastGlyph];
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+        x = firstGlyph + 2;
+
+        while (x < lastGlyph) {
+            glyphStorage[x - 2] = glyphStorage[x];
+            ix = glyphStorage.getCharIndex(x, success);
+            glyphStorage.setCharIndex(x - 2, ix, success);
+            x += 1;
+        }
+
+        glyphStorage[firstGlyph] = d;
+        glyphStorage[lastGlyph - 1] = b;
+        glyphStorage[lastGlyph] = a;
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(lastGlyph - 1, ib, success);
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    case irvCDxAB:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+
+        glyphStorage[firstGlyph] = glyphStorage[lastGlyph - 1];
+        glyphStorage[firstGlyph + 1] = glyphStorage[lastGlyph];
+
+        glyphStorage[lastGlyph - 1] = a;
+        glyphStorage[lastGlyph] = b;
+
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+
+        glyphStorage.setCharIndex(firstGlyph, ic, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, id, success);
+
+        glyphStorage.setCharIndex(lastGlyph - 1, ia, success);
+        glyphStorage.setCharIndex(lastGlyph, ib, success);
+        break;
+
+    case irvCDxBA:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+
+        glyphStorage[firstGlyph] = glyphStorage[lastGlyph - 1];
+        glyphStorage[firstGlyph + 1] = glyphStorage[lastGlyph];
+
+        glyphStorage[lastGlyph - 1] = b;
+        glyphStorage[lastGlyph] = a;
+
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+
+        glyphStorage.setCharIndex(firstGlyph, ic, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, id, success);
+
+        glyphStorage.setCharIndex(lastGlyph - 1, ib, success);
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    case irvDCxAB:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+
+        glyphStorage[firstGlyph] = glyphStorage[lastGlyph];
+        glyphStorage[firstGlyph + 1] = glyphStorage[lastGlyph - 1];
+
+        glyphStorage[lastGlyph - 1] = a;
+        glyphStorage[lastGlyph] = b;
+
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, ic, success);
+
+        glyphStorage.setCharIndex(lastGlyph - 1, ia, success);
+        glyphStorage.setCharIndex(lastGlyph, ib, success);
+        break;
+
+    case irvDCxBA:
+        a = glyphStorage[firstGlyph];
+        b = glyphStorage[firstGlyph + 1];
+
+        glyphStorage[firstGlyph] = glyphStorage[lastGlyph];
+        glyphStorage[firstGlyph + 1] = glyphStorage[lastGlyph - 1];
+
+        glyphStorage[lastGlyph - 1] = b;
+        glyphStorage[lastGlyph] = a;
+
+        ia = glyphStorage.getCharIndex(firstGlyph, success);
+        ib = glyphStorage.getCharIndex(firstGlyph + 1, success);
+        ic = glyphStorage.getCharIndex(lastGlyph - 1, success);
+        id = glyphStorage.getCharIndex(lastGlyph, success);
+
+        glyphStorage.setCharIndex(firstGlyph, id, success);
+        glyphStorage.setCharIndex(firstGlyph + 1, ic, success);
+
+        glyphStorage.setCharIndex(lastGlyph - 1, ib, success);
+        glyphStorage.setCharIndex(lastGlyph, ia, success);
+        break;
+
+    default:
+        break;
+    }
+
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,88 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __INDICREARRANGEMENTPROCESSOR2_H
+#define __INDICREARRANGEMENTPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor.h"
+#include "StateTableProcessor2.h"
+#include "IndicRearrangement.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class IndicRearrangementProcessor2 : public StateTableProcessor2
+{
+public:
+    virtual void beginStateTable();
+
+    virtual le_uint16 processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex2 index, LEErrorCode &success);
+
+    virtual void endStateTable();
+
+    void doRearrangementAction(LEGlyphStorage &glyphStorage, IndicRearrangementVerb verb) const;
+
+    IndicRearrangementProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+    virtual ~IndicRearrangementProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+protected:
+    le_int32 firstGlyph;
+    le_int32 lastGlyph;
+
+    LEReferenceToArrayOf<IndicRearrangementStateEntry2> entryTable;
+    LEReferenceTo<IndicRearrangementSubtableHeader2> indicRearrangementSubtableHeader;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/IndicReordering.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicReordering.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -266,7 +266,7 @@
                                         le_uint32 saveAuxData = fGlyphStorage.getAuxData(i+inv_count,success);
                     const SplitMatra *splitMatra = classTable->getSplitMatra(matraClass);
                     int j;
-                    for (j = 0 ; *(splitMatra)[j] != 0 ; j++) {
+                    for (j = 0 ; j < SM_MAX_PIECES && *(splitMatra)[j] != 0 ; j++) {
                         LEUnicode piece = (*splitMatra)[j];
                                                 if ( j == 0 ) {
                                                         fOutChars[i+inv_count] = piece;
@@ -357,7 +357,7 @@
                 const SplitMatra *splitMatra = classTable->getSplitMatra(matraClass);
                 int i;
 
-                for (i = 0; i < 3 && (*splitMatra)[i] != 0; i += 1) {
+                for (i = 0; i < SM_MAX_PIECES && (*splitMatra)[i] != 0; i += 1) {
                     LEUnicode piece = (*splitMatra)[i];
                     IndicClassTable::CharClass pieceClass = classTable->getCharClass(piece);
 
@@ -658,6 +658,11 @@
     MPreFixups *mpreFixups = NULL;
     const IndicClassTable *classTable = IndicClassTable::getScriptClassTable(scriptCode);
 
+    if(classTable==NULL) {
+      success = LE_MEMORY_ALLOCATION_ERROR;
+      return 0;
+    }
+
     if (classTable->scriptFlags & SF_MPRE_FIXUP) {
         mpreFixups = new MPreFixups(charCount);
         if (mpreFixups == NULL) {
@@ -1224,7 +1229,6 @@
 
 
     LEUnicode currentChar;
-    LEUnicode virama;
     LEUnicode workChars[2];
     LEGlyphStorage workGlyphs;
 
@@ -1232,14 +1236,17 @@
 
     //le_int32 offset = 0;
 
+#if 0
+// TODO:  Should this section of code have actually been doing something?
     // First find the relevant virama for the script we are dealing with
-
+    LEUnicode virama;
     for ( currentChar = classTable->firstChar ; currentChar <= classTable->lastChar ; currentChar++ ) {
         if ( classTable->isVirama(currentChar)) {
             virama = currentChar;
             break;
         }
     }
+#endif
 
     for ( currentChar = classTable->firstChar ; currentChar <= classTable->lastChar ; currentChar++ ) {
         if ( classTable->isConsonant(currentChar)) {
--- jdk/src/share/native/sun/font/layout/IndicReordering.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/IndicReordering.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2009 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -96,7 +96,9 @@
 #define SF_POST_BASE_LIMIT_MASK  0x0000FFFFU
 #define SF_NO_POST_BASE_LIMIT    0x00007FFFU
 
-typedef LEUnicode SplitMatra[3];
+#define SM_MAX_PIECES 3
+
+typedef LEUnicode SplitMatra[SM_MAX_PIECES];
 
 class MPreFixups;
 class LEGlyphStorage;
--- jdk/src/share/native/sun/font/layout/KernTable.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/KernTable.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -48,7 +48,7 @@
   le_int16  value; // fword, kern value in funits
 };
 #define KERN_PAIRINFO_SIZE 6
-
+LE_CORRECT_SIZE(PairInfo, KERN_PAIRINFO_SIZE)
 struct Subtable_0 {
   le_uint16 nPairs;
   le_uint16 searchRange;
@@ -56,6 +56,7 @@
   le_uint16 rangeShift;
 };
 #define KERN_SUBTABLE_0_HEADER_SIZE 8
+LE_CORRECT_SIZE(Subtable_0, KERN_SUBTABLE_0_HEADER_SIZE)
 
 // Kern table version 0 only
 struct SubtableHeader {
@@ -64,6 +65,7 @@
   le_uint16 coverage;
 };
 #define KERN_SUBTABLE_HEADER_SIZE 6
+LE_CORRECT_SIZE(SubtableHeader, KERN_SUBTABLE_HEADER_SIZE)
 
 // Version 0 only, version 1 has different layout
 struct KernTableHeader {
@@ -71,6 +73,7 @@
   le_uint16 nTables;
 };
 #define KERN_TABLE_HEADER_SIZE 4
+LE_CORRECT_SIZE(KernTableHeader, KERN_TABLE_HEADER_SIZE)
 
 #define COVERAGE_HORIZONTAL 0x1
 #define COVERAGE_MINIMUM 0x2
@@ -92,21 +95,21 @@
  * TODO: support multiple subtables
  * TODO: respect header flags
  */
-KernTable::KernTable(const LEFontInstance* font_, const void* tableData)
-  : pairs(0), font(font_)
+KernTable::KernTable(const LETableReference& base, LEErrorCode &success)
+  : pairs(), pairsSwapped(NULL), fTable(base)
 {
-  const KernTableHeader* header = (const KernTableHeader*)tableData;
-  if (header == 0) {
+  if(LE_FAILURE(success) || (fTable.isEmpty())) {
 #if DEBUG
     fprintf(stderr, "no kern data\n");
 #endif
     return;
   }
+  LEReferenceTo<KernTableHeader> header(fTable, success);
 
 #if DEBUG
   // dump first 32 bytes of header
   for (int i = 0; i < 64; ++i) {
-    fprintf(stderr, "%0.2x ", ((const char*)tableData)[i]&0xff);
+    fprintf(stderr, "%0.2x ", ((const char*)header.getAlias())[i]&0xff);
     if (((i+1)&0xf) == 0) {
       fprintf(stderr, "\n");
     } else if (((i+1)&0x7) == 0) {
@@ -115,12 +118,17 @@
   }
 #endif
 
-  if (header->version == 0 && SWAPW(header->nTables) > 0) {
-    const SubtableHeader* subhead = (const SubtableHeader*)((char*)tableData + KERN_TABLE_HEADER_SIZE);
-    if (subhead->version == 0) {
+  if(LE_FAILURE(success)) return;
+
+  if (!header.isEmpty() && header->version == 0 && SWAPW(header->nTables) > 0) {
+    LEReferenceTo<SubtableHeader> subhead(header, success, KERN_TABLE_HEADER_SIZE);
+
+    if (LE_SUCCESS(success) && !subhead.isEmpty() && subhead->version == 0) {
       coverage = SWAPW(subhead->coverage);
       if (coverage & COVERAGE_HORIZONTAL) { // only handle horizontal kerning
-        const Subtable_0* table = (const Subtable_0*)((char*)subhead + KERN_SUBTABLE_HEADER_SIZE);
+        LEReferenceTo<Subtable_0> table(subhead, success, KERN_SUBTABLE_HEADER_SIZE);
+
+        if(table.isEmpty() || LE_FAILURE(success)) return;
 
         nPairs        = SWAPW(table->nPairs);
 
@@ -134,19 +142,31 @@
         rangeShift    = (nPairs * KERN_PAIRINFO_SIZE) - searchRange;
 #endif
 
-        pairs = (PairInfo*)font->getKernPairs();
-        if (pairs == NULL) {
-            char *pairData = (char*)table + KERN_SUBTABLE_0_HEADER_SIZE;
-            char *pptr = pairData;
-            pairs =  (PairInfo*)(malloc(nPairs*sizeof(PairInfo)));
-            PairInfo *p = (PairInfo*)pairs;
-            for (int i = 0; i < nPairs; i++, pptr += KERN_PAIRINFO_SIZE, p++) {
-              memcpy(p, pptr, KERN_PAIRINFO_SIZE);
+        if(LE_SUCCESS(success) && nPairs>0) {
+          // pairs is an instance member, and table is on the stack.
+          // set 'pairs' based on table.getAlias(). This will range check it.
+
+          pairs = LEReferenceToArrayOf<PairInfo>(fTable, // based on overall table
+                                                 success,
+                                                 (const PairInfo*)table.getAlias(),  // subtable 0 + ..
+                                                 KERN_SUBTABLE_0_HEADER_SIZE,  // .. offset of header size
+                                                 nPairs); // count
+        }
+        if (LE_SUCCESS(success) && pairs.isValid()) {
+            pairsSwapped =  (PairInfo*)(malloc(nPairs*sizeof(PairInfo)));
+            PairInfo *p = (PairInfo*)pairsSwapped;
+            for (int i = 0; LE_SUCCESS(success) && i < nPairs; i++, p++) {
+              memcpy(p, pairs.getAlias(i,success), KERN_PAIRINFO_SIZE);
               p->key = SWAPL(p->key);
             }
-            font->setKernPairs((void*)pairs);
+            fTable.getFont()->setKernPairs((void*)pairsSwapped); // store it
         }
 
+#if 0
+        fprintf(stderr, "coverage: %0.4x nPairs: %d pairs %p\n", coverage, nPairs, pairs.getAlias());
+        fprintf(stderr, "  searchRange: %d entrySelector: %d rangeShift: %d\n", searchRange, entrySelector, rangeShift);
+        fprintf(stderr, "[[ ignored font table entries: range %d selector %d shift %d ]]\n", SWAPW(table->searchRange), SWAPW(table->entrySelector), SWAPW(table->rangeShift));
+#endif
 #if DEBUG
         fprintf(stderr, "coverage: %0.4x nPairs: %d pairs 0x%x\n", coverage, nPairs, pairs);
         fprintf(stderr,
@@ -194,14 +214,17 @@
  * Process the glyph positions.  The positions array has two floats for each
  * glyph, plus a trailing pair to mark the end of the last glyph.
  */
-void KernTable::process(LEGlyphStorage& storage)
+void KernTable::process(LEGlyphStorage& storage, LEErrorCode &success)
 {
-  if (pairs) {
-    LEErrorCode success = LE_NO_ERROR;
+  if(LE_FAILURE(success)) return;
+
+  if (pairsSwapped) {
+    success = LE_NO_ERROR;
 
     le_uint32 key = storage[0]; // no need to mask off high bits
     float adjust = 0;
-    for (int i = 1, e = storage.getGlyphCount(); i < e; ++i) {
+
+    for (int i = 1, e = storage.getGlyphCount(); LE_SUCCESS(success)&&  i < e; ++i) {
       key = key << 16 | (storage[i] & 0xffff);
 
       // argh, to do a binary search, we need to have the pair list in sorted order
@@ -209,7 +232,7 @@
       // so either I have to swap the element each time I examine it, or I have to swap
       // all the elements ahead of time and store them in the font
 
-      const PairInfo* p = pairs;
+      const PairInfo* p = pairsSwapped;
       const PairInfo* tp = (const PairInfo*)(p + (rangeShift/KERN_PAIRINFO_SIZE)); /* rangeshift is in original table bytes */
       if (key > tp->key) {
         p = tp;
@@ -225,7 +248,7 @@
         tp = (const PairInfo*)(p + (probe/KERN_PAIRINFO_SIZE));
         le_uint32 tkey = tp->key;
 #if DEBUG
-        fprintf(stdout, "   %.3d (%0.8x)\n", (tp - pairs), tkey);
+        fprintf(stdout, "   %.3d (%0.8x)\n", (tp - pairsSwapped), tkey);
 #endif
         if (tkey <= key) {
           if (tkey == key) {
@@ -240,10 +263,10 @@
             // device transform, or a faster way, such as moving the
             // entire kern table up to Java.
             LEPoint pt;
-            pt.fX = font->xUnitsToPoints(value);
+            pt.fX = fTable.getFont()->xUnitsToPoints(value);
             pt.fY = 0;
 
-            font->getKerningAdjustment(pt);
+            fTable.getFont()->getKerningAdjustment(pt);
             adjust += pt.fX;
             break;
           }
--- jdk/src/share/native/sun/font/layout/KernTable.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/KernTable.h	2013-05-05 09:38:38.000000000 -0700
@@ -26,7 +26,7 @@
 /*
  *
  *
- * (C) Copyright IBM Corp. 2004-2005 - All Rights Reserved
+ * (C) Copyright IBM Corp. 2004-2013 - All Rights Reserved
  *
  */
 
@@ -38,6 +38,7 @@
 #endif
 
 #include "LETypes.h"
+#include "LETableReference.h"
 //#include "LEFontInstance.h"
 //#include "LEGlyphStorage.h"
 
@@ -56,19 +57,20 @@
  private:
   le_uint16 coverage;
   le_uint16 nPairs;
-  const PairInfo* pairs;
-  const LEFontInstance* font;
+  LEReferenceToArrayOf<PairInfo> pairs;
+  PairInfo  *pairsSwapped;
+  const LETableReference &fTable;
   le_uint16 searchRange;
   le_uint16 entrySelector;
   le_uint16 rangeShift;
 
  public:
-  KernTable(const LEFontInstance* font, const void* tableData);
+  KernTable(const LETableReference &table, LEErrorCode &success);
 
   /*
    * Process the glyph positions.
    */
-  void process(LEGlyphStorage& storage);
+  void process(LEGlyphStorage& storage, LEErrorCode &success);
 };
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.cpp	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -43,7 +43,7 @@
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(KhmerOpenTypeLayoutEngine)
 
 KhmerOpenTypeLayoutEngine::KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                    le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+                                                     le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success)
 {
     fFeatureMap   = KhmerReordering::getFeatureMap(fFeatureMapCount);
--- jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.h	2012-08-10 10:30:32.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -83,7 +83,7 @@
      * @internal
      */
     KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success);
+                            le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
--- jdk/src/share/native/sun/font/layout/LEFontInstance.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LEFontInstance.h	2013-05-05 09:38:38.000000000 -0700
@@ -190,6 +190,25 @@
      */
     virtual const void *getFontTable(LETag tableTag) const = 0;
 
+    /**
+     * This method reads a table from the font. Note that in general,
+     * it only makes sense to call this method on an <code>LEFontInstance</code>
+     * which represents a physical font - i.e. one which has been returned by
+     * <code>getSubFont()</code>. This is because each subfont in a composite font
+     * will have different tables, and there's no way to know which subfont to access.
+     *
+     * Subclasses which represent composite fonts should always return <code>NULL</code>.
+     *
+     * This version sets a length, for range checking.
+     *
+     * @param tableTag - the four byte table tag. (e.g. 'cmap')
+     * @param length - ignored on entry, on exit will be the length of the table if known, or -1 if unknown.
+     * @return the address of the table in memory, or <code>NULL</code>
+     *         if the table doesn't exist.
+     * @internal
+     */
+    virtual const void* getFontTable(LETag tableTag, size_t &length) const { length=-1; return getFontTable(tableTag); }  /* -1 = unknown length */
+
     virtual void *getKernPairs() const = 0;
     virtual void  setKernPairs(void *pairs) const = 0;
 
--- jdk/src/share/native/sun/font/layout/LEGlyphFilter.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LEGlyphFilter.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -36,6 +36,7 @@
 
 U_NAMESPACE_BEGIN
 
+#ifndef U_HIDE_INTERNAL_API
 /**
  * This is a helper class that is used to
  * recognize a set of glyph indices.
@@ -63,6 +64,7 @@
      */
     virtual le_bool accept(LEGlyphID glyph) const = 0;
 };
+#endif  /* U_HIDE_INTERNAL_API */
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/LEInsertionList.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LEInsertionList.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  **********************************************************************
- *   Copyright (C) 1998-2008, International Business Machines
+ *   Copyright (C) 1998-2013, International Business Machines
  *   Corporation and others.  All Rights Reserved.
  **********************************************************************
  */
@@ -39,6 +39,7 @@
 
 struct InsertionRecord;
 
+#ifndef U_HIDE_INTERNAL_API
 /**
  * This class encapsulates the callback used by <code>LEInsertionList</code>
  * to apply an insertion from the insertion list.
@@ -194,6 +195,7 @@
      */
     le_bool  append;
 };
+#endif  /* U_HIDE_INTERNAL_API */
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/LEScripts.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LEScripts.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010. All Rights Reserved.
+ * (C) Copyright IBM Corp. 1998-2013. All Rights Reserved.
  *
  * WARNING: THIS FILE IS MACHINE GENERATED. DO NOT HAND EDIT IT UNLESS
  * YOU REALLY KNOW WHAT YOU'RE DOING.
@@ -241,8 +241,28 @@
     palmScriptCode = 144,
     sindScriptCode = 145,
     waraScriptCode = 146,
+/**
+ * @stable ICU 4.8
+ */
+
+    afakScriptCode = 147,
+    jurcScriptCode = 148,
+    mrooScriptCode = 149,
+    nshuScriptCode = 150,
+    shrdScriptCode = 151,
+    soraScriptCode = 152,
+    takrScriptCode = 153,
+    tangScriptCode = 154,
+    woleScriptCode = 155,
+/**
+ * @stable ICU 49
+ */
+
+    hluwScriptCode = 156, /* bump to match current ICU */
+    khojScriptCode = 157,
+    tirhScriptCode = 158,
 
-    scriptCodeCount = 147
+    scriptCodeCount = 159
 };
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/LETableReference.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/LETableReference.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * -*- c++ -*-
+ *
+ * (C) Copyright IBM Corp. and others 2013 - All Rights Reserved
+ *
+ * Range checking
+ *
+ */
+
+#ifndef __LETABLEREFERENCE_H
+#define __LETABLEREFERENCE_H
+
+#include "LETypes.h"
+#include "LEFontInstance.h"
+
+
+#define kQuestionmarkTableTag  0x3F3F3F3FUL
+#define kTildeTableTag  0x7e7e7e7eUL
+#ifdef __cplusplus
+
+// internal - interface for range checking
+U_NAMESPACE_BEGIN
+
+#if LE_ASSERT_BAD_FONT
+class LETableReference; // fwd
+/**
+ *  defined in OpenTypeUtilities.cpp
+ * @internal
+ */
+extern void _debug_LETableReference(const char *f, int l, const char *msg, const LETableReference *what, const void *ptr, size_t len);
+
+#define LE_DEBUG_TR(x) _debug_LETableReference(__FILE__, __LINE__, x, this, NULL, 0);
+#define LE_DEBUG_TR3(x,y,z) _debug_LETableReference(__FILE__, __LINE__, x, this, (const void*)y, (size_t)z);
+#if 0
+#define LE_TRACE_TR(x) _debug_LETableReference(__FILE__, __LINE__, x, this, NULL, 0);
+#else
+#define LE_TRACE_TR(x)
+#endif
+
+#else
+#define LE_DEBUG_TR(x)
+#define LE_DEBUG_TR3(x,y,z)
+#define LE_TRACE_TR(x)
+#endif
+
+/**
+ * @internal
+ */
+class LETableReference {
+public:
+/**
+ * @internal
+ * Construct from a specific tag
+ */
+  LETableReference(const LEFontInstance* font, LETag tableTag, LEErrorCode &success) :
+    fFont(font), fTag(tableTag), fParent(NULL), fStart(NULL),fLength(LE_UINTPTR_MAX) {
+      loadTable(success);
+    LE_TRACE_TR("INFO: new table load")
+  }
+
+  LETableReference(const LETableReference &parent, LEErrorCode &success) : fFont(parent.fFont), fTag(parent.fTag), fParent(&parent), fStart(parent.fStart), fLength(parent.fLength) {
+    if(LE_FAILURE(success)) {
+      clear();
+    }
+    LE_TRACE_TR("INFO: new clone")
+  }
+
+   LETableReference(const le_uint8* data, size_t length = LE_UINTPTR_MAX) :
+    fFont(NULL), fTag(kQuestionmarkTableTag), fParent(NULL), fStart(data), fLength(length) {
+    LE_TRACE_TR("INFO: new raw")
+  }
+  LETableReference() :
+    fFont(NULL), fTag(kQuestionmarkTableTag), fParent(NULL), fStart(NULL), fLength(0) {
+    LE_TRACE_TR("INFO: new empty")
+  }
+
+  ~LETableReference() {
+    fTag=kTildeTableTag;
+    LE_TRACE_TR("INFO: new dtor")
+  }
+
+  /**
+   * @internal
+   * @param length  if LE_UINTPTR_MAX means "whole table"
+   * subset
+   */
+  LETableReference(const LETableReference &parent, size_t offset, size_t length,
+                   LEErrorCode &err) :
+    fFont(parent.fFont), fTag(parent.fTag), fParent(&parent),
+    fStart((parent.fStart)+offset), fLength(length) {
+    if(LE_SUCCESS(err)) {
+      if(isEmpty()) {
+        //err = LE_MISSING_FONT_TABLE_ERROR;
+        clear(); // it's just empty. Not an error.
+      } else if(offset >= fParent->fLength) {
+        LE_DEBUG_TR3("offset out of range: (%p) +%d", NULL, offset);
+        err = LE_INDEX_OUT_OF_BOUNDS_ERROR;
+        clear();
+      } else {
+        if(fLength == LE_UINTPTR_MAX &&
+           fParent->fLength != LE_UINTPTR_MAX) {
+          fLength = (fParent->fLength) - offset; // decrement length as base address is incremented
+        }
+        if(fLength != LE_UINTPTR_MAX) {  // if we have bounds:
+          if(offset+fLength > fParent->fLength) {
+            LE_DEBUG_TR3("offset+fLength out of range: (%p) +%d", NULL, offset+fLength);
+            err = LE_INDEX_OUT_OF_BOUNDS_ERROR; // exceeded
+            clear();
+          }
+        }
+      }
+    } else {
+      clear();
+    }
+    LE_TRACE_TR("INFO: new subset")
+  }
+
+  const void* getAlias() const { return (const void*)fStart; }
+  const void* getAliasTODO() const { LE_DEBUG_TR("getAliasTODO()"); return (const void*)fStart; }
+  le_bool isEmpty() const { return fStart==NULL || fLength==0; }
+  le_bool isValid() const { return !isEmpty(); }
+  le_bool hasBounds() const { return fLength!=LE_UINTPTR_MAX; }
+  void clear() { fLength=0; fStart=NULL; }
+  size_t getLength() const { return fLength; }
+  const LEFontInstance* getFont() const { return fFont; }
+  LETag getTag() const { return fTag; }
+  const LETableReference* getParent() const { return fParent; }
+
+  void addOffset(size_t offset, LEErrorCode &success) {
+    if(hasBounds()) {
+      if(offset > fLength) {
+        LE_DEBUG_TR("addOffset off end");
+        success = LE_INDEX_OUT_OF_BOUNDS_ERROR;
+        return;
+      } else {
+        fLength -= offset;
+      }
+    }
+    fStart += offset;
+  }
+
+  size_t ptrToOffset(const void *atPtr, LEErrorCode &success) const {
+    if(atPtr==NULL) return 0;
+    if(LE_FAILURE(success)) return LE_UINTPTR_MAX;
+    if((atPtr < fStart) ||
+       (hasBounds() && (atPtr > fStart+fLength))) {
+      LE_DEBUG_TR3("ptrToOffset args out of range: %p", atPtr, 0);
+      success = LE_INDEX_OUT_OF_BOUNDS_ERROR;
+      return LE_UINTPTR_MAX;
+    }
+    return ((const le_uint8*)atPtr)-fStart;
+  }
+
+  /**
+   * Clamp down the length, for range checking.
+   */
+  size_t contractLength(size_t newLength) {
+    if(fLength!=LE_UINTPTR_MAX&&newLength>0&&newLength<=fLength) {
+      fLength = newLength;
+    }
+    return fLength;
+  }
+
+  /**
+   * Throw an error if offset+length off end
+   */
+public:
+  size_t verifyLength(size_t offset, size_t length, LEErrorCode &success) {
+    if(isValid()&&
+       LE_SUCCESS(success) &&
+       fLength!=LE_UINTPTR_MAX && length!=LE_UINTPTR_MAX && offset!=LE_UINTPTR_MAX &&
+       (offset+length)>fLength) {
+      LE_DEBUG_TR3("verifyLength failed (%p) %d",NULL, offset+length);
+      success = LE_INDEX_OUT_OF_BOUNDS_ERROR;
+#if LE_ASSERT_BAD_FONT
+      fprintf(stderr, "offset=%lu, len=%lu, would be at %p, (%lu) off end. End at %p\n", offset,length, fStart+offset+length, (offset+length-fLength), (offset+length-fLength)+fStart);
+#endif
+    }
+    return fLength;
+  }
+
+  /**
+   * Change parent link to another
+   */
+  LETableReference &reparent(const LETableReference &base) {
+    fParent = &base;
+    return *this;
+  }
+
+  /**
+   * remove parent link. Factory functions should do this.
+   */
+  void orphan(void) {
+    fParent=NULL;
+  }
+
+protected:
+  const LEFontInstance* fFont;
+  LETag  fTag;
+  const LETableReference *fParent;
+  const le_uint8 *fStart; // keep as 8 bit internally, for pointer math
+  size_t fLength;
+
+  void loadTable(LEErrorCode &success) {
+    if(LE_SUCCESS(success)) {
+      fStart = (const le_uint8*)(fFont->getFontTable(fTag, fLength)); // note - a null table is not an error.
+    }
+  }
+
+  void setRaw(const void *data, size_t length = LE_UINTPTR_MAX) {
+    fFont = NULL;
+    fTag = kQuestionmarkTableTag;
+    fParent = NULL;
+    fStart = (const le_uint8*)data;
+    fLength = length;
+  }
+};
+
+
+template<class T>
+class LETableVarSizer {
+ public:
+  inline static size_t getSize();
+};
+
+// base definition- could override for adjustments
+template<class T> inline
+size_t LETableVarSizer<T>::getSize() {
+  return sizeof(T);
+}
+
+/**
+ * \def LE_VAR_ARRAY
+ * @param x Type (T)
+ * @param y some member that is of length ANY_NUMBER
+ * Call this after defining a class, for example:
+ *   LE_VAR_ARRAY(FeatureListTable,featureRecordArray)
+ * this is roughly equivalent to:
+ *   template<> inline size_t LETableVarSizer<FeatureListTable>::getSize() { return sizeof(FeatureListTable) - (sizeof(le_uint16)*ANY_NUMBER); }
+ * it's a specialization that informs the LETableReference subclasses to NOT include the variable array in the size.
+ * dereferencing NULL is valid here because we never actually dereference it, just inside sizeof.
+ */
+#define LE_VAR_ARRAY(x,y) template<> inline size_t LETableVarSizer<x>::getSize() { return sizeof(x) - (sizeof(((const x*)0)->y)); }
+/**
+ * \def LE_CORRECT_SIZE
+ * @param x type (T)
+ * @param y fixed size for T
+ */
+#define LE_CORRECT_SIZE(x,y) template<> inline size_t LETableVarSizer<x>::getSize() { return y; }
+
+/**
+ * Open a new entry based on an existing table
+ */
+
+/**
+ * \def LE_UNBOUNDED_ARRAY
+ * define an array with no *known* bound. Will trim to available size.
+ * @internal
+ */
+#define LE_UNBOUNDED_ARRAY LE_UINT32_MAX
+
+template<class T>
+class LEReferenceToArrayOf : public LETableReference {
+public:
+  LEReferenceToArrayOf(const LETableReference &parent, LEErrorCode &success, size_t offset, le_uint32 count)
+    : LETableReference(parent, offset, LE_UINTPTR_MAX, success), fCount(count) {
+    LE_TRACE_TR("INFO: new RTAO by offset")
+    if(LE_SUCCESS(success)) {
+      if(count == LE_UNBOUNDED_ARRAY) { // not a known length
+        count = getLength()/LETableVarSizer<T>::getSize(); // fit to max size
+      }
+      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize()*count, success);
+    }
+    if(LE_FAILURE(success)) {
+      fCount=0;
+      clear();
+    }
+  }
+
+  LEReferenceToArrayOf(const LETableReference &parent, LEErrorCode &success, const T* array, le_uint32 count)
+    : LETableReference(parent, parent.ptrToOffset(array, success), LE_UINTPTR_MAX, success), fCount(count) {
+LE_TRACE_TR("INFO: new RTAO")
+    if(LE_SUCCESS(success)) {
+      if(count == LE_UNBOUNDED_ARRAY) { // not a known length
+        count = getLength()/LETableVarSizer<T>::getSize(); // fit to max size
+      }
+      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize()*count, success);
+    }
+    if(LE_FAILURE(success)) clear();
+  }
+ LEReferenceToArrayOf(const LETableReference &parent, LEErrorCode &success, const T* array, size_t offset, le_uint32 count)
+   : LETableReference(parent, parent.ptrToOffset(array, success)+offset, LE_UINTPTR_MAX, success), fCount(count) {
+LE_TRACE_TR("INFO: new RTAO")
+    if(LE_SUCCESS(success)) {
+      if(count == LE_UNBOUNDED_ARRAY) { // not a known length
+        count = getLength()/LETableVarSizer<T>::getSize(); // fit to max size
+      }
+      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize()*count, success);
+    }
+    if(LE_FAILURE(success)) clear();
+  }
+
+ LEReferenceToArrayOf() :LETableReference(), fCount(0) {}
+
+  le_uint32 getCount() const { return fCount; }
+
+  using LETableReference::getAlias;
+
+  const T *getAlias(le_uint32 i, LEErrorCode &success) const {
+    return ((const T*)(((const char*)getAlias())+getOffsetFor(i, success)));
+  }
+
+  const T *getAliasTODO() const { LE_DEBUG_TR("getAliasTODO<>"); return (const T*)fStart; }
+
+  const T& getObject(le_uint32 i, LEErrorCode &success) const {
+    return *getAlias(i,success);
+  }
+
+  const T& operator()(le_uint32 i, LEErrorCode &success) const {
+    return *getAlias(i,success);
+  }
+
+  size_t getOffsetFor(le_uint32 i, LEErrorCode &success) const {
+    if(LE_SUCCESS(success)&&i<getCount()) {
+      return LETableVarSizer<T>::getSize()*i;
+    } else {
+      success = LE_INDEX_OUT_OF_BOUNDS_ERROR;
+    }
+    return 0;
+  }
+
+  LEReferenceToArrayOf<T> &reparent(const LETableReference &base) {
+    fParent = &base;
+    return *this;
+  }
+
+ LEReferenceToArrayOf(const LETableReference& parent, LEErrorCode & success) : LETableReference(parent,0, LE_UINTPTR_MAX, success), fCount(0) {
+    LE_TRACE_TR("INFO: null RTAO")
+  }
+
+private:
+  le_uint32 fCount;
+};
+
+
+template<class T>
+class LEReferenceTo : public LETableReference {
+public:
+  /**
+   * open a sub reference.
+   * @param parent parent reference
+   * @param success error status
+   * @param atPtr location of reference - if NULL, will be at offset zero (i.e. downcast of parent). Otherwise must be a pointer within parent's bounds.
+   */
+  LEReferenceTo(const LETableReference &parent, LEErrorCode &success, const void* atPtr)
+    : LETableReference(parent, parent.ptrToOffset(atPtr, success), LE_UINTPTR_MAX, success) {
+    verifyLength(0, LETableVarSizer<T>::getSize(), success);
+    if(LE_FAILURE(success)) clear();
+  }
+  /**
+   * ptr plus offset
+   */
+ LEReferenceTo(const LETableReference &parent, LEErrorCode &success, const void* atPtr, size_t offset)
+    : LETableReference(parent, parent.ptrToOffset(atPtr, success)+offset, LE_UINTPTR_MAX, success) {
+    verifyLength(0, LETableVarSizer<T>::getSize(), success);
+    if(LE_FAILURE(success)) clear();
+  }
+  LEReferenceTo(const LETableReference &parent, LEErrorCode &success, size_t offset)
+    : LETableReference(parent, offset, LE_UINTPTR_MAX, success) {
+    verifyLength(0, LETableVarSizer<T>::getSize(), success);
+    if(LE_FAILURE(success)) clear();
+  }
+  LEReferenceTo(const LETableReference &parent, LEErrorCode &success)
+    : LETableReference(parent, 0, LE_UINTPTR_MAX, success) {
+    verifyLength(0, LETableVarSizer<T>::getSize(), success);
+    if(LE_FAILURE(success)) clear();
+  }
+ LEReferenceTo(const LEFontInstance *font, LETag tableTag, LEErrorCode &success)
+   : LETableReference(font, tableTag, success) {
+    verifyLength(0, LETableVarSizer<T>::getSize(), success);
+    if(LE_FAILURE(success)) clear();
+  }
+ LEReferenceTo(const le_uint8 *data, size_t length = LE_UINTPTR_MAX) : LETableReference(data, length) {}
+ LEReferenceTo(const T *data, size_t length = LE_UINTPTR_MAX) : LETableReference((const le_uint8*)data, length) {}
+  LEReferenceTo() : LETableReference(NULL) {}
+
+  LEReferenceTo<T>& operator=(const T* other) {
+    setRaw(other);
+    return *this;
+  }
+
+  LEReferenceTo<T> &reparent(const LETableReference &base) {
+    fParent = &base;
+    return *this;
+  }
+
+  /**
+   * roll forward by one <T> size.
+   * same as addOffset(LETableVarSizer<T>::getSize(),success)
+   */
+  void addObject(LEErrorCode &success) {
+    addOffset(LETableVarSizer<T>::getSize(), success);
+  }
+  void addObject(size_t count, LEErrorCode &success) {
+    addOffset(LETableVarSizer<T>::getSize()*count, success);
+  }
+
+  const T *operator->() const { return getAlias(); }
+  const T *getAlias() const { return (const T*)fStart; }
+  const T *getAliasTODO() const { LE_DEBUG_TR("getAliasTODO<>"); return (const T*)fStart; }
+};
+
+
+U_NAMESPACE_END
+
+#endif
+
+#endif
--- jdk/src/share/native/sun/font/layout/LETypes.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LETypes.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -50,14 +50,15 @@
 #endif
 
 #include "unicode/utypes.h"
+
+#ifdef __cplusplus
 #include "unicode/uobject.h"
+#endif
+
 #ifdef LE_USE_CMEMORY
 #include "cmemory.h"
 #endif
-#endif /* not standalone */
-
-
-U_NAMESPACE_BEGIN
+#endif
 
 /*!
  * \file
@@ -296,12 +297,14 @@
  */
 typedef UChar32 LEUnicode32;
 
+#ifndef U_HIDE_DEPRECATED_API
 /**
  * Used to represent 16-bit Unicode code points.
  *
  * @deprecated since ICU 2.4. Use LEUnicode16 instead
  */
 typedef UChar LEUnicode;
+#endif  /* U_HIDE_DEPRECATED_API */
 
 /**
  * Used to hold a pair of (x, y) values which represent a point.
@@ -325,7 +328,7 @@
     float fY;
 };
 
-#ifndef XP_CPLUSPLUS
+#ifndef __cplusplus
 /**
  * Used to hold a pair of (x, y) values which represent a point.
  *
@@ -335,6 +338,39 @@
 #endif
 
 
+#ifndef U_HIDE_INTERNAL_API
+
+#ifndef LE_ASSERT_BAD_FONT
+#define LE_ASSERT_BAD_FONT 0
+#endif
+
+#if LE_ASSERT_BAD_FONT
+#include <stdio.h>
+#define LE_DEBUG_BAD_FONT(x) fprintf(stderr,"%s:%d: BAD FONT: %s\n", __FILE__, __LINE__, (x));
+#else
+#define LE_DEBUG_BAD_FONT(x)
+#endif
+
+/**
+ * Max value representable by a uintptr
+ */
+
+#ifndef UINT32_MAX
+#define LE_UINT32_MAX 0xFFFFFFFFU
+#else
+#define LE_UINT32_MAX UINT32_MAX
+#endif
+
+#ifndef UINTPTR_MAX
+#define LE_UINTPTR_MAX LE_UINT32_MAX
+#else
+#define LE_UINTPTR_MAX UINTPTR_MAX
+#endif
+
+/**
+ * Range check for overflow
+ */
+#define LE_RANGE_CHECK(type, count, ptrfn) (( (LE_UINTPTR_MAX / sizeof(type)) < count ) ? NULL : (ptrfn))
 /**
  * A convenience macro to get the length of an array.
  *
@@ -356,7 +392,7 @@
  *
  * @internal
  */
-#define LE_NEW_ARRAY(type, count) (type *) uprv_malloc((count) * sizeof(type))
+#define LE_NEW_ARRAY(type, count) (type *)  LE_RANGE_CHECK(type,count,uprv_malloc((count) * sizeof(type)))
 
 /**
  * Re-allocate an array of basic types. This is used to isolate the rest of
@@ -373,7 +409,52 @@
  * @internal
  */
 #define LE_DELETE_ARRAY(array) uprv_free((void *) (array))
-#endif
+#else
+/* !LE_USE_CMEMORY - Not using ICU memory - use C std lib versions */
+
+#include <stdlib.h>
+#include <string.h>
+
+/**
+ * A convenience macro to get the length of an array.
+ *
+ * @internal
+ */
+#define LE_ARRAY_SIZE(array) (sizeof array / sizeof array[0])
+
+/**
+ * A convenience macro for copying an array.
+ *
+ * @internal
+ */
+#define LE_ARRAY_COPY(dst, src, count) memcpy((void *) (dst), (void *) (src), (count) * sizeof (src)[0])
+
+/**
+ * Allocate an array of basic types. This is used to isolate the rest of
+ * the LayoutEngine code from cmemory.h.
+ *
+ * @internal
+ */
+#define LE_NEW_ARRAY(type, count) LE_RANGE_CHECK(type,count,(type *) malloc((count) * sizeof(type)))
+
+/**
+ * Re-allocate an array of basic types. This is used to isolate the rest of
+ * the LayoutEngine code from cmemory.h.
+ *
+ * @internal
+ */
+#define LE_GROW_ARRAY(array, newSize) realloc((void *) (array), (newSize) * sizeof (array)[0])
+
+ /**
+ * Free an array of basic types. This is used to isolate the rest of
+ * the LayoutEngine code from cmemory.h.
+ *
+ * @internal
+ */
+#define LE_DELETE_ARRAY(array) free((void *) (array))
+
+#endif  /* LE_USE_CMEMORY */
+#endif  /* U_HIDE_INTERNAL_API */
 
 /**
  * A macro to construct the four-letter tags used to
@@ -536,7 +617,7 @@
     LE_RAND_FEATURE_TAG = 0x72616E64UL, /**< 'rand' */
     LE_RLIG_FEATURE_TAG = 0x726C6967UL, /**< 'rlig' */
     LE_RPHF_FEATURE_TAG = 0x72706866UL, /**< 'rphf' */
-        LE_RKRF_FEATURE_TAG = 0x726B7266UL, /**< 'rkrf' */
+    LE_RKRF_FEATURE_TAG = 0x726B7266UL, /**< 'rkrf' */
     LE_RTBD_FEATURE_TAG = 0x72746264UL, /**< 'rtbd' */
     LE_RTLA_FEATURE_TAG = 0x72746C61UL, /**< 'rtla' */
     LE_RUBY_FEATURE_TAG = 0x72756279UL, /**< 'ruby' */
@@ -588,6 +669,68 @@
 };
 
 /**
+ * @internal
+ */
+enum LEFeatureENUMs {
+  LE_Kerning_FEATURE_ENUM = 0,   /**< Requests Kerning. Formerly LayoutEngine::kTypoFlagKern */
+  LE_Ligatures_FEATURE_ENUM = 1, /**< Requests Ligatures. Formerly LayoutEngine::kTypoFlagLiga */
+  LE_NoCanon_FEATURE_ENUM = 2, /**< Requests No Canonical Processing */
+  LE_CLIG_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_DLIG_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_HLIG_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_LIGA_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_RLIG_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SMCP_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_FRAC_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_AFRC_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_ZERO_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SWSH_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_CSWH_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SALT_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_NALT_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_RUBY_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS01_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS02_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS03_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS04_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS05_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS06_FEATURE_ENUM,  /**< Feature specific enum */
+  LE_SS07_FEATURE_ENUM,   /**< Feature specific enum */
+
+  LE_CHAR_FILTER_FEATURE_ENUM = 31, /**< Apply CharSubstitutionFilter */
+  LE_FEATURE_ENUM_MAX = LE_CHAR_FILTER_FEATURE_ENUM
+};
+
+#define LE_Kerning_FEATURE_FLAG   (1 << LE_Kerning_FEATURE_ENUM)
+#define LE_Ligatures_FEATURE_FLAG (1 << LE_Ligatures_FEATURE_ENUM)
+#define LE_NoCanon_FEATURE_FLAG (1 << LE_NoCanon_FEATURE_ENUM)
+#define LE_CLIG_FEATURE_FLAG (1 << LE_CLIG_FEATURE_ENUM)
+#define LE_DLIG_FEATURE_FLAG (1 << LE_DLIG_FEATURE_ENUM)
+#define LE_HLIG_FEATURE_FLAG (1 << LE_HLIG_FEATURE_ENUM)
+#define LE_LIGA_FEATURE_FLAG (1 << LE_LIGA_FEATURE_ENUM)
+#define LE_RLIG_FEATURE_FLAG (1 << LE_RLIG_FEATURE_ENUM)
+#define LE_SMCP_FEATURE_FLAG (1 << LE_SMCP_FEATURE_ENUM)
+#define LE_FRAC_FEATURE_FLAG (1 << LE_FRAC_FEATURE_ENUM)
+#define LE_AFRC_FEATURE_FLAG (1 << LE_AFRC_FEATURE_ENUM)
+#define LE_ZERO_FEATURE_FLAG (1 << LE_ZERO_FEATURE_ENUM)
+#define LE_SWSH_FEATURE_FLAG (1 << LE_SWSH_FEATURE_ENUM)
+#define LE_CSWH_FEATURE_FLAG (1 << LE_CSWH_FEATURE_ENUM)
+#define LE_SALT_FEATURE_FLAG (1 << LE_SALT_FEATURE_ENUM)
+#define LE_NALT_FEATURE_FLAG (1 << LE_NALT_FEATURE_ENUM)
+#define LE_RUBY_FEATURE_FLAG (1 << LE_RUBY_FEATURE_ENUM)
+#define LE_SS01_FEATURE_FLAG (1 << LE_SS01_FEATURE_ENUM)
+#define LE_SS02_FEATURE_FLAG (1 << LE_SS02_FEATURE_ENUM)
+#define LE_SS03_FEATURE_FLAG (1 << LE_SS03_FEATURE_ENUM)
+#define LE_SS04_FEATURE_FLAG (1 << LE_SS04_FEATURE_ENUM)
+#define LE_SS05_FEATURE_FLAG (1 << LE_SS05_FEATURE_ENUM)
+#define LE_SS06_FEATURE_FLAG (1 << LE_SS06_FEATURE_ENUM)
+#define LE_SS07_FEATURE_FLAG (1 << LE_SS07_FEATURE_ENUM)
+
+#define LE_CHAR_FILTER_FEATURE_FLAG (1 << LE_CHAR_FILTER_FEATURE_ENUM)
+
+#define LE_DEFAULT_FEATURE_FLAG (LE_Kerning_FEATURE_FLAG | LE_Ligatures_FEATURE_FLAG) /**< default features */
+
+/**
  * Error codes returned by the LayoutEngine.
  *
  * @stable ICU 2.4
@@ -611,7 +754,7 @@
 };
 #endif
 
-#ifndef XP_CPLUSPLUS
+#ifndef __cplusplus
 /**
  * Error codes returned by the LayoutEngine.
  *
@@ -638,7 +781,4 @@
 #define LE_FAILURE(code) (U_FAILURE((UErrorCode)code))
 #endif
 
-U_NAMESPACE_END
-#endif
-
-
+#endif /* __LETYPES_H */
--- jdk/src/share/native/sun/font/layout/LayoutEngine.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -33,6 +33,7 @@
 #include "LETypes.h"
 #include "LEScripts.h"
 #include "LELanguages.h"
+#include "LESwaps.h"
 
 #include "LayoutEngine.h"
 #include "ArabicLayoutEngine.h"
@@ -44,6 +45,8 @@
 #include "ThaiLayoutEngine.h"
 #include "TibetanLayoutEngine.h"
 #include "GXLayoutEngine.h"
+#include "GXLayoutEngine2.h"
+
 #include "ScriptAndLanguageTags.h"
 #include "CharSubstitutionFilter.h"
 
@@ -63,6 +66,10 @@
 /* Leave this copyright notice here! It needs to go somewhere in this library. */
 static const char copyright[] = U_COPYRIGHT_STRING;
 
+/* TODO: remove these? */
+const le_int32 LayoutEngine::kTypoFlagKern = LE_Kerning_FEATURE_FLAG;
+const le_int32 LayoutEngine::kTypoFlagLiga = LE_Ligatures_FEATURE_FLAG;
+
 const LEUnicode32 DefaultCharMapper::controlChars[] = {
     0x0009, 0x000A, 0x000D,
     /*0x200C, 0x200D,*/ 0x200E, 0x200F,
@@ -140,21 +147,21 @@
 class CanonMarkFilter : public UMemory, public LEGlyphFilter
 {
 private:
-    const GlyphClassDefinitionTable *classDefTable;
+  const LEReferenceTo<GlyphClassDefinitionTable> classDefTable;
 
     CanonMarkFilter(const CanonMarkFilter &other); // forbid copying of this class
     CanonMarkFilter &operator=(const CanonMarkFilter &other); // forbid copying of this class
 
 public:
-    CanonMarkFilter(const GlyphDefinitionTableHeader *gdefTable);
+    CanonMarkFilter(const LEReferenceTo<GlyphDefinitionTableHeader> &gdefTable, LEErrorCode &success);
     virtual ~CanonMarkFilter();
 
     virtual le_bool accept(LEGlyphID glyph) const;
 };
 
-CanonMarkFilter::CanonMarkFilter(const GlyphDefinitionTableHeader *gdefTable)
+CanonMarkFilter::CanonMarkFilter(const LEReferenceTo<GlyphDefinitionTableHeader> &gdefTable, LEErrorCode &success)
+  : classDefTable(gdefTable->getMarkAttachClassDefinitionTable(gdefTable, success))
 {
-    classDefTable = gdefTable->getMarkAttachClassDefinitionTable();
 }
 
 CanonMarkFilter::~CanonMarkFilter()
@@ -164,9 +171,10 @@
 
 le_bool CanonMarkFilter::accept(LEGlyphID glyph) const
 {
-    le_int32 glyphClass = classDefTable->getGlyphClass(glyph);
-
-    return glyphClass != 0;
+  LEErrorCode success = LE_NO_ERROR;
+  le_int32 glyphClass = classDefTable->getGlyphClass(classDefTable, glyph, success);
+  if(LE_FAILURE(success)) return false;
+  return glyphClass != 0;
 }
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LayoutEngine)
@@ -251,24 +259,24 @@
         return 0;
     }
 
-    if ((fTypoFlags & 0x4) == 0) { // no canonical processing
+    if ((fTypoFlags & LE_NoCanon_FEATURE_FLAG) == 0) { // no canonical processing
       return count;
     }
 
-    const GlyphSubstitutionTableHeader *canonGSUBTable = (GlyphSubstitutionTableHeader *) CanonShaping::glyphSubstitutionTable;
+    LEReferenceTo<GlyphSubstitutionTableHeader> canonGSUBTable((GlyphSubstitutionTableHeader *) CanonShaping::glyphSubstitutionTable);
     LETag scriptTag  = OpenTypeLayoutEngine::getScriptTag(fScriptCode);
     LETag langSysTag = OpenTypeLayoutEngine::getLangSysTag(fLanguageCode);
     le_int32 i, dir = 1, out = 0, outCharCount = count;
 
-    if (canonGSUBTable->coversScript(scriptTag)) {
+    if (canonGSUBTable->coversScript(canonGSUBTable,scriptTag, success) || LE_SUCCESS(success)) {
         CharSubstitutionFilter *substitutionFilter = new CharSubstitutionFilter(fFontInstance);
         if (substitutionFilter == NULL) {
             success = LE_MEMORY_ALLOCATION_ERROR;
             return 0;
         }
 
-                const LEUnicode *inChars = &chars[offset];
-                LEUnicode *reordered = NULL;
+        const LEUnicode *inChars = &chars[offset];
+        LEUnicode *reordered = NULL;
         LEGlyphStorage fakeGlyphStorage;
 
         fakeGlyphStorage.allocateGlyphArray(count, rightToLeft, success);
@@ -278,20 +286,20 @@
             return 0;
         }
 
-                // This is the cheapest way to get mark reordering only for Hebrew.
-                // We could just do the mark reordering for all scripts, but most
-                // of them probably don't need it...
-                if (fScriptCode == hebrScriptCode) {
-                        reordered = LE_NEW_ARRAY(LEUnicode, count);
-
-                        if (reordered == NULL) {
-                delete substitutionFilter;
-                                success = LE_MEMORY_ALLOCATION_ERROR;
-                                return 0;
-                        }
+        // This is the cheapest way to get mark reordering only for Hebrew.
+        // We could just do the mark reordering for all scripts, but most
+        // of them probably don't need it...
+        if (fScriptCode == hebrScriptCode) {
+          reordered = LE_NEW_ARRAY(LEUnicode, count);
 
-                        CanonShaping::reorderMarks(&chars[offset], count, rightToLeft, reordered, fakeGlyphStorage);
-                        inChars = reordered;
+          if (reordered == NULL) {
+            delete substitutionFilter;
+            success = LE_MEMORY_ALLOCATION_ERROR;
+            return 0;
+          }
+
+          CanonShaping::reorderMarks(&chars[offset], count, rightToLeft, reordered, fakeGlyphStorage);
+          inChars = reordered;
                 }
 
         fakeGlyphStorage.allocateAuxData(success);
@@ -311,11 +319,11 @@
             fakeGlyphStorage.setAuxData(out, canonFeatures, success);
         }
 
-                if (reordered != NULL) {
-                        LE_DELETE_ARRAY(reordered);
-                }
+        if (reordered != NULL) {
+          LE_DELETE_ARRAY(reordered);
+        }
 
-        outCharCount = canonGSUBTable->process(fakeGlyphStorage, rightToLeft, scriptTag, langSysTag, NULL, substitutionFilter, canonFeatureMap, canonFeatureMapCount, FALSE, success);
+        outCharCount = canonGSUBTable->process(canonGSUBTable, fakeGlyphStorage, rightToLeft, scriptTag, langSysTag, (const GlyphDefinitionTableHeader*)NULL, substitutionFilter, canonFeatureMap, canonFeatureMapCount, FALSE, success);
 
         if (LE_FAILURE(success)) {
             delete substitutionFilter;
@@ -416,16 +424,16 @@
         return;
     }
 
-    GlyphDefinitionTableHeader *gdefTable = (GlyphDefinitionTableHeader *) CanonShaping::glyphDefinitionTable;
-    CanonMarkFilter filter(gdefTable);
+    LEReferenceTo<GlyphDefinitionTableHeader> gdefTable((GlyphDefinitionTableHeader *) CanonShaping::glyphDefinitionTable,
+                                                        CanonShaping::glyphDefinitionTableLen);
+    CanonMarkFilter filter(gdefTable, success);
 
     adjustMarkGlyphs(&chars[offset], count, reverse, glyphStorage, &filter, success);
 
-    if (fTypoFlags & 0x1) { /* kerning enabled */
-      static const le_uint32 kernTableTag = LE_KERN_TABLE_TAG;
-
-      KernTable kt(fFontInstance, getFontTable(kernTableTag));
-      kt.process(glyphStorage);
+    if (fTypoFlags & LE_Kerning_FEATURE_FLAG) { /* kerning enabled */
+      LETableReference kernTable(fFontInstance, LE_KERN_TABLE_TAG, success);
+      KernTable kt(kernTable, success);
+      kt.process(glyphStorage, success);
     }
 
     // default is no adjustments
@@ -510,9 +518,9 @@
     glyphStorage.adjustPosition(glyphCount, xAdjust, 0, success);
 }
 
-const void *LayoutEngine::getFontTable(LETag tableTag) const
+const void *LayoutEngine::getFontTable(LETag tableTag, size_t &length) const
 {
-    return fFontInstance->getFontTable(tableTag);
+  return fFontInstance->getFontTable(tableTag, length);
 }
 
 void LayoutEngine::mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, le_bool mirror,
@@ -559,37 +567,41 @@
 
 void LayoutEngine::reset()
 {
+  if(fGlyphStorage!=NULL) {
     fGlyphStorage->reset();
+    fGlyphStorage = NULL;
+  }
 }
 
 LayoutEngine *LayoutEngine::layoutEngineFactory(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, LEErrorCode &success)
 {
-  // 3 -> kerning and ligatures
-  return LayoutEngine::layoutEngineFactory(fontInstance, scriptCode, languageCode, 3, success);
+  //kerning and ligatures - by default
+  return LayoutEngine::layoutEngineFactory(fontInstance, scriptCode, languageCode, LE_DEFAULT_FEATURE_FLAG, success);
 }
 
 LayoutEngine *LayoutEngine::layoutEngineFactory(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags, LEErrorCode &success)
 {
     static const le_uint32 gsubTableTag = LE_GSUB_TABLE_TAG;
     static const le_uint32 mortTableTag = LE_MORT_TABLE_TAG;
+    static const le_uint32 morxTableTag = LE_MORX_TABLE_TAG;
 
     if (LE_FAILURE(success)) {
         return NULL;
     }
 
-    const GlyphSubstitutionTableHeader *gsubTable = (const GlyphSubstitutionTableHeader *) fontInstance->getFontTable(gsubTableTag);
+    LEReferenceTo<GlyphSubstitutionTableHeader> gsubTable(fontInstance,gsubTableTag,success);
     LayoutEngine *result = NULL;
     LETag scriptTag   = 0x00000000;
     LETag languageTag = 0x00000000;
-        LETag v2ScriptTag = OpenTypeLayoutEngine::getV2ScriptTag(scriptCode);
+    LETag v2ScriptTag = OpenTypeLayoutEngine::getV2ScriptTag(scriptCode);
 
     // Right now, only invoke V2 processing for Devanagari.  TODO: Allow more V2 scripts as they are
     // properly tested.
 
-        if ( v2ScriptTag == dev2ScriptTag && gsubTable != NULL && gsubTable->coversScript( v2ScriptTag )) {
-                result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, TRUE, gsubTable, success);
-        }
-    else if (gsubTable != NULL && gsubTable->coversScript(scriptTag = OpenTypeLayoutEngine::getScriptTag(scriptCode))) {
+    if ( v2ScriptTag == dev2ScriptTag && gsubTable.isValid() && gsubTable->coversScript(gsubTable, v2ScriptTag, success )) {
+      result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, TRUE, gsubTable, success);
+    }
+    else if (gsubTable.isValid() && gsubTable->coversScript(gsubTable, scriptTag = OpenTypeLayoutEngine::getScriptTag(scriptCode), success)) {
         switch (scriptCode) {
         case bengScriptCode:
         case devaScriptCode:
@@ -608,6 +620,11 @@
             result = new ArabicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success);
             break;
 
+        case hebrScriptCode:
+            // Disable hebrew ligatures since they have only archaic uses, see ticket #8318
+            result = new OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags & ~kTypoFlagLiga, gsubTable, success);
+            break;
+
         case hangScriptCode:
             result = new HangulOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success);
             break;
@@ -620,10 +637,10 @@
             case janLanguageCode:
             case zhtLanguageCode:
             case zhsLanguageCode:
-                if (gsubTable->coversScriptAndLanguage(scriptTag, languageTag, TRUE)) {
+              if (gsubTable->coversScriptAndLanguage(gsubTable, scriptTag, languageTag, success, TRUE)) {
                     result = new HanOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success);
                     break;
-                }
+              }
 
                 // note: falling through to default case.
             default:
@@ -646,26 +663,29 @@
             break;
         }
     } else {
-        const MorphTableHeader *morphTable = (MorphTableHeader *) fontInstance->getFontTable(mortTableTag);
-
-        if (morphTable != NULL) {
-            result = new GXLayoutEngine(fontInstance, scriptCode, languageCode, morphTable, success);
+        MorphTableHeader2 *morxTable = (MorphTableHeader2 *)fontInstance->getFontTable(morxTableTag);
+        if (morxTable != NULL && SWAPL(morxTable->version)==0x00020000) {
+            result = new GXLayoutEngine2(fontInstance, scriptCode, languageCode, morxTable, typoFlags, success);
         } else {
-            switch (scriptCode) {
-            case bengScriptCode:
-            case devaScriptCode:
-            case gujrScriptCode:
-            case kndaScriptCode:
-            case mlymScriptCode:
-            case oryaScriptCode:
-            case guruScriptCode:
-            case tamlScriptCode:
-            case teluScriptCode:
-            case sinhScriptCode:
-            {
-                result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success);
-                break;
-            }
+          LEReferenceTo<MorphTableHeader> mortTable(fontInstance, mortTableTag, success);
+          if (LE_SUCCESS(success) && mortTable.isValid() && SWAPL(mortTable->version)==0x00010000) { // mort
+            result = new GXLayoutEngine(fontInstance, scriptCode, languageCode, mortTable, success);
+            } else {
+                switch (scriptCode) {
+                    case bengScriptCode:
+                    case devaScriptCode:
+                    case gujrScriptCode:
+                    case kndaScriptCode:
+                    case mlymScriptCode:
+                    case oryaScriptCode:
+                    case guruScriptCode:
+                    case tamlScriptCode:
+                    case teluScriptCode:
+                    case sinhScriptCode:
+                    {
+                        result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success);
+                        break;
+                    }
 
             case arabScriptCode:
             //case hebrScriptCode:
@@ -683,9 +703,10 @@
                 result = new HangulOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success);
                 break;
 
-            default:
-                result = new LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success);
-                break;
+                    default:
+                        result = new LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success);
+                        break;
+                }
             }
         }
     }
--- jdk/src/share/native/sun/font/layout/LayoutEngine.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -26,7 +26,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2008 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -90,6 +90,14 @@
  * @stable ICU 2.8
  */
 class U_LAYOUT_API LayoutEngine : public UObject {
+public:
+#ifndef U_HIDE_INTERNAL_API
+    /** @internal Flag to request kerning. Use LE_Kerning_FEATURE_FLAG instead. */
+    static const le_int32 kTypoFlagKern;
+    /** @internal Flag to request ligatures. Use LE_Ligatures_FEATURE_FLAG instead. */
+    static const le_int32 kTypoFlagLiga;
+#endif  /* U_HIDE_INTERNAL_API */
+
 protected:
     /**
      * The object which holds the glyph storage
@@ -140,6 +148,7 @@
      */
     le_bool fFilterZeroWidth;
 
+#ifndef U_HIDE_INTERNAL_API
     /**
      * This constructs an instance for a given font, script and language. Subclass constructors
      * must call this constructor.
@@ -161,7 +170,10 @@
                  le_int32 languageCode,
                  le_int32 typoFlags,
                  LEErrorCode &success);
+#endif  /* U_HIDE_INTERNAL_API */
 
+    // Do not enclose the protected default constructor with #ifndef U_HIDE_INTERNAL_API
+    // or else the compiler will create a public default constructor.
     /**
      * This overrides the default no argument constructor to make it
      * difficult for clients to call it. Clients are expected to call
@@ -268,12 +280,18 @@
      * some other way must override this method.
      *
      * @param tableTag - the four byte table tag.
+     * @param length - length to use
      *
      * @return the address of the table.
      *
      * @internal
      */
-    virtual const void *getFontTable(LETag tableTag) const;
+    virtual const void *getFontTable(LETag tableTag, size_t &length) const;
+
+    /**
+     * @deprecated
+     */
+    virtual const void *getFontTable(LETag tableTag) const { size_t ignored; return getFontTable(tableTag, ignored); }
 
     /**
      * This method does character to glyph mapping. The default implementation
@@ -302,6 +320,7 @@
      */
     virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, le_bool mirror, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
+#ifndef U_HIDE_INTERNAL_API
     /**
      * This is a convenience method that forces the advance width of mark
      * glyphs to be zero, which is required for proper selection and highlighting.
@@ -336,7 +355,7 @@
      * @internal
      */
     static void adjustMarkGlyphs(const LEUnicode chars[], le_int32 charCount, le_bool reverse, LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter, LEErrorCode &success);
-
+#endif  /* U_HIDE_INTERNAL_API */
 
 public:
     /**
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -47,15 +47,15 @@
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LigatureSubstitutionProcessor)
 
-LigatureSubstitutionProcessor::LigatureSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : StateTableProcessor(morphSubtableHeader)
+  LigatureSubstitutionProcessor::LigatureSubstitutionProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+: StateTableProcessor(morphSubtableHeader, success), ligatureSubstitutionHeader(morphSubtableHeader, success)
 {
-    ligatureSubstitutionHeader = (const LigatureSubstitutionHeader *) morphSubtableHeader;
+    if(LE_FAILURE(success)) return;
     ligatureActionTableOffset = SWAPW(ligatureSubstitutionHeader->ligatureActionTableOffset);
     componentTableOffset = SWAPW(ligatureSubstitutionHeader->componentTableOffset);
     ligatureTableOffset = SWAPW(ligatureSubstitutionHeader->ligatureTableOffset);
 
-    entryTable = (const LigatureSubstitutionStateEntry *) ((char *) &stateTableHeader->stHeader + entryTableOffset);
+    entryTable = LEReferenceToArrayOf<LigatureSubstitutionStateEntry>(stHeader, success, entryTableOffset, LE_UNBOUNDED_ARRAY);
 }
 
 LigatureSubstitutionProcessor::~LigatureSubstitutionProcessor()
@@ -69,7 +69,9 @@
 
 ByteOffset LigatureSubstitutionProcessor::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex index)
 {
-    const LigatureSubstitutionStateEntry *entry = &entryTable[index];
+  LEErrorCode success = LE_NO_ERROR;
+  const LigatureSubstitutionStateEntry *entry = entryTable.getAlias(index, success);
+
     ByteOffset newState = SWAPW(entry->newStateOffset);
     le_int16 flags = SWAPW(entry->flags);
 
@@ -79,12 +81,16 @@
         }
 
         componentStack[m] = currGlyph;
+    } else if ( m == -1) {
+        // bad font- skip this glyph.
+        currGlyph++;
+        return newState;
     }
 
     ByteOffset actionOffset = flags & lsfActionOffsetMask;
 
     if (actionOffset != 0) {
-        const LigatureActionEntry *ap = (const LigatureActionEntry *) ((char *) &ligatureSubstitutionHeader->stHeader + actionOffset);
+      LEReferenceTo<LigatureActionEntry> ap(stHeader, success, actionOffset);
         LigatureActionEntry action;
         le_int32 offset, i = 0;
         le_int32 stack[nComponents];
@@ -93,7 +99,8 @@
         do {
             le_uint32 componentGlyph = componentStack[m--];
 
-            action = SWAPL(*ap++);
+            action = SWAPL(*ap.getAlias());
+            ap.addObject(success); // ap++
 
             if (m < 0) {
                 m = nComponents - 1;
@@ -101,29 +108,48 @@
 
             offset = action & lafComponentOffsetMask;
             if (offset != 0) {
-                const le_int16 *offsetTable = (const le_int16 *)((char *) &ligatureSubstitutionHeader->stHeader + 2 * SignExtend(offset, lafComponentOffsetMask));
+              LEReferenceToArrayOf<le_int16> offsetTable(stHeader, success, 2 * SignExtend(offset, lafComponentOffsetMask), LE_UNBOUNDED_ARRAY);
 
-                i += SWAPW(offsetTable[LE_GET_GLYPH(glyphStorage[componentGlyph])]);
+              if(LE_FAILURE(success)) {
+                  currGlyph++;
+                  LE_DEBUG_BAD_FONT("off end of ligature substitution header");
+                  return newState; // get out! bad font
+              }
+              if(componentGlyph > glyphStorage.getGlyphCount()) {
+                LE_DEBUG_BAD_FONT("preposterous componentGlyph");
+                currGlyph++;
+                return newState; // get out! bad font
+              }
+              i += SWAPW(offsetTable.getObject(LE_GET_GLYPH(glyphStorage[componentGlyph]), success));
 
                 if (action & (lafLast | lafStore))  {
-                    const TTGlyphID *ligatureOffset = (const TTGlyphID *) ((char *) &ligatureSubstitutionHeader->stHeader + i);
-                    TTGlyphID ligatureGlyph = SWAPW(*ligatureOffset);
+                  LEReferenceTo<TTGlyphID> ligatureOffset(stHeader, success, i);
+                  TTGlyphID ligatureGlyph = SWAPW(*ligatureOffset.getAlias());
 
-                    glyphStorage[componentGlyph] = LE_SET_GLYPH(glyphStorage[componentGlyph], ligatureGlyph);
-                    stack[++mm] = componentGlyph;
-                    i = 0;
+                  glyphStorage[componentGlyph] = LE_SET_GLYPH(glyphStorage[componentGlyph], ligatureGlyph);
+                  if(mm==nComponents) {
+                    LE_DEBUG_BAD_FONT("exceeded nComponents");
+                    mm--; // don't overrun the stack.
+                  }
+                  stack[++mm] = componentGlyph;
+                  i = 0;
                 } else {
-                    glyphStorage[componentGlyph] = LE_SET_GLYPH(glyphStorage[componentGlyph], 0xFFFF);
+                  glyphStorage[componentGlyph] = LE_SET_GLYPH(glyphStorage[componentGlyph], 0xFFFF);
                 }
             }
-        } while (!(action & lafLast));
+#if LE_ASSERT_BAD_FONT
+            if(m<0) {
+              LE_DEBUG_BAD_FONT("m<0")
+            }
+#endif
+        } while (!(action & lafLast)  && (m>=0) ); // stop if last bit is set, or if run out of items
 
         while (mm >= 0) {
-            if (++m >= nComponents) {
-                m = 0;
-            }
+          if (++m >= nComponents) {
+            m = 0;
+          }
 
-            componentStack[m] = stack[mm--];
+          componentStack[m] = stack[mm--];
         }
     }
 
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc.h	2013-05-05 09:38:38.000000000 -0700
@@ -58,7 +58,7 @@
 
     virtual void endStateTable();
 
-    LigatureSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    LigatureSubstitutionProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
     virtual ~LigatureSubstitutionProcessor();
 
     /**
@@ -83,12 +83,12 @@
     ByteOffset componentTableOffset;
     ByteOffset ligatureTableOffset;
 
-    const LigatureSubstitutionStateEntry *entryTable;
+    LEReferenceToArrayOf<LigatureSubstitutionStateEntry> entryTable;
 
     le_int32 componentStack[nComponents];
     le_int16 m;
 
-    const LigatureSubstitutionHeader *ligatureSubstitutionHeader;
+    LEReferenceTo<LigatureSubstitutionHeader> ligatureSubstitutionHeader;
 
 };
 
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,170 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp and Others. 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "StateTables.h"
+#include "MorphStateTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "LigatureSubstProc2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+#define ExtendedComplement(m) ((le_int32) (~((le_uint32) (m))))
+#define SignBit(m) ((ExtendedComplement(m) >> 1) & (le_int32)(m))
+#define SignExtend(v,m) (((v) & SignBit(m))? ((v) | ExtendedComplement(m)): (v))
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LigatureSubstitutionProcessor2)
+
+LigatureSubstitutionProcessor2::LigatureSubstitutionProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : StateTableProcessor2(morphSubtableHeader, success),
+  ligActionOffset(0),
+  ligatureSubstitutionHeader(morphSubtableHeader, success), componentOffset(0), ligatureOffset(0), entryTable()
+{
+    if (LE_FAILURE(success)) return;
+
+    ligActionOffset = SWAPL(ligatureSubstitutionHeader->ligActionOffset);
+    componentOffset = SWAPL(ligatureSubstitutionHeader->componentOffset);
+    ligatureOffset = SWAPL(ligatureSubstitutionHeader->ligatureOffset);
+
+    entryTable = LEReferenceToArrayOf<LigatureSubstitutionStateEntry2>(stHeader, success, entryTableOffset, LE_UNBOUNDED_ARRAY);
+}
+
+LigatureSubstitutionProcessor2::~LigatureSubstitutionProcessor2()
+{
+}
+
+void LigatureSubstitutionProcessor2::beginStateTable()
+{
+    m = -1;
+}
+
+le_uint16 LigatureSubstitutionProcessor2::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex2 index, LEErrorCode &success)
+{
+    const LigatureSubstitutionStateEntry2 *entry = entryTable.getAlias(index, success);
+    if(LE_FAILURE(success)) return 0;
+
+    le_uint16 nextStateIndex = SWAPW(entry->nextStateIndex);
+    le_uint16 flags = SWAPW(entry->entryFlags);
+    le_uint16 ligActionIndex = SWAPW(entry->ligActionIndex);
+
+    if (flags & lsfSetComponent) {
+        if (++m >= nComponents) {
+            m = 0;
+        }
+        componentStack[m] = currGlyph;
+    } else if ( m == -1) {
+        // bad font- skip this glyph.
+        //LE_DEBUG_BAD_FONT("m==-1 (componentCount went negative)")
+        currGlyph+= dir;
+        return nextStateIndex;
+    }
+
+    ByteOffset actionOffset = flags & lsfPerformAction;
+
+    if (actionOffset != 0) {
+        LEReferenceTo<LigatureActionEntry> ap(stHeader, success, ligActionOffset); // byte offset
+        ap.addObject(ligActionIndex - 1, success);  // index offset ( one before the actual start, because we will pre-increment)
+        LEReferenceToArrayOf<TTGlyphID> ligatureTable(stHeader, success, ligatureOffset, LE_UNBOUNDED_ARRAY);
+        LigatureActionEntry action;
+        le_int32 offset, i = 0;
+        le_int32 stack[nComponents];
+        le_int16 mm = -1;
+
+        LEReferenceToArrayOf<le_uint16> componentTable(stHeader, success, componentOffset, LE_UNBOUNDED_ARRAY);
+        if(LE_FAILURE(success)) {
+          currGlyph+= dir;
+            return nextStateIndex; // get out! bad font
+        }
+
+        do {
+            le_uint32 componentGlyph = componentStack[m--]; // pop off
+
+            ap.addObject(success);
+            action = SWAPL(*ap.getAlias());
+
+            if (m < 0) {
+                m = nComponents - 1;
+            }
+
+            offset = action & lafComponentOffsetMask;
+            if (offset != 0) {
+                if(componentGlyph > glyphStorage.getGlyphCount()) {
+                  LE_DEBUG_BAD_FONT("preposterous componentGlyph");
+                  currGlyph+= dir;
+                  return nextStateIndex; // get out! bad font
+                }
+                i += SWAPW(componentTable(LE_GET_GLYPH(glyphStorage[componentGlyph]) + (SignExtend(offset, lafComponentOffsetMask)),success));
+
+                if (action & (lafLast | lafStore))  {
+                  TTGlyphID ligatureGlyph = SWAPW(ligatureTable(i,success));
+                    glyphStorage[componentGlyph] = LE_SET_GLYPH(glyphStorage[componentGlyph], ligatureGlyph);
+                    if(mm==nComponents) {
+                      LE_DEBUG_BAD_FONT("exceeded nComponents");
+                      mm--; // don't overrun the stack.
+                    }
+                    stack[++mm] = componentGlyph;
+                    i = 0;
+                } else {
+                    glyphStorage[componentGlyph] = LE_SET_GLYPH(glyphStorage[componentGlyph], 0xFFFF);
+                }
+            }
+#if LE_ASSERT_BAD_FONT
+            if(m<0) {
+              LE_DEBUG_BAD_FONT("m<0")
+            }
+#endif
+        } while (!(action & lafLast) && (m>=0) ); // stop if last bit is set, or if run out of items
+
+        while (mm >= 0) {
+            if (++m >= nComponents) {
+                m = 0;
+            }
+
+            componentStack[m] = stack[mm--];
+        }
+    }
+
+    if (!(flags & lsfDontAdvance)) {
+        currGlyph += dir;
+    }
+
+    return nextStateIndex;
+}
+
+void LigatureSubstitutionProcessor2::endStateTable()
+{
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,97 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __LIGATURESUBSTITUTIONPROCESSOR2_H
+#define __LIGATURESUBSTITUTIONPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "LigatureSubstitution.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+#define nComponents 16
+
+class LigatureSubstitutionProcessor2 : public StateTableProcessor2
+{
+public:
+    virtual void beginStateTable();
+
+    virtual le_uint16 processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph,
+                                        EntryTableIndex2 index, LEErrorCode &success);
+
+    virtual void endStateTable();
+
+    LigatureSubstitutionProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+    virtual ~LigatureSubstitutionProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    LigatureSubstitutionProcessor2();
+
+protected:
+    le_uint32 ligActionOffset;
+    le_uint32 componentOffset;
+    le_uint32 ligatureOffset;
+
+    LEReferenceToArrayOf<LigatureSubstitutionStateEntry2> entryTable;
+
+    le_int32 componentStack[nComponents];
+    le_int16 m;
+
+    const LEReferenceTo<LigatureSubstitutionHeader2> ligatureSubstitutionHeader;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -40,10 +40,10 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 LigatureSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
+le_uint32 LigatureSubstitutionSubtable::process(const LETableReference &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, glyph, success);
 
     if (coverageIndex >= 0) {
         Offset ligSetTableOffset = SWAPW(ligSetTableOffsetArray[coverageIndex]);
--- jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,6 +50,7 @@
     le_uint16 ligatureCount;
     Offset    ligatureTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LigatureSetTable, ligatureTableOffsetArray)
 
 struct LigatureTable
 {
@@ -57,14 +58,16 @@
     le_uint16 compCount;
     TTGlyphID componentArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LigatureTable, componentArray)
 
 struct LigatureSubstitutionSubtable : GlyphSubstitutionSubtable
 {
     le_uint16 ligSetCount;
     Offset    ligSetTableOffsetArray[ANY_NUMBER];
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
+    le_uint32  process(const LETableReference &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter = NULL) const;
 };
+LE_VAR_ARRAY(LigatureSubstitutionSubtable, ligSetTableOffsetArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/LigatureSubstitution.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LigatureSubstitution.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -52,17 +52,32 @@
     ByteOffset ligatureTableOffset;
 };
 
+struct LigatureSubstitutionHeader2 : MorphStateTableHeader2
+{
+    le_uint32 ligActionOffset;
+    le_uint32 componentOffset;
+    le_uint32 ligatureOffset;
+};
+
 enum LigatureSubstitutionFlags
 {
     lsfSetComponent     = 0x8000,
     lsfDontAdvance      = 0x4000,
-    lsfActionOffsetMask = 0x3FFF
+    lsfActionOffsetMask = 0x3FFF, // N/A in morx
+    lsfPerformAction    = 0x2000
 };
 
 struct LigatureSubstitutionStateEntry : StateEntry
 {
 };
 
+struct LigatureSubstitutionStateEntry2
+{
+    le_uint16 nextStateIndex;
+    le_uint16 entryFlags;
+    le_uint16 ligActionIndex;
+};
+
 typedef le_uint32 LigatureActionEntry;
 
 enum LigatureActionFlags
--- jdk/src/share/native/sun/font/layout/LookupProcessor.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LookupProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -44,7 +44,7 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 LookupProcessor::applyLookupTable(const LookupTable *lookupTable, GlyphIterator *glyphIterator,
+le_uint32 LookupProcessor::applyLookupTable(const LEReferenceTo<LookupTable> &lookupTable, GlyphIterator *glyphIterator,
                                          const LEFontInstance *fontInstance, LEErrorCode& success) const
 {
     if (LE_FAILURE(success)) {
@@ -57,7 +57,7 @@
     le_uint32 delta;
 
     for (le_uint16 subtable = 0; subtable < subtableCount; subtable += 1) {
-        const LookupSubtable *lookupSubtable = lookupTable->getLookupSubtable(subtable);
+      LEReferenceTo<LookupSubtable> lookupSubtable = lookupTable->getLookupSubtable(lookupTable, subtable, success);
 
         delta = applySubtable(lookupSubtable, lookupType, glyphIterator, fontInstance, success);
 
@@ -72,7 +72,7 @@
 }
 
 le_int32 LookupProcessor::process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
-                              le_bool rightToLeft, const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
+                                  le_bool rightToLeft, const LEReferenceTo<GlyphDefinitionTableHeader> &glyphDefinitionTableHeader,
                               const LEFontInstance *fontInstance, LEErrorCode& success) const
 {
     if (LE_FAILURE(success)) {
@@ -89,22 +89,21 @@
                                 rightToLeft, 0, 0, glyphDefinitionTableHeader);
     le_int32 newGlyphCount = glyphCount;
 
-    for (le_uint16 order = 0; order < lookupOrderCount; order += 1) {
+    for (le_uint16 order = 0; order < lookupOrderCount && LE_SUCCESS(success); order += 1) {
         le_uint16 lookup = lookupOrderArray[order];
         FeatureMask selectMask = lookupSelectArray[lookup];
 
         if (selectMask != 0) {
-            const LookupTable *lookupTable = lookupListTable->getLookupTable(lookup);
-
-            if (!lookupTable)
+          const LEReferenceTo<LookupTable> lookupTable = lookupListTable->getLookupTable(lookupListTable, lookup, success);
+          if (!lookupTable.isValid() ||LE_FAILURE(success) ) {
                 continue;
-
+            }
             le_uint16 lookupFlags = SWAPW(lookupTable->lookupFlags);
 
             glyphIterator.reset(lookupFlags, selectMask);
 
             while (glyphIterator.findFeatureTag()) {
-                applyLookupTable(lookupTable, &glyphIterator, fontInstance, success);
+              applyLookupTable(lookupTable, &glyphIterator, fontInstance, success); // TODO
                 if (LE_FAILURE(success)) {
                     return 0;
                 }
@@ -124,7 +123,11 @@
         return 0;
     }
 
-    const LookupTable *lookupTable = lookupListTable->getLookupTable(lookupTableIndex);
+    const LEReferenceTo<LookupTable> lookupTable = lookupListTable->getLookupTable(lookupListTable, lookupTableIndex, success);
+    if (!lookupTable.isValid()) {
+        success = LE_INTERNAL_ERROR;
+        return 0;
+    }
     le_uint16 lookupFlags = SWAPW(lookupTable->lookupFlags);
     GlyphIterator tempIterator(*glyphIterator, lookupFlags);
     le_uint32 delta = applyLookupTable(lookupTable, &tempIterator, fontInstance, success);
@@ -132,33 +135,35 @@
     return delta;
 }
 
-le_int32 LookupProcessor::selectLookups(const FeatureTable *featureTable, FeatureMask featureMask, le_int32 order)
+le_int32 LookupProcessor::selectLookups(const LEReferenceTo<FeatureTable> &featureTable, FeatureMask featureMask, le_int32 order, LEErrorCode &success)
 {
-    le_uint16 lookupCount = featureTable? SWAPW(featureTable->lookupCount) : 0;
+  le_uint16 lookupCount = featureTable.isValid()? SWAPW(featureTable->lookupCount) : 0;
     le_int32  store = order;
 
-    for (le_uint16 lookup = 0; lookup < lookupCount; lookup += 1) {
-        le_uint16 lookupListIndex = SWAPW(featureTable->lookupListIndexArray[lookup]);
+    LEReferenceToArrayOf<le_uint16> lookupListIndexArray(featureTable, success, featureTable->lookupListIndexArray, lookupCount);
 
-        if (lookupListIndex >= lookupSelectCount)
-            continue;
+    for (le_uint16 lookup = 0; LE_SUCCESS(success) && lookup < lookupCount; lookup += 1) {
+      le_uint16 lookupListIndex = SWAPW(lookupListIndexArray.getObject(lookup,success));
+      if (lookupListIndex >= lookupSelectCount) {
+        continue;
+      }
 
-        lookupSelectArray[lookupListIndex] |= featureMask;
-        lookupOrderArray[store++] = lookupListIndex;
+      lookupSelectArray[lookupListIndex] |= featureMask;
+      lookupOrderArray[store++] = lookupListIndex;
     }
 
     return store - order;
 }
 
-LookupProcessor::LookupProcessor(const char *baseAddress,
+LookupProcessor::LookupProcessor(const LETableReference &baseAddress,
         Offset scriptListOffset, Offset featureListOffset, Offset lookupListOffset,
         LETag scriptTag, LETag languageTag, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool orderFeatures,
         LEErrorCode& success)
-    : lookupListTable(NULL), featureListTable(NULL), lookupSelectArray(NULL), lookupSelectCount(0),
-      lookupOrderArray(NULL), lookupOrderCount(0)
+    : lookupListTable(), featureListTable(), lookupSelectArray(NULL), lookupSelectCount(0),
+      lookupOrderArray(NULL), lookupOrderCount(0), fReference(baseAddress)
 {
-    const ScriptListTable *scriptListTable = NULL;
-    const LangSysTable *langSysTable = NULL;
+  LEReferenceTo<ScriptListTable> scriptListTable;
+  LEReferenceTo<LangSysTable> langSysTable;
     le_uint16 featureCount = 0;
     le_uint16 lookupListCount = 0;
     le_uint16 requiredFeatureIndex;
@@ -168,29 +173,33 @@
     }
 
     if (scriptListOffset != 0) {
-        scriptListTable = (const ScriptListTable *) (baseAddress + scriptListOffset);
-        langSysTable = scriptListTable->findLanguage(scriptTag, languageTag);
+      scriptListTable = LEReferenceTo<ScriptListTable>(baseAddress, success, scriptListOffset);
+      langSysTable = scriptListTable->findLanguage(scriptListTable, scriptTag, languageTag, success);
 
-        if (langSysTable != 0) {
-            featureCount = SWAPW(langSysTable->featureCount);
-        }
+      if (langSysTable.isValid() && LE_SUCCESS(success)) {
+        featureCount = SWAPW(langSysTable->featureCount);
+      }
     }
 
     if (featureListOffset != 0) {
-        featureListTable = (const FeatureListTable *) (baseAddress + featureListOffset);
+      featureListTable = LEReferenceTo<FeatureListTable>(baseAddress, success, featureListOffset);
     }
 
     if (lookupListOffset != 0) {
-        lookupListTable = (const LookupListTable *) (baseAddress + lookupListOffset);
+      lookupListTable = LEReferenceTo<LookupListTable>(baseAddress,success, lookupListOffset);
+      if(LE_SUCCESS(success) && lookupListTable.isValid()) {
         lookupListCount = SWAPW(lookupListTable->lookupCount);
+      }
     }
 
-    if (langSysTable == NULL || featureListTable == NULL || lookupListTable == NULL ||
+    if (langSysTable.isEmpty() || featureListTable.isEmpty() || lookupListTable.isEmpty() ||
         featureCount == 0 || lookupListCount == 0) {
         return;
     }
 
-    requiredFeatureIndex = SWAPW(langSysTable->reqFeatureIndex);
+    if(langSysTable.isValid()) {
+      requiredFeatureIndex = SWAPW(langSysTable->reqFeatureIndex);
+    }
 
     lookupSelectArray = LE_NEW_ARRAY(FeatureMask, lookupListCount);
     if (lookupSelectArray == NULL) {
@@ -205,31 +214,39 @@
     lookupSelectCount = lookupListCount;
 
     le_int32 count, order = 0;
-    le_int32 featureReferences = 0;
-    const FeatureTable *featureTable = NULL;
+    le_uint32 featureReferences = 0;
+    LEReferenceTo<FeatureTable> featureTable;
     LETag featureTag;
 
-    const FeatureTable *requiredFeatureTable = NULL;
+    LEReferenceTo<FeatureTable> requiredFeatureTable;
     LETag requiredFeatureTag = 0x00000000U;
 
     // Count the total number of lookups referenced by all features. This will
     // be the maximum number of entries in the lookupOrderArray. We can't use
     // lookupListCount because some lookups might be referenced by more than
     // one feature.
-    for (le_int32 feature = 0; feature < featureCount; feature += 1) {
-        le_uint16 featureIndex = SWAPW(langSysTable->featureIndexArray[feature]);
+    if(featureListTable.isValid() && LE_SUCCESS(success)) {
+      LEReferenceToArrayOf<le_uint16> featureIndexArray(langSysTable, success, langSysTable->featureIndexArray, featureCount);
 
-        featureTable = featureListTable->getFeatureTable(featureIndex, &featureTag);
-
-        if (!featureTable)
-            continue;
+      for (le_uint32 feature = 0; LE_SUCCESS(success)&&(feature < featureCount); feature += 1) {
+        le_uint16 featureIndex = SWAPW(featureIndexArray.getObject(feature, success));
 
+        featureTable = featureListTable->getFeatureTable(featureListTable, featureIndex,  &featureTag, success);
+        if (!featureTable.isValid() || LE_FAILURE(success)) {
+          continue;
+        }
         featureReferences += SWAPW(featureTable->lookupCount);
+      }
+    }
+
+    if (!featureTable.isValid() || LE_FAILURE(success)) {
+        success = LE_INTERNAL_ERROR;
+        return;
     }
 
     if (requiredFeatureIndex != 0xFFFF) {
-        requiredFeatureTable = featureListTable->getFeatureTable(requiredFeatureIndex, &requiredFeatureTag);
-        featureReferences += SWAPW(featureTable->lookupCount);
+      requiredFeatureTable = featureListTable->getFeatureTable(featureListTable, requiredFeatureIndex, &requiredFeatureTag, success);
+      featureReferences += SWAPW(featureTable->lookupCount);
     }
 
     lookupOrderArray = LE_NEW_ARRAY(le_uint16, featureReferences);
@@ -244,7 +261,7 @@
 
         // If this is the required feature, add its lookups
         if (requiredFeatureTag == fm.tag) {
-            count += selectLookups(requiredFeatureTable, fm.mask, order);
+          count += selectLookups(requiredFeatureTable, fm.mask, order, success);
         }
 
         if (orderFeatures) {
@@ -254,7 +271,8 @@
             }
 
             for (le_uint16 feature = 0; feature < featureCount; feature += 1) {
-                le_uint16 featureIndex = SWAPW(langSysTable->featureIndexArray[feature]);
+              LEReferenceToArrayOf<le_uint16> featureIndexArray(langSysTable, success, langSysTable->featureIndexArray, featureCount);
+              le_uint16 featureIndex = SWAPW(featureIndexArray.getObject(feature,success));
 
                 // don't add the required feature to the list more than once...
                 // TODO: Do we need this check? (Spec. says required feature won't be in feature list...)
@@ -262,10 +280,10 @@
                     continue;
                 }
 
-                featureTable = featureListTable->getFeatureTable(featureIndex, &featureTag);
+                featureTable = featureListTable->getFeatureTable(featureListTable, featureIndex, &featureTag, success);
 
                 if (featureTag == fm.tag) {
-                    count += selectLookups(featureTable, fm.mask, order + count);
+                  count += selectLookups(featureTable, fm.mask, order + count, success);
                 }
             }
 
@@ -274,9 +292,10 @@
             }
 
             order += count;
-        } else {
-            for (le_uint16 feature = 0; feature < featureCount; feature += 1) {
-                le_uint16 featureIndex = SWAPW(langSysTable->featureIndexArray[feature]);
+        } else if(langSysTable.isValid()) {
+          LEReferenceToArrayOf<le_uint16> featureIndexArray(langSysTable, success, langSysTable->featureIndexArray, featureCount);
+          for (le_uint16 feature = 0; LE_SUCCESS(success)&& (feature < featureCount); feature += 1) {
+            le_uint16 featureIndex = SWAPW(featureIndexArray.getObject(feature,success));
 
                 // don't add the required feature to the list more than once...
                 // NOTE: This check is commented out because the spec. says that
@@ -288,10 +307,10 @@
                 }
 #endif
 
-                featureTable = featureListTable->getFeatureTable(featureIndex, &featureTag);
+                featureTable = featureListTable->getFeatureTable(featureListTable, featureIndex, &featureTag, success);
 
                 if (featureTag == fm.tag) {
-                    order += selectLookups(featureTable, fm.mask, order);
+                  order += selectLookups(featureTable, fm.mask, order, success);
                 }
             }
         }
--- jdk/src/share/native/sun/font/layout/LookupProcessor.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LookupProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -41,6 +41,7 @@
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
+#include "LETableReference.h"
 //#include "Lookups.h"
 //#include "Features.h"
 
@@ -59,19 +60,21 @@
 class LookupProcessor : public UMemory {
 public:
     le_int32 process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
-                 le_bool rightToLeft, const GlyphDefinitionTableHeader *glyphDefinitionTableHeader, const LEFontInstance *fontInstance, LEErrorCode& success) const;
+                 le_bool rightToLeft, const LEReferenceTo<GlyphDefinitionTableHeader> &glyphDefinitionTableHeader, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 
-    le_uint32 applyLookupTable(const LookupTable *lookupTable, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
+    le_uint32 applyLookupTable(const LEReferenceTo<LookupTable> &lookupTable, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 
     le_uint32 applySingleLookup(le_uint16 lookupTableIndex, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const;
 
-    virtual le_uint32 applySubtable(const LookupSubtable *lookupSubtable, le_uint16 subtableType,
+    virtual le_uint32 applySubtable(const LEReferenceTo<LookupSubtable> &lookupSubtable, le_uint16 subtableType,
         GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode& success) const = 0;
 
     virtual ~LookupProcessor();
 
+    const LETableReference &getReference() const { return fReference; }
+
 protected:
-     LookupProcessor(const char *baseAddress,
+    LookupProcessor(const LETableReference &baseAddress,
         Offset scriptListOffset,
         Offset featureListOffset,
         Offset lookupListOffset,
@@ -84,10 +87,10 @@
 
    LookupProcessor();
 
-    le_int32 selectLookups(const FeatureTable *featureTable, FeatureMask featureMask, le_int32 order);
+    le_int32 selectLookups(const LEReferenceTo<FeatureTable> &featureTable, FeatureMask featureMask, le_int32 order, LEErrorCode &success);
 
-    const LookupListTable   *lookupListTable;
-    const FeatureListTable  *featureListTable;
+    LEReferenceTo<LookupListTable>   lookupListTable;
+    LEReferenceTo<FeatureListTable>  featureListTable;
 
     FeatureMask            *lookupSelectArray;
     le_uint32              lookupSelectCount;
@@ -95,6 +98,8 @@
     le_uint16               *lookupOrderArray;
     le_uint32               lookupOrderCount;
 
+    LETableReference        fReference;
+
 private:
 
     LookupProcessor(const LookupProcessor &other); // forbid copying of this class
--- jdk/src/share/native/sun/font/layout/LookupTables.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LookupTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -49,22 +49,26 @@
     of the derived classes, and implement it in the others by casting
     the "this" pointer to the type that has the implementation.
 */
-const LookupSegment *BinarySearchLookupTable::lookupSegment(const LookupSegment *segments, LEGlyphID glyph) const
+const LookupSegment *BinarySearchLookupTable::lookupSegment(const LETableReference &base, const LookupSegment *segments, LEGlyphID glyph, LEErrorCode &success) const
 {
+
     le_int16  unity = SWAPW(unitSize);
     le_int16  probe = SWAPW(searchRange);
     le_int16  extra = SWAPW(rangeShift);
     TTGlyphID ttGlyph = (TTGlyphID) LE_GET_GLYPH(glyph);
-    const LookupSegment *entry = segments;
-    const LookupSegment *trial = (const LookupSegment *) ((char *) entry + extra);
+    LEReferenceTo<LookupSegment> entry(base, success, segments);
+    LEReferenceTo<LookupSegment> trial(entry, success, extra);
+
+    if(LE_FAILURE(success)) return NULL;
 
     if (SWAPW(trial->lastGlyph) <= ttGlyph) {
         entry = trial;
     }
 
-    while (probe > unity) {
+    while (probe > unity && LE_SUCCESS(success)) {
         probe >>= 1;
-        trial = (const LookupSegment *) ((char *) entry + probe);
+        trial = entry; // copy
+        trial.addOffset(probe, success);
 
         if (SWAPW(trial->lastGlyph) <= ttGlyph) {
             entry = trial;
@@ -72,28 +76,29 @@
     }
 
     if (SWAPW(entry->firstGlyph) <= ttGlyph) {
-        return entry;
+      return entry.getAlias();
     }
 
     return NULL;
 }
 
-const LookupSingle *BinarySearchLookupTable::lookupSingle(const LookupSingle *entries, LEGlyphID glyph) const
+const LookupSingle *BinarySearchLookupTable::lookupSingle(const LETableReference &base, const LookupSingle *entries, LEGlyphID glyph, LEErrorCode &success) const
 {
     le_int16  unity = SWAPW(unitSize);
     le_int16  probe = SWAPW(searchRange);
     le_int16  extra = SWAPW(rangeShift);
     TTGlyphID ttGlyph = (TTGlyphID) LE_GET_GLYPH(glyph);
-    const LookupSingle *entry = entries;
-    const LookupSingle *trial = (const LookupSingle *) ((char *) entry + extra);
+    LEReferenceTo<LookupSingle> entry(base, success, entries);
+    LEReferenceTo<LookupSingle> trial(entry, success, extra);
 
     if (SWAPW(trial->glyph) <= ttGlyph) {
         entry = trial;
     }
 
-    while (probe > unity) {
+    while (probe > unity && LE_SUCCESS(success)) {
         probe >>= 1;
-        trial = (const LookupSingle *) ((char *) entry + probe);
+        trial = entry;
+        trial.addOffset(probe, success);
 
         if (SWAPW(trial->glyph) <= ttGlyph) {
             entry = trial;
@@ -101,7 +106,7 @@
     }
 
     if (SWAPW(entry->glyph) == ttGlyph) {
-        return entry;
+      return entry.getAlias();
     }
 
     return NULL;
--- jdk/src/share/native/sun/font/layout/LookupTables.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/LookupTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -39,6 +39,7 @@
 
 #include "LETypes.h"
 #include "LayoutTables.h"
+#include "LETableReference.h"
 
 U_NAMESPACE_BEGIN
 
@@ -79,30 +80,34 @@
     le_int16 entrySelector;
     le_int16 rangeShift;
 
-    const LookupSegment *lookupSegment(const LookupSegment *segments, LEGlyphID glyph) const;
+    const LookupSegment *lookupSegment(const LETableReference &base, const LookupSegment *segments, LEGlyphID glyph, LEErrorCode &success) const;
 
-    const LookupSingle *lookupSingle(const LookupSingle *entries, LEGlyphID glyph) const;
+    const LookupSingle *lookupSingle(const LETableReference &base, const LookupSingle *entries, LEGlyphID glyph, LEErrorCode &success) const;
 };
 
 struct SimpleArrayLookupTable : LookupTable
 {
     LookupValue valueArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SimpleArrayLookupTable, valueArray)
 
 struct SegmentSingleLookupTable : BinarySearchLookupTable
 {
     LookupSegment segments[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SegmentSingleLookupTable, segments)
 
 struct SegmentArrayLookupTable : BinarySearchLookupTable
 {
     LookupSegment segments[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SegmentArrayLookupTable, segments)
 
 struct SingleTableLookupTable : BinarySearchLookupTable
 {
     LookupSingle entries[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SingleTableLookupTable, entries)
 
 struct TrimmedArrayLookupTable : LookupTable
 {
@@ -110,6 +115,7 @@
     TTGlyphID   glyphCount;
     LookupValue valueArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(TrimmedArrayLookupTable, valueArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/Lookups.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/Lookups.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -37,33 +37,35 @@
 
 U_NAMESPACE_BEGIN
 
-const LookupTable *LookupListTable::getLookupTable(le_uint16 lookupTableIndex) const
+const LEReferenceTo<LookupTable> LookupListTable::getLookupTable(const LEReferenceTo<LookupListTable> &base, le_uint16 lookupTableIndex, LEErrorCode &success) const
 {
-    if (lookupTableIndex >= SWAPW(lookupCount)) {
-        return 0;
-    }
+  LEReferenceToArrayOf<Offset> lookupTableOffsetArrayRef(base, success, (const Offset*)&lookupTableOffsetArray, SWAPW(lookupCount));
 
-    Offset lookupTableOffset = lookupTableOffsetArray[lookupTableIndex];
-
-    return (const LookupTable *) ((char *) this + SWAPW(lookupTableOffset));
+  if(LE_FAILURE(success) || lookupTableIndex>lookupTableOffsetArrayRef.getCount()) {
+    return LEReferenceTo<LookupTable>();
+  } else {
+    return LEReferenceTo<LookupTable>(base, success, SWAPW(lookupTableOffsetArrayRef.getObject(lookupTableIndex, success)));
+  }
 }
 
-const LookupSubtable *LookupTable::getLookupSubtable(le_uint16 subtableIndex) const
+const LEReferenceTo<LookupSubtable> LookupTable::getLookupSubtable(const LEReferenceTo<LookupTable> &base, le_uint16 subtableIndex, LEErrorCode &success) const
 {
-    if (subtableIndex >= SWAPW(subTableCount)) {
-        return 0;
-    }
-
-    Offset subtableOffset = subTableOffsetArray[subtableIndex];
+  LEReferenceToArrayOf<Offset> subTableOffsetArrayRef(base, success, (const Offset*)&subTableOffsetArray, SWAPW(subTableCount));
 
-    return (const LookupSubtable *) ((char *) this + SWAPW(subtableOffset));
+  if(LE_FAILURE(success) || subtableIndex>subTableOffsetArrayRef.getCount()) {
+    return LEReferenceTo<LookupSubtable>();
+  } else {
+    return LEReferenceTo<LookupSubtable>(base, success, SWAPW(subTableOffsetArrayRef.getObject(subtableIndex, success)));
+  }
 }
 
-le_int32 LookupSubtable::getGlyphCoverage(Offset tableOffset, LEGlyphID glyphID) const
+le_int32 LookupSubtable::getGlyphCoverage(const LEReferenceTo<LookupSubtable> &base, Offset tableOffset, LEGlyphID glyphID, LEErrorCode &success) const
 {
-    const CoverageTable *coverageTable = (const CoverageTable *) ((char *) this + SWAPW(tableOffset));
+  const LEReferenceTo<CoverageTable> coverageTable(base, success, SWAPW(tableOffset));
+
+  if(LE_FAILURE(success)) return 0;
 
-    return coverageTable->getGlyphCoverage(glyphID);
+  return coverageTable->getGlyphCoverage(glyphID);
 }
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/Lookups.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/Lookups.h	2013-05-05 09:38:38.000000000 -0700
@@ -58,9 +58,14 @@
     le_uint16 subtableFormat;
     Offset    coverageTableOffset;
 
-    inline le_int32  getGlyphCoverage(LEGlyphID glyphID) const;
+  inline le_int32  getGlyphCoverage(const LEReferenceTo<LookupSubtable> &base, LEGlyphID glyphID, LEErrorCode &success) const;
 
-    le_int32  getGlyphCoverage(Offset tableOffset, LEGlyphID glyphID) const;
+  le_int32  getGlyphCoverage(const LEReferenceTo<LookupSubtable> &base, Offset tableOffset, LEGlyphID glyphID, LEErrorCode &success) const;
+
+  // convenience
+  inline le_int32  getGlyphCoverage(const LETableReference &base, LEGlyphID glyphID, LEErrorCode &success) const;
+
+  inline le_int32  getGlyphCoverage(const LETableReference &base, Offset tableOffset, LEGlyphID glyphID, LEErrorCode &success) const;
 };
 
 struct LookupTable
@@ -70,20 +75,32 @@
     le_uint16       subTableCount;
     Offset          subTableOffsetArray[ANY_NUMBER];
 
-    const LookupSubtable  *getLookupSubtable(le_uint16 subtableIndex) const;
+  const LEReferenceTo<LookupSubtable> getLookupSubtable(const LEReferenceTo<LookupTable> &base, le_uint16 subtableIndex, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(LookupTable, subTableOffsetArray)
 
 struct LookupListTable
 {
     le_uint16   lookupCount;
     Offset      lookupTableOffsetArray[ANY_NUMBER];
 
-    const LookupTable *getLookupTable(le_uint16 lookupTableIndex) const;
+  const LEReferenceTo<LookupTable> getLookupTable(const LEReferenceTo<LookupListTable> &base, le_uint16 lookupTableIndex, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(LookupListTable, lookupTableOffsetArray)
 
-inline le_int32 LookupSubtable::getGlyphCoverage(LEGlyphID glyphID) const
+inline le_int32 LookupSubtable::getGlyphCoverage(const LEReferenceTo<LookupSubtable> &base, LEGlyphID glyphID, LEErrorCode &success) const
 {
-    return getGlyphCoverage(coverageTableOffset, glyphID);
+  return getGlyphCoverage(base, coverageTableOffset, glyphID, success);
+}
+
+inline le_int32  LookupSubtable::getGlyphCoverage(const LETableReference &base, LEGlyphID glyphID, LEErrorCode &success) const {
+  LEReferenceTo<LookupSubtable> thisRef(base, success, this);
+  return getGlyphCoverage(thisRef, glyphID, success);
+}
+
+inline le_int32  LookupSubtable::getGlyphCoverage(const LETableReference &base, Offset tableOffset, LEGlyphID glyphID, LEErrorCode &success) const {
+  LEReferenceTo<LookupSubtable> thisRef(base, success, this);
+  return getGlyphCoverage(thisRef, tableOffset, glyphID, success);
 }
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/MPreFixups.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MPreFixups.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 2002-2008 - All Rights Reserved
+ * (C) Copyright IBM Corp. 2002-2013 - All Rights Reserved
  *
  */
 
@@ -65,9 +65,9 @@
     }
 }
 
-void MPreFixups::apply(LEGlyphStorage &glyphStorage, LEErrorCode& leSuccess)
+void MPreFixups::apply(LEGlyphStorage &glyphStorage, LEErrorCode& success)
 {
-    if (LE_FAILURE(leSuccess)) {
+    if (LE_FAILURE(success)) {
         return;
     }
 
--- jdk/src/share/native/sun/font/layout/MarkArrays.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkArrays.h	2013-05-05 09:38:38.000000000 -0700
@@ -57,6 +57,7 @@
     le_int32 getMarkClass(LEGlyphID glyphID, le_int32 coverageIndex, const LEFontInstance *fontInstance,
         LEPoint &anchor) const;
 };
+LE_VAR_ARRAY(MarkArray, markRecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -51,10 +51,10 @@
     return 0xFFFF;
 }
 
-le_int32 MarkToBasePositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_int32 MarkToBasePositioningSubtable::process(const LETableReference &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID markGlyph = glyphIterator->getCurrGlyphID();
-    le_int32 markCoverage = getGlyphCoverage((LEGlyphID) markGlyph);
+    le_int32 markCoverage = getGlyphCoverage(base, (LEGlyphID) markGlyph, success);
 
     if (markCoverage < 0) {
         // markGlyph isn't a covered mark glyph
@@ -75,7 +75,7 @@
     // FIXME: We probably don't want to find a base glyph before a previous ligature...
     GlyphIterator baseIterator(*glyphIterator, (le_uint16) (lfIgnoreMarks /*| lfIgnoreLigatures*/));
     LEGlyphID baseGlyph = findBaseGlyph(&baseIterator);
-    le_int32 baseCoverage = getBaseCoverage((LEGlyphID) baseGlyph);
+    le_int32 baseCoverage = getBaseCoverage(base, (LEGlyphID) baseGlyph, success);
     const BaseArray *baseArray = (const BaseArray *) ((char *) this + SWAPW(baseArrayOffset));
     le_uint16 baseCount = SWAPW(baseArray->baseRecordCount);
 
--- jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.h	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -48,7 +48,7 @@
 
 struct MarkToBasePositioningSubtable : AttachmentPositioningSubtable
 {
-    le_int32   process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+  le_int32   process(const LETableReference &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
     LEGlyphID  findBaseGlyph(GlyphIterator *glyphIterator) const;
 };
 
@@ -56,12 +56,14 @@
 {
     Offset baseAnchorTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(BaseRecord, baseAnchorTableOffsetArray)
 
 struct BaseArray
 {
     le_int16 baseRecordCount;
     BaseRecord baseRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(BaseArray, baseRecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.cpp	2012-08-10 10:30:33.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -50,10 +50,10 @@
     return 0xFFFF;
 }
 
-le_int32 MarkToLigaturePositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_int32 MarkToLigaturePositioningSubtable::process(const LETableReference &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID markGlyph = glyphIterator->getCurrGlyphID();
-    le_int32 markCoverage = getGlyphCoverage((LEGlyphID) markGlyph);
+    le_int32 markCoverage = getGlyphCoverage(base, (LEGlyphID) markGlyph, success);
 
     if (markCoverage < 0) {
         // markGlyph isn't a covered mark glyph
@@ -74,7 +74,7 @@
     // FIXME: we probably don't want to find a ligature before a previous base glyph...
     GlyphIterator ligatureIterator(*glyphIterator, (le_uint16) (lfIgnoreMarks /*| lfIgnoreBaseGlyphs*/));
     LEGlyphID ligatureGlyph = findLigatureGlyph(&ligatureIterator);
-    le_int32 ligatureCoverage = getBaseCoverage((LEGlyphID) ligatureGlyph);
+    le_int32 ligatureCoverage = getBaseCoverage(base, (LEGlyphID) ligatureGlyph, success);
     const LigatureArray *ligatureArray = (const LigatureArray *) ((char *) this + SWAPW(baseArrayOffset));
     le_uint16 ligatureCount = SWAPW(ligatureArray->ligatureCount);
 
--- jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.h	2012-08-10 10:30:34.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -48,7 +48,7 @@
 
 struct MarkToLigaturePositioningSubtable : AttachmentPositioningSubtable
 {
-    le_int32   process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+  le_int32   process(const LETableReference &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
     LEGlyphID  findLigatureGlyph(GlyphIterator *glyphIterator) const;
 };
 
@@ -56,18 +56,21 @@
 {
     Offset ligatureAnchorTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(ComponentRecord, ligatureAnchorTableOffsetArray)
 
 struct LigatureAttachTable
 {
     le_uint16 componentCount;
     ComponentRecord componentRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LigatureAttachTable, componentRecordArray)
 
 struct LigatureArray
 {
     le_uint16 ligatureCount;
     Offset ligatureAttachTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LigatureArray, ligatureAttachTableOffsetArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.cpp	2012-08-10 10:30:34.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -51,10 +51,10 @@
     return 0xFFFF;
 }
 
-le_int32 MarkToMarkPositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_int32 MarkToMarkPositioningSubtable::process(const LETableReference &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID markGlyph = glyphIterator->getCurrGlyphID();
-    le_int32 markCoverage = getGlyphCoverage((LEGlyphID) markGlyph);
+    le_int32 markCoverage = getGlyphCoverage(base, (LEGlyphID) markGlyph, success);
 
     if (markCoverage < 0) {
         // markGlyph isn't a covered mark glyph
@@ -74,7 +74,7 @@
 
     GlyphIterator mark2Iterator(*glyphIterator);
     LEGlyphID mark2Glyph = findMark2Glyph(&mark2Iterator);
-    le_int32 mark2Coverage = getBaseCoverage((LEGlyphID) mark2Glyph);
+    le_int32 mark2Coverage = getBaseCoverage(base, (LEGlyphID) mark2Glyph, success);
     const Mark2Array *mark2Array = (const Mark2Array *) ((char *) this + SWAPW(baseArrayOffset));
     le_uint16 mark2Count = SWAPW(mark2Array->mark2RecordCount);
 
--- jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.h	2012-08-10 10:30:34.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -48,7 +48,7 @@
 
 struct MarkToMarkPositioningSubtable : AttachmentPositioningSubtable
 {
-    le_int32   process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+  le_int32   process(const LETableReference &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
     LEGlyphID  findMark2Glyph(GlyphIterator *glyphIterator) const;
 };
 
@@ -56,12 +56,14 @@
 {
     Offset mark2AnchorTableOffsetArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(Mark2Record, mark2AnchorTableOffsetArray)
 
 struct Mark2Array
 {
     le_uint16 mark2RecordCount;
     Mark2Record mark2RecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(Mark2Array, mark2RecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/MorphStateTables.h	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MorphStateTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -49,5 +49,10 @@
     StateTableHeader stHeader;
 };
 
+struct MorphStateTableHeader2 : MorphSubtableHeader2
+{
+    StateTableHeader2 stHeader;
+};
+
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/MorphTables.cpp	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MorphTables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -44,61 +44,61 @@
 
 U_NAMESPACE_BEGIN
 
-void MorphTableHeader::process(LEGlyphStorage &glyphStorage) const
+void MorphTableHeader::process(const LETableReference &base, LEGlyphStorage &glyphStorage, LEErrorCode &success) const
 {
-    const ChainHeader *chainHeader = chains;
-    le_uint32 chainCount = SWAPL(this->nChains);
+  le_uint32 chainCount = SWAPL(this->nChains);
+  LEReferenceTo<ChainHeader> chainHeader(base, success, chains); // moving header
+    LEReferenceToArrayOf<ChainHeader> chainHeaderArray(base, success, chains, chainCount);
     le_uint32 chain;
 
-    for (chain = 0; chain < chainCount; chain += 1) {
+    for (chain = 0; LE_SUCCESS(success) && (chain < chainCount); chain += 1) {
         FeatureFlags defaultFlags = SWAPL(chainHeader->defaultFlags);
         le_uint32 chainLength = SWAPL(chainHeader->chainLength);
         le_int16 nFeatureEntries = SWAPW(chainHeader->nFeatureEntries);
         le_int16 nSubtables = SWAPW(chainHeader->nSubtables);
-        const MorphSubtableHeader *subtableHeader =
-            (const MorphSubtableHeader *)&chainHeader->featureTable[nFeatureEntries];
+        LEReferenceTo<MorphSubtableHeader> subtableHeader =
+          LEReferenceTo<MorphSubtableHeader>(chainHeader,success, &(chainHeader->featureTable[nFeatureEntries]));
         le_int16 subtable;
 
-        for (subtable = 0; subtable < nSubtables; subtable += 1) {
+        for (subtable = 0; LE_SUCCESS(success) && (subtable < nSubtables); subtable += 1) {
             le_int16 length = SWAPW(subtableHeader->length);
             SubtableCoverage coverage = SWAPW(subtableHeader->coverage);
             FeatureFlags subtableFeatures = SWAPL(subtableHeader->subtableFeatures);
 
             // should check coverage more carefully...
-            if ((coverage & scfVertical) == 0 && (subtableFeatures & defaultFlags) != 0) {
-                subtableHeader->process(glyphStorage);
+            if ((coverage & scfVertical) == 0 && (subtableFeatures & defaultFlags) != 0  && LE_SUCCESS(success)) {
+              subtableHeader->process(subtableHeader, glyphStorage, success);
             }
 
-            subtableHeader = (const MorphSubtableHeader *) ((char *)subtableHeader + length);
+            subtableHeader.addOffset(length, success);
         }
-
-        chainHeader = (const ChainHeader *)((char *)chainHeader + chainLength);
+        chainHeader.addOffset(chainLength, success);
     }
 }
 
-void MorphSubtableHeader::process(LEGlyphStorage &glyphStorage) const
+void MorphSubtableHeader::process(const LEReferenceTo<MorphSubtableHeader> &base, LEGlyphStorage &glyphStorage, LEErrorCode &success) const
 {
     SubtableProcessor *processor = NULL;
 
     switch (SWAPW(coverage) & scfTypeMask)
     {
     case mstIndicRearrangement:
-        processor = new IndicRearrangementProcessor(this);
+      processor = new IndicRearrangementProcessor(base, success);
         break;
 
     case mstContextualGlyphSubstitution:
-        processor = new ContextualGlyphSubstitutionProcessor(this);
+      processor = new ContextualGlyphSubstitutionProcessor(base, success);
         break;
 
     case mstLigatureSubstitution:
-        processor = new LigatureSubstitutionProcessor(this);
+      processor = new LigatureSubstitutionProcessor(base, success);
         break;
 
     case mstReservedUnused:
         break;
 
     case mstNonContextualGlyphSubstitution:
-        processor = NonContextualGlyphSubstitutionProcessor::createInstance(this);
+      processor = NonContextualGlyphSubstitutionProcessor::createInstance(base, success);
         break;
 
     /*
@@ -112,8 +112,10 @@
     }
 
     if (processor != NULL) {
-        processor->process(glyphStorage);
-        delete processor;
+      if(LE_SUCCESS(success)) {
+        processor->process(glyphStorage, success);
+      }
+      delete processor;
     }
 }
 
--- jdk/src/share/native/sun/font/layout/MorphTables.h	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MorphTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -39,6 +39,7 @@
 
 #include "LETypes.h"
 #include "LayoutTables.h"
+#include "LETableReference.h"
 
 U_NAMESPACE_BEGIN
 
@@ -65,6 +66,7 @@
     le_int16           nSubtables;
     FeatureTableEntry   featureTable[ANY_NUMBER];
 };
+LE_VAR_ARRAY(ChainHeader, featureTable)
 
 struct MorphTableHeader
 {
@@ -72,10 +74,12 @@
     le_uint32   nChains;
     ChainHeader chains[ANY_NUMBER];
 
-    void process(LEGlyphStorage &glyphStorage) const;
+  void process(const LETableReference& base, LEGlyphStorage &glyphStorage, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(MorphTableHeader, chains)
 
 typedef le_int16 SubtableCoverage;
+typedef le_uint32 SubtableCoverage2;
 
 enum SubtableCoverageFlags
 {
@@ -102,7 +106,305 @@
     SubtableCoverage    coverage;
     FeatureFlags        subtableFeatures;
 
-    void process(LEGlyphStorage &glyphStorage) const;
+  void process(const LEReferenceTo<MorphSubtableHeader> &base, LEGlyphStorage &glyphStorage, LEErrorCode &success) const;
+};
+
+enum SubtableCoverageFlags2
+{
+    scfVertical2 = 0x80000000,
+    scfReverse2  = 0x40000000,
+    scfIgnoreVt2 = 0x20000000,
+    scfReserved2 = 0x1FFFFF00,
+    scfTypeMask2 = 0x000000FF
+};
+
+struct MorphSubtableHeader2
+{
+    le_uint32           length;
+    SubtableCoverage2    coverage;
+    FeatureFlags        subtableFeatures;
+
+    void process(const LEReferenceTo<MorphSubtableHeader2> &base, LEGlyphStorage &glyphStorage, LEErrorCode &success) const;
+};
+
+struct ChainHeader2
+{
+    FeatureFlags        defaultFlags;
+    le_uint32           chainLength;
+    le_uint32           nFeatureEntries;
+    le_uint32           nSubtables;
+    FeatureTableEntry   featureTable[ANY_NUMBER];
+};
+LE_VAR_ARRAY(ChainHeader2, featureTable)
+
+struct MorphTableHeader2
+{
+    le_int32    version;
+    le_uint32   nChains;
+    ChainHeader2 chains[ANY_NUMBER];
+
+    void process(const LEReferenceTo<MorphTableHeader2> &base, LEGlyphStorage &glyphStorage, le_int32 typoFlags, LEErrorCode &success) const;
+};
+LE_VAR_ARRAY(MorphTableHeader2, chains)
+
+/*
+ * AAT Font Features
+ * source: https://developer.apple.com/fonts/registry/
+ * (plus addition from ATS/SFNTLayoutTypes.h)
+ */
+
+enum {
+
+   allTypographicFeaturesType = 0,
+
+      allTypeFeaturesOnSelector            = 0,
+      allTypeFeaturesOffSelector           = 1,
+
+   ligaturesType = 1,
+
+      requiredLigaturesOnSelector          = 0,
+      requiredLigaturesOffSelector         = 1,
+      commonLigaturesOnSelector            = 2,
+      commonLigaturesOffSelector           = 3,
+      rareLigaturesOnSelector              = 4,
+      rareLigaturesOffSelector             = 5,
+      logosOnSelector                      = 6,
+      logosOffSelector                     = 7,
+      rebusPicturesOnSelector              = 8,
+      rebusPicturesOffSelector             = 9,
+      diphthongLigaturesOnSelector         = 10,
+      diphthongLigaturesOffSelector        = 11,
+      squaredLigaturesOnSelector           = 12,
+      squaredLigaturesOffSelector          = 13,
+      abbrevSquaredLigaturesOnSelector     = 14,
+      abbrevSquaredLigaturesOffSelector    = 15,
+      symbolLigaturesOnSelector            = 16,
+      symbolLigaturesOffSelector           = 17,
+      contextualLigaturesOnSelector        = 18,
+      contextualLigaturesOffSelector       = 19,
+      historicalLigaturesOnSelector        = 20,
+      historicalLigaturesOffSelector       = 21,
+
+   cursiveConnectionType = 2,
+
+      unconnectedSelector                  = 0,
+      partiallyConnectedSelector           = 1,
+      cursiveSelector                      = 2,
+
+   letterCaseType = 3,
+
+      upperAndLowerCaseSelector            = 0,
+      allCapsSelector                      = 1,
+      allLowerCaseSelector                 = 2,
+      smallCapsSelector                    = 3,
+      initialCapsSelector                  = 4,
+      initialCapsAndSmallCapsSelector      = 5,
+
+   verticalSubstitutionType = 4,
+
+      substituteVerticalFormsOnSelector    = 0,
+      substituteVerticalFormsOffSelector   = 1,
+
+   linguisticRearrangementType = 5,
+
+      linguisticRearrangementOnSelector    = 0,
+      linguisticRearrangementOffSelector   = 1,
+
+   numberSpacingType = 6,
+
+      monospacedNumbersSelector            = 0,
+      proportionalNumbersSelector          = 1,
+
+   /*
+   appleReserved1Type = 7,
+   */
+
+   smartSwashType = 8,
+
+      wordInitialSwashesOnSelector         = 0,
+      wordInitialSwashesOffSelector        = 1,
+      wordFinalSwashesOnSelector           = 2,
+      wordFinalSwashesOffSelector          = 3,
+      lineInitialSwashesOnSelector         = 4,
+      lineInitialSwashesOffSelector        = 5,
+      lineFinalSwashesOnSelector           = 6,
+      lineFinalSwashesOffSelector          = 7,
+      nonFinalSwashesOnSelector            = 8,
+      nonFinalSwashesOffSelector           = 9,
+
+   diacriticsType = 9,
+
+      showDiacriticsSelector               = 0,
+      hideDiacriticsSelector               = 1,
+      decomposeDiacriticsSelector          = 2,
+
+   verticalPositionType = 10,
+
+      normalPositionSelector               = 0,
+      superiorsSelector                    = 1,
+      inferiorsSelector                    = 2,
+      ordinalsSelector                     = 3,
+
+   fractionsType = 11,
+
+      noFractionsSelector                  = 0,
+      verticalFractionsSelector            = 1,
+      diagonalFractionsSelector            = 2,
+
+   /*
+   appleReserved2Type = 12,
+   */
+
+   overlappingCharactersType = 13,
+
+      preventOverlapOnSelector             = 0,
+      preventOverlapOffSelector            = 1,
+
+   typographicExtrasType = 14,
+
+      hyphensToEmDashOnSelector            = 0,
+      hyphensToEmDashOffSelector           = 1,
+      hyphenToEnDashOnSelector             = 2,
+      hyphenToEnDashOffSelector            = 3,
+      unslashedZeroOnSelector              = 4,
+      slashedZeroOffSelector               = 4,
+      unslashedZeroOffSelector             = 5,
+      slashedZeroOnSelector                = 5,
+      formInterrobangOnSelector            = 6,
+      formInterrobangOffSelector           = 7,
+      smartQuotesOnSelector                = 8,
+      smartQuotesOffSelector               = 9,
+      periodsToEllipsisOnSelector          = 10,
+      periodsToEllipsisOffSelector         = 11,
+
+   mathematicalExtrasType = 15,
+
+      hyphenToMinusOnSelector              = 0,
+      hyphenToMinusOffSelector             = 1,
+      asteriskToMultiplyOnSelector         = 2,
+      asteriskToMultiplyOffSelector        = 3,
+      slashToDivideOnSelector              = 4,
+      slashToDivideOffSelector             = 5,
+      inequalityLigaturesOnSelector        = 6,
+      inequalityLigaturesOffSelector       = 7,
+      exponentsOnSelector                  = 8,
+      exponentsOffSelector                 = 9,
+
+   ornamentSetsType = 16,
+
+      noOrnamentsSelector                  = 0,
+      dingbatsSelector                     = 1,
+      piCharactersSelector                 = 2,
+      fleuronsSelector                     = 3,
+      decorativeBordersSelector            = 4,
+      internationalSymbolsSelector         = 5,
+      mathSymbolsSelector                  = 6,
+
+   characterAlternativesType = 17,
+
+      noAlternatesSelector                 = 0,
+
+   designComplexityType = 18,
+
+      designLevel1Selector                 = 0,
+      designLevel2Selector                 = 1,
+      designLevel3Selector                 = 2,
+      designLevel4Selector                 = 3,
+      designLevel5Selector                 = 4,
+      designLevel6Selector                 = 5,
+      designLevel7Selector                 = 6,
+
+   styleOptionsType = 19,
+
+      noStyleOptionsSelector               = 0,
+      displayTextSelector                  = 1,
+      engravedTextSelector                 = 2,
+      illuminatedCapsSelector              = 3,
+      titlingCapsSelector                  = 4,
+      tallCapsSelector                     = 5,
+
+   characterShapeType = 20,
+
+      traditionalCharactersSelector        = 0,
+      simplifiedCharactersSelector         = 1,
+      jis1978CharactersSelector            = 2,
+      jis1983CharactersSelector            = 3,
+      jis1990CharactersSelector            = 4,
+      traditionalAltOneSelector            = 5,
+      traditionalAltTwoSelector            = 6,
+      traditionalAltThreeSelector          = 7,
+      traditionalAltFourSelector           = 8,
+      traditionalAltFiveSelector           = 9,
+      expertCharactersSelector             = 10,
+
+   numberCaseType = 21,
+
+      lowerCaseNumbersSelector             = 0,
+      upperCaseNumbersSelector             = 1,
+
+   textSpacingType = 22,
+
+      proportionalTextSelector             = 0,
+      monospacedTextSelector               = 1,
+      halfWidthTextSelector                = 2,
+      normallySpacedTextSelector           = 3,
+
+   transliterationType = 23,
+
+      noTransliterationSelector            = 0,
+      hanjaToHangulSelector                = 1,
+      hiraganaToKatakanaSelector           = 2,
+      katakanaToHiraganaSelector           = 3,
+      kanaToRomanizationSelector           = 4,
+      romanizationToHiraganaSelector       = 5,
+      romanizationToKatakanaSelector       = 6,
+      hanjaToHangulAltOneSelector          = 7,
+      hanjaToHangulAltTwoSelector          = 8,
+      hanjaToHangulAltThreeSelector        = 9,
+
+   annotationType = 24,
+
+      noAnnotationSelector                 = 0,
+      boxAnnotationSelector                = 1,
+      roundedBoxAnnotationSelector         = 2,
+      circleAnnotationSelector             = 3,
+      invertedCircleAnnotationSelector     = 4,
+      parenthesisAnnotationSelector        = 5,
+      periodAnnotationSelector             = 6,
+      romanNumeralAnnotationSelector       = 7,
+      diamondAnnotationSelector            = 8,
+
+   kanaSpacingType = 25,
+
+      fullWidthKanaSelector                = 0,
+      proportionalKanaSelector             = 1,
+
+   ideographicSpacingType = 26,
+
+      fullWidthIdeographsSelector          = 0,
+      proportionalIdeographsSelector       = 1,
+
+   cjkRomanSpacingType = 103,
+
+      halfWidthCJKRomanSelector            = 0,
+      proportionalCJKRomanSelector         = 1,
+      defaultCJKRomanSelector              = 2,
+      fullWidthCJKRomanSelector            = 3,
+
+   rubyKanaType = 28,
+
+      rubyKanaOnSelector                = 2,
+      rubyKanaOffSelector               = 3,
+
+/* The following types are provided for compatibility; note that
+   their use is deprecated. */
+
+   adobeCharacterSpacingType = 100,        /* prefer 22 */
+   adobeKanaSpacingType = 101,             /* prefer 25 */
+   adobeKanjiSpacingType = 102,            /* prefer 26 */
+   adobeSquareLigatures = 104,             /* prefer 1 */
+
+   lastFeatureType = -1
 };
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/MorphTables2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/MorphTables2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,248 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ * (C) Copyright IBM Corp. and others 1998 - 2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "LayoutTables.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "IndicRearrangementProcessor2.h"
+#include "ContextualGlyphSubstProc2.h"
+#include "LigatureSubstProc2.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "ContextualGlyphInsertionProc2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+void MorphTableHeader2::process(const LEReferenceTo<MorphTableHeader2> &base, LEGlyphStorage &glyphStorage,
+                                le_int32 typoFlags, LEErrorCode &success) const
+{
+  if(LE_FAILURE(success)) return;
+
+  le_uint32 chainCount = SWAPL(this->nChains);
+  LEReferenceTo<ChainHeader2> chainHeader(base, success, &chains[0]);
+  /* chainHeader and subtableHeader are implemented as a moving pointer rather than an array dereference
+   * to (slightly) reduce code churn. However, must be careful to preincrement them the 2nd time through.
+   * We don't want to increment them at the end of the loop, as that would attempt to dereference
+   * out of range memory.
+   */
+  le_uint32 chain;
+
+  for (chain = 0; LE_SUCCESS(success) && (chain < chainCount); chain++) {
+        if (chain>0) {
+          le_uint32 chainLength = SWAPL(chainHeader->chainLength);
+          chainHeader.addOffset(chainLength, success); // Don't increment the first time
+        }
+        FeatureFlags flag = SWAPL(chainHeader->defaultFlags);
+        le_uint32 nFeatureEntries = SWAPL(chainHeader->nFeatureEntries);
+        le_uint32 nSubtables = SWAPL(chainHeader->nSubtables);
+        LEReferenceTo<MorphSubtableHeader2> subtableHeader(chainHeader,
+              success, (const MorphSubtableHeader2 *)&chainHeader->featureTable[nFeatureEntries]);
+        le_uint32 subtable;
+        if(LE_FAILURE(success)) break; // malformed table
+
+        if (typoFlags != 0) {
+           le_uint32 featureEntry;
+           LEReferenceToArrayOf<FeatureTableEntry> featureTableRef(chainHeader, success, &chainHeader->featureTable[0], nFeatureEntries);
+           if(LE_FAILURE(success)) break;
+            // Feature subtables
+            for (featureEntry = 0; featureEntry < nFeatureEntries; featureEntry++) {
+                const FeatureTableEntry &featureTableEntry = featureTableRef(featureEntry, success);
+                le_int16 featureType = SWAPW(featureTableEntry.featureType);
+                le_int16 featureSetting = SWAPW(featureTableEntry.featureSetting);
+                le_uint32 enableFlags = SWAPL(featureTableEntry.enableFlags);
+                le_uint32 disableFlags = SWAPL(featureTableEntry.disableFlags);
+                switch (featureType) {
+                    case ligaturesType:
+                        if ((typoFlags & LE_Ligatures_FEATURE_ENUM ) && (featureSetting ^ 0x1)){
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        } else {
+                            if (((typoFlags & LE_RLIG_FEATURE_FLAG) && featureSetting == requiredLigaturesOnSelector) ||
+                                ((typoFlags & LE_CLIG_FEATURE_FLAG) && featureSetting == contextualLigaturesOnSelector) ||
+                                ((typoFlags & LE_HLIG_FEATURE_FLAG) && featureSetting == historicalLigaturesOnSelector) ||
+                                ((typoFlags & LE_LIGA_FEATURE_FLAG) && featureSetting == commonLigaturesOnSelector)) {
+                                flag &= disableFlags;
+                                flag |= enableFlags;
+                            }
+                        }
+                        break;
+                    case letterCaseType:
+                        if ((typoFlags & LE_SMCP_FEATURE_FLAG) && featureSetting == smallCapsSelector) {
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        }
+                        break;
+                    case verticalSubstitutionType:
+                        break;
+                    case linguisticRearrangementType:
+                        break;
+                    case numberSpacingType:
+                        break;
+                    case smartSwashType:
+                        if ((typoFlags & LE_SWSH_FEATURE_FLAG) && (featureSetting ^ 0x1)){
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        }
+                        break;
+                    case diacriticsType:
+                        break;
+                    case verticalPositionType:
+                        break;
+                    case fractionsType:
+                        if (((typoFlags & LE_FRAC_FEATURE_FLAG) && featureSetting == diagonalFractionsSelector) ||
+                            ((typoFlags & LE_AFRC_FEATURE_FLAG) && featureSetting == verticalFractionsSelector)) {
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        } else {
+                            flag &= disableFlags;
+                        }
+                        break;
+                    case typographicExtrasType:
+                        if ((typoFlags & LE_ZERO_FEATURE_FLAG) && featureSetting == slashedZeroOnSelector) {
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        }
+                        break;
+                    case mathematicalExtrasType:
+                        break;
+                    case ornamentSetsType:
+                        break;
+                    case characterAlternativesType:
+                        break;
+                    case designComplexityType:
+                        if (((typoFlags & LE_SS01_FEATURE_FLAG) && featureSetting == designLevel1Selector) ||
+                            ((typoFlags & LE_SS02_FEATURE_FLAG) && featureSetting == designLevel2Selector) ||
+                            ((typoFlags & LE_SS03_FEATURE_FLAG) && featureSetting == designLevel3Selector) ||
+                            ((typoFlags & LE_SS04_FEATURE_FLAG) && featureSetting == designLevel4Selector) ||
+                            ((typoFlags & LE_SS05_FEATURE_FLAG) && featureSetting == designLevel5Selector) ||
+                            ((typoFlags & LE_SS06_FEATURE_FLAG) && featureSetting == designLevel6Selector) ||
+                            ((typoFlags & LE_SS07_FEATURE_FLAG) && featureSetting == designLevel7Selector)) {
+
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        }
+                        break;
+                    case styleOptionsType:
+                        break;
+                    case characterShapeType:
+                        break;
+                    case numberCaseType:
+                        break;
+                    case textSpacingType:
+                        break;
+                    case transliterationType:
+                        break;
+                    case annotationType:
+                        if ((typoFlags & LE_NALT_FEATURE_FLAG) && featureSetting == circleAnnotationSelector) {
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        }
+                        break;
+                    case kanaSpacingType:
+                        break;
+                    case ideographicSpacingType:
+                        break;
+                    case rubyKanaType:
+                        if ((typoFlags & LE_RUBY_FEATURE_FLAG) && featureSetting == rubyKanaOnSelector) {
+                            flag &= disableFlags;
+                            flag |= enableFlags;
+                        }
+                        break;
+                    case cjkRomanSpacingType:
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+
+        for (subtable = 0;  LE_SUCCESS(success) && subtable < nSubtables; subtable++) {
+            if(subtable>0)  {
+              le_uint32 length = SWAPL(subtableHeader->length);
+              subtableHeader.addOffset(length, success); // Don't addOffset for the last entry.
+            }
+            le_uint32 coverage = SWAPL(subtableHeader->coverage);
+            FeatureFlags subtableFeatures = SWAPL(subtableHeader->subtableFeatures);
+            // should check coverage more carefully...
+            if (((coverage & scfIgnoreVt2) || !(coverage & scfVertical2)) && (subtableFeatures & flag) != 0) {
+              subtableHeader->process(subtableHeader, glyphStorage, success);
+            }
+        }
+    }
+}
+
+void MorphSubtableHeader2::process(const LEReferenceTo<MorphSubtableHeader2> &base, LEGlyphStorage &glyphStorage, LEErrorCode &success) const
+{
+    SubtableProcessor2 *processor = NULL;
+
+    switch (SWAPL(coverage) & scfTypeMask2)
+    {
+    case mstIndicRearrangement:
+        processor = new IndicRearrangementProcessor2(base, success);
+        break;
+
+    case mstContextualGlyphSubstitution:
+        processor = new ContextualGlyphSubstitutionProcessor2(base, success);
+        break;
+
+    case mstLigatureSubstitution:
+        processor = new LigatureSubstitutionProcessor2(base, success);
+        break;
+
+    case mstReservedUnused:
+        break;
+
+    case mstNonContextualGlyphSubstitution:
+        processor = NonContextualGlyphSubstitutionProcessor2::createInstance(base, success);
+        break;
+
+
+    case mstContextualGlyphInsertion:
+        processor = new ContextualGlyphInsertionProcessor2(base, success);
+        break;
+
+    default:
+        return;
+        break; /*NOTREACHED*/
+    }
+
+    if (processor != NULL) {
+      processor->process(glyphStorage, success);
+        delete processor;
+    } else {
+      if(LE_SUCCESS(success)) {
+        success = LE_MEMORY_ALLOCATION_ERROR; // because ptr is null and we didn't break out.
+      }
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.cpp	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -39,7 +39,7 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 MultipleSubstitutionSubtable::process(GlyphIterator *glyphIterator, LEErrorCode& success, const LEGlyphFilter *filter) const
+le_uint32 MultipleSubstitutionSubtable::process(const LETableReference &base, GlyphIterator *glyphIterator, LEErrorCode& success, const LEGlyphFilter *filter) const
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -58,7 +58,7 @@
         return 0;
     }
 
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, glyph, success);
     le_uint16 seqCount = SWAPW(sequenceCount);
 
     if (coverageIndex >= 0 && coverageIndex < seqCount) {
--- jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.h	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,14 +50,16 @@
     le_uint16 glyphCount;
     TTGlyphID substituteArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(SequenceTable, substituteArray)
 
 struct MultipleSubstitutionSubtable : GlyphSubstitutionSubtable
 {
     le_uint16 sequenceCount;
     Offset    sequenceTableOffsetArray[ANY_NUMBER];
 
-    le_uint32 process(GlyphIterator *glyphIterator, LEErrorCode& success, const LEGlyphFilter *filter = NULL) const;
+    le_uint32 process(const LETableReference &base, GlyphIterator *glyphIterator, LEErrorCode& success, const LEGlyphFilter *filter = NULL) const;
 };
+LE_VAR_ARRAY(MultipleSubstitutionSubtable, sequenceTableOffsetArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubst.h	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubst.h	2013-05-05 09:38:38.000000000 -0700
@@ -26,7 +26,7 @@
 /*
  *
  *
- * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -50,6 +50,11 @@
     LookupTable table;
 };
 
+struct NonContextualGlyphSubstitutionHeader2 : MorphSubtableHeader2
+{
+    LookupTable table;
+};
+
 U_NAMESPACE_END
 #endif
 
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.cpp	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -47,8 +47,8 @@
 {
 }
 
-NonContextualGlyphSubstitutionProcessor::NonContextualGlyphSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader)
-    : SubtableProcessor(morphSubtableHeader)
+NonContextualGlyphSubstitutionProcessor::NonContextualGlyphSubstitutionProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : SubtableProcessor(morphSubtableHeader, success)
 {
 }
 
@@ -56,26 +56,27 @@
 {
 }
 
-SubtableProcessor *NonContextualGlyphSubstitutionProcessor::createInstance(const MorphSubtableHeader *morphSubtableHeader)
+SubtableProcessor *NonContextualGlyphSubstitutionProcessor::createInstance(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
 {
-    const NonContextualGlyphSubstitutionHeader *header = (const NonContextualGlyphSubstitutionHeader *) morphSubtableHeader;
+  LEReferenceTo<NonContextualGlyphSubstitutionHeader> header(morphSubtableHeader, success);
 
-    switch (SWAPW(header->table.format))
-    {
+  if(LE_FAILURE(success)) return NULL;
+
+  switch (SWAPW(header->table.format)) {
     case ltfSimpleArray:
-        return new SimpleArrayProcessor(morphSubtableHeader);
+      return new SimpleArrayProcessor(morphSubtableHeader, success);
 
     case ltfSegmentSingle:
-        return new SegmentSingleProcessor(morphSubtableHeader);
+      return new SegmentSingleProcessor(morphSubtableHeader, success);
 
     case ltfSegmentArray:
-        return new SegmentArrayProcessor(morphSubtableHeader);
+      return new SegmentArrayProcessor(morphSubtableHeader, success);
 
     case ltfSingleTable:
-        return new SingleTableProcessor(morphSubtableHeader);
+      return new SingleTableProcessor(morphSubtableHeader, success);
 
     case ltfTrimmedArray:
-        return new TrimmedArrayProcessor(morphSubtableHeader);
+      return new TrimmedArrayProcessor(morphSubtableHeader, success);
 
     default:
         return NULL;
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.h	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.h	2013-05-05 09:38:38.000000000 -0700
@@ -49,13 +49,13 @@
 class NonContextualGlyphSubstitutionProcessor : public SubtableProcessor
 {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage) = 0;
+  virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success) = 0;
 
-    static SubtableProcessor *createInstance(const MorphSubtableHeader *morphSubtableHeader);
+    static SubtableProcessor *createInstance(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
 protected:
     NonContextualGlyphSubstitutionProcessor();
-    NonContextualGlyphSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    NonContextualGlyphSubstitutionProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &status);
 
     virtual ~NonContextualGlyphSubstitutionProcessor();
 
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,88 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "SimpleArrayProcessor2.h"
+#include "SegmentSingleProcessor2.h"
+#include "SegmentArrayProcessor2.h"
+#include "SingleTableProcessor2.h"
+#include "TrimmedArrayProcessor2.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+NonContextualGlyphSubstitutionProcessor2::NonContextualGlyphSubstitutionProcessor2()
+{
+}
+
+NonContextualGlyphSubstitutionProcessor2::NonContextualGlyphSubstitutionProcessor2(
+     const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : SubtableProcessor2(morphSubtableHeader, success)
+{
+}
+
+NonContextualGlyphSubstitutionProcessor2::~NonContextualGlyphSubstitutionProcessor2()
+{
+}
+
+SubtableProcessor2 *NonContextualGlyphSubstitutionProcessor2::createInstance(
+      const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+{
+    const LEReferenceTo<NonContextualGlyphSubstitutionHeader2> header(morphSubtableHeader, success);
+    if(LE_FAILURE(success)) return NULL;
+
+    switch (SWAPW(header->table.format))
+    {
+    case ltfSimpleArray:
+      return new SimpleArrayProcessor2(morphSubtableHeader, success);
+
+    case ltfSegmentSingle:
+      return new SegmentSingleProcessor2(morphSubtableHeader, success);
+
+    case ltfSegmentArray:
+      return new SegmentArrayProcessor2(morphSubtableHeader, success);
+
+    case ltfSingleTable:
+      return new SingleTableProcessor2(morphSubtableHeader, success);
+
+    case ltfTrimmedArray:
+      return new TrimmedArrayProcessor2(morphSubtableHeader, success);
+
+    default:
+        return NULL;
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,68 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __NONCONTEXTUALGLYPHSUBSTITUTIONPROCESSOR2_H
+#define __NONCONTEXTUALGLYPHSUBSTITUTIONPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class NonContextualGlyphSubstitutionProcessor2 : public SubtableProcessor2
+{
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success) = 0;
+
+    static SubtableProcessor2 *createInstance(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+protected:
+    NonContextualGlyphSubstitutionProcessor2();
+    NonContextualGlyphSubstitutionProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    virtual ~NonContextualGlyphSubstitutionProcessor2();
+
+private:
+    NonContextualGlyphSubstitutionProcessor2(const NonContextualGlyphSubstitutionProcessor2 &other); // forbid copying of this class
+    NonContextualGlyphSubstitutionProcessor2 &operator=(const NonContextualGlyphSubstitutionProcessor2 &other); // forbid copying of this class
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.cpp	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -26,7 +26,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -64,11 +64,27 @@
 #define loclFeatureTag LE_LOCL_FEATURE_TAG
 #define caltFeatureTag LE_CALT_FEATURE_TAG
 
-// 'dlig' not used at the moment
-#define dligFeatureTag 0x646C6967
-
-// 'palt'
-#define paltFeatureTag 0x70616C74
+#define dligFeatureTag LE_DLIG_FEATURE_TAG
+#define rligFeatureTag LE_RLIG_FEATURE_TAG
+#define paltFeatureTag LE_PALT_FEATURE_TAG
+
+#define hligFeatureTag LE_HLIG_FEATURE_TAG
+#define smcpFeatureTag LE_SMCP_FEATURE_TAG
+#define fracFeatureTag LE_FRAC_FEATURE_TAG
+#define afrcFeatureTag LE_AFRC_FEATURE_TAG
+#define zeroFeatureTag LE_ZERO_FEATURE_TAG
+#define swshFeatureTag LE_SWSH_FEATURE_TAG
+#define cswhFeatureTag LE_CSWH_FEATURE_TAG
+#define saltFeatureTag LE_SALT_FEATURE_TAG
+#define naltFeatureTag LE_NALT_FEATURE_TAG
+#define rubyFeatureTag LE_RUBY_FEATURE_TAG
+#define ss01FeatureTag LE_SS01_FEATURE_TAG
+#define ss02FeatureTag LE_SS02_FEATURE_TAG
+#define ss03FeatureTag LE_SS03_FEATURE_TAG
+#define ss04FeatureTag LE_SS04_FEATURE_TAG
+#define ss05FeatureTag LE_SS05_FEATURE_TAG
+#define ss06FeatureTag LE_SS06_FEATURE_TAG
+#define ss07FeatureTag LE_SS07_FEATURE_TAG
 
 #define ccmpFeatureMask 0x80000000UL
 #define ligaFeatureMask 0x40000000UL
@@ -80,60 +96,146 @@
 #define loclFeatureMask 0x01000000UL
 #define caltFeatureMask 0x00800000UL
 
+#define dligFeatureMask 0x00400000UL
+#define rligFeatureMask 0x00200000UL
+#define hligFeatureMask 0x00100000UL
+#define smcpFeatureMask 0x00080000UL
+#define fracFeatureMask 0x00040000UL
+#define afrcFeatureMask 0x00020000UL
+#define zeroFeatureMask 0x00010000UL
+#define swshFeatureMask 0x00008000UL
+#define cswhFeatureMask 0x00004000UL
+#define saltFeatureMask 0x00002000UL
+#define naltFeatureMask 0x00001000UL
+#define rubyFeatureMask 0x00000800UL
+#define ss01FeatureMask 0x00000400UL
+#define ss02FeatureMask 0x00000200UL
+#define ss03FeatureMask 0x00000100UL
+#define ss04FeatureMask 0x00000080UL
+#define ss05FeatureMask 0x00000040UL
+#define ss06FeatureMask 0x00000020UL
+#define ss07FeatureMask 0x00000010UL
+
 #define minimalFeatures     (ccmpFeatureMask | markFeatureMask | mkmkFeatureMask | loclFeatureMask | caltFeatureMask)
-#define ligaFeatures        (ligaFeatureMask | cligFeatureMask | minimalFeatures)
-#define kernFeatures        (kernFeatureMask | paltFeatureMask | minimalFeatures)
-#define kernAndLigaFeatures (ligaFeatures    | kernFeatures)
 
 static const FeatureMap featureMap[] =
 {
     {ccmpFeatureTag, ccmpFeatureMask},
     {ligaFeatureTag, ligaFeatureMask},
     {cligFeatureTag, cligFeatureMask},
-        {kernFeatureTag, kernFeatureMask},
+    {kernFeatureTag, kernFeatureMask},
     {paltFeatureTag, paltFeatureMask},
     {markFeatureTag, markFeatureMask},
     {mkmkFeatureTag, mkmkFeatureMask},
     {loclFeatureTag, loclFeatureMask},
-    {caltFeatureTag, caltFeatureMask}
+    {caltFeatureTag, caltFeatureMask},
+    {hligFeatureTag, hligFeatureMask},
+    {smcpFeatureTag, smcpFeatureMask},
+    {fracFeatureTag, fracFeatureMask},
+    {afrcFeatureTag, afrcFeatureMask},
+    {zeroFeatureTag, zeroFeatureMask},
+    {swshFeatureTag, swshFeatureMask},
+    {cswhFeatureTag, cswhFeatureMask},
+    {saltFeatureTag, saltFeatureMask},
+    {naltFeatureTag, naltFeatureMask},
+    {rubyFeatureTag, rubyFeatureMask},
+    {ss01FeatureTag, ss01FeatureMask},
+    {ss02FeatureTag, ss02FeatureMask},
+    {ss03FeatureTag, ss03FeatureMask},
+    {ss04FeatureTag, ss04FeatureMask},
+    {ss05FeatureTag, ss05FeatureMask},
+    {ss06FeatureTag, ss06FeatureMask},
+    {ss07FeatureTag, ss07FeatureMask}
 };
 
 static const le_int32 featureMapCount = LE_ARRAY_SIZE(featureMap);
 
 OpenTypeLayoutEngine::OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+                     le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success)
     : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success), fFeatureMask(minimalFeatures),
       fFeatureMap(featureMap), fFeatureMapCount(featureMapCount), fFeatureOrder(FALSE),
-      fGSUBTable(gsubTable), fGDEFTable(NULL), fGPOSTable(NULL), fSubstitutionFilter(NULL)
+      fGSUBTable(gsubTable),
+      fGDEFTable(fontInstance, LE_GDEF_TABLE_TAG, success),
+      fGPOSTable(fontInstance, LE_GPOS_TABLE_TAG, success), fSubstitutionFilter(NULL)
 {
-    static const le_uint32 gdefTableTag = LE_GDEF_TABLE_TAG;
-    static const le_uint32 gposTableTag = LE_GPOS_TABLE_TAG;
-    const GlyphPositioningTableHeader *gposTable = (const GlyphPositioningTableHeader *) getFontTable(gposTableTag);
-
-    // todo: switch to more flags and bitfield rather than list of feature tags?
-    switch (typoFlags & ~0x80000000L) {
-    case 0: break; // default
-    case 1: fFeatureMask = kernFeatures; break;
-    case 2: fFeatureMask = ligaFeatures; break;
-    case 3: fFeatureMask = kernAndLigaFeatures; break;
-    default: break;
-    }
-
-    if (typoFlags & 0x80000000L) {
-        fSubstitutionFilter = new CharSubstitutionFilter(fontInstance);
-    }
+    applyTypoFlags();
 
     setScriptAndLanguageTags();
 
-    fGDEFTable = (const GlyphDefinitionTableHeader *) getFontTable(gdefTableTag);
-
 // JK patch, 2008-05-30 - see Sinhala bug report and LKLUG font
 //    if (gposTable != NULL && gposTable->coversScriptAndLanguage(fScriptTag, fLangSysTag)) {
-    if (gposTable != NULL && gposTable->coversScript(fScriptTag)) {
-        fGPOSTable = gposTable;
+    if (!fGPOSTable.isEmpty()&& !fGPOSTable->coversScript(fGPOSTable, fScriptTag, success)) {
+      fGPOSTable.clear(); // already loaded
     }
 }
 
+void OpenTypeLayoutEngine::applyTypoFlags() {
+    const le_int32& typoFlags = fTypoFlags;
+    const LEFontInstance *fontInstance = fFontInstance;
+
+    switch (typoFlags & (LE_SS01_FEATURE_FLAG
+                         | LE_SS02_FEATURE_FLAG
+                         | LE_SS03_FEATURE_FLAG
+                         | LE_SS04_FEATURE_FLAG
+                         | LE_SS05_FEATURE_FLAG
+                         | LE_SS06_FEATURE_FLAG
+                         | LE_SS07_FEATURE_FLAG)) {
+        case LE_SS01_FEATURE_FLAG:
+            fFeatureMask |= ss01FeatureMask;
+            break;
+        case LE_SS02_FEATURE_FLAG:
+            fFeatureMask |= ss02FeatureMask;
+            break;
+        case LE_SS03_FEATURE_FLAG:
+            fFeatureMask |= ss03FeatureMask;
+            break;
+        case LE_SS04_FEATURE_FLAG:
+            fFeatureMask |= ss04FeatureMask;
+            break;
+        case LE_SS05_FEATURE_FLAG:
+            fFeatureMask |= ss05FeatureMask;
+            break;
+        case LE_SS06_FEATURE_FLAG:
+            fFeatureMask |= ss06FeatureMask;
+            break;
+        case LE_SS07_FEATURE_FLAG:
+            fFeatureMask |= ss07FeatureMask;
+            break;
+    }
+
+    if (typoFlags & LE_Kerning_FEATURE_FLAG) {
+      fFeatureMask |= (kernFeatureMask | paltFeatureMask);
+      // Convenience.
+    }
+    if (typoFlags & LE_Ligatures_FEATURE_FLAG) {
+      fFeatureMask |= (ligaFeatureMask | cligFeatureMask);
+      // Convenience TODO: should add: .. dligFeatureMask | rligFeatureMask ?
+    }
+    if (typoFlags & LE_CLIG_FEATURE_FLAG) fFeatureMask |= cligFeatureMask;
+    if (typoFlags & LE_DLIG_FEATURE_FLAG) fFeatureMask |= dligFeatureMask;
+    if (typoFlags & LE_HLIG_FEATURE_FLAG) fFeatureMask |= hligFeatureMask;
+    if (typoFlags & LE_LIGA_FEATURE_FLAG) fFeatureMask |= ligaFeatureMask;
+    if (typoFlags & LE_RLIG_FEATURE_FLAG) fFeatureMask |= rligFeatureMask;
+    if (typoFlags & LE_SMCP_FEATURE_FLAG) fFeatureMask |= smcpFeatureMask;
+    if (typoFlags & LE_FRAC_FEATURE_FLAG) fFeatureMask |= fracFeatureMask;
+    if (typoFlags & LE_AFRC_FEATURE_FLAG) fFeatureMask |= afrcFeatureMask;
+    if (typoFlags & LE_ZERO_FEATURE_FLAG) fFeatureMask |= zeroFeatureMask;
+    if (typoFlags & LE_SWSH_FEATURE_FLAG) fFeatureMask |= swshFeatureMask;
+    if (typoFlags & LE_CSWH_FEATURE_FLAG) fFeatureMask |= cswhFeatureMask;
+    if (typoFlags & LE_SALT_FEATURE_FLAG) fFeatureMask |= saltFeatureMask;
+    if (typoFlags & LE_RUBY_FEATURE_FLAG) fFeatureMask |= rubyFeatureMask;
+    if (typoFlags & LE_NALT_FEATURE_FLAG) {
+      // Mutually exclusive with ALL other features. http://www.microsoft.com/typography/otspec/features_ko.htm
+      fFeatureMask = naltFeatureMask;
+    }
+
+    if (typoFlags & LE_CHAR_FILTER_FEATURE_FLAG) {
+      // This isn't a font feature, but requests a Char Substitution Filter
+      fSubstitutionFilter = new CharSubstitutionFilter(fontInstance);
+    }
+
+}
+
 void OpenTypeLayoutEngine::reset()
 {
     // NOTE: if we're called from
@@ -146,15 +248,17 @@
 OpenTypeLayoutEngine::OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
                        le_int32 typoFlags, LEErrorCode &success)
     : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, success), fFeatureOrder(FALSE),
-      fGSUBTable(NULL), fGDEFTable(NULL), fGPOSTable(NULL), fSubstitutionFilter(NULL)
+      fGSUBTable(), fGDEFTable(), fGPOSTable(), fSubstitutionFilter(NULL)
 {
-    setScriptAndLanguageTags();
+  applyTypoFlags();
+  setScriptAndLanguageTags();
 }
 
 OpenTypeLayoutEngine::~OpenTypeLayoutEngine()
 {
-    if (fTypoFlags & 0x80000000L) {
+    if (fTypoFlags & LE_CHAR_FILTER_FEATURE_FLAG) {
         delete fSubstitutionFilter;
+        fSubstitutionFilter = NULL;
     }
 
     reset();
@@ -267,13 +371,13 @@
         return 0;
     }
 
-    if (fGSUBTable != NULL) {
-        if (fScriptTagV2 != nullScriptTag && fGSUBTable->coversScriptAndLanguage(fScriptTagV2,fLangSysTag)) {
-            count = fGSUBTable->process(glyphStorage, rightToLeft, fScriptTagV2, fLangSysTag, fGDEFTable, fSubstitutionFilter,
+    if (fGSUBTable.isValid()) {
+      if (fScriptTagV2 != nullScriptTag && fGSUBTable->coversScriptAndLanguage(fGSUBTable, fScriptTagV2, fLangSysTag, success)) {
+          count = fGSUBTable->process(fGSUBTable, glyphStorage, rightToLeft, fScriptTagV2, fLangSysTag, fGDEFTable, fSubstitutionFilter,
                                     fFeatureMap, fFeatureMapCount, fFeatureOrder, success);
 
         } else {
-        count = fGSUBTable->process(glyphStorage, rightToLeft, fScriptTag, fLangSysTag, fGDEFTable, fSubstitutionFilter,
+          count = fGSUBTable->process(fGSUBTable, glyphStorage, rightToLeft, fScriptTag, fLangSysTag, fGDEFTable, fSubstitutionFilter,
                                     fFeatureMap, fFeatureMapCount, fFeatureOrder, success);
     }
     }
@@ -294,13 +398,13 @@
         return 0;
     }
 
-    if (fGSUBTable != NULL) {
-        if (fScriptTagV2 != nullScriptTag && fGSUBTable->coversScriptAndLanguage(fScriptTagV2,fLangSysTag)) {
-            count = fGSUBTable->process(glyphStorage, rightToLeft, fScriptTagV2, fLangSysTag, fGDEFTable, fSubstitutionFilter,
+    if (fGSUBTable.isValid()) {
+       if (fScriptTagV2 != nullScriptTag && fGSUBTable->coversScriptAndLanguage(fGSUBTable,fScriptTagV2,fLangSysTag,success)) {
+          count = fGSUBTable->process(fGSUBTable, glyphStorage, rightToLeft, fScriptTagV2, fLangSysTag, fGDEFTable, fSubstitutionFilter,
                                     fFeatureMap, fFeatureMapCount, fFeatureOrder, success);
 
         } else {
-        count = fGSUBTable->process(glyphStorage, rightToLeft, fScriptTag, fLangSysTag, fGDEFTable, fSubstitutionFilter,
+          count = fGSUBTable->process(fGSUBTable, glyphStorage, rightToLeft, fScriptTag, fLangSysTag, fGDEFTable, fSubstitutionFilter,
                                     fFeatureMap, fFeatureMapCount, fFeatureOrder, success);
         }
     }
@@ -325,7 +429,7 @@
 {
     LEUnicode *outChars = NULL;
     LEGlyphStorage fakeGlyphStorage;
-    le_int32 outCharCount, outGlyphCount, fakeGlyphCount;
+    le_int32 outCharCount, outGlyphCount;
 
     if (LE_FAILURE(success)) {
         return 0;
@@ -343,11 +447,13 @@
     }
 
     if (outChars != NULL) {
-        fakeGlyphCount = glyphProcessing(outChars, 0, outCharCount, outCharCount, rightToLeft, fakeGlyphStorage, success);
+        // le_int32 fakeGlyphCount =
+        glyphProcessing(outChars, 0, outCharCount, outCharCount, rightToLeft, fakeGlyphStorage, success);
         LE_DELETE_ARRAY(outChars); // FIXME: a subclass may have allocated this, in which case this delete might not work...
         //adjustGlyphs(outChars, 0, outCharCount, rightToLeft, fakeGlyphs, fakeGlyphCount);
     } else {
-        fakeGlyphCount = glyphProcessing(chars, offset, count, max, rightToLeft, fakeGlyphStorage, success);
+        // le_int32 fakeGlyphCount =
+        glyphProcessing(chars, offset, count, max, rightToLeft, fakeGlyphStorage, success);
         //adjustGlyphs(chars, offset, count, rightToLeft, fakeGlyphs, fakeGlyphCount);
     }
 
@@ -378,7 +484,7 @@
         return;
     }
 
-    if (fGPOSTable != NULL) {
+    if (!fGPOSTable.isEmpty()) {
         GlyphPositionAdjustments *adjustments = new GlyphPositionAdjustments(glyphCount);
         le_int32 i;
 
@@ -401,19 +507,20 @@
         }
 #endif
 
-        if (fGPOSTable != NULL) {
-            if (fScriptTagV2 != nullScriptTag && fGPOSTable->coversScriptAndLanguage(fScriptTagV2,fLangSysTag)) {
-                fGPOSTable->process(glyphStorage, adjustments, reverse, fScriptTagV2, fLangSysTag, fGDEFTable, success, fFontInstance,
-                            fFeatureMap, fFeatureMapCount, fFeatureOrder);
+        if (!fGPOSTable.isEmpty()) {
+            if (fScriptTagV2 != nullScriptTag &&
+                fGPOSTable->coversScriptAndLanguage(fGPOSTable, fScriptTagV2,fLangSysTag,success)) {
+              fGPOSTable->process(fGPOSTable, glyphStorage, adjustments, reverse, fScriptTagV2, fLangSysTag,
+                                  fGDEFTable, success, fFontInstance, fFeatureMap, fFeatureMapCount, fFeatureOrder);
 
             } else {
-                fGPOSTable->process(glyphStorage, adjustments, reverse, fScriptTag, fLangSysTag, fGDEFTable, success, fFontInstance,
-                                fFeatureMap, fFeatureMapCount, fFeatureOrder);
+              fGPOSTable->process(fGPOSTable, glyphStorage, adjustments, reverse, fScriptTag, fLangSysTag,
+                                  fGDEFTable, success, fFontInstance, fFeatureMap, fFeatureMapCount, fFeatureOrder);
             }
-        } else if ( fTypoFlags & 0x1 ) {
-            static const le_uint32 kernTableTag = LE_KERN_TABLE_TAG;
-            KernTable kt(fFontInstance, getFontTable(kernTableTag));
-            kt.process(glyphStorage);
+        } else if (fTypoFlags & LE_Kerning_FEATURE_FLAG) { /* kerning enabled */
+          LETableReference kernTable(fFontInstance, LE_KERN_TABLE_TAG, success);
+          KernTable kt(kernTable, success);
+          kt.process(glyphStorage, success);
         }
 
         float xAdjust = 0, yAdjust = 0;
--- jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.h	2012-08-10 10:30:35.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -24,7 +24,7 @@
  */
 
 /*
- * (C) Copyright IBM Corp. 1998-2010 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -35,6 +35,7 @@
 #include "LEGlyphFilter.h"
 #include "LEFontInstance.h"
 #include "LayoutEngine.h"
+#include "LETableReference.h"
 
 #include "GlyphSubstitutionTables.h"
 #include "GlyphDefinitionTables.h"
@@ -88,7 +89,7 @@
      * @internal
      */
     OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success);
+                            le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
@@ -184,6 +185,11 @@
      */
     static const LETag scriptTags[];
 
+    /**
+     * apply the typoflags. Only called by the c'tors.
+     */
+    void applyTypoFlags();
+
 protected:
     /**
      * A set of "default" features. The default characterProcessing method
@@ -223,21 +229,21 @@
      *
      * @internal
      */
-    const GlyphSubstitutionTableHeader *fGSUBTable;
+    LEReferenceTo<GlyphSubstitutionTableHeader> fGSUBTable;
 
     /**
      * The address of the GDEF table.
      *
      * @internal
      */
-    const GlyphDefinitionTableHeader   *fGDEFTable;
+    LEReferenceTo<GlyphDefinitionTableHeader> fGDEFTable;
 
     /**
      * The address of the GPOS table.
      *
      * @internal
      */
-    const GlyphPositioningTableHeader  *fGPOSTable;
+    LEReferenceTo<GlyphPositioningTableHeader> fGPOSTable;
 
     /**
      * An optional filter used to inhibit substitutions
--- jdk/src/share/native/sun/font/layout/OpenTypeTables.h	2012-08-10 10:30:36.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/OpenTypeTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -38,6 +38,7 @@
  */
 
 #include "LETypes.h"
+#include "LETableReference.h"
 
 U_NAMESPACE_BEGIN
 
@@ -50,7 +51,7 @@
 #define LE_GLYPH_GROUP_MASK 0x00000001UL
 typedef le_uint32 FeatureMask;
 
-#define SWAPT(atag) ((LETag) ((atag[0] << 24) + (atag[1] << 16) + (atag[2] << 8) + atag[3]))
+#define SWAPT(atag) ((LETag) (((atag[0]) << 24) + ((atag[1]) << 16) + ((atag[2]) << 8) + (atag[3])))
 
 struct TagAndOffsetRecord
 {
--- jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp	2012-08-10 10:30:36.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -76,58 +76,74 @@
     return bit;
 }
 
-Offset OpenTypeUtilities::getTagOffset(LETag tag, const TagAndOffsetRecord *records, le_int32 recordCount)
+
+Offset OpenTypeUtilities::getTagOffset(LETag tag, const LEReferenceToArrayOf<TagAndOffsetRecord> &records, LEErrorCode &success)
 {
-    le_uint8 bit = highBit(recordCount);
-    le_int32 power = 1 << bit;
-    le_int32 extra = recordCount - power;
-    le_int32 probe = power;
-    le_int32 index = 0;
+  if(LE_FAILURE(success)) return 0;
 
-    if (SWAPT(records[extra].tag) <= tag) {
-        index = extra;
+  le_uint32 recordCount = records.getCount();
+  le_uint8 bit = highBit(recordCount);
+  le_int32 power = 1 << bit;
+  le_int32 extra = recordCount - power;
+  le_int32 probe = power;
+  le_int32 index = 0;
+
+  {
+    const ATag &aTag = records.getAlias(extra,success)->tag;
+    if (SWAPT(aTag) <= tag) {
+      index = extra;
     }
+  }
 
-    while (probe > (1 << 0)) {
-        probe >>= 1;
+  while (probe > (1 << 0) && LE_SUCCESS(success)) {
+    probe >>= 1;
 
-        if (SWAPT(records[index + probe].tag) <= tag) {
-            index += probe;
-        }
+    {
+      const ATag &aTag = records.getAlias(index+probe,success)->tag;
+      if (SWAPT(aTag) <= tag) {
+        index += probe;
+      }
     }
+  }
 
-    if (SWAPT(records[index].tag) == tag) {
-        return SWAPW(records[index].offset);
+  {
+    const ATag &aTag = records.getAlias(index,success)->tag;
+    if (SWAPT(aTag) == tag) {
+      return SWAPW(records.getAlias(index,success)->offset);
     }
+  }
 
-    return 0;
+  return 0;
 }
 
-le_int32 OpenTypeUtilities::getGlyphRangeIndex(TTGlyphID glyphID, const GlyphRangeRecord *records, le_int32 recordCount)
+le_int32 OpenTypeUtilities::getGlyphRangeIndex(TTGlyphID glyphID, const LEReferenceToArrayOf<GlyphRangeRecord> &records, LEErrorCode &success)
 {
+  if(LE_FAILURE(success)) return -1;
+
+    le_uint32 recordCount = records.getCount();
     le_uint8 bit = highBit(recordCount);
     le_int32 power = 1 << bit;
     le_int32 extra = recordCount - power;
     le_int32 probe = power;
     le_int32 range = 0;
 
-        if (recordCount == 0) {
-                return -1;
-        }
+    if (recordCount == 0) {
+      return -1;
+    }
 
-    if (SWAPW(records[extra].firstGlyph) <= glyphID) {
+    if (SWAPW(records(extra,success).firstGlyph) <= glyphID) {
         range = extra;
     }
 
-    while (probe > (1 << 0)) {
+    while (probe > (1 << 0) && LE_SUCCESS(success)) {
         probe >>= 1;
 
-        if (SWAPW(records[range + probe].firstGlyph) <= glyphID) {
+        if (SWAPW(records(range + probe,success).firstGlyph) <= glyphID) {
             range += probe;
         }
     }
 
-    if (SWAPW(records[range].firstGlyph) <= glyphID && SWAPW(records[range].lastGlyph) >= glyphID) {
+    if (SWAPW(records(range,success).firstGlyph) <= glyphID && SWAPW(records(range,success).lastGlyph) >= glyphID) {
         return range;
     }
 
@@ -199,6 +215,38 @@
     }
 }
 
+U_NAMESPACE_END
 
+#if LE_ASSERT_BAD_FONT
+#include <stdio.h>
 
-U_NAMESPACE_END
+static const char *letagToStr(LETag tag, char *str) {
+  str[0]= 0xFF & (tag>>24);
+  str[1]= 0xFF & (tag>>16);
+  str[2]= 0xFF & (tag>>8);
+  str[3]= 0xFF & (tag>>0);
+  str[4]= 0;
+  return str;
+}
+
+U_CAPI void U_EXPORT2 _debug_LETableReference(const char *f, int l, const char *msg, const LETableReference *what, const void *ptr, size_t len) {
+  char tagbuf[5];
+
+  fprintf(stderr, "%s:%d: LETableReference@0x%p: ", f, l, what);
+  fprintf(stderr, msg, ptr, len);
+  fprintf(stderr, "\n");
+
+  for(int depth=0;depth<10&&(what!=NULL);depth++) {
+    for(int i=0;i<depth;i++) {
+      fprintf(stderr, " "); // indent
+    }
+    if(!what->isValid()) {
+      fprintf(stderr, "(invalid)");
+    }
+    fprintf(stderr, "@%p: tag (%s) font (0x%p), [0x%p+0x%lx]\n", what, letagToStr(what->getTag(), tagbuf), what->getFont(),
+            what->getAlias(), what->getLength());
+
+    what = what->getParent();
+  }
+}
+#endif
--- jdk/src/share/native/sun/font/layout/OpenTypeUtilities.h	2012-08-10 10:30:36.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/OpenTypeUtilities.h	2013-05-05 09:38:38.000000000 -0700
@@ -45,8 +45,17 @@
 class OpenTypeUtilities /* not : public UObject because all methods are static */ {
 public:
     static le_int8 highBit(le_int32 value);
-    static Offset getTagOffset(LETag tag, const TagAndOffsetRecord *records, le_int32 recordCount);
-    static le_int32 getGlyphRangeIndex(TTGlyphID glyphID, const GlyphRangeRecord *records, le_int32 recordCount);
+    static Offset getTagOffset(LETag tag, const LEReferenceToArrayOf<TagAndOffsetRecord> &records, LEErrorCode &success);
+    /**
+     * @deprecated TODO remove
+     */
+    static le_int32 getGlyphRangeIndex(TTGlyphID glyphID, const GlyphRangeRecord *records, le_int32 recordCount) {
+      LEErrorCode success = LE_NO_ERROR;
+      LETableReference recordRef0((const le_uint8*)records);
+      LEReferenceToArrayOf<GlyphRangeRecord> recordRef(recordRef0, success, (size_t)0, recordCount);
+      return getGlyphRangeIndex(glyphID, recordRef, success);
+    }
+    static le_int32 getGlyphRangeIndex(TTGlyphID glyphID, const LEReferenceToArrayOf<GlyphRangeRecord> &records, LEErrorCode &success);
     static le_int32 search(le_uint16 value, const le_uint16 array[], le_int32 count);
     static le_int32 search(le_uint32 value, const le_uint32 array[], le_int32 count);
     static void sort(le_uint16 *array, le_int32 count);
--- jdk/src/share/native/sun/font/layout/PairPositioningSubtables.cpp	2012-08-10 10:30:36.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/PairPositioningSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -41,7 +41,7 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 PairPositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 PairPositioningSubtable::process(const LEReferenceTo<PairPositioningSubtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     switch(SWAPW(subtableFormat))
     {
@@ -50,27 +50,32 @@
 
     case 1:
     {
-        const PairPositioningFormat1Subtable *subtable = (const PairPositioningFormat1Subtable *) this;
+      const LEReferenceTo<PairPositioningFormat1Subtable> subtable(base, success, (const PairPositioningFormat1Subtable *) this);
 
-        return subtable->process(glyphIterator, fontInstance);
+      if(LE_SUCCESS(success))
+      return subtable->process(subtable, glyphIterator, fontInstance, success);
+      else
+        return 0;
     }
 
     case 2:
     {
-        const PairPositioningFormat2Subtable *subtable = (const PairPositioningFormat2Subtable *) this;
+      const LEReferenceTo<PairPositioningFormat2Subtable> subtable(base, success, (const PairPositioningFormat2Subtable *) this);
 
-        return subtable->process(glyphIterator, fontInstance);
+      if(LE_SUCCESS(success))
+      return subtable->process(subtable, glyphIterator, fontInstance, success);
+      else
+        return 0;
     }
-
     default:
-        return 0;
+      return 0;
     }
 }
 
-le_uint32 PairPositioningFormat1Subtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 PairPositioningFormat1Subtable::process(const LEReferenceTo<PairPositioningFormat1Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID firstGlyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(firstGlyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, firstGlyph, success);
     GlyphIterator tempIterator(*glyphIterator);
 
     if (coverageIndex >= 0 && glyphIterator->next()) {
@@ -110,10 +115,10 @@
     return 0;
 }
 
-le_uint32 PairPositioningFormat2Subtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 PairPositioningFormat2Subtable::process(const LEReferenceTo<PairPositioningFormat2Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID firstGlyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(firstGlyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, firstGlyph, success);
     GlyphIterator tempIterator(*glyphIterator);
 
     if (coverageIndex >= 0 && glyphIterator->next()) {
--- jdk/src/share/native/sun/font/layout/PairPositioningSubtables.h	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/PairPositioningSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -59,13 +59,14 @@
     le_uint16       pairValueCount;
     PairValueRecord pairValueRecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(PairSetTable, pairValueRecordArray)
 
 struct PairPositioningSubtable : GlyphPositioningSubtable
 {
     ValueFormat valueFormat1;
     ValueFormat valueFormat2;
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<PairPositioningSubtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 };
 
 struct PairPositioningFormat1Subtable : PairPositioningSubtable
@@ -73,12 +74,13 @@
     le_uint16   pairSetCount;
     Offset      pairSetTableOffsetArray[ANY_NUMBER];
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<PairPositioningFormat1Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 
 private:
     const PairValueRecord *findPairValueRecord(TTGlyphID glyphID, const PairValueRecord *records,
         le_uint16 recordCount, le_uint16 recordSize) const;
 };
+LE_VAR_ARRAY(PairPositioningFormat1Subtable, pairSetTableOffsetArray)
 
 // NOTE: ValueRecord has a variable size
 struct Class2Record
@@ -91,6 +93,7 @@
 {
     Class2Record class2RecordArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(Class1Record, class2RecordArray)
 
 struct PairPositioningFormat2Subtable : PairPositioningSubtable
 {
@@ -100,8 +103,9 @@
     le_uint16    class2Count;
     Class1Record class1RecordArray[ANY_NUMBER];
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<PairPositioningFormat2Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(PairPositioningFormat2Subtable, class1RecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguage.cpp	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguage.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -38,29 +38,33 @@
 
 U_NAMESPACE_BEGIN
 
-const LangSysTable *ScriptTable::findLanguage(LETag languageTag, le_bool exactMatch) const
+LEReferenceTo<LangSysTable> ScriptTable::findLanguage(const LETableReference& base, LETag languageTag, LEErrorCode &success, le_bool exactMatch) const
 {
     le_uint16 count = SWAPW(langSysCount);
     Offset langSysTableOffset = exactMatch? 0 : SWAPW(defaultLangSysTableOffset);
 
     if (count > 0) {
-        Offset foundOffset =
-            OpenTypeUtilities::getTagOffset(languageTag, langSysRecordArray, count);
-
-        if (foundOffset != 0) {
-            langSysTableOffset = foundOffset;
-        }
+      LEReferenceToArrayOf<TagAndOffsetRecord> langSysRecords(base, success, langSysRecordArray, count);
+      Offset foundOffset =
+        OpenTypeUtilities::getTagOffset(languageTag, langSysRecords, success);
+
+      if (foundOffset != 0 && LE_SUCCESS(success)) {
+        langSysTableOffset = foundOffset;
+      }
     }
 
     if (langSysTableOffset != 0) {
-        return (const LangSysTable *) ((char *)this + langSysTableOffset);
+      return LEReferenceTo<LangSysTable>(base, success, langSysTableOffset);
     }
 
-    return NULL;
+    return LEReferenceTo<LangSysTable>();
 }
 
-const ScriptTable *ScriptListTable::findScript(LETag scriptTag) const
+LEReferenceTo<ScriptTable> ScriptListTable::findScript(const LETableReference &base, LETag scriptTag, LEErrorCode &success) const
 {
+    if (LE_FAILURE(success) ) {
+      return LEReferenceTo<ScriptTable>(); // get out
+    }
     /*
      * There are some fonts that have a large, bogus value for scriptCount. To try
      * and protect against this, we use the offset in the first scriptRecord,
@@ -74,38 +78,53 @@
      * to be unsorted.
      */
     le_uint16 count = SWAPW(scriptCount);
+
+    if (count == 0) {
+      return LEReferenceTo<ScriptTable>(); // no items, no search
+    }
+
+    // attempt to construct a ref with at least one element
+    LEReferenceToArrayOf<ScriptRecord> oneElementTable(base, success, &scriptRecordArray[0], 1);
+
+    if( LE_FAILURE(success) ) {
+      return LEReferenceTo<ScriptTable>(); // couldn't even read the first record - bad font.
+    }
+
     le_uint16 limit = ((SWAPW(scriptRecordArray[0].offset) - sizeof(ScriptListTable)) / sizeof(scriptRecordArray)) + ANY_NUMBER;
     Offset scriptTableOffset = 0;
 
+
     if (count > limit) {
         // the scriptCount value is bogus; do a linear search
         // because limit may still be too large.
-        for(le_int32 s = 0; s < limit; s += 1) {
-            if (SWAPT(scriptRecordArray[s].tag) == scriptTag) {
-                scriptTableOffset = SWAPW(scriptRecordArray[s].offset);
-                break;
-            }
+        LEReferenceToArrayOf<ScriptRecord> scriptRecordArrayRef(base, success, &scriptRecordArray[0], limit);
+        for(le_int32 s = 0; (s < limit)&&LE_SUCCESS(success); s += 1) {
+          if (SWAPT(scriptRecordArrayRef(s,success).tag) == scriptTag) {
+            scriptTableOffset = SWAPW(scriptRecordArrayRef(s,success).offset);
+            break;
+          }
         }
     } else {
-        scriptTableOffset = OpenTypeUtilities::getTagOffset(scriptTag, scriptRecordArray, count);
+      LEReferenceToArrayOf<ScriptRecord> scriptRecordArrayRef(base, success, &scriptRecordArray[0], count);
+      scriptTableOffset = OpenTypeUtilities::getTagOffset(scriptTag, scriptRecordArrayRef, success); // TODO
     }
 
     if (scriptTableOffset != 0) {
-        return (const ScriptTable *) ((char *)this + scriptTableOffset);
+      return LEReferenceTo<ScriptTable>(base, success, scriptTableOffset);
     }
 
-    return NULL;
+  return LEReferenceTo<ScriptTable>();
 }
 
-const LangSysTable *ScriptListTable::findLanguage(LETag scriptTag, LETag languageTag, le_bool exactMatch) const
+LEReferenceTo<LangSysTable>  ScriptListTable::findLanguage(const LETableReference &base, LETag scriptTag, LETag languageTag, LEErrorCode &success, le_bool exactMatch) const
 {
-    const ScriptTable *scriptTable = findScript(scriptTag);
+  const LEReferenceTo<ScriptTable> scriptTable = findScript(base, scriptTag, success);
 
-    if (scriptTable == 0) {
-        return NULL;
-    }
+  if (scriptTable.isEmpty()) {
+    return LEReferenceTo<LangSysTable>();
+  }
 
-    return scriptTable->findLanguage(languageTag, exactMatch);
+  return scriptTable->findLanguage(scriptTable, languageTag, success, exactMatch).reparent(base);
 }
 
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguage.h	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguage.h	2013-05-05 09:38:38.000000000 -0700
@@ -51,6 +51,7 @@
     le_uint16 featureCount;
     le_uint16 featureIndexArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(LangSysTable, featureIndexArray)
 
 struct ScriptTable
 {
@@ -58,8 +59,9 @@
     le_uint16           langSysCount;
     LangSysRecord       langSysRecordArray[ANY_NUMBER];
 
-    const LangSysTable  *findLanguage(LETag languageTag, le_bool exactMatch = FALSE) const;
+  LEReferenceTo<LangSysTable>  findLanguage(const LETableReference &base, LETag languageTag, LEErrorCode &success, le_bool exactMatch = FALSE) const;
 };
+LE_VAR_ARRAY(ScriptTable, langSysRecordArray)
 
 typedef TagAndOffsetRecord ScriptRecord;
 
@@ -68,9 +70,10 @@
     le_uint16           scriptCount;
     ScriptRecord        scriptRecordArray[ANY_NUMBER];
 
-    const ScriptTable   *findScript(LETag scriptTag) const;
-    const LangSysTable  *findLanguage(LETag scriptTag, LETag languageTag, le_bool exactMatch = FALSE) const;
+  LEReferenceTo<ScriptTable>   findScript(const LETableReference &base, LETag scriptTag, LEErrorCode &success) const;
+  LEReferenceTo<LangSysTable>  findLanguage(const LETableReference &base, LETag scriptTag, LETag languageTag, LEErrorCode &success, le_bool exactMatch = FALSE) const;
 };
+LE_VAR_ARRAY(ScriptListTable, scriptRecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.cpp	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010. All Rights Reserved.
+ * (C) Copyright IBM Corp. 1998-2013. All Rights Reserved.
  *
  * WARNING: THIS FILE IS MACHINE GENERATED. DO NOT HAND EDIT IT UNLESS
  * YOU REALLY KNOW WHAT YOU'RE DOING.
@@ -186,7 +186,18 @@
     nbatScriptTag, /* 'nbat' (NBAT) */
     palmScriptTag, /* 'palm' (PALM) */
     sindScriptTag, /* 'sind' (SIND) */
-    waraScriptTag  /* 'wara' (WARA) */
+    waraScriptTag, /* 'wara' (WARA) */
+    afakScriptTag, /* 'afak' (AFAK) */
+    jurcScriptTag, /* 'jurc' (JURC) */
+    mrooScriptTag, /* 'mroo' (MROO) */
+    nshuScriptTag, /* 'nshu' (NSHU) */
+    shrdScriptTag, /* 'shrd' (SHARADA) */
+    soraScriptTag, /* 'sora' (SORA_SOMPENG) */
+    takrScriptTag, /* 'takr' (TAKRI) */
+    tangScriptTag, /* 'tang' (TANG) */
+    woleScriptTag, /* 'wole' (WOLE) */
+    khojScriptTag, /* 'khoj' (KHOJ) */
+    tirhScriptTag  /* 'tirh' (TIRH) */
 };
 
 const LETag OpenTypeLayoutEngine::languageTags[] = {
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.h	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2010. All Rights Reserved.
+ * (C) Copyright IBM Corp. 1998-2013. All Rights Reserved.
  *
  * WARNING: THIS FILE IS MACHINE GENERATED. DO NOT HAND EDIT IT UNLESS
  * YOU REALLY KNOW WHAT YOU'RE DOING.
@@ -201,6 +201,17 @@
 const LETag palmScriptTag = 0x70616C6D; /* 'palm' (PALM) */
 const LETag sindScriptTag = 0x73696E64; /* 'sind' (SIND) */
 const LETag waraScriptTag = 0x77617261; /* 'wara' (WARA) */
+const LETag afakScriptTag = 0x6166616B; /* 'afak' (AFAK) */
+const LETag jurcScriptTag = 0x6A757263; /* 'jurc' (JURC) */
+const LETag mrooScriptTag = 0x6D726F6F; /* 'mroo' (MROO) */
+const LETag nshuScriptTag = 0x6E736875; /* 'nshu' (NSHU) */
+const LETag shrdScriptTag = 0x73687264; /* 'shrd' (SHARADA) */
+const LETag soraScriptTag = 0x736F7261; /* 'sora' (SORA_SOMPENG) */
+const LETag takrScriptTag = 0x74616B72; /* 'takr' (TAKRI) */
+const LETag tangScriptTag = 0x74616E67; /* 'tang' (TANG) */
+const LETag woleScriptTag = 0x776F6C65; /* 'wole' (WOLE) */
+const LETag khojScriptTag = 0x6B686F6A; /* 'khoj' (KHOJ) */
+const LETag tirhScriptTag = 0x74697268; /* 'tirh' (TIRH) */
 
 const LETag nullScriptTag = 0x00000000; /* ''     (NULL) */
 
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -46,19 +46,18 @@
 {
 }
 
-SegmentArrayProcessor::SegmentArrayProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader)
+SegmentArrayProcessor::SegmentArrayProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader, success)
 {
-    const NonContextualGlyphSubstitutionHeader *header = (const NonContextualGlyphSubstitutionHeader *) morphSubtableHeader;
-
-    segmentArrayLookupTable = (const SegmentArrayLookupTable *) &header->table;
+  LEReferenceTo<NonContextualGlyphSubstitutionHeader> header(morphSubtableHeader, success);
+  segmentArrayLookupTable = LEReferenceTo<SegmentArrayLookupTable>(morphSubtableHeader, success, (const SegmentArrayLookupTable*)&header->table);
 }
 
 SegmentArrayProcessor::~SegmentArrayProcessor()
 {
 }
 
-void SegmentArrayProcessor::process(LEGlyphStorage &glyphStorage)
+void SegmentArrayProcessor::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     const LookupSegment *segments = segmentArrayLookupTable->segments;
     le_int32 glyphCount = glyphStorage.getGlyphCount();
@@ -66,17 +65,16 @@
 
     for (glyph = 0; glyph < glyphCount; glyph += 1) {
         LEGlyphID thisGlyph = glyphStorage[glyph];
-        const LookupSegment *lookupSegment = segmentArrayLookupTable->lookupSegment(segments, thisGlyph);
+        const LookupSegment *lookupSegment = segmentArrayLookupTable->lookupSegment(segmentArrayLookupTable, segments, thisGlyph, success);
 
         if (lookupSegment != NULL)  {
             TTGlyphID firstGlyph = SWAPW(lookupSegment->firstGlyph);
             le_int16  offset = SWAPW(lookupSegment->value);
 
             if (offset != 0) {
-                TTGlyphID  *glyphArray = (TTGlyphID *) ((char *) subtableHeader + offset);
-                TTGlyphID   newGlyph   = SWAPW(glyphArray[LE_GET_GLYPH(thisGlyph) - firstGlyph]);
-
-                glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+              LEReferenceToArrayOf<TTGlyphID> glyphArray(subtableHeader, success, offset, LE_UNBOUNDED_ARRAY);
+              TTGlyphID   newGlyph   = SWAPW(glyphArray(LE_GET_GLYPH(thisGlyph) - firstGlyph, success));
+              glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
             }
         }
     }
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.h	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,9 +50,9 @@
 class SegmentArrayProcessor : public NonContextualGlyphSubstitutionProcessor
 {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage);
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
-    SegmentArrayProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    SegmentArrayProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
     virtual ~SegmentArrayProcessor();
 
@@ -74,7 +74,7 @@
     SegmentArrayProcessor();
 
 protected:
-    const SegmentArrayLookupTable *segmentArrayLookupTable;
+    LEReferenceTo<SegmentArrayLookupTable> segmentArrayLookupTable;
 
 };
 
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,84 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "SegmentArrayProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SegmentArrayProcessor2)
+
+SegmentArrayProcessor2::SegmentArrayProcessor2()
+{
+}
+
+SegmentArrayProcessor2::SegmentArrayProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor2(morphSubtableHeader, success)
+{
+  const LEReferenceTo<NonContextualGlyphSubstitutionHeader2> header(morphSubtableHeader, success);
+  segmentArrayLookupTable = LEReferenceTo<SegmentArrayLookupTable>(morphSubtableHeader,  success, &header->table); // don't parent to 'header' as it is on the stack
+}
+
+SegmentArrayProcessor2::~SegmentArrayProcessor2()
+{
+}
+
+void SegmentArrayProcessor2::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+    const LookupSegment *segments = segmentArrayLookupTable->segments;
+    le_int32 glyphCount = glyphStorage.getGlyphCount();
+    le_int32 glyph;
+
+    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+        LEGlyphID thisGlyph = glyphStorage[glyph];
+        const LookupSegment *lookupSegment = segmentArrayLookupTable->lookupSegment(segmentArrayLookupTable, segments, thisGlyph, success);
+
+        if (lookupSegment != NULL)  {
+            TTGlyphID firstGlyph = SWAPW(lookupSegment->firstGlyph);
+            le_int16  offset = SWAPW(lookupSegment->value);
+
+            if (offset != 0) {
+              TTGlyphID  *glyphArray = (TTGlyphID *) ((char *) subtableHeader.getAliasTODO() + offset);
+                TTGlyphID   newGlyph   = SWAPW(glyphArray[LE_GET_GLYPH(thisGlyph) - firstGlyph]);
+
+                glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+            }
+        }
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,82 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __SEGMENTARRAYPROCESSOR_H
+#define __SEGMENTARRAYPROCESSOR_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class SegmentArrayProcessor2 : public NonContextualGlyphSubstitutionProcessor2
+{
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    SegmentArrayProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    virtual ~SegmentArrayProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    SegmentArrayProcessor2();
+
+protected:
+    LEReferenceTo<SegmentArrayLookupTable> segmentArrayLookupTable;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.cpp	2012-08-10 10:30:37.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -46,29 +46,28 @@
 {
 }
 
-SegmentSingleProcessor::SegmentSingleProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader)
+SegmentSingleProcessor::SegmentSingleProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader, success)
 {
-    const NonContextualGlyphSubstitutionHeader *header = (const NonContextualGlyphSubstitutionHeader *) morphSubtableHeader;
-
-    segmentSingleLookupTable = (const SegmentSingleLookupTable *) &header->table;
+  LEReferenceTo<NonContextualGlyphSubstitutionHeader> header(morphSubtableHeader, success);
+  segmentSingleLookupTable = LEReferenceTo<SegmentSingleLookupTable>(morphSubtableHeader, success, (const SegmentSingleLookupTable*)&header->table);
 }
 
 SegmentSingleProcessor::~SegmentSingleProcessor()
 {
 }
 
-void SegmentSingleProcessor::process(LEGlyphStorage &glyphStorage)
+void SegmentSingleProcessor::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     const LookupSegment *segments = segmentSingleLookupTable->segments;
     le_int32 glyphCount = glyphStorage.getGlyphCount();
     le_int32 glyph;
 
-    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+    for (glyph = 0; glyph < glyphCount && LE_SUCCESS(success); glyph += 1) {
         LEGlyphID thisGlyph = glyphStorage[glyph];
-        const LookupSegment *lookupSegment = segmentSingleLookupTable->lookupSegment(segments, thisGlyph);
+        const LookupSegment *lookupSegment = segmentSingleLookupTable->lookupSegment(segmentSingleLookupTable, segments, thisGlyph, success);
 
-        if (lookupSegment != NULL) {
+        if (lookupSegment != NULL && LE_SUCCESS(success)) {
             TTGlyphID   newGlyph  = (TTGlyphID) LE_GET_GLYPH(thisGlyph) + SWAPW(lookupSegment->value);
 
             glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
--- jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.h	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,9 +50,9 @@
 class SegmentSingleProcessor : public NonContextualGlyphSubstitutionProcessor
 {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage);
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
-    SegmentSingleProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    SegmentSingleProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
     virtual ~SegmentSingleProcessor();
 
@@ -74,7 +74,7 @@
     SegmentSingleProcessor();
 
 protected:
-    const SegmentSingleLookupTable *segmentSingleLookupTable;
+    LEReferenceTo<SegmentSingleLookupTable> segmentSingleLookupTable;
 
 };
 
--- jdk/src/share/native/sun/font/layout/SegmentSingleProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SegmentSingleProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,79 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "SegmentSingleProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SegmentSingleProcessor2)
+
+SegmentSingleProcessor2::SegmentSingleProcessor2()
+{
+}
+
+SegmentSingleProcessor2::SegmentSingleProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor2(morphSubtableHeader, success)
+{
+  const LEReferenceTo<NonContextualGlyphSubstitutionHeader2> header(morphSubtableHeader, success);
+
+  segmentSingleLookupTable = LEReferenceTo<SegmentSingleLookupTable>(morphSubtableHeader, success, &header->table);
+}
+
+SegmentSingleProcessor2::~SegmentSingleProcessor2()
+{
+}
+
+void SegmentSingleProcessor2::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+    const LookupSegment *segments = segmentSingleLookupTable->segments;
+    le_int32 glyphCount = glyphStorage.getGlyphCount();
+    le_int32 glyph;
+
+    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+        LEGlyphID thisGlyph = glyphStorage[glyph];
+        const LookupSegment *lookupSegment = segmentSingleLookupTable->lookupSegment(segmentSingleLookupTable, segments, thisGlyph, success);
+
+        if (lookupSegment != NULL && LE_SUCCESS(success)) {
+            TTGlyphID   newGlyph  = (TTGlyphID) LE_GET_GLYPH(thisGlyph) + SWAPW(lookupSegment->value);
+
+            glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+        }
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/SegmentSingleProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SegmentSingleProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,82 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __SEGMENTSINGLEPROCESSOR_H
+#define __SEGMENTSINGLEPROCESSOR_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class SegmentSingleProcessor2 : public NonContextualGlyphSubstitutionProcessor2
+{
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    SegmentSingleProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    virtual ~SegmentSingleProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    SegmentSingleProcessor2();
+
+protected:
+    LEReferenceTo<SegmentSingleLookupTable> segmentSingleLookupTable;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/ShapingTypeData.cpp	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ShapingTypeData.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -122,4 +122,6 @@
     0x00, 0x05, 0xFE, 0xFF, 0xFE, 0xFF, 0x00, 0x05, 0xFF, 0xF9, 0xFF, 0xFB, 0x00, 0x05
 };
 
+const size_t ArabicShaping::shapingTypeTableLen = sizeof(shapingTypeTable)/sizeof(shapingTypeTable[0]);
+
 U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.cpp	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -46,29 +46,29 @@
 {
 }
 
-SimpleArrayProcessor::SimpleArrayProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader)
+SimpleArrayProcessor::SimpleArrayProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader, success)
 {
-    const NonContextualGlyphSubstitutionHeader *header = (const NonContextualGlyphSubstitutionHeader *) morphSubtableHeader;
-
-    simpleArrayLookupTable = (const SimpleArrayLookupTable *) &header->table;
+  LEReferenceTo<NonContextualGlyphSubstitutionHeader> header(morphSubtableHeader, success);
+  simpleArrayLookupTable = LEReferenceTo<SimpleArrayLookupTable>(morphSubtableHeader, success, (const SimpleArrayLookupTable*)&header->table);
 }
 
 SimpleArrayProcessor::~SimpleArrayProcessor()
 {
 }
 
-void SimpleArrayProcessor::process(LEGlyphStorage &glyphStorage)
+void SimpleArrayProcessor::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     le_int32 glyphCount = glyphStorage.getGlyphCount();
     le_int32 glyph;
 
-    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+    LEReferenceToArrayOf<LookupValue> valueArray(simpleArrayLookupTable, success, (const LookupValue*)&simpleArrayLookupTable->valueArray, LE_UNBOUNDED_ARRAY);
+
+    for (glyph = 0; LE_SUCCESS(success) && (glyph < glyphCount); glyph += 1) {
         LEGlyphID thisGlyph = glyphStorage[glyph];
         if (LE_GET_GLYPH(thisGlyph) < 0xFFFF) {
-            TTGlyphID newGlyph = SWAPW(simpleArrayLookupTable->valueArray[LE_GET_GLYPH(thisGlyph)]);
-
-            glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+          TTGlyphID newGlyph = SWAPW(valueArray.getObject(LE_GET_GLYPH(thisGlyph),success));
+          glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
         }
     }
 }
--- jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.h	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,9 +50,9 @@
 class SimpleArrayProcessor : public NonContextualGlyphSubstitutionProcessor
 {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage);
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
-    SimpleArrayProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    SimpleArrayProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
     virtual ~SimpleArrayProcessor();
 
@@ -74,7 +74,7 @@
     SimpleArrayProcessor();
 
 protected:
-    const SimpleArrayLookupTable *simpleArrayLookupTable;
+    LEReferenceTo<SimpleArrayLookupTable> simpleArrayLookupTable;
 
 };
 
--- jdk/src/share/native/sun/font/layout/SimpleArrayProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SimpleArrayProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,78 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "SimpleArrayProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SimpleArrayProcessor2)
+
+SimpleArrayProcessor2::SimpleArrayProcessor2()
+{
+}
+
+SimpleArrayProcessor2::SimpleArrayProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor2(morphSubtableHeader, success)
+{
+  const LEReferenceTo<NonContextualGlyphSubstitutionHeader2> header(morphSubtableHeader, success);
+
+  simpleArrayLookupTable = LEReferenceTo<SimpleArrayLookupTable>(morphSubtableHeader, success, &header->table);
+  valueArray = LEReferenceToArrayOf<LookupValue>(morphSubtableHeader, success, &simpleArrayLookupTable->valueArray[0], LE_UNBOUNDED_ARRAY);
+}
+
+SimpleArrayProcessor2::~SimpleArrayProcessor2()
+{
+}
+
+void SimpleArrayProcessor2::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+    if (LE_FAILURE(success)) return;
+    le_int32 glyphCount = glyphStorage.getGlyphCount();
+    le_int32 glyph;
+
+    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+        LEGlyphID thisGlyph = glyphStorage[glyph];
+        if (LE_GET_GLYPH(thisGlyph) < 0xFFFF) {
+          TTGlyphID newGlyph = SWAPW(valueArray(LE_GET_GLYPH(thisGlyph),success));
+
+            glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+        }
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/SimpleArrayProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SimpleArrayProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,83 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __SIMPLEARRAYPROCESSOR2_H
+#define __SIMPLEARRAYPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class SimpleArrayProcessor2 : public NonContextualGlyphSubstitutionProcessor2
+{
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    SimpleArrayProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    virtual ~SimpleArrayProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    SimpleArrayProcessor2();
+
+protected:
+    LEReferenceTo<SimpleArrayLookupTable> simpleArrayLookupTable;
+    LEReferenceToArrayOf<LookupValue> valueArray;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.cpp	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -40,7 +40,7 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 SinglePositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 SinglePositioningSubtable::process(const LEReferenceTo<SinglePositioningSubtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     switch(SWAPW(subtableFormat))
     {
@@ -49,16 +49,16 @@
 
     case 1:
     {
-        const SinglePositioningFormat1Subtable *subtable = (const SinglePositioningFormat1Subtable *) this;
+      const LEReferenceTo<SinglePositioningFormat1Subtable> subtable(base, success, (const SinglePositioningFormat1Subtable *) this);
 
-        return subtable->process(glyphIterator, fontInstance);
+      return subtable->process(subtable, glyphIterator, fontInstance, success);
     }
 
     case 2:
     {
-        const SinglePositioningFormat2Subtable *subtable = (const SinglePositioningFormat2Subtable *) this;
+      const LEReferenceTo<SinglePositioningFormat2Subtable> subtable(base, success, (const SinglePositioningFormat2Subtable *) this);
 
-        return subtable->process(glyphIterator, fontInstance);
+      return subtable->process(subtable, glyphIterator, fontInstance, success);
     }
 
     default:
@@ -66,10 +66,10 @@
     }
 }
 
-le_uint32 SinglePositioningFormat1Subtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 SinglePositioningFormat1Subtable::process(const LEReferenceTo<SinglePositioningFormat1Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, glyph, success);
 
     if (coverageIndex >= 0) {
         valueRecord.adjustPosition(SWAPW(valueFormat), (const char *) this, *glyphIterator, fontInstance);
@@ -80,10 +80,10 @@
     return 0;
 }
 
-le_uint32 SinglePositioningFormat2Subtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
+le_uint32 SinglePositioningFormat2Subtable::process(const LEReferenceTo<SinglePositioningFormat2Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int16 coverageIndex = (le_int16) getGlyphCoverage(glyph);
+    le_int16 coverageIndex = (le_int16) getGlyphCoverage(base, glyph, success);
 
     if (coverageIndex >= 0) {
         valueRecordArray[0].adjustPosition(coverageIndex, SWAPW(valueFormat), (const char *) this, *glyphIterator, fontInstance);
--- jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.h	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -48,7 +48,7 @@
 
 struct SinglePositioningSubtable : GlyphPositioningSubtable
 {
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<SinglePositioningSubtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 };
 
 struct SinglePositioningFormat1Subtable : SinglePositioningSubtable
@@ -56,7 +56,7 @@
     ValueFormat valueFormat;
     ValueRecord valueRecord;
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<SinglePositioningFormat1Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 };
 
 struct SinglePositioningFormat2Subtable : SinglePositioningSubtable
@@ -65,8 +65,9 @@
     le_uint16   valueCount;
     ValueRecord valueRecordArray[ANY_NUMBER];
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
+    le_uint32  process(const LEReferenceTo<SinglePositioningFormat2Subtable> &base, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance, LEErrorCode &success) const;
 };
+LE_VAR_ARRAY(SinglePositioningFormat2Subtable, valueRecordArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.cpp	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -39,7 +39,7 @@
 
 U_NAMESPACE_BEGIN
 
-le_uint32 SingleSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
+le_uint32 SingleSubstitutionSubtable::process(const LEReferenceTo<SingleSubstitutionSubtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter) const
 {
     switch(SWAPW(subtableFormat))
     {
@@ -48,16 +48,16 @@
 
     case 1:
     {
-        const SingleSubstitutionFormat1Subtable *subtable = (const SingleSubstitutionFormat1Subtable *) this;
+      const LEReferenceTo<SingleSubstitutionFormat1Subtable> subtable(base, success, (const SingleSubstitutionFormat1Subtable *) this);
 
-        return subtable->process(glyphIterator, filter);
+      return subtable->process(subtable, glyphIterator, success, filter);
     }
 
     case 2:
     {
-        const SingleSubstitutionFormat2Subtable *subtable = (const SingleSubstitutionFormat2Subtable *) this;
+      const LEReferenceTo<SingleSubstitutionFormat2Subtable> subtable(base, success, (const SingleSubstitutionFormat2Subtable *) this);
 
-        return subtable->process(glyphIterator, filter);
+      return subtable->process(subtable, glyphIterator, success, filter);
     }
 
     default:
@@ -65,10 +65,10 @@
     }
 }
 
-le_uint32 SingleSubstitutionFormat1Subtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
+le_uint32 SingleSubstitutionFormat1Subtable::process(const LEReferenceTo<SingleSubstitutionFormat1Subtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, glyph, success);
 
     if (coverageIndex >= 0) {
         TTGlyphID substitute = ((TTGlyphID) LE_GET_GLYPH(glyph)) + SWAPW(deltaGlyphID);
@@ -83,10 +83,10 @@
     return 0;
 }
 
-le_uint32 SingleSubstitutionFormat2Subtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
+le_uint32 SingleSubstitutionFormat2Subtable::process(const LEReferenceTo<SingleSubstitutionFormat2Subtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
-    le_int32 coverageIndex = getGlyphCoverage(glyph);
+    le_int32 coverageIndex = getGlyphCoverage(base, glyph, success);
 
     if (coverageIndex >= 0) {
         TTGlyphID substitute = SWAPW(substituteArray[coverageIndex]);
--- jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.h	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.h	2013-05-05 09:38:38.000000000 -0700
@@ -47,14 +47,14 @@
 
 struct SingleSubstitutionSubtable : GlyphSubstitutionSubtable
 {
-    le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
+    le_uint32  process(const LEReferenceTo<SingleSubstitutionSubtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter = NULL) const;
 };
 
 struct SingleSubstitutionFormat1Subtable : SingleSubstitutionSubtable
 {
     le_int16   deltaGlyphID;
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
+    le_uint32  process(const LEReferenceTo<SingleSubstitutionFormat1Subtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter = NULL) const;
 };
 
 struct SingleSubstitutionFormat2Subtable : SingleSubstitutionSubtable
@@ -62,8 +62,9 @@
     le_uint16  glyphCount;
     TTGlyphID  substituteArray[ANY_NUMBER];
 
-    le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
+    le_uint32  process(const LEReferenceTo<SingleSubstitutionFormat2Subtable> &base, GlyphIterator *glyphIterator, LEErrorCode &success, const LEGlyphFilter *filter = NULL) const;
 };
+LE_VAR_ARRAY(SingleSubstitutionFormat2Subtable, substituteArray)
 
 U_NAMESPACE_END
 #endif
--- jdk/src/share/native/sun/font/layout/SingleTableProcessor.cpp	2012-08-10 10:30:38.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SingleTableProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -46,26 +46,25 @@
 {
 }
 
-SingleTableProcessor::SingleTableProcessor(const MorphSubtableHeader *moprhSubtableHeader)
-  : NonContextualGlyphSubstitutionProcessor(moprhSubtableHeader)
+SingleTableProcessor::SingleTableProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader, success)
 {
-    const NonContextualGlyphSubstitutionHeader *header = (const NonContextualGlyphSubstitutionHeader *) moprhSubtableHeader;
-
-    singleTableLookupTable = (const SingleTableLookupTable *) &header->table;
+  LEReferenceTo<NonContextualGlyphSubstitutionHeader> header(morphSubtableHeader, success);
+  singleTableLookupTable = LEReferenceTo<SingleTableLookupTable>(morphSubtableHeader, success, (const SingleTableLookupTable*)&header->table);
 }
 
 SingleTableProcessor::~SingleTableProcessor()
 {
 }
 
-void SingleTableProcessor::process(LEGlyphStorage &glyphStorage)
+void SingleTableProcessor::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     const LookupSingle *entries = singleTableLookupTable->entries;
     le_int32 glyph;
     le_int32 glyphCount = glyphStorage.getGlyphCount();
 
     for (glyph = 0; glyph < glyphCount; glyph += 1) {
-        const LookupSingle *lookupSingle = singleTableLookupTable->lookupSingle(entries, glyphStorage[glyph]);
+      const LookupSingle *lookupSingle = singleTableLookupTable->lookupSingle(singleTableLookupTable, entries, glyphStorage[glyph], success);
 
         if (lookupSingle != NULL) {
             glyphStorage[glyph] = SWAPW(lookupSingle->value);
--- jdk/src/share/native/sun/font/layout/SingleTableProcessor.h	2012-08-10 10:30:39.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SingleTableProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,9 +50,9 @@
 class SingleTableProcessor : public NonContextualGlyphSubstitutionProcessor
 {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage);
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
-    SingleTableProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    SingleTableProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
     virtual ~SingleTableProcessor();
 
@@ -74,7 +74,7 @@
     SingleTableProcessor();
 
 protected:
-    const SingleTableLookupTable *singleTableLookupTable;
+    LEReferenceTo<SingleTableLookupTable> singleTableLookupTable;
 
 };
 
--- jdk/src/share/native/sun/font/layout/SingleTableProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SingleTableProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,77 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "SingleTableProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SingleTableProcessor2)
+
+SingleTableProcessor2::SingleTableProcessor2()
+{
+}
+
+SingleTableProcessor2::SingleTableProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor2(morphSubtableHeader, success)
+{
+  const LEReferenceTo<NonContextualGlyphSubstitutionHeader2> header(morphSubtableHeader, success);
+
+    singleTableLookupTable = LEReferenceTo<SingleTableLookupTable>(morphSubtableHeader, success, &header->table);
+}
+
+SingleTableProcessor2::~SingleTableProcessor2()
+{
+}
+
+void SingleTableProcessor2::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+  if(LE_FAILURE(success)) return;
+    const LookupSingle *entries = singleTableLookupTable->entries;
+    le_int32 glyph;
+    le_int32 glyphCount = glyphStorage.getGlyphCount();
+
+    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+      const LookupSingle *lookupSingle = singleTableLookupTable->lookupSingle(singleTableLookupTable, entries, glyphStorage[glyph], success);
+
+        if (lookupSingle != NULL) {
+            glyphStorage[glyph] = SWAPW(lookupSingle->value);
+        }
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/SingleTableProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SingleTableProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,82 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __SINGLETABLEPROCESSOR2_H
+#define __SINGLETABLEPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class SingleTableProcessor2 : public NonContextualGlyphSubstitutionProcessor2
+{
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    SingleTableProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    virtual ~SingleTableProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    SingleTableProcessor2();
+
+protected:
+    LEReferenceTo<SingleTableLookupTable> singleTableLookupTable;
+
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp	2012-08-10 10:30:39.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -44,17 +44,18 @@
 {
 }
 
-StateTableProcessor::StateTableProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : SubtableProcessor(morphSubtableHeader)
+StateTableProcessor::StateTableProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : SubtableProcessor(morphSubtableHeader, success), stateTableHeader(morphSubtableHeader, success),
+    stHeader(stateTableHeader, success, (const StateTableHeader*)&stateTableHeader->stHeader)
 {
-    stateTableHeader = (const MorphStateTableHeader *) morphSubtableHeader;
-
+  if(LE_FAILURE(success)) return;
     stateSize = SWAPW(stateTableHeader->stHeader.stateSize);
     classTableOffset = SWAPW(stateTableHeader->stHeader.classTableOffset);
     stateArrayOffset = SWAPW(stateTableHeader->stHeader.stateArrayOffset);
     entryTableOffset = SWAPW(stateTableHeader->stHeader.entryTableOffset);
 
-    classTable = (const ClassTable *) ((char *) &stateTableHeader->stHeader + classTableOffset);
+    classTable = LEReferenceTo<ClassTable>(stateTableHeader, success, ((char *) &stateTableHeader->stHeader + classTableOffset));
+  if(LE_FAILURE(success)) return;
     firstGlyph = SWAPW(classTable->firstGlyph);
     lastGlyph  = firstGlyph + SWAPW(classTable->nGlyphs);
 }
@@ -63,8 +64,11 @@
 {
 }
 
-void StateTableProcessor::process(LEGlyphStorage &glyphStorage)
+void StateTableProcessor::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
+    if (LE_FAILURE(success)) return;
+    LE_STATE_PATIENCE_INIT();
+
     // Start at state 0
     // XXX: How do we know when to start at state 1?
     ByteOffset currentState = stateArrayOffset;
@@ -76,6 +80,7 @@
     beginStateTable();
 
     while (currGlyph <= glyphCount) {
+        if(LE_STATE_PATIENCE_DECR()) break; // patience exceeded.
         ClassCode classCode = classCodeOOB;
         if (currGlyph == glyphCount) {
             // XXX: How do we handle EOT vs. EOL?
@@ -90,10 +95,11 @@
             }
         }
 
-        const EntryTableIndex *stateArray = (const EntryTableIndex *) ((char *) &stateTableHeader->stHeader + currentState);
-        EntryTableIndex entryTableIndex = stateArray[(le_uint8)classCode];
-
+        LEReferenceToArrayOf<EntryTableIndex> stateArray(stHeader, success, currentState, LE_UNBOUNDED_ARRAY);
+        EntryTableIndex entryTableIndex = stateArray.getObject((le_uint8)classCode, success);
+        LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
         currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex);
+        LE_STATE_PATIENCE_INCR(currGlyph);
     }
 
     endStateTable();
--- jdk/src/share/native/sun/font/layout/StateTableProcessor.h	2012-08-10 10:30:39.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -49,7 +49,7 @@
 class StateTableProcessor : public SubtableProcessor
 {
 public:
-    void process(LEGlyphStorage &glyphStorage);
+    void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     virtual void beginStateTable() = 0;
 
@@ -58,7 +58,7 @@
     virtual void endStateTable() = 0;
 
 protected:
-    StateTableProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    StateTableProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
     virtual ~StateTableProcessor();
 
     StateTableProcessor();
@@ -68,11 +68,12 @@
     ByteOffset stateArrayOffset;
     ByteOffset entryTableOffset;
 
-    const ClassTable *classTable;
+    LEReferenceTo<ClassTable> classTable;
     TTGlyphID firstGlyph;
     TTGlyphID lastGlyph;
 
-    const MorphStateTableHeader *stateTableHeader;
+    LEReferenceTo<MorphStateTableHeader> stateTableHeader;
+    LEReferenceTo<StateTableHeader> stHeader; // for convenience
 
 private:
     StateTableProcessor(const StateTableProcessor &other); // forbid copying of this class
--- jdk/src/share/native/sun/font/layout/StateTableProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,236 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "StateTables.h"
+#include "MorphStateTables.h"
+#include "SubtableProcessor2.h"
+#include "StateTableProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+#include "LookupTables.h"
+
+U_NAMESPACE_BEGIN
+
+StateTableProcessor2::StateTableProcessor2()
+{
+}
+
+StateTableProcessor2::StateTableProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : SubtableProcessor2(morphSubtableHeader, success), stateTableHeader(morphSubtableHeader, success),
+    stHeader(stateTableHeader, success, (const StateTableHeader2*)&stateTableHeader->stHeader),
+    nClasses(0), classTableOffset(0), stateArrayOffset(0), entryTableOffset(0), classTable(), format(0),
+    stateArray()
+{
+  if (LE_FAILURE(success)) {
+    return;
+  }
+  nClasses = SWAPL(stHeader->nClasses);
+  classTableOffset = SWAPL(stHeader->classTableOffset);
+  stateArrayOffset = SWAPL(stHeader->stateArrayOffset);
+  entryTableOffset = SWAPL(stHeader->entryTableOffset);
+
+  classTable = LEReferenceTo<LookupTable>(stHeader, success, classTableOffset);
+  format = SWAPW(classTable->format);
+
+  stateArray = LEReferenceToArrayOf<EntryTableIndex2>(stHeader, success, stateArrayOffset, LE_UNBOUNDED_ARRAY);
+}
+
+StateTableProcessor2::~StateTableProcessor2()
+{
+}
+
+void StateTableProcessor2::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+    if (LE_FAILURE(success)) return;
+    // Start at state 0
+    // XXX: How do we know when to start at state 1?
+    le_uint16 currentState = 0;
+    le_int32 glyphCount = glyphStorage.getGlyphCount();
+
+    LE_STATE_PATIENCE_INIT();
+
+    le_int32 currGlyph = 0;
+    if ((coverage & scfReverse2) != 0) {  // process glyphs in descending order
+        currGlyph = glyphCount - 1;
+        dir = -1;
+    } else {
+        dir = 1;
+    }
+
+    beginStateTable();
+    switch (format) {
+        case ltfSimpleArray: {
+#ifdef TEST_FORMAT
+          LEReferenceTo<SimpleArrayLookupTable> lookupTable0(classTable, success);
+          if(LE_FAILURE(success)) break;
+            while ((dir == 1 && currGlyph <= glyphCount) || (dir == -1 && currGlyph >= -1)) {
+                if (LE_FAILURE(success)) break;
+                if (LE_STATE_PATIENCE_DECR()) {
+                  LE_DEBUG_BAD_FONT("patience exceeded - state table not moving")
+                  break; // patience exceeded.
+                }
+                LookupValue classCode = classCodeOOB;
+                if (currGlyph == glyphCount || currGlyph == -1) {
+                    // XXX: How do we handle EOT vs. EOL?
+                    classCode = classCodeEOT;
+                } else {
+                    LEGlyphID gid = glyphStorage[currGlyph];
+                    TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
+
+                    if (glyphCode == 0xFFFF) {
+                        classCode = classCodeDEL;
+                    } else {
+                        classCode = SWAPW(lookupTable0->valueArray[gid]);
+                    }
+                }
+                EntryTableIndex2 entryTableIndex = SWAPW(stateArray(classCode + currentState * nClasses, success));
+                LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
+                currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex); // return a zero-based index instead of a byte offset
+                LE_STATE_PATIENCE_INCR(currGlyph);
+            }
+#endif
+            break;
+        }
+        case ltfSegmentSingle: {
+          LEReferenceTo<SegmentSingleLookupTable> lookupTable2(classTable, success);
+          if(LE_FAILURE(success)) break;
+            while ((dir == 1 && currGlyph <= glyphCount) || (dir == -1 && currGlyph >= -1)) {
+                if (LE_FAILURE(success)) break;
+                if (LE_STATE_PATIENCE_DECR()) {
+                  LE_DEBUG_BAD_FONT("patience exceeded  - state table not moving")
+                  break; // patience exceeded.
+                }
+                LookupValue classCode = classCodeOOB;
+                if (currGlyph == glyphCount || currGlyph == -1) {
+                    // XXX: How do we handle EOT vs. EOL?
+                    classCode = classCodeEOT;
+                } else {
+                    LEGlyphID gid = glyphStorage[currGlyph];
+                    TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
+
+                    if (glyphCode == 0xFFFF) {
+                        classCode = classCodeDEL;
+                    } else {
+                      const LookupSegment *segment =
+                        lookupTable2->lookupSegment(lookupTable2, lookupTable2->segments, gid, success);
+                        if (segment != NULL && LE_SUCCESS(success)) {
+                            classCode = SWAPW(segment->value);
+                        }
+                    }
+                }
+                EntryTableIndex2 entryTableIndex = SWAPW(stateArray(classCode + currentState * nClasses,success));
+                LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
+                currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex, success);
+                LE_STATE_PATIENCE_INCR(currGlyph);
+            }
+            break;
+        }
+        case ltfSegmentArray: {
+          //printf("Lookup Table Format4: specific interpretation needed!\n");
+            break;
+        }
+        case ltfSingleTable: {
+            LEReferenceTo<SingleTableLookupTable> lookupTable6(classTable, success);
+            while ((dir == 1 && currGlyph <= glyphCount) || (dir == -1 && currGlyph >= -1)) {
+                if (LE_FAILURE(success)) break;
+                if (LE_STATE_PATIENCE_DECR()) {
+                  LE_DEBUG_BAD_FONT("patience exceeded - state table not moving")
+                  break; // patience exceeded.
+                }
+                LookupValue classCode = classCodeOOB;
+                if (currGlyph == glyphCount || currGlyph == -1) {
+                    // XXX: How do we handle EOT vs. EOL?
+                    classCode = classCodeEOT;
+                } else if(currGlyph > glyphCount) {
+                  // note if > glyphCount, we've run off the end (bad font)
+                  currGlyph = glyphCount;
+                  classCode = classCodeEOT;
+                } else {
+                    LEGlyphID gid = glyphStorage[currGlyph];
+                    TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
+
+                    if (glyphCode == 0xFFFF) {
+                        classCode = classCodeDEL;
+                    } else {
+                      const LookupSingle *segment = lookupTable6->lookupSingle(lookupTable6, lookupTable6->entries, gid, success);
+                        if (segment != NULL) {
+                            classCode = SWAPW(segment->value);
+                        }
+                    }
+                }
+                EntryTableIndex2 entryTableIndex = SWAPW(stateArray(classCode + currentState * nClasses, success));
+                LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
+                currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex, success);
+                LE_STATE_PATIENCE_INCR(currGlyph);
+            }
+            break;
+        }
+        case ltfTrimmedArray: {
+            LEReferenceTo<TrimmedArrayLookupTable> lookupTable8(classTable, success);
+            if (LE_FAILURE(success)) break;
+            TTGlyphID firstGlyph = SWAPW(lookupTable8->firstGlyph);
+            TTGlyphID lastGlyph  = firstGlyph + SWAPW(lookupTable8->glyphCount);
+
+            while ((dir == 1 && currGlyph <= glyphCount) || (dir == -1 && currGlyph >= -1)) {
+                if(LE_STATE_PATIENCE_DECR()) {
+                  LE_DEBUG_BAD_FONT("patience exceeded - state table not moving")
+                  break; // patience exceeded.
+                }
+
+                LookupValue classCode = classCodeOOB;
+                if (currGlyph == glyphCount || currGlyph == -1) {
+                    // XXX: How do we handle EOT vs. EOL?
+                    classCode = classCodeEOT;
+                } else {
+                    TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(glyphStorage[currGlyph]);
+                    if (glyphCode == 0xFFFF) {
+                        classCode = classCodeDEL;
+                    } else if ((glyphCode >= firstGlyph) && (glyphCode < lastGlyph)) {
+                        classCode = SWAPW(lookupTable8->valueArray[glyphCode - firstGlyph]);
+                    }
+                }
+                EntryTableIndex2 entryTableIndex = SWAPW(stateArray(classCode + currentState * nClasses, success));
+                LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
+                currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex, success);
+                LE_STATE_PATIENCE_INCR(currGlyph);
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    endStateTable();
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/StateTableProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,85 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __STATETABLEPROCESSOR2_H
+#define __STATETABLEPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "MorphStateTables.h"
+#include "SubtableProcessor2.h"
+#include "LookupTables.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class StateTableProcessor2 : public SubtableProcessor2
+{
+public:
+    void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    virtual void beginStateTable() = 0;
+
+    virtual le_uint16 processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex2 index, LEErrorCode &success) = 0;
+
+    virtual void endStateTable() = 0;
+
+protected:
+    StateTableProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+    virtual ~StateTableProcessor2();
+
+    StateTableProcessor2();
+
+    le_int32  dir;
+    le_uint16 format;
+    le_uint32 nClasses;
+    le_uint32 classTableOffset;
+    le_uint32 stateArrayOffset;
+    le_uint32 entryTableOffset;
+
+    LEReferenceTo<LookupTable> classTable;
+    LEReferenceToArrayOf<EntryTableIndex2> stateArray;
+    LEReferenceTo<MorphStateTableHeader2> stateTableHeader;
+    LEReferenceTo<StateTableHeader2> stHeader; // for convenience
+
+private:
+    StateTableProcessor2(const StateTableProcessor2 &other); // forbid copying of this class
+    StateTableProcessor2 &operator=(const StateTableProcessor2 &other); // forbid copying of this class
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/StateTables.h	2012-08-10 10:30:42.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/StateTables.h	2013-05-05 09:38:38.000000000 -0700
@@ -25,7 +25,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
  *
  */
 
@@ -42,6 +42,41 @@
 
 U_NAMESPACE_BEGIN
 
+
+
+
+/*
+ * State table loop detection.
+ * Detects if too many ( LE_STATE_PATIENCE_COUNT ) state changes occur without moving the glyph index 'g'.
+ *
+ * Usage (pseudocode):
+ *
+ * {
+ *   LE_STATE_PATIENCE_INIT();
+ *
+ *   int g=0; // the glyph index - expect it to be moving
+ *
+ *   for(;;) {
+ *     if(LE_STATE_PATIENCE_DECR()) { // decrements the patience counter
+ *        // ran out of patience, get out.
+ *        break;
+ *     }
+ *
+ *     LE_STATE_PATIENCE_CURR(int, g); // store the 'current'
+ *     state = newState(state,g);
+ *     g+= <something, could be zero>;
+ *     LE_STATE_PATIENCE_INCR(g);  // if g has moved, increment the patience counter. Otherwise leave it.
+ *   }
+ *
+ */
+
+#define LE_STATE_PATIENCE_COUNT 4096 /**< give up if a state table doesn't move the glyph after this many iterations */
+#define LE_STATE_PATIENCE_INIT()  le_uint32 le_patience_count = LE_STATE_PATIENCE_COUNT
+#define LE_STATE_PATIENCE_DECR()  --le_patience_count==0
+#define LE_STATE_PATIENCE_CURR(type,x)  type le_patience_curr=(x)
+#define LE_STATE_PATIENCE_INCR(x)    if((x)!=le_patience_curr) ++le_patience_count;
+
+
 struct StateTableHeader
 {
     le_int16 stateSize;
@@ -50,6 +85,14 @@
     ByteOffset entryTableOffset;
 };
 
+struct StateTableHeader2
+{
+    le_uint32 nClasses;
+    le_uint32 classTableOffset;
+    le_uint32 stateArrayOffset;
+    le_uint32 entryTableOffset;
+};
+
 enum ClassCodes
 {
     classCodeEOT = 0,
@@ -68,6 +111,7 @@
     le_uint16 nGlyphs;
     ClassCode classArray[ANY_NUMBER];
 };
+LE_VAR_ARRAY(ClassTable, classArray)
 
 enum StateNumber
 {
@@ -85,6 +129,14 @@
     le_int16    flags;
 };
 
+typedef le_uint16 EntryTableIndex2;
+
+struct StateEntry2 // same struct different interpretation
+{
+    le_uint16    newStateIndex;
+    le_uint16    flags;
+};
+
 U_NAMESPACE_END
 #endif
 
--- jdk/src/share/native/sun/font/layout/SubtableProcessor.cpp	2012-08-10 10:30:47.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SubtableProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -40,10 +40,10 @@
 {
 }
 
-SubtableProcessor::SubtableProcessor(const MorphSubtableHeader *morphSubtableHeader)
+SubtableProcessor::SubtableProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : length(0), coverage(0), subtableFeatures(0L), subtableHeader(morphSubtableHeader)
 {
-    subtableHeader = morphSubtableHeader;
-
+  if(LE_FAILURE(success)) return;
     length = SWAPW(subtableHeader->length);
     coverage = SWAPW(subtableHeader->coverage);
     subtableFeatures = SWAPL(subtableHeader->subtableFeatures);
--- jdk/src/share/native/sun/font/layout/SubtableProcessor.h	2012-08-10 10:30:47.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/SubtableProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -46,11 +46,11 @@
 
 class SubtableProcessor : public UMemory {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage) = 0;
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success) = 0;
     virtual ~SubtableProcessor();
 
 protected:
-    SubtableProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    SubtableProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
     SubtableProcessor();
 
@@ -58,7 +58,7 @@
     SubtableCoverage coverage;
     FeatureFlags subtableFeatures;
 
-    const MorphSubtableHeader *subtableHeader;
+    const LEReferenceTo<MorphSubtableHeader> subtableHeader;
 
 private:
 
--- jdk/src/share/native/sun/font/layout/SubtableProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SubtableProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,57 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+SubtableProcessor2::SubtableProcessor2()
+{
+}
+
+SubtableProcessor2::SubtableProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : subtableHeader(morphSubtableHeader, success), length(0), coverage(0), subtableFeatures(0L)
+{
+  if(LE_FAILURE(success)) return;
+
+  length = SWAPL(subtableHeader->length);
+  coverage = SWAPL(subtableHeader->coverage);
+  subtableFeatures = SWAPL(subtableHeader->subtableFeatures);
+}
+
+SubtableProcessor2::~SubtableProcessor2()
+{
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/SubtableProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/SubtableProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,70 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __SUBTABLEPROCESSOR2_H
+#define __SUBTABLEPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class SubtableProcessor2 : public UMemory {
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success) = 0;
+    virtual ~SubtableProcessor2();
+
+protected:
+    SubtableProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    SubtableProcessor2();
+
+    le_uint32 length;
+    SubtableCoverage2 coverage;
+    FeatureFlags subtableFeatures;
+
+    const LEReferenceTo<MorphSubtableHeader2> subtableHeader;
+
+private:
+
+    SubtableProcessor2(const SubtableProcessor2 &other); // forbid copying of this class
+    SubtableProcessor2 &operator=(const SubtableProcessor2 &other); // forbid copying of this class
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/ThaiLayoutEngine.cpp	2012-08-10 10:30:48.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ThaiLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -134,11 +134,10 @@
         return;
     }
 
-    if (fTypoFlags & 0x1) { /* kerning enabled */
-      static const le_uint32 kernTableTag = LE_KERN_TABLE_TAG;
-
-      KernTable kt(fFontInstance, getFontTable(kernTableTag));
-      kt.process(glyphStorage);
+    if (fTypoFlags & LE_Kerning_FEATURE_FLAG) { /* kerning enabled */
+      LETableReference kernTable(fFontInstance, LE_KERN_TABLE_TAG, success);
+      KernTable kt(kernTable, success);
+      kt.process(glyphStorage, success);
     }
 
     // default is no adjustments
--- jdk/src/share/native/sun/font/layout/TibetanLayoutEngine.cpp	2012-08-10 10:30:50.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/TibetanLayoutEngine.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -49,7 +49,7 @@
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(TibetanOpenTypeLayoutEngine)
 
 TibetanOpenTypeLayoutEngine::TibetanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                    le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success)
+                                                         le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable, success)
 {
     fFeatureMap   = TibetanReordering::getFeatureMap(fFeatureMapCount);
--- jdk/src/share/native/sun/font/layout/TibetanLayoutEngine.h	2012-08-10 10:30:51.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/TibetanLayoutEngine.h	2013-05-05 09:38:38.000000000 -0700
@@ -83,7 +83,7 @@
      * @internal
      */
     TibetanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable, LEErrorCode &success);
+                            le_int32 typoFlags, const LEReferenceTo<GlyphSubstitutionTableHeader> &gsubTable, LEErrorCode &success);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
--- jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.cpp	2012-08-10 10:30:51.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -46,22 +46,28 @@
 {
 }
 
-TrimmedArrayProcessor::TrimmedArrayProcessor(const MorphSubtableHeader *morphSubtableHeader)
-  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader)
+TrimmedArrayProcessor::TrimmedArrayProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor(morphSubtableHeader, success), firstGlyph(0), lastGlyph(0)
 {
-    const NonContextualGlyphSubstitutionHeader *header = (const NonContextualGlyphSubstitutionHeader *) morphSubtableHeader;
+  LEReferenceTo<NonContextualGlyphSubstitutionHeader> header(morphSubtableHeader, success);
 
-    trimmedArrayLookupTable = (const TrimmedArrayLookupTable *) &header->table;
-    firstGlyph = SWAPW(trimmedArrayLookupTable->firstGlyph);
-    lastGlyph = firstGlyph + SWAPW(trimmedArrayLookupTable->glyphCount);
+  if(LE_FAILURE(success)) return;
+
+  trimmedArrayLookupTable = LEReferenceTo<TrimmedArrayLookupTable>(morphSubtableHeader, success, (const TrimmedArrayLookupTable*)&header->table);
+
+  if(LE_FAILURE(success)) return;
+
+  firstGlyph = SWAPW(trimmedArrayLookupTable->firstGlyph);
+  lastGlyph = firstGlyph + SWAPW(trimmedArrayLookupTable->glyphCount);
 }
 
 TrimmedArrayProcessor::~TrimmedArrayProcessor()
 {
 }
 
-void TrimmedArrayProcessor::process(LEGlyphStorage &glyphStorage)
+void TrimmedArrayProcessor::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
+  if(LE_FAILURE(success)) return;
     le_int32 glyphCount = glyphStorage.getGlyphCount();
     le_int32 glyph;
 
--- jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.h	2012-08-10 10:30:52.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.h	2013-05-05 09:38:38.000000000 -0700
@@ -50,9 +50,9 @@
 class TrimmedArrayProcessor : public NonContextualGlyphSubstitutionProcessor
 {
 public:
-    virtual void process(LEGlyphStorage &glyphStorage);
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
-    TrimmedArrayProcessor(const MorphSubtableHeader *morphSubtableHeader);
+    TrimmedArrayProcessor(const LEReferenceTo<MorphSubtableHeader> &morphSubtableHeader, LEErrorCode &success);
 
     virtual ~TrimmedArrayProcessor();
 
@@ -76,7 +76,7 @@
 protected:
     TTGlyphID firstGlyph;
     TTGlyphID lastGlyph;
-    const TrimmedArrayLookupTable *trimmedArrayLookupTable;
+    LEReferenceTo<TrimmedArrayLookupTable> trimmedArrayLookupTable;
 
 };
 
--- jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor2.cpp	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor2.cpp	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,82 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+#include "TrimmedArrayProcessor2.h"
+#include "LEGlyphStorage.h"
+#include "LESwaps.h"
+
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(TrimmedArrayProcessor2)
+
+TrimmedArrayProcessor2::TrimmedArrayProcessor2()
+{
+}
+
+TrimmedArrayProcessor2::TrimmedArrayProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success)
+  : NonContextualGlyphSubstitutionProcessor2(morphSubtableHeader, success)
+{
+    const LEReferenceTo<NonContextualGlyphSubstitutionHeader2> header(morphSubtableHeader, success);
+
+    trimmedArrayLookupTable = LEReferenceTo<TrimmedArrayLookupTable>(morphSubtableHeader, success, &header->table);
+    firstGlyph = SWAPW(trimmedArrayLookupTable->firstGlyph);
+    lastGlyph = firstGlyph + SWAPW(trimmedArrayLookupTable->glyphCount);
+    valueArray = LEReferenceToArrayOf<LookupValue>(morphSubtableHeader, success, &trimmedArrayLookupTable->valueArray[0], LE_UNBOUNDED_ARRAY);
+}
+
+TrimmedArrayProcessor2::~TrimmedArrayProcessor2()
+{
+}
+
+void TrimmedArrayProcessor2::process(LEGlyphStorage &glyphStorage, LEErrorCode &success)
+{
+    if(LE_FAILURE(success)) return;
+    le_int32 glyphCount = glyphStorage.getGlyphCount();
+    le_int32 glyph;
+
+    for (glyph = 0; glyph < glyphCount; glyph += 1) {
+        LEGlyphID thisGlyph = glyphStorage[glyph];
+        TTGlyphID ttGlyph = (TTGlyphID) LE_GET_GLYPH(thisGlyph);
+
+        if ((ttGlyph > firstGlyph) && (ttGlyph < lastGlyph)) {
+            TTGlyphID newGlyph = SWAPW(valueArray(ttGlyph - firstGlyph, success));
+
+            glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
+        }
+    }
+}
+
+U_NAMESPACE_END
--- jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor2.h	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor2.h	2013-05-05 09:38:38.000000000 -0700
@@ -0,0 +1,84 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ *
+ * (C) Copyright IBM Corp.  and others 1998-2013 - All Rights Reserved
+ *
+ */
+
+#ifndef __TRIMMEDARRAYPROCESSOR2_H
+#define __TRIMMEDARRAYPROCESSOR2_H
+
+/**
+ * \file
+ * \internal
+ */
+
+#include "LETypes.h"
+#include "MorphTables.h"
+#include "SubtableProcessor2.h"
+#include "NonContextualGlyphSubst.h"
+#include "NonContextualGlyphSubstProc2.h"
+
+U_NAMESPACE_BEGIN
+
+class LEGlyphStorage;
+
+class TrimmedArrayProcessor2 : public NonContextualGlyphSubstitutionProcessor2
+{
+public:
+    virtual void process(LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
+    TrimmedArrayProcessor2(const LEReferenceTo<MorphSubtableHeader2> &morphSubtableHeader, LEErrorCode &success);
+
+    virtual ~TrimmedArrayProcessor2();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
+private:
+    TrimmedArrayProcessor2();
+
+protected:
+    TTGlyphID firstGlyph;
+    TTGlyphID lastGlyph;
+    LEReferenceTo<TrimmedArrayLookupTable> trimmedArrayLookupTable;
+    LEReferenceToArrayOf<LookupValue> valueArray;
+};
+
+U_NAMESPACE_END
+#endif
--- jdk/src/share/native/sun/font/layout/ValueRecords.h	2012-08-10 10:30:52.000000000 -0700
+++ jdk/src/share/native/sun/font/layout/ValueRecords.h	2013-05-05 09:38:38.000000000 -0700
@@ -64,6 +64,7 @@
     static le_int16    getFieldCount(ValueFormat valueFormat);
     static le_int16    getFieldIndex(ValueFormat valueFormat, ValueRecordField field);
 };
+LE_VAR_ARRAY(ValueRecord, values)
 
 enum ValueRecordFields
 {
--- jdk/src/share/native/sun/font/sunFont.c	2012-08-10 10:30:52.000000000 -0700
+++ jdk/src/share/native/sun/font/sunFont.c	2013-05-05 09:38:38.000000000 -0700
@@ -320,22 +320,20 @@
 JNIEXPORT TTLayoutTableCache* newLayoutTableCache() {
   TTLayoutTableCache* ltc = calloc(1, sizeof(TTLayoutTableCache));
   if (ltc) {
-    ltc->gsub_len = -1;
-    ltc->gpos_len = -1;
-    ltc->gdef_len = -1;
-    ltc->mort_len = -1;
-    ltc->kern_len = -1;
+    int i;
+    for(i=0;i<LAYOUTCACHE_ENTRIES;i++) {
+      ltc->entries[i].len = -1;
+    }
   }
   return ltc;
 }
 
 JNIEXPORT void freeLayoutTableCache(TTLayoutTableCache* ltc) {
   if (ltc) {
-    if (ltc->gsub) free(ltc->gsub);
-    if (ltc->gpos) free(ltc->gpos);
-    if (ltc->gdef) free(ltc->gdef);
-    if (ltc->mort) free(ltc->mort);
-    if (ltc->kern) free(ltc->kern);
+    int i;
+    for(i=0;i<LAYOUTCACHE_ENTRIES;i++) {
+      if(ltc->entries[i].ptr) free (ltc->entries[i].ptr);
+    }
     if (ltc->kernPairs) free(ltc->kernPairs);
     free(ltc);
   }
--- jdk/src/share/native/sun/java2d/opengl/OGLBlitLoops.c	2012-08-10 10:31:05.000000000 -0700
+++ jdk/src/share/native/sun/java2d/opengl/OGLBlitLoops.c	2013-05-05 09:38:38.000000000 -0700
@@ -393,16 +393,7 @@
                    OGLSDOps *dstOps,
                    jint dx1, jint dy1, jint dx2, jint dy2)
 {
-    jboolean adjustAlpha = (pf != NULL && !pf->hasAlpha);
     j2d_glBindTexture(dstOps->textureTarget, dstOps->textureID);
-
-    if (adjustAlpha) {
-        // if the source surface does not have an alpha channel,
-        // we need to ensure that the alpha values are forced to 1.0f
-        j2d_glPixelTransferf(GL_ALPHA_SCALE, 0.0f);
-        j2d_glPixelTransferf(GL_ALPHA_BIAS, 1.0f);
-    }
-
     // in case pixel stride is not a multiple of scanline stride the copy
     // has to be done line by line (see 6207877)
     if (srcInfo->scanStride % srcInfo->pixelStride != 0) {
@@ -422,11 +413,6 @@
                             dx1, dy1, dx2-dx1, dy2-dy1,
                             pf->format, pf->type, srcInfo->rasBase);
     }
-    if (adjustAlpha) {
-        // restore scale/bias to their original values
-        j2d_glPixelTransferf(GL_ALPHA_SCALE, 1.0f);
-        j2d_glPixelTransferf(GL_ALPHA_BIAS, 0.0f);
-    }
 }
 
 /**
--- jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2012-08-10 10:31:05.000000000 -0700
+++ jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2013-05-05 09:38:38.000000000 -0700
@@ -26,7 +26,7 @@
 #ifndef OGLFuncs_h_Included
 #define OGLFuncs_h_Included
 
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #include <dlfcn.h>
 #endif
 #include "jni.h"
--- jdk/src/solaris/back/util_md.h	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/back/util_md.h	2013-05-05 09:38:40.000000000 -0700
@@ -51,7 +51,7 @@
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
--- jdk/src/solaris/bin/ergo.c	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/bin/ergo.c	2013-05-05 09:38:39.000000000 -0700
@@ -100,6 +100,27 @@
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+#if !defined(MACOSX) && defined(_ALLBSD_SOURCE)
+  uint64_t result;
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+# define UINT64_FORMAT "%" PRIu64
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+       physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  JLI_TraceLauncher("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  return result;
+#else /* !_ALLBSD_SOURCE */
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
   const uint64_t result    = pages * page_size;
@@ -110,4 +131,5 @@
           "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   return result;
+#endif
 }
--- jdk/src/solaris/bin/ergo.h	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/bin/ergo.h	2013-05-05 09:38:39.000000000 -0700
@@ -33,6 +33,10 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
 
 #include "java.h"
 
--- jdk/src/solaris/bin/ergo_i586.c	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/bin/ergo_i586.c	2013-05-05 09:38:39.000000000 -0700
@@ -106,7 +106,7 @@
 
 #endif /* __solaris__ */
 
-#ifdef __linux__
+#if !defined(MACOSX) && (defined(__linux__) || defined(_ALLBSD_SOURCE))
 
 /*
  * A utility method for asking the CPU about itself.
@@ -171,6 +171,12 @@
 #endif /* _LP64 */
 }
 
+#ifdef __linux__
+#define OSNAMEPREFIX "linux_"
+#else
+#define OSNAMEPREFIX "bsd_"
+#endif
+
 /* The definition of a server-class machine for linux-i586 */
 jboolean
 ServerClassMachineImpl(void) {
@@ -193,11 +199,11 @@
       result = JNI_TRUE;
     }
   }
-  JLI_TraceLauncher("linux_" LIBARCHNAME "_ServerClassMachine: %s\n",
+  JLI_TraceLauncher(OSNAMEPREFIX LIBARCHNAME "_ServerClassMachine: %s\n",
            (result == JNI_TRUE ? "true" : "false"));
   return result;
 }
-#endif /* __linux__ */
+#endif /* !MACOSX && (__linux__ || _ALLBSD_SOURCE) */
 
 /*
  * Routines shared by solaris-i586 and linux-i586.
@@ -308,6 +314,15 @@
 /* Compute the number of physical processors, not logical processors */
 static unsigned long
 physical_processors(void) {
+#if !defined(MACOSX) && defined(_ALLBSD_SOURCE)
+  unsigned long result;
+  int name[2] = { CTL_HW, HW_NCPU };
+  size_t rlen = sizeof(result);
+
+  if (sysctl(name, 2, &result, &rlen, NULL, 0) == -1)
+       result = 1;
+  return result;
+#else
   const long sys_processors = sysconf(_SC_NPROCESSORS_CONF);
   unsigned long result      = sys_processors;
 
@@ -320,4 +335,5 @@
   }
   JLI_TraceLauncher("physical processors: %lu\n", result);
   return result;
+#endif
 }
--- jdk/src/solaris/bin/java_md_common.c	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/bin/java_md_common.c	2013-05-05 09:38:39.000000000 -0700
@@ -502,3 +502,19 @@
    return findBootClass(env, classname);
 }
 
+StdArg
+*JLI_GetStdArgs()
+{
+    return NULL;
+}
+
+int
+JLI_GetStdArgc() {
+    return 0;
+}
+
+jobjectArray
+CreateApplicationArgs(JNIEnv *env, char **strv, int argc)
+{
+    return NewPlatformStringArray(env, strv, argc);
+}
--- jdk/src/solaris/bin/java_md_solinux.c	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/bin/java_md_solinux.c	2013-05-05 09:38:39.000000000 -0700
@@ -951,6 +951,19 @@
     return exec_path;
 }
 
+#if !defined(MACOSX) && defined(_ALLBSD_SOURCE)
+/*
+ * BSD's implementation of CounterGet()
+ */
+int64_t
+CounterGet()
+{
+       struct timeval tv;
+       gettimeofday(&tv, NULL);
+       return (tv.tv_sec * 1000) + tv.tv_usec;
+}
+#endif
+
 /* --- Splash Screen shared library support --- */
 static const char* SPLASHSCREEN_SO = JNI_LIB_NAME("splashscreen");
 static void* hSplashLib = NULL;
@@ -982,18 +995,7 @@
 int
 ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
     int rslt;
-#ifdef __solaris__
-    thread_t tid;
-    long flags = 0;
-    if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {
-      void * tmp;
-      thr_join(tid, NULL, &tmp);
-      rslt = (int)tmp;
-    } else {
-      /* See below. Continue in current thread if thr_create() failed */
-      rslt = continuation(args);
-    }
-#else /* ! __solaris__ */
+#if !defined(MACOSX) && (defined(__linux__) || defined(_ALLBSD_SOURCE))
     pthread_t tid;
     pthread_attr_t attr;
     pthread_attr_init(&attr);
@@ -1018,7 +1020,18 @@
     }
 
     pthread_attr_destroy(&attr);
-#endif /* __solaris__ */
+#else /* ! __linux__ */
+    thread_t tid;
+    long flags = 0;
+    if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {
+      void * tmp;
+      thr_join(tid, NULL, &tmp);
+      rslt = (int)tmp;
+    } else {
+      /* See above. Continue in current thread if thr_create() failed */
+      rslt = continuation(args);
+    }
+#endif /* __linux__ */
     return rslt;
 }
 
--- jdk/src/solaris/bin/java_md_solinux.h	2012-08-10 10:31:14.000000000 -0700
+++ jdk/src/solaris/bin/java_md_solinux.h	2013-05-05 09:38:39.000000000 -0700
@@ -33,6 +33,10 @@
 #include <sys/time.h>
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
+#elif !defined(MACOSX) && defined(_ALLBSD_SOURCE)
+/* CounterGet() is implemented in java_md_solinux.c */
+int64_t CounterGet(void);
+#define Counter2Micros(counts)    (counts)
 #else  /* ! HAVE_GETHRTIME */
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
@@ -48,16 +52,19 @@
 #ifdef __linux__
 static const char *system_dir   = "/usr/java";
 static const char *user_dir     = "/java";
+#elif !defined(MACOSX) && defined(_ALLBSD_SOURCE)
+static const char *system_dir  = PACKAGE_PATH "/openjdk7";
+static const char *user_dir    = "/java";
 #else /* Solaris */
 static const char *system_dir   = "/usr/jdk";
 static const char *user_dir     = "/jdk";
 #endif
 
 #include <dlfcn.h>
-#ifdef __solaris__
-#include <thread.h>
-#else
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
+#else
+#include <thread.h>
 #endif
 
 #define JVM_DLL         "libjvm.so"
--- jdk/src/solaris/classes/sun/awt/X11/XCheckboxMenuItemPeer.java	2012-08-10 10:31:17.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XCheckboxMenuItemPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -29,27 +29,12 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 class XCheckboxMenuItemPeer extends XMenuItemPeer implements CheckboxMenuItemPeer {
 
     /************************************************
      *
-     * Data members
-     *
-     ************************************************/
-
-    /*
-     * CheckboxMenuItem's fields
-     */
-    private final static Field f_state;
-    static {
-        f_state = SunToolkit.getField(CheckboxMenuItem.class, "state");
-    }
-
-    /************************************************
-     *
      * Construction
      *
      ************************************************/
@@ -74,16 +59,8 @@
      *
      ************************************************/
     boolean getTargetState() {
-        MenuItem target = getTarget();
-        if (target == null) {
-            return false;
-        }
-        try {
-            return f_state.getBoolean(target);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getCheckboxMenuItemAccessor()
+                   .getState((CheckboxMenuItem)getTarget());
     }
 
     /************************************************
--- jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	2012-08-10 10:31:18.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -29,14 +29,8 @@
 import java.awt.dnd.DropTarget;
 import java.awt.dnd.DropTargetListener;
 import java.awt.event.*;
-import java.awt.image.ColorModel;
-import java.awt.image.ImageObserver;
-import java.awt.image.ImageProducer;
-import java.awt.image.VolatileImage;
-import java.awt.peer.*;
 import sun.awt.*;
-import sun.awt.motif.X11FontMetrics;
-import java.lang.reflect.*;
+import sun.awt.AWTAccessor;
 import sun.util.logging.PlatformLogger;
 import java.util.*;
 import static sun.awt.X11.XEmbedHelper.*;
@@ -455,16 +449,8 @@
         }
     }
 
-    static Field bdataField;
     static byte[] getBData(KeyEvent e) {
-        try {
-            if (bdataField == null) {
-                bdataField = SunToolkit.getField(java.awt.AWTEvent.class, "bdata");
-            }
-            return (byte[])bdataField.get(e);
-        } catch (IllegalAccessException ex) {
-            return null;
-        }
+        return AWTAccessor.getAWTEventAccessor().getBData(e);
     }
 
     void forwardKeyEvent(KeyEvent e) {
--- jdk/src/solaris/classes/sun/awt/X11/XEmbeddingContainer.java	2012-08-10 10:31:18.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XEmbeddingContainer.java	2013-05-05 09:38:39.000000000 -0700
@@ -29,7 +29,7 @@
 import java.util.HashMap;
 import java.awt.event.KeyEvent;
 import java.lang.reflect.*;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XEmbeddingContainer extends XEmbedHelper implements XEventDispatcher {
     HashMap children = new HashMap();
@@ -127,20 +127,8 @@
         }
     }
 
-    static Field bdata;
-    byte[] getBData(KeyEvent e) {
-        try {
-            if (bdata == null) {
-                bdata = SunToolkit.getField(java.awt.AWTEvent.class, "bdata");
-            }
-            return (byte[])bdata.get(e);
-        } catch (IllegalAccessException ex) {
-            return null;
-        }
-    }
-
     void forwardKeyEvent(long child, KeyEvent e) {
-        byte[] bdata = getBData(e);
+        byte[] bdata = AWTAccessor.getAWTEventAccessor().getBData(e);
         long data = Native.toData(bdata);
         if (data == 0) {
             return;
--- jdk/src/solaris/classes/sun/awt/X11/XGlobalCursorManager.java	2012-08-10 10:31:18.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XGlobalCursorManager.java	2013-05-05 09:38:39.000000000 -0700
@@ -27,10 +27,7 @@
 
 import java.awt.*;
 import java.awt.peer.ComponentPeer;
-import java.awt.peer.LightweightPeer;
 import java.lang.ref.WeakReference;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
 import sun.awt.AWTAccessor;
 
 import sun.awt.GlobalCursorManager;
@@ -38,23 +35,6 @@
 
 public final class XGlobalCursorManager extends GlobalCursorManager {
 
-    private static Field  field_pData;
-    private static Field  field_type;
-    private static Class  cursorClass;
-    private static Method method_setPData;
-    static {
-        cursorClass = java.awt.Cursor.class;
-        field_pData = SunToolkit.getField(cursorClass, "pData");
-        field_type  = SunToolkit.getField(cursorClass, "type");
-        method_setPData = SunToolkit.getMethod(cursorClass, "setPData", new Class[] {long.class});
-        if (field_pData == null || field_type == null || method_setPData == null) {
-            System.out.println("Unable to initialize XGlobalCursorManager: ");
-            Thread.dumpStack();
-
-        }
-    }
-
-
     // cached nativeContainer
     private WeakReference<Component> nativeContainer;
 
@@ -213,8 +193,8 @@
         long pData = 0;
         int type = 0;
         try {
-            pData = field_pData.getLong(c);
-            type = field_type.getInt(c);
+            pData = AWTAccessor.getCursorAccessor().getPData(c);
+            type = AWTAccessor.getCursorAccessor().getType(c);
         }
         catch (Exception e)
         {
@@ -284,7 +264,7 @@
 
     static void setPData(Cursor c, long pData) {
         try {
-            method_setPData.invoke(c, pData);
+            AWTAccessor.getCursorAccessor().setPData(c, pData);
         }
         catch (Exception e)
         {
--- jdk/src/solaris/classes/sun/awt/X11/XMenuBarPeer.java	2012-08-10 10:31:18.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XMenuBarPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -28,10 +28,9 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
 import java.util.Vector;
 import sun.util.logging.PlatformLogger;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XMenuBarPeer extends XBaseMenuWindow implements MenuBarPeer {
 
@@ -67,15 +66,6 @@
     private final static int BAR_ITEM_MARGIN_TOP = 2;
     private final static int BAR_ITEM_MARGIN_BOTTOM = 2;
 
-    //fields
-    private static Field f_helpMenu;
-    private static Field f_menus;
-
-    static {
-        f_helpMenu = SunToolkit.getField(MenuBar.class, "helpMenu");
-        f_menus = SunToolkit.getField(MenuBar.class, "menus");
-    }
-
     /************************************************
      *
      * Mapping data
@@ -204,16 +194,12 @@
      */
     void postInit(XCreateWindowParams params) {
         super.postInit(params);
-        Vector targetMenuVector = null;
-        Menu targetHelpMenu = null;
-        try {
-            // Get menus from the target.
-            targetMenuVector = (Vector)f_menus.get(menuBarTarget);
-            targetHelpMenu = (Menu)f_helpMenu.get(menuBarTarget);
-            reloadItems(targetMenuVector);
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
-        }
+        // Get menus from the target.
+        Vector targetMenuVector = AWTAccessor.getMenuBarAccessor()
+                                      .getMenus(menuBarTarget);
+        Menu targetHelpMenu = AWTAccessor.getMenuBarAccessor()
+                                  .getHelpMenu(menuBarTarget);
+        reloadItems(targetMenuVector);
         if (targetHelpMenu != null) {
             addHelpMenu(targetHelpMenu);
         }
--- jdk/src/solaris/classes/sun/awt/X11/XMenuItemPeer.java	2012-08-10 10:31:18.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XMenuItemPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -28,10 +28,7 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XMenuItemPeer implements MenuItemPeer {
 
@@ -81,24 +78,6 @@
     private final static int SEPARATOR_WIDTH = 20;
     private final static int SEPARATOR_HEIGHT = 5;
 
-    /*
-     * MenuItem's fields & methods
-     */
-    private final static Field f_enabled;
-    private final static Field f_label;
-    private final static Field f_shortcut;
-    private final static Method m_getFont;
-    private final static Method m_isItemEnabled;
-    private final static Method m_getActionCommand;
-    static {
-        f_enabled = SunToolkit.getField(MenuItem.class, "enabled");
-        f_label = SunToolkit.getField(MenuItem.class, "label");
-        f_shortcut = SunToolkit.getField(MenuItem.class, "shortcut");
-
-        m_getFont = SunToolkit.getMethod(MenuComponent.class, "getFont_NoClientCode", null);
-        m_getActionCommand = SunToolkit.getMethod(MenuItem.class, "getActionCommandImpl", null);
-        m_isItemEnabled = SunToolkit.getMethod(MenuItem.class, "isItemEnabled", null);
-    }
     /************************************************
      *
      * Text Metrics
@@ -216,39 +195,22 @@
         if (target == null) {
             return XWindow.getDefaultFont();
         }
-        try {
-            return (Font)m_getFont.invoke(target, new Object[0]);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return XWindow.getDefaultFont();
+        return AWTAccessor.getMenuComponentAccessor().getFont_NoClientCode(target);
     }
 
     String getTargetLabel() {
         if (target == null) {
             return "";
         }
-        try {
-            String label = (String)f_label.get(target);
-            return (label == null) ? "" : label;
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return "";
+        String label = AWTAccessor.getMenuItemAccessor().getLabel(target);
+        return (label == null) ? "" : label;
     }
 
     boolean isTargetEnabled() {
         if (target == null) {
             return false;
         }
-        try {
-            return f_enabled.getBoolean(target);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getMenuItemAccessor().isEnabled(target);
     }
 
     /**
@@ -260,40 +222,21 @@
         if (target == null) {
             return false;
         }
-        try {
-            return ((Boolean)m_isItemEnabled.invoke(target, new Object[0])).booleanValue();
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getMenuItemAccessor().isItemEnabled(target);
     }
 
     String getTargetActionCommand() {
         if (target == null) {
             return "";
         }
-        try {
-            return (String) m_getActionCommand.invoke(target,(Object[]) null);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return "";
+        return AWTAccessor.getMenuItemAccessor().getActionCommandImpl(target);
     }
 
     MenuShortcut getTargetShortcut() {
         if (target == null) {
             return null;
         }
-        try {
-            return (MenuShortcut)f_shortcut.get(target);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return null;
+        return AWTAccessor.getMenuItemAccessor().getShortcut(target);
     }
 
     String getShortcutText() {
--- jdk/src/solaris/classes/sun/awt/X11/XMenuPeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XMenuPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -27,10 +27,9 @@
 import java.awt.*;
 import java.awt.peer.*;
 
-import java.lang.reflect.Field;
 import java.util.Vector;
 import sun.util.logging.PlatformLogger;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XMenuPeer extends XMenuItemPeer implements MenuPeer {
 
@@ -46,16 +45,6 @@
      */
     XMenuWindow menuWindow;
 
-
-    /*
-     * Menu's fields & methods
-     */
-    private final static Field f_items;
-
-    static {
-        f_items = SunToolkit.getField(Menu.class, "items");
-    }
-
     /************************************************
      *
      * Construction
@@ -153,12 +142,7 @@
      *
      ************************************************/
     Vector getTargetItems() {
-        try {
-            return (Vector)f_items.get(getTarget());
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
-            return null;
-        }
+        return AWTAccessor.getMenuAccessor().getItems((Menu)getTarget());
     }
 
     /************************************************
--- jdk/src/solaris/classes/sun/awt/X11/XPopupMenuPeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XPopupMenuPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -28,15 +28,10 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-
 import java.util.Vector;
+import sun.awt.AWTAccessor;
 import sun.util.logging.PlatformLogger;
 
-import sun.awt.SunToolkit;
-
 public class XPopupMenuPeer extends XMenuWindow implements PopupMenuPeer {
 
     /************************************************
@@ -66,24 +61,6 @@
     private final static int CAPTION_MARGIN_TOP = 4;
     private final static int CAPTION_SEPARATOR_HEIGHT = 6;
 
-    /*
-     * Menu's fields & methods
-     */
-    //Fix for 6184485: Popup menu is not disabled on XToolkit even when calling setEnabled (false)
-    private final static Field f_enabled;
-    //Fix for 6267144: PIT: Popup menu label is not shown, XToolkit
-    private final static Field f_label;
-    private final static Method m_getFont;
-    private final static Field f_items;
-
-    static {
-        f_enabled = SunToolkit.getField(MenuItem.class, "enabled");
-        f_label = SunToolkit.getField(MenuItem.class, "label");
-        f_items = SunToolkit.getField(Menu.class, "items");
-        m_getFont = SunToolkit.getMethod(MenuComponent.class, "getFont_NoClientCode", null);
-    }
-
-
     /************************************************
      *
      * Construction
@@ -96,7 +73,7 @@
 
     /************************************************
      *
-     * Implementaion of interface methods
+     * Implementation of interface methods
      *
      ************************************************/
     /*
@@ -189,27 +166,16 @@
         if (popupMenuTarget == null) {
             return XWindow.getDefaultFont();
         }
-        try {
-            return (Font)m_getFont.invoke(popupMenuTarget, new Object[0]);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return XWindow.getDefaultFont();
+        return AWTAccessor.getMenuComponentAccessor()
+                   .getFont_NoClientCode(popupMenuTarget);
     }
 
+    //Fix for 6267144: PIT: Popup menu label is not shown, XToolkit
     String getTargetLabel() {
         if (target == null) {
             return "";
         }
-        try {
-            String label = (String)f_label.get(popupMenuTarget);
-            return (label == null) ? "" : label;
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return "";
+        return AWTAccessor.getMenuItemAccessor().getLabel(popupMenuTarget);
     }
 
     //Fix for 6184485: Popup menu is not disabled on XToolkit even when calling setEnabled (false)
@@ -217,21 +183,14 @@
         if (popupMenuTarget == null) {
             return false;
         }
-        try {
-            return f_enabled.getBoolean(popupMenuTarget);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getMenuItemAccessor().isEnabled(popupMenuTarget);
     }
 
     Vector getMenuTargetItems() {
-        try {
-            return (Vector)f_items.get(popupMenuTarget);
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
+        if (popupMenuTarget == null) {
             return null;
         }
+        return AWTAccessor.getMenuAccessor().getItems(popupMenuTarget);
     }
 
     /************************************************
--- jdk/src/solaris/classes/sun/awt/X11/XScrollPanePeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XScrollPanePeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -29,7 +29,7 @@
 import java.awt.event.*;
 import java.awt.peer.*;
 import java.lang.reflect.*;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 class XScrollPanePeer extends XComponentPeer implements ScrollPanePeer, XScrollbarClient {
 
@@ -41,9 +41,7 @@
     public final static int     VERTICAL = 1 << 0;
     public final static int     HORIZONTAL = 1 << 1;
 
-    private static Method m_setValue;
     static {
-        m_setValue = SunToolkit.getMethod(ScrollPaneAdjustable.class, "setTypedValue", new Class[] {Integer.TYPE, Integer.TYPE});
         SCROLLBAR = XToolkit.getUIDefaults().getInt("ScrollBar.defaultWidth");
     }
 
@@ -316,19 +314,9 @@
     }
 
     void setAdjustableValue(ScrollPaneAdjustable adj, int value, int type) {
-        try {
-            m_setValue.invoke(adj, new Object[] {Integer.valueOf(value), Integer.valueOf(type)});
-        } catch (IllegalAccessException iae) {
-            adj.setValue(value);
-        } catch (IllegalArgumentException iae2) {
-            adj.setValue(value);
-        } catch (InvocationTargetException ite) {
-            adj.setValue(value);
-            ite.getCause().printStackTrace();
-        }
+        AWTAccessor.getScrollPaneAdjustableAccessor().setTypedValue(adj, value, type);
     }
 
-
     public void paint(Graphics g) {
         paintComponent(g);
     }
--- jdk/src/solaris/classes/sun/awt/X11/XSystemTrayPeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XSystemTrayPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -27,10 +27,9 @@
 
 import java.awt.*;
 import java.awt.peer.SystemTrayPeer;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
 import sun.awt.SunToolkit;
 import sun.awt.AppContext;
+import sun.awt.AWTAccessor;
 import sun.util.logging.PlatformLogger;
 
 public class XSystemTrayPeer implements SystemTrayPeer, XMSelectionListener {
@@ -42,11 +41,6 @@
     private volatile boolean available;
     private final XMSelection selection = new XMSelection("_NET_SYSTEM_TRAY");
 
-    private static final Method firePropertyChangeMethod =
-        XToolkit.getMethod(SystemTray.class, "firePropertyChange", new Class[] {String.class, Object.class, Object.class});
-    private static final Method addNotifyMethod = XToolkit.getMethod(TrayIcon.class, "addNotify", null);
-    private static final Method removeNotifyMethod = XToolkit.getMethod(TrayIcon.class, "removeNotify", null);
-
     private static final int SCREEN = 0;
     private static final String SYSTEM_TRAY_PROPERTY_NAME = "systemTray";
     private static final XAtom _NET_SYSTEM_TRAY = XAtom.get("_NET_SYSTEM_TRAY_S" + SCREEN);
@@ -157,46 +151,45 @@
         return peerInstance;
     }
 
-    private void firePropertyChange(final String propertyName, final Object oldValue, final Object newValue) {
+    private void firePropertyChange(final String propertyName,
+                                    final Object oldValue,
+                                    final Object newValue) {
         Runnable runnable = new Runnable() {
                 public void run() {
-                    Object[] args = new Object[] {propertyName, oldValue, newValue};
-                    invokeMethod(firePropertyChangeMethod, target, args);
+                    AWTAccessor.getSystemTrayAccessor()
+                        .firePropertyChange(target, propertyName, oldValue, newValue);
                 }
             };
         invokeOnEachAppContext(runnable);
     }
 
     private void createTrayPeers() {
-        invokeOnEachTrayIcon(addNotifyMethod);
+        Runnable runnable = new Runnable() {
+                public void run() {
+                    TrayIcon[] icons = target.getTrayIcons();
+                    try {
+                        for (TrayIcon ti : icons) {
+                            AWTAccessor.getTrayIconAccessor().addNotify(ti);
+                        }
+                    } catch (AWTException e) {
+                    }
+                }
+            };
+        invokeOnEachAppContext(runnable);
     }
 
     private void removeTrayPeers() {
-        invokeOnEachTrayIcon(removeNotifyMethod);
-    }
-
-    private void invokeOnEachTrayIcon(final Method method) {
         Runnable runnable = new Runnable() {
                 public void run() {
                     TrayIcon[] icons = target.getTrayIcons();
                     for (TrayIcon ti : icons) {
-                        invokeMethod(method, ti, (Object[]) null);
+                        AWTAccessor.getTrayIconAccessor().removeNotify(ti);
                     }
                 }
             };
         invokeOnEachAppContext(runnable);
     }
 
-    private void invokeMethod(Method method, Object obj, Object[] args) {
-        try{
-            method.invoke(obj, args);
-        } catch (InvocationTargetException e){
-            e.printStackTrace();
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-    }
-
     private void invokeOnEachAppContext(Runnable runnable) {
         for (AppContext appContext : AppContext.getAppContexts()) {
             SunToolkit.invokeLaterOnAppContext(appContext, runnable);
--- jdk/src/solaris/classes/sun/awt/X11/XTextAreaPeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XTextAreaPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -105,6 +105,7 @@
         this.target = target;
 
         //ComponentAccessor.enableEvents(target,AWTEvent.MOUSE_WHEEL_EVENT_MASK);
+        target.enableInputMethods(true);
 
         firstChangeSkipped = false;
         String text = ((TextArea)target).getText();
@@ -112,6 +113,7 @@
         jtext.setWrapStyleWord(true);
         jtext.getDocument().addDocumentListener(jtext);
         XToolkit.specialPeerMap.put(jtext,this);
+        jtext.enableInputMethods(true);
         textPane = new AWTTextPane(jtext,this, target.getParent());
 
         setBounds(x, y, width, height, SET_BOUNDS);
@@ -464,6 +466,13 @@
 
     protected boolean setTextImpl(String txt) {
         if (jtext != null) {
+            // Please note that we do not want to post an event
+            // if setText() replaces an empty text by an empty text,
+            // that is, if component's text remains unchanged.
+            if (jtext.getDocument().getLength() == 0 && txt.length() == 0) {
+                return true;
+            }
+
             // JTextArea.setText() posts two different events (remove & insert).
             // Since we make no differences between text events,
             // the document listener has to be disabled while
@@ -1006,8 +1015,10 @@
         // loading SystemFlavorMap and associated classes.
         public void setTransferHandler(TransferHandler newHandler) {
             TransferHandler oldHandler = (TransferHandler)
-                getClientProperty(XTextTransferHelper.getTransferHandlerKey());
-            putClientProperty(XTextTransferHelper.getTransferHandlerKey(),
+                getClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                      .getJComponent_TRANSFER_HANDLER());
+            putClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                  .getJComponent_TRANSFER_HANDLER(),
                               newHandler);
 
             firePropertyChange("transferHandler", oldHandler, newHandler);
--- jdk/src/solaris/classes/sun/awt/X11/XTextFieldPeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XTextFieldPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -73,6 +73,8 @@
         xtext = new XAWTTextField(text,this, target.getParent());
         xtext.getDocument().addDocumentListener(xtext);
         xtext.setCursor(target.getCursor());
+        target.enableInputMethods(true);
+        xtext.enableInputMethods(true);
         XToolkit.specialPeerMap.put(xtext,this);
 
         TextField txt = (TextField) target;
@@ -714,8 +716,10 @@
         // loading SystemFlavorMap and associated classes.
         public void setTransferHandler(TransferHandler newHandler) {
             TransferHandler oldHandler = (TransferHandler)
-                getClientProperty(XTextTransferHelper.getTransferHandlerKey());
-            putClientProperty(XTextTransferHelper.getTransferHandlerKey(),
+                getClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                      .getJComponent_TRANSFER_HANDLER());
+            putClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                  .getJComponent_TRANSFER_HANDLER(),
                               newHandler);
 
             firePropertyChange("transferHandler", oldHandler, newHandler);
--- jdk/src/solaris/classes/sun/awt/X11/XTextTransferHelper.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XTextTransferHelper.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.X11;
-
-import java.lang.reflect.Field;
-import sun.awt.SunToolkit;
-
-class XTextTransferHelper {
-    private static Object transferHandlerKey = null;
-    static Object getTransferHandlerKey() {
-        if (transferHandlerKey == null) {
-            try {
-                Class clazz = Class.forName("javax.swing.ClientPropertyKey");
-                Field field = SunToolkit.getField(clazz, "JComponent_TRANSFER_HANDLER");
-                transferHandlerKey = field.get(null);
-            } catch (IllegalAccessException ex) {
-                return null;
-            } catch (ClassNotFoundException cnfe) {
-                cnfe.printStackTrace();
-            }
-        }
-        return transferHandlerKey;
-    }
-}
--- jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	2013-05-05 09:38:39.000000000 -0700
@@ -41,8 +41,6 @@
 import java.awt.image.ColorModel;
 import java.awt.peer.*;
 import java.beans.PropertyChangeListener;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.*;
@@ -50,9 +48,9 @@
 import javax.swing.UIDefaults;
 import sun.awt.*;
 import sun.font.FontConfigManager;
-import sun.font.FontManager;
 import sun.misc.PerformanceLogger;
 import sun.print.PrintJob2D;
+import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
 import sun.util.logging.PlatformLogger;
 
@@ -112,7 +110,6 @@
     private static int screenWidth = -1, screenHeight = -1; // Dimensions of default screen
     static long awt_defaultFg; // Pixel
     private static XMouseInfoPeer xPeer;
-    private static Method m_removeSourceEvents;
 
     static {
         initSecurityWarning();
@@ -130,8 +127,6 @@
             initIDs();
             setBackingStoreType();
         }
-        m_removeSourceEvents = SunToolkit.getMethod(EventQueue.class, "removeSourceEvents", new Class[] {Object.class, Boolean.TYPE}) ;
-
         noisyAwtHandler = AccessController.doPrivileged(new GetBooleanAction("sun.awt.noisyerrorhandler"));
     }
 
@@ -222,7 +217,8 @@
 
     static void initSecurityWarning() {
         // Enable warning only for internal builds
-        String runtime = getSystemProperty("java.runtime.version");
+        String runtime = AccessController.doPrivileged(
+                             new GetPropertyAction("java.runtime.version"));
         securityWarningEnabled = (runtime != null && runtime.contains("internal"));
     }
 
@@ -1067,8 +1063,8 @@
      */
     public synchronized static boolean getSunAwtDisableGtkFileDialogs() {
         if (sunAwtDisableGtkFileDialogs == null) {
-            sunAwtDisableGtkFileDialogs =
-                getBooleanSystemProperty("sun.awt.disableGtkFileDialogs");
+            sunAwtDisableGtkFileDialogs = AccessController.doPrivileged(
+                                              new GetBooleanAction("sun.awt.disableGtkFileDialogs"));
         }
         return sunAwtDisableGtkFileDialogs.booleanValue();
     }
@@ -2056,17 +2052,11 @@
         return null;
     }
 
-    static void removeSourceEvents(EventQueue queue, Object source, boolean removeAllEvents) {
-        try {
-            m_removeSourceEvents.invoke(queue, source, removeAllEvents);
-        }
-        catch (IllegalAccessException e)
-        {
-            e.printStackTrace();
-        }
-        catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
+    static void removeSourceEvents(EventQueue queue,
+                                   Object source,
+                                   boolean removeAllEvents) {
+        AWTAccessor.getEventQueueAccessor()
+            .removeSourceEvents(queue, source, removeAllEvents);
     }
 
     public boolean isAlwaysOnTopSupported() {
--- jdk/src/solaris/classes/sun/awt/X11/XWindow.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XWindow.java	2013-05-05 09:38:39.000000000 -0700
@@ -126,10 +126,6 @@
     native void getWindowBounds(long window, long x, long y, long width, long height);
     private native static void initIDs();
 
-    private static Field isPostedField;
-    private static Field rawCodeField;
-    private static Field primaryLevelUnicodeField;
-    private static Field extendedKeyCodeField;
     static {
         initIDs();
     }
@@ -398,20 +394,11 @@
 
     static Method m_sendMessage;
     static void sendEvent(final AWTEvent e) {
-        if (isPostedField == null) {
-            isPostedField = SunToolkit.getField(AWTEvent.class, "isPosted");
-        }
         // The uses of this method imply that the incoming event is system-generated
         SunToolkit.setSystemGenerated(e);
         PeerEvent pe = new PeerEvent(Toolkit.getDefaultToolkit(), new Runnable() {
                 public void run() {
-                    try {
-                        isPostedField.setBoolean(e, true);
-                    } catch (IllegalArgumentException e) {
-                        assert(false);
-                    } catch (IllegalAccessException e) {
-                        assert(false);
-                    }
+                    AWTAccessor.getAWTEventAccessor().setPosted(e);
                     ((Component)e.getSource()).dispatchEvent(e);
                 }
             }, PeerEvent.ULTIMATE_PRIORITY_EVENT);
@@ -1427,16 +1414,8 @@
     }
 
 
-    static Field bdata;
     static void setBData(KeyEvent e, byte[] data) {
-        try {
-            if (bdata == null) {
-                bdata = SunToolkit.getField(java.awt.AWTEvent.class, "bdata");
-            }
-            bdata.set(e, data);
-        } catch (IllegalAccessException ex) {
-            assert false;
-        }
+        AWTAccessor.getAWTEventAccessor().setBData(e, data);
     }
 
     public void postKeyEvent(int id, long when, int keyCode, int keyChar,
@@ -1446,15 +1425,6 @@
     {
         long jWhen = XToolkit.nowMillisUTC_offset(when);
         int modifiers = getModifiers(state, 0, keyCode);
-        if (rawCodeField == null) {
-            rawCodeField = XToolkit.getField(KeyEvent.class, "rawCode");
-        }
-        if (primaryLevelUnicodeField == null) {
-            primaryLevelUnicodeField = XToolkit.getField(KeyEvent.class, "primaryLevelUnicode");
-        }
-        if (extendedKeyCodeField == null) {
-            extendedKeyCodeField = XToolkit.getField(KeyEvent.class, "extendedKeyCode");
-        }
 
         KeyEvent ke = new KeyEvent((Component)getEventSource(), id, jWhen,
                                    modifiers, keyCode, (char)keyChar, keyLocation);
@@ -1462,15 +1432,11 @@
             byte[] data = Native.toBytes(event, eventSize);
             setBData(ke, data);
         }
-        try {
-            rawCodeField.set(ke, rawCode);
-            primaryLevelUnicodeField.set(ke, (long)unicodeFromPrimaryKeysym);
-            extendedKeyCodeField.set(ke, (long)extendedKeyCode);
-        } catch (IllegalArgumentException e) {
-            assert(false);
-        } catch (IllegalAccessException e) {
-            assert(false);
-        }
+
+        AWTAccessor.KeyEventAccessor kea = AWTAccessor.getKeyEventAccessor();
+        kea.setRawCode(ke, rawCode);
+        kea.setPrimaryLevelUnicode(ke, (long)unicodeFromPrimaryKeysym);
+        kea.setExtendedKeyCode(ke, (long)extendedKeyCode);
         postEventToEventQueue(ke);
     }
 
--- jdk/src/solaris/classes/sun/awt/X11/XWindowPeer.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XWindowPeer.java	2013-05-05 09:38:39.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -992,8 +992,8 @@
                              XLayerProtocol.LAYER_NORMAL);
     }
 
-    public void setAlwaysOnTop(boolean alwaysOnTop) {
-        this.alwaysOnTop = alwaysOnTop;
+    public void updateAlwaysOnTopState() {
+        this.alwaysOnTop = ((Window) this.target).isAlwaysOnTop();
         updateAlwaysOnTop();
     }
 
--- jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java	2012-08-10 10:31:19.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java	2013-05-05 09:38:39.000000000 -0700
@@ -27,6 +27,7 @@
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import sun.security.action.GetPropertyAction;
 import sun.misc.*;
 
 final public class XlibWrapper
@@ -590,12 +591,8 @@
     static final boolean isBuildInternal;
 
     static {
-        String dataModelProp = (String)AccessController.doPrivileged(
-            new PrivilegedAction() {
-                    public Object run() {
-                        return System.getProperty("sun.arch.data.model");
-                    }
-                });
+        String dataModelProp = AccessController.doPrivileged(
+            new GetPropertyAction("sun.arch.data.model"));
         try {
             dataModel = Integer.parseInt(dataModelProp);
         } catch (Exception e) {
@@ -647,7 +644,8 @@
     }
 
     private static boolean getBuildInternal() {
-        String javaVersion = XToolkit.getSystemProperty("java.version");
+        String javaVersion = AccessController.doPrivileged(
+                                 new GetPropertyAction("java.version"));
         return javaVersion != null && javaVersion.contains("internal");
     }
 
--- jdk/src/solaris/classes/sun/awt/X11FontManager.java	2012-08-10 10:31:20.000000000 -0700
+++ jdk/src/solaris/classes/sun/awt/X11FontManager.java	2013-05-05 09:38:40.000000000 -0700
@@ -213,7 +213,7 @@
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && FontUtilities.isLinux && !isOpenJDK()) {
+            if (fileName == null && (FontUtilities.isLinux || FontUtilities.isBSD) && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -712,7 +712,7 @@
         if (fontConfigDirs == null) {
             return;
         }
-        if (FontUtilities.isLinux) {
+        if (FontUtilities.isLinux || FontUtilities.isBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
@@ -740,7 +740,7 @@
          */
         FontConfiguration mFontConfig = new MFontConfiguration(this);
         if (FontUtilities.isOpenSolaris ||
-            (FontUtilities.isLinux &&
+            ((FontUtilities.isLinux || FontUtilities.isBSD) &&
              (!mFontConfig.foundOsSpecificFile() ||
               !mFontConfig.fontFilesArePresent()) ||
              (FontUtilities.isSolaris && !mFontConfig.fontFilesArePresent()))) {
--- jdk/src/solaris/classes/sun/nio/ch/DevPollArrayWrapper.java	2012-08-10 10:31:23.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/ch/DevPollArrayWrapper.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -68,7 +68,7 @@
     static final short REVENT_OFFSET = 6;
 
     // Special value to indicate that an update should be ignored
-    static final byte  CANCELLED     = (byte)-1;
+    static final byte  IGNORE        = (byte)-1;
 
     // Maximum number of open file descriptors
     static final int   OPEN_MAX      = fdLimit();
@@ -192,15 +192,15 @@
 
             // events are stored as bytes for efficiency reasons
             byte b = (byte)mask;
-            assert (b == mask) && (b != CANCELLED);
+            assert (b == mask) && (b != IGNORE);
             setUpdateEvents(fd, b);
         }
     }
 
     void release(int fd) {
         synchronized (updateLock) {
-            // cancel any pending update for this file descriptor
-            setUpdateEvents(fd, CANCELLED);
+            // ignore any pending update for this file descriptor
+            setUpdateEvents(fd, IGNORE);
 
             // remove from /dev/poll
             if (registered.get(fd)) {
@@ -236,32 +236,40 @@
             while (j < updateCount) {
                 int fd = updateDescriptors[j];
                 short events = getUpdateEvents(fd);
-                boolean isRegistered = registered.get(fd);
+                boolean wasRegistered = registered.get(fd);
 
                 // events = 0 => POLLREMOVE or do-nothing
-                if (events != CANCELLED) {
+                if (events != IGNORE) {
                     if (events == 0) {
-                        if (isRegistered) {
+                        if (wasRegistered) {
                             events = POLLREMOVE;
                             registered.clear(fd);
                         } else {
-                            events = CANCELLED;
+                            events = IGNORE;
                         }
                     } else {
-                        if (!isRegistered) {
+                        if (!wasRegistered) {
                             registered.set(fd);
                         }
                     }
                 }
 
                 // populate pollfd array with updated event
-                if (events != CANCELLED) {
+                if (events != IGNORE) {
+                    // insert POLLREMOVE if changing events
+                    if (wasRegistered && events != POLLREMOVE) {
+                        putPollFD(pollArray, index, fd, POLLREMOVE);
+                        index++;
+                    }
                     putPollFD(pollArray, index, fd, events);
                     index++;
-                    if (index >= NUM_POLLFDS) {
+                    if (index >= (NUM_POLLFDS-1)) {
                         registerMultiple(wfd, pollArray.address(), index);
                         index = 0;
                     }
+
+                    // events for this fd now up to date
+                    setUpdateEvents(fd, IGNORE);
                 }
                 j++;
             }
--- jdk/src/solaris/classes/sun/nio/ch/SctpChannelImpl.java	2012-08-10 10:31:23.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/ch/SctpChannelImpl.java	2013-05-05 09:38:40.000000000 -0700
@@ -1019,13 +1019,21 @@
                                      boolean unordered,
                                      int ppid)
             throws IOException {
+        InetAddress addr = null;     // no preferred address
+        int port = 0;
+        if (target != null) {
+            InetSocketAddress isa = Net.checkAddress(target);
+            addr = isa.getAddress();
+            port = isa.getPort();
+        }
+
         int pos = bb.position();
         int lim = bb.limit();
         assert (pos <= lim);
         int rem = (pos <= lim ? lim - pos : 0);
 
-        int written = send0(fd, ((DirectBuffer)bb).address() + pos,
-                            rem, target, -1 /*121*/, streamNumber, unordered, ppid);
+        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,
+                            port, -1 /*121*/, streamNumber, unordered, ppid);
         if (written > 0)
             bb.position(pos + written);
         return written;
@@ -1084,7 +1092,7 @@
             long address, int length, boolean peek) throws IOException;
 
     static native int send0(int fd, long address, int length,
-            SocketAddress target, int assocId, int streamNumber,
+            InetAddress addr, int port, int assocId, int streamNumber,
             boolean unordered, int ppid) throws IOException;
 
     private static native int checkConnect(FileDescriptor fd, boolean block,
--- jdk/src/solaris/classes/sun/nio/ch/SctpMultiChannelImpl.java	2012-08-10 10:31:23.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/ch/SctpMultiChannelImpl.java	2013-05-05 09:38:40.000000000 -0700
@@ -880,13 +880,20 @@
                                      boolean unordered,
                                      int ppid)
             throws IOException {
+        InetAddress addr = null;     // no preferred address
+        int port = 0;
+        if (target != null) {
+            InetSocketAddress isa = Net.checkAddress(target);
+            addr = isa.getAddress();
+            port = isa.getPort();
+        }
         int pos = bb.position();
         int lim = bb.limit();
         assert (pos <= lim);
         int rem = (pos <= lim ? lim - pos : 0);
 
-        int written = send0(fd, ((DirectBuffer)bb).address() + pos,
-                            rem, target, assocId, streamNumber, unordered, ppid);
+        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,
+                            port, assocId, streamNumber, unordered, ppid);
         if (written > 0)
             bb.position(pos + written);
         return written;
@@ -967,13 +974,14 @@
     private static int send0(int fd,
                              long address,
                              int length,
-                             SocketAddress target,
+                             InetAddress addr,
+                             int port,
                              int assocId,
                              int streamNumber,
                              boolean unordered,
                              int ppid)
             throws IOException {
-        return SctpChannelImpl.send0(fd, address, length, target, assocId,
+        return SctpChannelImpl.send0(fd, address, length, addr, port, assocId,
                 streamNumber, unordered, ppid);
     }
 
--- jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	2013-05-05 09:38:40.000000000 -0700
@@ -68,7 +68,7 @@
             return createProvider("sun.nio.fs.SolarisFileSystemProvider");
         if (osname.equals("Linux"))
             return createProvider("sun.nio.fs.LinuxFileSystemProvider");
-        if (osname.equals("Darwin") || osname.contains("OS X"))
+        if (osname.endsWith("BSD") || osname.equals("Darwin") || osname.contains("OS X"))
             return createProvider("sun.nio.fs.BsdFileSystemProvider");
         throw new AssertionError("Platform not recognized");
     }
--- jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,7 +55,7 @@
         name = USER_NAMESPACE + name;
         byte[] bytes = name.getBytes();
         if (bytes.length > XATTR_NAME_MAX) {
-            throw new FileSystemException(file.getPathForExceptionMessage(),
+            throw new FileSystemException(file.getPathForExecptionMessage(),
                 null, "'" + name + "' is too big");
         }
         return bytes;
@@ -116,7 +116,7 @@
                         buffer = NativeBuffers.getNativeBuffer(size);
                         continue;
                     }
-                    throw new FileSystemException(file.getPathForExceptionMessage(),
+                    throw new FileSystemException(file.getPathForExecptionMessage(),
                         null, "Unable to get list of extended attributes: " +
                         x.getMessage());
                 }
@@ -138,7 +138,7 @@
             // fgetxattr returns size if called with size==0
             return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);
         } catch (UnixException x) {
-            throw new FileSystemException(file.getPathForExceptionMessage(),
+            throw new FileSystemException(file.getPathForExecptionMessage(),
                 null, "Unable to get size of extended attribute '" + name +
                 "': " + x.getMessage());
         } finally {
@@ -191,7 +191,7 @@
             } catch (UnixException x) {
                 String msg = (x.errno() == ERANGE) ?
                     "Insufficient space in buffer" : x.getMessage();
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "Error reading extended attribute '" + name + "': " + msg);
             } finally {
                 close(fd);
@@ -243,7 +243,7 @@
                 src.position(pos + rem);
                 return rem;
             } catch (UnixException x) {
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "Error writing extended attribute '" + name + "': " +
                     x.getMessage());
             } finally {
@@ -264,7 +264,7 @@
         try {
             fremovexattr(fd, nameAsBytes(file,name));
         } catch (UnixException x) {
-            throw new FileSystemException(file.getPathForExceptionMessage(),
+            throw new FileSystemException(file.getPathForExecptionMessage(),
                 null, "Unable to delete extended attribute '" + name + "': " + x.getMessage());
         } finally {
             close(fd);
--- jdk/src/solaris/classes/sun/nio/fs/LinuxWatchService.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/LinuxWatchService.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -243,7 +243,7 @@
                 return x.asIOException(dir);
             }
             if (!attrs.isDirectory()) {
-                return new NotDirectoryException(dir.getPathForExceptionMessage());
+                return new NotDirectoryException(dir.getPathForExecptionMessage());
             }
 
             // register with inotify (replaces existing mask if already registered)
--- jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -324,7 +324,7 @@
                 return decode(address, n);
             } catch (UnixException x) {
                 if ((x.errno() == ENOSYS) || !isAclsEnabled(fd)) {
-                    throw new FileSystemException(file.getPathForExceptionMessage(),
+                    throw new FileSystemException(file.getPathForExecptionMessage(),
                         null, x.getMessage() + " (file system does not support NFSv4 ACLs)");
                 }
                 x.rethrowAsIOException(file);
@@ -355,7 +355,7 @@
                 facl(fd, ACE_SETACL, n, address);
             } catch (UnixException x) {
                 if ((x.errno() == ENOSYS) || !isAclsEnabled(fd)) {
-                    throw new FileSystemException(file.getPathForExceptionMessage(),
+                    throw new FileSystemException(file.getPathForExecptionMessage(),
                         null, x.getMessage() + " (file system does not support NFSv4 ACLs)");
                 }
                 if (x.errno() == EINVAL && (n < 3))
--- jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,7 +49,7 @@
             if (bytes.length <= 1 ||
                 (bytes.length == 2 && bytes[1] == '.'))
             {
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "'" + name + "' is not a valid name");
             }
         }
@@ -96,7 +96,7 @@
                 }
                 return Collections.unmodifiableList(list);
             } catch (UnixException x) {
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "Unable to get list of extended attributes: " +
                     x.getMessage());
             }
@@ -126,7 +126,7 @@
                     close(afd);
                 }
             } catch (UnixException x) {
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "Unable to get size of extended attribute '" + name +
                     "': " + x.getMessage());
             }
@@ -165,7 +165,7 @@
                     fc.close();
                 }
             } catch (UnixException x) {
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "Unable to read extended attribute '" + name +
                     "': " + x.getMessage());
             }
@@ -201,7 +201,7 @@
                     fc.close();
                 }
             } catch (UnixException x) {
-                throw new FileSystemException(file.getPathForExceptionMessage(),
+                throw new FileSystemException(file.getPathForExecptionMessage(),
                     null, "Unable to write extended attribute '" + name +
                     "': " + x.getMessage());
             }
@@ -224,7 +224,7 @@
                 close(dfd);
             }
         } catch (UnixException x) {
-            throw new FileSystemException(file.getPathForExceptionMessage(),
+            throw new FileSystemException(file.getPathForExecptionMessage(),
                 null, "Unable to delete extended attribute '" + name +
                 "': " + x.getMessage());
         } finally {
--- jdk/src/solaris/classes/sun/nio/fs/SolarisWatchService.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/SolarisWatchService.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -288,7 +288,7 @@
                 return x.asIOException(dir);
             }
             if (!attrs.isDirectory()) {
-                return new NotDirectoryException(dir.getPathForExceptionMessage());
+                return new NotDirectoryException(dir.getPathForExecptionMessage());
             }
 
             // return existing watch key after updating events if already
--- jdk/src/solaris/classes/sun/nio/fs/UnixChannelFactory.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/UnixChannelFactory.java	2013-05-05 09:38:40.000000000 -0700
@@ -36,6 +36,8 @@
 import sun.misc.SharedSecrets;
 import sun.misc.JavaIOFileDescriptorAccess;
 
+import com.sun.nio.file.ExtendedOpenOption;
+
 import static sun.nio.fs.UnixNativeDispatcher.*;
 import static sun.nio.fs.UnixConstants.*;
 
@@ -84,13 +86,13 @@
                     }
                     continue;
                 }
-                if (option == LinkOption.NOFOLLOW_LINKS && supportsNoFollowLinks()) {
+                if (option == LinkOption.NOFOLLOW_LINKS) {
                     flags.noFollowLinks = true;
                     continue;
                 }
                 if (option == null)
                     throw new NullPointerException();
-               throw new UnsupportedOperationException(option + " not supported");
+               throw new UnsupportedOperationException();
             }
             return flags;
         }
@@ -218,15 +220,6 @@
         // follow links by default
         boolean followLinks = true;
         if (!flags.createNew && (flags.noFollowLinks || flags.deleteOnClose)) {
-            if (flags.deleteOnClose && !supportsNoFollowLinks()) {
-                try {
-                    if (UnixFileAttributes.get(path, false).isSymbolicLink())
-                        throw new UnixException("DELETE_ON_CLOSE specified and file is a symbolic link");
-                } catch (UnixException x) {
-                    if (!flags.create || x.errno() != ENOENT)
-                        throw x;
-                }
-            }
             followLinks = false;
             oflags |= O_NOFOLLOW;
         }
--- jdk/src/solaris/classes/sun/nio/fs/UnixCopyFile.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/UnixCopyFile.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -383,8 +383,8 @@
             } catch (UnixException x) {
                 if (x.errno() == EXDEV) {
                     throw new AtomicMoveNotSupportedException(
-                        source.getPathForExceptionMessage(),
-                        target.getPathForExceptionMessage(),
+                        source.getPathForExecptionMessage(),
+                        target.getPathForExecptionMessage(),
                         x.errorString());
                 }
                 x.rethrowAsIOException(source, target);
@@ -420,7 +420,7 @@
                 return;  // nothing to do as files are identical
             if (!flags.replaceExisting) {
                 throw new FileAlreadyExistsException(
-                    target.getPathForExceptionMessage());
+                    target.getPathForExecptionMessage());
             }
 
             // attempt to delete target
@@ -436,7 +436,7 @@
                    (x.errno() == EEXIST || x.errno() == ENOTEMPTY))
                 {
                     throw new DirectoryNotEmptyException(
-                        target.getPathForExceptionMessage());
+                        target.getPathForExecptionMessage());
                 }
                 x.rethrowAsIOException(target);
             }
@@ -489,7 +489,7 @@
                 (x.errno() == EEXIST || x.errno() == ENOTEMPTY))
             {
                 throw new DirectoryNotEmptyException(
-                    source.getPathForExceptionMessage());
+                    source.getPathForExecptionMessage());
             }
             x.rethrowAsIOException(source);
         }
@@ -542,7 +542,7 @@
                 return;  // nothing to do as files are identical
             if (!flags.replaceExisting)
                 throw new FileAlreadyExistsException(
-                    target.getPathForExceptionMessage());
+                    target.getPathForExecptionMessage());
             try {
                 if (targetAttrs.isDirectory()) {
                     rmdir(target);
@@ -555,7 +555,7 @@
                    (x.errno() == EEXIST || x.errno() == ENOTEMPTY))
                 {
                     throw new DirectoryNotEmptyException(
-                        target.getPathForExceptionMessage());
+                        target.getPathForExecptionMessage());
                 }
                 x.rethrowAsIOException(target);
             }
--- jdk/src/solaris/classes/sun/nio/fs/UnixException.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/UnixException.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -97,8 +97,8 @@
     }
 
     void rethrowAsIOException(UnixPath file, UnixPath other) throws IOException {
-        String a = (file == null) ? null : file.getPathForExceptionMessage();
-        String b = (other == null) ? null : other.getPathForExceptionMessage();
+        String a = (file == null) ? null : file.getPathForExecptionMessage();
+        String b = (other == null) ? null : other.getPathForExecptionMessage();
         IOException x = translateToIOException(a, b);
         throw x;
     }
@@ -108,6 +108,6 @@
     }
 
     IOException asIOException(UnixPath file) {
-        return translateToIOException(file.getPathForExceptionMessage(), null);
+        return translateToIOException(file.getPathForExecptionMessage(), null);
     }
 }
--- jdk/src/solaris/classes/sun/nio/fs/UnixFileSystemProvider.java	2012-08-10 10:31:24.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/UnixFileSystemProvider.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -238,7 +238,7 @@
             // DirectoryNotEmptyException if not empty
             if (attrs != null && attrs.isDirectory() &&
                 (x.errno() == EEXIST || x.errno() == ENOTEMPTY))
-                throw new DirectoryNotEmptyException(file.getPathForExceptionMessage());
+                throw new DirectoryNotEmptyException(file.getPathForExecptionMessage());
 
             x.rethrowAsIOException(file);
             return false;
@@ -395,13 +395,13 @@
 
         // can't return SecureDirectoryStream on kernels that don't support
         // openat, etc.
-        if (!supportsAtSysCalls() || !supportsNoFollowLinks()) {
+        if (!supportsAtSysCalls()) {
             try {
                 long ptr = opendir(dir);
                 return new UnixDirectoryStream(dir, ptr, filter);
             } catch (UnixException x) {
                 if (x.errno() == ENOTDIR)
-                    throw new NotDirectoryException(dir.getPathForExceptionMessage());
+                    throw new NotDirectoryException(dir.getPathForExecptionMessage());
                 x.rethrowAsIOException(dir);
             }
         }
@@ -421,7 +421,7 @@
             if (dfd2 != -1)
                 UnixNativeDispatcher.close(dfd2);
             if (x.errno() == UnixConstants.ENOTDIR)
-                throw new NotDirectoryException(dir.getPathForExceptionMessage());
+                throw new NotDirectoryException(dir.getPathForExecptionMessage());
             x.rethrowAsIOException(dir);
         }
         return new UnixSecureDirectoryStream(dir, dp, dfd2, filter);
@@ -490,7 +490,7 @@
             return new UnixPath(link.getFileSystem(), target);
         } catch (UnixException x) {
            if (x.errno() == UnixConstants.EINVAL)
-                throw new NotLinkException(link.getPathForExceptionMessage());
+                throw new NotLinkException(link.getPathForExecptionMessage());
             x.rethrowAsIOException(link);
             return null;    // keep compiler happy
         }
--- jdk/src/solaris/classes/sun/nio/fs/UnixNativeDispatcher.java	2012-08-10 10:31:25.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/UnixNativeDispatcher.java	2013-05-05 09:38:40.000000000 -0700
@@ -548,10 +548,6 @@
         return hasAtSysCalls;
     }
 
-    static boolean supportsNoFollowLinks() {
-        return UnixConstants.O_NOFOLLOW != 0;
-    }
-
     // initialize syscalls and fieldIDs
     private static native int init();
 
--- jdk/src/solaris/classes/sun/nio/fs/UnixPath.java	2012-08-10 10:31:25.000000000 -0700
+++ jdk/src/solaris/classes/sun/nio/fs/UnixPath.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -179,7 +179,7 @@
     }
 
     // use this message when throwing exceptions
-    String getPathForExceptionMessage() {
+    String getPathForExecptionMessage() {
         return toString();
     }
 
@@ -767,11 +767,8 @@
     // package-private
     int openForAttributeAccess(boolean followLinks) throws IOException {
         int flags = O_RDONLY;
-        if (!followLinks) {
-            if (!supportsNoFollowLinks())
-                throw new IOException("NOFOLLOW_LINKS is not supported on this platform");
+        if (!followLinks)
             flags |= O_NOFOLLOW;
-        }
         try {
             return open(this, flags, 0);
         } catch (UnixException x) {
@@ -780,7 +777,7 @@
                 x.setError(ELOOP);
 
             if (x.errno() == ELOOP)
-                throw new FileSystemException(getPathForExceptionMessage(), null,
+                throw new FileSystemException(getPathForExecptionMessage(), null,
                     x.getMessage() + " or unable to access attributes of symbolic link");
 
             x.rethrowAsIOException(this);
--- jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	2012-08-10 10:31:25.000000000 -0700
+++ jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	2013-05-05 09:38:40.000000000 -0700
@@ -125,6 +125,7 @@
 
     static boolean isBSD() {
         return (osname.equals("Linux") ||
+                osname.endsWith("BSD") ||
                 osname.contains("OS X"));
     }
 
--- jdk/src/solaris/javavm/export/jvm_md.h	2012-08-10 10:31:28.000000000 -0700
+++ jdk/src/solaris/javavm/export/jvm_md.h	2013-05-05 09:38:39.000000000 -0700
@@ -75,7 +75,11 @@
 #define JVM_O_O_APPEND   O_APPEND
 #define JVM_O_EXCL       O_EXCL
 #define JVM_O_CREAT      O_CREAT
+#if !defined(__APPLE__) && defined(_ALLBSD_SOURCE)
+#define JVM_O_DELETE     0x10000000
+#else
 #define JVM_O_DELETE     0x10000
+#endif
 
 /* Signals */
 
--- jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c	2012-08-10 10:31:28.000000000 -0700
+++ jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -168,6 +168,9 @@
     /*
      * XXXBSD: there's no way available to get swap info in
      *         FreeBSD.  Usage of libkvm is not an option here
+     *
+     * XXX: Investigate how swapinfo(8) does this.
+     *      Total swap is in vm.swap_total
      */
     // throw_internal_error(env, "Unimplemented in FreeBSD");
     return (0);
@@ -242,6 +245,8 @@
 #else /* _ALLBSD_SOURCE */
     /*
      * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     *
+     * XXX: Determine how linprocfs gets this.
      */
     // throw_internal_error(env, "Unimplemented in FreeBSD");
     return (64 * MB);
@@ -323,6 +328,8 @@
 #elif defined(_ALLBSD_SOURCE)
     /*
      * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     *
+     * XXX: Investigate how top(8) gets this on FreeBSD.
      */
     // throw_internal_error(env, "Unimplemented in FreeBSD");
     return (128 * MB);
@@ -342,7 +349,11 @@
     size_t rlen;
 
     mib[0] = CTL_HW;
+#ifdef __APPLE__
     mib[1] = HW_MEMSIZE;
+#else
+    mib[1] = HW_PHYSMEM;
+#endif
     rlen = sizeof(result);
     if (sysctl(mib, 2, &result, &rlen, NULL, 0) != 0) {
         throw_internal_error(env, "sysctl failed");
@@ -408,6 +419,8 @@
 #elif defined(_ALLBSD_SOURCE)
     /*
      * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     *
+     * XXX: Investigate getting this on FreeBSD.  Look at lsof.
      */
     // throw_internal_error(env, "Unimplemented in FreeBSD");
     return (100);
--- jdk/src/solaris/native/java/io/UnixFileSystem_md.c	2012-08-10 10:31:30.000000000 -0700
+++ jdk/src/solaris/native/java/io/UnixFileSystem_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -146,7 +146,6 @@
     return rv;
 }
 
-
 JNIEXPORT jboolean JNICALL
 Java_java_io_UnixFileSystem_setPermission(JNIEnv *env, jobject this,
                                           jobject file,
--- jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	2012-08-10 10:31:30.000000000 -0700
+++ jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -53,7 +53,7 @@
 
     for (i = 0; environ[i]; i++) {
         /* Ignore corrupted environment variables */
-        if (strchr(environ[i], '=') != NULL)
+        if (strchr(environ[i], '=') != NULL && *environ[i] != '=')
             count++;
     }
 
@@ -63,7 +63,7 @@
     for (i = 0, j = 0; environ[i]; i++) {
         const char * varEnd = strchr(environ[i], '=');
         /* Ignore corrupted environment variables */
-        if (varEnd != NULL) {
+        if (varEnd != NULL && varEnd != environ[i]) {
             jbyteArray var, val;
             const char * valBeg = varEnd + 1;
             jsize varLength = varEnd - environ[i];
--- jdk/src/solaris/native/java/lang/UNIXProcess_md.c	2012-08-10 10:31:30.000000000 -0700
+++ jdk/src/solaris/native/java/lang/UNIXProcess_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -394,7 +394,17 @@
   return c >= '0' && c <= '9';
 }
 
-#ifdef _ALLBSD_SOURCE
+#if defined(__OpenBSD__)
+static int
+closeDescriptors(void)
+{
+    int err;
+    RESTARTABLE(closefrom(FAIL_FILENO + 1), err);
+    return err;
+}
+#else
+
+#if defined(_ALLBSD_SOURCE)
 #define FD_DIR "/dev/fd"
 #define dirent64 dirent
 #define readdir64 readdir
@@ -436,6 +446,7 @@
 
     return 1;
 }
+#endif
 
 static int
 moveDescriptor(int fd_from, int fd_to)
--- jdk/src/solaris/native/java/lang/java_props_md.c	2012-08-10 10:31:30.000000000 -0700
+++ jdk/src/solaris/native/java/lang/java_props_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -151,7 +151,7 @@
     lc = setlocale(cat, NULL);
 #endif
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__OpenBSD__)
     if (lc == NULL) {
         return 0;
     }
@@ -484,12 +484,19 @@
                     &(sprops.format_country),
                     &(sprops.format_variant),
                     &(sprops.encoding))) {
+#ifdef __OpenBSD__
+        sprops.language = sprops.format_language;
+        sprops.script = sprops.format_script;
+        sprops.country = sprops.format_country;
+        sprops.variant = sprops.format_variant;
+#else
         ParseLocale(LC_MESSAGES,
                     &(sprops.language),
                     &(sprops.script),
                     &(sprops.country),
                     &(sprops.variant),
                     NULL);
+#endif
     } else {
         sprops.language = "en";
         sprops.encoding = "ISO8859-1";
--- jdk/src/solaris/native/java/net/Inet4AddressImpl.c	2012-08-10 10:31:30.000000000 -0700
+++ jdk/src/solaris/native/java/net/Inet4AddressImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -102,9 +102,6 @@
 static jclass ni_iacls;
 static jclass ni_ia4cls;
 static jmethodID ni_ia4ctrID;
-static jfieldID ni_iaaddressID;
-static jfieldID ni_iahostID;
-static jfieldID ni_iafamilyID;
 static int initialized = 0;
 
 /*
@@ -135,9 +132,6 @@
       ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
       ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
       ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
-      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
-      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
-      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
       initialized = 1;
     }
 
@@ -238,9 +232,8 @@
                 ret = NULL;
                 goto cleanupAndReturn;
             }
-            (*env)->SetIntField(env, iaObj, ni_iaaddressID,
-                                ntohl(((struct sockaddr_in*)(iterator->ai_addr))->sin_addr.s_addr));
-            (*env)->SetObjectField(env, iaObj, ni_iahostID, name);
+            setInetAddress_addr(env, iaObj, ntohl(((struct sockaddr_in*)(iterator->ai_addr))->sin_addr.s_addr));
+            setInetAddress_hostName(env, iaObj, name);
             (*env)->SetObjectArrayElement(env, ret, retLen - i -1, iaObj);
             i++;
             iterator = iterator->ai_next;
@@ -395,9 +388,6 @@
 static jclass ni_iacls;
 static jclass ni_ia4cls;
 static jmethodID ni_ia4ctrID;
-static jfieldID ni_iaaddressID;
-static jfieldID ni_iahostID;
-static jfieldID ni_iafamilyID;
 static int initialized = 0;
 
 /*
@@ -431,9 +421,6 @@
       ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
       ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
       ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
-      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
-      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
-      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
       initialized = 1;
     }
 
@@ -502,9 +489,8 @@
             ret = NULL;
             goto cleanupAndReturn;
           }
-          (*env)->SetIntField(env, iaObj, ni_iaaddressID,
-                              ntohl((*addrp)->s_addr));
-          (*env)->SetObjectField(env, iaObj, ni_iahostID, host);
+          setInetAddress_addr(env, iaObj, ntohl((*addrp)->s_addr));
+          setInetAddress_hostName(env, iaObj, host);
           (*env)->SetObjectArrayElement(env, ret, i, iaObj);
           addrp++;
           i++;
@@ -669,11 +655,11 @@
                  sizeof(struct sockaddr));
       if (n < 0 && errno != EINPROGRESS ) {
 #ifdef __linux__
-        if (errno != EINVAL && errno != EHOSTUNREACH)
+        if (errno != EINVAL)
           /*
            * On some Linuxes, when bound to the loopback interface, sendto
-           * will fail and errno will be set to EINVAL or EHOSTUNREACH.
-           * When that happens, don't throw an exception, just return false.
+           * will fail and errno will be set to EINVAL. When that happens,
+           * don't throw an exception, just return false.
            */
 #endif /*__linux__ */
           NET_ThrowNew(env, errno, "Can't send ICMP packet");
@@ -828,11 +814,10 @@
         case EADDRNOTAVAIL: /* address is not available on  the  remote machine */
 #ifdef __linux__
         case EINVAL:
-        case EHOSTUNREACH:
           /*
            * On some Linuxes, when bound to the loopback interface, connect
-           * will fail and errno will be set to EINVAL or EHOSTUNREACH.
-           * When that happens, don't throw an exception, just return false.
+           * will fail and errno will be set to EINVAL. When that happens,
+           * don't throw an exception, just return false.
            */
 #endif /* __linux__ */
           close(fd);
--- jdk/src/solaris/native/java/net/Inet6AddressImpl.c	2012-08-10 10:31:30.000000000 -0700
+++ jdk/src/solaris/native/java/net/Inet6AddressImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -122,9 +122,6 @@
 static jclass ni_ia6cls;
 static jmethodID ni_ia4ctrID;
 static jmethodID ni_ia6ctrID;
-static jfieldID ni_iaaddressID;
-static jfieldID ni_iahostID;
-static jfieldID ni_iafamilyID;
 static jfieldID ni_ia6ipaddressID;
 static int initialized = 0;
 
@@ -161,9 +158,6 @@
       ni_ia6cls = (*env)->NewGlobalRef(env, ni_ia6cls);
       ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
       ni_ia6ctrID = (*env)->GetMethodID(env, ni_ia6cls, "<init>", "()V");
-      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
-      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
-      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
       ni_ia6ipaddressID = (*env)->GetFieldID(env, ni_ia6cls, "ipaddress", "[B");
       initialized = 1;
     }
@@ -318,9 +312,8 @@
                   ret = NULL;
                   goto cleanupAndReturn;
                 }
-                (*env)->SetIntField(env, iaObj, ni_iaaddressID,
-                                    ntohl(((struct sockaddr_in*)iterator->ai_addr)->sin_addr.s_addr));
-                (*env)->SetObjectField(env, iaObj, ni_iahostID, host);
+                setInetAddress_addr(env, iaObj, ntohl(((struct sockaddr_in*)iterator->ai_addr)->sin_addr.s_addr));
+                setInetAddress_hostName(env, iaObj, host);
                 (*env)->SetObjectArrayElement(env, ret, inetIndex, iaObj);
                 inetIndex++;
               } else if (iterator->ai_family == AF_INET6) {
@@ -351,7 +344,7 @@
                   (*env)->SetBooleanField(env, iaObj, ia6_scopeidsetID, JNI_TRUE);
                 }
                 (*env)->SetObjectField(env, iaObj, ni_ia6ipaddressID, ipaddress);
-                (*env)->SetObjectField(env, iaObj, ni_iahostID, host);
+                setInetAddress_hostName(env, iaObj, host);
                 (*env)->SetObjectArrayElement(env, ret, inet6Index, iaObj);
                 inet6Index++;
               }
@@ -512,11 +505,11 @@
       n = sendto(fd, sendbuf, plen, 0, (struct sockaddr*) him, sizeof(struct sockaddr_in6));
       if (n < 0 && errno != EINPROGRESS) {
 #ifdef __linux__
-        if (errno != EINVAL && errno != EHOSTUNREACH)
+        if (errno != EINVAL)
           /*
            * On some Linuxes, when bound to the loopback interface, sendto
-           * will fail and errno will be set to EINVAL or EHOSTUNREACH.
-           * When that happens, don't throw an exception, just return false.
+           * will fail and errno will be set to EINVAL. When that happens,
+           * don't throw an exception, just return false.
            */
 #endif /*__linux__ */
         NET_ThrowNew(env, errno, "Can't send ICMP packet");
@@ -680,11 +673,10 @@
         case EADDRNOTAVAIL: /* address is not available on  the  remote machine */
 #ifdef __linux__
         case EINVAL:
-        case EHOSTUNREACH:
           /*
            * On some Linuxes, when bound to the loopback interface, connect
-           * will fail and errno will be set to EINVAL or EHOSTUNREACH.
-           * When that happens, don't throw an exception, just return false.
+           * will fail and errno will be set to EINVAL. When that happens,
+           * don't throw an exception, just return false.
            */
 #endif /* __linux__ */
           close(fd);
--- jdk/src/solaris/native/java/net/NetworkInterface.c	2012-08-10 10:31:31.000000000 -0700
+++ jdk/src/solaris/native/java/net/NetworkInterface.c	2013-05-05 09:38:40.000000000 -0700
@@ -60,14 +60,18 @@
 #include <sys/param.h>
 #include <sys/ioctl.h>
 #include <sys/sockio.h>
-#if defined(__APPLE__)
+#if defined(__FreeBSD__) || defined(__APPLE__)
 #include <net/ethernet.h>
 #include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#elif defined(__NetBSD__)
+#include <net/if_ether.h>
+#endif
 #include <net/if_dl.h>
 #include <netinet/in_var.h>
 #include <ifaddrs.h>
 #endif
-#endif
 
 #include "jvm.h"
 #include "jni_util.h"
@@ -118,8 +122,6 @@
 static jmethodID ni_ia4ctrID;
 static jmethodID ni_ia6ctrID;
 static jmethodID ni_ibctrID;
-static jfieldID ni_iaaddressID;
-static jfieldID ni_iafamilyID;
 static jfieldID ni_ia6ipaddressID;
 static jfieldID ni_ibaddressID;
 static jfieldID ni_ib4broadcastID;
@@ -195,8 +197,6 @@
     ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
     ni_ia6ctrID = (*env)->GetMethodID(env, ni_ia6cls, "<init>", "()V");
     ni_ibctrID = (*env)->GetMethodID(env, ni_ibcls, "<init>", "()V");
-    ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
-    ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
     ni_ia6ipaddressID = (*env)->GetFieldID(env, ni_ia6cls, "ipaddress", "[B");
     ni_ibaddressID = (*env)->GetFieldID(env, ni_ibcls, "address", "Ljava/net/InetAddress;");
     ni_ib4broadcastID = (*env)->GetFieldID(env, ni_ibcls, "broadcast", "Ljava/net/Inet4Address;");
@@ -300,7 +300,7 @@
     netif *ifs, *curr;
 
 #ifdef AF_INET6
-    int family = (  (*env)->GetIntField(env, iaObj, ni_iafamilyID) == IPv4 ) ? AF_INET : AF_INET6;
+    int family = (getInetAddress_family(env, iaObj) == IPv4) ? AF_INET : AF_INET6;
 #else
     int family =  AF_INET;
 #endif
@@ -325,7 +325,7 @@
             if (family == addrP->family) {
                 if (family == AF_INET) {
                     int address1 = htonl(((struct sockaddr_in*)addrP->addr)->sin_addr.s_addr);
-                    int address2 = (*env)->GetIntField(env, iaObj, ni_iaaddressID);
+                    int address2 = getInetAddress_addr(env, iaObj);
 
                     if (address1 == address2) {
                         match = JNI_TRUE;
@@ -650,7 +650,7 @@
         if (addrP->family == AF_INET) {
             iaObj = (*env)->NewObject(env, ni_ia4cls, ni_ia4ctrID);
             if (iaObj) {
-                 (*env)->SetIntField(env, iaObj, ni_iaaddressID, htonl(((struct sockaddr_in*)addrP->addr)->sin_addr.s_addr));
+                 setInetAddress_addr(env, iaObj, htonl(((struct sockaddr_in*)addrP->addr)->sin_addr.s_addr));
             }
             ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);
             if (ibObj) {
@@ -659,8 +659,7 @@
                     jobject ia2Obj = NULL;
                     ia2Obj = (*env)->NewObject(env, ni_ia4cls, ni_ia4ctrID);
                     if (ia2Obj) {
-                       (*env)->SetIntField(env, ia2Obj, ni_iaaddressID,
-                                                               htonl(((struct sockaddr_in*)addrP->brdcast)->sin_addr.s_addr));
+                       setInetAddress_addr(env, ia2Obj, htonl(((struct sockaddr_in*)addrP->brdcast)->sin_addr.s_addr));
                        (*env)->SetObjectField(env, ibObj, ni_ib4broadcastID, ia2Obj);
                        (*env)->SetShortField(env, ibObj, ni_ib4maskID, addrP->mask);
                     }
@@ -1289,7 +1288,11 @@
       return -1;
   }
 
-  return if2.ifr_flags;
+#ifdef __FreeBSD__
+  return ((if2.ifr_flags & 0xffff) | (if2.ifr_flagshigh << 16));
+#else
+  return (((int) if2.ifr_flags) & 0xffff);
+#endif
 }
 
 #endif
@@ -1979,7 +1982,11 @@
       return -1;
   }
 
+#ifdef __FreeBSD__
+  return ((if2.ifr_flags & 0xffff) | (if2.ifr_flagshigh << 16));
+#else
   return (((int) if2.ifr_flags) & 0xffff);
+#endif
 }
 
 #endif
--- jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	2012-08-10 10:31:31.000000000 -0700
+++ jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -23,12 +23,12 @@
  * questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 
 #ifdef __solaris__
 #include <fcntl.h>
@@ -357,13 +357,21 @@
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&addr;
+#ifdef __FreeBSD__
+            him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&addr;
+#ifdef __FreeBSD__
+            him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
         JVM_Connect(fd, (struct sockaddr *)&addr, len);
@@ -616,14 +624,13 @@
 
     iaObj = NET_SockaddrToInetAddress(env, (struct sockaddr *)&remote_addr, &port);
 #ifdef AF_INET6
-    family = (*env)->GetIntField(env, iaObj, ia_familyID) == IPv4?
-        AF_INET : AF_INET6;
+    family = getInetAddress_family(env, iaObj) == IPv4? AF_INET : AF_INET6;
 #else
     family = AF_INET;
 #endif
     if (family == AF_INET) { /* this api can't handle IPV6 addresses */
-        int address = (*env)->GetIntField(env, iaObj, ia_addressID);
-        (*env)->SetIntField(env, addressObj, ia_addressID, address);
+        int address = getInetAddress_addr(env, iaObj);
+        setInetAddress_addr(env, addressObj, address);
     }
     return port;
 }
@@ -1170,23 +1177,18 @@
  */
 static void mcast_set_if_by_if_v4(JNIEnv *env, jobject this, int fd, jobject value) {
     static jfieldID ni_addrsID;
-    static jfieldID ia_addressID;
     struct in_addr in;
     jobjectArray addrArray;
     jsize len;
     jobject addr;
     int i;
 
-    if (ni_addrsID == NULL || ia_addressID == NULL) {
+    if (ni_addrsID == NULL ) {
         jclass c = (*env)->FindClass(env, "java/net/NetworkInterface");
         CHECK_NULL(c);
         ni_addrsID = (*env)->GetFieldID(env, c, "addrs",
                                         "[Ljava/net/InetAddress;");
         CHECK_NULL(ni_addrsID);
-        c = (*env)->FindClass(env,"java/net/InetAddress");
-        CHECK_NULL(c);
-        ia_addressID = (*env)->GetFieldID(env, c, "address", "I");
-        CHECK_NULL(ia_addressID);
     }
 
     addrArray = (*env)->GetObjectField(env, value, ni_addrsID);
@@ -1207,8 +1209,8 @@
      */
     for (i = 0; i < len; i++) {
         addr = (*env)->GetObjectArrayElement(env, addrArray, i);
-        if ((*env)->GetIntField(env, addr, ia_familyID) == IPv4) {
-            in.s_addr = htonl((*env)->GetIntField(env, addr, ia_addressID));
+        if (getInetAddress_family(env, addr) == IPv4) {
+            in.s_addr = htonl(getInetAddress_addr(env, addr));
             break;
         }
     }
@@ -1268,17 +1270,9 @@
  * Throw exception if failed.
  */
 static void mcast_set_if_by_addr_v4(JNIEnv *env, jobject this, int fd, jobject value) {
-    static jfieldID ia_addressID;
     struct in_addr in;
 
-    if (ia_addressID == NULL) {
-        jclass c = (*env)->FindClass(env,"java/net/InetAddress");
-        CHECK_NULL(c);
-        ia_addressID = (*env)->GetFieldID(env, c, "address", "I");
-        CHECK_NULL(ia_addressID);
-    }
-
-    in.s_addr = htonl( (*env)->GetIntField(env, value, ia_addressID) );
+    in.s_addr = htonl( getInetAddress_addr(env, value) );
 
     if (JVM_SetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_IF,
                        (const char*)&in, sizeof(in)) < 0) {
@@ -1350,7 +1344,7 @@
          * value is an InetAddress.
          */
 #ifdef AF_INET6
-#if defined(__solaris__) || defined(MACOSX)
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
         if (ipv6_available()) {
             mcast_set_if_by_addr_v6(env, this, fd, value);
         } else {
@@ -1373,7 +1367,7 @@
          * value is a NetworkInterface.
          */
 #ifdef AF_INET6
-#if defined(__solaris__) || defined(MACOSX)
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
         if (ipv6_available()) {
             mcast_set_if_by_if_v6(env, this, fd, value);
         } else {
@@ -1456,7 +1450,7 @@
 static void setMulticastLoopbackMode(JNIEnv *env, jobject this, int fd,
                                   jint opt, jobject value) {
 #ifdef AF_INET6
-#if defined(__solaris__) || defined(MACOSX)
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
     if (ipv6_available()) {
         mcast_set_loop_v6(env, this, fd, value);
     } else {
@@ -1629,7 +1623,6 @@
     if (isIPV4) {
         static jclass inet4_class;
         static jmethodID inet4_ctrID;
-        static jfieldID inet4_addrID;
 
         static jclass ni_class;
         static jmethodID ni_ctrID;
@@ -1667,8 +1660,6 @@
             CHECK_NULL_RETURN(c, NULL);
             inet4_ctrID = (*env)->GetMethodID(env, c, "<init>", "()V");
             CHECK_NULL_RETURN(inet4_ctrID, NULL);
-            inet4_addrID = (*env)->GetFieldID(env, c, "address", "I");
-            CHECK_NULL_RETURN(inet4_addrID, NULL);
             inet4_class = (*env)->NewGlobalRef(env, c);
             CHECK_NULL_RETURN(inet4_class, NULL);
         }
@@ -1676,10 +1667,10 @@
         CHECK_NULL_RETURN(addr, NULL);
 
 #ifdef __linux__
-        (*env)->SetIntField(env, addr, inet4_addrID,
-                (isOldKernel ? ntohl(mreqn.imr_address.s_addr) : ntohl(in.s_addr)) );
+        setInetAddress_addr(env, addr, (isOldKernel ?
+                ntohl(mreqn.imr_address.s_addr) : ntohl(in.s_addr)));
 #else
-        (*env)->SetIntField(env, addr, inet4_addrID, ntohl(in.s_addr));
+        setInetAddress_addr(env, addr, ntohl(in.s_addr));
 #endif
 
         /*
@@ -2030,7 +2021,7 @@
     }
     /* setsockopt to be correct ttl */
 #ifdef AF_INET6
-#if defined(__solaris__) || defined(MACOSX)
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
     if (ipv6_available()) {
         setHopLimit(env, fd, ttl);
     } else {
@@ -2164,7 +2155,7 @@
     ipv6_join_leave = ipv6_available();
 
 #ifdef __linux__
-    if ((*env)->GetIntField(env, iaObj, ia_familyID) == IPv4) {
+    if (getInetAddress_family(env, iaObj) == IPv4) {
         ipv6_join_leave = JNI_FALSE;
     }
 #endif
@@ -2211,7 +2202,7 @@
                     CHECK_NULL(ni_indexID);
                 }
 
-                mname.imr_multiaddr.s_addr = htonl((*env)->GetIntField(env, iaObj, ia_addressID));
+                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));
                 mname.imr_address.s_addr = 0;
                 mname.imr_ifindex =  (*env)->GetIntField(env, niObj, ni_indexID);
                 mname_len = sizeof(struct ip_mreqn);
@@ -2229,11 +2220,11 @@
                 }
                 addr = (*env)->GetObjectArrayElement(env, addrArray, 0);
 
-                mname.imr_multiaddr.s_addr = htonl((*env)->GetIntField(env, iaObj, ia_addressID));
+                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));
 #ifdef __linux__
-                mname.imr_address.s_addr = htonl((*env)->GetIntField(env, addr, ia_addressID));
+                mname.imr_address.s_addr = htonl(getInetAddress_addr(env, addr));
 #else
-                mname.imr_interface.s_addr = htonl((*env)->GetIntField(env, addr, ia_addressID));
+                mname.imr_interface.s_addr = htonl(getInetAddress_addr(env, addr));
 #endif
                 mname_len = sizeof(struct ip_mreq);
             }
@@ -2272,7 +2263,7 @@
                     }
                 }
 
-                mname.imr_multiaddr.s_addr = htonl((*env)->GetIntField(env, iaObj, ia_addressID));
+                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));
                 mname.imr_address.s_addr = 0 ;
                 mname.imr_ifindex = index;
                 mname_len = sizeof(struct ip_mreqn);
@@ -2302,7 +2293,7 @@
 #else
                 mname.imr_interface.s_addr = in.s_addr;
 #endif
-                mname.imr_multiaddr.s_addr = htonl((*env)->GetIntField(env, iaObj, ia_addressID));
+                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));
                 mname_len = sizeof(struct ip_mreq);
             }
         }
@@ -2367,10 +2358,10 @@
         jbyte caddr[16];
         jint family;
         jint address;
-        family = (*env)->GetIntField(env, iaObj, ia_familyID) == IPv4? AF_INET : AF_INET6;
+        family = getInetAddress_family(env, iaObj) == IPv4? AF_INET : AF_INET6;
         if (family == AF_INET) { /* will convert to IPv4-mapped address */
             memset((char *) caddr, 0, 16);
-            address = (*env)->GetIntField(env, iaObj, ia_addressID);
+            address = getInetAddress_addr(env, iaObj);
 
             caddr[10] = 0xff;
             caddr[11] = 0xff;
--- jdk/src/solaris/native/java/net/bsd_close.c	2012-08-10 10:31:31.000000000 -0700
+++ jdk/src/solaris/native/java/net/bsd_close.c	2013-05-05 09:38:40.000000000 -0700
@@ -345,6 +345,76 @@
  * signal other than our wakeup signal.
  */
 int NET_Timeout(int s, long timeout) {
+/*
+ * On MacOS X, poll(2) is not working correctly, so a select(2) based
+ * implementation is preferred.  See
+ *
+ * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7131399
+ *
+ * However, on FreeBSD, the select(2) based implementation can cause
+ * crashes under load and poll(2) is preferred.  See
+ *
+ * http://docs.freebsd.org/cgi/getmsg.cgi?fetch=215525+0+current/freebsd-java
+ *
+ * Other *BSD will use poll(2) for now, but please adjust as appropriate.
+ */
+#ifndef __APPLE__
+    long prevtime = 0, newtime;
+    struct timeval t;
+    fdEntry_t *fdEntry = getFdEntry(s);
+
+    /*
+     * Check that fd hasn't been closed.
+     */
+    if (fdEntry == NULL) {
+        errno = EBADF;
+        return -1;
+    }
+
+    /*
+     * Pick up current time as may need to adjust timeout
+     */
+    if (timeout > 0) {
+        gettimeofday(&t, NULL);
+        prevtime = t.tv_sec * 1000  +  t.tv_usec / 1000;
+    }
+
+    for(;;) {
+        struct pollfd pfd;
+        int rv;
+        threadEntry_t self;
+
+        /*
+         * Poll the fd. If interrupted by our wakeup signal
+         * errno will be set to EBADF.
+         */
+        pfd.fd = s;
+        pfd.events = POLLIN | POLLERR;
+
+        startOp(fdEntry, &self);
+        rv = poll(&pfd, 1, timeout);
+        endOp(fdEntry, &self);
+
+        /*
+         * If interrupted then adjust timeout. If timeout
+         * has expired return 0 (indicating timeout expired).
+         */
+        if (rv < 0 && errno == EINTR) {
+            if (timeout > 0) {
+                gettimeofday(&t, NULL);
+                newtime = t.tv_sec * 1000  +  t.tv_usec / 1000;
+                timeout -= newtime - prevtime;
+                if (timeout <= 0) {
+                    return 0;
+                }
+                prevtime = newtime;
+            }
+        } else {
+            return rv;
+        }
+
+    }
+#else
     long prevtime = 0, newtime;
     struct timeval t, *tp = &t;
     fdEntry_t *fdEntry = getFdEntry(s);
@@ -414,4 +484,5 @@
         }
 
     }
+#endif
 }
--- jdk/src/solaris/native/java/net/net_util_md.c	2012-08-10 10:31:31.000000000 -0700
+++ jdk/src/solaris/native/java/net/net_util_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -45,6 +45,10 @@
 #endif
 #endif
 
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -818,7 +822,7 @@
 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port, struct sockaddr *him,
                           int *len, jboolean v4MappedAddress) {
     jint family;
-    family = (*env)->GetIntField(env, iaObj, ia_familyID);
+    family = getInetAddress_family(env, iaObj);
 #ifdef AF_INET6
     /* needs work. 1. family 2. clean up him6 etc deallocate memory */
     if (ipv6_available() && !(family == IPv4 && v4MappedAddress == JNI_FALSE)) {
@@ -830,7 +834,7 @@
 
         if (family == IPv4) { /* will convert to IPv4-mapped address */
             memset((char *) caddr, 0, 16);
-            address = (*env)->GetIntField(env, iaObj, ia_addressID);
+            address = getInetAddress_addr(env, iaObj);
             if (address == INADDR_ANY) {
                 /* we would always prefer IPv6 wildcard address
                    caddr[10] = 0xff;
@@ -942,7 +946,7 @@
               return -1;
             }
             memset((char *) him4, 0, sizeof(struct sockaddr_in));
-            address = (*env)->GetIntField(env, iaObj, ia_addressID);
+            address = getInetAddress_addr(env, iaObj);
             him4->sin_port = htons((short) port);
             him4->sin_addr.s_addr = (uint32_t) htonl(address);
             him4->sin_family = AF_INET;
@@ -1505,7 +1509,22 @@
         }
     }
 
-#endif
+#ifndef __APPLE__
+    /*
+     * Don't allow SO_LINGER value to be too big.
+     * Current max value (240) is empiric value based on tcp_timer.h's
+     * constant TCP_LINGERTIME, which was doubled.
+     *
+     * XXXBSD: maybe we should step it down to 120 ?
+     */
+    if (level == SOL_SOCKET && opt == SO_LINGER) {
+        ling = (struct linger *)arg;
+       if (ling->l_linger > 240 || ling->l_linger < 0) {
+           ling->l_linger = 240;
+       }
+    }
+#endif __APPLE__
+#endif _ALLBSD_SOURCE
 
     return setsockopt(fd, level, opt, arg, len);
 }
--- jdk/src/solaris/native/java/net/net_util_md.h	2012-08-10 10:31:31.000000000 -0700
+++ jdk/src/solaris/native/java/net/net_util_md.h	2013-05-05 09:38:40.000000000 -0700
@@ -37,7 +37,7 @@
 #endif
 
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(MACOSX)
 extern int NET_Timeout(int s, long timeout);
 extern int NET_Read(int s, void* buf, size_t len);
 extern int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
--- jdk/src/solaris/native/java/util/TimeZone_md.c	2012-08-10 10:31:31.000000000 -0700
+++ jdk/src/solaris/native/java/util/TimeZone_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -123,7 +123,7 @@
         return NULL;
     }
 
-#if defined(__linux__) || defined(MACOSX) || (defined(__solaris__) \
+#if defined(__linux__) || defined(_ALLBSD_SOURCE) || (defined(__solaris__) \
     && (defined(_POSIX_PTHREAD_SEMANTICS) || defined(_LP64)))
     while (readdir_r(dirp, entry, &dp) == 0 && dp != NULL) {
 #else
@@ -212,7 +212,7 @@
     return tz;
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 /*
  * Performs Linux specific mapping and returns a zone ID
@@ -678,7 +678,7 @@
  * Returns a GMT-offset-based zone ID. (e.g., "GMT-08:00")
  */
 
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 
 char *
 getGMTOffsetID()
@@ -738,4 +738,4 @@
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
 }
-#endif /* MACOSX */
+#endif /* _ALLBSD_SOURCE */
--- jdk/src/solaris/native/sun/awt/awt_Font.c	2012-08-10 10:31:32.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_Font.c	2013-05-05 09:38:40.000000000 -0700
@@ -334,7 +334,7 @@
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
--- jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2012-08-10 10:31:32.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2013-05-05 09:38:40.000000000 -0700
@@ -123,7 +123,7 @@
  */
 
 #define MAXFRAMEBUFFERS 16
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -652,7 +652,7 @@
 #endif /* HEADLESS */
 
 #ifndef HEADLESS
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
     void* libHandle = NULL;
@@ -703,7 +703,7 @@
     }
 }
 #endif
-#if !defined(__linux__) && !defined(MACOSX) /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
     void* libHandle = NULL;
@@ -763,11 +763,11 @@
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1642,7 +1642,7 @@
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1655,7 +1655,7 @@
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ || MACOSX */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
--- jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2012-08-10 10:31:32.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2013-05-05 09:38:40.000000000 -0700
@@ -67,7 +67,7 @@
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -81,7 +81,7 @@
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -99,14 +99,14 @@
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -146,7 +146,7 @@
 #endif /* XAWT */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #else
 #ifndef XAWT
@@ -425,7 +425,7 @@
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -531,7 +531,7 @@
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -539,7 +539,7 @@
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -648,7 +648,7 @@
     return result;
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
 #ifdef XAWT
                                 Window parent) {
@@ -993,7 +993,7 @@
         }
     }
 }
-#endif  /* __linux__ || MACOSX */
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -1050,7 +1050,7 @@
         return FALSE ;
     }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -1063,7 +1063,7 @@
             break;
         }
     }
-#else /*! __linux__ && !MACOSX */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
 #ifdef XAWT
     on_the_spot_styles |= XIMStatusNothing;
 #else /* !XAWT */
@@ -1086,7 +1086,7 @@
         on_the_spot_styles |= XIMStatusNothing;
 
 #endif /* XAWT */
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -1134,7 +1134,7 @@
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1156,7 +1156,7 @@
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ && !MACOSX */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
         if (on_the_spot_styles & XIMStatusArea) {
             Widget parent;
@@ -1184,7 +1184,7 @@
         }
 #endif /* XAWT */
         XFree((void *)preedit);
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
         pX11IMData->ic_passive = XCreateIC(X11im,
                                            XNClientWindow, w,
                                            XNFocusWindow, w,
@@ -1343,7 +1343,7 @@
 
 }
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1411,7 +1411,7 @@
  finally:
     AWT_UNLOCK();
 }
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1517,14 +1517,14 @@
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIDProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1588,13 +1588,13 @@
 #endif /* XAWT */
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#else /* !__linux__ && !MACOSX */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
     pX11IMData->statusWidget = (Widget) NULL;
 #endif /* XAWT */
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1741,14 +1741,14 @@
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  w;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1765,7 +1765,7 @@
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1862,7 +1862,7 @@
     X11InputMethodData *pX11IMData;
     XVaNestedList status;
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
       /*do nothing for linux? */
 #else
     AWT_LOCK();
@@ -1968,7 +1968,7 @@
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
--- jdk/src/solaris/native/sun/awt/awt_Robot.c	2012-08-10 10:31:32.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_Robot.c	2013-05-05 09:38:40.000000000 -0700
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
--- jdk/src/solaris/native/sun/awt/awt_util.h	2012-08-10 10:31:33.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_util.h	2013-05-05 09:38:40.000000000 -0700
@@ -187,7 +187,7 @@
 #ifdef __solaris__
 extern Widget awt_util_getXICStatusAreaWindow(Widget w);
 #else
-#if defined(MACOSX)
+#if defined(_ALLBSD_SOURCE)
 int32_t awt_util_getIMStatusHeight(Widget vw);
 Widget awt_util_getXICStatusAreaWindow(Widget w);
 #else
@@ -200,7 +200,7 @@
 
 
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct _XmImRefRec {
   Cardinal      num_refs;       /* Number of referencing widgets. */
   Cardinal      max_refs;       /* Maximum length of refs array. */
--- jdk/src/solaris/native/sun/awt/awt_wm.c	2012-08-10 10:31:33.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_wm.c	2013-05-05 09:38:40.000000000 -0700
@@ -121,12 +121,19 @@
 static Atom XA_KWM_WIN_MAXIMIZED;
 
 /* OpenLook */
+static Atom _XA_OL_DECOR_ADD;
 static Atom _XA_OL_DECOR_DEL;
 static Atom _XA_OL_DECOR_HEADER;
 static Atom _XA_OL_DECOR_RESIZE;
 static Atom _XA_OL_DECOR_PIN;
 static Atom _XA_OL_DECOR_CLOSE;
 
+/* AfterStep */
+static Atom _XA_AS_STYLE;
+
+/* WindowMaker */
+static Atom _XA_WINDOWMAKER_STATE;
+
 /* For _NET_WM_STATE ClientMessage requests */
 #define _NET_WM_STATE_REMOVE    0 /* remove/unset property */
 #define _NET_WM_STATE_ADD       1 /* add/set property      */
@@ -193,7 +200,12 @@
         { &_XA_OL_DECOR_HEADER,              "_OL_DECOR_HEADER"              },
         { &_XA_OL_DECOR_RESIZE,              "_OL_DECOR_RESIZE"              },
         { &_XA_OL_DECOR_PIN,                 "_OL_DECOR_PIN"                 },
-        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               }
+        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               },
+	{ &_XA_OL_DECOR_ADD,		     "_OL_DECOR_ADD"		     },
+
+	{ &_XA_AS_STYLE,		     "_XA_AS_STYLE"		     },
+
+	{ &_XA_WINDOWMAKER_STATE,	     "_XA_WINDOWMAKER_STATE"	     }
     };
 #define ATOM_LIST_LENGTH (sizeof(atom_list)/sizeof(atom_list[0]))
 
@@ -942,6 +954,39 @@
     return True;
 }
 
+/*
+ * Window Maker.
+ */
+static Boolean
+awt_wm_isWindowmaker()
+{
+    if (awt_wm_atomInterned(&_XA_WINDOWMAKER_STATE, "_WINDOWMAKER_STATE"))
+        return True;
+    return False;
+}
+
+/*
+ * Afterstep.
+ */
+static Boolean
+awt_wm_isAfterstep()
+{
+    if (awt_wm_atomInterned(&_XA_AS_STYLE, "_AS_STYLE"))
+        return True;
+    return False;
+}
+
+/*
+ * FVWM 2.
+ */
+static Boolean
+awt_wm_isFvwm2()
+{
+    if (awt_wm_atomInterned(&_XA_OL_DECOR_ADD, "_OL_DECOR_ADD")
+        && !awt_wm_atomInterned(&_XA_OL_DECOR_PIN, "_OL_DECOR_PIN"))
+        return True;
+    return False;
+}
 
 static Boolean
 awt_wm_isNetWMName(char *name)
@@ -1280,6 +1325,12 @@
     else if (awt_wm_isKDE2()) {
         awt_wmgr = KDE2_WM;
     }
+    else if (awt_wm_isWindowmaker()) {
+	awt_wmgr = WINDOWMAKER_WM;
+    }
+    else if (awt_wm_isAfterstep()) {
+	awt_wmgr = AFTERSTEP_WM;
+    }
     /*
      * We don't check for legacy WM when we already know that WM
      * supports WIN or _NET wm spec.
@@ -1302,6 +1353,9 @@
         awt_wmgr = MOTIF_WM;
     }
     else if (awt_wm_isOpenLook()) {
+	awt_wmgr = OPENLOOK_WM;
+    }
+    else if (awt_wm_isFvwm2()) {
         awt_wmgr = OPENLOOK_WM;
     }
     else {
--- jdk/src/solaris/native/sun/awt/awt_wm.h	2012-08-10 10:31:33.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/awt_wm.h	2013-05-05 09:38:40.000000000 -0700
@@ -45,7 +45,10 @@
     KDE2_WM,
     SAWFISH_WM,
     ICE_WM,
-    METACITY_WM
+    METACITY_WM,
+    AFTERSTEP_WM,
+    WINDOWMAKER_WM,
+    FVWM2_WM
 };
 
 extern void awt_wm_init(void);
--- jdk/src/solaris/native/sun/awt/extutil.h	2012-08-10 10:31:33.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/extutil.h	2013-05-05 09:38:40.000000000 -0700
@@ -58,7 +58,7 @@
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ || MACOSX */
+#endif /* __linux__ || _ALLBSD_SOURCE */
--- jdk/src/solaris/native/sun/awt/fontpath.c	2012-08-10 10:31:33.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/fontpath.c	2013-05-05 09:38:40.000000000 -0700
@@ -23,7 +23,7 @@
  * questions.
  */
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif /* __linux__ */
 #include <stdio.h>
@@ -78,7 +78,7 @@
 
 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
 
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 /*
  * This can be set in the makefile to "/usr/X11" if so desired.
  */
@@ -144,6 +144,22 @@
     PACKAGE_PATH "/share/fonts/Type1",
     NULL, /* terminates the list */
 };
+#elif _ALLBSD_SOURCE
+static char *fullBSDFontPath[] = {
+    X11_PATH "/lib/X11/fonts/TrueType",
+    X11_PATH "/lib/X11/fonts/truetype",
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/tt",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #else /* __linux */
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
@@ -395,7 +411,7 @@
 
 #endif /* !HEADLESS */
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -524,6 +540,8 @@
     knowndirs = fullLinuxFontPath;
 #elif defined(MACOSX)
     knowndirs = full_MACOSX_X11FontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #else /* IF SOLARIS */
     knowndirs = fullSolarisFontPath;
 #endif
@@ -534,7 +552,7 @@
      * be initialised.
      */
 #ifndef HEADLESS
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /* There's no headless build on linux ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
@@ -550,7 +568,7 @@
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 #endif /* !HEADLESS */
--- jdk/src/solaris/native/sun/awt/robot_common.c	2012-08-10 10:31:35.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/robot_common.c	2013-05-05 09:38:40.000000000 -0700
@@ -27,7 +27,7 @@
     #error This file should not be included in headless library
 #endif
 
-#ifdef MACOSX
+#ifdef _ALLBSD_SOURCE
 #include <stdlib.h>
 #endif
 
--- jdk/src/solaris/native/sun/awt/splashscreen/splashscreen_config.h	2012-08-10 10:31:35.000000000 -0700
+++ jdk/src/solaris/native/sun/awt/splashscreen/splashscreen_config.h	2013-05-05 09:38:40.000000000 -0700
@@ -32,7 +32,7 @@
 #include <X11/Xutil.h>
 #include <X11/extensions/shape.h>
 #include <sys/types.h>
-#include <unistd.h>
+#include <sys/unistd.h>
 #include <pthread.h>
 #include <signal.h>
 #include <inttypes.h>
--- jdk/src/solaris/native/sun/java2d/j2d_md.h	2012-08-10 10:31:35.000000000 -0700
+++ jdk/src/solaris/native/sun/java2d/j2d_md.h	2013-05-05 09:38:40.000000000 -0700
@@ -28,9 +28,9 @@
 #include <sys/types.h>
 
 /*
- * Linux and MACOSX's version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's's version of <sys/types.h> does not define intptr_t
  */
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
 #endif /* __linux__ || MACOSX */
 
--- jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	2012-08-10 10:31:36.000000000 -0700
+++ jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	2013-05-05 09:38:40.000000000 -0700
@@ -804,7 +804,7 @@
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#if defined(__linux__) || defined(MACOSX)
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
--- jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -46,8 +46,6 @@
 
 #include "sun_nio_ch_DatagramChannelImpl.h"
 
-static jfieldID isa_addrID;     /* address in java.net.InetSocketAddress */
-static jfieldID isa_portID;     /* port in java.net.InetSocketAddress */
 static jfieldID dci_senderID;   /* sender in sun.nio.ch.DatagramChannelImpl */
 static jfieldID dci_senderAddrID; /* sender InetAddress in sun.nio.ch.DatagramChannelImpl */
 static jfieldID dci_senderPortID; /* sender port in sun.nio.ch.DatagramChannelImpl */
@@ -61,9 +59,6 @@
     isa_class = (*env)->NewGlobalRef(env, clazz);
     isa_ctorID = (*env)->GetMethodID(env, clazz, "<init>",
                                      "(Ljava/net/InetAddress;I)V");
-    isa_addrID = (*env)->GetFieldID(env, clazz, "addr",
-                                    "Ljava/net/InetAddress;");
-    isa_portID = (*env)->GetFieldID(env, clazz, "port", "I");
 
     clazz = (*env)->FindClass(env, "sun/nio/ch/DatagramChannelImpl");
     dci_senderID = (*env)->GetFieldID(env, clazz, "sender",
@@ -77,7 +72,7 @@
 
 JNIEXPORT void JNICALL
 Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jobject this,
-                                                jobject fdo, jboolean isIPv6)
+                                                jobject fdo)
 {
     jint fd = fdval(env, fdo);
     int rv;
@@ -94,7 +89,7 @@
         memset(&sa, 0, sizeof(sa));
 
 #ifdef AF_INET6
-        if (isIPv6) {
+        if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&sa;
 #if defined(_ALLBSD_SOURCE)
             him6->sin6_family = AF_INET6;
@@ -212,15 +207,13 @@
 JNIEXPORT jint JNICALL
 Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jobject this,
                                           jboolean preferIPv6, jobject fdo, jlong address,
-                                            jint len, jobject dest)
+                                          jint len, jobject destAddress, jint destPort)
 {
     jint fd = fdval(env, fdo);
     void *buf = (void *)jlong_to_ptr(address);
     SOCKADDR sa;
     int sa_len = SOCKADDR_LEN;
     jint n = 0;
-    jobject destAddress = (*env)->GetObjectField(env, dest, isa_addrID);
-    jint destPort = (*env)->GetIntField(env, dest, isa_portID);
 
     if (len > MAX_PACKET_LEN) {
         len = MAX_PACKET_LEN;
--- jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c	2013-05-05 09:38:40.000000000 -0700
@@ -36,7 +36,6 @@
 #include <sys/socket.h>
 
 #include "nio_util.h"
-#include <limits.h>
 
 JNIEXPORT jint JNICALL
 Java_sun_nio_ch_DatagramDispatcher_read0(JNIEnv *env, jclass clazz,
@@ -61,14 +60,23 @@
     ssize_t result = 0;
     struct iovec *iov = (struct iovec *)jlong_to_ptr(address);
     struct msghdr m;
-    if (len > IOV_MAX) {
-        len = IOV_MAX;
+    if (len > 16) {
+        len = 16;
     }
 
-    // initialize the message
-    memset(&m, 0, sizeof(m));
+    m.msg_name = NULL;
+    m.msg_namelen = 0;
     m.msg_iov = iov;
     m.msg_iovlen = len;
+#ifdef __solaris__
+    m.msg_accrights = NULL;
+    m.msg_accrightslen = 0;
+#endif
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    m.msg_control = NULL;
+    m.msg_controllen = 0;
+#endif
 
     result = recvmsg(fd, &m, 0);
     if (result < 0 && errno == ECONNREFUSED) {
@@ -100,14 +108,23 @@
     struct iovec *iov = (struct iovec *)jlong_to_ptr(address);
     struct msghdr m;
     ssize_t result = 0;
-    if (len > IOV_MAX) {
-        len = IOV_MAX;
+    if (len > 16) {
+        len = 16;
     }
 
-    // initialize the message
-    memset(&m, 0, sizeof(m));
+    m.msg_name = NULL;
+    m.msg_namelen = 0;
     m.msg_iov = iov;
     m.msg_iovlen = len;
+#ifdef __solaris__
+    m.msg_accrights = NULL;
+    m.msg_accrightslen = 0;
+#endif
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    m.msg_control = NULL;
+    m.msg_controllen = 0;
+#endif
 
     result = sendmsg(fd, &m, 0);
     if (result < 0 && errno == ECONNREFUSED) {
--- jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -201,7 +201,7 @@
         return IOS_THROWN;
     }
     return result;
-#elif defined(__APPLE__)
+#elif defined(__APPLE__) || defined(__FreeBSD__)
     off_t numBytes;
     int result;
 
@@ -209,6 +209,8 @@
 
 #ifdef __APPLE__
     result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);
+#elif defined(__FreeBSD__)
+    result = sendfile(srcFD, dstFD, position, count, NULL, &numBytes, 0);
 #endif
 
     if (numBytes > 0)
--- jdk/src/solaris/native/sun/nio/ch/FileDispatcherImpl.c	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/FileDispatcherImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -200,7 +200,7 @@
     }
     lockResult = fcntl(fd, cmd, &fl);
     if (lockResult < 0) {
-        if ((cmd == F_SETLK64) && (errno == EAGAIN || errno == EACCES))
+        if ((cmd == F_SETLK64) && (errno == EAGAIN))
             return sun_nio_ch_FileDispatcherImpl_NO_LOCK;
         if (errno == EINTR)
             return sun_nio_ch_FileDispatcherImpl_INTERRUPTED;
@@ -227,6 +227,21 @@
     fl.l_start = (off64_t)pos;
     fl.l_type = F_UNLCK;
     lockResult = fcntl(fd, cmd, &fl);
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+    /* XXXFREEBSD:  While doing of preClose0() we're closing actual fd which
+       was locked, so here we'll get an error which need to be ignored to
+       satisfy TCK FileLock test */
+    if (lockResult < 0 && errno == EBADF)
+       lockResult = errno = 0;
+#endif
+#if defined(__NetBSD__)
+    /* XXXNETBSD: The dup2 in preClose0 is being done onto 1 end of a
+       socketpair which isn't a valid target for F_UNLCK. No good way to see
+       this vs. a bad lock setup so just return errno = 0 there
+       to pass JCK (lock will get removed once all fd's close anyways) */
+    if (lockResult < 0 && errno == EINVAL)
+       lockResult = errno = 0;
+#endif
     if (lockResult < 0) {
         JNU_ThrowIOExceptionWithLastError(env, "Release failed");
     }
--- jdk/src/solaris/native/sun/nio/ch/Sctp.h	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/Sctp.h	2013-05-05 09:38:40.000000000 -0700
@@ -320,8 +320,20 @@
 typedef int sctp_peeloff_func(int sock, sctp_assoc_t id);
 
 
+#elif defined(__FreeBSD__) && __FreeBSD__ >= 7
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/sctp.h>
+#include <netinet/sctp_peeloff.h>
+#include <netinet/sctp_uio.h>
+#include "jni.h"
+
 #endif /* __linux__ */
 
+#if !defined(__FreeBSD__) || __FreeBSD__ < 7
+
 sctp_getladdrs_func* nio_sctp_getladdrs;
 sctp_freeladdrs_func* nio_sctp_freeladdrs;
 sctp_getpaddrs_func* nio_sctp_getpaddrs;
@@ -329,6 +341,17 @@
 sctp_bindx_func* nio_sctp_bindx;
 sctp_peeloff_func* nio_sctp_peeloff;
 
+#else
+
+#define nio_sctp_getladdrs     sctp_getladdrs
+#define nio_sctp_freeladdrs    sctp_freeladdrs
+#define nio_sctp_getpaddrs     sctp_getpaddrs
+#define nio_sctp_freepaddrs    sctp_freepaddrs
+#define nio_sctp_bindx         sctp_bindx
+#define nio_sctp_peeloff       sctp_peeloff
+
+#endif
+
 jboolean loadSocketExtensionFuncs(JNIEnv* env);
 
 #endif /* !SUN_NIO_CH_SCTP_H */
--- jdk/src/solaris/native/sun/nio/ch/SctpChannelImpl.c	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/SctpChannelImpl.c	2013-05-05 09:38:40.000000000 -0700
@@ -67,8 +67,6 @@
 static jmethodID spc_ctrID;    /* sun.nio.ch.SctpPeerAddressChanged.<init>  */
 static jclass    ss_class;     /* sun.nio.ch.SctpShutdown                   */
 static jmethodID ss_ctrID;     /* sun.nio.ch.SctpShutdown.<init>            */
-static jfieldID  isa_addrID;   /* java.net.InetSocketAddress.addr           */
-static jfieldID  isa_portID;   /* java.net.InetSocketAddress.port           */
 
 /* defined in SctpNet.c */
 jobject SockAddrToInetSocketAddress(JNIEnv* env, struct sockaddr* addr);
@@ -136,13 +134,6 @@
     CHECK_NULL(ss_class);
     ss_ctrID = (*env)->GetMethodID(env, cls, "<init>", "(I)V");
     CHECK_NULL(ss_ctrID);
-
-    /* InetSocketAddress */
-    cls = (*env)->FindClass(env, "java/net/InetSocketAddress");
-    CHECK_NULL(cls);
-    isa_addrID = (*env)->GetFieldID(env, cls, "addr", "Ljava/net/InetAddress;");
-    CHECK_NULL(isa_addrID);
-    isa_portID = (*env)->GetFieldID(env, cls, "port", "I");
 }
 
 void getControlData
@@ -507,12 +498,12 @@
 /*
  * Class:     sun_nio_ch_SctpChannelImpl
  * Method:    send0
- * Signature: (IJILjava/net/SocketAddress;IIZI)I
+ * Signature: (IJILjava/net/InetAddress;IIIZI)I
  */
 JNIEXPORT jint JNICALL Java_sun_nio_ch_SctpChannelImpl_send0
   (JNIEnv *env, jclass klass, jint fd, jlong address, jint length,
-   jobject saTarget, jint assocId, jint streamNumber, jboolean unordered,
-   jint ppid) {
+   jobject targetAddress, jint targetPort, jint assocId, jint streamNumber,
+   jboolean unordered, jint ppid) {
     SOCKADDR sa;
     int sa_len = sizeof(sa);
     ssize_t rv = 0;
@@ -524,17 +515,13 @@
     struct controlData cdata[1];
 
     /* SctpChannel:
-     *    saTarget may contain the preferred address or NULL to use primary,
+     *    targetAddress may contain the preferred address or NULL to use primary,
      *    assocId will always be -1
      * SctpMultiChannell:
-     *    Setup new association, saTarget will contain address, assocId = -1
-     *    Association already existing, assocId != -1, saTarget = preferred addr
+     *    Setup new association, targetAddress will contain address, assocId = -1
+     *    Association already existing, assocId != -1, targetAddress = preferred addr
      */
-    if (saTarget != NULL /*&& assocId <= 0*/) {
-
-        jobject targetAddress = (*env)->GetObjectField(env, saTarget, isa_addrID);
-        jint targetPort = (*env)->GetIntField(env, saTarget, isa_portID);
-
+    if (targetAddress != NULL /*&& assocId <= 0*/) {
         if (NET_InetAddressToSockaddr(env, targetAddress, targetPort,
                                       (struct sockaddr *)&sa,
                                       &sa_len, JNI_TRUE) != 0) {
--- jdk/src/solaris/native/sun/nio/ch/SctpNet.c	2012-08-10 10:31:37.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/ch/SctpNet.c	2013-05-05 09:38:40.000000000 -0700
@@ -58,6 +58,7 @@
  */
 jboolean loadSocketExtensionFuncs
   (JNIEnv* env) {
+#if !defined(__FreeBSD__) || __FreeBSD__ < 7 /* On FreeBSD 7.x these functions are in libc */
     if (dlopen(nativeSctpLib, RTLD_GLOBAL | RTLD_LAZY) == NULL) {
         JNU_ThrowByName(env, "java/lang/UnsupportedOperationException",
               dlerror());
@@ -105,6 +106,7 @@
               dlerror());
         return JNI_FALSE;
     }
+#endif /* __FreeBSD__ */
 
     funcsLoaded = JNI_TRUE;
     return JNI_TRUE;
--- jdk/src/solaris/native/sun/nio/fs/genSolarisConstants.c	2012-08-10 10:31:38.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/fs/genSolarisConstants.c	2013-05-05 09:38:40.000000000 -0700
@@ -27,7 +27,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <sys/acl.h>
-#include <fcntl.h>
+#include <sys/fcntl.h>
 #include <sys/stat.h>
 
 /**
--- jdk/src/solaris/native/sun/nio/fs/genUnixConstants.c	2012-08-10 10:31:38.000000000 -0700
+++ jdk/src/solaris/native/sun/nio/fs/genUnixConstants.c	2013-05-05 09:38:40.000000000 -0700
@@ -26,7 +26,7 @@
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
-#include <fcntl.h>
+#include <sys/fcntl.h>
 #include <sys/stat.h>
 
 /**
@@ -69,12 +69,7 @@
 #else
     DEFX(O_DSYNC);
 #endif
-#ifdef O_NOFOLLOW
     DEFX(O_NOFOLLOW);
-#else
-    // not supported (dummy values will not be used at runtime).
-    emitX("O_NOFOLLOW", 0x0);
-#endif
 
     // mode masks
     emitX("S_IAMB",
--- jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	2012-08-10 10:31:38.000000000 -0700
+++ jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -36,6 +36,11 @@
 
 #include "j2secmod.h"
 
+#ifndef RTLD_NOLOAD
+/* A gross hack that will work if the NSS library is only opened once */
+static void *nssLibHandle = NULL;
+#endif
+
 void *findFunction(JNIEnv *env, jlong jHandle, const char *functionName) {
     void *hModule = (void*)jHandle;
     void *fAddress = dlsym(hModule, functionName);
@@ -53,7 +58,11 @@
 {
     const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);
     // look up existing handle only, do not load
+#ifdef RTLD_NOLOAD
     void *hModule = dlopen(libName, RTLD_NOLOAD);
+#else
+    void *hModule = nssLibHandle;
+#endif
     dprintf2("-handle for %s: %u\n", libName, hModule);
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     return (jlong)hModule;
@@ -67,6 +76,9 @@
 
     dprintf1("-lib %s\n", libName);
     hModule = dlopen(libName, RTLD_LAZY);
+#ifndef RTLD_NOLOAD
+    nssLibHandle = hModule;
+#endif
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     dprintf2("-handle: %u (0X%X)\n", hModule, hModule);
 
--- jdk/src/solaris/native/sun/xawt/XWindow.c	2012-08-10 10:31:38.000000000 -0700
+++ jdk/src/solaris/native/sun/xawt/XWindow.c	2013-05-05 09:38:40.000000000 -0700
@@ -867,7 +867,7 @@
 {
     KeySym originalKeysym = *keysym;
 
-#if !defined(__linux__) && !defined(MACOSX)
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
--- jdk/src/solaris/transport/socket/socket_md.c	2012-08-10 10:31:39.000000000 -0700
+++ jdk/src/solaris/transport/socket/socket_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -35,7 +35,8 @@
 #include <sys/time.h>
 #ifdef __solaris__
 #include <thread.h>
-#else
+#endif
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #include <sys/poll.h>
 #endif
@@ -305,7 +306,9 @@
     return r;
 }
 
-#else
+#endif
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 int
 dbgsysTlsAlloc() {
     pthread_key_t key;
--- jdk/src/windows/bin/cmdtoargs.c	1969-12-31 16:00:00.000000000 -0800
+++ jdk/src/windows/bin/cmdtoargs.c	2013-05-05 09:38:40.000000000 -0700
@@ -0,0 +1,609 @@
+/*
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+/*
+ * Converts a single string command line to the traditional argc, argv.
+ * There are rules which govern the breaking of the the arguments, and
+ * these rules are embodied in the regression tests below, and duplicated
+ * in the jdk regression tests.
+ */
+
+#ifndef IDE_STANDALONE
+#include "java.h"
+#include "jli_util.h"
+#else /* IDE_STANDALONE */
+// The defines we need for stand alone testing
+#include <stdio.h>
+#include <stdlib.h>
+#include <Windows.h>
+#define JNI_TRUE       TRUE
+#define JNI_FALSE      FALSE
+#define JLI_MemRealloc realloc
+#define JLI_StringDup  _strdup
+#define JLI_MemFree    free
+#define jboolean       boolean
+typedef struct  {
+    char* arg;
+    boolean has_wildcard;
+} StdArg ;
+#endif
+static StdArg *stdargs;
+static int    stdargc;
+
+static char* next_arg(char* cmdline, char* arg, jboolean* wildcard) {
+
+    char* src = cmdline;
+    char* dest = arg;
+    jboolean separator = JNI_FALSE;
+    int quotes = 0;
+    int slashes = 0;
+
+    char prev = 0;
+    char ch = 0;
+    int i;
+    jboolean done = JNI_FALSE;
+
+    *wildcard = JNI_FALSE;
+    while ((ch = *src) != 0 && !done) {
+        switch (ch) {
+        case '"':
+            if (separator) {
+                done = JNI_TRUE;
+                break;
+            }
+            if (prev == '\\') {
+                for (i = 1; i < slashes; i += 2) {
+                    *dest++ = prev;
+                }
+                if (slashes % 2 == 1) {
+                    *dest++ = ch;
+                } else {
+                    quotes++;
+                }
+            } else if (prev == '"' && quotes % 2 == 0) {
+                quotes++;
+                *dest++ = ch; // emit every other consecutive quote
+            } else if (quotes == 0) {
+                quotes++; // starting quote
+            } else {
+                quotes--; // matching quote
+            }
+            slashes = 0;
+            break;
+
+        case '\\':
+            slashes++;
+            if (separator) {
+                done = JNI_TRUE;
+                separator = JNI_FALSE;
+            }
+            break;
+
+        case ' ':
+        case '\t':
+            if (prev == '\\') {
+                for (i = 0 ; i < slashes; i++) {
+                   *dest++ = prev;
+                }
+            }
+            if (quotes % 2 == 1) {
+                *dest++ = ch;
+            } else {
+                separator = JNI_TRUE;
+            }
+            slashes = 0;
+            break;
+
+        case '*':
+        case '?':
+            if (separator) {
+                done = JNI_TRUE;
+                separator = JNI_FALSE;
+                break;
+            }
+            if (quotes % 2 == 0) {
+                *wildcard = JNI_TRUE;
+            }
+            if (prev == '\\') {
+                *dest++ = prev;
+            }
+            *dest++ = ch;
+            break;
+
+        default:
+            if (prev == '\\') {
+                for (i = 0 ; i < slashes ; i++) {
+                   *dest++ = prev;
+                }
+                *dest++ = ch;
+            } else if (separator) {
+                done = JNI_TRUE;
+            } else {
+                *dest++ = ch;
+            }
+            slashes = 0;
+        }
+
+        if (!done) {
+            prev = ch;
+            src++;
+        }
+    }
+    if (prev == '\\') {
+        for (i = 0; i < slashes; i++) {
+            *dest++ = prev;
+        }
+    }
+    *dest = 0;
+    return done ? src : NULL;
+}
+
+int JLI_GetStdArgc() {
+    return stdargc;
+}
+
+StdArg* JLI_GetStdArgs() {
+    return stdargs;
+}
+
+void JLI_CmdToArgs(char* cmdline) {
+    int nargs = 0;
+    StdArg* argv = NULL;
+    jboolean wildcard = JNI_FALSE;
+    char* src = cmdline;
+
+    // allocate arg buffer with sufficient space to receive the largest arg
+    char* arg = JLI_StringDup(cmdline);
+
+    do {
+        src = next_arg(src, arg, &wildcard);
+        // resize to accommodate another Arg
+        argv = (StdArg*) JLI_MemRealloc(argv, (nargs+1) * sizeof(StdArg));
+        argv[nargs].arg = JLI_StringDup(arg);
+        argv[nargs].has_wildcard = wildcard;
+
+        nargs++;
+    } while (src != NULL);
+
+    stdargc = nargs;
+    stdargs = argv;
+}
+
+#ifdef IDE_STANDALONE
+void doexit(int rv) {
+    printf("Hit any key to quit\n");
+    int c = getchar();
+    exit(rv);
+}
+
+void doabort() {
+    doexit(1);
+}
+
+class Vector {
+public:
+    char* cmdline;
+    int argc;
+    char* argv[10];
+    boolean wildcard[10];
+    boolean enabled;
+
+    Vector(){}
+    // Initialize our test vector with the program name, argv[0]
+    // and the single string command line.
+    Vector(char* pname, char* cline) {
+        argv[0] = pname;
+        wildcard[0] = FALSE;
+        cmdline = cline;
+        argc = 1;
+        enabled = TRUE;
+    }
+
+    // add our expected strings, the program name has already been
+    // added so ignore that
+    void add(char* arg, boolean w) {
+        argv[argc] = arg;
+        wildcard[argc] = w;
+        argc++;
+    }
+
+    void disable() {
+        enabled = FALSE;
+    }
+
+    // validate the returned arguments with the expected arguments, using the
+    // new CmdToArgs method.
+    bool check() {
+        // "pgmname" rest of cmdline ie. pgmname + 2 double quotes + space + cmdline from windows
+        char* cptr = (char*) malloc(strlen(argv[0]) + sizeof(char) * 3 + strlen(cmdline) + 1);
+        _snprintf(cptr, MAX_PATH, "\"%s\" %s", argv[0], cmdline);
+        JLI_CmdToArgs(cptr);
+        free(cptr);
+        StdArg *kargv = JLI_GetStdArgs();
+        int     kargc = JLI_GetStdArgc();
+        bool retval = true;
+        printf("\n===========================\n");
+        printf("cmdline=%s\n", cmdline);
+        if (argc != kargc) {
+            printf("*** argument count does not match\n");
+            printme();
+            printtest(kargc, kargv);
+            doabort();
+        }
+        for (int i = 0 ; i < argc && retval == true ; i++) {
+            if (strcmp(argv[i], kargv[i].arg) != 0) {
+                printf("*** argument at [%d] don't match\n  got: %s\n  exp: %s\n",
+                       i, kargv[i].arg, argv[i]);
+                doabort();
+            }
+        }
+        for (int i = 0 ; i < argc && retval == true ; i++) {
+            if (wildcard[i] != kargv[i].has_wildcard) {
+                printf("*** expansion flag at [%d] doesn't match\n  got: %d\n  exp: %d\n",
+                       i, kargv[i].has_wildcard, wildcard[i]);
+                doabort();
+            }
+        }
+        for (int i = 0 ; i < kargc ; i++) {
+            printf("k[%d]=%s\n", i, kargv[i].arg);
+            printf(" [%d]=%s\n", i, argv[i]);
+        }
+        return retval;
+    }
+    void printtest(int kargc, StdArg* kargv) {
+        for (int i = 0 ; i < kargc ; i++) {
+            printf("k[%d]=%s\n", i, kargv[i].arg);
+        }
+    }
+    void printme() {
+        for (int i = 0 ; i < argc ; i++) {
+            printf(" [%d]=%s\n", i, argv[i]);
+        }
+    }
+};
+
+void dotest(Vector** vectors) {
+    Vector* v = vectors[0];
+    for (int i = 0 ; v != NULL;) {
+        if (v->enabled) {
+            v->check();
+        }
+        v = vectors[++i];
+    }
+}
+
+#define MAXV 128
+int main(int argc, char* argv[]) {
+
+    int n;
+    for (n=1; n < argc; n++) {
+        printf("%d %s\n", n, argv[n]);
+    }
+    if (n > 1) {
+        JLI_CmdToArgs(GetCommandLine());
+        for (n = 0; n < stdargc; n++) {
+            printf(" [%d]=%s\n", n, stdargs[n].arg);
+            printf(" [%d]=%s\n", n, stdargs[n].has_wildcard ? "TRUE" : "FALSE");
+        }
+        doexit(0);
+    }
+
+    Vector *vectors[MAXV];
+
+    memset(vectors, 0, sizeof(vectors));
+    int i = 0;
+    Vector* v = new Vector(argv[0], "abcd");
+    v->add("abcd", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"a b c d\"");
+    v->add("a b c d", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a\"b c d\"e");
+    v->add("ab c de", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "ab\\\"cd");
+    v->add("ab\"cd", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"a b c d\\\\\"");
+    v->add("a b c d\\", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "ab\\\\\\\"cd");
+    v->add("ab\\\"cd", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    // Windows tests
+    v = new Vector(argv[0], "a\\\\\\c");
+    v->add("a\\\\\\c", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"a\\\\\\d\"");
+    v->add("a\\\\\\d", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"a b c\" d e");
+    v->add("a b c", FALSE);
+    v->add("d", FALSE);
+    v->add("e", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"ab\\\"c\"  \"\\\\\"  d");
+    v->add("ab\"c", FALSE);
+    v->add("\\", FALSE);
+    v->add("d", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a\\\\\\c d\"e f\"g h");
+    v->add("a\\\\\\c", FALSE);
+    v->add("de fg", FALSE);
+    v->add("h", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a\\\\\\\"b c d");
+    v->add("a\\\"b", FALSE); // XXX "a\\\\\\\"b"
+    v->add("c", FALSE);
+    v->add("d", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a\\\\\\\\\"g c\" d e"); // XXX "a\\\\\\\\\"b c\" d e"
+    v->add("a\\\\\g c", FALSE); // XXX "a\\\\\\\\\"b c"
+    v->add("d", FALSE);
+    v->add("e", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    // Additional tests
+    v = new Vector(argv[0], "\"a b c\"\"");
+    v->add("a b c\"", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"\"a b c\"\"");
+    v->add("a", FALSE);
+    v->add("b", FALSE);
+    v->add("c", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"\"\"a b c\"\"\"");
+    v->add("\"a b c\"", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"\"\"\"a b c\"\"\"\"");
+    v->add("\"a", FALSE);
+    v->add("b", FALSE);
+    v->add("c\"", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"\"\"\"\"a b c\"\"\"\"\"");
+    v->add("\"\"a b c\"\"", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"C:\\TEST A\\\\\"");
+    v->add("C:\\TEST A\\", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"\"C:\\TEST A\\\\\"\"");
+    v->add("C:\\TEST", FALSE);
+    v->add("A\\", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    // test if a wildcard is present
+    v = new Vector(argv[0], "abc*def");
+    v->add("abc*def", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"abc*def\"");
+    v->add("abc*def", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "*.abc");
+    v->add("*.abc", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"*.abc\"");
+    v->add("*.abc", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "x.???");
+    v->add("x.???", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\"x.???\"");
+    v->add("x.???", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "Debug\\*");
+    v->add("Debug\\*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "Debug\\f?a");
+    v->add("Debug\\f?a", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "Debug\\?a.java");
+    v->add("Debug\\?a.java", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "foo *.noexts");
+    v->add("foo", FALSE);
+    v->add("*.noexts", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "X\\Y\\Z");
+    v->add("X\\Y\\Z", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "\\X\\Y\\Z");
+    v->add("\\X\\Y\\Z", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a b");
+    v->add("a", FALSE);
+    v->add("b", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a\tb");
+    v->add("a", FALSE);
+    v->add("b", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+
+    v = new Vector(argv[0], "a \t b");
+    v->add("a", FALSE);
+    v->add("b", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "*\\");
+    v->add("*\\", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "*/");
+    v->add("*/", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], ".\\*");
+    v->add(".\\*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "./*");
+    v->add("./*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], ".\\*");
+    v->add(".\\*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], ".//*");
+    v->add(".//*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "..\\..\\*");
+    v->add("..\\..\\*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "../../*");
+    v->add("../../*", TRUE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "..\\..\\");
+    v->add("..\\..\\", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v = new Vector(argv[0], "../../");
+    v->add("../../", FALSE);
+    // v->disable();
+    vectors[i++] = v;
+
+    v= new Vector(argv[0], "a b\\\\ d");
+    v->add("a", FALSE);
+    v->add("b\\\\", FALSE);
+    v->add("d", FALSE);
+    vectors[i++] = v;
+
+    dotest(vectors);
+    printf("All tests pass [%d]\n", i);
+    doexit(0);
+}
+#endif /* IDE_STANDALONE */
--- jdk/src/windows/bin/java_md.c	2012-08-10 10:31:39.000000000 -0700
+++ jdk/src/windows/bin/java_md.c	2013-05-05 09:38:40.000000000 -0700
@@ -101,7 +101,6 @@
 /* funtion in awt.dll (src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp) */
 #define D3D_PRELOAD_FUNC "preloadD3D"
 
-
 /* Extracts value of a parameter with the specified name
  * from command line argument (returns pointer in the argument).
  * Returns NULL if the argument does not contains the parameter.
@@ -202,7 +201,7 @@
     }
 
     JLI_Snprintf(jvmcfg, so_jvmcfg, "%s%slib%s%s%sjvm.cfg",
-        jrepath, FILESEP, FILESEP, (char*)GetArch(), FILESEP);
+                 jrepath, FILESEP, FILESEP, (char*)GetArch(), FILESEP);
 
     /* Find the specified JVM type */
     if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {
@@ -276,7 +275,8 @@
 #endif
 #ifdef CRT_DLL
         if (GetJREPath(crtpath, MAXPATHLEN)) {
-            if (JLI_StrLen(crtpath) + JLI_StrLen("\\bin\\") + JLI_StrLen(CRT_DLL) >= MAXPATHLEN) {
+            if (JLI_StrLen(crtpath) + JLI_StrLen("\\bin\\") +
+                    JLI_StrLen(CRT_DLL) >= MAXPATHLEN) {
                 JLI_ReportErrorMessage(JRE_ERROR11);
                 return JNI_FALSE;
             }
@@ -347,7 +347,8 @@
     if (JLI_StrChr(jvmtype, '/') || JLI_StrChr(jvmtype, '\\')) {
         JLI_Snprintf(jvmpath, jvmpathsize, "%s\\" JVM_DLL, jvmtype);
     } else {
-        JLI_Snprintf(jvmpath, jvmpathsize, "%s\\bin\\%s\\" JVM_DLL, jrepath, jvmtype);
+        JLI_Snprintf(jvmpath, jvmpathsize, "%s\\bin\\%s\\" JVM_DLL,
+                     jrepath, jvmtype);
     }
     if (stat(jvmpath, &s) == 0) {
         return JNI_TRUE;
@@ -525,6 +526,37 @@
     }
     return (counts * 1000 * 1000)/counterFrequency.QuadPart;
 }
+/*
+ * windows snprintf does not guarantee a null terminator in the buffer,
+ * if the computed size is equal to or greater than the buffer size,
+ * as well as error conditions. This function guarantees a null terminator
+ * under all these conditions. An unreasonable buffer or size will return
+ * an error value. Under all other conditions this function will return the
+ * size of the bytes actually written minus the null terminator, similar
+ * to ansi snprintf api. Thus when calling this function the caller must
+ * ensure storage for the null terminator.
+ */
+int
+JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {
+    int rc;
+    va_list vl;
+    if (size == 0 || buffer == NULL)
+        return -1;
+    buffer[0] = '\0';
+    va_start(vl, format);
+    rc = vsnprintf(buffer, size, format, vl);
+    va_end(vl);
+    /* force a null terminator, if something is amiss */
+    if (rc < 0) {
+        /* apply ansi semantics */
+        buffer[size - 1] = '\0';
+        return size;
+    } else if (rc == size) {
+        /* force a null terminator */
+        buffer[size - 1] = '\0';
+    }
+    return rc;
+}
 
 void
 JLI_ReportErrorMessage(const char* fmt, ...) {
@@ -880,7 +912,7 @@
  */
 void
 ExecJRE(char *jre, char **argv) {
-    int     len;
+    jint     len;
     char    path[MAXPATHLEN + 1];
 
     const char *progname = GetProgramName();
@@ -1357,3 +1389,92 @@
 {
     return JNI_FALSE;
 }
+
+/*
+ * At this point we have the arguments to the application, and we need to
+ * check with original stdargs in order to compare which of these truly
+ * needs expansion. cmdtoargs will specify this if it finds a bare
+ * (unquoted) argument containing a glob character(s) ie. * or ?
+ */
+jobjectArray
+CreateApplicationArgs(JNIEnv *env, char **strv, int argc)
+{
+    int i, j, idx, tlen;
+    jobjectArray outArray, inArray;
+    char *ostart, *astart, **nargv;
+    jboolean needs_expansion = JNI_FALSE;
+    jmethodID mid;
+    int stdargc;
+    StdArg *stdargs;
+    jclass cls = GetLauncherHelperClass(env);
+    NULL_CHECK0(cls);
+
+    if (argc == 0) {
+        return NewPlatformStringArray(env, strv, argc);
+    }
+    // the holy grail we need to compare with.
+    stdargs = JLI_GetStdArgs();
+    stdargc = JLI_GetStdArgc();
+
+    // sanity check, this should never happen
+    if (argc > stdargc) {
+        JLI_TraceLauncher("Warning: app args is larger than the original, %d %d\n", argc, stdargc);
+        JLI_TraceLauncher("passing arguments as-is.\n");
+        return NewPlatformStringArray(env, strv, argc);
+    }
+
+    // sanity check, match the args we have, to the holy grail
+    idx = stdargc - argc;
+    ostart = stdargs[idx].arg;
+    astart = strv[0];
+    // sanity check, ensure that the first argument of the arrays are the same
+    if (JLI_StrCmp(ostart, astart) != 0) {
+        // some thing is amiss the args don't match
+        JLI_TraceLauncher("Warning: app args parsing error\n");
+        JLI_TraceLauncher("passing arguments as-is\n");
+        return NewPlatformStringArray(env, strv, argc);
+    }
+
+    // make a copy of the args which will be expanded in java if required.
+    nargv = (char **)JLI_MemAlloc(argc * sizeof(char*));
+    for (i = 0, j = idx; i < argc; i++, j++) {
+        jboolean arg_expand = (JLI_StrCmp(stdargs[j].arg, strv[i]) == 0)
+                                ? stdargs[j].has_wildcard
+                                : JNI_FALSE;
+        if (needs_expansion == JNI_FALSE)
+            needs_expansion = arg_expand;
+
+        // indicator char + String + NULL terminator, the java method will strip
+        // out the first character, the indicator character, so no matter what
+        // we add the indicator
+        tlen = 1 + JLI_StrLen(strv[i]) + 1;
+        nargv[i] = (char *) JLI_MemAlloc(tlen);
+        if (JLI_Snprintf(nargv[i], tlen, "%c%s", arg_expand ? 'T' : 'F',
+                         strv[i]) < 0) {
+            return NULL;
+        }
+        JLI_TraceLauncher("%s\n", nargv[i]);
+    }
+
+    if (!needs_expansion) {
+        // clean up any allocated memory and return back the old arguments
+        for (i = 0 ; i < argc ; i++) {
+            JLI_MemFree(nargv[i]);
+        }
+        JLI_MemFree(nargv);
+        return NewPlatformStringArray(env, strv, argc);
+    }
+    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, cls,
+                                                "expandArgs",
+                                                "([Ljava/lang/String;)[Ljava/lang/String;"));
+
+    // expand the arguments that require expansion, the java method will strip
+    // out the indicator character.
+    inArray = NewPlatformStringArray(env, nargv, argc);
+    outArray = (*env)->CallStaticObjectMethod(env, cls, mid, inArray);
+    for (i = 0; i < argc; i++) {
+        JLI_MemFree(nargv[i]);
+    }
+    JLI_MemFree(nargv);
+    return outArray;
+}
--- jdk/src/windows/classes/java/lang/ProcessImpl.java	2012-08-10 10:31:40.000000000 -0700
+++ jdk/src/windows/classes/java/lang/ProcessImpl.java	2013-05-05 09:38:40.000000000 -0700
@@ -144,6 +144,88 @@
 
     }
 
+    // We guarantee the only command file execution for implicit [cmd.exe] run.
+    //    http://technet.microsoft.com/en-us/library/bb490954.aspx
+    private static final char CMD_BAT_ESCAPE[] = {' ', '\t', '<', '>', '&', '|', '^'};
+    private static final char WIN32_EXECUTABLE_ESCAPE[] = {' ', '\t', '<', '>'};
+
+    private static boolean isQuoted(boolean noQuotesInside, String arg,
+            String errorMessage) {
+        int lastPos = arg.length() - 1;
+        if (lastPos >=1 && arg.charAt(0) == '"' && arg.charAt(lastPos) == '"') {
+            // The argument has already been quoted.
+            if (noQuotesInside) {
+                if (arg.indexOf('"', 1) != lastPos) {
+                    // There is ["] inside.
+                    throw new IllegalArgumentException(errorMessage);
+                }
+            }
+            return true;
+        }
+        if (noQuotesInside) {
+            if (arg.indexOf('"') >= 0) {
+                // There is ["] inside.
+                throw new IllegalArgumentException(errorMessage);
+            }
+        }
+        return false;
+    }
+
+    private static boolean needsEscaping(boolean isCmdFile, String arg) {
+        // Switch off MS heuristic for internal ["].
+        // Please, use the explicit [cmd.exe] call
+        // if you need the internal ["].
+        //    Example: "cmd.exe", "/C", "Extended_MS_Syntax"
+
+        // For [.exe] or [.com] file the unpaired/internal ["]
+        // in the argument is not a problem.
+        boolean argIsQuoted = isQuoted(isCmdFile, arg,
+            "Argument has embedded quote, use the explicit CMD.EXE call.");
+
+        if (!argIsQuoted) {
+            char testEscape[] = isCmdFile
+                    ? CMD_BAT_ESCAPE
+                    : WIN32_EXECUTABLE_ESCAPE;
+            for (int i = 0; i < testEscape.length; ++i) {
+                if (arg.indexOf(testEscape[i]) >= 0) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private static String getExecutablePath(String path)
+        throws IOException
+    {
+        boolean pathIsQuoted = isQuoted(true, path,
+                "Executable name has embedded quote, split the arguments");
+
+        // Win32 CreateProcess requires path to be normalized
+        File fileToRun = new File(pathIsQuoted
+            ? path.substring(1, path.length() - 1)
+            : path);
+
+        // From the [CreateProcess] function documentation:
+        //
+        // "If the file name does not contain an extension, .exe is appended.
+        // Therefore, if the file name extension is .com, this parameter
+        // must include the .com extension. If the file name ends in
+        // a period (.) with no extension, or if the file name contains a path,
+        // .exe is not appended."
+        //
+        // "If the file name !does not contain a directory path!,
+        // the system searches for the executable file in the following
+        // sequence:..."
+        //
+        // In practice ANY non-existent path is extended by [.exe] extension
+        // in the [CreateProcess] funcion with the only exception:
+        // the path ends by (.)
+
+        return fileToRun.getPath();
+    }
+
+
     private long handle = 0;
     private OutputStream stdin_stream;
     private InputStream stdout_stream;
@@ -156,30 +238,47 @@
                         final boolean redirectErrorStream)
         throws IOException
     {
-        // Win32 CreateProcess requires cmd[0] to be normalized
-        cmd[0] = new File(cmd[0]).getPath();
+        // The [executablePath] is not quoted for any case.
+        String executablePath = getExecutablePath(cmd[0]);
+
+        // We need to extend the argument verification procedure
+        // to guarantee the only command file execution for implicit [cmd.exe]
+        // run.
+        String upPath = executablePath.toUpperCase();
+        boolean isCmdFile = (upPath.endsWith(".CMD") || upPath.endsWith(".BAT"));
 
         StringBuilder cmdbuf = new StringBuilder(80);
-        for (int i = 0; i < cmd.length; i++) {
-            if (i > 0) {
-                cmdbuf.append(' ');
-            }
+
+        // Quotation protects from interpretation of the [path] argument as
+        // start of longer path with spaces. Quotation has no influence to
+        // [.exe] extension heuristic.
+        cmdbuf.append('"');
+        cmdbuf.append(executablePath);
+        cmdbuf.append('"');
+
+        for (int i = 1; i < cmd.length; i++) {
+            cmdbuf.append(' ');
             String s = cmd[i];
-            if (s.indexOf(' ') >= 0 || s.indexOf('\t') >= 0) {
-                if (s.charAt(0) != '"') {
-                    cmdbuf.append('"');
-                    cmdbuf.append(s);
-                    if (s.endsWith("\\")) {
-                        cmdbuf.append("\\");
-                    }
-                    cmdbuf.append('"');
-                } else if (s.endsWith("\"")) {
-                    /* The argument has already been quoted. */
-                    cmdbuf.append(s);
-                } else {
-                    /* Unmatched quote for the argument. */
-                    throw new IllegalArgumentException();
+            if (needsEscaping(isCmdFile, s)) {
+                cmdbuf.append('"');
+                cmdbuf.append(s);
+
+                // The code protects the [java.exe] and console command line
+                // parser, that interprets the [\"] combination as an escape
+                // sequence for the ["] char.
+                //     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
+                //
+                // If the argument is an FS path, doubling of the tail [\]
+                // char is not a problem for non-console applications.
+                //
+                // The [\"] sequence is not an escape sequence for the [cmd.exe]
+                // command line parser. The case of the [""] tail escape
+                // sequence could not be realized due to the argument validation
+                // procedure.
+                if (!isCmdFile && s.endsWith("\\")) {
+                    cmdbuf.append('\\');
                 }
+                cmdbuf.append('"');
             } else {
                 cmdbuf.append(s);
             }
--- jdk/src/windows/classes/sun/awt/windows/WCanvasPeer.java	2012-08-10 10:31:41.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WCanvasPeer.java	2013-05-05 09:38:40.000000000 -0700
@@ -27,7 +27,6 @@
 import java.awt.*;
 import java.awt.peer.*;
 import java.lang.ref.WeakReference;
-import java.lang.reflect.Method;
 import sun.awt.SunToolkit;
 import sun.awt.Win32GraphicsDevice;
 import sun.awt.PaintEventDispatcher;
--- jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java	2012-08-10 10:31:41.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java	2013-05-05 09:38:40.000000000 -0700
@@ -491,14 +491,15 @@
                     try {
                         replaceSurfaceData();
                     } catch (InvalidPipeException e) {
-                    // REMIND : what do we do if our surface creation failed?
+                        // REMIND : what do we do if our surface creation failed?
                     }
                 }
             }
         };
+        Component c = (Component)target;
         // Fix 6255371.
-        if (!PaintEventDispatcher.getPaintEventDispatcher().queueSurfaceDataReplacing((Component)target, r)) {
-            postEvent(new InvocationEvent(Toolkit.getDefaultToolkit(), r));
+        if (!PaintEventDispatcher.getPaintEventDispatcher().queueSurfaceDataReplacing(c, r)) {
+            postEvent(new InvocationEvent(c, r));
         }
     }
 
@@ -620,7 +621,7 @@
     }
 
     public void disposeLater() {
-        postEvent(new InvocationEvent(Toolkit.getDefaultToolkit(), new Runnable() {
+        postEvent(new InvocationEvent(target, new Runnable() {
             public void run() {
                 dispose();
             }
--- jdk/src/windows/classes/sun/awt/windows/WEmbeddedFrame.java	2012-08-10 10:31:41.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WEmbeddedFrame.java	2013-05-05 09:38:40.000000000 -0700
@@ -29,12 +29,9 @@
 import java.awt.*;
 import java.awt.event.*;
 import java.awt.peer.ComponentPeer;
-import java.util.*;
-import java.awt.color.*;
 import java.awt.image.*;
 import sun.awt.image.ByteInterleavedRaster;
 import sun.security.action.GetPropertyAction;
-import java.lang.reflect.*;
 
 public class WEmbeddedFrame extends EmbeddedFrame {
 
@@ -232,11 +229,13 @@
         } else {
             // To avoid focus concurrence b/w IE and EmbeddedFrame
             // activation is postponed by means of posting it to EDT.
-            EventQueue.invokeLater(new Runnable() {
-                    public void run() {
-                        ((WEmbeddedFramePeer)getPeer()).synthesizeWmActivate(true);
-                    }
-                });
+            Runnable r = new Runnable() {
+                public void run() {
+                    ((WEmbeddedFramePeer)getPeer()).synthesizeWmActivate(true);
+                }
+            };
+            WToolkit.postEvent(WToolkit.targetToAppContext(this),
+                               new InvocationEvent(this, r));
         }
     }
 
--- jdk/src/windows/classes/sun/awt/windows/WFileDialogPeer.java	2012-08-10 10:31:41.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WFileDialogPeer.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -237,7 +237,7 @@
 
     // unused methods.  Overridden to disable this functionality as
     // it requires HWND which is not available for FileDialog
-    public void setAlwaysOnTop(boolean value) {}
+    public void updateAlwaysOnTopState() {}
     public void setDirectory(String dir) {}
     public void setFile(String file) {}
     public void setTitle(String title) {}
--- jdk/src/windows/classes/sun/awt/windows/WMouseDragGestureRecognizer.java	2012-08-10 10:31:42.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WMouseDragGestureRecognizer.java	2013-05-05 09:38:40.000000000 -0700
@@ -39,8 +39,6 @@
 import java.awt.event.MouseListener;
 import java.awt.event.MouseMotionListener;
 
-import java.lang.reflect.*;
-
 import sun.awt.dnd.SunDragSourceContextPeer;
 
 /**
--- jdk/src/windows/classes/sun/awt/windows/WPopupMenuPeer.java	2012-08-10 10:31:42.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WPopupMenuPeer.java	2013-05-05 09:38:40.000000000 -0700
@@ -26,9 +26,7 @@
 
 import java.awt.*;
 import java.awt.peer.*;
-import java.lang.reflect.Field;
 
-import sun.awt.SunToolkit;
 import sun.awt.AWTAccessor;
 
 public class WPopupMenuPeer extends WMenuPeer implements PopupMenuPeer {
--- jdk/src/windows/classes/sun/awt/windows/WPrintDialogPeer.java	2012-08-10 10:31:42.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WPrintDialogPeer.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -117,7 +117,7 @@
     // unused methods.  Overridden to disable this functionality as
     // it requires HWND which is not available for FileDialog
     void initialize() {}
-    public void setAlwaysOnTop(boolean b) {}
+    public void updateAlwaysOnTopState() {}
     public void setResizable(boolean resizable) {}
     public void hide() {}
     public void enable() {}
--- jdk/src/windows/classes/sun/awt/windows/WWindowPeer.java	2012-08-10 10:31:42.000000000 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WWindowPeer.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,8 +31,6 @@
 
 import java.beans.*;
 
-import java.lang.reflect.*;
-
 import java.util.*;
 import java.util.List;
 import sun.util.logging.PlatformLogger;
@@ -134,6 +132,10 @@
         }
     }
 
+    public void updateAlwaysOnTopState() {
+        setAlwaysOnTop(((Window)target).isAlwaysOnTop());
+    }
+
     public void updateFocusableWindowState() {
         setFocusableWindow(((Window)target).isFocusableWindow());
     }
--- jdk/src/windows/classes/sun/net/www/protocol/http/ntlm/NTLMAuthSequence.java	2012-08-10 10:31:45.000000000 -0700
+++ jdk/src/windows/classes/sun/net/www/protocol/http/ntlm/NTLMAuthSequence.java	2013-05-05 09:38:40.000000000 -0700
@@ -45,15 +45,25 @@
     private long ctxHandle;
 
     static {
-        initFirst();
+        initFirst(Status.class);
     }
 
+    // Used by native code to indicate when a particular protocol sequence is completed
+    // and must not be re-used.
+
+    class Status {
+        boolean sequenceComplete;
+    }
+
+    Status status;
+
     NTLMAuthSequence (String username, String password, String ntdomain)
     throws IOException
     {
         this.username = username;
         this.password = password;
         this.ntdomain = ntdomain;
+        this.status = new Status();
         state = 0;
         crdHandle = getCredentialsHandle (username, ntdomain, password);
         if (crdHandle == 0) {
@@ -63,19 +73,26 @@
 
     public String getAuthHeader (String token) throws IOException {
         byte[] input = null;
+
+        assert !status.sequenceComplete;
+
         if (token != null)
             input = (new BASE64Decoder()).decodeBuffer(token);
-        byte[] b = getNextToken (crdHandle, input);
+        byte[] b = getNextToken (crdHandle, input, status);
         if (b == null)
             throw new IOException ("Internal authentication error");
         return (new B64Encoder()).encode (b);
     }
 
-    private native static void initFirst ();
+    public boolean isComplete() {
+        return status.sequenceComplete;
+    }
+
+    private native static void initFirst (Class<NTLMAuthSequence.Status> clazz);
 
     private native long getCredentialsHandle (String user, String domain, String password);
 
-    private native byte[] getNextToken (long crdHandle, byte[] lastToken);
+    private native byte[] getNextToken (long crdHandle, byte[] lastToken, Status returned);
 }
 
 class B64Encoder extends BASE64Encoder {
--- jdk/src/windows/classes/sun/net/www/protocol/http/ntlm/NTLMAuthentication.java	2012-08-10 10:31:45.000000000 -0700
+++ jdk/src/windows/classes/sun/net/www/protocol/http/ntlm/NTLMAuthentication.java	2013-05-05 09:38:40.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -186,6 +186,7 @@
     public synchronized boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {
 
         try {
+
             NTLMAuthSequence seq = (NTLMAuthSequence)conn.authObj();
             if (seq == null) {
                 seq = new NTLMAuthSequence (username, password, ntdomain);
@@ -193,8 +194,12 @@
             }
             String response = "NTLM " + seq.getAuthHeader (raw.length()>6?raw.substring(5):null);
             conn.setAuthenticationProperty(getHeaderName(), response);
+            if (seq.isComplete()) { // 7200720
+                conn.authObj(null);
+            }
             return true;
         } catch (IOException e) {
+            conn.authObj(null); // MMM 7200720 ??
             return false;
         }
     }
--- jdk/src/windows/native/java/net/Inet4AddressImpl.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/Inet4AddressImpl.c	2013-05-05 09:38:41.000000000 -0700
@@ -114,9 +114,6 @@
 static jclass ni_iacls;
 static jclass ni_ia4cls;
 static jmethodID ni_ia4ctrID;
-static jfieldID ni_iaaddressID;
-static jfieldID ni_iahostID;
-static jfieldID ni_iafamilyID;
 static int initialized = 0;
 
 /*
@@ -149,9 +146,6 @@
       ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
       ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
       ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
-      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
-      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
-      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
       initialized = 1;
     }
 
@@ -208,8 +202,7 @@
           ret = NULL;
           goto cleanupAndReturn;
         }
-        (*env)->SetIntField(env, iaObj, ni_iaaddressID,
-                            ntohl(address));
+        setInetAddress_addr(env, iaObj, ntohl(address));
         (*env)->SetObjectArrayElement(env, ret, 0, iaObj);
         JNU_ReleaseStringPlatformChars(env, host, hostname);
         return ret;
@@ -242,9 +235,8 @@
             ret = NULL;
             goto cleanupAndReturn;
           }
-          (*env)->SetIntField(env, iaObj, ni_iaaddressID,
-                              ntohl((*addrp)->s_addr));
-          (*env)->SetObjectField(env, iaObj, ni_iahostID, host);
+          setInetAddress_addr(env, iaObj, ntohl((*addrp)->s_addr));
+          setInetAddress_hostName(env, iaObj, host);
           (*env)->SetObjectArrayElement(env, ret, i, iaObj);
           addrp++;
           i++;
--- jdk/src/windows/native/java/net/Inet6AddressImpl.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/Inet6AddressImpl.c	2013-05-05 09:38:41.000000000 -0700
@@ -77,9 +77,6 @@
 static jclass ni_ia6cls;
 static jmethodID ni_ia4ctrID;
 static jmethodID ni_ia6ctrID;
-static jfieldID ni_iaaddressID;
-static jfieldID ni_iahostID;
-static jfieldID ni_iafamilyID;
 static jfieldID ni_ia6ipaddressID;
 static int initialized = 0;
 
@@ -104,9 +101,6 @@
       ni_ia6cls = (*env)->NewGlobalRef(env, ni_ia6cls);
       ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
       ni_ia6ctrID = (*env)->GetMethodID(env, ni_ia6cls, "<init>", "()V");
-      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
-      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
-      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
       ni_ia6ipaddressID = (*env)->GetFieldID(env, ni_ia6cls, "ipaddress", "[B");
       initialized = 1;
     }
@@ -243,9 +237,8 @@
                 ret = NULL;
                 goto cleanupAndReturn;
               }
-              (*env)->SetIntField(env, iaObj, ni_iaaddressID,
-                                  ntohl(((struct sockaddr_in*)iterator->ai_addr)->sin_addr.s_addr));
-              (*env)->SetObjectField(env, iaObj, ni_iahostID, host);
+              setInetAddress_addr(env, iaObj, ntohl(((struct sockaddr_in*)iterator->ai_addr)->sin_addr.s_addr));
+              setInetAddress_hostName(env, iaObj, host);
               (*env)->SetObjectArrayElement(env, ret, inetIndex, iaObj);
                 inetIndex ++;
             } else if (iterator->ai_family == AF_INET6) {
@@ -269,7 +262,7 @@
                 (*env)->SetBooleanField(env, iaObj, ia6_scopeidsetID, JNI_TRUE);
               }
               (*env)->SetObjectField(env, iaObj, ni_ia6ipaddressID, ipaddress);
-              (*env)->SetObjectField(env, iaObj, ni_iahostID, host);
+              setInetAddress_hostName(env, iaObj, host);
               (*env)->SetObjectArrayElement(env, ret, inet6Index, iaObj);
               inet6Index ++;
             }
--- jdk/src/windows/native/java/net/NetworkInterface.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/NetworkInterface.c	2013-05-05 09:38:41.000000000 -0700
@@ -66,7 +66,6 @@
 jfieldID ni_displayNameID;  /* NetworkInterface.displayName */
 jfieldID ni_childsID;       /* NetworkInterface.childs */
 jclass ni_iacls;            /* InetAddress */
-jfieldID ni_iaAddr;         /* InetAddress.address */
 
 jclass ni_ia4cls;           /* Inet4Address */
 jmethodID ni_ia4Ctor;       /* Inet4Address() */
@@ -445,7 +444,6 @@
 
     ni_iacls = (*env)->FindClass(env, "java/net/InetAddress");
     ni_iacls = (*env)->NewGlobalRef(env, ni_iacls);
-    ni_iaAddr = (*env)->GetFieldID(env, ni_iacls, "address", "I");
 
     ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
     ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
@@ -504,7 +502,8 @@
      */
     if (netaddrCount < 0) {
         netaddrCount = enumAddresses_win(env, ifs, &netaddrP);
-        if (netaddrCount == -1) {
+        if ((*env)->ExceptionOccurred(env)) {
+            free_netaddr(netaddrP);
             return NULL;
         }
     }
@@ -533,7 +532,7 @@
             }
             /* default ctor will set family to AF_INET */
 
-            (*env)->SetIntField(env, iaObj, ni_iaAddr, ntohl(addrs->addr.him4.sin_addr.s_addr));
+            setInetAddress_addr(env, iaObj, ntohl(addrs->addr.him4.sin_addr.s_addr));
             if (addrs->mask != -1) {
               ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);
               if (ibObj == NULL) {
@@ -546,8 +545,7 @@
                 free_netaddr(netaddrP);
                 return NULL;
               }
-              (*env)->SetIntField(env, ia2Obj, ni_iaAddr,
-                                  ntohl(addrs->brdcast.him4.sin_addr.s_addr));
+              setInetAddress_addr(env, ia2Obj, ntohl(addrs->brdcast.him4.sin_addr.s_addr));
               (*env)->SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);
               (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);
               (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);
@@ -701,7 +699,7 @@
     (JNIEnv *env, jclass cls, jobject iaObj)
 {
     netif *ifList, *curr;
-    jint addr = (*env)->GetIntField(env, iaObj, ni_iaAddr);
+    jint addr = getInetAddress_addr(env, iaObj);
     jobject netifObj = NULL;
 
     // Retained for now to support IPv4 only stack, java.net.preferIPv4Stack
--- jdk/src/windows/native/java/net/NetworkInterface.h	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/NetworkInterface.h	2013-05-05 09:38:41.000000000 -0700
@@ -71,7 +71,6 @@
 extern jfieldID ni_childsID;        /* NetworkInterface.childs */
 
 extern jclass ni_iacls;             /* InetAddress */
-extern jfieldID ni_iaAddr;          /* InetAddress.address */
 
 extern jclass ni_ia4cls;            /* Inet4Address */
 extern jmethodID ni_ia4Ctor;        /* Inet4Address() */
--- jdk/src/windows/native/java/net/NetworkInterface_winXP.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/NetworkInterface_winXP.c	2013-05-05 09:38:41.000000000 -0700
@@ -33,6 +33,7 @@
 #include "jni_util.h"
 
 #include "NetworkInterface.h"
+#include "net_util.h"
 
 /*
  * Windows implementation of the java.net.NetworkInterface native methods.
@@ -194,7 +195,8 @@
     while (curr != NULL) {
         netaddr *netaddrP;
         ret = enumAddresses_win(env, curr, &netaddrP);
-        if (ret == -1) {
+        if ((*env)->ExceptionOccurred(env)) {
+            free_netaddr(netaddrP);
             return -1;
         }
         curr->addrs = netaddrP;
@@ -448,7 +450,8 @@
      */
     if (netaddrCount < 0) {
         netaddrCount = enumAddresses_win(env, ifs, &netaddrP);
-        if (netaddrCount == -1) {
+        if ((*env)->ExceptionOccurred(env)) {
+            free_netaddr(netaddrP);
             return NULL;
         }
     }
@@ -477,7 +480,7 @@
             }
             /* default ctor will set family to AF_INET */
 
-            (*env)->SetIntField(env, iaObj, ni_iaAddr, ntohl(addrs->addr.him4.sin_addr.s_addr));
+            setInetAddress_addr(env, iaObj, ntohl(addrs->addr.him4.sin_addr.s_addr));
 
             ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);
             if (ibObj == NULL) {
@@ -490,8 +493,7 @@
               free_netaddr(netaddrP);
               return NULL;
             }
-            (*env)->SetIntField(env, ia2Obj, ni_iaAddr,
-                                ntohl(addrs->brdcast.him4.sin_addr.s_addr));
+            setInetAddress_addr(env, ia2Obj, ntohl(addrs->brdcast.him4.sin_addr.s_addr));
             (*env)->SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);
             (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);
             (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);
--- jdk/src/windows/native/java/net/TwoStacksPlainDatagramSocketImpl.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/TwoStacksPlainDatagramSocketImpl.c	2013-05-05 09:38:41.000000000 -0700
@@ -432,7 +432,7 @@
     int lcladdrlen;
     int address;
 
-    family = (*env)->GetIntField(env, addressObj, ia_familyID);
+    family = getInetAddress_family(env, addressObj);
     if (family == IPv6 && !ipv6_supported) {
         JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Protocol family not supported");
@@ -452,7 +452,7 @@
         JNU_ThrowNullPointerException(env, "argument address");
         return;
     } else {
-        address = (*env)->GetIntField(env, addressObj, ia_addressID);
+        address = getInetAddress_addr(env, addressObj);
     }
 
     if (NET_InetAddressToSockaddr(env, addressObj, port, (struct sockaddr *)&lcladdr, &lcladdrlen, JNI_FALSE) != 0) {
@@ -552,9 +552,9 @@
         return;
     }
 
-    addr = (*env)->GetIntField(env, address, ia_addressID);
+    addr = getInetAddress_addr(env, address);
 
-    family = (*env)->GetIntField(env, address, ia_familyID);
+    family = getInetAddress_family(env, address);
     if (family == IPv6 && !ipv6_supported) {
         JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Protocol family not supported");
@@ -670,7 +670,7 @@
         return;
     }
 
-    family = (*env)->GetIntField(env, iaObj, ia_familyID);
+    family = getInetAddress_family(env, iaObj);
     if (family == IPv4) {
         fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);
     } else {
@@ -714,7 +714,7 @@
         if (!w2k_or_later) { /* avoid this check on Win 2K or better. Does not work with IPv6.
                       * Check is not necessary on these OSes */
             if (connected) {
-                address = (*env)->GetIntField(env, iaObj, ia_addressID);
+                address = getInetAddress_addr(env, iaObj);
             } else {
                 address = ntohl(rmtaddr.him4.sin_addr.s_addr);
             }
@@ -823,7 +823,7 @@
     if (IS_NULL(addressObj)) {
         JNU_ThrowNullPointerException(env, "Null address in peek()");
     } else {
-        address = (*env)->GetIntField(env, addressObj, ia_addressID);
+        address = getInetAddress_addr(env, addressObj);
         /* We only handle IPv4 for now. Will support IPv6 once its in the os */
         family = AF_INET;
     }
@@ -905,9 +905,8 @@
         JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException", 0);
         return 0;
     }
-    (*env)->SetIntField(env, addressObj, ia_addressID,
-                        ntohl(remote_addr.sin_addr.s_addr));
-    (*env)->SetIntField(env, addressObj, ia_familyID, IPv4);
+    setInetAddress_addr(env, addressObj, ntohl(remote_addr.sin_addr.s_addr));
+    setInetAddress_family(env, addressObj, IPv4);
 
     /* return port */
     return ntohs(remote_addr.sin_port);
@@ -1574,21 +1573,16 @@
 {
     jobjectArray addrArray;
     static jfieldID ni_addrsID=0;
-    static jfieldID ia_familyID=0;
     jsize len;
     jobject addr;
     int i;
 
-    if (ni_addrsID == NULL || ia_familyID == NULL) {
+    if (ni_addrsID == NULL ) {
         jclass c = (*env)->FindClass(env, "java/net/NetworkInterface");
         CHECK_NULL_RETURN (c, -1);
         ni_addrsID = (*env)->GetFieldID(env, c, "addrs",
                                         "[Ljava/net/InetAddress;");
         CHECK_NULL_RETURN (ni_addrsID, -1);
-        c = (*env)->FindClass(env,"java/net/InetAddress");
-        CHECK_NULL_RETURN (c, -1);
-        ia_familyID = (*env)->GetFieldID(env, c, "family", "I");
-        CHECK_NULL_RETURN (ia_familyID, -1);
     }
 
     addrArray = (*env)->GetObjectField(env, nif, ni_addrsID);
@@ -1606,7 +1600,7 @@
     for (i=0; i<len; i++) {
         int fam;
         addr = (*env)->GetObjectArrayElement(env, addrArray, i);
-        fam = (*env)->GetIntField(env, addr, ia_familyID);
+        fam = getInetAddress_family(env, addr);
         if (fam == family) {
             *iaddr = addr;
             return 0;
@@ -1618,20 +1612,13 @@
 static int getInet4AddrFromIf (JNIEnv *env, jobject nif, struct in_addr *iaddr)
 {
     jobject addr;
-    static jfieldID ia_addressID;
 
     int ret = getInetAddrFromIf (env, IPv4, nif, &addr);
     if (ret == -1) {
         return -1;
     }
 
-    if (ia_addressID == 0) {
-        jclass c = (*env)->FindClass(env,"java/net/InetAddress");
-        CHECK_NULL_RETURN (c, -1);
-        ia_addressID = (*env)->GetFieldID(env, c, "address", "I");
-        CHECK_NULL_RETURN (ia_addressID, -1);
-    }
-    iaddr->s_addr = htonl((*env)->GetIntField(env, addr, ia_addressID));
+    iaddr->s_addr = htonl(getInetAddress_addr(env, addr));
     return 0;
 }
 
@@ -1706,17 +1693,9 @@
             }
             opt = java_net_SocketOptions_IP_MULTICAST_IF2;
         } else {
-            static jfieldID ia_addressID;
             struct in_addr in;
 
-            if (ia_addressID == NULL) {
-                        jclass c = (*env)->FindClass(env,"java/net/InetAddress");
-                CHECK_NULL(c);
-                ia_addressID = (*env)->GetFieldID(env, c, "address", "I");
-                CHECK_NULL(ia_addressID);
-            }
-
-            in.s_addr = htonl((*env)->GetIntField(env, value, ia_addressID));
+            in.s_addr = htonl(getInetAddress_addr(env, value));
 
             if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
                                (const char*)&in, sizeof(in)) < 0) {
@@ -1945,7 +1924,6 @@
     if (isIPV4) {
         static jclass inet4_class;
         static jmethodID inet4_ctrID;
-        static jfieldID inet4_addrID;
 
         static jclass ni_class;
         static jmethodID ni_ctrID;
@@ -1975,15 +1953,13 @@
             CHECK_NULL_RETURN(c, NULL);
             inet4_ctrID = (*env)->GetMethodID(env, c, "<init>", "()V");
             CHECK_NULL_RETURN(inet4_ctrID, NULL);
-            inet4_addrID = (*env)->GetFieldID(env, c, "address", "I");
-            CHECK_NULL_RETURN(inet4_addrID, NULL);
             inet4_class = (*env)->NewGlobalRef(env, c);
             CHECK_NULL_RETURN(inet4_class, NULL);
         }
         addr = (*env)->NewObject(env, inet4_class, inet4_ctrID, 0);
         CHECK_NULL_RETURN(addr, NULL);
 
-        (*env)->SetIntField(env, addr, inet4_addrID, ntohl(in.s_addr));
+        setInetAddress_addr(env, addr, ntohl(in.s_addr));
 
         /*
          * For IP_MULTICAST_IF return InetAddress
--- jdk/src/windows/native/java/net/TwoStacksPlainSocketImpl.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/TwoStacksPlainSocketImpl.c	2013-05-05 09:38:41.000000000 -0700
@@ -412,7 +412,7 @@
     fdObj = (*env)->GetObjectField(env, this, psi_fdID);
     fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);
 
-    family = (*env)->GetIntField(env, iaObj, ia_familyID);
+    family = getInetAddress_family(env, iaObj);
 
     if (family == IPv6 && !ipv6_supported) {
         JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
@@ -724,9 +724,8 @@
             return;
         }
 
-        (*env)->SetIntField(env, socketAddressObj, ia_addressID,
-                            ntohl(him.him4.sin_addr.s_addr));
-        (*env)->SetIntField(env, socketAddressObj, ia_familyID, IPv4);
+        setInetAddress_addr(env, socketAddressObj, ntohl(him.him4.sin_addr.s_addr));
+        setInetAddress_family(env, socketAddressObj, IPv4);
         (*env)->SetObjectField(env, socket, psi_addressID, socketAddressObj);
     } else {
         jbyteArray addr;
@@ -754,7 +753,7 @@
         }
         addr = (*env)->GetObjectField (env, socketAddressObj, ia6_ipaddressID);
         (*env)->SetByteArrayRegion (env, addr, 0, 16, (const char *)&him.him6.sin6_addr);
-        (*env)->SetIntField(env, socketAddressObj, ia_familyID, IPv6);
+        setInetAddress_family(env, socketAddressObj, IPv6);
         (*env)->SetIntField(env, socketAddressObj, ia6_scopeidID, him.him6.sin6_scope_id);
     }
     /* fields common to AF_INET and AF_INET6 */
--- jdk/src/windows/native/java/net/net_util_md.c	2012-08-10 10:31:48.000000000 -0700
+++ jdk/src/windows/native/java/net/net_util_md.c	2013-05-05 09:38:41.000000000 -0700
@@ -804,7 +804,7 @@
 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port, struct sockaddr *him,
                           int *len, jboolean v4MappedAddress) {
     jint family, iafam;
-    iafam = (*env)->GetIntField(env, iaObj, ia_familyID);
+    iafam = getInetAddress_family(env, iaObj);
     family = (iafam == IPv4)? AF_INET : AF_INET6;
     if (ipv6_available() && !(family == AF_INET && v4MappedAddress == JNI_FALSE)) {
         struct SOCKADDR_IN6 *him6 = (struct SOCKADDR_IN6 *)him;
@@ -815,7 +815,7 @@
 
         if (family == AF_INET) { /* will convert to IPv4-mapped address */
             memset((char *) caddr, 0, 16);
-            address = (*env)->GetIntField(env, iaObj, ia_addressID);
+            address = getInetAddress_addr(env, iaObj);
             if (address == INADDR_ANY) {
                 /* we would always prefer IPv6 wildcard address
                 caddr[10] = 0xff;
@@ -854,7 +854,7 @@
           return -1;
         }
         memset((char *) him4, 0, sizeof(struct sockaddr_in));
-        address = (int)(*env)->GetIntField(env, iaObj, ia_addressID);
+        address = getInetAddress_addr(env, iaObj);
         him4->sin_port = htons((short) port);
         him4->sin_addr.s_addr = (u_long) htonl(address);
         him4->sin_family = AF_INET;
--- jdk/src/windows/native/sun/net/www/protocol/http/ntlm/NTLMAuthSequence.c	2012-08-10 10:31:52.000000000 -0700
+++ jdk/src/windows/native/sun/net/www/protocol/http/ntlm/NTLMAuthSequence.c	2013-05-05 09:38:41.000000000 -0700
@@ -41,18 +41,20 @@
 #define SECURITY_WIN32
 #include "sspi.h"
 
-static void endSequence (PCredHandle credHand, PCtxtHandle ctxHandle);
+static void endSequence (PCredHandle credHand, PCtxtHandle ctxHandle, JNIEnv *env, jobject status);
 
 static jfieldID ntlm_ctxHandleID;
 static jfieldID ntlm_crdHandleID;
+static jfieldID status_seqCompleteID;
 
 static HINSTANCE lib = NULL;
 
 JNIEXPORT void JNICALL Java_sun_net_www_protocol_http_ntlm_NTLMAuthSequence_initFirst
-(JNIEnv *env, jclass clazz)
+(JNIEnv *env, jclass authseq_clazz, jclass status_clazz)
 {
-    ntlm_ctxHandleID = (*env)->GetFieldID(env, clazz, "ctxHandle", "J");
-    ntlm_crdHandleID = (*env)->GetFieldID(env, clazz, "crdHandle", "J");
+    ntlm_ctxHandleID = (*env)->GetFieldID(env, authseq_clazz, "ctxHandle", "J");
+    ntlm_crdHandleID = (*env)->GetFieldID(env, authseq_clazz, "crdHandle", "J");
+    status_seqCompleteID = (*env)->GetFieldID(env, status_clazz, "sequenceComplete", "Z");
 }
 
 /*
@@ -145,8 +147,14 @@
     }
 }
 
+
+/*
+ * Class:     sun_net_www_protocol_http_ntlm_NTLMAuthSequence
+ * Method:    getNextToken
+ * Signature: (J[BLsun/net/www/protocol/http/ntlm/NTLMAuthSequence/Status;)[B
+ */
 JNIEXPORT jbyteArray JNICALL Java_sun_net_www_protocol_http_ntlm_NTLMAuthSequence_getNextToken
-(JNIEnv *env, jobject this, jlong crdHandle, jbyteArray lastToken)
+(JNIEnv *env, jobject this, jlong crdHandle, jbyteArray lastToken, jobject status)
 {
 
     VOID        *pInput = 0;
@@ -217,7 +225,7 @@
     }
 
     if (ss < 0) {
-        endSequence (pCred, pCtx);
+        endSequence (pCred, pCtx, env, status);
         return 0;
     }
 
@@ -225,7 +233,7 @@
         ss = CompleteAuthToken( pCtx, &OutBuffDesc );
 
         if (ss < 0) {
-            endSequence (pCred, pCtx);
+            endSequence (pCred, pCtx, env, status);
             return 0;
         }
     }
@@ -235,18 +243,18 @@
         (*env)->SetByteArrayRegion(env, ret, 0, OutSecBuff.cbBuffer,
                 OutSecBuff.pvBuffer);
         if (lastToken != 0) // 2nd stage
-            endSequence (pCred, pCtx);
+            endSequence (pCred, pCtx, env, status);
         result = ret;
     }
 
     if ((ss != SEC_I_CONTINUE_NEEDED) && (ss == SEC_I_COMPLETE_AND_CONTINUE)) {
-        endSequence (pCred, pCtx);
+        endSequence (pCred, pCtx, env, status);
     }
 
     return result;
 }
 
-static void endSequence (PCredHandle credHand, PCtxtHandle ctxHandle) {
+static void endSequence (PCredHandle credHand, PCtxtHandle ctxHandle, JNIEnv *env, jobject status) {
     if (credHand != 0) {
         FreeCredentialsHandle(credHand);
         free(credHand);
@@ -256,4 +264,7 @@
         DeleteSecurityContext(ctxHandle);
         free(ctxHandle);
     }
+
+    /* Sequence is complete so set flag */
+    (*env)->SetBooleanField(env, status, status_seqCompleteID, JNI_TRUE);
 }
--- jdk/src/windows/native/sun/nio/ch/DatagramChannelImpl.c	2012-08-10 10:31:52.000000000 -0700
+++ jdk/src/windows/native/sun/nio/ch/DatagramChannelImpl.c	2013-05-05 09:38:41.000000000 -0700
@@ -34,8 +34,6 @@
 #include "net_util.h"
 #include <winsock2.h>
 
-static jfieldID isa_addrID;     /* address in java.net.InetSocketAddress */
-static jfieldID isa_portID;     /* port in java.net.InetSocketAddress */
 static jfieldID dci_senderID;   /* sender in sun.nio.ch.DatagramChannelImpl */
 static jfieldID dci_senderAddrID; /* sender InetAddress in sun.nio.ch.DatagramChannelImpl */
 static jfieldID dci_senderPortID; /* sender port in sun.nio.ch.DatagramChannelImpl */
@@ -50,9 +48,6 @@
     isa_class = (*env)->NewGlobalRef(env, clazz);
     isa_ctorID = (*env)->GetMethodID(env, clazz, "<init>",
                                      "(Ljava/net/InetAddress;I)V");
-    isa_addrID = (*env)->GetFieldID(env, clazz, "addr",
-                                    "Ljava/net/InetAddress;");
-    isa_portID = (*env)->GetFieldID(env, clazz, "port", "I");
 
     clazz = (*env)->FindClass(env, "sun/nio/ch/DatagramChannelImpl");
     dci_senderID = (*env)->GetFieldID(env, clazz, "sender",
@@ -108,7 +103,7 @@
 
 JNIEXPORT void JNICALL
 Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jobject this,
-                                                jobject fdo, jboolean isIPv6)
+                                                jobject fdo)
 {
     jint fd = fdval(env, fdo);
     int rv = 0;
@@ -214,15 +209,14 @@
 JNIEXPORT jint JNICALL
 Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jobject this,
                                           jboolean preferIPv6, jobject fdo,
-                                          jlong address, jint len, jobject dest)
+                                          jlong address, jint len,
+                                          jobject destAddress, jint destPort)
 {
     jint fd = fdval(env, fdo);
     void *buf = (void *)jlong_to_ptr(address);
     SOCKETADDRESS sa;
     int sa_len;
     jint rv = 0;
-    jobject destAddress = (*env)->GetObjectField(env, dest, isa_addrID);
-    jint destPort = (*env)->GetIntField(env, dest, isa_portID);
 
     if (NET_InetAddressToSockaddr(env, destAddress, destPort,
                                   (struct sockaddr *)&sa,
--- jdk/src/windows/native/sun/windows/awt_Component.cpp	2012-08-10 10:31:55.000000000 -0700
+++ jdk/src/windows/native/sun/windows/awt_Component.cpp	2013-05-05 09:38:41.000000000 -0700
@@ -558,8 +558,6 @@
 
     m_hwnd = hwnd;
 
-    ::ImmAssociateContext(m_hwnd, NULL);
-
     SetDrawState((jint)JAWT_LOCK_SURFACE_CHANGED |
         (jint)JAWT_LOCK_BOUNDS_CHANGED |
         (jint)JAWT_LOCK_CLIP_CHANGED);
--- jdk/src/windows/native/sun/windows/awt_TextComponent.cpp	2012-08-10 10:31:58.000000000 -0700
+++ jdk/src/windows/native/sun/windows/awt_TextComponent.cpp	2013-05-05 09:38:41.000000000 -0700
@@ -53,14 +53,12 @@
  * AwtTextComponent fields
  */
 
-/* java.awt.TextComponent fields */
-jfieldID AwtTextComponent::canAccessClipboardID;
-
-
 /************************************************************************
  * AwtTextComponent methods
  */
 
+jmethodID AwtTextComponent::canAccessClipboardMID;
+
 AwtTextComponent::AwtTextComponent() {
     m_synthetic = FALSE;
     m_lStartPos = -1;
@@ -367,8 +365,7 @@
         }
         jobject target = GetTarget(env);
         jboolean canAccessClipboard =
-            env->GetBooleanField(target,
-                                 AwtTextComponent::canAccessClipboardID);
+            env->CallBooleanMethod (target, AwtTextComponent::canAccessClipboardMID);
         env->DeleteLocalRef(target);
         return (canAccessClipboard) ? mrDoDefault : mrConsume;
     }
@@ -854,12 +851,13 @@
 {
     TRY;
 
-    cls = env->FindClass("java/awt/TextComponent");
-    if (cls != NULL) {
-        AwtTextComponent::canAccessClipboardID =
-            env->GetFieldID(cls, "canAccessClipboard", "Z");
-        DASSERT(AwtTextComponent::canAccessClipboardID != NULL);
-    }
+    jclass textComponentClassID = env->FindClass("java/awt/TextComponent");
+    AwtTextComponent::canAccessClipboardMID =
+        env->GetMethodID(textComponentClassID,
+        "canAccessClipboard", "()Z");
+    env->DeleteLocalRef(textComponentClassID);
+
+    DASSERT(AwtTextComponent::canAccessClipboardMID != NULL)
 
     CATCH_BAD_ALLOC;
 }
--- jdk/src/windows/native/sun/windows/awt_TextComponent.h	2012-08-10 10:31:58.000000000 -0700
+++ jdk/src/windows/native/sun/windows/awt_TextComponent.h	2013-05-05 09:38:41.000000000 -0700
@@ -42,8 +42,7 @@
 
 class AwtTextComponent : public AwtComponent {
 public:
-    /* java.awt.TextComponent canAccessClipboard field ID */
-    static jfieldID canAccessClipboardID;
+    static jmethodID canAccessClipboardMID;
 
     AwtTextComponent();
 
--- jdk/src/windows/native/sun/windows/awt_Window.cpp	2012-08-10 10:31:58.000000000 -0700
+++ jdk/src/windows/native/sun/windows/awt_Window.cpp	2013-05-05 09:38:41.000000000 -0700
@@ -1477,7 +1477,7 @@
     if (wClassEvent == NULL) {
         if (env->PushLocalFrame(1) < 0)
             return;
-        wClassEvent = env->FindClass("java/awt/event/WindowEvent");
+        wClassEvent = env->FindClass("sun/awt/TimedWindowEvent");
         if (wClassEvent != NULL) {
             wClassEvent = (jclass)env->NewGlobalRef(wClassEvent);
         }
@@ -1491,7 +1491,7 @@
     if (wEventInitMID == NULL) {
         wEventInitMID =
             env->GetMethodID(wClassEvent, "<init>",
-                             "(Ljava/awt/Window;ILjava/awt/Window;II)V");
+                             "(Ljava/awt/Window;ILjava/awt/Window;IIJ)V");
         DASSERT(wEventInitMID);
         if (wEventInitMID == NULL) {
             return;
@@ -1532,7 +1532,7 @@
         }
     }
     jobject event = env->NewObject(wClassEvent, wEventInitMID, target, id,
-                                   jOpposite, oldState, newState);
+                                   jOpposite, oldState, newState, TimeHelper::getMessageTimeUTC());
     DASSERT(!safe_ExceptionOccurred(env));
     DASSERT(event != NULL);
     if (jOpposite != NULL) {
@@ -1559,21 +1559,8 @@
 
 BOOL AwtWindow::AwtSetActiveWindow(BOOL isMouseEventCause, UINT hittest)
 {
-    // Fix for 6458497.
-    // Retreat if current foreground window is out of both our and embedder process.
-    // The exception is when activation is requested due to a mouse event.
-    if (!isMouseEventCause) {
-        HWND fgWindow = ::GetForegroundWindow();
-        if (NULL != fgWindow) {
-            DWORD fgProcessID;
-            ::GetWindowThreadProcessId(fgWindow, &fgProcessID);
-            if (fgProcessID != ::GetCurrentProcessId()
-                && !AwtToolkit::GetInstance().IsEmbedderProcessId(fgProcessID))
-            {
-                return FALSE;
-            }
-        }
-    }
+    // We used to reject non mouse window activation if our app wasn't active.
+    // This code since has been removed as the fix for 7185280
 
     HWND proxyContainerHWnd = GetProxyToplevelContainer();
     HWND proxyHWnd = GetProxyFocusOwner();
--- jdk/test/Makefile	2012-08-10 10:31:59.000000000 -0700
+++ jdk/test/Makefile	2013-05-05 09:38:49.000000000 -0700
@@ -79,6 +79,11 @@
   endif
   OS_VERSION := $(shell $(UNAME) -r)
 endif
+ifeq ($(findstring BSD,$(UNAME_S)), BSD)
+  OS_NAME     = bsd
+  OS_ARCH    := $(shell $(UNAME) -m)
+  OS_VERSION := $(shell $(UNAME) -r)
+endif
 ifeq ($(UNAME_S), Darwin)
   OS_NAME     = macosx
   OS_ARCH    := $(shell $(UNAME) -m)
@@ -512,7 +517,8 @@
 JDK_ALL_TARGETS += jdk_misc
 jdk_misc: $(call TestDirs, \
           demo/jvmti demo/zipfs javax/naming javax/script \
-          javax/smartcardio com/sun/jndi com/sun/xml sun/misc)
+          javax/smartcardio javax/xml com/sun/jndi com/sun/org/glassfish \
+          com/sun/xml sun/misc)
 	$(call RunAgentvmBatch)
 
 # Stable samevm testruns (minus items from PROBLEM_LIST)
@@ -560,7 +566,7 @@
 #   Using samevm has serious problems with these tests
 JDK_ALL_TARGETS += jdk_security2
 jdk_security2: $(call TestDirs, javax/crypto com/sun/crypto)
-	$(call RunOthervmBatch)
+	$(call RunAgentvmBatch)
 
 # Stable othervm testruns (minus items from PROBLEM_LIST)
 #   Using samevm has serious problems with these tests
@@ -570,7 +576,7 @@
                com/sun/org/apache/xml/internal/security \
                com/oracle/security/ucrypto)
 	$(call SharedLibraryPermissions,sun/security)
-	$(call RunOthervmBatch)
+	$(call RunAgentvmBatch)
 
 # All security tests
 jdk_security: jdk_security1 jdk_security2 jdk_security3
@@ -834,17 +840,17 @@
 # The jtjck.jar utility to use to run the tests
 JTJCK_JAR = $(JCK_HOME)/lib/jtjck.jar
 JTJCK_JAVA_ARGS =  -XX:MaxPermSize=256m -Xmx512m
-JTJCK_OPTIONS = -headless -v 
+JTJCK_OPTIONS = -headless -v
 
 # Default tests to run
 ifndef JCK_COMPILER_TESTS
-  JCK_COMPILER_TESTS = 
+  JCK_COMPILER_TESTS =
 endif
 ifndef JCK_RUNTIME_TESTS
-  JCK_RUNTIME_TESTS  = 
+  JCK_RUNTIME_TESTS  =
 endif
 ifndef JCK_DEVTOOLS_TESTS
-  JCK_DEVTOOLS_TESTS = 
+  JCK_DEVTOOLS_TESTS =
 endif
 
 # Generic rule used to run jck tests
@@ -870,14 +876,14 @@
                 _generic_jck_tests
 
 # JCK7 runtime tests
-jck7runtime: 
+jck7runtime:
 	$(MAKE) UNIQUE_DIR=$@ \
 	        JCK_HOME=$(JCK7RUNTIME_HOME) \
 	        TESTDIRS="$(JCK_RUNTIME_TESTS)" \
                 _generic_jck_tests
 
 # JCK7 devtools tests
-jck7devtools: 
+jck7devtools:
 	$(MAKE) UNIQUE_DIR=$@ \
 	        JCK_HOME=$(JCK7DEVTOOLS_HOME) \
                 TESTDIRS="$(JCK_DEVTOOLS_TESTS)" \
--- jdk/test/ProblemList.txt	2012-08-10 10:31:59.000000000 -0700
+++ jdk/test/ProblemList.txt	2013-05-05 09:38:49.000000000 -0700
@@ -1,6 +1,6 @@
-###########################################################################
+##########################################################################
 #
-# Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -114,83 +114,10 @@
 
 # jdk_awt
 
-# None of the awt tests are using samevm, might not be worth the effort due
-#  to the vm overhead not being enough to make a difference.
-# In general, the awt tests are problematic with or without samevm, and there
-#  are issues with using a Xvfb display.
-
-# Fails on solaris sparc, timedout? in othervm mode
-java/awt/event/MouseEvent/AcceptExtraButton/AcceptExtraButton.java generic-all
-
-# Causes hang in samevm mode??? Solaris 11 i586
-java/awt/FullScreen/SetFSWindow/FSFrame.java                    generic-all
-
-# Fails on solaris 11 i586, -client, in othervm mode not sure why
-java/awt/Component/PrintAllXcheckJNI/PrintAllXcheckJNI.java     generic-all
-java/awt/Focus/CloseDialogActivateOwnerTest/CloseDialogActivateOwnerTest.java generic-all
-java/awt/FontClass/FontAccess.java                              generic-all
-java/awt/Mixing/HWDisappear.java                                generic-all
-java/awt/Mixing/MixingInHwPanel.java                            generic-all
-java/awt/Mouse/MaximizedFrameTest/MaximizedFrameTest.html       generic-all
-java/awt/Robot/AcceptExtraMouseButtons/AcceptExtraMouseButtons.java generic-all
-java/awt/Toolkit/SecurityTest/SecurityTest2.java                generic-all
-java/awt/image/mlib/MlibOpsTest.java                            generic-all
-
-# Fails on windows, othervm mode, various errors
-java/awt/Focus/NonFocusableWindowTest/NonfocusableOwnerTest.java        generic-all
-java/awt/Focus/OwnedWindowFocusIMECrashTest/OwnedWindowFocusIMECrashTest.java   generic-all
-java/awt/FullScreen/NoResizeEventOnDMChangeTest/NoResizeEventOnDMChangeTest.java        generic-all
-java/awt/Mouse/MouseModifiersUnitTest/MouseModifiersUnitTest_Standard.java      generic-all
-java/awt/event/KeyEvent/KeyTyped/CtrlASCII.html                 generic-all
-java/awt/font/Threads/FontThread.java                           generic-all
-java/awt/print/PrinterJob/PrtException.java                     generic-all
-
-# Fails with windows X64, othervm, -server
-com/sun/awt/Translucency/WindowOpacity.java                     generic-all
-java/awt/EventDispatchThread/HandleExceptionOnEDT/HandleExceptionOnEDT.java             generic-all
-java/awt/EventDispatchThread/LoopRobustness/LoopRobustness.html generic-all
-java/awt/Focus/AppletInitialFocusTest/AppletInitialFocusTest1.html generic-all
-java/awt/Focus/FocusEmbeddedFrameTest/FocusEmbeddedFrameTest.java generic-all
-java/awt/Frame/LayoutOnMaximizeTest/LayoutOnMaximizeTest.java   generic-all
-java/awt/FullScreen/TranslucentWindow/TranslucentWindow.java    generic-all
-java/awt/Mixing/MixingOnShrinkingHWButton.java                  generic-all
-java/awt/Mouse/MouseModifiersUnitTest/ExtraButtonDrag.java      generic-all
-
 ############################################################################
 
 # jdk_beans
 
-# A large set of the beans tests set the security manager, which would seem
-#  to indicate that a large number of them should be "othervm", yet are all
-#  very small tests and could greatly benefit from a samevm test run.
-#  So a large batch of beans tests are currently run with othervm mode.
-
-# Filed 6986807
-java/beans/Introspector/TestTypeResolver.java                   generic-all
-
-# Filed 6986813
-java/beans/Introspector/memory/Test4508780.java                 generic-all
-
-# Linux, some kind of problems with X11 display
-java/beans/PropertyChangeSupport/Test4682386.java               generic-all
-java/beans/PropertyChangeSupport/TestSynchronization.java       generic-all
-java/beans/Statement/Test4653179.java                           generic-all
-
-# Runs REALLY slow on Solaris sparc for some reason, both -client and -server
-java/beans/XMLEncoder/Test4625418.java                          solaris-sparc
-
-# Problems with samevm and setting security manager (speculation partially)
-java/beans/Introspector/4168475/Test4168475.java                generic-all
-java/beans/Introspector/4520754/Test4520754.java                generic-all
-java/beans/Introspector/6380849/TestBeanInfo.java               generic-all
-java/beans/Introspector/Test4144543.java                        generic-all
-
-# Failed to call method solaris-sparc???
-java/beans/EventHandler/Test6788531.java                        generic-all
-
-# Jar or class not found???
-java/beans/XMLEncoder/6329581/Test6329581.java                  generic-all
-
 ############################################################################
 
 # jdk_lang
@@ -290,7 +217,7 @@
 # Windows X64, java.lang.IllegalStateException
 javax/management/monitor/AttributeArbitraryDataTypeTest.java    generic-all
 
-# 7149181 
+# 7149181
 sun/management/jmxremote/startstop/JMXStartStopTest.sh          generic-all
 
 ############################################################################
@@ -304,95 +231,29 @@
 # 6988950
 demo/jvmti/compiledMethodLoad/CompiledMethodLoadTest.java       generic-all
 
-# 7162111
-demo/jvmti/mtrace/TraceJFrame.java				macosx-all
-
-# Need to be marked othervm, or changed to be samevm safe
+# 7056489
 com/sun/jndi/ldap/ReadTimeoutTest.java                          generic-all
-com/sun/jndi/rmi/registry/RegistryContext/UnbindIdempotent.java generic-all
-
-# Need to be marked othervm, or changed to be samevm safe
-com/sun/org/apache/xml/internal/security/transforms/ClassLoaderTest.java generic-all
-
-# Solaris sparc and others, exception in initializer
-javax/imageio/CachePremissionsTest/CachePermissionsTest.java    generic-all
-
-# Leaves file rgba_* open, fails with windows samevm
-javax/imageio/plugins/png/PngOutputTypeTest.java                generic-all
-
-# Suspect test.png file is left open, windows samevm problems
-javax/imageio/plugins/png/ITXtTest.java                         generic-all
-
-# Solaris sparc and others, failed to compile testcase
-javax/imageio/metadata/DOML3Node.java                           generic-all
-
-# One of these tests is leaving file IMGP1001.JPG open, windows samevm
-javax/imageio/plugins/jpeg/ConcurrentReadingTest.java           generic-all
-javax/imageio/plugins/jpeg/ReadingInterruptionTest.java         generic-all
-
-# One of these files is missing a close on writer_* files, windows samevm
-javax/imageio/plugins/jpeg/ConcurrentWritingTest.java           generic-all
-javax/imageio/plugins/jpeg/WritingInterruptionTest.java         generic-all
-
-# Leaving file test.jpg open, windows samevm
-javax/imageio/plugins/jpeg/ReadAsGrayTest.java                  generic-all
-
-# Missing close on file wbmp*, windows samevm
-javax/imageio/plugins/wbmp/CanDecodeTest.java                   generic-all
-
-# Failures on OpenSolaris, cannot read input files? samevm issues?
-javax/imageio/metadata/BooleanAttributes.java                   generic-all
-javax/imageio/plugins/bmp/BMPSubsamplingTest.java               generic-all
-javax/imageio/plugins/bmp/TopDownTest.java                      generic-all
-javax/imageio/plugins/gif/EncodeSubImageTest.java               generic-all
-javax/imageio/plugins/gif/GifTransparencyTest.java              generic-all
-javax/imageio/plugins/png/GrayPngTest.java                      generic-all
-javax/imageio/plugins/png/ItxtUtf8Test.java                     generic-all
-javax/imageio/plugins/png/MergeStdCommentTest.java              generic-all
-javax/imageio/plugins/png/ShortHistogramTest.java               generic-all
-javax/imageio/plugins/shared/BitDepth.java                      generic-all
-
-# Exclude all javax/print tests, even if they passed, they may need samevm work
-
-# Times out on solaris-sparc, sparcv9, x64 -server, some on i586 -client
-javax/print/attribute/autosense/PrintAutoSenseData.java         generic-all
-javax/print/attribute/Chroma.java                               generic-all
-javax/print/attribute/CollateAttr.java                          generic-all
-javax/print/attribute/PSCopiesFlavorTest.java                   generic-all
-javax/print/LookupServices.java                                 generic-all
-javax/print/TestRaceCond.java                                   generic-all
-
-# These tests really require a printer (might all be windows only tests?)
-javax/print/CheckDupFlavor.java                                 generic-all
-javax/print/PrintSE/PrintSE.sh                                  generic-all
-javax/print/attribute/ChromaticityValues.java                   generic-all
-javax/print/attribute/GetCopiesSupported.java                   generic-all
-javax/print/attribute/SidesPageRangesTest.java                  generic-all
-javax/print/attribute/SupportedPrintableAreas.java              generic-all
-javax/print/attribute/AttributeTest.java                        generic-all
-
-# Only print test left, excluding just because all print tests have been
-javax/print/attribute/MediaMappingsTest.java                    generic-all
 
 # 7162111
-javax/script/CauseExceptionTest.java				macosx-all
-javax/script/GetInterfaceTest.java				macosx-all
-javax/script/JavaScriptScopeTest.java				macosx-all
-javax/script/NullUndefinedVarTest.java				macosx-all
-javax/script/PluggableContextTest.java				macosx-all
-javax/script/ProviderTest.sh					macosx-all
-javax/script/RhinoExceptionTest.java				macosx-all
-javax/script/StringWriterPrintTest.java				macosx-all
-javax/script/Test1.java						macosx-all
-javax/script/Test2.java						macosx-all
-javax/script/Test3.java						macosx-all
-javax/script/Test4.java						macosx-all
-javax/script/Test5.java						macosx-all
-javax/script/Test6.java						macosx-all
-javax/script/Test7.java						macosx-all
-javax/script/Test8.java						macosx-all
-javax/script/UnescapedBracketRegExTest.java			macosx-all
-javax/script/VersionTest.java					macosx-all
+demo/jvmti/mtrace/TraceJFrame.java                              macosx-all
+javax/script/CauseExceptionTest.java                            macosx-all
+javax/script/GetInterfaceTest.java                              macosx-all
+javax/script/JavaScriptScopeTest.java                           macosx-all
+javax/script/NullUndefinedVarTest.java                          macosx-all
+javax/script/PluggableContextTest.java                          macosx-all
+javax/script/ProviderTest.sh                                    macosx-all
+javax/script/RhinoExceptionTest.java                            macosx-all
+javax/script/StringWriterPrintTest.java                         macosx-all
+javax/script/Test1.java                                         macosx-all
+javax/script/Test2.java                                         macosx-all
+javax/script/Test3.java                                         macosx-all
+javax/script/Test4.java                                         macosx-all
+javax/script/Test5.java                                         macosx-all
+javax/script/Test6.java                                         macosx-all
+javax/script/Test7.java                                         macosx-all
+javax/script/Test8.java                                         macosx-all
+javax/script/UnescapedBracketRegExTest.java                     macosx-all
+javax/script/VersionTest.java                                   macosx-all
 
 ############################################################################
 
@@ -436,6 +297,11 @@
 # 6962637
 java/io/File/MaxPathLength.java                                 windows-all
 
+# 7162111 - these tests need to be updated to run headless
+java/io/Serializable/resolveClass/deserializeButton/run.sh      macosx-all
+java/io/Serializable/serialver/classpath/run.sh                 macosx-all
+java/io/Serializable/serialver/nested/run.sh                    macosx-all
+
 ############################################################################
 
 # jdk_nio
@@ -458,153 +324,36 @@
 
 # jdk_rmi
 
-# Port already in use, fails on sparc, othervm
-java/rmi/reliability/benchmark/runRmiBench.sh                   generic-all
-
-# Already in use port issues? othervm solaris
-java/rmi/activation/rmidViaInheritedChannel/InheritedChannelNotServerSocket.java generic-all
-java/rmi/activation/rmidViaInheritedChannel/RmidViaInheritedChannel.java generic-all
-
-java/rmi/transport/rapidExportUnexport/RapidExportUnexport.java         generic-all
-java/rmi/transport/dgcDeadLock/TestImpl_Stub.java                       generic-all
-
-# Address already in use, othervm mode, solaris
-java/rmi/activation/Activatable/elucidateNoSuchMethod/ElucidateNoSuchMethod.java        generic-all
-java/rmi/activation/Activatable/forceLogSnapshot/ForceLogSnapshot.java  generic-all
-
-# Registry already running on port, solaris
-java/rmi/Naming/legalRegistryNames/LegalRegistryNames.java      generic-all
-
-# Fails on Linux 32 and 64bit -server?, impl not garbage collected???
-java/rmi/transport/pinLastArguments/PinLastArguments.java       generic-all
-
 # 7146541
 java/rmi/transport/rapidExportUnexport/RapidExportUnexport.java	linux-all
 
-# Times out on solaris sparc
-java/rmi/server/RemoteServer/AddrInUse.java                     generic-all
+# 7190106
+java/rmi/reliability/benchmark/runRmiBench.sh                   generic-all
 
-# Connection error on Windows i586 -server
-#  Also connection errors in othervm on Solaris 10 sparc, same port???
-sun/rmi/transport/tcp/DeadCachedConnection.java                 generic-all
-
-# Connection errors in othervm on Solaris 10 sparc, same port???
-java/rmi/activation/Activatable/checkActivateRef/CheckActivateRef.java generic-all
-java/rmi/activation/Activatable/checkAnnotations/CheckAnnotations.java generic-all
-java/rmi/activation/Activatable/checkImplClassLoader/CheckImplClassLoader.java generic-all
-java/rmi/activation/Activatable/checkRegisterInLog/CheckRegisterInLog.java generic-all
-java/rmi/activation/Activatable/createPrivateActivable/CreatePrivateActivatable.java generic-all
-java/rmi/activation/Activatable/downloadParameterClass/DownloadParameterClass.java generic-all
-java/rmi/activation/Activatable/extLoadedImpl/ext.sh generic-all
-java/rmi/activation/Activatable/inactiveGroup/InactiveGroup.java generic-all
-java/rmi/activation/Activatable/lookupActivationSystem/LookupActivationSystem.java generic-all
-java/rmi/activation/Activatable/nestedActivate/NestedActivate.java generic-all
-java/rmi/activation/Activatable/restartCrashedService/RestartCrashedService.java generic-all
-java/rmi/activation/Activatable/restartLatecomer/RestartLatecomer.java generic-all
-java/rmi/activation/Activatable/shutdownGracefully/ShutdownGracefully.java generic-all
-java/rmi/activation/Activatable/unregisterInactive/UnregisterInactive.java generic-all
-java/rmi/activation/ActivateFailedException/activateFails/ActivateFails.java generic-all
-java/rmi/activation/ActivationGroup/downloadActivationGroup/DownloadActivationGroup.java generic-all
-java/rmi/activation/ActivationSystem/activeGroup/IdempotentActiveGroup.java generic-all
-java/rmi/reliability/juicer/AppleUserImpl.java generic-all
-java/rmi/server/RMISocketFactory/useSocketFactory/unicast/UseCustomSocketFactory.java generic-all
-java/rmi/server/UnicastRemoteObject/keepAliveDuringCall/KeepAliveDuringCall.java generic-all
-java/rmi/transport/handshakeTimeout/HandshakeTimeout.java generic-all
-java/rmi/activation/Activatable/restartService/RestartService.java generic-all
-java/rmi/activation/ActivationSystem/modifyDescriptor/ModifyDescriptor.java generic-all
-java/rmi/activation/ActivationSystem/stubClassesPermitted/StubClassesPermitted.java generic-all
-java/rmi/activation/ActivationSystem/unregisterGroup/UnregisterGroup.java generic-all
-java/rmi/activation/CommandEnvironment/SetChildEnv.java generic-all
-java/rmi/registry/classPathCodebase/ClassPathCodebase.java generic-all
-java/rmi/registry/reexport/Reexport.java generic-all
-java/rmi/server/Unreferenced/finiteGCLatency/FiniteGCLatency.java generic-all
-java/rmi/server/Unreferenced/leaseCheckInterval/LeaseCheckInterval.java generic-all
-java/rmi/server/Unreferenced/unreferencedContext/UnreferencedContext.java generic-all
-java/rmi/server/useCustomRef/UseCustomRef.java generic-all
-java/rmi/transport/checkFQDN/CheckFQDN.java generic-all
-java/rmi/transport/checkLeaseInfoLeak/CheckLeaseLeak.java generic-all
-java/rmi/server/RMISocketFactory/useSocketFactory/activatable/UseCustomSocketFactory.java generic-all
-java/rmi/server/RMISocketFactory/useSocketFactory/registry/UseCustomSocketFactory.java generic-all
-java/rmi/server/UnicastRemoteObject/unexportObject/UnexportLeak.java generic-all
+# 7191877
+java/rmi/transport/checkLeaseInfoLeak/CheckLeaseLeak.java       generic-all
 
-# 7142596
-java/rmi/transport/httpSocket/HttpSocketTest.java		macosx-all
+# 7195095
+sun/rmi/transport/proxy/EagerHttpFallback.java                  generic-all
 
 ############################################################################
 
 # jdk_security
 
-# Filed 6986868
-sun/security/tools/jarsigner/crl.sh                             generic-all
-
-# Filed 6951285, not sure how often this fails, last was Linux 64bit Fedora 9
-sun/security/krb5/auto/MaxRetries.java                          generic-all
-
-# Filed 6950930, fails on windows 32bit c1 and windows 64bit
-sun/security/krb5/auto/IgnoreChannelBinding.java                windows-all
-
-# Filed 6950931, failing on all windows systems
-sun/security/tools/jarsigner/crl.sh                             windows-all
-
-# Filed 6950929, only seemed to fail on solaris sparcv9 (-d64)
-#   Failed on Linux -server 32bit too, making generic
-sun/security/krb5/auto/BadKdc4.java                             generic-all
-
 # Failing on Solaris i586, 3/9/2010, not a -samevm issue (jdk_security3)
 sun/security/pkcs11/Secmod/AddPrivateKey.java                   solaris-i586
 sun/security/pkcs11/ec/ReadCertificates.java                    solaris-i586
 sun/security/pkcs11/ec/ReadPKCS12.java                          solaris-i586
 sun/security/pkcs11/ec/TestCurves.java                          solaris-i586
 sun/security/pkcs11/ec/TestECDSA.java                           solaris-i586
-sun/security/pkcs11/ec/TestECGenSpec.java                       solaris-i586
-sun/security/pkcs11/ec/TestKeyFactory.java                      solaris-i586
-
-# Unknown problem, could be a jtreg -samevm issue?
-#  Error while cleaning up threads after test
-java/security/Security/SynchronizedAccess.java                  generic-all
-
-# Failing on Solaris X64 (-d64 -server) with:
-#  GSSException: Failure unspecified at GSS-API level
-#    (Mechanism level: Specified version of key is not available (44))
-sun/security/krb5/auto/BasicKrb5Test.java                       generic-all
-
-# Solaris X86 failures, readjar.jks: No such file or directory
-sun/security/tools/keytool/readjar.sh                           generic-all
-
-# Fails with -ea -esa, but only on Solaris sparc? Suspect it is timing out
-sun/security/tools/keytool/standard.sh                          generic-all
-
-# Fails on Solaris 10 X64, address already in use
-sun/security/krb5/auto/HttpNegotiateServer.java                 generic-all
-
-# Fails on almost all platforms
-#   java.lang.UnsupportedClassVersionError: SerialTest :
-#      Unsupported major.minor version 51.0
-#    at java.lang.ClassLoader.defineClass1(Native Method)
-sun/security/util/Oid/S11N.sh                                   generic-all
-
-# Fails on Fedora 9 32bit
-#  GSSException: Failure unspecified at GSS-API level (Mechanism level:
-#    Invalid argument (400) - Cannot find key of appropriate type to decrypt
-#    AP REP - DES CBC mode with MD5)
-#  at sun.security.jgss.krb5.Krb5Context.acceptSecContext(Krb5Context.java:778)
-sun/security/krb5/auto/NonMutualSpnego.java                     generic-all
-
-# Fails on Solaris 10 sparc, GSSException: Failure unspecified at GSS-API level
-#   Also fails on Windows 2000 similar way
-sun/security/krb5/auto/ok-as-delegate.sh                        generic-all
-
-# Fails on Windows 2000, GSSException: Failure unspecified at GSS-API level
-#    (Mechanism level: Request is a replay (34))
-sun/security/krb5/auto/ok-as-delegate-xrealm.sh                 generic-all
-
-# Fails on Windows 2000, ExceptionInInitializerError
-sun/security/mscapi/AccessKeyStore.sh                           generic-all
+#sun/security/pkcs11/ec/TestECGenSpec.java                       solaris-i586
+#sun/security/pkcs11/ec/TestKeyFactory.java                      solaris-i586
+sun/security/pkcs11/sslecc/ClientJSSEServerJSSE.java            generic-all
 
-# Fails on Solaris 10, KrbException: Additional pre-authentication required (25)
-sun/security/krb5/auto/basic.sh                                 generic-all
+# Directly references PKCS11 class
+sun/security/pkcs11/Provider/Absolute.java                      windows-x64
 
-# Fails on Fedora 9 64bit, PKCS11Exception: CKR_DEVICE_ERROR
+# Fails on Fedora 9/Ubuntu 10.04 64bit, PKCS11Exception: CKR_DEVICE_ERROR
 sun/security/pkcs11/KeyAgreement/TestDH.java                    generic-all
 
 # Run too slow on Solaris 10 sparc
@@ -613,18 +362,10 @@
 sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ServerTimeout.java solaris-sparc
 sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/ReadTimeout.java solaris-sparc
 sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NotifyHandshakeTest.sh solaris-sparc
-sun/security/tools/keytool/AltProviderPath.sh                   solaris-sparc
 
 # Solaris 10 sparc, passed/failed confusion? java.security.ProviderException: update() failed
 sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/AsyncSSLSocketClose.java generic-all
 
-# Seem really slow on Solaris sparc, being excluded just for timing reasons
-sun/security/tools/jarsigner/AlgOptions.sh                      solaris-sparc
-sun/security/tools/jarsigner/nameclash.sh                       solaris-sparc
-sun/security/krb5/auto/basic.sh                                 solaris-sparc
-sun/security/provider/PolicyFile/getinstance/getinstance.sh     solaris-sparc
-sun/security/tools/jarsigner/samename.sh                        solaris-sparc
-
 # Timed out, Solaris 10 64bit sparcv9
 com/sun/crypto/provider/Cipher/DES/PaddingTest.java             generic-all
 
@@ -635,88 +376,25 @@
 #    Solaris sparc and sparcv9 -server, timeout
 sun/security/ssl/javax/net/ssl/NewAPIs/SessionTimeOutTests.java generic-all
 
-# Failed on solaris 10 sparc, othervm mode,  "js.jks: No such file or directory"
-#  Also, cannot verify signature on solaris i586 -server
-sun/security/tools/jarsigner/concise_jarsigner.sh               generic-all
-
 # Various failures on Linux Fedora 9 X64, othervm mode
 sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/TestAllSuites.java generic-all
 sun/security/ssl/sanity/ciphersuites/CheckCipherSuites.java     generic-all
-sun/security/tools/jarsigner/oldsig.sh                          generic-all
 
 # Various failures on Linux Fedora 9 X64, othervm mode
 sun/security/ssl/sanity/interop/ClientJSSEServerJSSE.java       generic-all
 
-# Linux i586 -server, buffer too short to hold shared secret?
-com/sun/crypto/provider/KeyAgreement/DHKeyAgreement2.java       generic-all
-
-# Solaris sparcv9: Failed to parse input emptysubject.jks: No such file or directory
-sun/security/tools/keytool/emptysubject.sh                      generic-all
-
-# Timeout on solaris-sparcv9 or exception thrown
-com/sun/crypto/provider/Cipher/RSA/TestOAEP_KAT.java            solaris-all
-
-# Leaving file open: SerialVersion.current, windows samevm
-java/security/BasicPermission/SerialVersion.java                generic-all
-
-# Solaris 11 i586, these all fail with samevm, need to be othervm???
-java/security/BasicPermission/NullOrEmptyName.java              generic-all
-
-# Suspect missing close() on file PermClass.current, windows samevm cascade
-java/security/BasicPermission/PermClass.java                    generic-all
-
 # Solaris 11 i586, these all fail with samevm, need to be othervm???
-java/security/KeyPairGenerator/Failover.java                    generic-all
-java/security/Provider/DefaultPKCS11.java                       generic-all
 java/security/SecureClassLoader/DefineClassByteBuffer.java      generic-all
-java/security/SecureRandom/GetAlgorithm.java                    generic-all
-java/security/Security/removing/RemoveProviders.java            generic-all
-java/security/Signature/ByteBuffers.java                        generic-all
-java/security/Signature/NONEwithRSA.java                        generic-all
-java/security/Signature/SignWithOutputBuffer.java               generic-all
-java/security/Signature/TestInitSignWithMyOwnRandom.java        generic-all
-java/security/UnresolvedPermission/AccessorMethods.java         generic-all
-java/security/UnresolvedPermission/Equals.java                  generic-all
-
-# Fails on OpenSolaris, missing classes, slow on Solaris sparc
-sun/security/ec/TestEC.java                                     generic-all
-
-# Problems with windows x64
-sun/security/mscapi/IsSunMSCAPIAvailable.sh                     windows-x64
-sun/security/mscapi/RSAEncryptDecrypt.sh                        windows-x64
-
-# Exception in test solaris-sparc -client -server, no windows
-sun/security/pkcs11/KeyGenerator/TestKeyGenerator.java          solaris-all
-
-# Solaris sparc client, fails to compile?
-sun/security/pkcs11/KeyStore/SecretKeysBasic.sh                 solaris-all
-
-# Fails on OpenSolaris java.net.BindException: Address already in use
-sun/security/pkcs11/sslecc/ClientJSSEServerJSSE.java            generic-all
-
-# Timeout on solaris-sparcv9 or ArrayIndexOutOfBoundsException?
-sun/security/rsa/TestKeyPairGeneratorLength.java                solaris-all
-sun/security/rsa/TestSignatures.java                            solaris-all
 
 # Timeout on solaris-sparc and i586 and x64, -client and -server
 sun/security/ssl/com/sun/net/ssl/internal/ssl/InputRecord/InterruptedIO.java solaris-all
 
-# Do not seem to run on windows machines? dll missing?
-sun/security/tools/jarsigner/emptymanifest.sh                   windows-all
-
-# Files does not exist or no encoding? solaris-sparcv9
-sun/security/tools/keytool/importreadall.sh                     solaris-all
-sun/security/tools/keytool/selfissued.sh                        solaris-all
+# 7147060
+com/sun/org/apache/xml/internal/security/transforms/ClassLoaderTest.java        generic-all
 
 ############################################################################
 
-# jdk_swing (not using samevm)
-
-# Fails on solaris 11 i586, with othervm
-javax/swing/JFileChooser/6570445/bug6570445.java                generic-all
-javax/swing/JFileChooser/6738668/bug6738668.java                generic-all
-javax/swing/JPopupMenu/6675802/bug6675802.java                  generic-all
-javax/swing/system/6799345/TestShutdown.java                    generic-all
+# jdk_swing
 
 ############################################################################
 
@@ -729,6 +407,9 @@
 
 # jdk_tools
 
+# 6461635
+com/sun/tools/attach/BasicTests.sh                              generic-all
+
 # Filed 6952105
 com/sun/jdi/SuspendThreadTest.java                              generic-all
 
@@ -745,12 +426,19 @@
 sun/jvmstat/monitor/MonitoredVm/CR6672135.java                  generic-all
 
 # 7162111
-sun/tools/jrunscript/jrunscript-DTest.sh			macosx-all
-sun/tools/jrunscript/jrunscript-argsTest.sh			macosx-all
-sun/tools/jrunscript/jrunscript-cpTest.sh			macosx-all
-sun/tools/jrunscript/jrunscript-eTest.sh			macosx-all
-sun/tools/jrunscript/jrunscript-fTest.sh			macosx-all
-sun/tools/jrunscript/jrunscriptTest.sh				macosx-all
+sun/tools/jrunscript/jrunscript-DTest.sh                       macosx-all
+sun/tools/jrunscript/jrunscript-argsTest.sh                    macosx-all
+sun/tools/jrunscript/jrunscript-cpTest.sh                      macosx-all
+sun/tools/jrunscript/jrunscript-eTest.sh                       macosx-all
+sun/tools/jrunscript/jrunscript-fTest.sh                       macosx-all
+sun/tools/jrunscript/jrunscriptTest.sh                         macosx-all
+
+# 8001118
+sun/tools/jcmd/jcmd-f.sh					generic-all
+sun/tools/jcmd/jcmd-help-help.sh				generic-all
+
+# 7175775
+sun/tools/jinfo/Basic.sh					macosx-all
 
 ############################################################################
 
@@ -784,7 +472,11 @@
 java/util/concurrent/locks/Lock/TimedAcquireLeak.java           generic-all
 
 # 7162111
-java/util/ResourceBundle/Control/Bug6530694.java		macosx-all
+java/util/ResourceBundle/Control/Bug6530694.java               macosx-all
+java/util/logging/LoggingDeadlock4.java                        macosx-all
+
+# 7041639, Solaris DSA keypair generation bug
+java/util/TimeZone/TimeZoneDatePermissionCheck.sh               solaris-all
 
 ############################################################################
 
--- jdk/test/TEST.ROOT	2012-08-10 10:31:59.000000000 -0700
+++ jdk/test/TEST.ROOT	2013-05-05 09:38:49.000000000 -0700
@@ -4,3 +4,9 @@
 
 # The list of keywords supported in the entire test suite
 keys=2d dnd i18n
+
+# Tests that must run in othervm mode
+othervm.dirs=java/awt java/beans java/rmi javax/accessibility javax/imageio javax/sound javax/print javax/management com/sun/awt sun/awt sun/java2d sun/pisces sun/rmi
+
+# Tests that cannot run concurrently
+exclusiveAccess.dirs=java/rmi/Naming java/util/prefs sun/management/jmxremote sun/tools/jstatd sun/security/mscapi
--- jdk/test/com/sun/crypto/provider/Cipher/DES/Sealtest.java	2012-08-10 10:32:00.000000000 -0700
+++ jdk/test/com/sun/crypto/provider/Cipher/DES/Sealtest.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 0000000
+ * @bug 0000000 7055362
  * @summary Sealtest
  * @author Jan Luehe
  */
@@ -54,14 +54,16 @@
         SealedObject sealed = new SealedObject(kp.getPrivate(), c);
 
         // serialize
-        FileOutputStream fos = new FileOutputStream("sealed");
-        ObjectOutputStream oos = new ObjectOutputStream(fos);
-        oos.writeObject(sealed);
+        try (FileOutputStream fos = new FileOutputStream("sealed");
+                ObjectOutputStream oos = new ObjectOutputStream(fos)) {
+            oos.writeObject(sealed);
+        }
 
         // deserialize
-        FileInputStream fis = new FileInputStream("sealed");
-        ObjectInputStream ois = new ObjectInputStream(fis);
-        sealed = (SealedObject)ois.readObject();
+        try (FileInputStream fis = new FileInputStream("sealed");
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            sealed = (SealedObject)ois.readObject();
+        }
 
         System.out.println(sealed.getAlgorithm());
 
--- jdk/test/com/sun/crypto/provider/Cipher/RSA/TestOAEP_KAT.java	2012-08-10 10:32:01.000000000 -0700
+++ jdk/test/com/sun/crypto/provider/Cipher/RSA/TestOAEP_KAT.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 4894151
+ * @bug 4894151 7055362
  * @summary known answer test for OAEP encryption
  * @author Andreas Sterbenz
  */
@@ -62,60 +62,62 @@
         System.out.println("Testing provider " + provider.getName() + "...");
         Cipher c = Cipher.getInstance("RSA/ECB/OAEPwithSHA1andMGF1Padding", provider);
         KeyFactory kf = KeyFactory.getInstance("RSA", kfProvider);
-        InputStream in = new FileInputStream(new File(BASE, "oaep-vect.txt"));
-        BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF8"));
-        while (true) {
-            String line = reader.readLine();
-            if (line == null) {
-                break;
-            }
-            line = line.trim();
-            if (line.length() == 0) {
-                continue;
-            }
-            if (line.equals("# RSA modulus n:")) {
-                n = parseNumber(reader);
-            } else if (line.equals("# RSA public exponent e:")) {
-                e = parseNumber(reader);
-            } else if (line.equals("# RSA private exponent d:")) {
-                d = parseNumber(reader);
-            } else if (line.equals("# Prime p:")) {
-                p = parseNumber(reader);
-            } else if (line.equals("# Prime q:")) {
-                q = parseNumber(reader);
-            } else if (line.equals("# p's CRT exponent dP:")) {
-                pe = parseNumber(reader);
-            } else if (line.equals("# q's CRT exponent dQ:")) {
-                qe = parseNumber(reader);
-            } else if (line.equals("# CRT coefficient qInv:")) {
-                coeff = parseNumber(reader);
-            } else if (line.equals("# Message to be encrypted:")) {
-                plainText = parseBytes(reader);
-            } else if (line.equals("# Seed:")) {
-                seed = parseBytes(reader);
-            } else if (line.equals("# Encryption:")) {
-                cipherText = parseBytes(reader);
-                // do encryption test first
-                KeySpec pubSpec = new RSAPublicKeySpec(n, e);
-                PublicKey pubKey = kf.generatePublic(pubSpec);
-                c.init(Cipher.ENCRYPT_MODE, pubKey, new MyRandom(seed));
-                cipherText2 = c.doFinal(plainText);
-                if (Arrays.equals(cipherText2, cipherText) == false) {
-                    throw new Exception("Encryption mismatch");
+        try (InputStream in = new FileInputStream(new File(BASE, "oaep-vect.txt"));
+                BufferedReader reader =
+                        new BufferedReader(new InputStreamReader(in, "UTF8"))) {
+            while (true) {
+                String line = reader.readLine();
+                if (line == null) {
+                    break;
+                }
+                line = line.trim();
+                if (line.length() == 0) {
+                    continue;
                 }
-                // followed by decryption test
-                KeySpec privSpec = new RSAPrivateCrtKeySpec(n, e, d, p, q, pe, qe, coeff);
-                PrivateKey privKey = kf.generatePrivate(privSpec);
-                c.init(Cipher.DECRYPT_MODE, privKey);
-                byte[] dec = c.doFinal(cipherText);
-                if (Arrays.equals(plainText, dec) == false) {
-                    throw new Exception("Decryption mismatch");
+                if (line.equals("# RSA modulus n:")) {
+                    n = parseNumber(reader);
+                } else if (line.equals("# RSA public exponent e:")) {
+                    e = parseNumber(reader);
+                } else if (line.equals("# RSA private exponent d:")) {
+                    d = parseNumber(reader);
+                } else if (line.equals("# Prime p:")) {
+                    p = parseNumber(reader);
+                } else if (line.equals("# Prime q:")) {
+                    q = parseNumber(reader);
+                } else if (line.equals("# p's CRT exponent dP:")) {
+                    pe = parseNumber(reader);
+                } else if (line.equals("# q's CRT exponent dQ:")) {
+                    qe = parseNumber(reader);
+                } else if (line.equals("# CRT coefficient qInv:")) {
+                    coeff = parseNumber(reader);
+                } else if (line.equals("# Message to be encrypted:")) {
+                    plainText = parseBytes(reader);
+                } else if (line.equals("# Seed:")) {
+                    seed = parseBytes(reader);
+                } else if (line.equals("# Encryption:")) {
+                    cipherText = parseBytes(reader);
+                    // do encryption test first
+                    KeySpec pubSpec = new RSAPublicKeySpec(n, e);
+                    PublicKey pubKey = kf.generatePublic(pubSpec);
+                    c.init(Cipher.ENCRYPT_MODE, pubKey, new MyRandom(seed));
+                    cipherText2 = c.doFinal(plainText);
+                    if (Arrays.equals(cipherText2, cipherText) == false) {
+                        throw new Exception("Encryption mismatch");
+                    }
+                    // followed by decryption test
+                    KeySpec privSpec = new RSAPrivateCrtKeySpec(n, e, d, p, q, pe, qe, coeff);
+                    PrivateKey privKey = kf.generatePrivate(privSpec);
+                    c.init(Cipher.DECRYPT_MODE, privKey);
+                    byte[] dec = c.doFinal(cipherText);
+                    if (Arrays.equals(plainText, dec) == false) {
+                        throw new Exception("Decryption mismatch");
+                    }
+                } else if (line.startsWith("# ------------------------------")) {
+                    // ignore, do not print
+                } else {
+                    // unknown line (comment), print
+                    System.out.println(": " + line);
                 }
-            } else if (line.startsWith("# ------------------------------")) {
-                // ignore, do not print
-            } else {
-                // unknown line (comment), print
-                System.out.println(": " + line);
             }
         }
         long stop = System.currentTimeMillis();
--- jdk/test/com/sun/jdi/ImmutableResourceTest.sh	2012-08-10 10:32:04.000000000 -0700
+++ jdk/test/com/sun/jdi/ImmutableResourceTest.sh	2013-05-05 09:38:48.000000000 -0700
@@ -56,7 +56,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux | Darwin )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- jdk/test/com/sun/jdi/JITDebug.sh	2012-08-10 10:32:04.000000000 -0700
+++ jdk/test/com/sun/jdi/JITDebug.sh	2013-05-05 09:38:48.000000000 -0700
@@ -63,7 +63,7 @@
 OS=`uname -s`
 export TRANSPORT_METHOD
 case "$OS" in
-   SunOS | Linux | Darwin )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       TRANSPORT_METHOD=dt_socket
       ;;
--- jdk/test/com/sun/jdi/PrivateTransportTest.sh	2012-08-10 10:32:05.000000000 -0700
+++ jdk/test/com/sun/jdi/PrivateTransportTest.sh	2013-05-05 09:38:48.000000000 -0700
@@ -123,7 +123,7 @@
     esac
     libloc=${jreloc}/lib/${libarch}
     ;;
-  Linux)
+  Linux | *BSD)
     xx=`find ${jreloc}/lib -name libdt_socket.so`
     libloc=`dirname ${xx}`
     ;;
--- jdk/test/com/sun/jdi/ShellScaffold.sh	2012-08-10 10:32:06.000000000 -0700
+++ jdk/test/com/sun/jdi/ShellScaffold.sh	2013-05-05 09:38:48.000000000 -0700
@@ -250,6 +250,7 @@
     isCygwin=
     case "$osname" in
        Windows* | CYGWIN*)	   
+         devnull=NUL
 	 if [ "$osname" = Windows_98 -o "$osname" = Windows_ME ]; then
              isWin98=1
              debuggeeKeyword='we_cant_kill_debuggees_on_win98'
@@ -259,6 +260,7 @@
          case "$osname" in
            CYGWIN*)
              isCygwin=1
+             devnull=/dev/null
              ;;
          esac
 
@@ -269,7 +271,6 @@
             transport=dt_socket
             address=
          fi
-         devnull=NUL
          baseArgs="$baseArgs -XX:-ShowMessageBoxOnError"
          # jtreg puts \\s in TESTCLASSES and some uses, eg. echo
          # treat them as control chars on mks (eg \t is tab)
@@ -292,7 +293,7 @@
          psCmd=ps
          jstack=jstack.exe
          ;;
-       SunOS | Linux | Darwin)
+       SunOS | Linux | *BSD | Darwin)
          transport=dt_socket
          address=
          devnull=/dev/null
--- jdk/test/com/sun/jdi/Solaris32AndSolaris64Test.sh	2012-08-10 10:32:06.000000000 -0700
+++ jdk/test/com/sun/jdi/Solaris32AndSolaris64Test.sh	2013-05-05 09:38:48.000000000 -0700
@@ -112,7 +112,7 @@
       fi
       ;;
 
-   Linux | Darwin )
+   Linux | *BSD | Darwin )
       pass "This test always passes on $OS"
       ;;
 
--- jdk/test/com/sun/jdi/connect/spi/JdiLoadedByCustomLoader.sh	2012-08-10 10:32:07.000000000 -0700
+++ jdk/test/com/sun/jdi/connect/spi/JdiLoadedByCustomLoader.sh	2013-05-05 09:38:48.000000000 -0700
@@ -45,7 +45,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     ;;
   Windows* | CYGWIN*)
--- jdk/test/com/sun/jndi/rmi/registry/RegistryContext/ContextWithNullProperties.java	2012-08-10 10:32:09.000000000 -0700
+++ jdk/test/com/sun/jndi/rmi/registry/RegistryContext/ContextWithNullProperties.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,26 +25,21 @@
  * @test
  * @bug 6676075
  * @summary RegistryContext (com.sun.jndi.url.rmi.rmiURLContext) coding problem
+ * @library ../../../../../../java/rmi/testlibrary
+ * @build TestLibrary
+ * @run main ContextWithNullProperties
  */
 
-import java.rmi.RemoteException;
-import java.rmi.registry.LocateRegistry;
-
-import com.sun.jndi.rmi.registry.*;
+import com.sun.jndi.rmi.registry.RegistryContext;
+import java.rmi.registry.Registry;
 
 public class ContextWithNullProperties {
-
     public static void main(String[] args) throws Exception {
-
-        // Create registry on port 1099 if one is not already running.
-        try {
-            LocateRegistry.createRegistry(1099);
-        } catch (RemoteException e) {
-        }
-
+        Registry registry = TestLibrary.createRegistryOnUnusedPort();
+        int registryPort = TestLibrary.getRegistryPort(registry);
         System.out.println("Connecting to the default Registry...");
         // Connect to the default Registry.
         // Pass null as the JNDI environment properties (see final argument)
-        RegistryContext ctx = new RegistryContext(null, -1, null);
+        RegistryContext ctx = new RegistryContext(null, registryPort, null);
     }
 }
--- jdk/test/com/sun/jndi/rmi/registry/RegistryContext/UnbindIdempotent.java	2012-08-10 10:32:09.000000000 -0700
+++ jdk/test/com/sun/jndi/rmi/registry/RegistryContext/UnbindIdempotent.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,26 +1,52 @@
 /*
+ * Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
  * @test
  * @bug 4278121
  * @summary Ensure that calling unbind() on an unbound name returns
  *      successfully.
+ * @library ../../../../../../java/rmi/testlibrary
+ * @build TestLibrary
+ * @run main UnbindIdempotent
  */
 
-import javax.naming.*;
+import java.rmi.registry.Registry;
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.NameNotFoundException;
+import javax.naming.NamingException;
 
 public class UnbindIdempotent {
 
     public static void main(String[] args) throws Exception {
-
-        // Create registry on port 1099 if one is not already running.
-        try {
-            java.rmi.registry.LocateRegistry.createRegistry(1099);
-        } catch (java.rmi.RemoteException e) {
-        }
-
-        Context ictx = new InitialContext();
+        Registry registry = TestLibrary.createRegistryOnUnusedPort();
+        int registryPort = TestLibrary.getRegistryPort(registry);
+        InitialContext ictx = new InitialContext();
         Context rctx;
+
         try {
-            rctx = (Context)ictx.lookup("rmi://localhost:1099");
+            rctx = (Context)ictx.lookup("rmi://localhost:" + Integer.toString(registryPort));
         } catch (NamingException e) {
             // Unable to set up for test.
             return;
--- jdk/test/com/sun/management/OperatingSystemMXBean/TestTotalSwap.sh	2012-08-10 10:32:09.000000000 -0700
+++ jdk/test/com/sun/management/OperatingSystemMXBean/TestTotalSwap.sh	2013-05-05 09:38:48.000000000 -0700
@@ -72,6 +72,16 @@
    done
 }
 
+bsd_swap_size()
+{
+   total_swap=0
+   for i in `/usr/sbin/swapinfo -k | awk '{print $2}' | grep -v blocks`
+   do
+      # swapinfo -k returns size in kilobytes.
+      total_swap=`expr $i \* 1024 + $total_swap`
+   done
+}
+
 # Test GetTotalSwapSpaceSize if we are running on Unix
 total_swap=0
 case `uname -s` in
@@ -83,6 +93,9 @@
        total_swap=`free -b | grep -i swap | awk '{print $2}'`
        runOne GetTotalSwapSpaceSize $total_swap 
        ;;
+     *BSD )
+       bsd_swap_size
+       runOne GetTotalSwapSpaceSize $total_swap 
      Darwin )
        # $ sysctl -n vm.swapusage 
        # total = 8192.00M  used = 7471.11M  free = 720.89M  (encrypted)
--- jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetMaxFileDescriptorCount.sh	2012-08-10 10:32:11.000000000 -0700
+++ jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetMaxFileDescriptorCount.sh	2013-05-05 09:38:48.000000000 -0700
@@ -48,7 +48,7 @@
 
 # Test GetMaxFileDescriptorCount if we are running on Unix
 case `uname -s` in
-    SunOS | Linux )
+    SunOS | Linux | *BSD | Darwin )
        runOne GetMaxFileDescriptorCount
        ;;
     * )
--- jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetOpenFileDescriptorCount.sh	2012-08-10 10:32:11.000000000 -0700
+++ jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetOpenFileDescriptorCount.sh	2013-05-05 09:38:48.000000000 -0700
@@ -48,7 +48,7 @@
 
 # Test GetOpenFileDescriptorCount if we are running on Unix
 case `uname -s` in
-    SunOS | Linux )
+    SunOS | Linux | *BSD | Darwin )
        runOne GetOpenFileDescriptorCount
        ;;
     * )
--- jdk/test/com/sun/security/auth/login/ConfigFile/IllegalURL.java	2012-08-10 10:32:13.000000000 -0700
+++ jdk/test/com/sun/security/auth/login/ConfigFile/IllegalURL.java	2013-05-05 09:38:49.000000000 -0700
@@ -43,8 +43,9 @@
     static void use(String f) throws Exception {
         System.out.println("Testing " + f  + "...");
         System.setProperty("java.security.auth.login.config", f);
-        try {
-            new FileInputStream(new URL(f).getFile().replace('/', File.separatorChar));
+        try (FileInputStream fis =
+                new FileInputStream(new URL(f).getFile().replace('/', File.separatorChar))) {
+            // do nothing
         } catch (Exception e) {
             System.out.println("Even old implementation does not support it. Ignored.");
             return;
--- jdk/test/com/sun/tools/attach/CommonSetup.sh	2012-08-10 10:32:15.000000000 -0700
+++ jdk/test/com/sun/tools/attach/CommonSetup.sh	2013-05-05 09:38:49.000000000 -0700
@@ -36,7 +36,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/demo/jvmti/mtrace/TraceJFrame.java	2012-08-10 10:32:16.000000000 -0700
+++ jdk/test/demo/jvmti/mtrace/TraceJFrame.java	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,21 +32,26 @@
  * @run main TraceJFrame JFrameCreateTime
  */
 
-public class TraceJFrame {
+import java.awt.GraphicsEnvironment;
 
+public class TraceJFrame {
     public static void main(String args[]) throws Exception {
-        DemoRun demo;
+        if (GraphicsEnvironment.getLocalGraphicsEnvironment().isHeadlessInstance()) {
+            System.out.println("JFrame test was skipped due to headless mode");
+        } else {
+            DemoRun demo;
+
+            /* Run demo that uses JVMTI mtrace agent (no options) */
+            demo = new DemoRun("mtrace", "" /* options to mtrace */ );
+            demo.runit(args[0]);
+
+            /* Make sure patterns in output look ok */
+            if (demo.output_contains("ERROR")) {
+                throw new RuntimeException("Test failed - ERROR seen in output");
+            }
 
-        /* Run demo that uses JVMTI mtrace agent (no options) */
-        demo = new DemoRun("mtrace", "" /* options to mtrace */ );
-        demo.runit(args[0]);
-
-        /* Make sure patterns in output look ok */
-        if (demo.output_contains("ERROR")) {
-            throw new RuntimeException("Test failed - ERROR seen in output");
+            /* Must be a pass. */
+            System.out.println("Test passed - cleanly terminated");
         }
-
-        /* Must be a pass. */
-        System.out.println("Test passed - cleanly terminated");
     }
 }
--- jdk/test/java/awt/Frame/7024749/bug7024749.java	2012-08-10 10:32:20.000000000 -0700
+++ jdk/test/java/awt/Frame/7024749/bug7024749.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,9 +23,9 @@
 
 /*
  * @test
- * @bug 7024749
+ * @bug 7024749 7184326
  * @summary JDK7 b131---a crash in: Java_sun_awt_windows_ThemeReader_isGetThemeTransitionDurationDefined+0x75
- * @library ../../../regtesthelpers
+ * @library ../../regtesthelpers
  * @build Util
  * @author Oleg Pekhovskiy: area=awt.toplevel
    @run main bug7024749
--- jdk/test/java/awt/Frame/HugeFrame/HugeFrame.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/awt/Frame/HugeFrame/HugeFrame.java	2013-05-05 09:38:43.000000000 -0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  @test
+  @bug 7160609
+  @summary A window with huge dimensions shouldn't crash JVM
+  @author anthony.petrov@oracle.com: area=awt.toplevel
+  @run main HugeFrame
+*/
+
+import java.awt.*;
+
+public class HugeFrame {
+    public static void main(String[] args) throws Exception {
+        Frame f = new Frame("Huge");
+
+        // 8193+ should already produce a crash, but let's go extreme...
+        f.setBounds(10, 10, 30000, 500000);
+        f.setVisible(true);
+
+        // We would crash by now if the bug wasn't fixed
+        Thread.sleep(1000);
+        System.err.println(f.getBounds());
+
+        // Cleanup
+        f.dispose();
+    }
+}
--- jdk/test/java/awt/Frame/WindowDragTest/WindowDragTest.java	2012-08-10 10:32:21.000000000 -0700
+++ jdk/test/java/awt/Frame/WindowDragTest/WindowDragTest.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,10 +23,11 @@
 
 /*
   @test
-  @bug 7128738
+  @bug 7128738 7161759
   @summary dragged dialog freezes system on dispose
   @author Oleg Pekhovskiy: area=awt.toplevel
   @library ../../regtesthelpers
+  @build Util
   @run main WindowDragTest
 */
 
--- jdk/test/java/awt/Modal/ModalDialogMultiscreenTest/ModalDialogMultiscreenTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/awt/Modal/ModalDialogMultiscreenTest/ModalDialogMultiscreenTest.java	2013-05-05 09:38:42.000000000 -0700
@@ -0,0 +1,441 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  @test
+  @bug 6430802 8008379
+  @summary WM should not hang after show()/close()
+  @author anthony.petrov@sun.com: area=awt.modal
+  @run main/manual ModalDialogMultiscreenTest
+*/
+
+
+/**
+ * ModalDialogMultiscreenTest.java
+ *
+ * summary: Tests whether a WM will hang on show()/close() a modal dialog in multiscreen mode
+ */
+
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+
+
+public class ModalDialogMultiscreenTest
+{
+
+    private static class ButtonActionListener implements ActionListener {
+        JFrame frame;
+        JDialog dialog;
+        public ButtonActionListener(JFrame frame, JDialog dialog) {
+            this.frame = frame;
+            this.dialog = dialog;
+        }
+        public void actionPerformed(ActionEvent e) {
+            dialog.setLocationRelativeTo(frame);
+            dialog.setVisible(true);
+        }
+    }
+    public static class TestDialog extends JDialog {
+        public TestDialog(Frame owner, String title, boolean modal, GraphicsConfiguration gc) {
+            super(owner, title, modal, gc);
+            setSize(200, 100);
+            JButton button = new JButton("Close");
+            button.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    dispose();
+                }
+            });
+            getContentPane().add(button);
+        }
+    }
+
+    private static void init()
+    {
+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
+        GraphicsDevice[] gs = ge.getScreenDevices();
+
+        Sysout.createDialog( );
+
+        if (gs.length < 2) {
+            System.out.println("Not multi-head environment, test not valid!");
+            ModalDialogMultiscreenTest.pass( );
+        }
+
+        String[] instructions =
+        {
+            "The test should be run on a multi-head X (non-xinerama) systems.",
+            "Otherwise click the Pass button right now.",
+            "You will see an open Frame on each screen your system has.",
+            "The frame has an 'Open dialog' button.",
+            "Clicking the button opens a modal dialog with a Close button.",
+            "The test procedure:",
+            "1. Open a dialog and close it with appropriate buttons.",
+            "2. Switch to another screen ($ DISPLAY=X.Y xprop)",
+            "3. Repeat steps 1-2 several times (about 3*<number-of-screens>)",
+            "If the test doesn't cause the window manager to hang, it's passed."
+        };
+        Sysout.printInstructions( instructions );
+
+
+        for (int i = 0; i < gs.length; i++) {
+            JFrame frame = new JFrame("Frame "+i,gs[i].getDefaultConfiguration());
+            JButton button = new JButton("Open Dialog");
+            button.setMinimumSize(new Dimension(200, 100));
+            button.setPreferredSize(new Dimension(200, 100));
+            button.setSize(new Dimension(200, 100));
+            button.addActionListener(new ButtonActionListener(frame, new TestDialog(frame, "Dialog #"+i, true, gs[i].getDefaultConfiguration())));
+            frame.getContentPane().add(button);
+            frame.pack();
+            frame.setVisible(true);
+        }
+
+    }//End  init()
+
+
+    //ap203012: NO MORE CHANGES BELOW THIS LINE
+
+
+
+    /*****************************************************
+     * Standard Test Machinery Section
+     * DO NOT modify anything in this section -- it's a
+     * standard chunk of code which has all of the
+     * synchronisation necessary for the test harness.
+     * By keeping it the same in all tests, it is easier
+     * to read and understand someone else's test, as
+     * well as insuring that all tests behave correctly
+     * with the test harness.
+     * There is a section following this for test-defined
+     * classes
+     ******************************************************/
+    private static boolean theTestPassed = false;
+    private static boolean testGeneratedInterrupt = false;
+    private static String failureMessage = "";
+
+    private static Thread mainThread = null;
+
+    private static int sleepTime = 300000;
+
+    public static void main( String args[] ) throws InterruptedException
+    {
+        mainThread = Thread.currentThread();
+        try
+        {
+            init();
+        }
+        catch( TestPassedException e )
+        {
+            //The test passed, so just return from main and harness will
+            // interepret this return as a pass
+            return;
+        }
+        //At this point, neither test passed nor test failed has been
+        // called -- either would have thrown an exception and ended the
+        // test, so we know we have multiple threads.
+
+        //Test involves other threads, so sleep and wait for them to
+        // called pass() or fail()
+        try
+        {
+            Thread.sleep( sleepTime );
+            //Timed out, so fail the test
+            throw new RuntimeException( "Timed out after " + sleepTime/1000 + " seconds" );
+        }
+        catch (InterruptedException e)
+        {
+            if( ! testGeneratedInterrupt ) throw e;
+
+            //reset flag in case hit this code more than once for some reason (just safety)
+            testGeneratedInterrupt = false;
+            if ( theTestPassed == false )
+            {
+                throw new RuntimeException( failureMessage );
+            }
+        }
+
+    }//main
+
+    public static synchronized void setTimeoutTo( int seconds )
+    {
+        sleepTime = seconds * 1000;
+    }
+
+    public static synchronized void pass()
+    {
+        Sysout.println( "The test passed." );
+        Sysout.println( "The test is over, hit  Ctl-C to stop Java VM" );
+        //first check if this is executing in main thread
+        if ( mainThread == Thread.currentThread() )
+        {
+            //Still in the main thread, so set the flag just for kicks,
+            // and throw a test passed exception which will be caught
+            // and end the test.
+            theTestPassed = true;
+            throw new TestPassedException();
+        }
+        //pass was called from a different thread, so set the flag and interrupt
+        // the main thead.
+        theTestPassed = true;
+        testGeneratedInterrupt = true;
+        mainThread.interrupt();
+    }//pass()
+
+    public static synchronized void fail()
+    {
+        //test writer didn't specify why test failed, so give generic
+        fail( "it just plain failed! :-)" );
+    }
+
+    public static synchronized void fail( String whyFailed )
+    {
+        Sysout.println( "The test failed: " + whyFailed );
+        Sysout.println( "The test is over, hit  Ctl-C to stop Java VM" );
+        //check if this called from main thread
+        if ( mainThread == Thread.currentThread() )
+        {
+            //If main thread, fail now 'cause not sleeping
+            throw new RuntimeException( whyFailed );
+        }
+        theTestPassed = false;
+        testGeneratedInterrupt = true;
+        failureMessage = whyFailed;
+        mainThread.interrupt();
+    }//fail()
+
+}// class ModalDialogMultiscreenTest
+
+//This exception is used to exit from any level of call nesting
+// when it's determined that the test has passed, and immediately
+// end the test.
+class TestPassedException extends RuntimeException
+{
+}
+
+//*********** End Standard Test Machinery Section **********
+
+
+//************ Begin classes defined for the test ****************
+
+// make listeners in a class defined here, and instantiate them in init()
+
+/* Example of a class which may be written as part of a test
+class NewClass implements anInterface
+ {
+   static int newVar = 0;
+
+   public void eventDispatched(AWTEvent e)
+    {
+      //Counting events to see if we get enough
+      eventCount++;
+
+      if( eventCount == 20 )
+       {
+         //got enough events, so pass
+
+         ModalDialogMultiscreenTest.pass();
+       }
+      else if( tries == 20 )
+       {
+         //tried too many times without getting enough events so fail
+
+         ModalDialogMultiscreenTest.fail();
+       }
+
+    }// eventDispatched()
+
+ }// NewClass class
+
+*/
+
+
+//************** End classes defined for the test *******************
+
+
+
+
+/****************************************************
+ Standard Test Machinery
+ DO NOT modify anything below -- it's a standard
+  chunk of code whose purpose is to make user
+  interaction uniform, and thereby make it simpler
+  to read and understand someone else's test.
+ ****************************************************/
+
+/**
+ This is part of the standard test machinery.
+ It creates a dialog (with the instructions), and is the interface
+  for sending text messages to the user.
+ To print the instructions, send an array of strings to Sysout.createDialog
+  WithInstructions method.  Put one line of instructions per array entry.
+ To display a message for the tester to see, simply call Sysout.println
+  with the string to be displayed.
+ This mimics System.out.println but works within the test harness as well
+  as standalone.
+ */
+
+class Sysout
+{
+    private static TestDialog dialog;
+
+    public static void createDialogWithInstructions( String[] instructions )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        dialog.printInstructions( instructions );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+    public static void createDialog( )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        String[] defInstr = { "Instructions will appear here. ", "" } ;
+        dialog.printInstructions( defInstr );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+
+    public static void printInstructions( String[] instructions )
+    {
+        dialog.printInstructions( instructions );
+    }
+
+
+    public static void println( String messageIn )
+    {
+        dialog.displayMessage( messageIn );
+    }
+
+}// Sysout  class
+
+/**
+  This is part of the standard test machinery.  It provides a place for the
+   test instructions to be displayed, and a place for interactive messages
+   to the user to be displayed.
+  To have the test instructions displayed, see Sysout.
+  To have a message to the user be displayed, see Sysout.
+  Do not call anything in this dialog directly.
+  */
+class TestDialog extends Dialog implements ActionListener
+{
+
+    TextArea instructionsText;
+    TextArea messageText;
+    int maxStringLength = 80;
+    Panel  buttonP = new Panel();
+    Button passB = new Button( "pass" );
+    Button failB = new Button( "fail" );
+
+    //DO NOT call this directly, go through Sysout
+    public TestDialog( Frame frame, String name )
+    {
+        super( frame, name );
+        int scrollBoth = TextArea.SCROLLBARS_BOTH;
+        instructionsText = new TextArea( "", 15, maxStringLength, scrollBoth );
+        add( "North", instructionsText );
+
+        messageText = new TextArea( "", 5, maxStringLength, scrollBoth );
+        add("Center", messageText);
+
+        passB = new Button( "pass" );
+        passB.setActionCommand( "pass" );
+        passB.addActionListener( this );
+        buttonP.add( "East", passB );
+
+        failB = new Button( "fail" );
+        failB.setActionCommand( "fail" );
+        failB.addActionListener( this );
+        buttonP.add( "West", failB );
+
+        add( "South", buttonP );
+        pack();
+
+        setVisible(true);
+    }// TestDialog()
+
+    //DO NOT call this directly, go through Sysout
+    public void printInstructions( String[] instructions )
+    {
+        //Clear out any current instructions
+        instructionsText.setText( "" );
+
+        //Go down array of instruction strings
+
+        String printStr, remainingStr;
+        for( int i=0; i < instructions.length; i++ )
+        {
+            //chop up each into pieces maxSringLength long
+            remainingStr = instructions[ i ];
+            while( remainingStr.length() > 0 )
+            {
+                //if longer than max then chop off first max chars to print
+                if( remainingStr.length() >= maxStringLength )
+                {
+                    //Try to chop on a word boundary
+                    int posOfSpace = remainingStr.
+                        lastIndexOf( ' ', maxStringLength - 1 );
+
+                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;
+
+                    printStr = remainingStr.substring( 0, posOfSpace + 1 );
+                    remainingStr = remainingStr.substring( posOfSpace + 1 );
+                }
+                //else just print
+                else
+                {
+                    printStr = remainingStr;
+                    remainingStr = "";
+                }
+
+                instructionsText.append( printStr + "\n" );
+
+            }// while
+
+        }// for
+
+    }//printInstructions()
+
+    //DO NOT call this directly, go through Sysout
+    public void displayMessage( String messageIn )
+    {
+        messageText.append( messageIn + "\n" );
+        System.out.println(messageIn);
+    }
+
+    //catch presses of the passed and failed buttons.
+    //simply call the standard pass() or fail() static methods of
+    //ModalDialogMultiscreenTest
+    public void actionPerformed( ActionEvent e )
+    {
+        if( e.getActionCommand() == "pass" )
+        {
+            ModalDialogMultiscreenTest.pass();
+        }
+        else
+        {
+            ModalDialogMultiscreenTest.fail();
+        }
+    }
+
+}// TestDialog  class
--- jdk/test/java/awt/Modal/WsDisabledStyle/Winkey/Winkey.java	2012-08-10 10:32:23.000000000 -0700
+++ jdk/test/java/awt/Modal/WsDisabledStyle/Winkey/Winkey.java	2013-05-05 09:38:42.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,8 +22,8 @@
  */
 
 /*
-  @test %I% %E%
-  @bug 6572263 6571808
+  @test
+  @bug 6572263 6571808 8005920
   @summary  PIT:FileDialog minimized to taskbar(through 'Show Desktop')selecting the fileDialog using windowList
   @author dmitry.cherepanov: area=awt.modal
   @run main/manual Winkey
@@ -48,12 +48,14 @@
 
         String[] instructions =
         {
+            " 0. This test is for MS Windows only, if you use other OS, press \"pass\" button.",
             " 1. there is a frame with a 'show modal' button, ",
             " 2. press the button to show a modal dialog, ",
             " 3. the modal dialog will be shown over the frame, ",
             " 4. please verify that all (5.1, 5.2.1, 5.2.2) the following tests pass: ",
             " ",
             " 5.1. press combination Windows Key and M key to minimize all windows, ",
+            "      note that the modal dialog and modal blocked windows are NOT minimized",
             " 5.2. press combination Windows Key and D key to show desktop, ",
             "      5.2.1. restore the dialog by choosing this one in the ALT-TAB list, ",
             "      5.2.2. restore the dialog by mouse click on taskbar (on java or any other item)",
--- jdk/test/java/awt/PrintJob/Text/stringwidth.sh	2012-08-10 10:32:25.000000000 -0700
+++ jdk/test/java/awt/PrintJob/Text/stringwidth.sh	2013-05-05 09:38:43.000000000 -0700
@@ -25,10 +25,11 @@
 fi
 
 
-if [ $OS = SunOS -o $OS = Linux ]
-then
-    exit 0
-fi
+case "${OS}" in
+    SunOS | Linux | *BSD | Darwin )
+        exit 0
+        ;;
+esac
 # Windows
 
 if [ -z "${TESTJAVA}" ] ; then
--- jdk/test/java/awt/Toolkit/AutoShutdown/ShowExitTest/ShowExitTest.sh	2012-08-10 10:32:25.000000000 -0700
+++ jdk/test/java/awt/Toolkit/AutoShutdown/ShowExitTest/ShowExitTest.sh	2013-05-05 09:38:43.000000000 -0700
@@ -1,7 +1,7 @@
 #!/bin/ksh -p
 
 #
-# Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -39,7 +39,7 @@
 
 #Call this from anywhere to fail the test with an error message
 # usage: fail "reason why the test failed"
-fail() 
+fail()
  { echo "The test failed :-("
    echo "$*" 1>&2
    echo "exit status was $status"
@@ -48,7 +48,7 @@
 
 #Call this from anywhere to pass the test with a message
 # usage: pass "reason why the test passed if applicable"
-pass() 
+pass()
  { echo "The test passed!!!"
    echo "$*" 1>&2
    exit 0
@@ -64,20 +64,42 @@
 case "$OS" in
    SunOS )
       VAR="One value for Sun"
-      DEFAULT_JDK=/usr/local/java/jdk1.2/solaris
+      DEFAULT_JDK=/
       FILESEP="/"
+      PATHSEP=":"
+      TMP="/tmp"
       ;;
 
    Linux )
       VAR="A different value for Linux"
-      DEFAULT_JDK=/usr/local/java/jdk1.4/linux-i386
+      DEFAULT_JDK=/
       FILESEP="/"
+      PATHSEP=":"
+      TMP="/tmp"
       ;;
 
-   Windows_95 | Windows_98 | Windows_NT | Windows_ME )
+   Darwin )
+      VAR="A different value for MacOSX"
+      DEFAULT_JDK=/usr
+      FILESEP="/"
+      PATHSEP=":"
+      TMP="/tmp"
+      ;;
+
+   Windows* )
       VAR="A different value for Win32"
-      DEFAULT_JDK=/usr/local/java/jdk1.2/win32
+      DEFAULT_JDK="C:/Program Files/Java/jdk1.8.0"
       FILESEP="\\"
+      PATHSEP=";"
+      TMP=`cd "${SystemRoot}/Temp"; echo ${PWD}`
+      ;;
+
+    CYGWIN* )
+      VAR="A different value for Cygwin"
+      DEFAULT_JDK="/cygdrive/c/Program\ Files/Java/jdk1.8.0"
+      FILESEP="/"
+      PATHSEP=";"
+      TMP=`cd "${SystemRoot}/Temp"; echo ${PWD}`
       ;;
 
    # catch all other OSs
@@ -88,8 +110,8 @@
 esac
 
 
-# Want this test to run standalone as well as in the harness, so do the 
-#  following to copy the test's directory into the harness's scratch directory 
+# Want this test to run standalone as well as in the harness, so do the
+#  following to copy the test's directory into the harness's scratch directory
 #  and set all appropriate variables:
 
 if [ -z "${TESTJAVA}" ] ; then
@@ -104,7 +126,7 @@
    if [ -n "$1" ] ;
       then TESTJAVA=$1
       else echo "no JDK specified on command line so using default!"
-	 TESTJAVA=$DEFAULT_JDK
+     TESTJAVA=$DEFAULT_JDK
    fi
    TESTSRC=.
    TESTCLASSES=.
@@ -113,25 +135,25 @@
 echo "JDK under test is: $TESTJAVA"
 
 #Deal with .class files:
-if [ -n "${STANDALONE}" ] ; 
-   then 
+if [ -n "${STANDALONE}" ] ;
+   then
    #if standalone, remind user to cd to dir. containing test before running it
    echo "Just a reminder: cd to the dir containing this test when running it"
    # then compile all .java files (if there are any) into .class files
-   if [ -a *.java ] ; 
+   if [ -a *.java ] ;
       then echo "Reminder, this test should be in its own directory with all"
       echo "supporting files it needs in the directory with it."
-      ${TESTJAVA}/bin/javac ./*.java ; 
+      ${TESTJAVA}/bin/javac ./*.java ;
    fi
    # else in harness so copy all the class files from where jtreg put them
-   # over to the scratch directory this test is running in. 
+   # over to the scratch directory this test is running in.
    else cp ${TESTCLASSES}/*.class . ;
 fi
 
-#if in test harness, then copy the entire directory that the test is in over 
+#if in test harness, then copy the entire directory that the test is in over
 # to the scratch directory.  This catches any support files needed by the test.
-if [ -z "${STANDALONE}" ] ; 
-   then cp ${TESTSRC}/* . 
+if [ -z "${STANDALONE}" ] ;
+   then cp ${TESTSRC}/* .
 fi
 
 #Just before executing anything, make sure it has executable permission!
--- jdk/test/java/awt/Window/Grab/GrabTest.java	2012-08-10 10:32:26.000000000 -0700
+++ jdk/test/java/awt/Window/Grab/GrabTest.java	2013-05-05 09:38:43.000000000 -0700
@@ -65,7 +65,7 @@
             }, sun.awt.SunToolkit.GRAB_EVENT_MASK);
 
         f = new Frame("Frame");
-        f.setBounds(0, 0, 300, 300);
+        f.setSize(200, 200);
         f.addMouseListener(new MouseAdapter() {
                 public void mousePressed(MouseEvent e) {
                     System.out.println(e);
@@ -74,7 +74,7 @@
             });
 
         f1 = new Frame("OtherFrame");
-        f1.setBounds(700, 100, 200, 200);
+        f1.setBounds(600, 100, 200, 200);
 
         w = new Window(f);
         w.setLayout(new FlowLayout());
@@ -86,7 +86,7 @@
                 }
             });
         w.add(b);
-        w.setBounds(400, 100, 200, 200);
+        w.setBounds(300, 100, 200, 200);
         w.setBackground(Color.blue);
         w.addMouseListener(new MouseAdapter() {
                 public void mousePressed(MouseEvent e) {
@@ -175,8 +175,7 @@
 
         // 6. Check that press on the outside area causes ungrab
         Point loc = f.getLocationOnScreen();
-        robot.mouseMove(loc.x + 100, loc.y + f.getSize().height + 1);
-        Util.waitForIdle(robot);
+        robot.mouseMove(loc.x + 100, loc.y + f.getSize().height + 300);
         robot.mousePress(InputEvent.BUTTON1_MASK);
         robot.delay(50);
         robot.mouseRelease(InputEvent.BUTTON1_MASK);
--- jdk/test/java/awt/appletviewer/IOExceptionIfEncodedURLTest/IOExceptionIfEncodedURLTest.sh	2012-08-10 10:32:26.000000000 -0700
+++ jdk/test/java/awt/appletviewer/IOExceptionIfEncodedURLTest/IOExceptionIfEncodedURLTest.sh	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -38,7 +38,7 @@
 
 #Call this from anywhere to fail the test with an error message
 # usage: fail "reason why the test failed"
-fail() 
+fail()
  { echo "The test failed :-("
    echo "$*" 1>&2
    echo "exit status was $status"
@@ -47,7 +47,7 @@
 
 #Call this from anywhere to pass the test with a message
 # usage: pass "reason why the test passed if applicable"
-pass() 
+pass()
  { echo "The test passed!!!"
    echo "$*" 1>&2
    exit 0
@@ -99,20 +99,42 @@
 case "$OS" in
    SunOS )
       VAR="One value for Sun"
-      DEFAULT_JDK=/usr/local/java/jdk1.2.1/solaris
+      DEFAULT_JDK=/
       FILESEP="/"
+      PATHSEP=":"
+      TMP="/tmp"
       ;;
 
    Linux )
       VAR="A different value for Linux"
-      DEFAULT_JDK=/usr/local/java/jdk1.4/linux-i386
+      DEFAULT_JDK=/
       FILESEP="/"
+      PATHSEP=":"
+      TMP="/tmp"
       ;;
 
-   Windows_95 | Windows_98 | Windows_NT | Windows_ME | CYGWIN_NT-5.1)
+   Darwin )
+      VAR="A different value for MacOSX"
+      DEFAULT_JDK=/usr
+      FILESEP="/"
+      PATHSEP=":"
+      TMP="/tmp"
+      ;;
+
+   Windows* )
       VAR="A different value for Win32"
-      DEFAULT_JDK=/usr/local/java/jdk1.2.1/win32
+      DEFAULT_JDK="C:/Program Files/Java/jdk1.8.0"
       FILESEP="\\"
+      PATHSEP=";"
+      TMP=`cd "${SystemRoot}/Temp"; echo ${PWD}`
+      ;;
+
+    CYGWIN* )
+      VAR="A different value for Cygwin"
+      DEFAULT_JDK="/cygdrive/c/Program\ Files/Java/jdk1.8.0"
+      FILESEP="/"
+      PATHSEP=";"
+      TMP=`cd "${SystemRoot}/Temp"; echo ${PWD}`
       ;;
 
    # catch all other OSs
@@ -132,12 +154,12 @@
 #  note that the name of the executable is in the fail string as well.
 # this is how to check for presence of the compiler, etc.
 #RESOURCE=`whence SomeProgramOrFileNeeded`
-#if [ "${RESOURCE}" = "" ] ; 
-#   then fail "Need SomeProgramOrFileNeeded to perform the test" ; 
+#if [ "${RESOURCE}" = "" ] ;
+#   then fail "Need SomeProgramOrFileNeeded to perform the test" ;
 #fi
 
-# Want this test to run standalone as well as in the harness, so do the 
-#  following to copy the test's directory into the harness's scratch directory 
+# Want this test to run standalone as well as in the harness, so do the
+#  following to copy the test's directory into the harness's scratch directory
 #  and set all appropriate variables:
 
 if [ -z "${TESTJAVA}" ] ; then
@@ -152,7 +174,7 @@
    if [ -n "$1" ] ;
       then TESTJAVA=$1
       else echo "no JDK specified on command line so using default!"
-	 TESTJAVA=$DEFAULT_JDK
+     TESTJAVA=$DEFAULT_JDK
    fi
    TESTSRC=.
    TESTCLASSES=.
@@ -161,25 +183,25 @@
 echo "JDK under test is: $TESTJAVA"
 
 #Deal with .class files:
-if [ -n "${STANDALONE}" ] ; 
-   then 
+if [ -n "${STANDALONE}" ] ;
+   then
    #if standalone, remind user to cd to dir. containing test before running it
    echo "Just a reminder: cd to the dir containing this test when running it"
    # then compile all .java files (if there are any) into .class files
-   if [ -a *.java ] ; 
+   if [ -a *.java ] ;
       then echo "Reminder, this test should be in its own directory with all"
       echo "supporting files it needs in the directory with it."
-      ${TESTJAVA}/bin/javac ./*.java ; 
+      ${TESTJAVA}/bin/javac ./*.java ;
    fi
    # else in harness so copy all the class files from where jtreg put them
-   # over to the scratch directory this test is running in. 
+   # over to the scratch directory this test is running in.
    else cp ${TESTCLASSES}/*.class . ;
 fi
 
-#if in test harness, then copy the entire directory that the test is in over 
+#if in test harness, then copy the entire directory that the test is in over
 # to the scratch directory.  This catches any support files needed by the test.
-#if [ -z "${STANDALONE}" ] ; 
-#   then cp ${TESTSRC}/* . 
+#if [ -z "${STANDALONE}" ] ;
+#   then cp ${TESTSRC}/* .
 #fi
 
 #Just before executing anything, make sure it has executable permission!
@@ -198,7 +220,7 @@
 # this shell test as appropriate ( 0 status is considered a pass here )
 
 # The test verifies that appletviewer correctly works with the different
-# names of the files, including relative and absolute paths 
+# names of the files, including relative and absolute paths
 
 # 6619458: exclude left brace from the name of the files managed by the VCS
 NAME='test.html'
--- jdk/test/java/awt/event/TextEvent/TextEventSequenceTest/TextEventSequenceTest.java	2012-08-10 10:32:28.000000000 -0700
+++ jdk/test/java/awt/event/TextEvent/TextEventSequenceTest/TextEventSequenceTest.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,138 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 4028580
- * @summary TextArea does not send TextEvent when setText. Does for insert
- * @author kdm@sparc.spb.su: area= awt.TextAvent
- * @run main TextEventSequenceTest
- */
-import java.awt.*;
-import java.awt.event.*;
-import sun.awt.SunToolkit;
-
-public class TextEventSequenceTest {
-
-    private static Frame f;
-    private static TextField tf;
-    private static TextArea t;
-    private static int cntEmptyStrings = 0;
-    private static int cntNonEmptyStrings = 0;
-
-    public static void main(String[] args) {
-
-        test("non-empty text string");
-        test("");
-        test(null);
-    }
-
-    private static void test(String test) {
-        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
-
-        createAndShowGUI(test);
-        toolkit.realSync();
-
-        initCounts();
-        t.setText("Hello ");
-        toolkit.realSync();
-        t.append("World! !");
-        toolkit.realSync();
-        t.insert("from Roger Pham", 13);
-        toolkit.realSync();
-        t.replaceRange("Java Duke", 18, 28);
-        toolkit.realSync();
-        checkCounts(0, 4);
-
-        initCounts();
-        t.setText("");
-        toolkit.realSync();
-        t.setText("");
-        toolkit.realSync();
-        t.setText("");
-        toolkit.realSync();
-        checkCounts(1, 0);
-
-        initCounts();
-        tf.setText("Hello There!");
-        toolkit.realSync();
-        checkCounts(0, 1);
-
-        initCounts();
-        tf.setText("");
-        toolkit.realSync();
-        tf.setText("");
-        toolkit.realSync();
-        tf.setText("");
-        toolkit.realSync();
-        checkCounts(1, 0);
-
-        f.dispose();
-    }
-
-    private static void createAndShowGUI(String text) {
-        f = new Frame("TextEventSequenceTest");
-        f.setLayout(new FlowLayout());
-
-        TextListener listener = new MyTextListener();
-
-        tf = new TextField(text);
-        tf.addTextListener(listener);
-        f.add(tf);
-
-        t = new TextArea(text, 10, 30);
-        t.addTextListener(listener);
-        f.add(t);
-
-        f.pack();
-        f.setVisible(true);
-    }
-
-    static class MyTextListener implements TextListener {
-
-        public synchronized void textValueChanged(TextEvent e) {
-            TextComponent tc = (TextComponent) e.getSource();
-            String text = tc.getText();
-            if (text.length() == 0) {
-                cntEmptyStrings++;
-            } else {
-                cntNonEmptyStrings++;
-            }
-        }
-    }
-
-    synchronized static void initCounts() {
-        cntEmptyStrings = 0;
-        cntNonEmptyStrings = 0;
-    }
-
-    synchronized static void checkCounts(int empty, int nonempty) {
-        if (empty != cntEmptyStrings || nonempty != cntNonEmptyStrings) {
-            throw new RuntimeException(
-                    String.format("Expected events: empty = %d, nonempty = %d, "
-                    + "actual events: empty = %d, nonempty = %d",
-                    empty, nonempty, cntEmptyStrings, cntNonEmptyStrings));
-        }
-    }
-}
-
--- jdk/test/java/awt/font/TextLayout/TestKerning.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/awt/font/TextLayout/TestKerning.java	2013-05-05 09:38:43.000000000 -0700
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @summary Test Kerning is working.
+ * @bug 8009530
+ */
+
+import java.applet.*;
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.font.*;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Locale;
+
+public class TestKerning extends Applet {
+    private Panel panel;
+
+    static public void main(String[] args) {
+System.out.println(System.getProperty("os.name"));
+
+        Applet test = new TestKerning();
+        test.init();
+        test.start();
+
+        Frame f = new Frame("Test Kerning");
+        f.addWindowListener(new WindowAdapter() {
+            public void windowClosing(WindowEvent e) {
+                System.exit(0);
+            }
+        });
+        f.add("Center", test);
+        f.pack();
+        f.setVisible(true);
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(500, 200);
+    }
+
+    public Dimension getMaximumSize() {
+        return getPreferredSize();
+    }
+
+    private static final String testString = "To WAVA 1,45 office glyph.";
+
+    public void paint(Graphics g) {
+        Graphics2D g2d = (Graphics2D)g;
+        Font f = new Font("Arial", Font.PLAIN, 36);
+        // testing Arial on Solaris.
+        if (!("SunOS".equals(System.getProperty("os.name")))) {
+           return;
+        }
+        if (!("Arial".equals(f.getFamily(Locale.ENGLISH)))) {
+            return;
+        }
+        Map m = new HashMap();
+        m.put(TextAttribute.KERNING, TextAttribute.KERNING_ON);
+        Font kf = f.deriveFont(m);
+        g.setFont(f);
+        FontMetrics fm1 = g.getFontMetrics();
+        int sw1 = fm1.stringWidth(testString);
+        g.drawString(testString, 10, 50);
+        g.setFont(kf);
+        FontMetrics fm2 = g.getFontMetrics();
+        int sw2 = fm2.stringWidth(testString);
+        g.drawString(testString, 10, 90);
+        if (sw1 == sw2) {
+            System.out.println(sw1+" " + sw2);
+            throw new RuntimeException("No kerning");
+        }
+    }
+}
--- jdk/test/java/beans/Introspector/4520754/Test4520754.java	2012-08-10 10:32:30.000000000 -0700
+++ jdk/test/java/beans/Introspector/4520754/Test4520754.java	2013-05-05 09:38:41.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -58,7 +58,7 @@
     public static void main(String[] args) {
         // ensure that 4168475 does not regress
         test4168475(Component.class);
-        // AWT classes (sun.beans.infos.ComponentBeanInfo)
+        // AWT classes (com.sun.beans.infos.ComponentBeanInfo)
         test(null, Button.class, Component.class, List.class, Menu.class, Panel.class);
         // Swing classes (dt.jar)
         test(null, JApplet.class, JButton.class, JCheckBox.class);
--- jdk/test/java/beans/Introspector/6380849/TestBeanInfo.java	2012-08-10 10:32:31.000000000 -0700
+++ jdk/test/java/beans/Introspector/6380849/TestBeanInfo.java	2013-05-05 09:38:41.000000000 -0700
@@ -38,8 +38,7 @@
 
 import java.beans.BeanInfo;
 import java.beans.Introspector;
-import java.lang.ref.Reference;
-import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 
 public class TestBeanInfo implements Runnable {
 
@@ -60,10 +59,9 @@
         try {
             actual = Introspector.getBeanInfo(type);
             type = actual.getClass();
-            Field field = type.getDeclaredField("targetBeanInfoRef"); // NON-NLS: field name
-            field.setAccessible(true);
-            Reference ref = (Reference) field.get(actual);
-            actual = (BeanInfo) ref.get();
+            Method method = type.getDeclaredMethod("getTargetBeanInfo"); // NON-NLS: method name
+            method.setAccessible(true);
+            actual = (BeanInfo) method.invoke(actual);
         }
         catch (Exception exception) {
             throw new Error("unexpected error", exception);
--- jdk/test/java/beans/Introspector/Test7193977.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/beans/Introspector/Test7193977.java	2013-05-05 09:38:41.000000000 -0700
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7193977
+ * @summary Tests that generified property descriptors do not loose additional info
+ * @author Sergey Malenkov
+ */
+
+import java.awt.Image;
+import java.beans.BeanDescriptor;
+import java.beans.BeanInfo;
+import java.beans.EventSetDescriptor;
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.MethodDescriptor;
+import java.beans.PropertyDescriptor;
+import java.util.Arrays;
+import java.util.List;
+
+public class Test7193977 {
+
+    private static final List<String> names = Arrays.asList("listType", "list", "value");
+
+    public static void main(String args[]) {
+        for (String name : names) {
+            test(Abstract.class, name);
+            test(Concrete.class, name);
+        }
+    }
+
+    private static void test(Class<?> type, String name) {
+        if (!Boolean.TRUE.equals(BeanUtils.getPropertyDescriptor(type, name).getValue("transient"))) {
+            throw new Error("property '" + name + "' is not transient");
+        }
+    }
+
+    public static final class Concrete extends Abstract<String> {
+    }
+
+    public static abstract class Abstract<T> {
+        private List<T> list;
+
+        public List<T> getList() {
+            return this.list;
+        }
+
+        public void setList(List<T> list) {
+            this.list = list;
+        }
+
+        public T getValue(int index) {
+            return (0 <= index) && (this.list != null) && (index < this.list.size())
+                    ? this.list.get(index)
+                    : null;
+        }
+
+        public void setValue(int index, T value) {
+            if ((0 <= index) && (this.list != null)) {
+                if (index == this.list.size()) {
+                    this.list.add(value);
+                }
+                else if (index < this.list.size()) {
+                    this.list.set(index, value);
+                }
+            }
+        }
+
+        public String getListType() {
+            return (this.list != null)
+                    ? this.list.getClass().getName()
+                    : null;
+        }
+
+        public void setListType(String type) throws Exception {
+            this.list = (type != null)
+                    ? (List<T>) Class.forName(type).newInstance()
+                    : null;
+        }
+    }
+
+    public static final class ConcreteBeanInfo extends Wrapper {
+        public ConcreteBeanInfo() throws IntrospectionException {
+            super(Concrete.class);
+        }
+    }
+
+    public static final class AbstractBeanInfo extends Wrapper {
+        public AbstractBeanInfo() throws IntrospectionException {
+            super(Abstract.class);
+            for (PropertyDescriptor pd : getPropertyDescriptors()) {
+                if (names.contains(pd.getName())) {
+                    pd.setValue("transient", Boolean.TRUE);
+                }
+            }
+        }
+    }
+
+    private static class Wrapper implements BeanInfo {
+        private final BeanInfo info;
+
+        Wrapper(Class<?> type) throws IntrospectionException {
+            this.info = Introspector.getBeanInfo(type, Introspector.IGNORE_IMMEDIATE_BEANINFO);
+        }
+
+        public BeanDescriptor getBeanDescriptor() {
+            return this.info.getBeanDescriptor();
+        }
+
+        public EventSetDescriptor[] getEventSetDescriptors() {
+            return this.info.getEventSetDescriptors();
+        }
+
+        public int getDefaultEventIndex() {
+            return this.info.getDefaultEventIndex();
+        }
+
+        public PropertyDescriptor[] getPropertyDescriptors() {
+            return this.info.getPropertyDescriptors();
+        }
+
+        public int getDefaultPropertyIndex() {
+            return this.info.getDefaultPropertyIndex();
+        }
+
+        public MethodDescriptor[] getMethodDescriptors() {
+            return this.info.getMethodDescriptors();
+        }
+
+        public BeanInfo[] getAdditionalBeanInfo() {
+            return this.info.getAdditionalBeanInfo();
+        }
+
+        public Image getIcon(int kind) {
+            return this.info.getIcon(kind);
+        }
+    }
+}
--- jdk/test/java/beans/Introspector/Test7195106.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/beans/Introspector/Test7195106.java	2013-05-05 09:38:41.000000000 -0700
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7195106
+ * @summary Tests that explicit BeanInfo is not collected
+ * @author Sergey Malenkov
+ */
+
+import java.awt.Image;
+import java.awt.image.BufferedImage;
+import java.beans.BeanInfo;
+import java.beans.Introspector;
+import java.beans.SimpleBeanInfo;
+
+public class Test7195106 {
+
+    public static void main(String[] arg) throws Exception {
+        BeanInfo info = Introspector.getBeanInfo(My.class);
+        if (null == info.getIcon(BeanInfo.ICON_COLOR_16x16)) {
+            throw new Error("Unexpected behavior");
+        }
+        try {
+            int[] array = new int[1024];
+            while (true) {
+                array = new int[array.length << 1];
+            }
+        }
+        catch (OutOfMemoryError error) {
+            System.gc();
+        }
+        if (null == info.getIcon(BeanInfo.ICON_COLOR_16x16)) {
+            throw new Error("Explicit BeanInfo is collected");
+        }
+    }
+
+    public static class My {
+    }
+
+    public static class MyBeanInfo extends SimpleBeanInfo {
+        @Override
+        public Image getIcon(int type) {
+            return new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
+        }
+    }
+}
--- jdk/test/java/beans/Performance/Test7122740.java	2012-08-10 10:32:32.000000000 -0700
+++ jdk/test/java/beans/Performance/Test7122740.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 7122740
- * @summary Tests just a benchmark of PropertyDescriptor(String, Class) performance
- * @author Sergey Malenkov
- * @run main/manual Test7122740
- */
-
-import java.beans.PropertyDescriptor;
-
-public class Test7122740 {
-    public static void main(String[] args) throws Exception {
-        long time = System.nanoTime();
-        for (int i = 0; i < 1000; i++) {
-            new PropertyDescriptor("name", PropertyDescriptor.class);
-            new PropertyDescriptor("value", Concrete.class);
-        }
-        time -= System.nanoTime();
-        System.out.println("Time (ms): " + (-time / 1000000));
-    }
-
-    public static class Abstract<T> {
-        private T value;
-        public T getValue() {
-            return this.value;
-        }
-        public void setValue(T value) {
-            this.value = value;
-        }
-    }
-
-    private static class Concrete extends Abstract<String> {
-    }
-}
--- jdk/test/java/beans/Performance/Test7184799.java	2012-08-10 10:32:32.000000000 -0700
+++ jdk/test/java/beans/Performance/Test7184799.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 7184799
- * @summary Tests just a benchmark of Introspector.getBeanInfo(Class) performance
- * @author Sergey Malenkov
- * @run main/manual Test7184799
- */
-
-import java.beans.Introspector;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-
-public class Test7184799 {
-    private static final Class[] TYPES = {
-            Class.class,
-            String.class,
-            Character.class,
-            Boolean.class,
-            Byte.class,
-            Short.class,
-            Integer.class,
-            Long.class,
-            Float.class,
-            Double.class,
-            Collection.class,
-            Set.class,
-            HashSet.class,
-            TreeSet.class,
-            LinkedHashSet.class,
-            Map.class,
-            HashMap.class,
-            TreeMap.class,
-            LinkedHashMap.class,
-            WeakHashMap.class,
-            ConcurrentHashMap.class,
-            Dictionary.class,
-            Exception.class,
-    };
-
-    public static void main(String[] args) throws Exception {
-        long time = System.nanoTime();
-        for (Class type : TYPES) {
-            Introspector.getBeanInfo(type);
-        }
-        time -= System.nanoTime();
-        System.out.println("Time (ms): " + (-time / 1000000));
-    }
-}
--- jdk/test/java/beans/PropertyEditor/6380849/TestPropertyEditor.java	2012-08-10 10:32:33.000000000 -0700
+++ jdk/test/java/beans/PropertyEditor/6380849/TestPropertyEditor.java	2013-05-05 09:38:41.000000000 -0700
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,8 @@
  * @bug 6380849
  * @summary Tests PropertyEditor finder
  * @author Sergey Malenkov
+ * @compile -XDignore.symbol.file TestPropertyEditor.java
+ * @run main TestPropertyEditor
  */
 
 import editors.SecondBeanEditor;
@@ -36,17 +38,17 @@
 import java.beans.PropertyEditor;
 import java.beans.PropertyEditorManager;
 
-import sun.beans.editors.BooleanEditor;
-import sun.beans.editors.ByteEditor;
-import sun.beans.editors.ColorEditor;
-import sun.beans.editors.DoubleEditor;
-import sun.beans.editors.EnumEditor;
-import sun.beans.editors.FloatEditor;
-import sun.beans.editors.FontEditor;
-import sun.beans.editors.IntegerEditor;
-import sun.beans.editors.LongEditor;
-import sun.beans.editors.ShortEditor;
-import sun.beans.editors.StringEditor;
+import com.sun.beans.editors.BooleanEditor;
+import com.sun.beans.editors.ByteEditor;
+import com.sun.beans.editors.ColorEditor;
+import com.sun.beans.editors.DoubleEditor;
+import com.sun.beans.editors.EnumEditor;
+import com.sun.beans.editors.FloatEditor;
+import com.sun.beans.editors.FontEditor;
+import com.sun.beans.editors.IntegerEditor;
+import com.sun.beans.editors.LongEditor;
+import com.sun.beans.editors.ShortEditor;
+import com.sun.beans.editors.StringEditor;
 
 public class TestPropertyEditor implements Runnable {
 
--- jdk/test/java/beans/PropertyEditor/Test6963811.java	2012-08-10 10:32:33.000000000 -0700
+++ jdk/test/java/beans/PropertyEditor/Test6963811.java	2013-05-05 09:38:41.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,10 +26,12 @@
  * @bug 6963811
  * @summary Tests deadlock in PropertyEditorManager
  * @author Sergey Malenkov
+ * @compile -XDignore.symbol.file Test6963811.java
+ * @run main Test6963811
  */
 
 import java.beans.PropertyEditorManager;
-import sun.beans.editors.StringEditor;
+import com.sun.beans.editors.StringEditor;
 
 public class Test6963811 implements Runnable {
     private final long time;
--- jdk/test/java/beans/XMLEncoder/Test7169395.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/beans/XMLEncoder/Test7169395.java	2013-05-05 09:38:42.000000000 -0700
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7169395
+ * @summary Tests that array list initialized correctly
+ * @author Sergey Malenkov
+ */
+
+import java.beans.ConstructorProperties;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.TreeMap;
+
+public class Test7169395 extends AbstractTest {
+
+    public static void main(String[] args) {
+        new Test7169395().test(true);
+    }
+
+    protected Object getObject() {
+        Container container = new Container();
+        container.add("test-null", null);
+        container.add("test-value", "value");
+        container.add("test-other", "other");
+        return container;
+    }
+
+    public static class Component {
+
+        private final Container container;
+        private final String name;
+        private String value;
+
+        @ConstructorProperties({ "container", "name" })
+        public Component(Container container, String name) {
+            this.container = container;
+            this.name = name;
+        }
+
+        public Container getContainer() {
+            return this.container;
+        }
+
+        public String getName() {
+            return this.name;
+        }
+
+        public String getValue() {
+            return this.value;
+        }
+
+        public void setValue(String value) {
+            this.value = value;
+        }
+    }
+
+    public static class Container {
+
+        private final Map<String, Component> map = new TreeMap<String, Component>();
+
+        public Collection<Component> getComponents() {
+            return new ArrayList<Component>(this.map.values());
+        }
+
+        public void setComponents(Collection<Component> components) {
+            this.map.clear();
+            for (Component component : components){
+                this.map.put(component.getName(), component);
+            }
+        }
+
+        public void add(String name, String value) {
+            Component list = new Component(this, name);
+            list.setValue(value);
+            this.map.put(name, list);
+        }
+    }
+}
--- jdk/test/java/io/File/GetXSpace.sh	2012-08-10 10:32:44.000000000 -0700
+++ jdk/test/java/io/File/GetXSpace.sh	2013-05-05 09:38:42.000000000 -0700
@@ -26,7 +26,7 @@
 # set platform-dependent variable
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux ) TMP=/tmp  ;;
+  SunOS | Linux | *BSD | Darwin ) TMP=/tmp  ;;
   Windows_98 )    return    ;;
   Windows* )      SID=`sid`; TMP="c:/temp"  ;;
   * )
--- jdk/test/java/io/FileInputStream/LargeFileAvailable.java	2012-08-10 10:32:45.000000000 -0700
+++ jdk/test/java/io/FileInputStream/LargeFileAvailable.java	2013-05-05 09:38:42.000000000 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 6402006
+ * @bug 6402006 7030573
  * @summary Test if available returns correct value when reading
  *          a large file.
  */
@@ -35,23 +35,35 @@
 import static java.nio.file.StandardOpenOption.*;
 
 public class LargeFileAvailable {
-    private static final long FILESIZE = 7405576182L;
     public static void main(String args[]) throws Exception {
-        File file = createLargeFile(FILESIZE);
+        // Create a temporary file in the current directory.
+        // Use it to check if we have 7G available for
+        // a large sparse file test. As a fallback use whatever
+        // space is available, so the test can proceed.
+        File file = File.createTempFile("largefile", null, new File("."));
+        long spaceavailable = file.getUsableSpace();
+        long filesize = Math.min(spaceavailable,  7405576182L);
+        if (spaceavailable == 0L) {
+            // A full disk is considered fatal.
+            throw new RuntimeException("No space available for temp file.");
+        }
+
+        createLargeFile(filesize, file);
+
         try (FileInputStream fis = new FileInputStream(file)) {
-            if (file.length() != FILESIZE) {
-                throw new RuntimeException("unexpected file size = " + file.length());
+            if (file.length() != filesize) {
+                throw new RuntimeException("unexpected file size = "
+                                           + file.length());
             }
 
-            long bigSkip = 3110608882L;
-            long remaining = FILESIZE;
+            long bigSkip = Math.min(filesize/2, 3110608882L);
+            long remaining = filesize;
             remaining -= skipBytes(fis, bigSkip, remaining);
             remaining -= skipBytes(fis, 10L, remaining);
             remaining -= skipBytes(fis, bigSkip, remaining);
             if (fis.available() != (int) remaining) {
-                 throw new RuntimeException("available() returns " +
-                     fis.available() +
-                     " but expected " + remaining);
+                 throw new RuntimeException("available() returns "
+                     + fis.available() + " but expected " + remaining);
             }
         } finally {
             file.delete();
@@ -64,39 +76,41 @@
             throws IOException {
         long skip = is.skip(toSkip);
         if (skip != toSkip) {
-            throw new RuntimeException("skip() returns " + skip +
-                " but expected " + toSkip);
+            throw new RuntimeException("skip() returns " + skip
+                + " but expected " + toSkip);
         }
         long remaining = avail - skip;
         int expected = remaining >= Integer.MAX_VALUE
                            ? Integer.MAX_VALUE
                            : (int) remaining;
 
-        System.out.println("Skipped " + skip + " bytes " +
-            " available() returns " + expected +
+        System.out.println("Skipped " + skip + " bytes "
+            + " available() returns " + expected +
             " remaining=" + remaining);
         if (is.available() != expected) {
-            throw new RuntimeException("available() returns " +
-                is.available() + " but expected " + expected);
+            throw new RuntimeException("available() returns "
+                + is.available() + " but expected " + expected);
         }
         return skip;
     }
 
-    private static File createLargeFile(long filesize) throws Exception {
-        // Create a large file as a sparse file if possible
-        File largefile = File.createTempFile("largefile", null);
-        // re-create as a sparse file
-        Files.delete(largefile.toPath());
+    private static void createLargeFile(long filesize,
+                                        File file) throws Exception {
+        // Recreate a large file as a sparse file if possible
+        Files.delete(file.toPath());
+
         try (FileChannel fc =
-                FileChannel.open(largefile.toPath(),
-                                 CREATE_NEW, WRITE, SPARSE)) {
+             FileChannel.open(file.toPath(),
+                              CREATE_NEW, WRITE, SPARSE)) {
             ByteBuffer bb = ByteBuffer.allocate(1).put((byte)1);
             bb.rewind();
-            int rc = fc.write(bb, filesize-1);
+            int rc = fc.write(bb, filesize - 1);
+
             if (rc != 1) {
-                throw new RuntimeException("Failed to write 1 byte to the large file");
+                throw new RuntimeException("Failed to write 1 byte"
+                                           + " to the large file");
             }
         }
-        return largefile;
+        return;
     }
 }
--- jdk/test/java/io/FileOutputStream/ManyFiles.java	2012-08-10 10:32:46.000000000 -0700
+++ jdk/test/java/io/FileOutputStream/ManyFiles.java	2013-05-05 09:38:42.000000000 -0700
@@ -43,7 +43,7 @@
         // Windows capability it is much simpler to only run it
         // on that platform.
         String osName = System.getProperty("os.name");
-        if (osName.startsWith("Linux")||osName.startsWith("SunOS"))
+        if (osName.startsWith("Linux")||osName.startsWith("SunOS")||osName.endsWith("BSD")||osName.contains("OS X"))
             return;
 
         for (int n = 0; n < NUM_FILES; n++) {
--- jdk/test/java/io/Serializable/evolution/RenamePackage/run.sh	2012-08-10 10:33:10.000000000 -0700
+++ jdk/test/java/io/Serializable/evolution/RenamePackage/run.sh	2013-05-05 09:38:42.000000000 -0700
@@ -41,7 +41,7 @@
 # Need to determine the classpath separator and filepath separator based on the
 # operating system.
 case "$OS" in
-SunOS | Linux | Darwin )
+SunOS | Linux | *BSD | Darwin )
   PS=":"  ;;
 Windows* | CYGWIN* )
   PS=";"  ;;
--- jdk/test/java/io/Serializable/resolveClass/deserializeButton/Foo.java	2012-08-10 10:33:29.000000000 -0700
+++ jdk/test/java/io/Serializable/resolveClass/deserializeButton/Foo.java	2013-05-05 09:38:42.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,27 +26,26 @@
  * @summary Verify that class loaded outside of application class loader is
  *          correctly resolved during deserialization when read in by custom
  *          readObject() method of a bootstrap class (in this case,
- *          java.awt.Button).
+ *          java.util.Vector).
  */
 
-import java.awt.Button;
-import java.awt.event.MouseAdapter;
 import java.io.*;
+import java.util.Vector;
 
 public class Foo implements Runnable {
 
-    static class Adapter extends MouseAdapter implements Serializable {}
+    static class TestElement extends Object implements Serializable {}
 
     public void run() {
         try {
-            Button button = new Button();
-            button.addMouseListener(new Adapter());
+            Vector<TestElement> container = new Vector<TestElement>();
+            container.add(new TestElement());
 
             // iterate to trigger java.lang.reflect code generation
             for (int i = 0; i < 100; i++) {
                 ByteArrayOutputStream bout = new ByteArrayOutputStream();
                 ObjectOutputStream oout = new ObjectOutputStream(bout);
-                oout.writeObject(button);
+                oout.writeObject(container);
                 oout.close();
                 ObjectInputStream oin = new ObjectInputStream(
                     new ByteArrayInputStream(bout.toByteArray()));
@@ -54,7 +53,7 @@
             }
         } catch (Exception ex) {
             throw new Error(
-                "Error occured while (de)serializing Button: " + ex);
+                "Error occured while (de)serializing container: ", ex);
         }
     }
 }
--- jdk/test/java/io/Serializable/resolveClass/deserializeButton/Test.java	2012-08-10 10:33:29.000000000 -0700
+++ jdk/test/java/io/Serializable/resolveClass/deserializeButton/Test.java	2013-05-05 09:38:42.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,7 @@
  * @summary Verify that class loaded outside of application class loader is
  *          correctly resolved during deserialization when read in by custom
  *          readObject() method of a bootstrap class (in this case,
- *          java.awt.Button).
+ *          java.util.Vector).
  */
 
 import java.io.*;
--- jdk/test/java/io/Serializable/resolveClass/deserializeButton/run.sh	2012-08-10 10:33:30.000000000 -0700
+++ jdk/test/java/io/Serializable/resolveClass/deserializeButton/run.sh	2013-05-05 09:38:42.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,7 @@
 # @summary Verify that class loaded outside of application class loader is
 #          correctly resolved during deserialization when read in by custom
 #          readObject() method of a bootstrap class (in this case,
-#          java.awt.Button).
+#          java.util.Vector).
 
 if [ "${TESTJAVA}" = "" ]
 then
--- jdk/test/java/io/Serializable/serialver/classpath/run.sh	2012-08-10 10:33:31.000000000 -0700
+++ jdk/test/java/io/Serializable/serialver/classpath/run.sh	2013-05-05 09:38:42.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"    ;;
   Windows* | CYGWIN* )
     PS=";"    ;;
--- jdk/test/java/io/Serializable/serialver/nested/run.sh	2012-08-10 10:33:31.000000000 -0700
+++ jdk/test/java/io/Serializable/serialver/nested/run.sh	2013-05-05 09:38:42.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"    ;;
   Windows* | CYGWIN* )
     PS=";"    ;;
--- jdk/test/java/lang/ClassLoader/deadlock/TestCrossDelegate.sh	2012-08-10 10:34:02.000000000 -0700
+++ jdk/test/java/lang/ClassLoader/deadlock/TestCrossDelegate.sh	2013-05-05 09:38:42.000000000 -0700
@@ -45,13 +45,7 @@
 # set platform-specific variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    ;;
-  Linux )
-    FS="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   Windows*)
--- jdk/test/java/lang/ClassLoader/deadlock/TestOneWayDelegate.sh	2012-08-10 10:34:02.000000000 -0700
+++ jdk/test/java/lang/ClassLoader/deadlock/TestOneWayDelegate.sh	2013-05-05 09:38:42.000000000 -0700
@@ -49,13 +49,7 @@
 # set platform-specific variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    ;;
-  Linux )
-    FS="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   Windows* | CYGWIN* )
--- jdk/test/java/lang/ProcessBuilder/Basic.java	2012-08-10 10:34:03.000000000 -0700
+++ jdk/test/java/lang/ProcessBuilder/Basic.java	2013-05-05 09:38:42.000000000 -0700
@@ -36,9 +36,11 @@
 import static java.lang.ProcessBuilder.Redirect.*;
 
 import java.io.*;
+import java.lang.reflect.Field;
 import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.security.*;
+import sun.misc.Unsafe;
 import java.util.regex.Pattern;
 import java.util.regex.Matcher;
 import static java.lang.System.getenv;
@@ -1908,17 +1910,21 @@
                 final byte[] bytes = new byte[10];
                 final Process p = new ProcessBuilder(childArgs).start();
                 final CountDownLatch latch = new CountDownLatch(1);
+                final InputStream s;
+                switch (action & 0x1) {
+                    case 0: s = p.getInputStream(); break;
+                    case 1: s = p.getErrorStream(); break;
+                    default: throw new Error();
+                }
                 final Thread thread = new Thread() {
                     public void run() {
                         try {
-                            latch.countDown();
                             int r;
-                            switch (action) {
-                            case 0: r = p.getInputStream().read(); break;
-                            case 1: r = p.getErrorStream().read(); break;
-                            case 2: r = p.getInputStream().read(bytes); break;
-                            case 3: r = p.getErrorStream().read(bytes); break;
-                            default: throw new Error();
+                            latch.countDown();
+                            switch (action & 0x2) {
+                                case 0: r = s.read(); break;
+                                case 2: r = s.read(bytes); break;
+                                default: throw new Error();
                             }
                             equal(-1, r);
                         } catch (Throwable t) { unexpected(t); }}};
@@ -1926,6 +1932,40 @@
                 thread.start();
                 latch.await();
                 Thread.sleep(10);
+
+                String os = System.getProperty("os.name");
+                if (os.equalsIgnoreCase("Solaris") ||
+                    os.equalsIgnoreCase("SunOS"))
+                {
+                    final Object deferred;
+                    Class<?> c = s.getClass();
+                    if (c.getName().equals(
+                        "java.lang.UNIXProcess$DeferredCloseInputStream"))
+                    {
+                        deferred = s;
+                    } else {
+                        Field deferredField = p.getClass().
+                            getDeclaredField("stdout_inner_stream");
+                        deferredField.setAccessible(true);
+                        deferred = deferredField.get(p);
+                    }
+                    Field useCountField = deferred.getClass().
+                        getDeclaredField("useCount");
+                    useCountField.setAccessible(true);
+
+                    while (useCountField.getInt(deferred) <= 0) {
+                        Thread.yield();
+                    }
+                } else if (s instanceof BufferedInputStream) {
+                    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+                    f.setAccessible(true);
+                    Unsafe unsafe = (Unsafe)f.get(null);
+
+                    while (unsafe.tryMonitorEnter(s)) {
+                        unsafe.monitorExit(s);
+                        Thread.sleep(1);
+                    }
+                }
                 p.destroy();
                 thread.join();
             }
--- jdk/test/java/lang/Runtime/exec/StreamsSurviveDestroy.java	2012-08-10 10:34:04.000000000 -0700
+++ jdk/test/java/lang/Runtime/exec/StreamsSurviveDestroy.java	2013-05-05 09:38:42.000000000 -0700
@@ -28,6 +28,7 @@
  */
 
 import java.io.*;
+import java.util.concurrent.*;
 
 
 public class StreamsSurviveDestroy {
@@ -40,15 +41,17 @@
         boolean wantInterrupt;
         boolean acceptException;
         Exception exc = null;
+        CountDownLatch latch;
 
         Copier(String name, InputStream in, OutputStream out,
-               boolean ae, boolean wi)
+               boolean ae, boolean wi, CountDownLatch l)
         {
             this.name = name;
             this.in = in;
             this.out = out;
             this.acceptException = ae;
             this.wantInterrupt = wi;
+            this.latch = l;
             setName(name);
             start();
         }
@@ -59,6 +62,7 @@
 
         public void run() {
             byte[] buf = new byte[4242];
+            latch.countDown();
             for (;;) {
                 try {
                     int n = in.read(buf);
@@ -95,13 +99,17 @@
     }
 
     static void test() throws Exception {
+        CountDownLatch latch = new CountDownLatch(2);
+
         System.err.println("test");
         Process p = Runtime.getRuntime().exec("/bin/cat");
         Copier cp1 = new Copier("out", p.getInputStream(), System.err,
-                               false, false);
+                                false, false, latch);
         Copier cp2 = new Copier("err", p.getErrorStream(), System.err,
-                               false, false);
-        Thread.sleep(100);
+                                false, false, latch);
+        latch.await();    // Wait till both Copiers about to read
+        Thread.sleep(100);// Give both Copiers a chance to start read
+
         p.destroy();
         System.err.println("  exit: " + p.waitFor());
         cp1.join();
@@ -111,13 +119,17 @@
     }
 
     static void testCloseBeforeDestroy() throws Exception {
+        CountDownLatch latch = new CountDownLatch(2);
+
         System.err.println("testCloseBeforeDestroy");
         Process p = Runtime.getRuntime().exec("/bin/cat");
         Copier cp1 = new Copier("out", p.getInputStream(), System.err,
-                                true, false);
+                                true, false, latch);
         Copier cp2 = new Copier("err", p.getErrorStream(), System.err,
-                                true, false);
-        Thread.sleep(100);
+                                true, false, latch);
+        latch.await();    // Wait till both Copiers about to read
+        Thread.sleep(100);// Give both Copiers a chance to start read
+
         p.getInputStream().close();
         p.getErrorStream().close();
         p.destroy();
@@ -129,13 +141,17 @@
     }
 
     static void testCloseAfterDestroy() throws Exception {
+        CountDownLatch latch = new CountDownLatch(2);
         System.err.println("testCloseAfterDestroy");
         Process p = Runtime.getRuntime().exec("/bin/cat");
         Copier cp1 = new Copier("out", p.getInputStream(), System.err,
-                                true, false);
+                                true, false,latch);
         Copier cp2 = new Copier("err", p.getErrorStream(), System.err,
-                                true, false);
-        Thread.sleep(100);
+                                true, false, latch);
+
+        latch.await();    // Wait till both Copiers about to read
+        Thread.sleep(100);// Give both Copiers a chance to start read
+
         p.destroy();
         p.getInputStream().close();
         p.getErrorStream().close();
@@ -147,13 +163,16 @@
     }
 
     static void testInterrupt() throws Exception {
+        CountDownLatch latch = new CountDownLatch(2);
         System.err.println("testInterrupt");
         Process p = Runtime.getRuntime().exec("/bin/cat");
         Copier cp1 = new Copier("out", p.getInputStream(), System.err,
-                                false, true);
+                                false, true, latch);
         Copier cp2 = new Copier("err", p.getErrorStream(), System.err,
-                                false, true);
-        Thread.sleep(100);
+                                false, true, latch);
+        latch.await();    // Wait till both Copiers about to read
+        Thread.sleep(100);// Give both Copiers a chance to start read
+
         cp1.interrupt();
         cp2.interrupt();
         Thread.sleep(100);
@@ -176,7 +195,5 @@
         testCloseBeforeDestroy();
         testCloseAfterDestroy();
         testInterrupt();
-
     }
-
 }
--- jdk/test/java/lang/StringCoding/CheckEncodings.sh	2012-08-10 10:34:06.000000000 -0700
+++ jdk/test/java/lang/StringCoding/CheckEncodings.sh	2013-05-05 09:38:42.000000000 -0700
@@ -30,7 +30,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin) ;;
+  SunOS | Linux | *BSD | Darwin) ;;
   Windows* | CYGWIN* )
     echo "Passed"; exit 0 ;;
   * ) echo "Unrecognized system!" ;  exit 1 ;;
--- jdk/test/java/lang/ThreadGroup/NullThreadName.java	2012-08-10 10:34:06.000000000 -0700
+++ jdk/test/java/lang/ThreadGroup/NullThreadName.java	2013-05-05 09:38:42.000000000 -0700
@@ -24,7 +24,6 @@
 /*
  * @test
  * @bug 6576763
- * @ignore until hotspot 6776144 bug is resolved
  * @summary (thread) Thread constructors throw undocumented NPE for null name
  */
 
@@ -64,8 +63,8 @@
             try { Thread.sleep(2000); }
             catch (InterruptedException unused) {}
 
-            /* do not wait forever */
-            if (count++ > 5)
+            /* do not wait forever - allow 120 seconds same as jtreg default timeout. */
+            if (count++ > 60)
                 throw new AssertionError("GoodThread is still alive!");
         }
 
--- jdk/test/java/lang/ThreadGroup/Stop.java	2012-08-10 10:34:07.000000000 -0700
+++ jdk/test/java/lang/ThreadGroup/Stop.java	2013-05-05 09:38:42.000000000 -0700
@@ -29,37 +29,58 @@
  */
 
 public class Stop implements Runnable {
-    private static Thread first=null;
-    private static Thread second=null;
-    private static ThreadGroup group = new ThreadGroup("");
-
-    Stop() {
-        Thread thread = new Thread(group, this);
-        if (first == null)
-            first = thread;
-        else
-            second = thread;
+    private static boolean groupStopped = false ;
+    private static final Object lock = new Object();
 
-        thread.start();
-    }
+    private static final ThreadGroup group = new ThreadGroup("");
+    private static final Thread first = new Thread(group, new Stop());
+    private static final Thread second = new Thread(group, new Stop());
 
     public void run() {
         while (true) {
+            // Give the other thread a chance to start
             try {
-                Thread.sleep(1000); // Give other thread a chance to start
-                if (Thread.currentThread() == first)
-                    group.stop();
-            } catch(InterruptedException e){
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+            }
+
+            // When the first thread runs, it will stop the group.
+            if (Thread.currentThread() == first) {
+                synchronized (lock) {
+                    try {
+                        group.stop();
+                    } finally {
+                        // Signal the main thread it is time to check
+                        // that the stopped thread group was successful
+                        groupStopped = true;
+                        lock.notifyAll();
+                    }
+                }
             }
         }
     }
 
     public static void main(String[] args) throws Exception {
-        for (int i=0; i<2; i++)
-            new Stop();
-        Thread.sleep(3000);
+        // Launch two threads as part of the same thread group
+        first.start();
+        second.start();
+
+        // Wait for the thread group stop to be issued
+        synchronized(lock){
+            while (!groupStopped) {
+                lock.wait();
+                // Give the other thread a chance to stop
+                Thread.sleep(1000);
+            }
+        }
+
+        // Check that the second thread is terminated when the
+        // first thread terminates the thread group.
         boolean failed = second.isAlive();
-        first.stop(); second.stop();
+
+        // Clean up any threads that may have not been terminated
+        first.stop();
+        second.stop();
         if (failed)
             throw new RuntimeException("Failure.");
     }
--- jdk/test/java/lang/annotation/loaderLeak/LoaderLeak.sh	2012-08-10 10:34:07.000000000 -0700
+++ jdk/test/java/lang/annotation/loaderLeak/LoaderLeak.sh	2013-05-05 09:38:42.000000000 -0700
@@ -44,7 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin)
+  SunOS | Linux | *BSD | Darwin)
     NULL=/dev/null
     PS=":"
     FS="/"
--- jdk/test/java/lang/instrument/MakeJAR2.sh	2012-08-10 10:34:08.000000000 -0700
+++ jdk/test/java/lang/instrument/MakeJAR2.sh	2013-05-05 09:38:42.000000000 -0700
@@ -49,7 +49,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- jdk/test/java/lang/instrument/ManifestTest.sh	2012-08-10 10:34:08.000000000 -0700
+++ jdk/test/java/lang/instrument/ManifestTest.sh	2013-05-05 09:38:42.000000000 -0700
@@ -26,7 +26,7 @@
 # @summary JLI JAR manifest processing should ignore leading and trailing white space.
 # @author Daniel D. Daugherty
 #
-# @run build ManifestTestApp
+# @run build ManifestTestApp ExampleForBootClassPath
 # @run shell/timeout=900 ManifestTest.sh
 #
 
@@ -42,6 +42,9 @@
     expect_retrans_line="isRetransformClassesSupported()=false"
     can_set_nmp_line=""
     expect_set_nmp_line="isNativeMethodPrefixSupported()=false"
+    # some tests create directories with spaces in their name,
+    # explicitly delete these.
+    to_be_deleted=""
 
     while [ $# != 0 ] ; do
         case "$1" in
@@ -59,30 +62,33 @@
         boot_cp_line2)
             boot_cp_line="Boot-Class-Path:  has_leading_blank"
             expect_boot_cp_line="ExampleForBootClassPath was loaded."
+            to_be_deleted=" has_leading_blank"
             mkdir -p has_leading_blank " has_leading_blank"
             # the good class is in the directory without the blank
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class \
                 has_leading_blank
             # the bad class is in the directory with the blank
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class.bad \
-                " has_leading_blank"/ExampleForBootClassPath.class
+                " has_leading_blank/ExampleForBootClassPath.class"
             ;;
 
         boot_cp_line3)
             boot_cp_line="Boot-Class-Path: has_trailing_blank "
             expect_boot_cp_line="ExampleForBootClassPath was loaded."
+            to_be_deleted="has_trailing_blank "
             mkdir -p has_trailing_blank "has_trailing_blank "
             # the good class is in the directory without the blank
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class \
                 has_trailing_blank
             # the bad class is in the directory with the blank
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class.bad \
-                "has_trailing_blank "/ExampleForBootClassPath.class
+                "has_trailing_blank /ExampleForBootClassPath.class"
             ;;
 
         boot_cp_line4)
             boot_cp_line="Boot-Class-Path:  has_leading_and_trailing_blank "
             expect_boot_cp_line="ExampleForBootClassPath was loaded."
+            to_be_deleted=" has_leading_and_trailing_blank "
             mkdir -p has_leading_and_trailing_blank \
                 " has_leading_and_trailing_blank "
             # the good class is in the directory without the blanks
@@ -90,18 +96,19 @@
                 has_leading_and_trailing_blank
             # the bad class is in the directory with the blanks
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class.bad \
-                " has_leading_and_trailing_blank "/ExampleForBootClassPath.class
+                " has_leading_and_trailing_blank /ExampleForBootClassPath.class"
             ;;
 
         boot_cp_line5)
             boot_cp_line="Boot-Class-Path: has_embedded blank"
             expect_boot_cp_line="ExampleForBootClassPath was loaded."
+            to_be_deleted="has_embedded blank"
             mkdir -p has_embedded "has_embedded blank"
             # the good class is in the first blank separated word
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class has_embedded
             # the bad class is in the directory with the blank
             cp -p $OUT_OF_THE_WAY/ExampleForBootClassPath.class.bad \
-                "has_embedded blank"/ExampleForBootClassPath.class
+                "has_embedded blank/ExampleForBootClassPath.class"
             ;;
 
         can_redef_line1)
@@ -429,6 +436,12 @@
         touch $FAIL_MARKER
     fi
 
+    #clean up any problematic directories
+    if [ -n "$to_be_deleted" ]; then
+        echo "Test removing [$to_be_deleted]"
+        rm -rf "$to_be_deleted"
+    fi
+
     echo "===== end test case: $token ====="
     echo
 done << EOF
--- jdk/test/java/lang/instrument/appendToClassLoaderSearch/CommonSetup.sh	2012-08-10 10:34:11.000000000 -0700
+++ jdk/test/java/lang/instrument/appendToClassLoaderSearch/CommonSetup.sh	2013-05-05 09:38:42.000000000 -0700
@@ -35,15 +35,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
-    PS=":"
-    FS="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/lang/invoke/InvokeGenericTest.java	2012-08-10 10:34:11.000000000 -0700
+++ jdk/test/java/lang/invoke/InvokeGenericTest.java	2013-05-05 09:38:42.000000000 -0700
@@ -25,7 +25,7 @@
 
 /* @test
  * @summary unit tests for java.lang.invoke.MethodHandle.invoke
- * @compile -target 7 InvokeGenericTest.java
+ * @compile InvokeGenericTest.java
  * @run junit/othervm test.java.lang.invoke.InvokeGenericTest
  */
 
--- jdk/test/java/lang/management/OperatingSystemMXBean/TestSystemLoadAvg.sh	2012-08-10 10:34:13.000000000 -0700
+++ jdk/test/java/lang/management/OperatingSystemMXBean/TestSystemLoadAvg.sh	2013-05-05 09:38:42.000000000 -0700
@@ -61,7 +61,7 @@
 while true; do
   echo "Run $i: TestSystemLoadAvg"
   case `uname -s` in
-       SunOS | Linux | Darwin )
+       SunOS | Linux | *BSD | Darwin )
          runOne GetSystemLoadAverage
          ;;
       * )
--- jdk/test/java/net/Authenticator/B4933582.sh	2012-08-10 10:34:17.000000000 -0700
+++ jdk/test/java/net/Authenticator/B4933582.sh	2013-05-05 09:38:41.000000000 -0700
@@ -26,7 +26,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/net/BindException/Test.java	2012-08-10 10:34:17.000000000 -0700
+++ jdk/test/java/net/BindException/Test.java	2013-05-05 09:38:41.000000000 -0700
@@ -46,7 +46,7 @@
     static int failures;
 
     static void doTest(Object test[], InetAddress ia1, InetAddress ia2,
-                       boolean silent) {
+                       boolean silent) throws Exception {
         String s1_type = (String)test[0];
         String s2_type = (String)test[1];
         int port = 0;
@@ -64,11 +64,10 @@
         boolean failed = false;
         Exception failed_exc = null;
 
+        Socket sock1 = null;
+        ServerSocket ss = null;
+        DatagramSocket dsock1 = null;
         try {
-            Socket sock1, sock2;
-            ServerSocket ss;
-            DatagramSocket dsock1, dsock2;
-
             /* bind the first socket */
 
             if (s1_type.equals("Socket")) {
@@ -90,16 +89,18 @@
             /* bind the second socket */
 
             if (s2_type.equals("Socket")) {
-                sock2 = new Socket();
-                sock2.bind( new InetSocketAddress(ia2, port));
+                try (Socket sock2 = new Socket()) {
+                    sock2.bind( new InetSocketAddress(ia2, port));
+                }
             }
 
             if (s2_type.equals("ServerSocket")) {
-                ss = new ServerSocket(port, 0, ia2);
+                try (ServerSocket ss2 = new ServerSocket(port, 0, ia2)) { }
             }
 
             if (s2_type.equals("DatagramSocket")) {
-                dsock2 = new DatagramSocket( new InetSocketAddress(ia2, port) );
+                try (DatagramSocket ds =
+                        new DatagramSocket(new InetSocketAddress(ia2, port))) { }
             }
 
         } catch (BindException be) {
@@ -107,6 +108,10 @@
         } catch (Exception e) {
             failed = true;
             failed_exc = e;
+        } finally {
+            if (sock1 != null) sock1.close();
+            if (ss != null) ss.close();
+            if (dsock1 != null) dsock1.close();
         }
 
         /*
--- jdk/test/java/net/CookieHandler/NullUriCookieTest.java	2012-08-10 10:34:18.000000000 -0700
+++ jdk/test/java/net/CookieHandler/NullUriCookieTest.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 6953455
- * @summary CookieStore.add() cannot handle null URI parameter
- */
-
-import java.net.CookieManager;
-import java.net.CookieStore;
-import java.net.HttpCookie;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.List;
-
-public class NullUriCookieTest {
-    static boolean fail = false;
-
-    public static void main(String[] args) throws Exception {
-        checkCookieNullUri();
-    }
-
-    static void checkCookieNullUri() throws Exception {
-        //get a cookie store implementation and add a cookie to the store with null URI
-        CookieStore cookieStore = (new CookieManager()).getCookieStore();
-        HttpCookie cookie = new HttpCookie("MY_COOKIE", "MY_COOKIE_VALUE");
-        cookie.setDomain("foo.com");
-        cookieStore.add(null, cookie);
-
-        //Retrieve added cookie
-        URI uri = new URI("http://foo.com");
-        List<HttpCookie> addedCookieList = cookieStore.get(uri);
-
-        //Verify CookieStore behaves well
-        if (addedCookieList.size() != 1) {
-           fail = true;
-        }
-        checkFail("Abnormal size of cookie jar");
-
-        for (HttpCookie chip : addedCookieList) {
-            if (!chip.equals(cookie)) {
-                 fail = true;
-            }
-        }
-        checkFail("Cookie not retrieved from Cookie Jar");
-        boolean ret = cookieStore.remove(null,cookie);
-        if (!ret) {
-            fail = true;
-        }
-        checkFail("Abnormal removal behaviour from Cookie Jar");
-    }
-
-    static void checkFail(String exp) {
-        if (fail) {
-            throw new RuntimeException(exp);
-        }
-    }
-}
-
--- jdk/test/java/net/DatagramSocket/SendDatagramToBadAddress.java	2012-08-10 10:34:18.000000000 -0700
+++ jdk/test/java/net/DatagramSocket/SendDatagramToBadAddress.java	2013-05-05 09:38:41.000000000 -0700
@@ -45,6 +45,8 @@
             return (true);
         if (p.getProperty ("os.name").equals ("Linux"))
             return (true);
+        if (p.getProperty ("os.name").endsWith ("BSD"))
+            return (true);
         if (p.getProperty ("os.name").startsWith ("Mac OS"))
             return (true);
         // Check for specific Solaris version from here
--- jdk/test/java/net/DatagramSocket/SetDatagramSocketImplFactory/ADatagramSocket.sh	2012-08-10 10:34:18.000000000 -0700
+++ jdk/test/java/net/DatagramSocket/SetDatagramSocketImplFactory/ADatagramSocket.sh	2013-05-05 09:38:41.000000000 -0700
@@ -27,11 +27,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Darwin )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/java/net/InetAddress/GetLocalHostWithSM.java	2012-08-10 10:34:19.000000000 -0700
+++ jdk/test/java/net/InetAddress/GetLocalHostWithSM.java	2013-05-05 09:38:41.000000000 -0700
@@ -41,14 +41,13 @@
         public static void main(String[] args) throws Exception {
 
             // try setting the local hostname
-            try {
-                System.setProperty("host.name", InetAddress.
-                                                getLocalHost().
-                                                getHostName());
-            } catch (UnknownHostException e) {
-                System.out.println("Cannot find the local hostname, " +
-                        "no nameserver entry found");
+            InetAddress localHost = InetAddress.getLocalHost();
+            if (localHost.isLoopbackAddress()) {
+                System.err.println("Local host name is resolved into a loopback address. Quit now!");
+                return;
             }
+            System.setProperty("host.name", localHost.
+                                            getHostName());
             String policyFileName = System.getProperty("test.src", ".") +
                           "/" + "policy.file";
             System.setProperty("java.security.policy", policyFileName);
@@ -66,6 +65,7 @@
                                 new MyAction(), null);
 
             if (localHost1.equals(localHost2)) {
+                System.out.println("localHost1 = " + localHost1);
                 throw new RuntimeException("InetAddress.getLocalHost() test " +
                                            " fails. localHost2 should be " +
                                            " the real address instead of " +
--- jdk/test/java/net/ResponseCache/Test.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/net/ResponseCache/Test.java	2013-05-05 09:38:41.000000000 -0700
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @summary Fixed a potential NullPointerException when setting a ResponseCache that returns a null CacheRequest
+ * @bug 4837267
+ * @author Michael McMahon
+ */
+
+import com.sun.net.httpserver.*;
+import java.net.*;
+import java.io.*;
+import java.util.*;
+
+public class Test
+{
+
+    static class MyHandler implements HttpHandler {
+        public void handle(HttpExchange t) throws IOException {
+            byte[] b = new byte[1024];
+            int r = 0;
+            InputStream is = t.getRequestBody();
+            while (is.read(b) != -1) ;
+            String response = "This is the response";
+            t.sendResponseHeaders(200, response.length());
+            OutputStream os = t.getResponseBody();
+            os.write(response.getBytes());
+            os.close();
+        }
+    }
+
+    public static void main(String args[])  throws Exception {
+        HttpServer server = HttpServer.create(new InetSocketAddress(0), 0);
+        server.createContext("/", new MyHandler());
+        server.start();
+        ResponseCache bak = ResponseCache.getDefault();
+
+        try {
+            ResponseCache.setDefault (new ResponseCache() {
+                public CacheResponse get (URI uri, String rqstMethod, Map<String,List<String>> rqstHeaders)
+                    throws IOException {
+                    return null;
+                }
+                public CacheRequest put(URI uri, URLConnection conn)  throws IOException
+                {
+                    return null;
+                }
+            });
+
+            URL url = new URL ("http://localhost:" + server.getAddress().getPort() + "/");
+            URLConnection urlc = url.openConnection ();
+            InputStream is = urlc.getInputStream();
+            while (is.read() != -1) ;
+            is.close();
+        } finally {
+            ResponseCache.setDefault(bak);
+            server.stop(0);
+        }
+    }
+}
--- jdk/test/java/net/Socket/B6210227.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/net/Socket/B6210227.java	2013-05-05 09:38:41.000000000 -0700
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 6210227
+ * @summary  REGRESSION: Socket.getLocalAddress() returns address of 0.0.0.0 on outbound TCP
+ */
+
+import java.util.*;
+import java.net.*;
+
+public class B6210227 {
+    public static void main(String[] args) throws Exception
+    {
+        ServerSocket ss = new ServerSocket(0);
+        int port = ss.getLocalPort();
+
+        byte[] bad = {0,0,0,0};
+        try {
+            InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), port);
+            Socket s = new Socket();
+            s.connect( isa, 1000 );
+            InetAddress iaLocal = s.getLocalAddress(); // if this comes back as 0.0. 0.0 this would demonstrate issue
+            String      sLocalHostname = iaLocal.getHostName();
+            if (Arrays.equals (iaLocal.getAddress(), bad)) {
+                throw new RuntimeException ("0.0.0.0 returned");
+            }
+            System.out.println("local hostname is "+sLocalHostname );
+        } catch(Exception e) {
+            System.out.println("Exception happened");
+            throw e;
+        } finally {
+            ss.close();
+        }
+    }
+}
+
--- jdk/test/java/net/Socket/OldSocketImpl.sh	2012-08-10 10:34:21.000000000 -0700
+++ jdk/test/java/net/Socket/OldSocketImpl.sh	2013-05-05 09:38:41.000000000 -0700
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/net/Socks/SocksServer.java	2012-08-10 10:34:22.000000000 -0700
+++ jdk/test/java/net/Socks/SocksServer.java	2013-05-05 09:38:41.000000000 -0700
@@ -22,13 +22,14 @@
  */
 import java.net.*;
 import java.io.*;
+import java.util.HashMap;
 
 public class SocksServer extends Thread {
     // Some useful SOCKS constant
 
-    static final int PROTO_VERS4                = 4;
+    static final int PROTO_VERS4        = 4;
     static final int PROTO_VERS         = 5;
-    static final int DEFAULT_PORT               = 1080;
+    static final int DEFAULT_PORT       = 1080;
 
     static final int NO_AUTH            = 0;
     static final int GSSAPI             = 1;
@@ -36,28 +37,28 @@
     static final int NO_METHODS         = -1;
 
     static final int CONNECT            = 1;
-    static final int BIND                       = 2;
+    static final int BIND               = 2;
     static final int UDP_ASSOC          = 3;
 
-    static final int IPV4                       = 1;
-    static final int DOMAIN_NAME                = 3;
-    static final int IPV6                       = 4;
+    static final int IPV4               = 1;
+    static final int DOMAIN_NAME        = 3;
+    static final int IPV6               = 4;
 
     static final int REQUEST_OK         = 0;
     static final int GENERAL_FAILURE    = 1;
-    static final int NOT_ALLOWED                = 2;
+    static final int NOT_ALLOWED        = 2;
     static final int NET_UNREACHABLE    = 3;
     static final int HOST_UNREACHABLE   = 4;
-    static final int CONN_REFUSED               = 5;
-    static final int TTL_EXPIRED                = 6;
+    static final int CONN_REFUSED       = 5;
+    static final int TTL_EXPIRED        = 6;
     static final int CMD_NOT_SUPPORTED  = 7;
     static final int ADDR_TYPE_NOT_SUP  = 8;
 
     private int port;
     private ServerSocket server;
     private boolean useV4 = false;
-    private java.util.Hashtable users = new java.util.Hashtable();
-    private boolean done = false;
+    private HashMap<String,String> users = new HashMap<>();
+    private volatile boolean done = false;
     // Inner class to handle protocol with client
     // This is the bulk of the work (protocol handler)
     class ClientHandler extends Thread {
@@ -136,7 +137,7 @@
             System.err.println("User: '" + uname);
             System.err.println("PSWD: '" + password);
             if (users.containsKey(uname)) {
-                String p1 = (String) users.get(uname);
+                String p1 = users.get(uname);
                 System.err.println("p1 = " + p1);
                 if (p1.equals(password)) {
                     out.write(PROTO_VERS);
@@ -492,7 +493,12 @@
     public SocksServer(int port) throws IOException {
         this.port = port;
         server = new ServerSocket();
-        server.bind(new InetSocketAddress(port));
+        if (port == 0) {
+            server.bind(null);
+            this.port = server.getLocalPort();
+        } else {
+            server.bind(new InetSocketAddress(port));
+        }
     }
 
     public SocksServer() throws IOException {
@@ -503,8 +509,13 @@
         users.put(user, passwd);
     }
 
-    public synchronized void terminate() {
+    public int getPort() {
+        return port;
+    }
+
+    public void terminate() {
         done = true;
+        try { server.close(); } catch (IOException unused) {}
     }
 
     public void run() {
--- jdk/test/java/net/Socks/SocksV4Test.java	2012-08-10 10:34:22.000000000 -0700
+++ jdk/test/java/net/Socks/SocksV4Test.java	2013-05-05 09:38:41.000000000 -0700
@@ -26,23 +26,29 @@
  * @bug 4727547
  * @summary SocksSocketImpl throws NullPointerException
  * @build SocksServer
+ * @run main SocksV4Test
  */
 
 import java.net.*;
-import java.io.*;
 
 public class SocksV4Test {
-    public static void main(String[] args) throws IOException {
-        // Create a SOCKS V4 proxy on port 8888
-        SocksServer srvr = new SocksServer(8888, true);
+
+    // An unresolvable host
+    static final String HOSTNAME = "doesnot.exist.invalid";
+
+    public static void main(String[] args) throws Exception {
+        // sanity before running the test
+        assertUnresolvableHost(HOSTNAME);
+
+        // Create a SOCKS V4 proxy
+        SocksServer srvr = new SocksServer(0, true);
         srvr.start();
-        System.setProperty("socksProxyHost", "localhost");
-        System.setProperty("socksProxyPort", "8888");
+        Proxy sp = new Proxy(Proxy.Type.SOCKS,
+                             new InetSocketAddress("localhost", srvr.getPort()));
         // Let's create an unresolved address
-        InetSocketAddress ad = new InetSocketAddress("doesnt.exist.name", 1234);
-        Socket s = new Socket();
-        try {
-            s.connect(ad,10000);
+        InetSocketAddress ad = new InetSocketAddress(HOSTNAME, 1234);
+        try (Socket s = new Socket(sp)) {
+            s.connect(ad, 10000);
         } catch (UnknownHostException ex) {
             // OK, that's what we expected
         } catch (NullPointerException npe) {
@@ -50,7 +56,17 @@
             throw new RuntimeException("Got a NUllPointerException");
         } finally {
             srvr.terminate();
-            srvr.interrupt();
         }
     }
+
+    static void assertUnresolvableHost(String host) {
+        InetAddress addr = null;
+        try {
+            addr = InetAddress.getByName(host);
+        } catch (UnknownHostException x) {
+            // OK, expected
+        }
+        if (addr != null)
+            throw new RuntimeException("Test cannot run. resolvable address:" + addr);
+    }
 }
--- jdk/test/java/net/URL/B5086147.sh	2012-08-10 10:34:22.000000000 -0700
+++ jdk/test/java/net/URL/B5086147.sh	2013-05-05 09:38:41.000000000 -0700
@@ -26,7 +26,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     exit 0
     ;;
   CYGWIN* )
--- jdk/test/java/net/URL/Gopher.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/net/URL/Gopher.java	2013-05-05 09:38:41.000000000 -0700
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7189567
+ * @summary java net obselete protocol
+ * @run main Gopher
+ * @run main/othervm -Djdk.net.registerGopherProtocol Gopher enabled
+ * @run main/othervm -Djdk.net.registerGopherProtocol=false Gopher
+ */
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+public class Gopher {
+    static final String GOPHER_PROP = "jdk.net.registerGopherProtocol";
+
+    public static void main(String[] args) throws Exception {
+        boolean expectEnabled = false;
+        if (args.length >= 1 && args[0].equals("enabled"))
+            expectEnabled = true;
+
+        String prop = System.getProperty(GOPHER_PROP);
+        boolean gopherEnabled = prop == null ? false :
+                                   (prop.equalsIgnoreCase("false") ? false : true);
+
+        // Validate system property reading
+        if (expectEnabled && !gopherEnabled) {
+            System.err.println(GOPHER_PROP + ": " + gopherEnabled);
+            throw new RuntimeException(
+                    "Failed: expected system property to be enabled, but it is not");
+        }
+        if (!expectEnabled && gopherEnabled) {
+            System.err.println(GOPHER_PROP + ": " + gopherEnabled);
+            throw new RuntimeException(
+                    "Failed: expected system property to be disabled, but it is not");
+        }
+
+        try {
+            new URL("gopher://anyhost:70/[anydata]");
+            if (!gopherEnabled) {
+                System.err.println(GOPHER_PROP + ": " + gopherEnabled);
+                throw new RuntimeException("Failed: gopher should NOT be enabled");
+            }
+        } catch (MalformedURLException x) {
+            if (gopherEnabled) {
+                System.err.println(GOPHER_PROP + ": " + gopherEnabled);
+                x.printStackTrace();
+                throw new RuntimeException("Failed: gopher should be enabled");
+            }
+        }
+    }
+}
--- jdk/test/java/net/URL/Test.java	2012-08-10 10:34:23.000000000 -0700
+++ jdk/test/java/net/URL/Test.java	2013-05-05 09:38:41.000000000 -0700
@@ -322,10 +322,6 @@
         test("ftp://ftp.is.co.za/rfc/rfc1808.txt")
             .s("ftp").h("ftp.is.co.za").p("/rfc/rfc1808.txt").z();
 
-        test("gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles")
-            .s("gopher").h("spinaltap.micro.umn.edu")
-            .p("/00/Weather/California/Los%20Angeles").z();
-
         test("http://www.math.uio.no/faq/compression-faq/part1.html")
             .s("http").h("www.math.uio.no").p("/faq/compression-faq/part1.html").z();
 
--- jdk/test/java/net/URL/runconstructor.sh	2012-08-10 10:34:23.000000000 -0700
+++ jdk/test/java/net/URL/runconstructor.sh	2013-05-05 09:38:41.000000000 -0700
@@ -27,7 +27,7 @@
 #
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/net/URLClassLoader/B5077773.sh	2012-08-10 10:34:23.000000000 -0700
+++ jdk/test/java/net/URLClassLoader/B5077773.sh	2013-05-05 09:38:41.000000000 -0700
@@ -34,11 +34,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Darwin )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/net/URLClassLoader/sealing/checksealed.sh	2012-08-10 10:34:25.000000000 -0700
+++ jdk/test/java/net/URLClassLoader/sealing/checksealed.sh	2013-05-05 09:38:41.000000000 -0700
@@ -27,11 +27,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Darwin )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/net/URLConnection/6212146/test.sh	2012-08-10 10:34:25.000000000 -0700
+++ jdk/test/java/net/URLConnection/6212146/test.sh	2013-05-05 09:38:41.000000000 -0700
@@ -33,11 +33,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Darwin )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/net/ipv6tests/B6521014.java	2012-08-10 10:34:25.000000000 -0700
+++ jdk/test/java/net/ipv6tests/B6521014.java	2013-05-05 09:38:41.000000000 -0700
@@ -95,14 +95,12 @@
         Socket sock;
         ServerSocket ssock;
         int port;
-        int localport;
 
         ssock = new ServerSocket(0);
         ssock.setSoTimeout(100);
         port = ssock.getLocalPort();
-        localport = port + 1;
         sock = new Socket();
-        sock.bind(new InetSocketAddress(sin, localport));
+        sock.bind(new InetSocketAddress(sin, 0));
         try {
             sock.connect(new InetSocketAddress(sin, port), 100);
         } catch (SocketTimeoutException e) {
--- jdk/test/java/nio/channels/AsynchronousSocketChannel/Basic.java	2012-08-10 10:34:28.000000000 -0700
+++ jdk/test/java/nio/channels/AsynchronousSocketChannel/Basic.java	2013-05-05 09:38:43.000000000 -0700
@@ -24,7 +24,7 @@
 /* @test
  * @bug 4607272 6842687 6878369 6944810 7023403
  * @summary Unit test for AsynchronousSocketChannel
- * @run main/timeout=600 Basic
+ * @run main Basic -skipSlowConnectTest
  */
 
 import java.nio.ByteBuffer;
@@ -34,12 +34,25 @@
 import java.util.Random;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
+import java.io.Closeable;
 import java.io.IOException;
 
 public class Basic {
     static final Random rand = new Random();
 
+    static boolean skipSlowConnectTest = false;
+
     public static void main(String[] args) throws Exception {
+        for (String arg: args) {
+            switch (arg) {
+            case "-skipSlowConnectTest" :
+                skipSlowConnectTest = true;
+                break;
+            default:
+                throw new RuntimeException("Unrecognized argument: " + arg);
+            }
+        }
+
         testBind();
         testSocketOptions();
         testConnect();
@@ -54,7 +67,7 @@
         testShutdown();
     }
 
-    static class Server {
+    static class Server implements Closeable {
         private final ServerSocketChannel ssc;
         private final InetSocketAddress address;
 
@@ -74,10 +87,8 @@
             return ssc.accept();
         }
 
-        void close() {
-            try {
-                ssc.close();
-            } catch (IOException ignore) { }
+        public void close() throws IOException {
+            ssc.close();
         }
 
     }
@@ -85,28 +96,28 @@
     static void testBind() throws Exception {
         System.out.println("-- bind --");
 
-        AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        if (ch.getLocalAddress() != null)
-            throw new RuntimeException("Local address should be 'null'");
-        ch.bind(new InetSocketAddress(0));
-
-        // check local address after binding
-        InetSocketAddress local = (InetSocketAddress)ch.getLocalAddress();
-        if (local.getPort() == 0)
-            throw new RuntimeException("Unexpected port");
-        if (!local.getAddress().isAnyLocalAddress())
-            throw new RuntimeException("Not bound to a wildcard address");
-
-        // try to re-bind
-        try {
+        try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
+            if (ch.getLocalAddress() != null)
+                throw new RuntimeException("Local address should be 'null'");
             ch.bind(new InetSocketAddress(0));
-            throw new RuntimeException("AlreadyBoundException expected");
-        } catch (AlreadyBoundException x) {
+
+            // check local address after binding
+            InetSocketAddress local = (InetSocketAddress)ch.getLocalAddress();
+            if (local.getPort() == 0)
+                throw new RuntimeException("Unexpected port");
+            if (!local.getAddress().isAnyLocalAddress())
+                throw new RuntimeException("Not bound to a wildcard address");
+
+            // try to re-bind
+            try {
+                ch.bind(new InetSocketAddress(0));
+                throw new RuntimeException("AlreadyBoundException expected");
+            } catch (AlreadyBoundException x) {
+            }
         }
-        ch.close();
 
         // check ClosedChannelException
-        ch = AsynchronousSocketChannel.open();
+        AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
         ch.close();
         try {
             ch.bind(new InetSocketAddress(0));
@@ -118,109 +129,124 @@
     static void testSocketOptions() throws Exception {
         System.out.println("-- socket options --");
 
-        AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()
-            .setOption(SO_RCVBUF, 128*1024)
-            .setOption(SO_SNDBUF, 128*1024)
-            .setOption(SO_REUSEADDR, true);
-
-        // check SO_SNDBUF/SO_RCVBUF limits
-        int before, after;
-        before = ch.getOption(SO_SNDBUF);
-        after = ch.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);
-        if (after < before)
-            throw new RuntimeException("setOption caused SO_SNDBUF to decrease");
-        before = ch.getOption(SO_RCVBUF);
-        after = ch.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);
-        if (after < before)
-            throw new RuntimeException("setOption caused SO_RCVBUF to decrease");
-
-        ch.bind(new InetSocketAddress(0));
-
-        // default values
-        if ((Boolean)ch.getOption(SO_KEEPALIVE))
-            throw new RuntimeException("Default of SO_KEEPALIVE should be 'false'");
-        if ((Boolean)ch.getOption(TCP_NODELAY))
-            throw new RuntimeException("Default of TCP_NODELAY should be 'false'");
-
-        // set and check
-        if (!(Boolean)ch.setOption(SO_KEEPALIVE, true).getOption(SO_KEEPALIVE))
-            throw new RuntimeException("SO_KEEPALIVE did not change");
-        if (!(Boolean)ch.setOption(TCP_NODELAY, true).getOption(TCP_NODELAY))
-            throw new RuntimeException("SO_KEEPALIVE did not change");
-
-        // read others (can't check as actual value is implementation dependent)
-        ch.getOption(SO_RCVBUF);
-        ch.getOption(SO_SNDBUF);
+        try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
+            ch.setOption(SO_RCVBUF, 128*1024)
+              .setOption(SO_SNDBUF, 128*1024)
+              .setOption(SO_REUSEADDR, true);
+
+            // check SO_SNDBUF/SO_RCVBUF limits
+            int before, after;
+            before = ch.getOption(SO_SNDBUF);
+            after = ch.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);
+            if (after < before)
+                throw new RuntimeException("setOption caused SO_SNDBUF to decrease");
+            before = ch.getOption(SO_RCVBUF);
+            after = ch.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);
+            if (after < before)
+                throw new RuntimeException("setOption caused SO_RCVBUF to decrease");
 
-        ch.close();
+            ch.bind(new InetSocketAddress(0));
+
+            // default values
+            if (ch.getOption(SO_KEEPALIVE))
+                throw new RuntimeException("Default of SO_KEEPALIVE should be 'false'");
+            if (ch.getOption(TCP_NODELAY))
+                throw new RuntimeException("Default of TCP_NODELAY should be 'false'");
+
+            // set and check
+            if (!ch.setOption(SO_KEEPALIVE, true).getOption(SO_KEEPALIVE))
+                throw new RuntimeException("SO_KEEPALIVE did not change");
+            if (!ch.setOption(TCP_NODELAY, true).getOption(TCP_NODELAY))
+                throw new RuntimeException("SO_KEEPALIVE did not change");
+
+            // read others (can't check as actual value is implementation dependent)
+            ch.getOption(SO_RCVBUF);
+            ch.getOption(SO_SNDBUF);
+        }
     }
 
     static void testConnect() throws Exception {
         System.out.println("-- connect --");
 
-        Server server = new Server();
-        AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
+        SocketAddress address;
 
-        // check local address
-        if (ch.getLocalAddress() == null)
-            throw new RuntimeException("Not bound to local address");
-
-        // check remote address
-        InetSocketAddress remote = (InetSocketAddress)ch.getRemoteAddress();
-        if (remote.getPort() != server.address().getPort())
-            throw new RuntimeException("Connected to unexpected port");
-        if (!remote.getAddress().equals(server.address().getAddress()))
-            throw new RuntimeException("Connected to unexpected address");
+        try (Server server = new Server()) {
+            address = server.address();
 
-        // try to connect again
-        try {
-            ch.connect(server.address()).get();
-            throw new RuntimeException("AlreadyConnectedException expected");
-        } catch (AlreadyConnectedException x) {
-        }
-        ch.close();
+            // connect to server and check local/remote addresses
+            try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
+                ch.connect(address).get();
+                // check local address
+                if (ch.getLocalAddress() == null)
+                    throw new RuntimeException("Not bound to local address");
 
-        // check that connect fails with ClosedChannelException)
-        ch = AsynchronousSocketChannel.open();
-        ch.close();
-        try {
-            ch.connect(server.address()).get();
-            throw new RuntimeException("ExecutionException expected");
-        } catch (ExecutionException x) {
-            if (!(x.getCause() instanceof ClosedChannelException))
-                throw new RuntimeException("Cause of ClosedChannelException expected");
-        }
-        final AtomicReference<Throwable> connectException =
-            new AtomicReference<Throwable>();
-        ch.connect(server.address(), (Void)null, new CompletionHandler<Void,Void>() {
-            public void completed(Void result, Void att) {
+                // check remote address
+                InetSocketAddress remote = (InetSocketAddress)ch.getRemoteAddress();
+                if (remote.getPort() != server.address().getPort())
+                    throw new RuntimeException("Connected to unexpected port");
+                if (!remote.getAddress().equals(server.address().getAddress()))
+                    throw new RuntimeException("Connected to unexpected address");
+
+                // try to connect again
+                try {
+                    ch.connect(server.address()).get();
+                    throw new RuntimeException("AlreadyConnectedException expected");
+                } catch (AlreadyConnectedException x) {
+                }
+
+                // clean-up
+                server.accept().close();
             }
-            public void failed(Throwable exc, Void att) {
-                connectException.set(exc);
+
+            // check that connect fails with ClosedChannelException
+            AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+            ch.close();
+            try {
+                ch.connect(server.address()).get();
+                throw new RuntimeException("ExecutionException expected");
+            } catch (ExecutionException x) {
+                if (!(x.getCause() instanceof ClosedChannelException))
+                    throw new RuntimeException("Cause of ClosedChannelException expected");
+            }
+            final AtomicReference<Throwable> connectException = new AtomicReference<>();
+            ch.connect(server.address(), (Void)null, new CompletionHandler<Void,Void>() {
+                public void completed(Void result, Void att) {
+                }
+                public void failed(Throwable exc, Void att) {
+                    connectException.set(exc);
+                }
+            });
+            while (connectException.get() == null) {
+                Thread.sleep(100);
             }
-        });
-        while (connectException.get() == null) {
-            Thread.sleep(100);
+            if (!(connectException.get() instanceof ClosedChannelException))
+                throw new RuntimeException("ClosedChannelException expected");
         }
-        if (!(connectException.get() instanceof ClosedChannelException))
-            throw new RuntimeException("ClosedChannelException expected");
-
-        System.out.println("-- connect to non-existent host --");
 
         // test that failure to connect closes the channel
-        ch = AsynchronousSocketChannel.open();
-        try {
-            ch.connect(genSocketAddress()).get();
-        } catch (ExecutionException x) {
-            // failed to establish connection
-            if (ch.isOpen())
-                throw new RuntimeException("Channel should be closed");
-        } finally {
-            ch.close();
+        try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
+            try {
+                ch.connect(address).get();
+            } catch (ExecutionException x) {
+                // failed to establish connection
+                if (ch.isOpen())
+                    throw new RuntimeException("Channel should be closed");
+            }
         }
 
-        server.close();
+        // repeat test by connecting to a (probably) non-existent host. This
+        // improves the chance that the connect will not fail immediately.
+        if (!skipSlowConnectTest) {
+            try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
+                try {
+                    ch.connect(genSocketAddress()).get();
+                } catch (ExecutionException x) {
+                    // failed to establish connection
+                    if (ch.isOpen())
+                        throw new RuntimeException("Channel should be closed");
+                }
+            }
+        }
     }
 
     static void testCloseWhenPending() throws Exception {
@@ -249,466 +275,460 @@
 
         System.out.println("-- asynchronous close when reading --");
 
-        Server server = new Server();
-        ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
+        try (Server server = new Server()) {
+            ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
 
-        ByteBuffer dst = ByteBuffer.allocateDirect(100);
-        Future<Integer> result = ch.read(dst);
+            ByteBuffer dst = ByteBuffer.allocateDirect(100);
+            Future<Integer> result = ch.read(dst);
 
-        // attempt a second read - should fail with ReadPendingException
-        ByteBuffer buf = ByteBuffer.allocateDirect(100);
-        try {
-            ch.read(buf);
-            throw new RuntimeException("ReadPendingException expected");
-        } catch (ReadPendingException x) {
-        }
+            // attempt a second read - should fail with ReadPendingException
+            ByteBuffer buf = ByteBuffer.allocateDirect(100);
+            try {
+                ch.read(buf);
+                throw new RuntimeException("ReadPendingException expected");
+            } catch (ReadPendingException x) {
+            }
 
-        // close channel (should cause initial read to complete)
-        ch.close();
+            // close channel (should cause initial read to complete)
+            ch.close();
+            server.accept().close();
 
-        // check that AsynchronousCloseException is thrown
-        try {
-            result.get();
-            throw new RuntimeException("Should not read");
-        } catch (ExecutionException x) {
-            if (!(x.getCause() instanceof AsynchronousCloseException))
-                throw new RuntimeException(x);
-        }
+            // check that AsynchronousCloseException is thrown
+            try {
+                result.get();
+                throw new RuntimeException("Should not read");
+            } catch (ExecutionException x) {
+                if (!(x.getCause() instanceof AsynchronousCloseException))
+                    throw new RuntimeException(x);
+            }
 
-        System.out.println("-- asynchronous close when writing --");
+            System.out.println("-- asynchronous close when writing --");
 
-        ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
+            ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
 
-        final AtomicReference<Throwable> writeException =
-            new AtomicReference<Throwable>();
+            final AtomicReference<Throwable> writeException =
+                new AtomicReference<Throwable>();
 
-        // write bytes to fill socket buffer
-        ch.write(genBuffer(), ch, new CompletionHandler<Integer,AsynchronousSocketChannel>() {
-            public void completed(Integer result, AsynchronousSocketChannel ch) {
-                ch.write(genBuffer(), ch, this);
-            }
-            public void failed(Throwable x, AsynchronousSocketChannel ch) {
-                writeException.set(x);
-            }
-        });
+            // write bytes to fill socket buffer
+            ch.write(genBuffer(), ch, new CompletionHandler<Integer,AsynchronousSocketChannel>() {
+                public void completed(Integer result, AsynchronousSocketChannel ch) {
+                    ch.write(genBuffer(), ch, this);
+                }
+                public void failed(Throwable x, AsynchronousSocketChannel ch) {
+                    writeException.set(x);
+                }
+            });
 
-        // give time for socket buffer to fill up.
-        Thread.sleep(5*1000);
+            // give time for socket buffer to fill up.
+            Thread.sleep(5*1000);
 
-        //  attempt a concurrent write - should fail with WritePendingException
-        try {
-            ch.write(genBuffer());
-            throw new RuntimeException("WritePendingException expected");
-        } catch (WritePendingException x) {
-        }
+            //  attempt a concurrent write - should fail with WritePendingException
+            try {
+                ch.write(genBuffer());
+                throw new RuntimeException("WritePendingException expected");
+            } catch (WritePendingException x) {
+            }
 
-        // close channel - should cause initial write to complete
-        ch.close();
+            // close channel - should cause initial write to complete
+            ch.close();
+            server.accept().close();
 
-        // wait for exception
-        while (writeException.get() == null) {
-            Thread.sleep(100);
+            // wait for exception
+            while (writeException.get() == null) {
+                Thread.sleep(100);
+            }
+            if (!(writeException.get() instanceof AsynchronousCloseException))
+                throw new RuntimeException("AsynchronousCloseException expected");
         }
-        if (!(writeException.get() instanceof AsynchronousCloseException))
-            throw new RuntimeException("AsynchronousCloseException expected");
-
-        server.close();
     }
 
     static void testCancel() throws Exception {
         System.out.println("-- cancel --");
 
-        Server server = new Server();
+        try (Server server = new Server()) {
+            for (int i=0; i<2; i++) {
+                boolean mayInterruptIfRunning = (i == 0) ? false : true;
+
+                // establish loopback connection
+                AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+                ch.connect(server.address()).get();
+                SocketChannel peer = server.accept();
+
+                // start read operation
+                ByteBuffer buf = ByteBuffer.allocate(1);
+                Future<Integer> res = ch.read(buf);
+
+                // cancel operation
+                boolean cancelled = res.cancel(mayInterruptIfRunning);
+
+                // check post-conditions
+                if (!res.isDone())
+                    throw new RuntimeException("isDone should return true");
+                if (res.isCancelled() != cancelled)
+                    throw new RuntimeException("isCancelled not consistent");
+                try {
+                    res.get();
+                    throw new RuntimeException("CancellationException expected");
+                } catch (CancellationException x) {
+                }
+                try {
+                    res.get(1, TimeUnit.SECONDS);
+                    throw new RuntimeException("CancellationException expected");
+                } catch (CancellationException x) {
+                }
+
+                // check that the cancel doesn't impact writing to the channel
+                if (!mayInterruptIfRunning) {
+                    buf = ByteBuffer.wrap("a".getBytes());
+                    ch.write(buf).get();
+                }
 
-        for (int i=0; i<2; i++) {
-            boolean mayInterruptIfRunning = (i == 0) ? false : true;
+                ch.close();
+                peer.close();
+            }
+        }
+    }
 
-            // establish loopback connection
-            AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+    static void testRead1() throws Exception {
+        System.out.println("-- read (1) --");
+
+        try (Server server = new Server()) {
+            final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
             ch.connect(server.address()).get();
-            SocketChannel peer = server.accept();
 
-            // start read operation
+            // read with 0 bytes remaining should complete immediately
             ByteBuffer buf = ByteBuffer.allocate(1);
-            Future<Integer> res = ch.read(buf);
-
-            // cancel operation
-            boolean cancelled = res.cancel(mayInterruptIfRunning);
+            buf.put((byte)0);
+            int n = ch.read(buf).get();
+            if (n != 0)
+                throw new RuntimeException("0 expected");
+
+            // write bytes and close connection
+            ByteBuffer src = genBuffer();
+            try (SocketChannel sc = server.accept()) {
+                sc.setOption(SO_SNDBUF, src.remaining());
+                while (src.hasRemaining())
+                    sc.write(src);
+            }
+
+            // reads should complete immediately
+            final ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity() + 100);
+            final CountDownLatch latch = new CountDownLatch(1);
+            ch.read(dst, (Void)null, new CompletionHandler<Integer,Void>() {
+                public void completed(Integer result, Void att) {
+                    int n = result;
+                    if (n > 0) {
+                        ch.read(dst, (Void)null, this);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+                public void failed(Throwable exc, Void att) {
+                }
+            });
 
-            // check post-conditions
-            if (!res.isDone())
-                throw new RuntimeException("isDone should return true");
-            if (res.isCancelled() != cancelled)
-                throw new RuntimeException("isCancelled not consistent");
-            try {
-                res.get();
-                throw new RuntimeException("CancellationException expected");
-            } catch (CancellationException x) {
-            }
-            try {
-                res.get(1, TimeUnit.SECONDS);
-                throw new RuntimeException("CancellationException expected");
-            } catch (CancellationException x) {
-            }
+            latch.await();
 
-            // check that the cancel doesn't impact writing to the channel
-            if (!mayInterruptIfRunning) {
-                buf = ByteBuffer.wrap("a".getBytes());
-                ch.write(buf).get();
+            // check buffers
+            src.flip();
+            dst.flip();
+            if (!src.equals(dst)) {
+                throw new RuntimeException("Contents differ");
             }
 
+            // close channel
             ch.close();
-            peer.close();
-        }
-
-        server.close();
-    }
-
-    static void testRead1() throws Exception {
-        System.out.println("-- read (1) --");
-
-        Server server = new Server();
-        final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-
-        // read with 0 bytes remaining should complete immediately
-        ByteBuffer buf = ByteBuffer.allocate(1);
-        buf.put((byte)0);
-        int n = ch.read(buf).get();
-        if (n != 0)
-            throw new RuntimeException("0 expected");
-
-        // write bytes and close connection
-        SocketChannel sc = server.accept();
-        ByteBuffer src = genBuffer();
-        sc.setOption(StandardSocketOptions.SO_SNDBUF, src.remaining());
-        while (src.hasRemaining())
-            sc.write(src);
-        sc.close();
-
-        // reads should complete immediately
-        final ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity() + 100);
-        final CountDownLatch latch = new CountDownLatch(1);
-        ch.read(dst, (Void)null, new CompletionHandler<Integer,Void>() {
-            public void completed(Integer result, Void att) {
-                int n = result;
-                if (n > 0) {
-                    ch.read(dst, (Void)null, this);
-                } else {
-                    latch.countDown();
-                }
-            }
-            public void failed(Throwable exc, Void att) {
-            }
-        });
-
-        latch.await();
-
-        // check buffers
-        src.flip();
-        dst.flip();
-        if (!src.equals(dst)) {
-            throw new RuntimeException("Contents differ");
-        }
 
-        // close channel
-        ch.close();
-
-        // check read fails with ClosedChannelException
-        try {
-            ch.read(dst).get();
-            throw new RuntimeException("ExecutionException expected");
-        } catch (ExecutionException x) {
-            if (!(x.getCause() instanceof ClosedChannelException))
-                throw new RuntimeException("Cause of ClosedChannelException expected");
+            // check read fails with ClosedChannelException
+            try {
+                ch.read(dst).get();
+                throw new RuntimeException("ExecutionException expected");
+            } catch (ExecutionException x) {
+                if (!(x.getCause() instanceof ClosedChannelException))
+                    throw new RuntimeException("Cause of ClosedChannelException expected");
+            }
         }
-
-        server.close();
     }
 
     static void testRead2() throws Exception {
         System.out.println("-- read (2) --");
 
-        Server server = new Server();
+        try (Server server = new Server()) {
+            final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
+            SocketChannel sc = server.accept();
 
-        final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-        SocketChannel sc = server.accept();
-
-        ByteBuffer src = genBuffer();
-
-        // read until the buffer is full
-        final ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity());
-        final CountDownLatch latch = new CountDownLatch(1);
-        ch.read(dst, (Void)null, new CompletionHandler<Integer,Void>() {
-            public void completed(Integer result, Void att) {
-                if (dst.hasRemaining()) {
-                    ch.read(dst, (Void)null, this);
-                } else {
-                    latch.countDown();
-                }
-            }
-            public void failed(Throwable exc, Void att) {
-            }
-        });
-
-        // trickle the writing
-        do {
-            int rem = src.remaining();
-            int size = (rem <= 100) ? rem : 50 + rand.nextInt(rem - 100);
-            ByteBuffer buf = ByteBuffer.allocate(size);
-            for (int i=0; i<size; i++)
-                buf.put(src.get());
-            buf.flip();
-            Thread.sleep(50 + rand.nextInt(1500));
-            while (buf.hasRemaining())
-                sc.write(buf);
-        } while (src.hasRemaining());
-
-        // wait until ascynrhonous reading has completed
-        latch.await();
-
-        // check buffers
-        src.flip();
-        dst.flip();
-        if (!src.equals(dst)) {
-           throw new RuntimeException("Contents differ");
-        }
+            ByteBuffer src = genBuffer();
 
-        sc.close();
-        ch.close();
-        server.close();
+            // read until the buffer is full
+            final ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity());
+            final CountDownLatch latch = new CountDownLatch(1);
+            ch.read(dst, (Void)null, new CompletionHandler<Integer,Void>() {
+                public void completed(Integer result, Void att) {
+                    if (dst.hasRemaining()) {
+                        ch.read(dst, (Void)null, this);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+                public void failed(Throwable exc, Void att) {
+                }
+            });
+
+            // trickle the writing
+            do {
+                int rem = src.remaining();
+                int size = (rem <= 100) ? rem : 50 + rand.nextInt(rem - 100);
+                ByteBuffer buf = ByteBuffer.allocate(size);
+                for (int i=0; i<size; i++)
+                    buf.put(src.get());
+                buf.flip();
+                Thread.sleep(50 + rand.nextInt(1500));
+                while (buf.hasRemaining())
+                    sc.write(buf);
+            } while (src.hasRemaining());
+
+            // wait until ascynrhonous reading has completed
+            latch.await();
+
+            // check buffers
+            src.flip();
+            dst.flip();
+            if (!src.equals(dst)) {
+               throw new RuntimeException("Contents differ");
+            }
+
+            sc.close();
+            ch.close();
+        }
     }
 
     // exercise scattering read
     static void testRead3() throws Exception {
         System.out.println("-- read (3) --");
 
-        Server server = new Server();
-        final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-        SocketChannel sc = server.accept();
-
-        ByteBuffer[] dsts = new ByteBuffer[3];
-        for (int i=0; i<dsts.length; i++) {
-            dsts[i] = ByteBuffer.allocateDirect(100);
-        }
-
-        // scattering read that completes ascynhronously
-        final CountDownLatch l1 = new CountDownLatch(1);
-        ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
-            new CompletionHandler<Long,Void>() {
-                public void completed(Long result, Void att) {
-                    long n = result;
-                    if (n <= 0)
-                        throw new RuntimeException("No bytes read");
-                    l1.countDown();
-                }
-                public void failed(Throwable exc, Void att) {
-                }
-        });
+        try (Server server = new Server()) {
+            final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
+            SocketChannel sc = server.accept();
 
-        // write some bytes
-        sc.write(genBuffer());
+            ByteBuffer[] dsts = new ByteBuffer[3];
+            for (int i=0; i<dsts.length; i++) {
+                dsts[i] = ByteBuffer.allocateDirect(100);
+            }
+
+            // scattering read that completes ascynhronously
+            final CountDownLatch l1 = new CountDownLatch(1);
+            ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
+                new CompletionHandler<Long,Void>() {
+                    public void completed(Long result, Void att) {
+                        long n = result;
+                        if (n <= 0)
+                            throw new RuntimeException("No bytes read");
+                        l1.countDown();
+                    }
+                    public void failed(Throwable exc, Void att) {
+                    }
+            });
 
-        // read should now complete
-        l1.await();
+            // write some bytes
+            sc.write(genBuffer());
 
-        // write more bytes
-        sc.write(genBuffer());
-
-        // read should complete immediately
-        for (int i=0; i<dsts.length; i++) {
-            dsts[i].rewind();
-        }
-
-        final CountDownLatch l2 = new CountDownLatch(1);
-        ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
-            new CompletionHandler<Long,Void>() {
-                public void completed(Long result, Void att) {
-                    long n = result;
-                    if (n <= 0)
-                        throw new RuntimeException("No bytes read");
-                    l2.countDown();
-                }
-                public void failed(Throwable exc, Void att) {
-                }
-        });
-        l2.await();
+            // read should now complete
+            l1.await();
 
-        ch.close();
-        sc.close();
-        server.close();
+            // write more bytes
+            sc.write(genBuffer());
+
+            // read should complete immediately
+            for (int i=0; i<dsts.length; i++) {
+                dsts[i].rewind();
+            }
+
+            final CountDownLatch l2 = new CountDownLatch(1);
+            ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
+                new CompletionHandler<Long,Void>() {
+                    public void completed(Long result, Void att) {
+                        long n = result;
+                        if (n <= 0)
+                            throw new RuntimeException("No bytes read");
+                        l2.countDown();
+                    }
+                    public void failed(Throwable exc, Void att) {
+                    }
+            });
+            l2.await();
+
+            ch.close();
+            sc.close();
+        }
     }
 
     static void testWrite1() throws Exception {
         System.out.println("-- write (1) --");
 
-        Server server = new Server();
-        final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-        SocketChannel sc = server.accept();
-
-        // write with 0 bytes remaining should complete immediately
-        ByteBuffer buf = ByteBuffer.allocate(1);
-        buf.put((byte)0);
-        int n = ch.write(buf).get();
-        if (n != 0)
-            throw new RuntimeException("0 expected");
-
-        // write all bytes and close connection when done
-        final ByteBuffer src = genBuffer();
-        ch.write(src, (Void)null, new CompletionHandler<Integer,Void>() {
-            public void completed(Integer result, Void att) {
-                if (src.hasRemaining()) {
-                    ch.write(src, (Void)null, this);
-                } else {
-                    try {
-                        ch.close();
-                    } catch (IOException ignore) { }
-                }
-            }
-            public void failed(Throwable exc, Void att) {
-            }
-        });
-
-        // read to EOF or buffer full
-        ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity() + 100);
-        do {
-            n = sc.read(dst);
-        } while (n > 0);
-        sc.close();
-
-        // check buffers
-        src.flip();
-        dst.flip();
-        if (!src.equals(dst)) {
-            throw new RuntimeException("Contents differ");
-        }
+        try (Server server = new Server()) {
+            final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
+            SocketChannel sc = server.accept();
 
-        // check write fails with ClosedChannelException
-        try {
-            ch.read(dst).get();
-            throw new RuntimeException("ExecutionException expected");
-        } catch (ExecutionException x) {
-            if (!(x.getCause() instanceof ClosedChannelException))
-                throw new RuntimeException("Cause of ClosedChannelException expected");
-        }
+            // write with 0 bytes remaining should complete immediately
+            ByteBuffer buf = ByteBuffer.allocate(1);
+            buf.put((byte)0);
+            int n = ch.write(buf).get();
+            if (n != 0)
+                throw new RuntimeException("0 expected");
+
+            // write all bytes and close connection when done
+            final ByteBuffer src = genBuffer();
+            ch.write(src, (Void)null, new CompletionHandler<Integer,Void>() {
+                public void completed(Integer result, Void att) {
+                    if (src.hasRemaining()) {
+                        ch.write(src, (Void)null, this);
+                    } else {
+                        try {
+                            ch.close();
+                        } catch (IOException ignore) { }
+                    }
+                }
+                public void failed(Throwable exc, Void att) {
+                }
+            });
 
-        server.close();
+            // read to EOF or buffer full
+            ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity() + 100);
+            do {
+                n = sc.read(dst);
+            } while (n > 0);
+            sc.close();
+
+            // check buffers
+            src.flip();
+            dst.flip();
+            if (!src.equals(dst)) {
+                throw new RuntimeException("Contents differ");
+            }
+
+            // check write fails with ClosedChannelException
+            try {
+                ch.read(dst).get();
+                throw new RuntimeException("ExecutionException expected");
+            } catch (ExecutionException x) {
+                if (!(x.getCause() instanceof ClosedChannelException))
+                    throw new RuntimeException("Cause of ClosedChannelException expected");
+            }
+        }
     }
 
     // exercise gathering write
     static void testWrite2() throws Exception {
         System.out.println("-- write (2) --");
 
-        Server server = new Server();
-        final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-        SocketChannel sc = server.accept();
-
-        // number of bytes written
-        final AtomicLong bytesWritten = new AtomicLong(0);
-
-        // write buffers (should complete immediately)
-        ByteBuffer[] srcs = genBuffers(1);
-        final CountDownLatch l1 = new CountDownLatch(1);
-        ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
-            new CompletionHandler<Long,Void>() {
-                public void completed(Long result, Void att) {
-                    long n = result;
-                    if (n <= 0)
-                        throw new RuntimeException("No bytes read");
-                    bytesWritten.addAndGet(n);
-                    l1.countDown();
-                }
-                public void failed(Throwable exc, Void att) {
-                }
-        });
-        l1.await();
+        try (Server server = new Server()) {
+            final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
+            SocketChannel sc = server.accept();
 
-        // set to true to signal that no more buffers should be written
-        final AtomicBoolean continueWriting = new AtomicBoolean(true);
+            // number of bytes written
+            final AtomicLong bytesWritten = new AtomicLong(0);
 
-        // write until socket buffer is full so as to create the conditions
-        // for when a write does not complete immediately
-        srcs = genBuffers(1);
-        ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
-            new CompletionHandler<Long,Void>() {
-                public void completed(Long result, Void att) {
-                    long n = result;
-                    if (n <= 0)
-                        throw new RuntimeException("No bytes written");
-                    bytesWritten.addAndGet(n);
-                    if (continueWriting.get()) {
-                        ByteBuffer[] srcs = genBuffers(8);
-                        ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS,
-                            (Void)null, this);
+            // write buffers (should complete immediately)
+            ByteBuffer[] srcs = genBuffers(1);
+            final CountDownLatch l1 = new CountDownLatch(1);
+            ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
+                new CompletionHandler<Long,Void>() {
+                    public void completed(Long result, Void att) {
+                        long n = result;
+                        if (n <= 0)
+                            throw new RuntimeException("No bytes read");
+                        bytesWritten.addAndGet(n);
+                        l1.countDown();
                     }
-                }
-                public void failed(Throwable exc, Void att) {
-                }
-        });
+                    public void failed(Throwable exc, Void att) {
+                    }
+            });
+            l1.await();
 
-        // give time for socket buffer to fill up.
-        Thread.sleep(5*1000);
+            // set to true to signal that no more buffers should be written
+            final AtomicBoolean continueWriting = new AtomicBoolean(true);
 
-        // signal handler to stop further writing
-        continueWriting.set(false);
+            // write until socket buffer is full so as to create the conditions
+            // for when a write does not complete immediately
+            srcs = genBuffers(1);
+            ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
+                new CompletionHandler<Long,Void>() {
+                    public void completed(Long result, Void att) {
+                        long n = result;
+                        if (n <= 0)
+                            throw new RuntimeException("No bytes written");
+                        bytesWritten.addAndGet(n);
+                        if (continueWriting.get()) {
+                            ByteBuffer[] srcs = genBuffers(8);
+                            ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS,
+                                (Void)null, this);
+                        }
+                    }
+                    public void failed(Throwable exc, Void att) {
+                    }
+            });
 
-        // read until done
-        ByteBuffer buf = ByteBuffer.allocateDirect(4096);
-        long total = 0L;
-        do {
-            int n = sc.read(buf);
-            if (n <= 0)
-                throw new RuntimeException("No bytes read");
-            buf.rewind();
-            total += n;
-        } while (total < bytesWritten.get());
+            // give time for socket buffer to fill up.
+            Thread.sleep(5*1000);
 
-        ch.close();
-        sc.close();
-        server.close();
+            // signal handler to stop further writing
+            continueWriting.set(false);
+
+            // read until done
+            ByteBuffer buf = ByteBuffer.allocateDirect(4096);
+            long total = 0L;
+            do {
+                int n = sc.read(buf);
+                if (n <= 0)
+                    throw new RuntimeException("No bytes read");
+                buf.rewind();
+                total += n;
+            } while (total < bytesWritten.get());
+
+            ch.close();
+            sc.close();
+        }
     }
 
     static void testShutdown() throws Exception {
         System.out.println("-- shutdown--");
 
-        Server server = new Server();
-        AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-        SocketChannel sc = server.accept();
-
-        ByteBuffer buf = ByteBuffer.allocateDirect(1000);
-        int n;
-
-        // check read
-        ch.shutdownInput();
-        n = ch.read(buf).get();
-        if (n != -1)
-            throw new RuntimeException("-1 expected");
-        // check full with full buffer
-        buf.put(new byte[100]);
-        n = ch.read(buf).get();
-        if (n != -1)
-            throw new RuntimeException("-1 expected");
-
-        // check write
-        ch.shutdownOutput();
-        try {
-            ch.write(buf).get();
-            throw new RuntimeException("ClosedChannelException expected");
-        } catch (ExecutionException x) {
-            if (!(x.getCause() instanceof ClosedChannelException))
-                throw new RuntimeException("ClosedChannelException expected");
+        try (Server server = new Server();
+             AsynchronousSocketChannel ch = AsynchronousSocketChannel.open())
+        {
+            ch.connect(server.address()).get();
+            try (SocketChannel peer = server.accept()) {
+                ByteBuffer buf = ByteBuffer.allocateDirect(1000);
+                int n;
+
+                // check read
+                ch.shutdownInput();
+                n = ch.read(buf).get();
+                if (n != -1)
+                    throw new RuntimeException("-1 expected");
+                // check full with full buffer
+                buf.put(new byte[100]);
+                n = ch.read(buf).get();
+                if (n != -1)
+                    throw new RuntimeException("-1 expected");
+
+                // check write
+                ch.shutdownOutput();
+                try {
+                    ch.write(buf).get();
+                    throw new RuntimeException("ClosedChannelException expected");
+                } catch (ExecutionException x) {
+                    if (!(x.getCause() instanceof ClosedChannelException))
+                        throw new RuntimeException("ClosedChannelException expected");
+                }
+            }
         }
-
-        sc.close();
-        ch.close();
-        server.close();
     }
 
     static void testTimeout() throws Exception {
@@ -720,88 +740,88 @@
     }
 
     static void testTimeout(final long timeout, final TimeUnit unit) throws Exception {
-        Server server = new Server();
-        AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
-        ch.connect(server.address()).get();
-
-        ByteBuffer dst = ByteBuffer.allocate(512);
-
-        final AtomicReference<Throwable> readException = new AtomicReference<Throwable>();
-
-        // this read should timeout if value is > 0
-        ch.read(dst, timeout, unit, null, new CompletionHandler<Integer,Void>() {
-            public void completed(Integer result, Void att) {
-                readException.set(new RuntimeException("Should not complete"));
-            }
-            public void failed(Throwable exc, Void att) {
-                readException.set(exc);
-            }
-        });
-        if (timeout > 0L) {
-            // wait for exception
-            while (readException.get() == null) {
-                Thread.sleep(100);
-            }
-            if (!(readException.get() instanceof InterruptedByTimeoutException))
-                throw new RuntimeException("InterruptedByTimeoutException expected");
+        try (Server server = new Server()) {
+            AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
+            ch.connect(server.address()).get();
 
-            // after a timeout then further reading should throw unspecified runtime exception
-            boolean exceptionThrown = false;
-            try {
-                ch.read(dst);
-            } catch (RuntimeException x) {
-                exceptionThrown = true;
-            }
-            if (!exceptionThrown)
-                throw new RuntimeException("RuntimeException expected after timeout.");
-        } else {
-            Thread.sleep(1000);
-            Throwable exc = readException.get();
-            if (exc != null)
-                throw new RuntimeException(exc);
-        }
+            ByteBuffer dst = ByteBuffer.allocate(512);
 
-        final AtomicReference<Throwable> writeException = new AtomicReference<Throwable>();
+            final AtomicReference<Throwable> readException = new AtomicReference<Throwable>();
 
-        // write bytes to fill socket buffer
-        ch.write(genBuffer(), timeout, unit, ch,
-            new CompletionHandler<Integer,AsynchronousSocketChannel>()
-        {
-            public void completed(Integer result, AsynchronousSocketChannel ch) {
-                ch.write(genBuffer(), timeout, unit, ch, this);
-            }
-            public void failed(Throwable exc, AsynchronousSocketChannel ch) {
-                writeException.set(exc);
-            }
-        });
-        if (timeout > 0) {
-            // wait for exception
-            while (writeException.get() == null) {
-                Thread.sleep(100);
+            // this read should timeout if value is > 0
+            ch.read(dst, timeout, unit, null, new CompletionHandler<Integer,Void>() {
+                public void completed(Integer result, Void att) {
+                    readException.set(new RuntimeException("Should not complete"));
+                }
+                public void failed(Throwable exc, Void att) {
+                    readException.set(exc);
+                }
+            });
+            if (timeout > 0L) {
+                // wait for exception
+                while (readException.get() == null) {
+                    Thread.sleep(100);
+                }
+                if (!(readException.get() instanceof InterruptedByTimeoutException))
+                    throw new RuntimeException("InterruptedByTimeoutException expected");
+
+                // after a timeout then further reading should throw unspecified runtime exception
+                boolean exceptionThrown = false;
+                try {
+                    ch.read(dst);
+                } catch (RuntimeException x) {
+                    exceptionThrown = true;
+                }
+                if (!exceptionThrown)
+                    throw new RuntimeException("RuntimeException expected after timeout.");
+            } else {
+                Thread.sleep(1000);
+                Throwable exc = readException.get();
+                if (exc != null)
+                    throw new RuntimeException(exc);
+            }
+
+            final AtomicReference<Throwable> writeException = new AtomicReference<Throwable>();
+
+            // write bytes to fill socket buffer
+            ch.write(genBuffer(), timeout, unit, ch,
+                new CompletionHandler<Integer,AsynchronousSocketChannel>()
+            {
+                public void completed(Integer result, AsynchronousSocketChannel ch) {
+                    ch.write(genBuffer(), timeout, unit, ch, this);
+                }
+                public void failed(Throwable exc, AsynchronousSocketChannel ch) {
+                    writeException.set(exc);
+                }
+            });
+            if (timeout > 0) {
+                // wait for exception
+                while (writeException.get() == null) {
+                    Thread.sleep(100);
+                }
+                if (!(writeException.get() instanceof InterruptedByTimeoutException))
+                    throw new RuntimeException("InterruptedByTimeoutException expected");
+
+                // after a timeout then further writing should throw unspecified runtime exception
+                boolean exceptionThrown = false;
+                try {
+                    ch.write(genBuffer());
+                } catch (RuntimeException x) {
+                    exceptionThrown = true;
+                }
+                if (!exceptionThrown)
+                    throw new RuntimeException("RuntimeException expected after timeout.");
+            } else {
+                Thread.sleep(1000);
+                Throwable exc = writeException.get();
+                if (exc != null)
+                    throw new RuntimeException(exc);
             }
-            if (!(writeException.get() instanceof InterruptedByTimeoutException))
-                throw new RuntimeException("InterruptedByTimeoutException expected");
 
-            // after a timeout then further writing should throw unspecified runtime exception
-            boolean exceptionThrown = false;
-            try {
-                ch.write(genBuffer());
-            } catch (RuntimeException x) {
-                exceptionThrown = true;
-            }
-            if (!exceptionThrown)
-                throw new RuntimeException("RuntimeException expected after timeout.");
-        } else {
-            Thread.sleep(1000);
-            Throwable exc = writeException.get();
-            if (exc != null)
-                throw new RuntimeException(exc);
+            // clean-up
+            server.accept().close();
+            ch.close();
         }
-
-        // clean-up
-        server.accept().close();
-        ch.close();
-        server.close();
     }
 
     // returns ByteBuffer with random bytes
--- jdk/test/java/nio/channels/AsynchronousSocketChannel/Leaky.java	2012-08-10 10:34:28.000000000 -0700
+++ jdk/test/java/nio/channels/AsynchronousSocketChannel/Leaky.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,9 +22,9 @@
  */
 
 /* @test
- * @bug 4607272 6999915
+ * @bug 4607272 6999915 7185340
  * @summary Unit test for AsynchronousSocketChannel
- * @run main/othervm -XX:+DisableExplicitGC -XX:MaxDirectMemorySize=64m Leaky
+ * @run main/othervm -XX:+DisableExplicitGC -XX:MaxDirectMemorySize=75m Leaky
  */
 
 import java.nio.ByteBuffer;
--- jdk/test/java/nio/channels/DatagramChannel/AdaptDatagramSocket.java	2012-08-10 10:34:28.000000000 -0700
+++ jdk/test/java/nio/channels/DatagramChannel/AdaptDatagramSocket.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,29 +27,16 @@
  * @library ..
  */
 
-import java.io.*;
 import java.net.*;
-import java.nio.*;
 import java.nio.channels.*;
-import java.nio.charset.*;
 import java.util.*;
 
 
 public class AdaptDatagramSocket {
 
     static java.io.PrintStream out = System.out;
-
     static Random rand = new Random();
 
-    static final int ECHO_PORT = 7;
-    static final int DISCARD_PORT = 9;
-    static final String REMOTE_HOST = TestUtil.HOST;
-
-    static final InetSocketAddress echoAddress
-        = new InetSocketAddress(REMOTE_HOST, ECHO_PORT);
-    static final InetSocketAddress discardAddress
-        = new InetSocketAddress(REMOTE_HOST, DISCARD_PORT);
-
     static String toString(DatagramPacket dp) {
         return ("DatagramPacket[off=" + dp.getOffset()
                 + ", len=" + dp.getLength()
@@ -88,10 +75,11 @@
         out.println("rtt: " + (System.currentTimeMillis() - start));
         out.println("post op: " + toString(op) + "  ip: " + toString(ip));
 
-        for (int i = 0; i < ip.getLength(); i++)
+        for (int i = 0; i < ip.getLength(); i++) {
             if (ip.getData()[ip.getOffset() + i]
                 != op.getData()[op.getOffset() + i])
                 throw new Exception("Incorrect data received");
+        }
 
         if (!(ip.getSocketAddress().equals(dst))) {
             throw new Exception("Incorrect sender address, expected: " + dst
@@ -130,8 +118,9 @@
             ds.setSoTimeout(timeout);
         out.println("timeout: " + ds.getSoTimeout());
 
-        for (int i = 0; i < 5; i++)
+        for (int i = 0; i < 5; i++) {
             test(ds, dst, shouldTimeout);
+        }
 
         // Leave the socket open so that we don't reuse the old src address
         //ds.close();
@@ -139,10 +128,23 @@
     }
 
     public static void main(String[] args) throws Exception {
-        test(echoAddress, 0, false, false);
-        test(echoAddress, 0, false, true);
-        test(echoAddress, 5000, false, false);
-        test(discardAddress, 10, true, false);
+        // need an UDP echo server
+        try (TestServers.UdpEchoServer echoServer
+                = TestServers.UdpEchoServer.startNewServer(100)) {
+            final InetSocketAddress address
+                = new InetSocketAddress(echoServer.getAddress(),
+                                        echoServer.getPort());
+            test(address, 0, false, false);
+            test(address, 0, false, true);
+            test(address, 5000, false, false);
+        }
+        try (TestServers.UdpDiscardServer discardServer
+                = TestServers.UdpDiscardServer.startNewServer()) {
+            final InetSocketAddress address
+                = new InetSocketAddress(discardServer.getAddress(),
+                                        discardServer.getPort());
+            test(address, 10, true, false);
+        }
     }
 
 }
--- jdk/test/java/nio/channels/DatagramChannel/Disconnect.java	2012-08-10 10:34:28.000000000 -0700
+++ jdk/test/java/nio/channels/DatagramChannel/Disconnect.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/* @test
- * @bug 7132924
- * @summary Test DatagramChannel.disconnect when DatagramChannel is connected to an IPv4 socket
- * @run main Disconnect
- * @run main/othervm -Djava.net.preferIPv4Stack=true Disconnect
- */
-
-import java.net.*;
-import java.nio.*;
-import java.nio.channels.*;
-import java.io.IOException;
-
-public class Disconnect {
-    public static void main(String[] args) throws IOException {
-        // test with default protocol family
-        try (DatagramChannel dc = DatagramChannel.open()) {
-            test(dc);
-            test(dc);
-        }
-
-        // test with IPv4 only
-        try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {
-            test(dc);
-            test(dc);
-        }
-    }
-
-    /**
-     * Connect DatagramChannel to a server, write a datagram and disconnect. Invoke
-     * a second or subsequent time with the same DatagramChannel instance to check
-     * that disconnect works as expected.
-     */
-    static void test(DatagramChannel dc) throws IOException {
-        try (DatagramChannel server = DatagramChannel.open()) {
-            server.bind(new InetSocketAddress(0));
-
-            InetAddress lh = InetAddress.getLocalHost();
-            dc.connect(new InetSocketAddress(lh, server.socket().getLocalPort()));
-
-            dc.write(ByteBuffer.wrap("hello".getBytes()));
-
-            ByteBuffer bb = ByteBuffer.allocate(100);
-            server.receive(bb);
-
-            dc.disconnect();
-
-            try {
-                dc.write(ByteBuffer.wrap("another message".getBytes()));
-                throw new RuntimeException("write should fail, not connected");
-            } catch (NotYetConnectedException expected) {
-            }
-        }
-    }
-}
--- jdk/test/java/nio/channels/DatagramChannel/IsBound.java	2012-08-10 10:34:28.000000000 -0700
+++ jdk/test/java/nio/channels/DatagramChannel/IsBound.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,21 +34,25 @@
 
 public class IsBound {
     public static void main(String argv[]) throws Exception {
-        InetSocketAddress isa = new InetSocketAddress(
-            InetAddress.getByName(TestUtil.HOST), 13);
-        ByteBuffer bb = ByteBuffer.allocateDirect(256);
-        bb.put("hello".getBytes());
-        bb.flip();
-
-        DatagramChannel dc = DatagramChannel.open();
-        dc.send(bb, isa);
-        if(!dc.socket().isBound())
-            throw new Exception("Test failed");
-        dc.close();
-
-        dc = DatagramChannel.open();
-        if(dc.socket().isBound())
-            throw new Exception("Test failed");
-        dc.close();
+        try (TestServers.UdpDayTimeServer daytimeServer
+                = TestServers.UdpDayTimeServer.startNewServer(100)) {
+            InetSocketAddress isa = new InetSocketAddress(
+                daytimeServer.getAddress(),
+                daytimeServer.getPort());
+            ByteBuffer bb = ByteBuffer.allocateDirect(256);
+            bb.put("hello".getBytes());
+            bb.flip();
+
+            DatagramChannel dc = DatagramChannel.open();
+            dc.send(bb, isa);
+            if(!dc.socket().isBound())
+                throw new Exception("Test failed");
+            dc.close();
+
+            dc = DatagramChannel.open();
+            if(dc.socket().isBound())
+                throw new Exception("Test failed");
+            dc.close();
+        }
     }
 }
--- jdk/test/java/nio/channels/DatagramChannel/IsConnected.java	2012-08-10 10:34:28.000000000 -0700
+++ jdk/test/java/nio/channels/DatagramChannel/IsConnected.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,21 +28,23 @@
  */
 
 import java.net.*;
-import java.nio.*;
 import java.nio.channels.*;
 
 
 public class IsConnected {
     public static void main(String argv[]) throws Exception {
-        InetSocketAddress isa = new InetSocketAddress(
-            InetAddress.getByName(TestUtil.HOST), 13);
-        DatagramChannel dc = DatagramChannel.open();
-        dc.configureBlocking(true);
-        dc.connect(isa);
-        if  (!dc.isConnected())
-            throw new RuntimeException("channel.isConnected inconsistent");
-        if (!dc.socket().isConnected())
-            throw new RuntimeException("socket.isConnected inconsistent");
-        dc.close();
+        try (TestServers.UdpDayTimeServer daytimeServer
+                = TestServers.UdpDayTimeServer.startNewServer(100)) {
+            InetSocketAddress isa = new InetSocketAddress(
+                daytimeServer.getAddress(), daytimeServer.getPort());
+            DatagramChannel dc = DatagramChannel.open();
+            dc.configureBlocking(true);
+            dc.connect(isa);
+            if  (!dc.isConnected())
+                throw new RuntimeException("channel.isConnected inconsistent");
+            if (!dc.socket().isConnected())
+                throw new RuntimeException("socket.isConnected inconsistent");
+            dc.close();
+        }
     }
 }
--- jdk/test/java/nio/channels/DatagramChannel/SelectWhenRefused.java	2012-08-10 10:34:29.000000000 -0700
+++ jdk/test/java/nio/channels/DatagramChannel/SelectWhenRefused.java	2013-05-05 09:38:43.000000000 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 6935563
+ * @bug 6935563 7044870
  * @summary Test that Selector does not select an unconnected DatagramChannel when
  *    ICMP port unreachable received
  */
@@ -35,14 +35,15 @@
 public class SelectWhenRefused {
 
     public static void main(String[] args) throws IOException {
-        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));
-        int port = dc.socket().getLocalPort();
-        dc.close();
+        DatagramChannel dc1 = DatagramChannel.open().bind(new InetSocketAddress(0));
+        int port = dc1.socket().getLocalPort();
 
         // datagram sent to this address should be refused
         SocketAddress refuser = new InetSocketAddress(InetAddress.getLocalHost(), port);
 
-        dc = DatagramChannel.open().bind(new InetSocketAddress(0));
+        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));
+        dc1.close();
+
         Selector sel = Selector.open();
         try {
             dc.configureBlocking(false);
@@ -52,6 +53,10 @@
             sendDatagram(dc, refuser);
             int n = sel.select(2000);
             if (n > 0) {
+                sel.selectedKeys().clear();
+                // BindException will be thrown if another service is using
+                // our expected refuser port, cannot run just exit.
+                DatagramChannel.open().bind(refuser).close();
                 throw new RuntimeException("Unexpected wakeup");
             }
 
@@ -80,6 +85,8 @@
                 throw new RuntimeException("Unexpected wakeup after disconnect");
             }
 
+        } catch(BindException e) {
+            // Do nothing, some other test has used this port
         } finally {
             sel.close();
             dc.close();
--- jdk/test/java/nio/channels/DatagramChannel/SendToUnresolved.java	2012-08-10 10:34:29.000000000 -0700
+++ jdk/test/java/nio/channels/DatagramChannel/SendToUnresolved.java	2013-05-05 09:38:43.000000000 -0700
@@ -42,7 +42,7 @@
         try {
             dc.send(bb, sa);
             throw new RuntimeException("Expected exception not thrown");
-        } catch (IOException e) {
+        } catch (IOException | UnresolvedAddressException e) {
             // Correct result
         }
         dc.close();
--- jdk/test/java/nio/channels/Selector/Alias.java	2012-08-10 10:34:29.000000000 -0700
+++ jdk/test/java/nio/channels/Selector/Alias.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,12 +27,11 @@
  * @library ..
  */
 
-import java.io.*;
 import java.net.*;
 import java.nio.*;
 import java.nio.channels.*;
-import java.util.*;
 import java.nio.channels.spi.SelectorProvider;
+import java.util.*;
 
 public class Alias {
 
@@ -40,18 +39,26 @@
     static int LIMIT = 20; // Hangs after just 1 if problem is present
 
     public static void main(String[] args) throws Exception {
-        test1();
+        try (TestServers.DayTimeServer daytimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            test1(daytimeServer);
+        }
     }
 
-    public static void test1() throws Exception {
+    static void test1(TestServers.DayTimeServer daytimeServer) throws Exception {
         Selector selector = SelectorProvider.provider().openSelector();
-        InetAddress myAddress=InetAddress.getByName(TestUtil.HOST);
-        InetSocketAddress isa = new InetSocketAddress(myAddress,13);
+        InetAddress myAddress = daytimeServer.getAddress();
+        InetSocketAddress isa
+            = new InetSocketAddress(myAddress,
+                                    daytimeServer.getPort());
 
         for (int j=0; j<LIMIT; j++) {
             SocketChannel sc = SocketChannel.open();
             sc.configureBlocking(false);
             boolean result = sc.connect(isa);
+
+            // On some platforms - given that we're using a local server,
+            // we may not enter into the if () { } statement below...
             if (!result) {
                 SelectionKey key = sc.register(selector,
                                                SelectionKey.OP_CONNECT);
--- jdk/test/java/nio/channels/Selector/BasicConnect.java	2012-08-10 10:34:30.000000000 -0700
+++ jdk/test/java/nio/channels/Selector/BasicConnect.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,12 +27,10 @@
  * @library ..
  */
 
-import java.io.*;
 import java.net.*;
 import java.nio.*;
 import java.nio.channels.*;
 import java.nio.channels.spi.SelectorProvider;
-import java.nio.charset.*;
 import java.util.*;
 
 
@@ -44,52 +42,57 @@
 
 public class BasicConnect {
 
-    static final int PORT = 7;          // echo
-    static final String HOST = TestUtil.HOST;
-
     public static void main(String[] args) throws Exception {
         Selector connectSelector =
             SelectorProvider.provider().openSelector();
-        InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(HOST), PORT);
-        SocketChannel sc = SocketChannel.open();
-        sc.configureBlocking(false);
-        boolean result = sc.connect(isa);
-        while (!result) {
-            SelectionKey connectKey = sc.register(connectSelector,
-                                                  SelectionKey.OP_CONNECT);
-            int keysAdded = connectSelector.select();
-            if (keysAdded > 0) {
-                Set readyKeys = connectSelector.selectedKeys();
-                Iterator i = readyKeys.iterator();
-                while (i.hasNext()) {
-                    SelectionKey sk = (SelectionKey)i.next();
-                    i.remove();
-                    SocketChannel nextReady = (SocketChannel)sk.channel();
-                    result = nextReady.finishConnect();
-                    if (result)
-                        sk.cancel();
+        try (TestServers.EchoServer echoServer
+                = TestServers.EchoServer.startNewServer(100)) {
+            InetSocketAddress isa
+                = new InetSocketAddress(echoServer.getAddress(),
+                                        echoServer.getPort());
+            SocketChannel sc = SocketChannel.open();
+            sc.configureBlocking(false);
+            boolean result = sc.connect(isa);
+            if (result) {
+                System.out.println("Socket immediately connected on "
+                        + System.getProperty("os.name")
+                        + ": " + sc);
+            }
+            while (!result) {
+                SelectionKey connectKey = sc.register(connectSelector,
+                                                      SelectionKey.OP_CONNECT);
+                int keysAdded = connectSelector.select();
+                if (keysAdded > 0) {
+                    Set readyKeys = connectSelector.selectedKeys();
+                    Iterator i = readyKeys.iterator();
+                    while (i.hasNext()) {
+                        SelectionKey sk = (SelectionKey)i.next();
+                        i.remove();
+                        SocketChannel nextReady = (SocketChannel)sk.channel();
+                        result = nextReady.finishConnect();
+                        if (result)
+                            sk.cancel();
+                    }
                 }
             }
-        }
 
-        byte[] bs = new byte[] { (byte)0xca, (byte)0xfe,
-                                 (byte)0xba, (byte)0xbe };
-        ByteBuffer bb = ByteBuffer.wrap(bs);
-        sc.configureBlocking(true);
-        sc.write(bb);
-        bb.rewind();
-
-        ByteBuffer bb2 = ByteBuffer.allocateDirect(100);
-        int n = sc.read(bb2);
-        bb2.flip();
-
-        sc.close();
-        connectSelector.close();
-
-        if (!bb.equals(bb2))
-            throw new Exception("Echoed bytes incorrect: Sent "
-                                + bb + ", got " + bb2);
+            byte[] bs = new byte[] { (byte)0xca, (byte)0xfe,
+                                     (byte)0xba, (byte)0xbe };
+            ByteBuffer bb = ByteBuffer.wrap(bs);
+            sc.configureBlocking(true);
+            sc.write(bb);
+            bb.rewind();
+
+            ByteBuffer bb2 = ByteBuffer.allocateDirect(100);
+            int n = sc.read(bb2);
+            bb2.flip();
+
+            sc.close();
+            connectSelector.close();
+
+            if (!bb.equals(bb2))
+                throw new Exception("Echoed bytes incorrect: Sent "
+                                    + bb + ", got " + bb2);
+        }
     }
-
 }
--- jdk/test/java/nio/channels/Selector/ChangingInterests.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/nio/channels/Selector/ChangingInterests.java	2013-05-05 09:38:43.000000000 -0700
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @bug 7200742
+ * @summary Test that Selector doesn't spin when changing interest ops
+ */
+
+import java.net.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import static java.nio.channels.SelectionKey.*;
+import java.io.IOException;
+
+public class ChangingInterests {
+
+    static int OPS[] = { 0, OP_WRITE, OP_READ, (OP_WRITE|OP_READ) };
+
+    static String toOpsString(int ops) {
+        String s = "";
+        if ((ops & OP_READ) > 0)
+            s += "POLLIN";
+        if ((ops & OP_WRITE) > 0) {
+            if (s.length() > 0)
+                s += "|";
+            s += "POLLOUT";
+        }
+        if (s.length() == 0)
+            s = "0";
+        return "(" + s + ")";
+    }
+
+    static void write1(SocketChannel peer) throws IOException {
+        peer.write(ByteBuffer.wrap(new byte[1]));
+        // give time for other end to be readable
+        try {
+            Thread.sleep(50);
+        } catch (InterruptedException ignore) { }
+    }
+
+    static void drain(SocketChannel sc) throws IOException {
+        ByteBuffer buf = ByteBuffer.allocate(100);
+        int n;
+        while ((n = sc.read(buf)) > 0) {
+            buf.rewind();
+        }
+    }
+
+    /**
+     * Changes the given key's interest set from one set to another and then
+     * checks the selected key set and the key's channel.
+     */
+    static void testChange(SelectionKey key, int from, int to) throws IOException {
+        Selector sel = key.selector();
+        assertTrue(sel.keys().size() == 1, "Only one channel should be registered");
+
+        // ensure that channel is registered with the "from" interest set
+        key.interestOps(from);
+        sel.selectNow();
+        sel.selectedKeys().clear();
+
+        // change to the "to" interest set
+        key.interestOps(to);
+        System.out.println("select...");
+        int selected = sel.selectNow();
+        System.out.println("" + selected + " channel(s) selected");
+
+        int expected = (to == 0) ? 0 : 1;
+        assertTrue(selected == expected, "Expected " + expected);
+
+        // check selected keys
+        for (SelectionKey k: sel.selectedKeys()) {
+            assertTrue(k == key, "Unexpected key selected");
+
+            boolean readable = k.isReadable();
+            boolean writable = k.isWritable();
+
+            System.out.println("key readable: " + readable);
+            System.out.println("key writable: " + writable);
+
+            if ((to & OP_READ) == 0) {
+                assertTrue(!readable, "Not expected to be readable");
+            } else {
+                assertTrue(readable, "Expected to be readable");
+            }
+
+            if ((to & OP_WRITE) == 0) {
+                assertTrue(!writable, "Not expected to be writable");
+            } else {
+                assertTrue(writable, "Expected to be writable");
+            }
+
+            sel.selectedKeys().clear();
+        }
+    }
+
+    /**
+     * Tests that given Selector's select method blocks.
+     */
+    static void testForSpin(Selector sel) throws IOException {
+        System.out.println("Test for spin...");
+        long start = System.currentTimeMillis();
+        int count = 3;
+        while (count-- > 0) {
+            int selected = sel.select(1000);
+            System.out.println("" + selected + " channel(s) selected");
+            assertTrue(selected == 0, "Channel should not be selected");
+        }
+        long dur = System.currentTimeMillis() - start;
+        assertTrue(dur > 1000, "select was too short");
+    }
+
+    public static void main(String[] args) throws IOException {
+        InetAddress lh = InetAddress.getLocalHost();
+
+        // create loopback connection
+        ServerSocketChannel ssc =
+            ServerSocketChannel.open().bind(new InetSocketAddress(0));
+
+        final SocketChannel sc = SocketChannel.open();
+        sc.connect(new InetSocketAddress(lh, ssc.socket().getLocalPort()));
+        SocketChannel peer = ssc.accept();
+
+        sc.configureBlocking(false);
+
+        // ensure that channel "sc" is readable
+        write1(peer);
+
+        try (Selector sel = Selector.open()) {
+            SelectionKey key = sc.register(sel, 0);
+            sel.selectNow();
+
+            // test all transitions
+            for (int from: OPS) {
+                for (int to: OPS) {
+
+                    System.out.println(toOpsString(from) + " -> " + toOpsString(to));
+
+                    testChange(key, from, to);
+
+                    // if the interst ops is now 0 then Selector should not spin
+                    if (to == 0)
+                        testForSpin(sel);
+
+                    // if interest ops is now OP_READ then make non-readable
+                    // and test that Selector does not spin.
+                    if (to == OP_READ) {
+                        System.out.println("Drain channel...");
+                        drain(sc);
+                        testForSpin(sel);
+                        System.out.println("Make channel readable again");
+                        write1(peer);
+                    }
+
+                    System.out.println();
+                }
+            }
+
+        } finally {
+            sc.close();
+            peer.close();
+            ssc.close();
+        }
+    }
+
+    static void assertTrue(boolean v, String msg) {
+        if (!v) throw new RuntimeException(msg);
+    }
+
+}
--- jdk/test/java/nio/channels/Selector/Connect.java	2012-08-10 10:34:30.000000000 -0700
+++ jdk/test/java/nio/channels/Selector/Connect.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,12 +27,11 @@
  * @library ..
  */
 
-import java.io.*;
 import java.net.*;
 import java.nio.*;
 import java.nio.channels.*;
-import java.util.*;
 import java.nio.channels.spi.SelectorProvider;
+import java.util.*;
 
 public class Connect {
 
@@ -40,12 +39,18 @@
     static int LIMIT = 100;
 
     public static void main(String[] args) throws Exception {
-        scaleTest();
+        try (TestServers.DayTimeServer daytimeServer
+                = TestServers.DayTimeServer.startNewServer(50)) {
+            scaleTest(daytimeServer);
+        }
     }
 
-    public static void scaleTest() throws Exception {
-        InetAddress myAddress=InetAddress.getByName(TestUtil.HOST);
-        InetSocketAddress isa = new InetSocketAddress(myAddress,13);
+    static void scaleTest(TestServers.DayTimeServer daytimeServer)
+        throws Exception
+    {
+        InetAddress myAddress = daytimeServer.getAddress();
+        InetSocketAddress isa
+            = new InetSocketAddress(myAddress, daytimeServer.getPort());
 
         for (int j=0; j<LIMIT; j++) {
             SocketChannel sc = SocketChannel.open();
--- jdk/test/java/nio/channels/Selector/ConnectWrite.java	2012-08-10 10:34:30.000000000 -0700
+++ jdk/test/java/nio/channels/Selector/ConnectWrite.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,23 +27,25 @@
  * @library ..
  */
 
-import java.io.*;
 import java.net.*;
-import java.nio.*;
 import java.nio.channels.*;
-import java.util.*;
 import java.nio.channels.spi.SelectorProvider;
+import java.util.*;
 
 public class ConnectWrite {
 
     public static void main(String[] args) throws Exception {
-        test1(13);
+        try (TestServers.DayTimeServer daytimeServer
+                = TestServers.DayTimeServer.startNewServer(25)) {
+            test1(daytimeServer);
+        }
     }
 
-    public static void test1(int port) throws Exception {
+    static void test1(TestServers.DayTimeServer daytimeServer) throws Exception {
         Selector selector = SelectorProvider.provider().openSelector();
-        InetAddress myAddress=InetAddress.getByName(TestUtil.HOST);
-        InetSocketAddress isa = new InetSocketAddress(myAddress, port);
+        InetAddress myAddress = daytimeServer.getAddress();
+        InetSocketAddress isa
+            = new InetSocketAddress(myAddress, daytimeServer.getPort());
         SocketChannel sc = SocketChannel.open();
         try {
             sc.configureBlocking(false);
--- jdk/test/java/nio/channels/Selector/KeysReady.java	2012-08-10 10:34:30.000000000 -0700
+++ jdk/test/java/nio/channels/Selector/KeysReady.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,21 +28,15 @@
  */
 
 import java.net.*;
-import java.io.*;
-import java.nio.*;
 import java.nio.channels.*;
-import java.nio.charset.*;
 import java.nio.channels.spi.SelectorProvider;
 
 public class KeysReady {
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
-
-    static void test() throws Exception {
+    static void test(TestServers.DayTimeServer dayTimeServer) throws Exception {
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(dayTimeServer.getAddress(),
+                                    dayTimeServer.getPort());
         SocketChannel sc = SocketChannel.open();
         sc.configureBlocking(false);
         sc.connect(isa);
@@ -64,7 +58,10 @@
     }
 
     public static void main(String[] args) throws Exception {
-        test();
+        try (TestServers.DayTimeServer daytimeServer
+                = TestServers.DayTimeServer.startNewServer(50)) {
+            test(daytimeServer);
+        }
     }
 
 }
--- jdk/test/java/nio/channels/SocketChannel/AdaptSocket.java	2012-08-10 10:34:30.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/AdaptSocket.java	2013-05-05 09:38:43.000000000 -0700
@@ -35,19 +35,16 @@
 
     static java.io.PrintStream out = System.out;
 
-    static final int ECHO_PORT = 7;
-    static final int DAYTIME_PORT = 13;
-    static final String REMOTE_HOST = TestUtil.HOST;
-    static final String VERY_REMOTE_HOST = TestUtil.FAR_HOST;
-
-    static void test(String hn, int timeout, boolean shouldTimeout)
+    static void test(TestServers.DayTimeServer dayTimeServer,
+                     int timeout,
+                     boolean shouldTimeout)
         throws Exception
     {
         out.println();
 
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(hn),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(dayTimeServer.getAddress(),
+                                    dayTimeServer.getPort());
         SocketChannel sc = SocketChannel.open();
         Socket so = sc.socket();
         out.println("opened: " + so);
@@ -116,13 +113,16 @@
         }
     }
 
-    static void testRead(String hn, int timeout, boolean shouldTimeout)
+    static void testRead(TestServers.EchoServer echoServer,
+                         int timeout,
+                         boolean shouldTimeout)
         throws Exception
     {
         out.println();
 
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(hn), ECHO_PORT);
+            = new InetSocketAddress(echoServer.getAddress(),
+                                    echoServer.getPort());
         SocketChannel sc = SocketChannel.open();
         sc.connect(isa);
         Socket so = sc.socket();
@@ -134,22 +134,38 @@
         out.println("timeout: " + so.getSoTimeout());
 
         testRead(so, shouldTimeout);
-        for (int i = 0; i < 4; i++)
+        for (int i = 0; i < 4; i++) {
             testRead(so, shouldTimeout);
+        }
 
         sc.close();
     }
 
     public static void main(String[] args) throws Exception {
 
-        test(REMOTE_HOST, 0, false);
-        test(REMOTE_HOST, 1000, false);
-        test(VERY_REMOTE_HOST, 10, true);
-
-        testRead(REMOTE_HOST, 0, false);
-        testRead(REMOTE_HOST, 8000, false);
-        testRead(VERY_REMOTE_HOST, 10, true);
+        try (TestServers.DayTimeServer dayTimeServer
+                = TestServers.DayTimeServer.startNewServer()) {
+            test(dayTimeServer, 0, false);
+            test(dayTimeServer, 1000, false);
+        }
 
-    }
+        try (TestServers.DayTimeServer lingerDayTimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            // this test no longer really test the connection timeout
+            // since there is no way to prevent the server from eagerly
+            // accepting connection...
+            test(lingerDayTimeServer, 10, true);
+        }
 
+        try (TestServers.EchoServer echoServer
+                = TestServers.EchoServer.startNewServer()) {
+            testRead(echoServer, 0, false);
+            testRead(echoServer, 8000, false);
+        }
+
+        try (TestServers.EchoServer lingerEchoServer
+                = TestServers.EchoServer.startNewServer(100)) {
+            testRead(lingerEchoServer, 10, true);
+        }
+    }
 }
--- jdk/test/java/nio/channels/SocketChannel/Basic.java	2012-08-10 10:34:30.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/Basic.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,13 +36,10 @@
 
     static java.io.PrintStream out = System.out;
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
-
-    static void test() throws Exception {
+    static void test(TestServers.DayTimeServer daytimeServer) throws Exception {
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(daytimeServer.getAddress(),
+                                    daytimeServer.getPort());
         SocketChannel sc = SocketChannel.open(isa);
         out.println("opened: " + sc);
         /*
@@ -76,7 +73,10 @@
     }
 
     public static void main(String[] args) throws Exception {
-        test();
+        try (TestServers.DayTimeServer dayTimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            test(dayTimeServer);
+        }
     }
 
 }
--- jdk/test/java/nio/channels/SocketChannel/BufferSize.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/BufferSize.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,17 +28,10 @@
  */
 
 import java.nio.channels.*;
-import java.net.*;
 
 public class BufferSize {
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
-
     public static void main(String[] args) throws Exception {
-        InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
         ServerSocketChannel sc = ServerSocketChannel.open();
         try {
             sc.socket().setReceiveBufferSize(-1);
--- jdk/test/java/nio/channels/SocketChannel/Connect.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/Connect.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@
  * @library ..
  */
 
+import java.net.*;
 import java.nio.*;
 import java.nio.channels.*;
-import java.net.*;
 import java.util.*;
 
 public class Connect {
@@ -37,21 +37,26 @@
     private static final long INCREMENTAL_DELAY = 30L * 1000L;
 
     public static void main(String args[]) throws Exception {
-        test1(TestUtil.HOST);
+        try (TestServers.EchoServer echoServer
+                = TestServers.EchoServer.startNewServer(1000)) {
+            test1(echoServer);
+        }
         try {
-            test1(TestUtil.REFUSING_HOST);
+            TestServers.RefusingServer refusingServer
+                = TestServers.RefusingServer.startNewServer();
+            test1(refusingServer);
             throw new Exception("Refused connection throws no exception");
         } catch (ConnectException ce) {
             // Correct result
         }
     }
 
-    static void test1(String hostname) throws Exception {
+    static void test1(TestServers.AbstractServer server) throws Exception {
         Selector selector;
         SocketChannel sc;
         SelectionKey sk;
         InetSocketAddress isa = new InetSocketAddress(
-            InetAddress.getByName (hostname), 80);
+            server.getAddress(), server.getPort());
         sc = SocketChannel.open();
         sc.configureBlocking(false);
 
--- jdk/test/java/nio/channels/SocketChannel/ConnectState.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/ConnectState.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,20 +30,39 @@
 import java.net.*;
 import java.nio.*;
 import java.nio.channels.*;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
 
 
 public class ConnectState {
 
     static PrintStream log = System.err;
 
-    static String REMOTE_HOST = TestUtil.HOST;
-    static int REMOTE_PORT = 7;                         // echo
     static InetSocketAddress remote;
 
     final static int ST_UNCONNECTED = 0;
     final static int ST_PENDING = 1;
     final static int ST_CONNECTED = 2;
     final static int ST_CLOSED = 3;
+    final static int ST_PENDING_OR_CONNECTED = 4;
+    // NO exceptions expected
+    final static Collection<Class<?>> NONE = Collections.emptySet();
+
+    // make a set of expected exception.
+    static Collection<Class<?>> expectedExceptions(Class<?>... expected) {
+        final Collection<Class<?>> exceptions;
+        if (expected.length == 0) {
+            exceptions = NONE;
+        } else if (expected.length == 1) {
+            assert expected[0] != null;
+            exceptions = Collections.<Class<?>>singleton(expected[0]);
+        } else {
+            exceptions = new HashSet<>(Arrays.asList(expected));
+        }
+        return exceptions;
+    }
 
     static abstract class Test {
 
@@ -76,37 +95,65 @@
                 check(!sc.isConnectionPending(), "!isConnectionPending");
                 check(sc.isOpen(), "isOpen");
                 break;
+            case ST_PENDING_OR_CONNECTED:
+                check(sc.isConnected() || sc.isConnectionPending(),
+                        "isConnected || isConnectionPending");
+                check(sc.isOpen(), "isOpen");
+                break;
             }
         }
 
-        Test(String name, Class exception, int state) throws Exception {
+        Test(String name, Class<?> exception, int state) throws Exception {
+            this(name, expectedExceptions(exception), state);
+        }
+
+        // On some architecture we may need to accept several exceptions.
+        // For instance on Solaris, when using a server colocated on the
+        // machine we cannot guarantee that we will get a
+        // ConnectionPendingException when connecting twice on the same
+        // non-blocking socket. We may instead get a an
+        // AlreadyConnectedException, which is also valid: it simply means
+        // that the first connection has been immediately accepted.
+        Test(String name, Collection<Class<?>> exceptions, int state)
+                throws Exception {
             SocketChannel sc = SocketChannel.open();
-            String note = null;
+            String note;
             try {
                 try {
                     note = go(sc);
                 } catch (Exception x) {
-                    if (exception != null) {
+                    Class<?> expectedExceptionClass = null;
+                    for (Class<?> exception : exceptions) {
                         if (exception.isInstance(x)) {
                             log.println(name + ": As expected: "
                                         + x);
+                            expectedExceptionClass = exception;
                             check(sc, state);
-                            return;
-                        } else {
-                            throw new Exception(name
+                            break;
+                        }
+                    }
+                    if (expectedExceptionClass == null
+                            && !exceptions.isEmpty()) {
+                        // we had an exception, but it's not of the set of
+                        // exceptions we expected.
+                        throw new Exception(name
                                                 + ": Incorrect exception",
                                                 x);
-                        }
-                    } else {
+                    } else if (exceptions.isEmpty()) {
+                        // we didn't expect any exception
                         throw new Exception(name
                                             + ": Unexpected exception",
                                             x);
                     }
+                    // if we reach here, we have our expected exception
+                    assert expectedExceptionClass != null;
+                    return;
                 }
-                if (exception != null)
+                if (!exceptions.isEmpty()) {
                     throw new Exception(name
                                         + ": Expected exception not thrown: "
-                                        + exception);
+                                        + exceptions.iterator().next());
+                }
                 check(sc, state);
                 log.println(name + ": Returned normally"
                             + ((note != null) ? ": " + note : ""));
@@ -123,6 +170,7 @@
 
         new Test("Read unconnected", NotYetConnectedException.class,
                  ST_UNCONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     ByteBuffer b = ByteBuffer.allocateDirect(1024);
                     sc.read(b);
@@ -131,19 +179,22 @@
 
         new Test("Write unconnected", NotYetConnectedException.class,
                  ST_UNCONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     ByteBuffer b = ByteBuffer.allocateDirect(1024);
                     sc.write(b);
                     return null;
                 }};
 
-        new Test("Simple connect", null, ST_CONNECTED) {
+        new Test("Simple connect", NONE, ST_CONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.connect(remote);
                     return null;
                 }};
 
-        new Test("Simple connect & finish", null, ST_CONNECTED) {
+        new Test("Simple connect & finish", NONE, ST_CONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.connect(remote);
                     if (!sc.finishConnect())
@@ -153,6 +204,7 @@
 
         new Test("Double connect",
                  AlreadyConnectedException.class, ST_CONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.connect(remote);
                     sc.connect(remote);
@@ -161,12 +213,16 @@
 
         new Test("Finish w/o start",
                  NoConnectionPendingException.class, ST_UNCONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.finishConnect();
                     return null;
                 }};
 
-        new Test("NB simple connect", null, ST_CONNECTED) {
+        // Note: using our local EchoServer rather than echo on a distant
+        //       host - we see that Tries to finish = 0 (instead of ~ 18).
+        new Test("NB simple connect", NONE, ST_CONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.configureBlocking(false);
                     sc.connect(remote);
@@ -179,8 +235,15 @@
                     return ("Tries to finish = " + n);
                 }};
 
+        // Note: using our local EchoServer rather than echo on a distant
+        //       host - we cannot guarantee that this test will get a
+        //       a ConnectionPendingException: it may get an
+        //       AlreadyConnectedException, so we should allow for both.
         new Test("NB double connect",
-                 ConnectionPendingException.class, ST_PENDING) {
+                 expectedExceptions(ConnectionPendingException.class,
+                                    AlreadyConnectedException.class),
+                 ST_PENDING_OR_CONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.configureBlocking(false);
                     sc.connect(remote);
@@ -190,13 +253,15 @@
 
         new Test("NB finish w/o start",
                  NoConnectionPendingException.class, ST_UNCONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.configureBlocking(false);
                     sc.finishConnect();
                     return null;
                 }};
 
-        new Test("NB connect, B finish", null, ST_CONNECTED) {
+        new Test("NB connect, B finish", NONE, ST_CONNECTED) {
+                @Override
                 String go(SocketChannel sc) throws Exception {
                     sc.configureBlocking(false);
                     sc.connect(remote);
@@ -208,9 +273,12 @@
     }
 
     public static void main(String[] args) throws Exception {
-        remote = new InetSocketAddress(InetAddress.getByName(REMOTE_HOST),
-                                       REMOTE_PORT);
-        tests();
+        try (TestServers.EchoServer echoServer
+                = TestServers.EchoServer.startNewServer(500)) {
+            remote = new InetSocketAddress(echoServer.getAddress(),
+                                           echoServer.getPort());
+            tests();
+        }
     }
 
 }
--- jdk/test/java/nio/channels/SocketChannel/FinishConnect.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/FinishConnect.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,21 +36,25 @@
 
 public class FinishConnect {
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
-
     public static void main(String[] args) throws Exception {
-        test1(true, true);
-        test1(true, false);
-        test1(false, true);
-        test1(false, false);
-        test2();
+        try (TestServers.DayTimeServer dayTimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            test1(dayTimeServer, true, true);
+            test1(dayTimeServer, true, false);
+            test1(dayTimeServer, false, true);
+            test1(dayTimeServer, false, false);
+            test2(dayTimeServer);
+        }
     }
 
-    static void test1(boolean select, boolean setBlocking) throws Exception {
+    static void test1(TestServers.DayTimeServer daytimeServer,
+                      boolean select,
+                      boolean setBlocking)
+        throws Exception
+    {
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(daytimeServer.getAddress(),
+                                    daytimeServer.getPort());
         SocketChannel sc = SocketChannel.open();
         sc.configureBlocking(false);
         boolean connected = sc.connect(isa);
@@ -109,15 +113,27 @@
         sc.close();
     }
 
-    static void test2() throws Exception {
+    static void test2(TestServers.DayTimeServer daytimeServer) throws Exception {
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(daytimeServer.getAddress(),
+                                    daytimeServer.getPort());
         boolean done = false;
         int globalAttempts = 0;
+        int connectSuccess = 0;
         while (!done) {
-            if (globalAttempts++ > 50)
+            // When using a local daytime server it is not always possible
+            // to get a pending connection, as sc.connect(isa) may always
+            // return true.
+            // So we're going to throw the exception only if there was
+            // at least 1 case where we did not manage to connect.
+            if (globalAttempts++ > 50) {
+                if (globalAttempts == connectSuccess + 1) {
+                    System.out.println("Can't fully test on "
+                            + System.getProperty("os.name"));
+                    break;
+                }
                 throw new RuntimeException("Failed to connect");
+            }
             SocketChannel sc = SocketChannel.open();
             sc.configureBlocking(false);
             boolean connected = sc.connect(isa);
@@ -132,6 +148,9 @@
                 }
                 Thread.sleep(10);
             }
+            if (connected) {
+                connectSuccess++;
+            }
             sc.close();
         }
     }
--- jdk/test/java/nio/channels/SocketChannel/IsConnectable.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/IsConnectable.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,24 +28,19 @@
  */
 
 import java.net.*;
-import java.io.*;
-import java.nio.*;
 import java.nio.channels.*;
 import java.nio.channels.spi.SelectorProvider;
 import java.util.*;
 
 public class IsConnectable {
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
-
-    static void test() throws Exception {
+    static void test(TestServers.DayTimeServer daytimeServer) throws Exception {
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(daytimeServer.getAddress(),
+                                    daytimeServer.getPort());
         SocketChannel sc = SocketChannel.open();
         sc.configureBlocking(false);
-        sc.connect(isa);
+        final boolean immediatelyConnected = sc.connect(isa);
 
         Selector selector = SelectorProvider.provider().openSelector();
         try {
@@ -67,7 +62,12 @@
                         throw new Exception("Test failed: 4737146 detected");
                 }
             } else {
-                throw new Exception("Select failed");
+                if (!immediatelyConnected) {
+                    throw new Exception("Select failed");
+                } else {
+                    System.out.println("IsConnectable couldn't be fully tested for "
+                            + System.getProperty("os.name"));
+                }
             }
         } finally {
             sc.close();
@@ -76,7 +76,10 @@
     }
 
     public static void main(String[] args) throws Exception {
-        test();
+        try (TestServers.DayTimeServer daytimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            test(daytimeServer);
+        }
     }
 
 }
--- jdk/test/java/nio/channels/SocketChannel/LocalAddress.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/LocalAddress.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,18 +28,20 @@
  */
 
 import java.net.*;
-import java.nio.*;
 import java.nio.channels.*;
 
 public class LocalAddress {
     public static void main(String[] args) throws Exception {
-        test1();
+        try (TestServers.EchoServer echoServer
+                = TestServers.EchoServer.startNewServer()) {
+            test1(echoServer);
+        }
     }
 
-    static void test1() throws Exception {
+    static void test1(TestServers.AbstractServer server) throws Exception {
         InetAddress bogus = InetAddress.getByName("0.0.0.0");
         InetSocketAddress saddr = new InetSocketAddress(
-            InetAddress.getByName(TestUtil.HOST), 23);
+            server.getAddress(), server.getPort());
 
         //Test1: connect only
         SocketChannel sc = SocketChannel.open();
--- jdk/test/java/nio/channels/SocketChannel/Stream.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/Stream.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,22 +27,17 @@
  * @library ..
  */
 
-import java.net.*;
 import java.io.*;
-import java.nio.*;
+import java.net.*;
 import java.nio.channels.*;
-import java.nio.charset.*;
 
 
 public class Stream {
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
-
-    static void test() throws Exception {
+    static void test(TestServers.DayTimeServer daytimeServer) throws Exception {
         InetSocketAddress isa
-            = new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+            = new InetSocketAddress(daytimeServer.getAddress(),
+                                    daytimeServer.getPort());
         SocketChannel sc = SocketChannel.open();
         sc.connect(isa);
         sc.configureBlocking(false);
@@ -58,7 +53,9 @@
     }
 
     public static void main(String[] args) throws Exception {
-        test();
+        try (TestServers.DayTimeServer dayTimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            test(dayTimeServer);
+        }
     }
-
 }
--- jdk/test/java/nio/channels/SocketChannel/VectorParams.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/SocketChannel/VectorParams.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,31 +27,31 @@
  * @library ..
  */
 
-import java.net.*;
 import java.io.*;
+import java.net.*;
 import java.nio.*;
 import java.nio.channels.*;
-import java.nio.charset.*;
 
 public class VectorParams {
 
     static java.io.PrintStream out = System.out;
 
-    static final int DAYTIME_PORT = 13;
-    static final String DAYTIME_HOST = TestUtil.HOST;
     static final int testSize = 10;
     static ByteBuffer[] bufs = null;
     static InetSocketAddress isa = null;
 
     public static void main(String[] args) throws Exception {
-        initBufs();
-        testSocketChannelVectorParams();
-        testDatagramChannelVectorParams();
-        testPipeVectorParams();
-        testFileVectorParams();
+        try (TestServers.DayTimeServer daytimeServer
+                = TestServers.DayTimeServer.startNewServer(100)) {
+            initBufs(daytimeServer);
+            testSocketChannelVectorParams();
+            testDatagramChannelVectorParams();
+            testPipeVectorParams();
+            testFileVectorParams();
+        }
     }
 
-    static void initBufs() throws Exception {
+    static void initBufs(TestServers.DayTimeServer daytimeServer) throws Exception {
         bufs = new ByteBuffer[testSize];
         for(int i=0; i<testSize; i++) {
             String source = "buffer" + i;
@@ -59,8 +59,8 @@
             bufs[i].put(source.getBytes("8859_1"));
             bufs[i].flip();
         }
-        isa =  new InetSocketAddress(InetAddress.getByName(DAYTIME_HOST),
-                                    DAYTIME_PORT);
+        isa = new InetSocketAddress(daytimeServer.getAddress(),
+                                    daytimeServer.getPort());
     }
 
     static void testSocketChannelVectorParams() throws Exception {
--- jdk/test/java/nio/channels/TestServers.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/nio/channels/TestServers.java	2013-05-05 09:38:43.000000000 -0700
@@ -0,0 +1,849 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* Test utility classes
+ *
+ */
+
+import java.io.*;
+import java.net.*;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+
+public class TestServers {
+
+    private TestServers() { }
+
+    /**
+     * An abstract server identifies a server which listens on a port on on a
+     * given machine.
+     */
+    static abstract class AbstractServer {
+
+        private AbstractServer() {
+        }
+
+        public abstract int getPort();
+
+        public abstract InetAddress getAddress();
+    }
+
+    /**
+     * A downgraded type of AbstractServer which will refuse connections. Note:
+     * use it once and throw it away - this implementation opens an anonymous
+     * socket and closes it, returning the address of the closed socket. If
+     * other servers are started afterwards, the address/port might get reused
+     * and become connectable again - so it's not a good idea to assume that
+     * connections using this address/port will always be refused. Connections
+     * will be refused as long as the address/port of the refusing server has
+     * not been reused.
+     */
+    static class RefusingServer extends AbstractServer {
+
+        final InetAddress address;
+        final int port;
+
+        private RefusingServer(InetAddress address, int port) {
+            this.address = address;
+            this.port = port;
+        }
+
+        @Override
+        public int getPort() {
+            return port;
+        }
+
+        @Override
+        public InetAddress getAddress() {
+            return address;
+        }
+
+        public static RefusingServer startNewServer() throws IOException {
+            ServerSocket socket = new ServerSocket(0, 100,
+                    InetAddress.getLocalHost());
+            RefusingServer server = new RefusingServer(socket.getInetAddress(),
+                    socket.getLocalPort());
+            socket.close();
+            return server;
+        }
+    }
+
+    /**
+     * An abstract class for implementing small TCP servers for the nio tests
+     * purposes. Disclaimer: This is a naive implementation that uses the old
+     * networking APIs (not those from {@code java.nio.*}) and shamelessly
+     * extends/creates Threads instead of using an executor service.
+     */
+    static abstract class AbstractTcpServer extends AbstractServer
+            implements Runnable, Closeable {
+
+        protected final long linger; // #of ms to wait before responding
+        private Thread acceptThread; // thread waiting for accept
+        // list of opened connections that should be closed on close.
+        private List<TcpConnectionThread> connections = new ArrayList<>();
+        private ServerSocket serverSocket; // the server socket
+        private boolean started = false; // whether the server is started
+        Throwable error = null;
+
+        /**
+         * Creates a new abstract TCP server.
+         *
+         * @param linger the amount of time the server should wait before
+         * responding to requests.
+         */
+        protected AbstractTcpServer(long linger) {
+            this.linger = linger;
+        }
+
+        /**
+         * The local port to which the server is bound.
+         *
+         * @return The local port to which the server is bound.
+         * @exception IllegalStateException is thrown if the server is not
+         * started.
+         */
+        @Override
+        public final synchronized int getPort() {
+            if (!started) {
+                throw new IllegalStateException("Not started");
+            }
+            return serverSocket.getLocalPort();
+        }
+
+        /**
+         * The local address to which the server is bound.
+         *
+         * @return The local address to which the server is bound.
+         * @exception IllegalStateException is thrown if the server is not
+         * started.
+         */
+        @Override
+        public final synchronized InetAddress getAddress() {
+            if (!started) {
+                throw new IllegalStateException("Not started");
+            }
+            return serverSocket.getInetAddress();
+        }
+
+        /**
+         * Tells whether the server is started.
+         *
+         * @return true if the server is started.
+         */
+        public final synchronized boolean isStarted() {
+            return started;
+        }
+
+        /**
+         * Creates a new server socket.
+         *
+         * @param port local port to bind to.
+         * @param backlog requested maximum length of the queue of incoming
+         * connections.
+         * @param address local address to bind to.
+         * @return a new bound server socket ready to accept connections.
+         * @throws IOException if the socket cannot be created or bound.
+         */
+        protected ServerSocket newServerSocket(int port, int backlog,
+                InetAddress address)
+                throws IOException {
+            return new ServerSocket(port, backlog, address);
+        }
+
+        /**
+         * Starts listening for connections.
+         *
+         * @throws IOException if the server socket cannot be created or bound.
+         */
+        public final synchronized void start() throws IOException {
+            if (started) {
+                return;
+            }
+            final ServerSocket socket =
+                    newServerSocket(0, 100, InetAddress.getLocalHost());
+            serverSocket = socket;
+            acceptThread = new Thread(this);
+            acceptThread.setDaemon(true);
+            acceptThread.start();
+            started = true;
+        }
+
+        /**
+         * Calls {@code Thread.sleep(linger);}
+         */
+        protected final void lingerIfRequired() {
+            if (linger > 0) {
+                try {
+                    Thread.sleep(linger);
+                } catch (InterruptedException x) {
+                    Thread.interrupted();
+                    final ServerSocket socket = serverSocket();
+                    if (socket != null && !socket.isClosed()) {
+                        System.err.println("Thread interrupted...");
+                    }
+                }
+            }
+        }
+
+        final synchronized ServerSocket serverSocket() {
+            return this.serverSocket;
+        }
+
+        /**
+         * The main accept loop.
+         */
+        @Override
+        public final void run() {
+            final ServerSocket sSocket = serverSocket();
+            try {
+                Socket s;
+                while (isStarted() && !Thread.interrupted()
+                        && (s = sSocket.accept()) != null) {
+                    lingerIfRequired();
+                    listen(s);
+                }
+            } catch (Exception x) {
+                error = x;
+            } finally {
+                synchronized (this) {
+                    if (!sSocket.isClosed()) {
+                        try {
+                            sSocket.close();
+                        } catch (IOException x) {
+                            System.err.println("Failed to close server socket");
+                        }
+                    }
+                    if (started && this.serverSocket == sSocket) {
+                        started = false;
+                        this.serverSocket = null;
+                        this.acceptThread = null;
+                    }
+                }
+            }
+        }
+
+        /**
+         * Represents a connection accepted by the server.
+         */
+        protected abstract class TcpConnectionThread extends Thread {
+
+            protected final Socket socket;
+
+            protected TcpConnectionThread(Socket socket) {
+                this.socket = socket;
+                this.setDaemon(true);
+            }
+
+            public void close() throws IOException {
+                socket.close();
+                interrupt();
+            }
+        }
+
+        /**
+         * Creates a new TcpConnnectionThread to handle the connection through
+         * an accepted socket.
+         *
+         * @param s the socket returned by {@code serverSocket.accept()}.
+         * @return a new TcpConnnectionThread to handle the connection through
+         * an accepted socket.
+         */
+        protected abstract TcpConnectionThread createConnection(Socket s);
+
+        /**
+         * Creates and starts a new TcpConnectionThread to handle the accepted
+         * socket.
+         *
+         * @param s the socket returned by {@code serverSocket.accept()}.
+         */
+        private synchronized void listen(Socket s) {
+            TcpConnectionThread c = createConnection(s);
+            c.start();
+            addConnection(c);
+        }
+
+        /**
+         * Add the connection to the list of accepted connections.
+         *
+         * @param connection an accepted connection.
+         */
+        protected synchronized void addConnection(
+                TcpConnectionThread connection) {
+            connections.add(connection);
+        }
+
+        /**
+         * Remove the connection from the list of accepted connections.
+         *
+         * @param connection an accepted connection.
+         */
+        protected synchronized void removeConnection(
+                TcpConnectionThread connection) {
+            connections.remove(connection);
+        }
+
+        /**
+         * Close the server socket and all the connections present in the list
+         * of accepted connections.
+         *
+         * @throws IOException
+         */
+        @Override
+        public synchronized void close() throws IOException {
+            if (serverSocket != null && !serverSocket.isClosed()) {
+                serverSocket.close();
+            }
+            if (acceptThread != null) {
+                acceptThread.interrupt();
+            }
+            int failed = 0;
+            for (TcpConnectionThread c : connections) {
+                try {
+                    c.close();
+                } catch (IOException x) {
+                    // no matter - we're closing.
+                    failed++;
+                }
+            }
+            connections.clear();
+            if (failed > 0) {
+                throw new IOException("Failed to close some connections");
+            }
+        }
+    }
+
+    /**
+     * A small TCP Server that emulates the echo service for tests purposes. See
+     * http://en.wikipedia.org/wiki/Echo_Protocol This server uses an anonymous
+     * port - NOT the standard port 7. We don't guarantee that its behavior
+     * exactly matches the RFC - the only purpose of this server is to have
+     * something that responds to nio tests...
+     */
+    static final class EchoServer extends AbstractTcpServer {
+
+        public EchoServer() {
+            this(0L);
+        }
+
+        public EchoServer(long linger) {
+            super(linger);
+        }
+
+        @Override
+        protected TcpConnectionThread createConnection(Socket s) {
+            return new EchoConnection(s);
+        }
+
+        private final class EchoConnection extends TcpConnectionThread {
+
+            public EchoConnection(Socket socket) {
+                super(socket);
+            }
+
+            @Override
+            public void run() {
+                try {
+                    final InputStream is = socket.getInputStream();
+                    final OutputStream out = socket.getOutputStream();
+                    byte[] b = new byte[255];
+                    int n;
+                    while ((n = is.read(b)) > 0) {
+                        lingerIfRequired();
+                        out.write(b, 0, n);
+                    }
+                } catch (IOException io) {
+                    // fall through to finally
+                } finally {
+                    if (!socket.isClosed()) {
+                        try {
+                            socket.close();
+                        } catch (IOException x) {
+                            System.err.println(
+                                    "Failed to close echo connection socket");
+                        }
+                    }
+                    removeConnection(this);
+                }
+            }
+        }
+
+        public static EchoServer startNewServer() throws IOException {
+            return startNewServer(0);
+        }
+
+        public static EchoServer startNewServer(long linger) throws IOException {
+            final EchoServer echoServer = new EchoServer(linger);
+            echoServer.start();
+            return echoServer;
+        }
+    }
+
+    /**
+     * A small TCP server that emulates the Day & Time service for tests
+     * purposes. See http://en.wikipedia.org/wiki/Daytime_Protocol This server
+     * uses an anonymous port - NOT the standard port 13. We don't guarantee
+     * that its behavior exactly matches the RFC - the only purpose of this
+     * server is to have something that responds to nio tests...
+     */
+    static final class DayTimeServer extends AbstractTcpServer {
+
+        public DayTimeServer() {
+            this(0L);
+        }
+
+        public DayTimeServer(long linger) {
+            super(linger);
+        }
+
+        @Override
+        protected TcpConnectionThread createConnection(Socket s) {
+            return new DayTimeServerConnection(s);
+        }
+
+        @Override
+        protected void addConnection(TcpConnectionThread connection) {
+            // do nothing - the connection just write the date and terminates.
+        }
+
+        @Override
+        protected void removeConnection(TcpConnectionThread connection) {
+            // do nothing - we're not adding connections to the list...
+        }
+
+        private final class DayTimeServerConnection extends TcpConnectionThread {
+
+            public DayTimeServerConnection(Socket socket) {
+                super(socket);
+            }
+
+            @Override
+            public void run() {
+                try {
+                    final OutputStream out = socket.getOutputStream();
+                    lingerIfRequired();
+                    out.write(new Date(System.currentTimeMillis())
+                            .toString().getBytes("US-ASCII"));
+                    out.flush();
+                } catch (IOException io) {
+                    // fall through to finally
+                } finally {
+                    if (!socket.isClosed()) {
+                        try {
+                            socket.close();
+                        } catch (IOException x) {
+                            System.err.println(
+                                    "Failed to close echo connection socket");
+                        }
+                    }
+                }
+            }
+        }
+
+        public static DayTimeServer startNewServer()
+                throws IOException {
+            return startNewServer(0);
+        }
+
+        public static DayTimeServer startNewServer(long linger)
+                throws IOException {
+            final DayTimeServer daytimeServer = new DayTimeServer(linger);
+            daytimeServer.start();
+            return daytimeServer;
+        }
+    }
+
+    /**
+     * An abstract class for implementing small UDP Servers for the nio tests
+     * purposes. Disclaimer: This is a naive implementation that uses the old
+     * networking APIs (not those from {@code java.nio.*}) and shamelessly
+     * extends/creates Threads instead of using an executor service.
+     */
+    static abstract class AbstractUdpServer extends AbstractServer
+            implements Runnable, Closeable {
+
+        protected final long linger; // #of ms to wait before responding
+        private Thread acceptThread; // thread waiting for packets
+        private DatagramSocket serverSocket; // the server socket
+        private boolean started = false; // whether the server is started
+        Throwable error = null;
+
+        /**
+         * Creates a new abstract UDP server.
+         *
+         * @param linger the amount of time the server should wait before
+         * responding to requests.
+         */
+        protected AbstractUdpServer(long linger) {
+            this.linger = linger;
+        }
+
+        /**
+         * The local port to which the server is bound.
+         *
+         * @return The local port to which the server is bound.
+         * @exception IllegalStateException is thrown if the server is not
+         * started.
+         */
+        @Override
+        public final synchronized int getPort() {
+            if (!started) {
+                throw new IllegalStateException("Not started");
+            }
+            return serverSocket.getLocalPort();
+        }
+
+        /**
+         * The local address to which the server is bound.
+         *
+         * @return The local address to which the server is bound.
+         * @exception IllegalStateException is thrown if the server is not
+         * started.
+         */
+        @Override
+        public final synchronized InetAddress getAddress() {
+            if (!started) {
+                throw new IllegalStateException("Not started");
+            }
+            return serverSocket.getLocalAddress();
+        }
+
+        /**
+         * Tells whether the server is started.
+         *
+         * @return true if the server is started.
+         */
+        public final synchronized boolean isStarted() {
+            return started;
+        }
+
+        /**
+         * Creates a new datagram socket.
+         *
+         * @param port local port to bind to.
+         * @param address local address to bind to.
+         * @return a new bound server socket ready to listen for packets.
+         * @throws IOException if the socket cannot be created or bound.
+         */
+        protected DatagramSocket newDatagramSocket(int port,
+                InetAddress address)
+                throws IOException {
+            return new DatagramSocket(port, address);
+        }
+
+        /**
+         * Starts listening for connections.
+         *
+         * @throws IOException if the server socket cannot be created or bound.
+         */
+        public final synchronized void start() throws IOException {
+            if (started) {
+                return;
+            }
+            final DatagramSocket socket =
+                    newDatagramSocket(0, InetAddress.getLocalHost());
+            serverSocket = socket;
+            acceptThread = new Thread(this);
+            acceptThread.setDaemon(true);
+            acceptThread.start();
+            started = true;
+        }
+
+        /**
+         * Calls {@code Thread.sleep(linger);}
+         */
+        protected final void lingerIfRequired() {
+            if (linger > 0) {
+                try {
+                    Thread.sleep(linger);
+                } catch (InterruptedException x) {
+                    Thread.interrupted();
+                    final DatagramSocket socket = serverSocket();
+                    if (socket != null && !socket.isClosed()) {
+                        System.err.println("Thread interrupted...");
+                    }
+                }
+            }
+        }
+
+        final synchronized DatagramSocket serverSocket() {
+            return this.serverSocket;
+        }
+
+        final synchronized boolean send(DatagramSocket socket,
+                DatagramPacket response) throws IOException {
+            if (!socket.isClosed()) {
+                socket.send(response);
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        /**
+         * The main receive loop.
+         */
+        @Override
+        public final void run() {
+            final DatagramSocket sSocket = serverSocket();
+            try {
+                final int size = Math.max(1024, sSocket.getReceiveBufferSize());
+                if (size > sSocket.getReceiveBufferSize()) {
+                    sSocket.setReceiveBufferSize(size);
+                }
+                while (isStarted() && !Thread.interrupted() && !sSocket.isClosed()) {
+                    final byte[] buf = new byte[size];
+                    final DatagramPacket packet =
+                            new DatagramPacket(buf, buf.length);
+                    lingerIfRequired();
+                    sSocket.receive(packet);
+                    //System.out.println("Received packet from: "
+                    //        + packet.getAddress()+":"+packet.getPort());
+                    handle(sSocket, packet);
+                }
+            } catch (Exception x) {
+                error = x;
+            } finally {
+                synchronized (this) {
+                    if (!sSocket.isClosed()) {
+                        sSocket.close();
+                    }
+                    if (started && this.serverSocket == sSocket) {
+                        started = false;
+                        this.serverSocket = null;
+                        this.acceptThread = null;
+                    }
+                }
+            }
+        }
+
+        /**
+         * Represents an UDP request received by the server.
+         */
+        protected abstract class UdpRequestThread extends Thread {
+
+            protected final DatagramPacket request;
+            protected final DatagramSocket socket;
+
+            protected UdpRequestThread(DatagramSocket socket, DatagramPacket request) {
+                this.socket = socket;
+                this.request = request;
+                this.setDaemon(true);
+            }
+        }
+
+        /**
+         * Creates a new UdpRequestThread to handle a DatagramPacket received
+         * through a DatagramSocket.
+         *
+         * @param socket the socket through which the request was received.
+         * @param request the datagram packet received through the socket.
+         * @return a new UdpRequestThread to handle the request received through
+         * a DatagramSocket.
+         */
+        protected abstract UdpRequestThread createConnection(DatagramSocket socket,
+                DatagramPacket request);
+
+        /**
+         * Creates and starts a new UdpRequestThread to handle the received
+         * datagram packet.
+         *
+         * @param socket the socket through which the request was received.
+         * @param request the datagram packet received through the socket.
+         */
+        private synchronized void handle(DatagramSocket socket,
+                DatagramPacket request) {
+            UdpRequestThread c = createConnection(socket, request);
+            // c can be null if the request requires no response.
+            if (c != null) {
+                c.start();
+            }
+        }
+
+        /**
+         * Close the server socket.
+         *
+         * @throws IOException
+         */
+        @Override
+        public synchronized void close() throws IOException {
+            if (serverSocket != null && !serverSocket.isClosed()) {
+                serverSocket.close();
+            }
+            if (acceptThread != null) {
+                acceptThread.interrupt();
+            }
+        }
+    }
+
+    /**
+     * A small UDP Server that emulates the discard service for tests purposes.
+     * See http://en.wikipedia.org/wiki/Discard_Protocol This server uses an
+     * anonymous port - NOT the standard port 9. We don't guarantee that its
+     * behavior exactly matches the RFC - the only purpose of this server is to
+     * have something that responds to nio tests...
+     */
+    static final class UdpDiscardServer extends AbstractUdpServer {
+
+        public UdpDiscardServer() {
+            this(0L);
+        }
+
+        public UdpDiscardServer(long linger) {
+            super(linger);
+        }
+
+        @Override
+        protected UdpRequestThread createConnection(DatagramSocket socket,
+                DatagramPacket request) {
+            // no response required
+            return null;
+        }
+
+        public static UdpDiscardServer startNewServer() throws IOException {
+            return startNewServer(0);
+        }
+
+        public static UdpDiscardServer startNewServer(long linger) throws IOException {
+            final UdpDiscardServer discardServer = new UdpDiscardServer(linger);
+            discardServer.start();
+            return discardServer;
+        }
+    }
+
+    /**
+     * A small UDP Server that emulates the echo service for tests purposes. See
+     * http://en.wikipedia.org/wiki/Echo_Protocol This server uses an anonymous
+     * port - NOT the standard port 7. We don't guarantee that its behavior
+     * exactly matches the RFC - the only purpose of this server is to have
+     * something that responds to nio tests...
+     */
+    static final class UdpEchoServer extends AbstractUdpServer {
+
+        public UdpEchoServer() {
+            this(0L);
+        }
+
+        public UdpEchoServer(long linger) {
+            super(linger);
+        }
+
+        @Override
+        protected UdpEchoRequest createConnection(DatagramSocket socket,
+                DatagramPacket request) {
+            return new UdpEchoRequest(socket, request);
+        }
+
+        private final class UdpEchoRequest extends UdpRequestThread {
+
+            public UdpEchoRequest(DatagramSocket socket, DatagramPacket request) {
+                super(socket, request);
+            }
+
+            @Override
+            public void run() {
+                try {
+                    lingerIfRequired();
+                    final DatagramPacket response =
+                            new DatagramPacket(request.getData(),
+                                    request.getOffset(), request.getLength(),
+                                    request.getAddress(), request.getPort());
+                    send(socket, response);
+                } catch (IOException io) {
+                    System.err.println("Failed to send response: " + io);
+                    io.printStackTrace(System.err);
+                }
+            }
+        }
+
+        public static UdpEchoServer startNewServer() throws IOException {
+            return startNewServer(0);
+        }
+
+        public static UdpEchoServer startNewServer(long linger) throws IOException {
+            final UdpEchoServer echoServer = new UdpEchoServer(linger);
+            echoServer.start();
+            return echoServer;
+        }
+    }
+
+    /**
+     * A small UDP server that emulates the Day & Time service for tests
+     * purposes. See http://en.wikipedia.org/wiki/Daytime_Protocol This server
+     * uses an anonymous port - NOT the standard port 13. We don't guarantee
+     * that its behavior exactly matches the RFC - the only purpose of this
+     * server is to have something that responds to nio tests...
+     */
+    static final class UdpDayTimeServer extends AbstractUdpServer {
+
+        public UdpDayTimeServer() {
+            this(0L);
+        }
+
+        public UdpDayTimeServer(long linger) {
+            super(linger);
+        }
+
+        @Override
+        protected UdpDayTimeRequestThread createConnection(DatagramSocket socket,
+                DatagramPacket request) {
+            return new UdpDayTimeRequestThread(socket, request);
+        }
+
+        private final class UdpDayTimeRequestThread extends UdpRequestThread {
+
+            public UdpDayTimeRequestThread(DatagramSocket socket,
+                    DatagramPacket request) {
+                super(socket, request);
+            }
+
+            @Override
+            public void run() {
+                try {
+                    lingerIfRequired();
+                    final byte[] data = new Date(System.currentTimeMillis())
+                            .toString().getBytes("US-ASCII");
+                    final DatagramPacket response =
+                            new DatagramPacket(data, 0, data.length,
+                                    request.getAddress(), request.getPort());
+                    send(socket, response);
+                } catch (IOException io) {
+                    System.err.println("Failed to send response: " + io);
+                    io.printStackTrace(System.err);
+                }
+            }
+        }
+
+        public static UdpDayTimeServer startNewServer() throws IOException {
+            return startNewServer(0);
+        }
+
+        public static UdpDayTimeServer startNewServer(long linger)
+                throws IOException {
+            final UdpDayTimeServer echoServer = new UdpDayTimeServer(linger);
+            echoServer.start();
+            return echoServer;
+        }
+    }
+}
--- jdk/test/java/nio/channels/TestUtil.java	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/TestUtil.java	2013-05-05 09:38:43.000000000 -0700
@@ -27,7 +27,6 @@
 
 import java.io.*;
 import java.net.*;
-import java.nio.*;
 import java.nio.channels.*;
 import java.util.Random;
 
@@ -36,9 +35,6 @@
 
     // Test hosts used by the channels tests - change these when
     // executing in a different network.
-    public static final String HOST = "javaweb.sfbay.sun.com";
-    public static final String REFUSING_HOST = "jano1.sfbay.sun.com";
-    public static final String FAR_HOST = "irejano.ireland.sun.com";
     public static final String UNRESOLVABLE_HOST = "blah-blah.blah-blah.blah";
 
     private TestUtil() { }
--- jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/Makefile	2012-08-10 10:34:31.000000000 -0700
+++ jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/Makefile	2013-05-05 09:38:43.000000000 -0700
@@ -71,6 +71,48 @@
   EXTRA_LIBS = -lc
 endif
 
+ifeq ($(uname), Darwin)
+  PLATFORM = bsd
+  archExpr = case "`$(UNAME) -m`" in  \
+		i[3-6]86) \
+                    $(ECHO) i586 \
+                    ;; \
+		sparc*)	 \
+                    $(ECHO) sparc \
+                    ;; \
+		*) \
+                    $(UNAME) -m	 \
+                    ;; \
+	   esac
+  ARCH	    := $(shell $(archExpr) )
+  CC = gcc
+  CFLAGS = -fno-strict-aliasing -fPIC -W -Wall
+  LD = ld
+  LDFLAGS_COMMON = -shared
+  EXTRA_LIBS = -lc
+endif
+
+ifeq ($(findstring BSD,$(uname)), BSD)
+  PLATFORM = bsd
+  archExpr = case "`$(UNAME) -m`" in  \
+		i[3-6]86) \
+                    $(ECHO) i586 \
+                    ;; \
+		sparc*)	 \
+                    $(ECHO) sparc \
+                    ;; \
+		*) \
+                    $(UNAME) -m	 \
+                    ;; \
+	   esac
+  ARCH	    := $(shell $(archExpr) )
+  CC = gcc
+  CFLAGS = -fno-strict-aliasing -fPIC -W -Wall
+  LD = ld
+  LDFLAGS_COMMON = -shared
+  EXTRA_LIBS = -lc
+endif
+
 LIBDIR=lib/$(PLATFORM)-$(ARCH)
 LAUNCHERLIB=$(LIBDIR)/libLauncher.so
 
--- jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/run_tests.sh	2012-08-10 10:34:32.000000000 -0700
+++ jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/run_tests.sh	2013-05-05 09:38:43.000000000 -0700
@@ -33,11 +33,14 @@
 # @run shell run_tests.sh
 
 os=`uname -s`
-
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    SunOS | Linux | *BSD | Darwin )
+        ;;
+    * )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 
 # if TESTJAVA isn't set then we assume an interactive run. So that it's
@@ -67,7 +70,8 @@
 # On Solaris we assume 64-bit if java -d64 works.
 
 DFLAG=
-if [ "$os" = "SunOS" ]; then
+case "${os}" in
+  SunOS )
     PLATFORM=solaris
     case "`uname -p`" in
 	i[3-9]86) 
@@ -84,9 +88,9 @@
 	    fi
 	    ;;
     esac 
-fi
+    ;;
 
-if [ "$os" = "Linux" ]; then
+  Linux )
     PLATFORM=linux
     ARCH=unknown
     case "`uname -m`" in
@@ -100,7 +104,24 @@
 	    ARCH=amd64
 	    ;;
     esac
-fi
+    ;;
+
+  *BSD | Darwin )
+    PLATFORM=bsd
+    ARCH=unknown
+    case "`uname -m`" in
+	i[3-6]86)
+	    ARCH=i586
+	    ;;
+	ia64)
+	    ARCH=ia64
+	    ;;
+	x86_64)
+	    ARCH=amd64
+	    ;;
+    esac
+    ;;
+esac
 
 LIBDIR=lib/${PLATFORM}-${ARCH}
 LAUNCHERLIB=${LIBDIR}/libLauncher.so
--- jdk/test/java/nio/charset/Charset/default.sh	2012-08-10 10:34:32.000000000 -0700
+++ jdk/test/java/nio/charset/Charset/default.sh	2013-05-05 09:38:43.000000000 -0700
@@ -41,10 +41,14 @@
 fi
 
 s="`uname -s`"
-if [ "$s" != Linux -a "$s" != SunOS ]; then
-  echo "$s: locale command not supported on this system, skipping..."
-  exit 0
-fi
+case "$s" in
+  Linux|SunOS|*BSD|Darwin)
+    ;;
+  *)
+    echo "$s: locale command not supported on this system, skipping..."
+    exit 0
+    ;;
+esac
 
 JAVA=$TESTJAVA/bin/java
 
--- jdk/test/java/nio/charset/coders/CheckSJISMappingProp.sh	2012-08-10 10:34:32.000000000 -0700
+++ jdk/test/java/nio/charset/coders/CheckSJISMappingProp.sh	2013-05-05 09:38:43.000000000 -0700
@@ -34,7 +34,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin ) ;;
+  SunOS | Linux | *BSD | Darwin ) ;;
   # Skip locale test for Windows
   Windows* )
     echo "Passed"; exit 0 ;;
--- jdk/test/java/nio/charset/spi/basic.sh	2012-08-10 10:34:32.000000000 -0700
+++ jdk/test/java/nio/charset/spi/basic.sh	2013-05-05 09:38:43.000000000 -0700
@@ -70,10 +70,14 @@
     L="$1"
     shift
     s=`uname -s`
-    if [ $s != Linux -a $s != SunOS -a $s != Darwin ]; then
-      echo "$L: Locales not supported on this system, skipping..."
-      exit 0
-    fi
+    case "$s" in
+      Linux|SunOS|*BSD|Darwin)
+        ;;
+      *)
+        echo "$L: Locales not supported on this system, skipping..."
+        exit 0
+       ;;
+    esac
     if [ "x`locale -a | grep $L`" != "x$L" ]; then
       echo "$L: Locale not supported, skipping..."
       exit 0
@@ -85,7 +89,7 @@
 cd $TMP
 
 case `uname` in
-  SunOS | Linux | Darwin ) CPS=':' ;;
+  SunOS | Linux | *BSD | Darwin ) CPS=':' ;;
   Windows* )      CPS=';' ;;
   *)              echo "Unknown platform: `uname`"; exit 1 ;;
 esac
--- jdk/test/java/nio/file/FileSystem/Basic.java	2012-08-10 10:34:32.000000000 -0700
+++ jdk/test/java/nio/file/FileSystem/Basic.java	2013-05-05 09:38:43.000000000 -0700
@@ -76,6 +76,8 @@
             checkSupported(fs, "posix", "unix", "owner", "acl", "user");
         if (os.equals("Linux"))
             checkSupported(fs, "posix", "unix", "owner", "dos", "user");
+        if (os.endsWith("BSD"))
+            checkSupported(fs, "posix", "unix", "owner");
         if (os.contains("OS X"))
             checkSupported(fs, "posix", "unix", "owner");
         if (os.equals("Windows"))
--- jdk/test/java/nio/file/Files/CopyAndMove.java	2012-08-10 10:34:32.000000000 -0700
+++ jdk/test/java/nio/file/Files/CopyAndMove.java	2013-05-05 09:38:43.000000000 -0700
@@ -634,7 +634,7 @@
 
                 // check POSIX attributes are copied
                 String os = System.getProperty("os.name");
-                if (os.equals("SunOS") || os.equals("Linux")) {
+                if (os.equals("SunOS") || os.equals("Linux") || os.endsWith("BSD")) {
                     checkPosixAttributes(
                         readAttributes(source, PosixFileAttributes.class, linkOptions),
                         readAttributes(target, PosixFileAttributes.class, linkOptions));
@@ -1136,7 +1136,7 @@
     static void randomizeAttributes(Path file) throws IOException {
         String os = System.getProperty("os.name");
         boolean isWindows = os.startsWith("Windows");
-        boolean isUnix = os.equals("SunOS") || os.equals("Linux");
+        boolean isUnix = os.equals("SunOS") || os.equals("Linux") || os.endsWith("BSD");
         boolean isDirectory = isDirectory(file, NOFOLLOW_LINKS);
 
         if (isUnix) {
--- jdk/test/java/rmi/MarshalledObject/compare/Compare.java	2012-08-10 10:34:33.000000000 -0700
+++ jdk/test/java/rmi/MarshalledObject/compare/Compare.java	2013-05-05 09:38:43.000000000 -0700
@@ -29,7 +29,6 @@
  *          not involved in location should be compared.
  * @author Ken Arnold
  *
- * @build Compare
  * @run main Compare 11 annotatedRef
  */
 
--- jdk/test/java/rmi/MarshalledObject/compare/HashCode.java	2012-08-10 10:34:33.000000000 -0700
+++ jdk/test/java/rmi/MarshalledObject/compare/HashCode.java	2013-05-05 09:38:43.000000000 -0700
@@ -27,7 +27,6 @@
  * @summary MarshalledObject with null throws NullPointerException
  * @author Ken Arnold
  *
- * @build HashCode
  * @run main HashCode 11 annotatedRef
  */
 
--- jdk/test/java/rmi/MarshalledObject/compare/NullReference.java	2012-08-10 10:34:33.000000000 -0700
+++ jdk/test/java/rmi/MarshalledObject/compare/NullReference.java	2013-05-05 09:38:43.000000000 -0700
@@ -27,7 +27,6 @@
  * @summary MarshalledObject with null throws NullPointerException
  * @author Ken Arnold
  *
- * @build NullReference
  * @run main NullReference
  */
 
--- jdk/test/java/rmi/Naming/DefaultRegistryPort.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/Naming/DefaultRegistryPort.java	2013-05-05 09:38:43.000000000 -0700
@@ -28,7 +28,6 @@
  * @author Dana Burns
  * @library ../testlibrary
  * @build TestLibrary
- * @build DefaultRegistryPort
  * @run main DefaultRegistryPort
  */
 
--- jdk/test/java/rmi/Naming/LookupIPv6.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/Naming/LookupIPv6.java	2013-05-05 09:38:43.000000000 -0700
@@ -22,12 +22,11 @@
  */
 
 /* @test
+ * @summary Ensure that java.rmi.Naming.lookup can handle URLs containing
+ *          IPv6 addresses.
  * @bug 4402708
  *
  * @run main/othervm -Djava.net.preferIPv6Addresses=true LookupIPv6
- *
- * @summary Ensure that java.rmi.Naming.lookup can handle URLs containing
- *          IPv6 addresses.
  */
 
 import java.net.InetAddress;
--- jdk/test/java/rmi/Naming/LookupNameWithColon.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/Naming/LookupNameWithColon.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,10 +25,13 @@
  * @bug 4387038
  * @summary Ensure that java.rmi.Naming.lookup functions properly for names
  *          containing embedded ':' characters.
+ *
+ * @library ../testlibrary
+ * @build TestLibrary
+ * @run main LookupNameWithColon
  */
 
 import java.rmi.Naming;
-import java.rmi.registry.LocateRegistry;
 import java.rmi.registry.Registry;
 
 public class LookupNameWithColon {
@@ -38,15 +41,12 @@
             "multiple:colons:in:name"
         };
 
-        Registry reg;
-        try {
-            reg = LocateRegistry.createRegistry(Registry.REGISTRY_PORT);
-        } catch (Exception ex) {
-            reg = LocateRegistry.getRegistry();
-        }
+        Registry reg = TestLibrary.createRegistryOnUnusedPort();
+        int port = TestLibrary.getRegistryPort(reg);
+
         for (int i = 0; i < names.length; i++) {
             reg.rebind(names[i], reg);
-            Naming.lookup("rmi://localhost/" + names[i]);
+            Naming.lookup("rmi://localhost:" + port + "/" + names[i]);
         }
     }
 }
--- jdk/test/java/rmi/Naming/RmiIsNoScheme.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/Naming/RmiIsNoScheme.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,7 +30,6 @@
  *
  * @library ../testlibrary
  * @build TestLibrary
- * @build RmiIsNoScheme
  * @run main/othervm RmiIsNoScheme
  */
 
@@ -39,9 +38,6 @@
 import java.rmi.registry.*;
 
 public class RmiIsNoScheme implements Remote, Serializable {
-
-    private static final int REGISTRY_PORT = 2002;
-
     private RmiIsNoScheme() {}
 
     public static void main(String[] args) {
@@ -49,10 +45,11 @@
         System.err.println("\nRegression test for bug 4626311\n");
 
         try {
-            LocateRegistry.createRegistry(REGISTRY_PORT);
-            Naming.rebind("//:" + REGISTRY_PORT + "/RmiIsNoScheme",
+            Registry registry = TestLibrary.createRegistryOnUnusedPort();
+            int registryPort = TestLibrary.getRegistryPort(registry);
+            Naming.rebind("//:" + registryPort + "/RmiIsNoScheme",
                           new RmiIsNoScheme());
-            String name = Naming.list("//:" + REGISTRY_PORT)[0];
+            String name = Naming.list("//:" + registryPort)[0];
             System.err.println("name = " + name);
             if (name.startsWith("rmi:", 0) == false) {
                 System.err.println("TEST PASSED: rmi scheme not present");
--- jdk/test/java/rmi/Naming/UnderscoreHost.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/Naming/UnderscoreHost.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,37 +1,36 @@
-/*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @bug 5083594
- * @summary Ensure that Naming.java correctly parses host names with '_' in
- * them.
- * @author Vinod Johnson
- *
- * @library ../testlibrary
- * @build TestLibrary
- * @build UnderscoreHost UnderscoreHost_Stub
- * @run main/othervm UnderscoreHost
+ /*
+  * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+  *
+  * This code is free software; you can redistribute it and/or modify it
+  * under the terms of the GNU General Public License version 2 only, as
+  * published by the Free Software Foundation.
+  *
+  * This code is distributed in the hope that it will be useful, but WITHOUT
+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  * version 2 for more details (a copy is included in the LICENSE file that
+  * accompanied this code).
+  *
+  * You should have received a copy of the GNU General Public License version
+  * 2 along with this work; if not, write to the Free Software Foundation,
+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+  *
+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+  * or visit www.oracle.com if you need additional information or have any
+  * questions.
+  */
+
+ /*
+  * @test
+  * @bug 5083594
+  * @summary Ensure that Naming.java correctly parses host names with '_' in
+  * them.
+  * @author Vinod Johnson
+  *
+  * @library ../testlibrary
+  * @build TestLibrary UnderscoreHost_Stub
+  * @run main/othervm UnderscoreHost
  */
 
 import java.io.IOException;
@@ -77,11 +76,12 @@
         try {
             HostVerifyingSocketFactory hvf = new HostVerifyingSocketFactory();
             RMISocketFactory.setSocketFactory(hvf);
-            Registry r = LocateRegistry.createRegistry(Registry.REGISTRY_PORT);
+            Registry r = TestLibrary.createRegistryOnUnusedPort();
+            int port = TestLibrary.getRegistryPort(r);
             t = new UnderscoreHost();
             r.rebind(NAME, t);
             Naming.lookup("rmi://" + HOSTNAME +
-                          ":" + Registry.REGISTRY_PORT + "/" + NAME);
+                          ":" + port + "/" + NAME);
             /*
              * This test is coded to pass whether java.net.URI obeys
              * RFC 2396 or RFC 3986 (see 5085902, 6394131, etc.).
--- jdk/test/java/rmi/Naming/legalRegistryNames/LegalRegistryNames.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/Naming/legalRegistryNames/LegalRegistryNames.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,14 +21,13 @@
  * questions.
  */
 
-/**
+/*
  * @test
  * @bug 4254808
  * @summary Naming assumes '/' is present in relative URL; change in URL causes regression
  * @author Dana Burns
  * @library ../../testlibrary
- * @build TestLibrary
- * @build Legal LegalRegistryNames LegalRegistryNames_Stub
+ * @build TestLibrary Legal LegalRegistryNames_Stub
  * @run main LegalRegistryNames
  */
 
@@ -45,7 +44,9 @@
 
 /**
  * Ensure that all legal forms of Naming URLs operate with the
- * java.rmi.Naming interface
+ * java.rmi.Naming interface.  This test requires using the default RMI Registry
+ * port as it tests all of the RMI naming URL's, including the ones which do not
+ * take a port (and therefore uses the default port).
  */
 public class LegalRegistryNames extends UnicastRemoteObject
     implements Legal
--- jdk/test/java/rmi/RMISecurityManager/checkPackageAccess/CheckPackageAccess.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/RMISecurityManager/checkPackageAccess/CheckPackageAccess.java	2013-05-05 09:38:43.000000000 -0700
@@ -28,10 +28,9 @@
  * as when the default java.lang.SecurityManager is set, which with the
  * default "java.security" file in the JDK means that access to packages in
  * the sun.* package hierarchy is denied (without explicit runtime permission
- * "accessClassInPackge.*").
+ * "accessClassInPackage.*").
  * @author Peter Jones
  *
- * @build CheckPackageAccess
  * @run main/othervm CheckPackageAccess
  */
 
--- jdk/test/java/rmi/activation/Activatable/checkActivateRef/CheckActivateRef.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkActivateRef/CheckActivateRef.java	2013-05-05 09:38:43.000000000 -0700
@@ -36,8 +36,7 @@
  *          functionality is in place
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID
- * @build ActivateMe CheckActivateRef_Stub CheckActivateRef
+ * @build TestLibrary RMID ActivateMe CheckActivateRef_Stub
  * @run main/othervm/policy=security.policy/timeout=240 -Djava.rmi.server.ignoreStubClasses=true CheckActivateRef
  * @run main/othervm/policy=security.policy/timeout=240 -Djava.rmi.server.ignoreStubClasses=false CheckActivateRef
  */
--- jdk/test/java/rmi/activation/Activatable/checkActivateRef/security.policy	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkActivateRef/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -29,11 +29,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/checkAnnotations/CheckAnnotations.java	2012-08-10 10:34:34.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkAnnotations/CheckAnnotations.java	2013-05-05 09:38:43.000000000 -0700
@@ -28,10 +28,7 @@
  * @author Laird Dornin; code borrowed from Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build MyRMI
- * @build CheckAnnotations
- * @build CheckAnnotations_Stub
+ * @build TestLibrary RMID MyRMI CheckAnnotations_Stub
  * @run main/othervm/policy=security.policy/timeout=480 CheckAnnotations
  */
 
--- jdk/test/java/rmi/activation/Activatable/checkAnnotations/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkAnnotations/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/checkImplClassLoader/CheckImplClassLoader.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkImplClassLoader/CheckImplClassLoader.java	2013-05-05 09:38:43.000000000 -0700
@@ -24,14 +24,11 @@
 /* @test
  * @bug 4289544
  * @summary ActivationGroupImpl.newInstance does not set context classloader for impl
- *
  * @author Laird Dornin; code borrowed from Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build MyRMI
- * @build CheckImplClassLoader ActivatableImpl
- * @build ActivatableImpl ActivatableImpl_Stub
+ * @build TestLibrary RMID
+ *     MyRMI ActivatableImpl ActivatableImpl ActivatableImpl_Stub
  * @run main/othervm/policy=security.policy/timeout=150 CheckImplClassLoader
  */
 
--- jdk/test/java/rmi/activation/Activatable/checkImplClassLoader/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkImplClassLoader/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -32,11 +32,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/checkRegisterInLog/CheckRegisterInLog.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkRegisterInLog/CheckRegisterInLog.java	2013-05-05 09:38:43.000000000 -0700
@@ -27,8 +27,8 @@
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build RMID ActivationLibrary TestLibrary
- * @build ActivateMe CheckRegisterInLog CheckRegisterInLog_Stub
+ * @build TestLibrary RMID ActivationLibrary
+ *     ActivateMe CheckRegisterInLog_Stub
  * @run main/othervm/policy=security.policy/timeout=240 CheckRegisterInLog
  */
 
--- jdk/test/java/rmi/activation/Activatable/checkRegisterInLog/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/checkRegisterInLog/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,17 +21,18 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
 
   // allow exporting of remote objects on an arbitrary port.
-  permission java.net.SocketPermission "*:1024-", "connect,accept";
+  permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
 
   // allow exporting object with non-public remote interface
   permission java.rmi.RMIPermission "exportRemoteInterface.ActivateMe";
--- jdk/test/java/rmi/activation/Activatable/createPrivateActivable/CreatePrivateActivatable.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/createPrivateActivable/CreatePrivateActivatable.java	2013-05-05 09:38:43.000000000 -0700
@@ -22,14 +22,12 @@
  */
 
 /* @test
- * @author Laird Dornin
  * @bug 4164971
  * @summary allow non-public activatable class and/or constructor
+ * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID
- * @build ActivateMe
- * @build CreatePrivateActivatable
+ * @build TestLibrary RMID ActivateMe
  * @run main/othervm/policy=security.policy/timeout=240 CreatePrivateActivatable
  */
 
--- jdk/test/java/rmi/activation/Activatable/createPrivateActivable/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/createPrivateActivable/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/downloadParameterClass/DownloadParameterClass.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/downloadParameterClass/DownloadParameterClass.java	2013-05-05 09:38:43.000000000 -0700
@@ -32,11 +32,7 @@
  *
  * @library ../../../testlibrary
  * @build TestLibrary RMID ActivationLibrary
- * @build DownloadParameterClass
- * @build Foo
- * @build FooReceiverImpl
- * @build FooReceiverImpl_Stub
- * @build Bar
+ *     Foo FooReceiverImpl FooReceiverImpl_Stub Bar
  * @run main/othervm/policy=security.policy/timeout=240 DownloadParameterClass
  */
 
--- jdk/test/java/rmi/activation/Activatable/downloadParameterClass/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/downloadParameterClass/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -31,11 +31,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // allow exporting of remote objects on an arbitrary port.
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
--- jdk/test/java/rmi/activation/Activatable/elucidateNoSuchMethod/ElucidateNoSuchMethod.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/elucidateNoSuchMethod/ElucidateNoSuchMethod.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,14 +23,11 @@
 
 /* @test
  * @bug 4128620
- *
  * @summary synopsis: NoSuchMethodError should be elucidated
- *
  * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID
- * @build ActivateMe ElucidateNoSuchMethod ElucidateNoSuchMethod_Stub
+ * @build TestLibrary RMID ActivateMe ElucidateNoSuchMethod_Stub
  * @run main/othervm/policy=security.policy/timeout=240 ElucidateNoSuchMethod
  */
 
--- jdk/test/java/rmi/activation/Activatable/elucidateNoSuchMethod/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/elucidateNoSuchMethod/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -30,11 +30,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/extLoadedImpl/ext.sh	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/extLoadedImpl/ext.sh	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -28,11 +28,25 @@
 # set to the impl's class loader) when the impl is activated.
 # @library ../../../testlibrary
 # @build TestLibrary RMID ActivationLibrary
-# @build ExtLoadedImplTest ExtLoadedImpl ExtLoadedImpl_Stub CheckLoader
+#     ExtLoadedImplTest ExtLoadedImpl ExtLoadedImpl_Stub CheckLoader
 # @run shell ext.sh
 
+OS=`uname -s`
+case "$OS" in
+  SunOS | Linux | Darwin )
+    PS=":"
+    ;;
+  Windows* | CYGWIN* )
+    PS=";"
+    ;;
+  * )
+    echo "Unrecognized system!"
+    exit 1;
+    ;;
+esac
+
 mkdir -p classes
-cp $TESTCLASSES/*.class classes
+for dir in `echo ${TESTCLASSPATH:-$TESTCLASSES} | sed -e "s/$PS/ /"` ; do cp $dir/*.class classes ; done
 rm classes/ExtLoadedImpl.class classes/ExtLoadedImpl_Stub.class classes/CheckLoader.class
 mkdir -p ext
 $TESTJAVA/bin/jar cf ext/ext.jar -C $TESTCLASSES ExtLoadedImpl.class -C $TESTCLASSES ExtLoadedImpl_Stub.class -C $TESTCLASSES CheckLoader.class
--- jdk/test/java/rmi/activation/Activatable/extLoadedImpl/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/extLoadedImpl/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -17,11 +17,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // allow exporting of remote objects on an arbitrary port.
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
--- jdk/test/java/rmi/activation/Activatable/forceLogSnapshot/ForceLogSnapshot.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/forceLogSnapshot/ForceLogSnapshot.java	2013-05-05 09:38:43.000000000 -0700
@@ -27,9 +27,8 @@
  * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build ActivateMe
- * @build ForceLogSnapshot
- * @build ForceLogSnapshot_Stub
+ * @build TestLibrary RMID ActivationLibrary
+ *     ActivateMe ForceLogSnapshot_Stub
  * @run main/othervm/policy=security.policy/timeout=640 ForceLogSnapshot
  */
 
--- jdk/test/java/rmi/activation/Activatable/forceLogSnapshot/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/forceLogSnapshot/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/inactiveGroup/InactiveGroup.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/inactiveGroup/InactiveGroup.java	2013-05-05 09:38:43.000000000 -0700
@@ -29,10 +29,7 @@
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID ActivationLibrary
- * @build ActivateMe
- * @build InactiveGroup
- * @build InactiveGroup_Stub
+ * @build TestLibrary RMID ActivationLibrary ActivateMe InactiveGroup_Stub
  * @run main/othervm/policy=security.policy/timeout=240 InactiveGroup
  */
 
--- jdk/test/java/rmi/activation/Activatable/inactiveGroup/security.policy	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/inactiveGroup/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,17 +21,18 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
 
   // allow exporting of remote objects on an arbitrary port.
-  permission java.net.SocketPermission "*:1024-", "connect,accept";
+  permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
 
   // allow exporting object with non-public remote interface
   permission java.rmi.RMIPermission "exportRemoteInterface.ActivateMe";
--- jdk/test/java/rmi/activation/Activatable/lookupActivationSystem/LookupActivationSystem.java	2012-08-10 10:34:35.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/lookupActivationSystem/LookupActivationSystem.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,14 +24,12 @@
 /*
  * @test
  * @bug 6245733
- *
  * @summary synopsis: rmid's registry's list operation doesn't include
  * activation system
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
  * @build TestLibrary RMID ActivationLibrary
- * @build LookupActivationSystem
  * @run main/othervm/timeout=240 LookupActivationSystem
  */
 
@@ -58,7 +56,7 @@
 
             System.err.println("look up activation system");
             Registry rmidRegistry =
-                LocateRegistry.getRegistry(ActivationSystem.SYSTEM_PORT);
+                LocateRegistry.getRegistry(rmid.getPort());
             ActivationSystem system = (ActivationSystem)
                 rmidRegistry.lookup(NAME);
 
--- jdk/test/java/rmi/activation/Activatable/nestedActivate/NestedActivate.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/nestedActivate/NestedActivate.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,15 +23,11 @@
 
 /* @test
  * @bug 4138056
- *
  * @summary synopsis: Activating objects from an Activatable constructor causes deadlock
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID ActivationLibrary
- * @build ActivateMe
- * @build NestedActivate
- * @build NestedActivate_Stub
+ * @build TestLibrary RMID ActivationLibrary ActivateMe NestedActivate_Stub
  * @run main/othervm/policy=security.policy/timeout=240 NestedActivate
  */
 
--- jdk/test/java/rmi/activation/Activatable/nestedActivate/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/nestedActivate/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,17 +21,18 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
 
   // allow exporting of remote objects on an arbitrary port.
-  permission java.net.SocketPermission "*:1024-", "connect,accept";
+  permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
 
   // allow exporting of non-public remote interface
   permission java.rmi.RMIPermission "exportRemoteInterface.ActivateMe";
--- jdk/test/java/rmi/activation/Activatable/nonExistentActivatable/NonExistentActivatable.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/nonExistentActivatable/NonExistentActivatable.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,16 +23,13 @@
 
 /* @test
  * @bug 4115296
- *
  * @summary synopsis: NoSuchObjectException not thrown for non-existent
  * activatable objects
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
  * @build TestLibrary RMID ActivationLibrary
- * @build ActivateMe
- * @build NonExistentActivatable
- * @build NonExistentActivatable_Stub
+ *     ActivateMe NonExistentActivatable_Stub
  * @run main/othervm/policy=security.policy/timeout=240 NonExistentActivatable
  */
 
--- jdk/test/java/rmi/activation/Activatable/nonExistentActivatable/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/nonExistentActivatable/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/restartCrashedService/RestartCrashedService.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/restartCrashedService/RestartCrashedService.java	2013-05-05 09:38:43.000000000 -0700
@@ -28,10 +28,7 @@
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build ActivateMe
- * @build RestartCrashedService
- * @build RestartCrashedService_Stub
+ * @build TestLibrary RMID ActivateMe RestartCrashedService_Stub
  * @run main/othervm/policy=security.policy/timeout=240 RestartCrashedService
  */
 
--- jdk/test/java/rmi/activation/Activatable/restartCrashedService/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/restartCrashedService/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/Activatable/restartLatecomer/RestartLatecomer.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/restartLatecomer/RestartLatecomer.java	2013-05-05 09:38:43.000000000 -0700
@@ -28,8 +28,7 @@
  *
  * @library ../../../testlibrary
  * @build TestLibrary RMID ActivationLibrary
- * @build RestartLatecomer
- * @build RestartLatecomer_Stub
+ *     RestartLatecomer RestartLatecomer_Stub
  * @run main/othervm/policy=security.policy/timeout=240 RestartLatecomer
  */
 
--- jdk/test/java/rmi/activation/Activatable/restartLatecomer/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/restartLatecomer/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Used in remote impl of Activator.inactive; by the method
   // "restartThread.dispose()"when it calls thread.interrupt()
--- jdk/test/java/rmi/activation/Activatable/restartService/RestartService.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/restartService/RestartService.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,15 +23,11 @@
 
 /* @test
  * @bug 4095165 4321151
-
  * @summary synopsis: activator should restart daemon services
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID ActivationLibrary
- * @build ActivateMe
- * @build RestartService
- * @build RestartService_Stub
+ * @build TestLibrary RMID ActivationLibrary ActivateMe RestartService_Stub
  * @run main/othervm/policy=security.policy/timeout=240 RestartService
  */
 
--- jdk/test/java/rmi/activation/Activatable/restartService/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/restartService/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Used in remote impl of Activator.inactive; by the method
   // "restartThread.dispose()"when it calls thread.interrupt()
--- jdk/test/java/rmi/activation/Activatable/shutdownGracefully/ShutdownGracefully.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/shutdownGracefully/ShutdownGracefully.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,11 +28,8 @@
  * @author Laird Dornin; code borrowed from Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build TestSecurityManager
- * @build RegisteringActivatable
- * @build ShutdownGracefully
- * @build ShutdownGracefully_Stub
+ * @build TestLibrary RMID
+ *     TestSecurityManager RegisteringActivatable ShutdownGracefully_Stub
  * @run main/othervm/policy=security.policy/timeout=700 ShutdownGracefully
  */
 
@@ -171,7 +168,7 @@
             registering = null;
 
             // Need to make sure that rmid goes away by itself
-            Process rmidProcess = rmid.getVM();
+            JavaVM rmidProcess = rmid;
             if (rmidProcess != null) {
                 try {
                     Runnable waitThread =
@@ -208,9 +205,9 @@
      * class that waits for rmid to exit
      */
     private static class ShutdownDetectThread implements Runnable {
-        private Process rmidProcess = null;
+        private JavaVM rmidProcess = null;
 
-        ShutdownDetectThread(Process rmidProcess) {
+        ShutdownDetectThread(JavaVM rmidProcess) {
             this.rmidProcess = rmidProcess;
         }
         public void run() {
--- jdk/test/java/rmi/activation/Activatable/shutdownGracefully/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/shutdownGracefully/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // allow exporting of remote objects on an arbitrary port.
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
--- jdk/test/java/rmi/activation/Activatable/unregisterInactive/UnregisterInactive.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/unregisterInactive/UnregisterInactive.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,16 +23,12 @@
 
 /* @test
  * @bug 4115331
-
  * @summary synopsis: activatable object fails to go inactive after
  * unregister/inactive sequence.
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID ActivationLibrary
- * @build ActivateMe
- * @build UnregisterInactive
- * @build UnregisterInactive_Stub
+ * @build TestLibrary RMID ActivationLibrary ActivateMe UnregisterInactive_Stub
  * @run main/othervm/policy=security.policy/timeout=240 UnregisterInactive
  */
 
--- jdk/test/java/rmi/activation/Activatable/unregisterInactive/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/Activatable/unregisterInactive/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // Needed to create an activation group
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/ActivateFailedException/activateFails/ActivateFails.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivateFailedException/activateFails/ActivateFails.java	2013-05-05 09:38:43.000000000 -0700
@@ -31,11 +31,8 @@
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build ActivateMe
- * @build ActivateFails
- * @build ActivateFails_Stub
- * @build ShutdownThread
+ * @build TestLibrary RMID ActivationLibrary
+ *     ActivateMe ActivateFails_Stub ShutdownThread
  * @run main/othervm/policy=security.policy/timeout=240 ActivateFails
  */
 
--- jdk/test/java/rmi/activation/ActivateFailedException/activateFails/security.policy	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivateFailedException/activateFails/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/ActivationGroup/downloadActivationGroup/DownloadActivationGroup.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationGroup/downloadActivationGroup/DownloadActivationGroup.java	2013-05-05 09:38:43.000000000 -0700
@@ -33,9 +33,7 @@
  *
  * @library ../../../testlibrary
  * @build TestLibrary RMID ActivationLibrary
- * @build MyActivationGroupImpl
- * @build DownloadActivationGroup
- * @build DownloadActivationGroup_Stub
+ *     DownloadActivationGroup MyActivationGroupImpl DownloadActivationGroup_Stub
  * @run main/othervm/policy=security.policy/timeout=240 DownloadActivationGroup
  */
 
--- jdk/test/java/rmi/activation/ActivationGroupDesc/checkDefaultGroupName/CheckDefaultGroupName.java	2012-08-10 10:34:36.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationGroupDesc/checkDefaultGroupName/CheckDefaultGroupName.java	2013-05-05 09:38:43.000000000 -0700
@@ -21,16 +21,15 @@
  * questions.
  */
 
-/**
+/*
  * @test
  * @bug 4252236
  * @summary ActivationGroupDesc should not do early binding of default classname
- * @library ../../../testlibrary
- *
- * @build CheckDefaultGroupName
+ * @author Laird Dornin
  *
+ * @library ../../../testlibrary
+ * @build TestLibrary
  * @run main CheckDefaultGroupName
- * @author Laird Dornin
  */
 
 import java.rmi.activation.*;
--- jdk/test/java/rmi/activation/ActivationSystem/activeGroup/IdempotentActiveGroup.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/activeGroup/IdempotentActiveGroup.java	2013-05-05 09:38:43.000000000 -0700
@@ -23,15 +23,13 @@
 
 /* @test
  * @bug 4720528
- *
  * @summary synopsis: (spec) ActivationSystem.activeGroup spec should be
  * relaxed (duplicate call to activeGroup with same instantiator and
  * incarnation should not throw ActivationException; it should succeed)
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID
- * @build IdempotentActiveGroup
+ * @build TestLibrary RMID ActivationLibrary
  * @run main/othervm/policy=security.policy/timeout=480 IdempotentActiveGroup
  */
 
--- jdk/test/java/rmi/activation/ActivationSystem/activeGroup/security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/activeGroup/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -15,11 +15,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // test needs to export rmid and communicate with objects on arbitrary ports
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
--- jdk/test/java/rmi/activation/ActivationSystem/modifyDescriptor/ModifyDescriptor.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/modifyDescriptor/ModifyDescriptor.java	2013-05-05 09:38:43.000000000 -0700
@@ -29,9 +29,8 @@
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build ActivateMe
- * @build ModifyDescriptor
- * @build ModifyDescriptor_Stub
+ * @build TestLibrary RMID ActivationLibrary
+ *     ActivateMe ModifyDescriptor_Stub
  * @run main/othervm/policy=security.policy/timeout=240 ModifyDescriptor
  */
 
--- jdk/test/java/rmi/activation/ActivationSystem/modifyDescriptor/security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/modifyDescriptor/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,11 +21,12 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/ActivationSystem/stubClassesPermitted/StubClassesPermitted.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/stubClassesPermitted/StubClassesPermitted.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,14 +24,11 @@
 /* @test
  * @bug 4179055
  * @summary Some java apps need to have access to read "accessClassInPackage.sun.rmi.server"
- *
  * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe ActivationLibrary
- * @build CanCreateStubs
- * @build StubClassesPermitted
- * @build StubClassesPermitted_Stub
+ * @build TestLibrary RMID ActivationLibrary
+ *     CanCreateStubs StubClassesPermitted_Stub
  * @run main/othervm/policy=security.policy/secure=java.lang.SecurityManager/timeout=240 StubClassesPermitted
  */
 
@@ -61,7 +58,7 @@
     extends Activatable implements Runnable, CanCreateStubs
 {
     public static boolean sameGroup = false;
-
+    private static int registryPort = -1;
     private static CanCreateStubs canCreateStubs = null;
     private static Registry registry = null;
 
@@ -76,8 +73,8 @@
         try {
             TestLibrary.suggestSecurityManager("java.lang.SecurityManager");
 
-            registry = java.rmi.registry.LocateRegistry.
-                createRegistry(TestLibrary.REGISTRY_PORT);
+            registry = TestLibrary.createRegistryOnUnusedPort();
+            registryPort = TestLibrary.getRegistryPort(registry);
 
             // must run with java.lang.SecurityManager or the test
             // result will be nullified if running with a build where
@@ -192,7 +189,7 @@
 
         // obtain reference to the test registry
         registry = java.rmi.registry.LocateRegistry.
-            getRegistry(TestLibrary.REGISTRY_PORT);
+            getRegistry(registryPort);
     }
 
     /**
--- jdk/test/java/rmi/activation/ActivationSystem/stubClassesPermitted/security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/stubClassesPermitted/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,15 +21,22 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
 
+  // required for test to get the registry port
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.registry";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.server";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.tcp";
+
   // test needs to export rmid and communicate with objects on arbitrary ports
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
 };
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/ActivateMe.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/ActivateMe.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,5 @@
 import java.rmi.RemoteException;
 interface ActivateMe extends Remote {
     public void ping() throws RemoteException;
-    public void unregister() throws Exception;
     public void shutdown() throws Exception;
-    public void justGoAway() throws RemoteException;
 }
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/CallbackInterface.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/CallbackInterface.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-import java.rmi.Remote;
-import java.rmi.RemoteException;
-public interface CallbackInterface extends Remote {
-    public void inc() throws RemoteException;
-    public int getNumDeactivated() throws RemoteException;
-}
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/Callback_Stub.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/Callback_Stub.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,122 +0,0 @@
-/*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-// Stub class generated by rmic, do not edit.
-// Contents subject to change without notice.
-
-public final class Callback_Stub
-    extends java.rmi.server.RemoteStub
-    implements CallbackInterface, java.rmi.Remote
-{
-    private static final java.rmi.server.Operation[] operations = {
-        new java.rmi.server.Operation("int getNumDeactivated()"),
-        new java.rmi.server.Operation("void inc()")
-    };
-
-    private static final long interfaceHash = -1008194523112388035L;
-
-    private static final long serialVersionUID = 2;
-
-    private static boolean useNewInvoke;
-    private static java.lang.reflect.Method $method_getNumDeactivated_0;
-    private static java.lang.reflect.Method $method_inc_1;
-
-    static {
-        try {
-            java.rmi.server.RemoteRef.class.getMethod("invoke",
-                new java.lang.Class[] {
-                    java.rmi.Remote.class,
-                    java.lang.reflect.Method.class,
-                    java.lang.Object[].class,
-                    long.class
-                });
-            useNewInvoke = true;
-            $method_getNumDeactivated_0 = CallbackInterface.class.getMethod("getNumDeactivated", new java.lang.Class[] {});
-            $method_inc_1 = CallbackInterface.class.getMethod("inc", new java.lang.Class[] {});
-        } catch (java.lang.NoSuchMethodException e) {
-            useNewInvoke = false;
-        }
-    }
-
-    // constructors
-    public Callback_Stub() {
-        super();
-    }
-    public Callback_Stub(java.rmi.server.RemoteRef ref) {
-        super(ref);
-    }
-
-    // methods from remote interfaces
-
-    // implementation of getNumDeactivated()
-    public int getNumDeactivated()
-        throws java.rmi.RemoteException
-    {
-        try {
-            if (useNewInvoke) {
-                Object $result = ref.invoke(this, $method_getNumDeactivated_0, null, -761062487639949912L);
-                return ((java.lang.Integer) $result).intValue();
-            } else {
-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);
-                ref.invoke(call);
-                int $result;
-                try {
-                    java.io.ObjectInput in = call.getInputStream();
-                    $result = in.readInt();
-                } catch (java.io.IOException e) {
-                    throw new java.rmi.UnmarshalException("error unmarshalling return", e);
-                } finally {
-                    ref.done(call);
-                }
-                return $result;
-            }
-        } catch (java.lang.RuntimeException e) {
-            throw e;
-        } catch (java.rmi.RemoteException e) {
-            throw e;
-        } catch (java.lang.Exception e) {
-            throw new java.rmi.UnexpectedException("undeclared checked exception", e);
-        }
-    }
-
-    // implementation of inc()
-    public void inc()
-        throws java.rmi.RemoteException
-    {
-        try {
-            if (useNewInvoke) {
-                ref.invoke(this, $method_inc_1, null, 4394985085384332959L);
-            } else {
-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);
-                ref.invoke(call);
-                ref.done(call);
-            }
-        } catch (java.lang.RuntimeException e) {
-            throw e;
-        } catch (java.rmi.RemoteException e) {
-            throw e;
-        } catch (java.lang.Exception e) {
-            throw new java.rmi.UnexpectedException("undeclared checked exception", e);
-        }
-    }
-}
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/UnregisterGroup.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/UnregisterGroup.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,57 +24,26 @@
 /* @test
  * @bug 4134233
  * @bug 4213186
- *
  * @summary synopsis: ActivationSystem.unregisterGroup should unregister objects in group
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build ActivateMe CallbackInterface
- * @build UnregisterGroup
- * @build UnregisterGroup_Stub
- * @build Callback_Stub
- * @run main/othervm/policy=security.policy/timeout=480 UnregisterGroup
+ * @build TestLibrary RMID ActivationLibrary ActivateMe
+ * @run main/othervm/policy=security.policy UnregisterGroup
  */
 
 import java.io.*;
 import java.rmi.*;
 import java.rmi.activation.*;
 import java.rmi.server.*;
-import java.rmi.registry.*;
 import java.util.Properties;
 
-class Callback extends UnicastRemoteObject implements CallbackInterface {
-
-  public static int num_deactivated = 0;
-
-  public Callback() throws RemoteException { super(); }
-
-  public void inc() throws RemoteException {
-    incNumDeactivated();
-  }
-
-  public synchronized int getNumDeactivated() throws RemoteException {
-    return(num_deactivated);
-  }
-
-  public synchronized void incNumDeactivated() {
-    num_deactivated++;
-  }
-
-}
-
-public class UnregisterGroup
-        extends Activatable
-        implements ActivateMe, Runnable
+public class UnregisterGroup extends Activatable implements ActivateMe
 {
-
-    private static Exception exception = null;
-    private static String error = null;
-    private static boolean done = false;
-    private static ActivateMe lastResortExitObj = null;
+    private static volatile Exception exception = null;
+    private static volatile String error = null;
+    private static volatile boolean done = false;
     private static final int NUM_OBJECTS = 10;
-    private static int PORT = 2006;
 
     public UnregisterGroup(ActivationID id, MarshalledObject mobj)
         throws Exception
@@ -82,55 +51,22 @@
         super(id, 0);
     }
 
-    public void ping()
-    {}
-
-    public void unregister() throws Exception {
-        super.unregister(super.getID());
-    }
-
-    /**
-     * Spawns a thread to deactivate the object.
-     */
-    public void shutdown() throws Exception {
-        (new Thread(this,"UnregisterGroup")).start();
-    }
-
     /**
-     * To support exiting of group VM as a last resort
+     * Does nothing, but serves to activate this object.
      */
-    public void justGoAway() {
-        System.exit(0);
-    }
+    public void ping() { }
 
     /**
-     * Thread to deactivate object. First attempts to make object
-     * inactive (via the inactive method).  If that fails (the
-     * object may still have pending/executing calls), then
-     * unexport the object forcibly.
+     * Deactivates the object. We need to unexport forcibly because
+     * this call is in-progress on this object, which is the same object
+     * that we are trying to deactivate.
      */
-    public void run() {
-
+    public void shutdown() throws Exception {
+        Activatable.unexportObject(this, true);
         ActivationLibrary.deactivate(this, getID());
-        System.err.println("\tActivationLibrary.deactivate returned");
-
-        try {
-            CallbackInterface cobj =
-                (CallbackInterface)Naming.lookup("//:" + PORT + "/Callback");
-            cobj.inc();
-        } catch (Exception e) {
-            System.err.println("cobj.inc exception");
-            e.printStackTrace();
-        }
-
     }
 
-    public static void main(String[] args) {
-
-        Registry registry;
-
-        System.err.println("\nRegression test for bug 4134233\n");
-
+    public static void main(String[] args) throws RemoteException {
         TestLibrary.suggestSecurityManager("java.rmi.RMISecurityManager");
         RMID rmid = null;
 
@@ -145,12 +81,8 @@
             final Properties p = new Properties();
             // this test must always set policies/managers in its
             // activation groups
-            p.put("java.security.policy",
-                  TestParams.defaultGroupPolicy);
-            p.put("java.security.manager",
-                  TestParams.defaultSecurityManager);
-
-            //final int NUM_OBJECTS = 10;
+            p.put("java.security.policy", TestParams.defaultGroupPolicy);
+            p.put("java.security.manager", TestParams.defaultSecurityManager);
 
             Thread t = new Thread() {
                 public void run () {
@@ -174,7 +106,6 @@
                             System.err.println("Activating object: " + i);
                             obj[i].ping();
                         }
-                        lastResortExitObj = obj[0];
 
                         System.err.println("Unregistering group");
                         system.unregisterGroup(groupID);
@@ -188,7 +119,6 @@
                                                "group unregistered");
                         }
 
-
                         /*
                          * Deactivate objects so group VM will exit.
                          */
@@ -197,7 +127,7 @@
                             obj[i].shutdown();
                             obj[i] = null;
                         }
-                        lastResortExitObj = null;
+                        System.err.println("Successfully deactivated all objects.");
 
                     } catch (Exception e) {
                         exception = e;
@@ -208,7 +138,11 @@
             };
 
             t.start();
-            t.join(120000);
+
+            // Default jtreg timeout is two minutes.
+            // Timeout ourselves after one minute so that
+            // we can clean up.
+            t.join(60000);
 
             if (exception != null) {
                 TestLibrary.bomb("test failed", exception);
@@ -219,42 +153,9 @@
             } else {
                 System.err.println("Test passed");
             }
-
-
         } catch (Exception e) {
             TestLibrary.bomb("test failed", e);
         } finally {
-            if (lastResortExitObj != null) {
-                try {
-                    lastResortExitObj.justGoAway();
-                } catch (Exception munch) {
-                }
-            }
-
-            // Wait for the object deactivation to take place first
-            try {
-
-                // create reg and export callback object
-                registry = LocateRegistry.createRegistry(PORT);
-                Callback robj = new Callback();
-                registry.bind("Callback", robj);
-
-                //get the callback object
-                int maxwait=30;
-                int nd = robj.getNumDeactivated();
-                while ((nd < NUM_OBJECTS) && (maxwait> 0)) {
-                    System.err.println("num_deactivated="+nd);
-                    try {
-                        Thread.sleep(1000);
-                    } catch (InterruptedException ie) {}
-                    maxwait--;
-                    nd = robj.getNumDeactivated();
-                }
-            } catch (Exception ce) {
-                System.err.println("E:"+ce);
-                ce.printStackTrace();
-            }
-
             ActivationLibrary.rmidCleanup(rmid);
         }
     }
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/UnregisterGroup_Stub.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/UnregisterGroup_Stub.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,144 +0,0 @@
-/*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-// Stub class generated by rmic, do not edit.
-// Contents subject to change without notice.
-
-public final class UnregisterGroup_Stub
-    extends java.rmi.server.RemoteStub
-    implements ActivateMe, java.rmi.Remote
-{
-    private static final java.rmi.server.Operation[] operations = {
-        new java.rmi.server.Operation("void justGoAway()"),
-        new java.rmi.server.Operation("void ping()"),
-        new java.rmi.server.Operation("void shutdown()"),
-        new java.rmi.server.Operation("void unregister()")
-    };
-
-    private static final long interfaceHash = -4733924075192691630L;
-
-    private static final long serialVersionUID = 2;
-
-    private static boolean useNewInvoke;
-    private static java.lang.reflect.Method $method_justGoAway_0;
-    private static java.lang.reflect.Method $method_ping_1;
-    private static java.lang.reflect.Method $method_shutdown_2;
-    private static java.lang.reflect.Method $method_unregister_3;
-
-    static {
-        try {
-            java.rmi.server.RemoteRef.class.getMethod("invoke",
-                new java.lang.Class[] {
-                    java.rmi.Remote.class,
-                    java.lang.reflect.Method.class,
-                    java.lang.Object[].class,
-                    long.class
-                });
-            useNewInvoke = true;
-            $method_justGoAway_0 = ActivateMe.class.getMethod("justGoAway", new java.lang.Class[] {});
-            $method_ping_1 = ActivateMe.class.getMethod("ping", new java.lang.Class[] {});
-            $method_shutdown_2 = ActivateMe.class.getMethod("shutdown", new java.lang.Class[] {});
-            $method_unregister_3 = ActivateMe.class.getMethod("unregister", new java.lang.Class[] {});
-        } catch (java.lang.NoSuchMethodException e) {
-            useNewInvoke = false;
-        }
-    }
-
-    // constructors
-    public UnregisterGroup_Stub() {
-        super();
-    }
-    public UnregisterGroup_Stub(java.rmi.server.RemoteRef ref) {
-        super(ref);
-    }
-
-    // methods from remote interfaces
-
-    // implementation of justGoAway()
-    public void justGoAway()
-        throws java.rmi.RemoteException
-    {
-        try {
-            if (useNewInvoke) {
-                ref.invoke(this, $method_justGoAway_0, null, -5382478058620783904L);
-            } else {
-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);
-                ref.invoke(call);
-                ref.done(call);
-            }
-        } catch (java.lang.RuntimeException e) {
-            throw e;
-        } catch (java.rmi.RemoteException e) {
-            throw e;
-        } catch (java.lang.Exception e) {
-            throw new java.rmi.UnexpectedException("undeclared checked exception", e);
-        }
-    }
-
-    // implementation of ping()
-    public void ping()
-        throws java.rmi.RemoteException
-    {
-        try {
-            if (useNewInvoke) {
-                ref.invoke(this, $method_ping_1, null, 5866401369815527589L);
-            } else {
-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);
-                ref.invoke(call);
-                ref.done(call);
-            }
-        } catch (java.lang.RuntimeException e) {
-            throw e;
-        } catch (java.rmi.RemoteException e) {
-            throw e;
-        } catch (java.lang.Exception e) {
-            throw new java.rmi.UnexpectedException("undeclared checked exception", e);
-        }
-    }
-
-    // implementation of shutdown()
-    public void shutdown()
-        throws java.lang.Exception
-    {
-        if (useNewInvoke) {
-            ref.invoke(this, $method_shutdown_2, null, -7207851917985848402L);
-        } else {
-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);
-            ref.invoke(call);
-            ref.done(call);
-        }
-    }
-
-    // implementation of unregister()
-    public void unregister()
-        throws java.lang.Exception
-    {
-        if (useNewInvoke) {
-            ref.invoke(this, $method_unregister_3, null, -5366864281862648102L);
-        } else {
-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 3, interfaceHash);
-            ref.invoke(call);
-            ref.done(call);
-        }
-    }
-}
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/group.security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/group.security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -7,4 +7,5 @@
 
   // test needs to communicate with the activation system
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
+  permission java.util.PropertyPermission "unregisterGroup.port", "read";
 };
--- jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/ActivationSystem/unregisterGroup/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -21,15 +21,22 @@
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
-  // used by TestLibrary to determine test environment 
+  // used by TestLibrary to determine test environment
   permission java.util.PropertyPermission "test.classes", "read";
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
 
   // test needs to export rmid and communicate with objects on arbitrary ports
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
+
+  // required for test to get the registry port
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.registry";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.server";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.tcp";
 };
--- jdk/test/java/rmi/activation/CommandEnvironment/NullOptions.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/CommandEnvironment/NullOptions.java	2013-05-05 09:38:43.000000000 -0700
@@ -27,7 +27,6 @@
  * ActivationGroupDesc.CommandEnvironment
  * @author  Ann Wollrath
  *
- * @build NullOptions
  * @run main/othervm/timeout=240 NullOptions
  */
 
--- jdk/test/java/rmi/activation/CommandEnvironment/SetChildEnv.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/CommandEnvironment/SetChildEnv.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2000, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,9 +35,10 @@
  * @author Adrian Colley
  *
  * @library ../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build Eliza Retireable Doctor Doctor_Stub SetChildEnv
- * @run main/othervm/timeout=240/policy=security.policy -Djava.compiler=NONE  SetChildEnv
+ * @build TestLibrary RMID ActivationLibrary
+ *     Eliza Retireable Doctor Doctor_Stub
+ * @run main/othervm/timeout=240/policy=security.policy
+ *     -Djava.compiler=NONE SetChildEnv
  */
 import java.rmi.*;
 import java.util.Properties;
@@ -53,31 +54,37 @@
     public static void main(String argv[])
         throws Exception
     {
+        int runningPort = TestLibrary.getUnusedRandomPort();
+
         System.out.println("java.compiler=" + System.getProperty("java.compiler"));
         // don't embed spaces in any of the test args/props, because
         // they won't be parsed properly
-        runwith (new String[0], new String[0]);
+        runwith (new String[0], new String[0], runningPort);
 
         runwith (
             new String[] { "-verbosegc" },
             new String[] { "foo.bar=SetChildEnvTest",
-                           "sun.rmi.server.doSomething=true" }
+                           "sun.rmi.server.doSomething=true" },
+            runningPort
             );
 
         runwith (
             new String[] { },
-            new String[] { "parameter.count=zero" }
+            new String[] { "parameter.count=zero" },
+            runningPort
             );
 
         runwith (
             new String[] { "-Xmx32m" },
-            new String[] { }
+            new String[] { },
+            runningPort
             );
     }
 
     private static void runwith(
         String[] params,        // extra args
-        String[] props          // extra system properties
+        String[] props,         // extra system properties
+        int port                // port on which to communicate
     )
         throws Exception
     {
@@ -89,7 +96,8 @@
 
         RMID.removeLog();
         RMID rmid = RMID.createRMID(watcher.otherEnd(), watcher.otherEnd(),
-                                    true); // debugExec turned on
+                                    true,  // debugExec turned on
+                                    true, port);
 
         rmid.start();
 
@@ -195,7 +203,7 @@
         actsys.unregisterGroup(gid);
 
         Thread.sleep(5000);
-        rmid.destroy();
+        ActivationLibrary.rmidCleanup(rmid);
     }
 
     public static class DebugExecWatcher
@@ -243,7 +251,19 @@
                     System.err.println(line);
                 }
             } catch (IOException e) {
-                e.printStackTrace();
+                /* During termination of distant rmid, StreamPipes will be broken when
+                 * distant vm terminates. A "Pipe broken" exception is expected because
+                 * DebugExecWatcher points to the same streams as StreamPipes used by RMID.
+                 * If we get this exception. We just terminate the thread.
+                 */
+                if (e.getMessage().equals("Pipe broken")) {
+                    try {
+                        str.close();
+                    } catch (IOException ioe) {}
+                }
+                else {
+                    e.printStackTrace();
+                }
             }
         }
     }
--- jdk/test/java/rmi/activation/CommandEnvironment/security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/CommandEnvironment/security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -27,6 +27,7 @@
   permission java.util.PropertyPermission "test.src", "read";
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
--- jdk/test/java/rmi/activation/checkusage/CheckUsage.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/checkusage/CheckUsage.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,9 +23,10 @@
 
 /* @test
  * @bug 4259564
+ * @summary RMID's usage message is incomplete and inconsistent with other tools
  *
  * @library ../../testlibrary
- * @build TestLibrary JavaVM CheckUsage
+ * @build TestLibrary JavaVM
  * @run main/othervm CheckUsage
  */
 
@@ -37,28 +38,18 @@
  */
 public class CheckUsage {
     public static void main(String[] args) {
-
-        System.err.println("\nregression test for 4259564\n");
-
-        JavaVM rmidVM = null;
-
         try {
-            // make sure the registry exits with a proper usage statement
             ByteArrayOutputStream berr = new ByteArrayOutputStream();
 
-            // run a VM to start the registry
-            rmidVM = new JavaVM("sun.rmi.server.Activation", "", "foo",
-                                    System.out, berr);
+            // create rmid with incorrect command line args
+            JavaVM rmidVM = new JavaVM("sun.rmi.server.Activation", "", "foo",
+                                       System.out, berr);
             System.err.println("starting rmid");
-            rmidVM.start();
 
-            // wait for registry exit
+            // run the subprocess and wait for it to exit
+            int rmidVMExitStatus = rmidVM.execute();
             System.err.println("rmid exited with status: " +
-                               rmidVM.getVM().waitFor());
-            try {
-                Thread.sleep(7000);
-            } catch (InterruptedException ie) {
-            }
+                               rmidVMExitStatus);
 
             String usage = new String(berr.toByteArray());
 
@@ -69,12 +60,8 @@
             } else {
                 System.err.println("test passed");
             }
-
         } catch (Exception e) {
             TestLibrary.bomb(e);
-        } finally {
-            rmidVM.destroy();
-            rmidVM = null;
         }
     }
 }
--- jdk/test/java/rmi/activation/log/LogTest.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/log/LogTest.java	2013-05-05 09:38:43.000000000 -0700
@@ -29,7 +29,6 @@
  * boundaries
  * @author Ann Wollrath
  *
- * @build LogTest
  * @run main/othervm/timeout=240 LogTest
  */
 
--- jdk/test/java/rmi/activation/rmidViaInheritedChannel/InheritedChannelNotServerSocket.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/rmidViaInheritedChannel/InheritedChannelNotServerSocket.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,10 +29,8 @@
  * @author Peter Jones
  *
  * @library ../../testlibrary
- * @build RMID ActivationLibrary
- * @build InheritedChannelNotServerSocket
- * @run main/othervm/timeout=240 -Djava.rmi.activation.port=5398
- *     InheritedChannelNotServerSocket
+ * @build TestLibrary RMID ActivationLibrary
+ * @run main/othervm/timeout=240 InheritedChannelNotServerSocket
  */
 
 import java.io.IOException;
@@ -55,8 +53,6 @@
 import java.rmi.server.UnicastRemoteObject;
 
 public class InheritedChannelNotServerSocket {
-
-    private static final int PORT = 5398;
     private static final Object lock = new Object();
     private static boolean notified = false;
 
@@ -79,7 +75,8 @@
 
     public static void main(String[] args) throws Exception {
         System.err.println("\nRegression test for bug 6261402\n");
-
+        System.setProperty("java.rmi.activation.port",
+                           Integer.toString(TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT));
         RMID rmid = null;
         Callback obj = null;
         try {
@@ -91,7 +88,8 @@
             Callback proxy =
                 (Callback) UnicastRemoteObject.exportObject(obj, 0);
             Registry registry =
-                LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+                LocateRegistry.createRegistry(
+                    TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_REGISTRY_PORT);
             registry.bind("Callback", proxy);
 
             /*
@@ -99,7 +97,8 @@
              */
             System.err.println("start rmid with inherited channel");
             RMID.removeLog();
-            rmid = RMID.createRMID(System.out, System.err, true, true, PORT);
+            rmid = RMID.createRMID(System.out, System.err, true, true,
+                                   TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT);
             rmid.addOptions(new String[]{
                 "-Djava.nio.channels.spi.SelectorProvider=" +
                 "InheritedChannelNotServerSocket$SP"});
@@ -122,7 +121,7 @@
             if (obj != null) {
                 UnicastRemoteObject.unexportObject(obj, true);
             }
-            ActivationLibrary.rmidCleanup(rmid, PORT);
+            ActivationLibrary.rmidCleanup(rmid);
         }
     }
 
@@ -175,7 +174,7 @@
                 try {
                     System.err.println("notify test...");
                     Registry registry =
-                        LocateRegistry.getRegistry(TestLibrary.REGISTRY_PORT);
+                        LocateRegistry.getRegistry(TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_REGISTRY_PORT);
                     Callback obj = (Callback) registry.lookup("Callback");
                     obj.notifyTest();
                 } catch (NotBoundException nbe) {
--- jdk/test/java/rmi/activation/rmidViaInheritedChannel/RmidViaInheritedChannel.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/rmidViaInheritedChannel/RmidViaInheritedChannel.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,8 @@
  * @author Ann Wollrath
  *
  * @library ../../testlibrary
- * @build RMID ActivationLibrary
- * @build RmidViaInheritedChannel
- * @run main/othervm/timeout=240 -Djava.rmi.activation.port=5398 RmidViaInheritedChannel
+ * @build TestLibrary RMID ActivationLibrary
+ * @run main/othervm/timeout=240 RmidViaInheritedChannel
  */
 
 import java.io.IOException;
@@ -48,8 +47,6 @@
 import java.rmi.server.UnicastRemoteObject;
 
 public class RmidViaInheritedChannel implements Callback {
-
-    private static final int PORT = 5398;
     private static final Object lock = new Object();
     private static boolean notified = false;
 
@@ -64,7 +61,8 @@
     }
 
     public static void main(String[] args) throws Exception {
-
+        System.setProperty("java.rmi.activation.port",
+                           Integer.toString(TestLibrary.RMIDVIAINHERITEDCHANNEL_ACTIVATION_PORT));
         RMID rmid = null;
         Callback obj = null;
 
@@ -77,7 +75,8 @@
             Callback proxy = (Callback)
                 UnicastRemoteObject.exportObject(obj, 0);
             Registry registry =
-                LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+                LocateRegistry.createRegistry(
+                    TestLibrary.RMIDVIAINHERITEDCHANNEL_REGISTRY_PORT);
             registry.bind("Callback", proxy);
 
             /*
@@ -85,7 +84,8 @@
              */
             System.err.println("start rmid with inherited channel");
             RMID.removeLog();
-            rmid = RMID.createRMID(System.out, System.err, true, false, PORT);
+            rmid = RMID.createRMID(System.out, System.err, true, false,
+                                   TestLibrary.RMIDVIAINHERITEDCHANNEL_ACTIVATION_PORT);
             rmid.addOptions(new String[]{
                 "-Djava.nio.channels.spi.SelectorProvider=RmidViaInheritedChannel$RmidSelectorProvider"});
             rmid.start();
@@ -108,7 +108,7 @@
             if (obj != null) {
                 UnicastRemoteObject.unexportObject(obj, true);
             }
-            ActivationLibrary.rmidCleanup(rmid, PORT);
+            ActivationLibrary.rmidCleanup(rmid);
         }
     }
 
@@ -166,7 +166,8 @@
                 channel = ServerSocketChannel.open();
                 ServerSocket serverSocket = channel.socket();
                 serverSocket.bind(
-                     new InetSocketAddress(InetAddress.getLocalHost(), PORT));
+                     new InetSocketAddress(InetAddress.getLocalHost(),
+                     TestLibrary.RMIDVIAINHERITEDCHANNEL_ACTIVATION_PORT));
                 System.err.println("serverSocket = " + serverSocket);
 
                 /*
@@ -175,7 +176,7 @@
                 try {
                     System.err.println("notify test...");
                     Registry registry =
-                        LocateRegistry.getRegistry(TestLibrary.REGISTRY_PORT);
+                        LocateRegistry.getRegistry(TestLibrary.RMIDVIAINHERITEDCHANNEL_REGISTRY_PORT);
                     Callback obj = (Callback) registry.lookup("Callback");
                     obj.notifyTest();
                 } catch (NotBoundException nbe) {
--- jdk/test/java/rmi/activation/rmidViaInheritedChannel/rmid.security.policy	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/activation/rmidViaInheritedChannel/rmid.security.policy	2013-05-05 09:38:43.000000000 -0700
@@ -2,4 +2,5 @@
     permission java.lang.RuntimePermission "selectorProvider";
     permission java.lang.RuntimePermission "accessClassInPackage.sun.nio.ch";
     permission java.net.SocketPermission "*", "connect,accept";
+    permission java.util.PropertyPermission "java.rmi.activation.port", "write";
 };
--- jdk/test/java/rmi/dgc/VMID/CheckVMID.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/dgc/VMID/CheckVMID.java	2013-05-05 09:38:43.000000000 -0700
@@ -30,7 +30,7 @@
  * @author Ann Wollrath
  *
  * @library ../../testlibrary
- * @build CheckVMID
+ * @build TestLibrary
  * @run main/othervm/policy=security.policy CheckVMID
  */
 
--- jdk/test/java/rmi/dgc/dgcAckFailure/DGCAckFailure.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/dgc/dgcAckFailure/DGCAckFailure.java	2013-05-05 09:38:43.000000000 -0700
@@ -30,8 +30,7 @@
  * rather than pinning it indefinitely.
  * @author Peter Jones
  *
- * @build DGCAckFailure
- * @build DGCAckFailure_Stub
+ * @build DGCAckFailure DGCAckFailure_Stub
  * @run main/othervm DGCAckFailure
  */
 
--- jdk/test/java/rmi/dgc/dgcImplInsulation/DGCImplInsulation.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/dgc/dgcImplInsulation/DGCImplInsulation.java	2013-05-05 09:38:43.000000000 -0700
@@ -31,9 +31,7 @@
  * @author Peter Jones
  *
  * @library ../../testlibrary
- * @build TestLibrary
- * @build DGCImplInsulation
- * @build DGCImplInsulation_Stub
+ * @build TestLibrary DGCImplInsulation_Stub
  * @run main/othervm/policy=security.policy DGCImplInsulation
  */
 
--- jdk/test/java/rmi/dgc/retryDirtyCalls/RetryDirtyCalls.java	2012-08-10 10:34:37.000000000 -0700
+++ jdk/test/java/rmi/dgc/retryDirtyCalls/RetryDirtyCalls.java	2013-05-05 09:38:43.000000000 -0700
@@ -29,8 +29,7 @@
  * renewing that lease at all after the first failure.
  * @author Peter Jones (inspired by Adrian Colley's test case in 4268258)
  *
- * @build RetryDirtyCalls
- * @build RetryDirtyCalls_Stub
+ * @build RetryDirtyCalls RetryDirtyCalls_Stub
  * @run main/othervm RetryDirtyCalls
  */
 
--- jdk/test/java/rmi/invalidName/InvalidName.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/invalidName/InvalidName.java	2013-05-05 09:38:43.000000000 -0700
@@ -32,7 +32,7 @@
  * @author Laird Dornin
  *
  * @library ../testlibrary
- * @build InvalidName
+ * @build TestLibrary
  * @run main/othervm InvalidName
  */
 
--- jdk/test/java/rmi/registry/altSecurityManager/AltSecurityManager.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/altSecurityManager/AltSecurityManager.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,8 +27,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build StreamPipe TestParams TestLibrary JavaVM
- * @build AltSecurityManager TestSecurityManager
+ * @build TestLibrary JavaVM RMID TestSecurityManager
  * @run main/othervm AltSecurityManager
  */
 
@@ -41,26 +40,43 @@
  * if registry and rmid take too long to exit.
  */
 public class AltSecurityManager implements Runnable {
-
+    private final int regPort;
     // variable to hold registry and rmid children
     static JavaVM vm = null;
 
     // names of utilities
     static String utilityToStart = null;
-    static String registry = "sun.rmi.registry.RegistryImpl";
-    static String rmid = "sun.rmi.server.Activation";
+    static final String REGISTRY_IMPL = "sun.rmi.registry.RegistryImpl";
+    static final String ACTIVATION = "sun.rmi.server.Activation";
 
     // children should exit in at least this time.
     static long TIME_OUT = 15000;
 
+    public AltSecurityManager(int port) {
+        if (port <= 0) {
+            TestLibrary.bomb("Port must be greater then 0.");
+        }
+
+        this.regPort = port;
+    }
+
     public void run() {
         try {
-            vm = new JavaVM(utilityToStart,
-                            " -Djava.security.manager=TestSecurityManager",
-                            "");
+            if (utilityToStart.equals(REGISTRY_IMPL)) {
+                vm = new JavaVM(utilityToStart,
+                        " -Djava.security.manager=TestSecurityManager",
+                        Integer.toString(regPort));
+            } else if (utilityToStart.contains(ACTIVATION)) {
+                vm = new JavaVM(utilityToStart,
+                        " -Djava.security.manager=TestSecurityManager",
+                        "-port " + Integer.toString(regPort));
+            } else {
+                TestLibrary.bomb("Utility to start must be " + REGISTRY_IMPL +
+                        " or " + ACTIVATION);
+            }
+
             System.err.println("starting " + utilityToStart);
-            vm.start();
-            vm.getVM().waitFor();
+            vm.execute();
 
         } catch (Exception e) {
             TestLibrary.bomb(e);
@@ -75,7 +91,8 @@
         utilityToStart = utility;
 
         try {
-            Thread thread = new Thread(new AltSecurityManager());
+            int port = TestLibrary.getUnusedRandomPort();
+            Thread thread = new Thread(new AltSecurityManager(port));
             System.err.println("expecting RuntimeException for " +
                                "checkListen in child process");
             long start = System.currentTimeMillis();
@@ -90,8 +107,8 @@
 
                 // dont pollute other tests; increase the likelihood
                 // that rmid will go away if it did not exit already.
-                if (utility.equals(rmid)) {
-                    RMID.shutdown();
+                if (utility.equals(ACTIVATION)) {
+                    RMID.shutdown(port);
                 }
 
                 TestLibrary.bomb(utilityToStart +
@@ -111,10 +128,10 @@
             System.err.println("\nRegression test for bug 4183202\n");
 
             // make sure the registry exits early.
-            ensureExit(registry);
+            ensureExit(REGISTRY_IMPL);
 
             // make sure rmid exits early
-            ensureExit(rmid);
+            ensureExit(ACTIVATION);
 
             System.err.println("test passed");
 
--- jdk/test/java/rmi/registry/checkusage/CheckUsage.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/checkusage/CheckUsage.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,7 +27,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build TestLibrary JavaVM CheckUsage
+ * @build TestLibrary JavaVM
  * @run main/othervm CheckUsage
  */
 
@@ -35,34 +35,21 @@
 
 /**
  * Make sure that the rmiregistry prints out a correct usage statement
- * when run with an incorrect command line; test written to conform to
- * new tighter bug fix/regression test guidelines.
+ * when run with an incorrect command line.
  */
 public class CheckUsage {
     public static void main(String[] args) {
 
-        System.err.println("\nregression test for 4151966\n");
-
-        JavaVM registryVM = null;
-
         try {
-            // make sure the registry exits with a proper usage statement
             ByteArrayOutputStream berr = new ByteArrayOutputStream();
 
             // run a VM to start the registry
-            registryVM = new JavaVM("sun.rmi.registry.RegistryImpl",
-                                    "", "foo",
-                                    System.out, berr);
+            JavaVM registryVM = new JavaVM("sun.rmi.registry.RegistryImpl",
+                                           "", "foo",
+                                           System.out, berr);
             System.err.println("starting registry");
-            registryVM.start();
-
-            // wait for registry exit
             System.err.println(" registry exited with status: " +
-                               registryVM.getVM().waitFor());
-            try {
-                Thread.sleep(7000);
-            } catch (InterruptedException ie) {
-            }
+                               registryVM.execute());
 
             String usage = new String(berr.toByteArray());
 
@@ -75,9 +62,6 @@
             }
         } catch (Exception e) {
             TestLibrary.bomb(e);
-        } finally {
-            registryVM.destroy();
-            registryVM = null;
         }
     }
 }
--- jdk/test/java/rmi/registry/classPathCodebase/ClassPathCodebase.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/classPathCodebase/ClassPathCodebase.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,8 +30,9 @@
  * @author Peter Jones
  *
  * @library ../../testlibrary
- * @build ClassPathCodebase Dummy
- * @run main/othervm/policy=security.policy ClassPathCodebase
+ * @build TestLibrary Dummy
+ * @run main/othervm/policy=security.policy
+ *     -Djava.rmi.server.useCodebaseOnly=false ClassPathCodebase
  */
 
 import java.io.*;
@@ -83,11 +84,12 @@
                 System.getProperty("java.home") + File.separator +
                 "bin" + File.separator + "rmiregistry";
 
+            int port = TestLibrary.getUnusedRandomPort();
             String cmdarray[] = new String[] {
                 rmiregistryCommand,
                 "-J-Denv.class.path=.",
                 "-J-Djava.rmi.server.codebase=" + exportCodebaseURL,
-                Integer.toString(TestLibrary.REGISTRY_PORT) };
+                Integer.toString(port) };
 
             System.err.println("\nCommand used to spawn rmiregistry process:");
             System.err.println("\t" + Arrays.asList(cmdarray).toString());
@@ -118,7 +120,7 @@
              * dummy object to it.
              */
             Registry registry = LocateRegistry.getRegistry(
-                "localhost", TestLibrary.REGISTRY_PORT);
+                "localhost", port);
 
             try {
                 registry.bind(dummyBinding, dummyObject);
@@ -133,7 +135,7 @@
                 {
                     System.err.println(
                         "Error: another registry running on port " +
-                        TestLibrary.REGISTRY_PORT + "?");
+                        port + "?");
                 }
                 throw e;
             }
--- jdk/test/java/rmi/registry/emptyName/EmptyName.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/emptyName/EmptyName.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
 /* @test
  * @bug 4399304
  * @summary check that registry allows empty names
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm EmptyName
  */
 import java.rmi.registry.LocateRegistry;
@@ -32,7 +34,7 @@
 
 public class EmptyName {
     public static void main(String[] args) throws Exception {
-        Registry impl = LocateRegistry.createRegistry(0);
+        Registry impl = TestLibrary.createRegistryOnUnusedPort();
         Registry stub = (Registry) RemoteObject.toStub(impl);
         stub.bind("", stub);
         stub.lookup("");
--- jdk/test/java/rmi/registry/interfaceHash/InterfaceHash.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/interfaceHash/InterfaceHash.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,8 +35,8 @@
  * "interface hash": 4905912898345647071L.
  *
  * @author Peter Jones
- * @build InterfaceHash
- * @build ReferenceRegistryStub
+ * @library ../../testlibrary
+ * @build TestLibrary ReferenceRegistryStub
  * @run main/othervm InterfaceHash
  */
 
@@ -58,7 +58,7 @@
 
 public class InterfaceHash {
 
-    private static final int PORT = 2020;
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
     private static final String NAME = "WMM";
 
     public static void main(String[] args) throws Exception {
--- jdk/test/java/rmi/registry/multipleRegistries/MultipleRegistries.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/multipleRegistries/MultipleRegistries.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,8 @@
  * @summary Can't run multiple registries in the same VM
  * @author Ann Wollrath
  *
- * @build MultipleRegistries
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm/timeout=240 MultipleRegistries
  */
 
@@ -58,12 +59,13 @@
             System.err.println("proxy = " + proxy);
 
             System.err.println("export registries");
-            Registry registryImpl1 = LocateRegistry.createRegistry(2030);
-            Registry registryImpl2 = LocateRegistry.createRegistry(2040);
-
+            Registry registryImpl1 = TestLibrary.createRegistryOnUnusedPort();
+            int port1 = TestLibrary.getRegistryPort(registryImpl1);
+            Registry registryImpl2 = TestLibrary.createRegistryOnUnusedPort();
+            int port2 = TestLibrary.getRegistryPort(registryImpl2);
             System.err.println("bind remote object in registries");
-            Registry registry1 = LocateRegistry.getRegistry(2030);
-            Registry registry2 = LocateRegistry.getRegistry(2040);
+            Registry registry1 = LocateRegistry.getRegistry(port1);
+            Registry registry2 = LocateRegistry.getRegistry(port2);
 
             registry1.bind(NAME, proxy);
             registry2.bind(NAME, proxy);
--- jdk/test/java/rmi/registry/readTest/readTest.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/readTest/readTest.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,18 +30,19 @@
 public class readTest {
 
     public static void main(String args[]) throws Exception {
-        int port = 7491;
         try {
             testPkg.Server obj = new testPkg.Server();
             testPkg.Hello stub = (testPkg.Hello) UnicastRemoteObject.exportObject(obj, 0);
             // Bind the remote object's stub in the registry
-            Registry registry = LocateRegistry.getRegistry(port);
+            Registry registry =
+                LocateRegistry.getRegistry(TestLibrary.READTEST_REGISTRY_PORT);
             registry.bind("Hello", stub);
 
             System.err.println("Server ready");
 
             // now, let's test client
-            testPkg.Client client = new testPkg.Client(port);
+            testPkg.Client client =
+                new testPkg.Client(TestLibrary.READTEST_REGISTRY_PORT);
             String testStubReturn = client.testStub();
             if(!testStubReturn.equals(obj.hello)) {
                 throw new RuntimeException("Test Fails : unexpected string from stub call");
--- jdk/test/java/rmi/registry/readTest/readTest.sh	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/readTest/readTest.sh	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -23,43 +23,61 @@
 
 # @test
 # @bug 7102369 7094468 7100592
-# @summary remove java.rmi.server.codebase property parsing from registyimpl
+# @library ../../testlibrary
+# @build TestLibrary
+# @summary remove java.rmi.server.codebase property parsing from RegistryImpl
 # @run shell readTest.sh
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     FILEURL="file:"
     ;;
-  Windows* | CYGWIN* )
+  Windows* )
     PS=";"
     FS="\\"
     FILEURL="file:/"
     ;;
+  CYGWIN* )
+    PS=";"
+    FS="/"
+    FILEURL="file:/"
+    ;;
   * )
     echo "Unrecognized system!"
     exit 1;
     ;;
 esac
 
+TEST_CLASSPATH=.$PS${TESTCLASSPATH:-$TESTCLASSES}
 cp -r ${TESTSRC}${FS}* .
 ${TESTJAVA}${FS}bin${FS}javac testPkg${FS}*java
-${TESTJAVA}${FS}bin${FS}javac readTest.java
+${TESTJAVA}${FS}bin${FS}javac -cp $TEST_CLASSPATH readTest.java
 
 mkdir rmi_tmp
 RMIREG_OUT=rmi.out
 #start rmiregistry without any local classes on classpath
 cd rmi_tmp
-${TESTJAVA}${FS}bin${FS}rmiregistry 7491 > ..${FS}${RMIREG_OUT} 2>&1 &
+# NOTE: This RMI Registry port must match TestLibrary.READTEST_REGISTRY_PORT
+${TESTJAVA}${FS}bin${FS}rmiregistry -J-Djava.rmi.server.useCodebaseOnly=false \
+    ${TESTTOOLVMOPTS} 64005 > ..${FS}${RMIREG_OUT} 2>&1 &
 RMIREG_PID=$!
 # allow some time to start
 sleep 3
 cd ..
 
+case "$OS" in
+  CYGWIN* )
+    CODEBASE=`cygpath -w $PWD`
+    ;;
+  * )
+    CODEBASE=`pwd`
+    ;;  
+esac
 # trailing / after code base is important for rmi codebase property.
-${TESTJAVA}${FS}bin${FS}java -Djava.rmi.server.codebase=${FILEURL}`pwd`/ readTest > OUT.TXT 2>&1 &
+${TESTJAVA}${FS}bin${FS}java -cp $TEST_CLASSPATH -Djava.rmi.server.codebase=${FILEURL}$CODEBASE/ readTest > OUT.TXT 2>&1 &
 TEST_PID=$!
 #bulk of testcase - let it run for a while
 sleep 5
--- jdk/test/java/rmi/registry/reexport/Reexport.java	2012-08-10 10:34:39.000000000 -0700
+++ jdk/test/java/rmi/registry/reexport/Reexport.java	2013-05-05 09:38:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,9 +25,7 @@
  * @bug 4120329
  * @summary RMI registry creation is impossible if first attempt fails.
  * @library ../../testlibrary
- * @build StreamPipe TestParams TestLibrary JavaVM
- * @build RegistryRunner RegistryRunner_Stub
- * @build Reexport
+ * @build TestLibrary JavaVM RegistryRunner RegistryRunner_Stub
  * @run main/othervm Reexport
  */
 
@@ -49,22 +47,21 @@
 import java.rmi.server.*;
 
 public class Reexport {
-    static public final int regport = TestLibrary.REGISTRY_PORT;
-
     static public void main(String[] argv) {
 
         Registry reg = null;
+        int regPort = TestLibrary.getUnusedRandomPort();
 
         try {
             System.err.println("\nregression test for 4120329\n");
 
             // establish the registry (we hope)
-            System.err.println("Starting registry on port " + regport);
-            Reexport.makeRegistry(regport);
+            System.err.println("Starting registry on port " + regPort);
+            Reexport.makeRegistry(regPort);
 
             // Get a handle to the registry
             System.err.println("Creating duplicate registry, this should fail...");
-            reg = createReg(true);
+            reg = createReg(true, regPort);
 
             if (reg != null) {
                 TestLibrary.bomb("failed was able to duplicate the registry?!?");
@@ -73,7 +70,7 @@
             // Kill the first registry.
             System.err.println("Bringing down the first registry");
             try {
-                Reexport.killRegistry();
+                Reexport.killRegistry(regPort);
             } catch (Exception foo) {
             }
 
@@ -81,7 +78,7 @@
             System.err.println("Trying again to start our own " +
                                "registry... this should work");
 
-            reg = createReg(false);
+            reg = createReg(false, regPort);
 
             if (reg == null) {
                 TestLibrary.bomb("Could not create registry on second try");
@@ -93,17 +90,17 @@
             TestLibrary.bomb(e);
         } finally {
             // dont leave the registry around to affect other tests.
-            killRegistry();
+            killRegistry(regPort);
 
             reg = null;
         }
     }
 
-    static Registry createReg(boolean remoteOk) {
+    static Registry createReg(boolean remoteOk, int port) {
         Registry reg = null;
 
         try {
-            reg = LocateRegistry.createRegistry(regport);
+            reg = LocateRegistry.createRegistry(port);
         } catch (Throwable e) {
             if (remoteOk) {
                 System.err.println("EXPECTING PORT IN USE EXCEPTION:");
@@ -125,8 +122,7 @@
         try {
             JavaVM jvm = new JavaVM("RegistryRunner", "", Integer.toString(p));
             jvm.start();
-            Reexport.subreg = jvm.getVM();
-
+            Reexport.subreg = jvm;
         } catch (IOException e) {
             // one of these is summarily dropped, can't remember which one
             System.out.println ("Test setup failed - cannot run rmiregistry");
@@ -138,12 +134,13 @@
         } catch (Exception whatever) {
         }
     }
-    private static Process subreg = null;
 
-    public static void killRegistry() {
+    private static JavaVM subreg = null;
+
+    public static void killRegistry(int port) {
         if (Reexport.subreg != null) {
 
-            RegistryRunner.requestExit();
+            RegistryRunner.requestExit(port);
 
             try {
                 Reexport.subreg.waitFor();
--- jdk/test/java/rmi/reliability/benchmark/runRmiBench.sh	2012-08-10 10:34:42.000000000 -0700
+++ jdk/test/java/rmi/reliability/benchmark/runRmiBench.sh	2013-05-05 09:38:44.000000000 -0700
@@ -27,20 +27,20 @@
 #          used to run the test under JTREG.
 #
 # @build bench.BenchInfo bench.HtmlReporter bench.Util bench.Benchmark 
-# @build bench.Reporter bench.XmlReporter bench.ConfigFormatException 
-# @build bench.Harness bench.TextReporter bench.rmi.BenchServer 
-# @build bench.rmi.DoubleArrayCalls bench.rmi.LongCalls bench.rmi.ShortCalls
-# @build bench.rmi.BenchServerImpl bench.rmi.DoubleCalls 
-# @build bench.rmi.Main bench.rmi.SmallObjTreeCalls
-# @build bench.rmi.BooleanArrayCalls bench.rmi.ExceptionCalls 
-# @build bench.rmi.NullCalls bench.rmi.BooleanCalls bench.rmi.ExportObjs 
-# @build bench.rmi.ObjArrayCalls bench.rmi.ByteArrayCalls 
-# @build bench.rmi.FloatArrayCalls bench.rmi.ObjTreeCalls
-# @build bench.rmi.ByteCalls bench.rmi.FloatCalls bench.rmi.ProxyArrayCalls
-# @build bench.rmi.CharArrayCalls bench.rmi.IntArrayCalls 
-# @build bench.rmi.RemoteObjArrayCalls bench.rmi.CharCalls bench.rmi.IntCalls
-# @build bench.rmi.ClassLoading bench.rmi.LongArrayCalls 
-# @build bench.rmi.ShortArrayCalls bench.rmi.altroot.Node
+#     bench.Reporter bench.XmlReporter bench.ConfigFormatException 
+#     bench.Harness bench.TextReporter bench.rmi.BenchServer 
+#     bench.rmi.DoubleArrayCalls bench.rmi.LongCalls bench.rmi.ShortCalls
+#     bench.rmi.BenchServerImpl bench.rmi.DoubleCalls 
+#     bench.rmi.Main bench.rmi.SmallObjTreeCalls
+#     bench.rmi.BooleanArrayCalls bench.rmi.ExceptionCalls 
+#     bench.rmi.NullCalls bench.rmi.BooleanCalls bench.rmi.ExportObjs 
+#     bench.rmi.ObjArrayCalls bench.rmi.ByteArrayCalls 
+#     bench.rmi.FloatArrayCalls bench.rmi.ObjTreeCalls
+#     bench.rmi.ByteCalls bench.rmi.FloatCalls bench.rmi.ProxyArrayCalls
+#     bench.rmi.CharArrayCalls bench.rmi.IntArrayCalls 
+#     bench.rmi.RemoteObjArrayCalls bench.rmi.CharCalls bench.rmi.IntCalls
+#     bench.rmi.ClassLoading bench.rmi.LongArrayCalls 
+#     bench.rmi.ShortArrayCalls bench.rmi.altroot.Node
 #
 # @run shell/timeout=1800 runRmiBench.sh
 #
--- jdk/test/java/rmi/reliability/benchmark/runSerialBench.sh	2012-08-10 10:34:42.000000000 -0700
+++ jdk/test/java/rmi/reliability/benchmark/runSerialBench.sh	2013-05-05 09:38:44.000000000 -0700
@@ -27,22 +27,22 @@
 #          used to run the test under JTREG.
 #
 # @build bench.BenchInfo bench.HtmlReporter bench.Util bench.Benchmark 
-# @build bench.Reporter bench.XmlReporter bench.ConfigFormatException 
-# @build bench.Harness bench.TextReporter
-# @build bench.serial.BooleanArrays bench.serial.Booleans
-# @build bench.serial.ByteArrays bench.serial.Bytes bench.serial.CharArrays
-# @build bench.serial.Chars bench.serial.ClassDesc bench.serial.Cons
-# @build bench.serial.CustomDefaultObjTrees bench.serial.CustomObjTrees
-# @build bench.serial.DoubleArrays bench.serial.Doubles
-# @build bench.serial.ExternObjTrees bench.serial.FloatArrays
-# @build bench.serial.Floats bench.serial.GetPutFieldTrees
-# @build bench.serial.IntArrays bench.serial.Ints bench.serial.LongArrays
-# @build bench.serial.Longs bench.serial.Main bench.serial.ObjArrays
-# @build bench.serial.ObjTrees bench.serial.ProxyArrays
-# @build bench.serial.ProxyClassDesc bench.serial.RepeatObjs
-# @build bench.serial.ReplaceTrees bench.serial.ShortArrays
-# @build bench.serial.Shorts bench.serial.SmallObjTrees
-# @build bench.serial.StreamBuffer bench.serial.Strings
+#     bench.Reporter bench.XmlReporter bench.ConfigFormatException 
+#     bench.Harness bench.TextReporter
+#     bench.serial.BooleanArrays bench.serial.Booleans
+#     bench.serial.ByteArrays bench.serial.Bytes bench.serial.CharArrays
+#     bench.serial.Chars bench.serial.ClassDesc bench.serial.Cons
+#     bench.serial.CustomDefaultObjTrees bench.serial.CustomObjTrees
+#     bench.serial.DoubleArrays bench.serial.Doubles
+#     bench.serial.ExternObjTrees bench.serial.FloatArrays
+#     bench.serial.Floats bench.serial.GetPutFieldTrees
+#     bench.serial.IntArrays bench.serial.Ints bench.serial.LongArrays
+#     bench.serial.Longs bench.serial.Main bench.serial.ObjArrays
+#     bench.serial.ObjTrees bench.serial.ProxyArrays
+#     bench.serial.ProxyClassDesc bench.serial.RepeatObjs
+#     bench.serial.ReplaceTrees bench.serial.ShortArrays
+#     bench.serial.Shorts bench.serial.SmallObjTrees
+#     bench.serial.StreamBuffer bench.serial.Strings
 #
 # @run shell/timeout=1800 runSerialBench.sh
 #
--- jdk/test/java/rmi/reliability/juicer/AppleUserImpl.java	2012-08-10 10:34:42.000000000 -0700
+++ jdk/test/java/rmi/reliability/juicer/AppleUserImpl.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,23 +55,24 @@
  * has been reached.
  *
  * @library ../../testlibrary
- *
- * @build Apple AppleEvent AppleImpl AppleUserImpl
- * @build Orange OrangeEcho OrangeEchoImpl OrangeImpl
- * @build ApplicationServer
+ * @build TestLibrary
+ *     Apple AppleEvent AppleImpl
+ *     Orange OrangeEcho OrangeEchoImpl OrangeImpl
+ *     ApplicationServer
  *
  * @run main/othervm/policy=security.policy AppleUserImpl -seconds 30
  *
  * @author Peter Jones, Nigel Daley
  */
 
-import java.rmi.RemoteException;
 import java.rmi.NoSuchObjectException;
-import java.rmi.server.UnicastRemoteObject;
+import java.rmi.RemoteException;
 import java.rmi.registry.LocateRegistry;
+import java.rmi.registry.Registry;
+import java.rmi.server.UnicastRemoteObject;
 import java.util.Random;
-import java.util.logging.Logger;
 import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * The AppleUserImpl class implements the behavior of the remote
@@ -80,7 +81,7 @@
  * AppleUserThread is created for each apple.
  */
 public class AppleUserImpl extends UnicastRemoteObject implements AppleUser {
-
+    private static int registryPort = -1;
     private static final Logger logger =
         Logger.getLogger("reliability.appleuser");
     private static int threadNum = 0;
@@ -308,8 +309,10 @@
 
             synchronized (user) {
                 // create new registry and bind new AppleUserImpl in registry
-                LocateRegistry.createRegistry(2006);
-                LocateRegistry.getRegistry(2006).rebind("AppleUser",user);
+                Registry registry = TestLibrary.createRegistryOnUnusedPort();
+                registryPort = TestLibrary.getRegistryPort(registry);
+                LocateRegistry.getRegistry(registryPort).rebind("AppleUser",
+                                                                 user);
 
                 // start the other server if applicable
                 if (othervm) {
@@ -318,7 +321,9 @@
                         "started in separate process");
                 } else {
                     Class app = Class.forName("ApplicationServer");
-                    server = new Thread((Runnable) app.newInstance());
+                    java.lang.reflect.Constructor appConstructor =
+                            app.getDeclaredConstructor(new Class[] {Integer.TYPE});
+                    server = new Thread((Runnable) appConstructor.newInstance(registryPort));
                     logger.log(Level.INFO, "Starting application server " +
                         "in same process");
                     server.start();
--- jdk/test/java/rmi/reliability/juicer/ApplicationServer.java	2012-08-10 10:34:42.000000000 -0700
+++ jdk/test/java/rmi/reliability/juicer/ApplicationServer.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,18 +38,21 @@
     private static final int LOOKUP_ATTEMPTS = 5;
     private static final int DEFAULT_NUMAPPLES = 10;
     private static final String DEFAULT_REGISTRYHOST = "localhost";
+    private static final int DEFAULT_REGISTRYPORT = -1;
     private final int numApples;
     private final String registryHost;
+    private final int registryPort;
     private final Apple[] apples;
     private AppleUser user;
 
-    ApplicationServer() {
-        this(DEFAULT_NUMAPPLES, DEFAULT_REGISTRYHOST);
+    ApplicationServer(int registryPort) {
+        this(DEFAULT_NUMAPPLES, DEFAULT_REGISTRYHOST, registryPort);
     }
 
-    ApplicationServer(int numApples, String registryHost) {
+    ApplicationServer(int numApples, String registryHost, int registryPort) {
         this.numApples = numApples;
         this.registryHost = registryHost;
+        this.registryPort = registryPort;
         apples = new Apple[numApples];
     }
 
@@ -71,7 +74,7 @@
             for (i = 0; i < LOOKUP_ATTEMPTS; i++) {
                 try {
                     Registry registry = LocateRegistry.getRegistry(
-                        registryHost, 2006);
+                           registryHost, registryPort);
                     user = (AppleUser) registry.lookup("AppleUser");
                     user.startTest();
                     break; //successfully obtained AppleUser
@@ -120,16 +123,20 @@
     private static void usage() {
         System.err.println("Usage: ApplicationServer [-numApples <numApples>]");
         System.err.println("                         [-registryHost <host>]");
+        System.err.println("                         -registryPort <port>");
         System.err.println("  numApples  The number of apples (threads) to use.");
         System.err.println("             The default is 10 apples.");
         System.err.println("  host       The host running rmiregistry " +
                                          "which contains AppleUser.");
         System.err.println("             The default is \"localhost\".");
+        System.err.println("  port       The port the rmiregistry is running" +
+                                         "on.");
         System.err.println();
     }
 
     public static void main(String[] args) {
         int num = DEFAULT_NUMAPPLES;
+        int port = -1;
         String host = DEFAULT_REGISTRYHOST;
 
         // parse command line args
@@ -142,17 +149,25 @@
                 } else if (arg.equals("-registryHost")) {
                     i++;
                     host = args[i];
+                } else if (arg.equals("-registryPort")) {
+                    i++;
+                    port = Integer.parseInt(args[i]);
                 } else {
                     usage();
                 }
             }
+
+            if (port == -1) {
+                usage();
+                throw new RuntimeException("Port must be specified.");
+            }
         } catch (Throwable t) {
             usage();
             throw new RuntimeException("TEST FAILED: Bad argument");
         }
 
         // start the client server
-        Thread server = new Thread(new ApplicationServer(num,host));
+        Thread server = new Thread(new ApplicationServer(num,host,port));
         server.start();
         // main should exit once all exported remote objects are gc'd
     }
--- jdk/test/java/rmi/reliability/launch_reliability.ksh	2012-08-10 10:34:42.000000000 -0700
+++ jdk/test/java/rmi/reliability/launch_reliability.ksh	2013-05-05 09:38:44.000000000 -0700
@@ -84,14 +84,12 @@
 
 
 # set platform-dependent variables
-if [ `uname` = "SunOS" ] ; then
+case `uname` in
+    SunOS | Linux | *BSD | Darwin )
         PATH_SEP=":"
-
-elif [ `uname` = "Linux" ] ; then
-        PATH_SEP=":"
-else
+    * )
         PATH_SEP=";"
-fi
+esac
 
 export PATH_SEP
 mainpid=$$
--- jdk/test/java/rmi/server/ObjID/randomIDs/RandomIDs.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/ObjID/randomIDs/RandomIDs.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,7 +30,6 @@
  * ObjID() should still generate sequential object numbers.
  * @author Peter Jones
  *
- * @build RandomIDs
  * @run main/othervm RandomIDs random
  * @run main/othervm -Djava.rmi.server.randomIDs=true RandomIDs random
  * @run main/othervm -Djava.rmi.server.randomIDs=false RandomIDs sequential
--- jdk/test/java/rmi/server/RMIClassLoader/delegateBeforePermissionCheck/DelegateBeforePermissionCheck.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/delegateBeforePermissionCheck/DelegateBeforePermissionCheck.java	2013-05-05 09:38:44.000000000 -0700
@@ -33,9 +33,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build DelegateBeforePermissionCheck
- * @build Foo
+ * @build TestLibrary Foo
  * @run main/othervm DelegateBeforePermissionCheck
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/delegateToContextLoader/DelegateToContextLoader.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/delegateToContextLoader/DelegateToContextLoader.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,7 +29,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build DelegateToContextLoader Dummy
+ * @build TestLibrary Dummy
  * @run main/othervm/policy=security.policy/timeout=120 DelegateToContextLoader
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/downloadArrayClass/DownloadArrayClass.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/downloadArrayClass/DownloadArrayClass.java	2013-05-05 09:38:44.000000000 -0700
@@ -31,11 +31,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build Receiver
- * @build DownloadArrayClass
- * @build DownloadArrayClass_Stub
- * @build Foo
+ * @build TestLibrary Receiver DownloadArrayClass_Stub Foo
  * @run main/othervm/policy=security.policy DownloadArrayClass
  */
 
@@ -68,6 +64,10 @@
             TestLibrary.bomb(e);
         }
 
+        System.err.println("Setting codebase property to: " + remoteCodebase);
+        System.setProperty("java.rmi.server.codebase",
+            remoteCodebase.toString());
+
         /*
          * Load Foo from a non-RMI class loader so that it won't be already
          * loaded by an RMI class loader in this VM (for whatever that's
--- jdk/test/java/rmi/server/RMIClassLoader/downloadArrayClass/security.policy	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/downloadArrayClass/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -7,6 +7,8 @@
 };
 
 grant {
+    permission java.util.PropertyPermission
+        "java.rmi.server.codebase", "read,write";
 
     // permissions needed to move classes into separate codebase directories
     permission java.io.FilePermission
--- jdk/test/java/rmi/server/RMIClassLoader/getClassAnnotation/NullClass.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/getClassAnnotation/NullClass.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,7 +29,6 @@
  *
  * @library ../../../testlibrary
  * @build TestLibrary
- * @build NullClass
  * @run main/othervm NullClass
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/getClassLoader/GetClassLoader.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/getClassLoader/GetClassLoader.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,9 +29,7 @@
  * @author Ann Wollrath
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build GetClassLoader
- * @build Foo
+ * @build TestLibrary Foo
  * @run main/othervm/policy=security.policy GetClassLoader
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/loadProxyClasses/LoadProxyClasses.java	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/loadProxyClasses/LoadProxyClasses.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,9 +30,10 @@
  * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build TestLibrary FnnClass FnnUnmarshal LoadProxyClasses NonpublicInterface
- * @build NonpublicInterface1 PublicInterface PublicInterface1
- * @run main/othervm/policy=security.policy LoadProxyClasses
+ * @build TestLibrary FnnClass FnnUnmarshal NonpublicInterface
+ *     NonpublicInterface1 PublicInterface PublicInterface1
+ * @run main/othervm/policy=security.policy
+ *     -Djava.rmi.server.useCodebaseOnly=false LoadProxyClasses
  */
 
 import java.rmi.server.RMIClassLoader;
--- jdk/test/java/rmi/server/RMIClassLoader/loadProxyClasses/security.policy	2012-08-10 10:34:43.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/loadProxyClasses/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -13,6 +13,7 @@
     permission java.io.FilePermission ".${/}-", "read,write,delete";
 
     permission java.lang.RuntimePermission "createClassLoader";
+    permission java.lang.RuntimePermission "getClassLoader";
     permission java.lang.RuntimePermission "setContextClassLoader";
 
     // used by TestLibrary to determine test environment
--- jdk/test/java/rmi/server/RMIClassLoader/noSecurityManager/NoSecurityManager.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/noSecurityManager/NoSecurityManager.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,7 +30,7 @@
  * been used for the RMI class loader instance.
  * @author Peter Jones
  *
- * @build NoSecurityManager Dummy LocalDummy
+ * @build Dummy LocalDummy
  * @run main/othervm/timeout=120 NoSecurityManager
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/spi/ContextInsulation.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/spi/ContextInsulation.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,11 +30,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build ContextInsulation
- * @build ServiceConfiguration
- * @build TestProvider
- * @build TestProvider2
+ * @build TestLibrary ServiceConfiguration TestProvider TestProvider2
  * @run main/othervm/policy=security.policy ContextInsulation
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/spi/DefaultProperty.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/spi/DefaultProperty.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,10 +29,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build DefaultProperty
- * @build ServiceConfiguration
- * @build Foo
+ * @build TestLibrary ServiceConfiguration Foo
  * @run main/othervm/policy=security.policy DefaultProperty
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/spi/Installed.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/spi/Installed.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,11 +29,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build Installed
- * @build ServiceConfiguration
- * @build TestProvider
- * @build TestProvider2
+ * @build TestLibrary ServiceConfiguration TestProvider TestProvider2
  * @run main/othervm/policy=security.policy Installed
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/spi/InvalidProperty.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/spi/InvalidProperty.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,9 +29,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build InvalidProperty
- * @build ServiceConfiguration
+ * @build TestLibrary ServiceConfiguration
  * @run main/othervm/policy=security.policy InvalidProperty
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/spi/Property.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/spi/Property.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,10 +29,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build Property
- * @build ServiceConfiguration
- * @build TestProvider
+ * @build TestLibrary ServiceConfiguration TestProvider
  * @run main/othervm/policy=security.policy Property
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/useCodebaseOnly/UseCodebaseOnly.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/useCodebaseOnly/UseCodebaseOnly.java	2013-05-05 09:38:44.000000000 -0700
@@ -31,12 +31,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build Receiver
- * @build UseCodebaseOnly
- * @build UseCodebaseOnly_Stub
- * @build Foo
- * @build Bar
+ * @build TestLibrary Receiver UseCodebaseOnly_Stub Foo Bar
  * @run main/othervm/policy=security.policy UseCodebaseOnly
  */
 
--- jdk/test/java/rmi/server/RMIClassLoader/useCodebaseOnlyDefault/UseCodebaseOnlyDefault.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/rmi/server/RMIClassLoader/useCodebaseOnlyDefault/UseCodebaseOnlyDefault.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8001040
+ * @summary Tests proper parsing and defaulting of the
+ * "java.rmi.server.useCodebaseOnly" property.
+ *
+ * @run main/othervm UseCodebaseOnlyDefault true
+ * @run main/othervm -Djava.rmi.server.useCodebaseOnly=xyzzy UseCodebaseOnlyDefault true
+ * @run main/othervm -Djava.rmi.server.useCodebaseOnly UseCodebaseOnlyDefault true
+ * @run main/othervm -Djava.rmi.server.useCodebaseOnly=true UseCodebaseOnlyDefault true
+ * @run main/othervm -Djava.rmi.server.useCodebaseOnly=false UseCodebaseOnlyDefault false
+ */
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectOutputStream;
+import java.lang.reflect.Field;
+import sun.rmi.server.MarshalInputStream;
+
+/**
+ * usage: UseCodebaseOnlyDefault expected
+ *
+ * 'expected' is the expected value of useCodebaseOnly, which
+ * must be "true" or "false".
+ */
+public class UseCodebaseOnlyDefault {
+    static final String USAGE = "usage: UseCodebaseOnlyDefault boolean";
+    static final String PROPNAME = "java.rmi.server.useCodebaseOnly";
+
+    /**
+     * Gets the actual useCodebaseOnly value by creating an instance
+     * of MarshalInputStream and reflecting on the useCodebaseOnly field.
+     */
+    static boolean getActualValue() throws Exception {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(baos);
+        oos.writeObject("foo");
+        oos.close();
+
+        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
+        MarshalInputStream mis = new MarshalInputStream(bais);
+
+        Field f = MarshalInputStream.class.getDeclaredField("useCodebaseOnly");
+        f.setAccessible(true);
+        return f.getBoolean(mis);
+    }
+
+    public static void main(String[] args) throws Exception {
+        if (args.length != 1) {
+            throw new IllegalArgumentException(USAGE);
+        }
+
+        boolean expected;
+        if (args[0].equals("true")) {
+            expected = true;
+        } else if (args[0].equals("false")) {
+            expected = false;
+        } else {
+            throw new IllegalArgumentException(USAGE);
+        }
+        System.out.println("expected = " + expected);
+
+        String prop = System.getProperty(PROPNAME);
+        System.out.print("Property " + PROPNAME);
+        if (prop == null) {
+            System.out.println(" is not set");
+        } else {
+            System.out.println(" = '" + prop + "'");
+        }
+
+        boolean actual = getActualValue();
+        System.out.println("actual = " + actual);
+
+        if (expected != actual)
+            throw new AssertionError("actual does not match expected value");
+    }
+}
--- jdk/test/java/rmi/server/RMIClassLoader/useGetURLs/UseGetURLs.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMIClassLoader/useGetURLs/UseGetURLs.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,8 +30,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build UseGetURLs Dummy
+ * @build TestLibrary Dummy
  * @run main/othervm/policy=security.policy/timeout=120 UseGetURLs
  */
 
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/activatable/EchoImpl.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/activatable/EchoImpl.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -128,8 +128,9 @@
             ActivationGroup.createGroup(groupID, groupDesc, 0);
 
             EchoImpl impl = new EchoImpl(protocol);
-            System.out.println("EchoServer: binding in registry");
-            Naming.rebind("//:" + UseCustomSocketFactory.REGISTRY_PORT +
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
+            System.out.println("EchoServer: binding in registry on port:" + registryPort);
+            Naming.rebind("//:" + registryPort +
                           "/EchoServer", impl);
             System.out.println("EchoServer ready.");
         } catch (Exception e) {
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/activatable/UseCustomSocketFactory.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/activatable/UseCustomSocketFactory.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,10 +28,7 @@
  * @author Ann Wollrath
  *
  * @library ../../../../testlibrary
- * @build Echo
- * @build EchoImpl
- * @build EchoImpl_Stub
- * @build UseCustomSocketFactory
+ * @build TestLibrary Echo EchoImpl EchoImpl_Stub
  * @run main/othervm/policy=security.policy/timeout=360 UseCustomSocketFactory
  */
 
@@ -42,8 +39,8 @@
 import java.rmi.registry.*;
 
 public class UseCustomSocketFactory {
+    static final int REGISTRY_PORT = TestLibrary.getUnusedRandomPort();
 
-    final static int REGISTRY_PORT = 2006;
     static String[] protocol = new String[] { "", "compress", "xor" };
 
     public static void main(String[] args) {
@@ -68,7 +65,7 @@
                     " -C-Djava.security.manager=java.rmi.RMISecurityManager "});
             rmid.start();
 
-            Echo[] echo = spawnAndTest();
+            Echo[] echo = spawnAndTest(rmid.getPort());
             reactivateAndTest(echo);
         } catch (IOException e) {
             TestLibrary.bomb("creating rmid", e);
@@ -78,17 +75,20 @@
         }
     }
 
-    private static Echo[] spawnAndTest() {
+    private static Echo[] spawnAndTest(int rmidPort) {
 
         System.err.println("\nCreate Test-->");
 
         Echo[] echo = new Echo[protocol.length];
 
         for (int i = 0; i < protocol.length; i++) {
-
             JavaVM serverVM = new JavaVM("EchoImpl",
                                          "-Djava.security.policy=" +
-                                         TestParams.defaultPolicy,
+                                         TestParams.defaultPolicy +
+                                         " -Drmi.registry.port=" +
+                                         REGISTRY_PORT +
+                                         " -Djava.rmi.activation.port=" +
+                                         rmidPort,
                                          protocol[i]);
 
             System.err.println("\nusing protocol: " +
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/activatable/security.policy	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/activatable/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -30,6 +30,9 @@
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
 
+  permission java.util.PropertyPermission "rmi.registry.port", "read";
+  permission java.util.PropertyPermission "java.rmi.activation.port", "write";
+
   // required for test to create an ActivationGroup
   permission java.lang.RuntimePermission "setFactory";
 
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/registry/HelloImpl.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/registry/HelloImpl.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -65,8 +65,9 @@
             if (args.length >= 1)
                 protocol = args[0];
 
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
             registry = java.rmi.registry.LocateRegistry.
-                getRegistry("localhost", TestLibrary.REGISTRY_PORT,
+                getRegistry("localhost", registryPort,
                             new Compress.CompressRMIClientSocketFactory());
             UseCustomSocketFactory.checkStub(registry, "RMIClientSocket");
             hello = (Hello) registry.lookup("/HelloServer");
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/registry/UseCustomSocketFactory.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/registry/UseCustomSocketFactory.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,11 +29,7 @@
  * @author Laird Dornin; code borrowed from Ann Wollrath
  *
  * @library ../../../../testlibrary
- * @build Hello
- * @build HelloImpl
- * @build HelloImpl_Stub
- * @build UseCustomSocketFactory
- * @build Compress
+ * @build TestLibrary Compress Hello HelloImpl HelloImpl_Stub
  * @run main/othervm/policy=security.policy/timeout=240 UseCustomSocketFactory
  */
 
@@ -58,6 +54,7 @@
         System.out.println("\nRegression test for bug 4148850\n");
 
         TestLibrary.suggestSecurityManager("java.rmi.RMISecurityManager");
+        int registryPort = TestLibrary.getUnusedRandomPort();
 
         try {
             impl = new HelloImpl();
@@ -67,7 +64,7 @@
              * allow the rmiregistry to be secure.
              */
             registry = LocateRegistry.
-                createRegistry(TestLibrary.REGISTRY_PORT,
+                createRegistry(registryPort,
                                new Compress.CompressRMIClientSocketFactory(),
                                new Compress.CompressRMIServerSocketFactory());
             registry.rebind("/HelloServer", impl);
@@ -77,8 +74,12 @@
             TestLibrary.bomb("creating registry", e);
         }
 
-        JavaVM serverVM = new JavaVM("HelloImpl", "-Djava.security.policy=" +
-                                     TestParams.defaultPolicy, "");
+        JavaVM serverVM = new JavaVM("HelloImpl",
+                                     "-Djava.security.policy=" +
+                                     TestParams.defaultPolicy +
+                                     " -Drmi.registry.port=" +
+                                     registryPort,
+                                     "");
 
         try {
 
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/registry/security.policy	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/registry/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -22,6 +22,8 @@
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
 
+  permission java.util.PropertyPermission "rmi.registry.port", "read";	
+
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/unicast/EchoImpl.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/unicast/EchoImpl.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -64,8 +64,9 @@
 
             System.out.println("EchoServer: creating remote object");
             EchoImpl impl = new EchoImpl(protocol);
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
             System.out.println("EchoServer: binding in registry");
-            Naming.rebind("//:" + TestLibrary.REGISTRY_PORT +
+            Naming.rebind("//:" + registryPort +
                           "/EchoServer", impl);
             System.out.println("EchoServer ready.");
         } catch (Exception e) {
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/unicast/UseCustomSocketFactory.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/unicast/UseCustomSocketFactory.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,11 +29,7 @@
  * @author Ann Wollrath
  *
  * @library ../../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build Echo
- * @build EchoImpl
- * @build EchoImpl_Stub
- * @build UseCustomSocketFactory
+ * @build TestLibrary RMID JavaVM Echo EchoImpl EchoImpl_Stub
  * @run main/othervm/policy=security.policy/timeout=120 UseCustomSocketFactory
  */
 
@@ -46,6 +42,8 @@
 
     public static void main(String[] args) {
 
+        int registryPort = -1;
+
         String[] protocol = new String[] { "", "compress", "xor" };
 
         System.out.println("\nRegression test for bug 4127826\n");
@@ -53,7 +51,8 @@
         TestLibrary.suggestSecurityManager("java.rmi.RMISecurityManager");
 
         try {
-            LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+            Registry registry = TestLibrary.createRegistryOnUnusedPort();
+            registryPort = TestLibrary.getRegistryPort(registry);
         } catch (Exception e) {
             TestLibrary.bomb("creating registry", e);
         }
@@ -65,7 +64,9 @@
 
             JavaVM serverVM = new JavaVM("EchoImpl",
                                          "-Djava.security.policy=" +
-                                         TestParams.defaultPolicy,
+                                         TestParams.defaultPolicy +
+                                         " -Drmi.registry.port=" +
+                                         registryPort,
                                          protocol[i]);
             System.err.println("\nusing protocol: " +
                                (protocol[i] == "" ? "none" : protocol[i]));
@@ -79,7 +80,7 @@
                 Echo obj = null;
                 do {
                     try {
-                        obj = (Echo) Naming.lookup("//:" + TestLibrary.REGISTRY_PORT +
+                        obj = (Echo) Naming.lookup("//:" + registryPort +
                                                    "/EchoServer");
                         break;
                     } catch (NotBoundException e) {
@@ -109,7 +110,7 @@
             } finally {
                 serverVM.destroy();
                 try {
-                    Naming.unbind("//:" + TestLibrary.REGISTRY_PORT +
+                    Naming.unbind("//:" + registryPort +
                                   "/EchoServer");
                 } catch (Exception e) {
                     TestLibrary.bomb("unbinding EchoServer", e);
--- jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/unicast/security.policy	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RMISocketFactory/useSocketFactory/unicast/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -22,9 +22,18 @@
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
 
+  permission java.util.PropertyPermission "rmi.registry.port", "read";	
+
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
+  // used by TestLibrary to get the RMI Registry port
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.registry";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.server";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.proxy";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.tcp";
+
   // test needs to export rmid and communicate with objects on arbitrary ports
   permission java.net.SocketPermission "*:1024-", "connect,accept,listen";
 };
--- jdk/test/java/rmi/server/RemoteObject/notExtending/NotExtending.java	2012-08-10 10:34:44.000000000 -0700
+++ jdk/test/java/rmi/server/RemoteObject/notExtending/NotExtending.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,9 +29,7 @@
  *          (specifically: stubs) that contain the instance's RemoteRef.
  * @author Peter Jones
  *
- * @build NotExtending
- * @build NotExtending_Stub
- * @build NotExtending_Skel
+ * @build NotExtending_Stub NotExtending_Skel
  * @run main/othervm/timeout=240 NotExtending
  */
 
--- jdk/test/java/rmi/server/RemoteObject/verifyRemoteEquals/VerifyRemoteEquals.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/RemoteObject/verifyRemoteEquals/VerifyRemoteEquals.java	2013-05-05 09:38:44.000000000 -0700
@@ -21,16 +21,16 @@
  * questions.
  */
 
-/**
+/*
  * @test
  * @bug 4251010
  * @summary equals does not works on stub objects created with
  *           custom socket AndFactory
- * @library ../../../testlibrary
+ * @author Laird Dornin
  *
- * @build VerifyRemoteEquals
+ * @library ../../../testlibrary
+ * @build TestLibrary
  * @run main/othervm/timeout=40 VerifyRemoteEquals
- * @author Laird Dornin
  */
 
 import java.io.*;
--- jdk/test/java/rmi/server/RemoteServer/AddrInUse.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/RemoteServer/AddrInUse.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,6 @@
  * @summary retryServerSocket should not retry on BindException
  * @author Ann Wollrath
  *
- * @build AddrInUse
  * @run main/othervm AddrInUse
  */
 
@@ -36,7 +35,7 @@
 
 public class AddrInUse implements Runnable {
 
-    private static final int PORT = 9999;
+    private static int port = -1;
     private static final long TIMEOUT = 10000;
 
     private boolean exportSucceeded = false;
@@ -49,7 +48,7 @@
          * has already been bound, and record the result.
          */
         try {
-            LocateRegistry.createRegistry(PORT);
+            LocateRegistry.createRegistry(port);
             synchronized (this) {
                 exportSucceeded = true;
                 notifyAll();
@@ -68,8 +67,9 @@
         /*
          * Bind a server socket to a port.
          */
-        System.err.println("create a ServerSocket on port " + PORT + "...");
-        ServerSocket server = new ServerSocket(PORT);
+        ServerSocket server = new ServerSocket(0);
+        port = server.getLocalPort();
+        System.err.println("Created a ServerSocket on port " + port + "...");
 
         /*
          * Start a thread that creates a registry on the same port,
--- jdk/test/java/rmi/server/UnicastRemoteObject/changeHostName/ChangeHostName.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/changeHostName/ChangeHostName.java	2013-05-05 09:38:44.000000000 -0700
@@ -31,8 +31,7 @@
  *
  * @author Ann Wollrath
  *
- * @build ChangeHostName
- * @build ChangeHostName_Stub
+ * @build ChangeHostName ChangeHostName_Stub
  * @run main/othervm ChangeHostName
  */
 
--- jdk/test/java/rmi/server/UnicastRemoteObject/exportObject/GcDuringExport.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/exportObject/GcDuringExport.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,6 +30,7 @@
  * @bug 6597112
  * @summary GC'ing objects whilst being exported to RMI should not cause exceptions
  * @author Neil Richards <neil.richards@ngmr.net>, <neil_richards@uk.ibm.com>
+ * @run main GcDuringExport
  */
 
 import java.rmi.Remote;
--- jdk/test/java/rmi/server/UnicastRemoteObject/keepAliveDuringCall/KeepAliveDuringCall.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/keepAliveDuringCall/KeepAliveDuringCall.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,14 +32,8 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build JavaVM
- * @build KeepAliveDuringCall
- * @build KeepAliveDuringCall_Stub
- * @build ShutdownMonitor
- * @build Shutdown
- * @build ShutdownImpl
- * @build ShutdownImpl_Stub
+ * @build TestLibrary JavaVM KeepAliveDuringCall_Stub
+ *     ShutdownMonitor Shutdown ShutdownImpl ShutdownImpl_Stub
  * @run main/othervm KeepAliveDuringCall
  */
 
@@ -82,15 +76,17 @@
             UnicastRemoteObject.exportObject(obj);
             System.err.println("exported shutdown monitor");
 
-            Registry localRegistry =
-                LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+            Registry localRegistry = TestLibrary.createRegistryOnUnusedPort();
+            int registryPort = TestLibrary.getRegistryPort(localRegistry);
             System.err.println("created local registry");
 
             localRegistry.bind(BINDING, obj);
             System.err.println("bound shutdown monitor in local registry");
 
             System.err.println("starting remote ShutdownImpl VM...");
-            (new JavaVM("ShutdownImpl")).start();
+            (new JavaVM("ShutdownImpl",
+                        "-Drmi.registry.port=" +
+                        registryPort, "")).start();
 
             Shutdown s;
             synchronized (obj.lock) {
--- jdk/test/java/rmi/server/UnicastRemoteObject/keepAliveDuringCall/ShutdownImpl.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/keepAliveDuringCall/ShutdownImpl.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -68,8 +68,9 @@
 
     public static void main(String[] args) {
         try {
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
             Registry registry =
-                LocateRegistry.getRegistry("", TestLibrary.REGISTRY_PORT);
+                LocateRegistry.getRegistry("", registryPort);
             ShutdownMonitor monitor = (ShutdownMonitor)
                 registry.lookup(KeepAliveDuringCall.BINDING);
             System.err.println("(ShutdownImpl) retrieved shutdown monitor");
--- jdk/test/java/rmi/server/UnicastRemoteObject/marshalAfterUnexport/MarshalAfterUnexport.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/marshalAfterUnexport/MarshalAfterUnexport.java	2013-05-05 09:38:44.000000000 -0700
@@ -31,8 +31,7 @@
  * IOException (see fix for bugid 4017232).
  * @author Peter Jones
  *
- * @build MarshalAfterUnexport
- * @build MarshalAfterUnexport_Stub
+ * @build MarshalAfterUnexport MarshalAfterUnexport_Stub
  * @run main/othervm MarshalAfterUnexport
  */
 
--- jdk/test/java/rmi/server/UnicastRemoteObject/marshalAfterUnexport/MarshalAfterUnexport2.java	2012-08-10 10:34:45.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/marshalAfterUnexport/MarshalAfterUnexport2.java	2013-05-05 09:38:44.000000000 -0700
@@ -33,8 +33,7 @@
  * @author Peter Jones
  * @author Ann Wollrath
  *
- * @build MarshalAfterUnexport2
- * @build MarshalAfterUnexport2_Stub
+ * @build MarshalAfterUnexport2 MarshalAfterUnexport2_Stub
  * @run main/othervm MarshalAfterUnexport2
  */
 
--- jdk/test/java/rmi/server/UnicastRemoteObject/unexportObject/UnexportLeak.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/UnicastRemoteObject/unexportObject/UnexportLeak.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,9 +28,8 @@
  *
  * @author Ann Wollrath
  *
- * @build UnexportLeak
- * @build UnexportLeak_Stub
- * @build Ping
+ * @library ../../../testlibrary
+ * @build TestLibrary UnexportLeak_Stub Ping
  * @run main/othervm UnexportLeak
  */
 
@@ -40,20 +39,18 @@
 import java.rmi.registry.*;
 
 public class UnexportLeak implements Ping {
-
-    private static int PORT = 2006;
-
     public void ping() {
     }
 
     public static void main(String[] args) {
         try {
             System.err.println("\nRegression test for bug 4331349\n");
-            LocateRegistry.createRegistry(PORT);
+            Registry registry = TestLibrary.createRegistryOnUnusedPort();
+            int registryPort = TestLibrary.getRegistryPort(registry);
             Remote obj = new UnexportLeak();
             WeakReference wr = new WeakReference(obj);
             UnicastRemoteObject.exportObject(obj);
-            LocateRegistry.getRegistry(PORT).rebind("UnexportLeak", obj);
+            LocateRegistry.getRegistry(registryPort).rebind("UnexportLeak", obj);
             UnicastRemoteObject.unexportObject(obj, true);
             obj = null;
             flushRefs();
--- jdk/test/java/rmi/server/Unmarshal/PrimitiveClasses.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unmarshal/PrimitiveClasses.java	2013-05-05 09:38:44.000000000 -0700
@@ -25,6 +25,7 @@
  * @bug 4442373
  * @summary Verify that RMI can successfully unmarshal Class objects for
  *          primitive types.
+ * @run main PrimitiveClasses
  */
 
 import java.rmi.MarshalledObject;
--- jdk/test/java/rmi/server/Unmarshal/checkUnmarshalOnStopThread/CheckUnmarshal.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/rmi/server/Unmarshal/checkUnmarshalOnStopThread/CheckUnmarshal.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ *
+ */
+import java.rmi.Remote;
+import java.rmi.RemoteException;
+    /*
+     * Interface with methods to exercise RMI parameter marshalling
+     * and unmarshalling.
+     */
+    interface CheckUnmarshal extends java.rmi.Remote {
+        public PoisonPill getPoisonPill() throws RemoteException;
+        public Object ping() throws RemoteException;
+        public void passRuntimeExceptionParameter(
+            RuntimeExceptionParameter rep)
+        throws RemoteException;
+    }
--- jdk/test/java/rmi/server/Unmarshal/checkUnmarshalOnStopThread/CheckUnmarshalOnStopThread.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unmarshal/checkUnmarshalOnStopThread/CheckUnmarshalOnStopThread.java	2013-05-05 09:38:44.000000000 -0700
@@ -31,10 +31,8 @@
  * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build TestLibrary RMID JavaVM StreamPipe
- * @build CheckUnmarshall PoisonPill RuntimeExceptionParameter
- * @build CheckUnmarshalOnStopThread
- * @build CheckUnmarshalOnStopThread_Stub
+ * @build TestLibrary CheckUnmarshal CheckUnmarshalOnStopThread_Stub
+ *     PoisonPill RuntimeExceptionParameter
  * @run main/othervm/timeout=480 CheckUnmarshalOnStopThread
  */
 
--- jdk/test/java/rmi/server/Unmarshal/checkUnmarshalOnStopThread/CheckUnmarshall.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unmarshal/checkUnmarshalOnStopThread/CheckUnmarshall.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/**
- *
- */
-import java.rmi.Remote;
-import java.rmi.RemoteException;
-    /*
-     * Interface with methods to exercise RMI parameter marshalling
-     * and unmarshalling.
-     */
-    interface CheckUnmarshal extends java.rmi.Remote {
-        public PoisonPill getPoisonPill() throws RemoteException;
-        public Object ping() throws RemoteException;
-        public void passRuntimeExceptionParameter(
-            RuntimeExceptionParameter rep)
-        throws RemoteException;
-    }
--- jdk/test/java/rmi/server/Unreferenced/finiteGCLatency/FiniteGCLatency.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unreferenced/finiteGCLatency/FiniteGCLatency.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,8 +35,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build FiniteGCLatency
- * @build FiniteGCLatency_Stub
+ * @build TestLibrary FiniteGCLatency_Stub
  * @run main/othervm/timeout=120 FiniteGCLatency
  */
 
@@ -78,11 +77,11 @@
         try {
             UnicastRemoteObject.exportObject(obj);
             System.err.println("exported remote object");
-
-            LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+            Registry registry1 = TestLibrary.createRegistryOnUnusedPort();
+            int port = TestLibrary.getRegistryPort(registry1);
             System.err.println("created registry");
 
-            Registry registry = LocateRegistry.getRegistry("", TestLibrary.REGISTRY_PORT);
+            Registry registry = LocateRegistry.getRegistry("", port);
             registry.bind(BINDING, obj);
             System.err.println("bound remote object in registry");
 
--- jdk/test/java/rmi/server/Unreferenced/leaseCheckInterval/LeaseCheckInterval.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unreferenced/leaseCheckInterval/LeaseCheckInterval.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,11 +37,7 @@
  * @author Peter Jones
  *
  * @library ../../../testlibrary
- * @build TestLibrary
- * @build JavaVM
- * @build LeaseCheckInterval
- * @build LeaseCheckInterval_Stub
- * @build SelfTerminator
+ * @build TestLibrary JavaVM LeaseCheckInterval_Stub SelfTerminator
  * @run main/othervm LeaseCheckInterval
  */
 
@@ -87,8 +83,9 @@
             UnicastRemoteObject.exportObject(obj);
             System.err.println("exported remote object");
 
+            int registryPort = TestLibrary.getUnusedRandomPort();
             Registry localRegistry =
-                LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+                LocateRegistry.createRegistry(registryPort);
             System.err.println("created local registry");
 
             localRegistry.bind(BINDING, obj);
@@ -96,7 +93,8 @@
 
             synchronized (obj.lock) {
                 System.err.println("starting remote client VM...");
-                (new JavaVM("SelfTerminator")).start();
+                (new JavaVM("SelfTerminator", "-Drmi.registry.port=" +
+                            registryPort, "")).start();
 
                 System.err.println("waiting for unreferenced() callback...");
                 obj.lock.wait(TIMEOUT);
--- jdk/test/java/rmi/server/Unreferenced/leaseCheckInterval/SelfTerminator.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unreferenced/leaseCheckInterval/SelfTerminator.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,8 +33,10 @@
 
     public static void main(String[] args) {
         try {
+            int registryPort =
+                Integer.parseInt(System.getProperty("rmi.registry.port"));
             Registry registry =
-                LocateRegistry.getRegistry("", TestLibrary.REGISTRY_PORT);
+                LocateRegistry.getRegistry("", registryPort);
             Remote stub = registry.lookup(LeaseCheckInterval.BINDING);
             Runtime.getRuntime().halt(0);
         } catch (Exception e) {
--- jdk/test/java/rmi/server/Unreferenced/marshalledObjectGet/MarshalledObjectGet.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unreferenced/marshalledObjectGet/MarshalledObjectGet.java	2013-05-05 09:38:44.000000000 -0700
@@ -30,8 +30,6 @@
  * invoked.
  * @author Peter Jones
  *
- * @library ../../../testlibrary
- * @build MarshalledObjectGet
  * @build MarshalledObjectGet_Stub
  * @run main/othervm/timeout=120 MarshalledObjectGet
  */
--- jdk/test/java/rmi/server/Unreferenced/unreferencedContext/UnreferencedContext.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/Unreferenced/unreferencedContext/UnreferencedContext.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,8 +39,7 @@
  * @author Laird Dornin
  *
  * @library ../../../testlibrary
- * @build UnreferencedContext
- * @build UnreferencedContext_Stub
+ * @build TestLibrary UnreferencedContext_Stub
  * @run main/othervm/timeout=120 UnreferencedContext
  */
 
@@ -119,10 +118,11 @@
             UnicastRemoteObject.exportObject(obj);
             System.err.println("exported remote object");
 
-            LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+            Registry registry1 = TestLibrary.createRegistryOnUnusedPort();
+            int port = TestLibrary.getRegistryPort(registry1);
             System.err.println("created registry");
 
-            Registry registry = LocateRegistry.getRegistry("", TestLibrary.REGISTRY_PORT);
+            Registry registry = LocateRegistry.getRegistry("", port);
             registry.bind(BINDING, obj);
             System.err.println("bound remote object in registry");
 
--- jdk/test/java/rmi/server/clientStackTrace/ClientStackTrace.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/clientStackTrace/ClientStackTrace.java	2013-05-05 09:38:44.000000000 -0700
@@ -28,7 +28,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build ClientStackTrace MyRemoteObject_Stub TestLibrary TestParams
+ * @build TestLibrary ClientStackTrace MyRemoteObject_Stub
  * @run main/othervm/policy=security.policy/timeout=120 ClientStackTrace
  */
 
--- jdk/test/java/rmi/server/getRemoteClass/GetRemoteClass.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/getRemoteClass/GetRemoteClass.java	2013-05-05 09:38:44.000000000 -0700
@@ -28,7 +28,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build GetRemoteClass TestLibrary TestParams
+ * @build TestLibrary
  * @run main/othervm GetRemoteClass
  */
 
--- jdk/test/java/rmi/server/serverStackTrace/ServerStackTrace.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/serverStackTrace/ServerStackTrace.java	2013-05-05 09:38:44.000000000 -0700
@@ -29,8 +29,7 @@
  * serialized with the Throwable from the server.
  * @author Peter Jones
  *
- * @build ServerStackTrace
- * @build ServerStackTrace_Stub
+ * @build ServerStackTrace ServerStackTrace_Stub
  * @run main/othervm ServerStackTrace
  */
 
--- jdk/test/java/rmi/server/serverStackTrace/SuppressStackTraces.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/serverStackTrace/SuppressStackTraces.java	2013-05-05 09:38:44.000000000 -0700
@@ -36,10 +36,7 @@
  * for reasons of performance or confidentiality requirements.
  * @author Peter Jones
  *
- * @build SuppressStackTraces
- * @build Impl2_Stub
- * @build Impl1_Stub
- * @build Impl1_Skel
+ * @build SuppressStackTraces Impl2_Stub Impl1_Stub Impl1_Skel
  * @run main/othervm SuppressStackTraces
  */
 
--- jdk/test/java/rmi/server/useCustomRef/UseCustomRef.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/useCustomRef/UseCustomRef.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,10 +31,7 @@
  * 4180392
  *
  * @library ../../testlibrary
- * @build UseCustomRef
- * @build Ping
- * @build UseCustomRef_Stub
- * @build UseCustomRef_Skel
+ * @build TestLibrary Ping UseCustomRef_Stub UseCustomRef_Skel
  * @run main/othervm/policy=security.policy/secure=java.rmi.RMISecurityManager/timeout=120 UseCustomRef
  *
  * This test was failing to run because the synthetic access
@@ -84,8 +81,9 @@
             TestLibrary.suggestSecurityManager("java.rmi.RMISecurityManager");
 
             System.err.println("creating Registry...");
-            registry = LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
 
+            registry = TestLibrary.createRegistryOnUnusedPort();
+            int port = TestLibrary.getRegistryPort(registry);
             /*
              * create object with custom ref and bind in registry
              */
@@ -97,7 +95,7 @@
                                 "instanceof CustomServerRef");
             }
 
-            String name = "//:" + TestLibrary.REGISTRY_PORT + "/UseCustomRef";
+            String name = "//:" + port + "/UseCustomRef";
             //      String name = "UseCustomRef";
             System.err.println("binding object in registry...");
             Naming.rebind(name, cr);
--- jdk/test/java/rmi/server/useCustomRef/security.policy	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/server/useCustomRef/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -8,8 +8,11 @@
 
 grant {
   // the test uses a class in the package sun.rmi.server
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.registry";
   permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.server";
   permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.proxy";
+  permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.tcp";
   permission java.util.PropertyPermission "package.restrict.access.sun", "read";
   permission java.util.PropertyPermission "package.restrict.access.sun.rmi", "read";
 
--- jdk/test/java/rmi/testlibrary/ActivationLibrary.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/testlibrary/ActivationLibrary.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,19 +63,30 @@
      */
     public static void deactivate(Remote remote,
                                   ActivationID id) {
-        for (int i = 0; i < 5; i ++) {
+        // We do as much as 50 deactivation trials, each separated by
+        // at least 100 milliseconds sleep time (max sleep time of 5 secs).
+        final long deactivateSleepTime = 100;
+        for (int i = 0; i < 50; i ++) {
             try {
                 if (Activatable.inactive(id) == true) {
                     mesg("inactive successful");
                     return;
                 } else {
-                    Thread.sleep(1000);
+                    mesg("inactive trial failed. Sleeping " +
+                         deactivateSleepTime +
+                         " milliseconds before next trial");
+                    Thread.sleep(deactivateSleepTime);
                 }
             } catch (InterruptedException e) {
-                continue;
+                Thread.currentThread().interrupt();
+                mesg("Thread interrupted while trying to deactivate activatable. Exiting deactivation");
+                return;
             } catch (Exception e) {
                 try {
                     // forcibly unexport the object
+                    mesg("Unexpected exception. Have to forcibly unexport the object." +
+                         " Exception was :");
+                    e.printStackTrace();
                     Activatable.unexportObject(remote, true);
                 } catch (NoSuchObjectException ex) {
                 }
@@ -99,59 +110,60 @@
      * activation system.
      */
     public static boolean rmidRunning(int port) {
-        int allowedNotReady = 10;
+        int allowedNotReady = 50;
         int connectionRefusedExceptions = 0;
 
-        for (int i = 0; i < 15 ; i++) {
+        /* We wait as much as a total of 7.5 secs trying to see Rmid running.
+         * We do this by pausing steps of 100 milliseconds (so up to 75 steps),
+         * right after trying to lookup and find RMID running in the other vm.
+         */
+        final long rmidWaitingStepTime = 100;
+        for (int i = 0; i <= 74; i++) {
 
             try {
-                Thread.sleep(500);
                 LocateRegistry.getRegistry(port).lookup(SYSTEM_NAME);
+                mesg("Activation System available after " +
+                     (i * rmidWaitingStepTime) + " milliseconds");
                 return true;
 
             } catch (java.rmi.ConnectException e) {
-                // ignore connect exceptions until we decide rmid is not up
+                mesg("Remote connection refused after " +
+                     (i * rmidWaitingStepTime) + " milliseconds");
 
+                // ignore connect exceptions until we decide rmid is not up
                 if ((connectionRefusedExceptions ++) >= allowedNotReady) {
                     return false;
                 }
 
-            } catch (NotBoundException e) {
+            } catch (java.rmi.NoSuchObjectException nsoe) {
+                /* Activation System still unavailable.
+                 * Ignore this since we are just waiting for its availibility.
+                 * Just signal unavailibility.
+                 */
+                mesg("Activation System still unavailable after more than " +
+                     (i * rmidWaitingStepTime) + " milliseconds");
 
+            } catch (NotBoundException e) {
                 return false;
 
             } catch (Exception e) {
-                // print out other types of exceptions as an FYI.
-                // test should not fail as rmid is likely to be in an
-                // undetermined state at this point.
-
+                /* print out other types of exceptions as an FYI.
+                 * test should not fail as rmid is likely to be in an
+                 * undetermined state at this point.
+                 */
                 mesg("caught an exception trying to" +
                      " start rmid, last exception was: " +
                      e.getMessage());
                 e.printStackTrace();
             }
-        }
-        return false;
-    }
 
-    /**
-     * Check to see if an arry of Strings contains a given string.
-     */
-    private static boolean
-        containsString(String[] strings, String contained)
-    {
-        if (strings == null) {
-            if (contained == null) {
-                return true;
-            }
-            return false;
-        }
-
-        for (int i = 0 ; i < strings.length ; i ++ ) {
-            if ((strings[i] != null) &&
-                (strings[i].indexOf(contained) >= 0))
-            {
-                return true;
+            // Waiting for another 100 milliseconds.
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+                mesg("Thread interrupted while checking if Activation System is running. Exiting check");
+                return false;
             }
         }
         return false;
@@ -159,12 +171,8 @@
 
     /** cleanup after rmid */
     public static void rmidCleanup(RMID rmid) {
-        rmidCleanup(rmid, TestLibrary.RMID_PORT);
-    }
-
-    public static void rmidCleanup(RMID rmid, int port) {
         if (rmid != null) {
-            if (!ActivationLibrary.safeDestroy(rmid, port, SAFE_WAIT_TIME)) {
+            if (!ActivationLibrary.safeDestroy(rmid, SAFE_WAIT_TIME)) {
                 TestLibrary.bomb("rmid not destroyed in: " +
                                  SAFE_WAIT_TIME +
                                  " milliseconds");
@@ -180,8 +188,8 @@
      * @return whether or not shutdown completed succesfully in the
      *         timeAllowed
      */
-    private static boolean safeDestroy(RMID rmid, int port, long timeAllowed) {
-        DestroyThread destroyThread = new DestroyThread(rmid, port);
+    private static boolean safeDestroy(RMID rmid, long timeAllowed) {
+        DestroyThread destroyThread = new DestroyThread(rmid);
         destroyThread.start();
 
         try {
@@ -201,9 +209,9 @@
         private final int port;
         private boolean succeeded = false;
 
-        DestroyThread(RMID rmid, int port) {
+        DestroyThread(RMID rmid) {
             this.rmid = rmid;
-            this.port = port;
+            this.port = rmid.getPort();
             this.setDaemon(true);
         }
 
--- jdk/test/java/rmi/testlibrary/JavaVM.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/testlibrary/JavaVM.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,13 +21,10 @@
  * questions.
  */
 
-/**
- *
- */
-
-import java.io.*;
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
 import java.util.Arrays;
-import java.util.Properties;
 import java.util.StringTokenizer;
 
 /**
@@ -36,7 +33,6 @@
  */
 public class JavaVM {
 
-    // need to
     protected Process vm = null;
 
     private String classname = "";
@@ -45,6 +41,8 @@
     private OutputStream outputStream = System.out;
     private OutputStream errorStream = System.err;
     private String policyFileName = null;
+    private StreamPipe outPipe;
+    private StreamPipe errPipe;
 
     private static void mesg(Object mesg) {
         System.err.println("JAVAVM: " + mesg.toString());
@@ -79,6 +77,7 @@
         this.errorStream = err;
     }
 
+    // Prepends passed opts array to current options
     public void addOptions(String[] opts) {
         String newOpts = "";
         for (int i = 0 ; i < opts.length ; i ++) {
@@ -87,6 +86,8 @@
         newOpts += " ";
         options = newOpts + options;
     }
+
+    // Prepends passed arguments array to current args
     public void addArguments(String[] arguments) {
         String newArgs = "";
         for (int i = 0 ; i < arguments.length ; i ++) {
@@ -109,13 +110,22 @@
         return TestLibrary.getExtraProperty("jcov.options","");
     }
 
+    public void start(Runnable runnable) throws IOException {
+        if (runnable == null) {
+            throw new NullPointerException("Runnable cannot be null.");
+        }
+
+        start();
+        new JavaVMCallbackHandler(runnable).start();
+    }
 
     /**
      * Exec the VM as specified in this object's constructor.
      */
     public void start() throws IOException {
 
-        if (vm != null) return;
+        if (vm != null)
+            throw new IllegalStateException("JavaVM already started");
 
         /*
          * If specified, add option for policy file
@@ -145,20 +155,12 @@
         }
 
         mesg("command = " + Arrays.asList(javaCommand).toString());
-        System.err.println("");
 
         vm = Runtime.getRuntime().exec(javaCommand);
 
         /* output from the execed process may optionally be captured. */
-        StreamPipe.plugTogether(vm.getInputStream(), this.outputStream);
-        StreamPipe.plugTogether(vm.getErrorStream(), this.errorStream);
-
-        try {
-            Thread.sleep(2000);
-        } catch (Exception ignore) {
-        }
-
-        mesg("finished starting vm.");
+        outPipe = StreamPipe.plugTogether(vm.getInputStream(), this.outputStream);
+        errPipe = StreamPipe.plugTogether(vm.getErrorStream(), this.errorStream);
     }
 
     public void destroy() {
@@ -168,7 +170,56 @@
         vm = null;
     }
 
-    protected Process getVM() {
-        return vm;
+    /**
+     * Waits for the subprocess to exit, joins the pipe threads to ensure that
+     * all output is collected, and returns its exit status.
+     */
+    public int waitFor() throws InterruptedException {
+        if (vm == null)
+            throw new IllegalStateException("can't wait for JavaVM that hasn't started");
+
+        int status = vm.waitFor();
+        outPipe.join();
+        errPipe.join();
+        return status;
+    }
+
+    /**
+     * Starts the subprocess, waits for it to exit, and returns its exit status.
+     */
+    public int execute() throws IOException, InterruptedException {
+        start();
+        return waitFor();
+    }
+
+    /**
+     * Handles calling the callback.
+     */
+    private class JavaVMCallbackHandler extends Thread {
+        Runnable runnable;
+
+        JavaVMCallbackHandler(Runnable runnable) {
+            this.runnable = runnable;
+        }
+
+
+        /**
+         * Wait for the Process to terminate and notify the callback.
+         */
+        @Override
+        public void run() {
+            if (vm != null) {
+                try {
+                    vm.waitFor();
+                } catch(InterruptedException ie) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            if (runnable != null) {
+                runnable.run();
+            }
+        }
     }
 }
--- jdk/test/java/rmi/testlibrary/RMID.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/testlibrary/RMID.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,6 @@
 import java.io.*;
 import java.rmi.*;
 import java.rmi.activation.*;
-import java.util.Properties;
 
 /**
  * Utility class that creates an instance of rmid with a policy
@@ -109,6 +108,9 @@
         if (!TestParams.testClasses.equals("")) {
             args += " -C-Dtest.classes=" + TestParams.testClasses;
         }
+
+        args += " -C-Djava.rmi.server.useCodebaseOnly=false ";
+
         args += " " + getCodeCoverageArgs();
         return args;
     }
@@ -133,7 +135,7 @@
                                   boolean debugExec)
     {
         return createRMID(out, err, debugExec, true,
-                          TestLibrary.RMID_PORT);
+                          TestLibrary.getUnusedRandomPort());
     }
 
     public static RMID createRMID(OutputStream out, OutputStream err,
@@ -203,12 +205,10 @@
 
     public void start(long waitTime) throws IOException {
 
-        if (getVM() != null) return;
-
         // if rmid is already running, then the test will fail with
         // a well recognized exception (port already in use...).
 
-        mesg("starting rmid...");
+        mesg("starting rmid on port #" + port + "...");
         super.start();
 
         int slopFactor = 1;
@@ -218,20 +218,38 @@
         } catch (NumberFormatException ignore) {}
         waitTime = waitTime * slopFactor;
 
-        // give rmid time to come up
+        // We check several times (as many as provides passed waitTime) to
+        // see if Rmid is currently running. Waiting steps last 100 msecs.
+        final long rmidStartSleepTime = 100;
         do {
+            // Sleeping for another rmidStartSleepTime time slice.
             try {
-                Thread.sleep(Math.min(waitTime, 10000));
+                Thread.sleep(Math.min(waitTime, rmidStartSleepTime));
             } catch (InterruptedException ie) {
                 Thread.currentThread().interrupt();
+                mesg("Thread interrupted while checking for start of Activation System. Giving up check.");
+                mesg("Activation System state unknown");
+                return;
             }
-            waitTime -= 10000;
+            waitTime -= rmidStartSleepTime;
 
-            // is rmid present?
+            // Checking if rmid is present
             if (ActivationLibrary.rmidRunning(port)) {
+                /**
+                 * We need to set the java.rmi.activation.port value as the
+                 * activation system will use the property to determine the
+                 * port #.  The activation system will use this value if set.
+                 * If it isn't set, the activation system will set it to an
+                 * incorrect value.
+                 */
+                System.setProperty("java.rmi.activation.port", Integer.toString(port));
                 mesg("finished starting rmid.");
                 return;
             }
+            else {
+                mesg("rmid still not started");
+            }
+
         } while (waitTime > 0);
         TestLibrary.bomb("start rmid failed... giving up", null);
     }
@@ -249,10 +267,6 @@
      * Shutdown does not nullify possible references to the rmid
      * process object (destroy does though).
      */
-    public static void shutdown() {
-        shutdown(TestLibrary.RMID_PORT);
-    }
-
     public static void shutdown(int port) {
 
         try {
@@ -264,6 +278,8 @@
                     port +
                     "/java.rmi.activation.ActivationSystem");
                 mesg("obtained a reference to the activation system");
+            } catch (RemoteException re) {
+                mesg("could not contact registry while trying to shutdown activation system");
             } catch (java.net.MalformedURLException mue) {
             }
 
@@ -272,19 +288,14 @@
             }
             system.shutdown();
 
+        } catch (RemoteException re) {
+            mesg("shutting down the activation daemon failed");
         } catch (Exception e) {
             mesg("caught exception trying to shutdown rmid");
             mesg(e.getMessage());
             e.printStackTrace();
         }
 
-        try {
-            // wait for the shutdown to happen
-            Thread.sleep(5000);
-        } catch (InterruptedException ie) {
-            Thread.currentThread().interrupt();
-        }
-
         mesg("testlibrary finished shutting down rmid");
     }
 
@@ -294,25 +305,52 @@
      * if rmid is a child process of the current VM.
      */
     public void destroy() {
-
-        // attempt graceful shutdown of the activation system on
-        // TestLibrary.RMID_PORT
+        // attempt graceful shutdown of the activation system
         shutdown(port);
 
         if (vm != null) {
             try {
-                // destroy rmid if it is still running...
-                try {
-                    vm.exitValue();
-                    mesg("rmid exited on shutdown request");
-                } catch (IllegalThreadStateException illegal) {
-                    mesg("Had to destroy RMID's process " +
-                         "using Process.destroy()");
+                /* Waiting for distant RMID process to shutdown.
+                 * Waiting is bounded at a hardcoded max of 60 secs (1 min).
+                 * Waiting by steps of 200 msecs, thus at most 300 such attempts
+                 * for termination of distant RMID process. If process is not
+                 * known to be terminated properly after that time,
+                 * we give up for a gracefull termination, and thus go for
+                 * forcibly destroying the process.
+                 */
+                boolean vmEnded = false;
+                int waitingTrials = 0;
+                final int maxTrials = 300;
+                final long vmProcessEndWaitInterval = 200;
+                int vmExitValue;
+                do {
+                    try {
+                        Thread.sleep(vmProcessEndWaitInterval);
+                        waitingTrials++;
+                        vmExitValue = vm.exitValue();
+                        mesg("rmid exited on shutdown request");
+                        vmEnded = true;
+                    } catch (IllegalThreadStateException illegal) {
+                        mesg("RMID's process still not terminated after more than " +
+                             (waitingTrials * vmProcessEndWaitInterval) + " milliseconds");
+                    }
+                }
+                while (!vmEnded &&
+                       (waitingTrials < maxTrials));
+
+                if (waitingTrials >= maxTrials) {
+                    mesg("RMID's process still not terminated after more than " +
+                         (waitingTrials * vmProcessEndWaitInterval) + " milliseconds." +
+                         "Givinp up gracefull termination...");
+                    mesg("destroying RMID's process using Process.destroy()");
                     super.destroy();
                 }
 
+            } catch (InterruptedException ie) {
+                Thread.currentThread().interrupt();
+                mesg("Thread interrupted while checking for termination of distant rmid vm. Giving up check.");
             } catch (Exception e) {
-                mesg("caught exception trying to destroy rmid: " +
+                mesg("caught unexpected exception trying to destroy rmid: " +
                      e.getMessage());
                 e.printStackTrace();
             }
@@ -321,4 +359,6 @@
             vm = null;
         }
     }
+
+    public int getPort() {return port;}
 }
--- jdk/test/java/rmi/testlibrary/RegistryRunner.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/testlibrary/RegistryRunner.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,12 +56,13 @@
      * Request that the registry process exit and handle
      * related exceptions.
      */
-    public static void requestExit() {
+    public static void requestExit(int port) {
+
         try {
             RemoteExiter exiter =
                 (RemoteExiter)
                 Naming.lookup("rmi://localhost:" +
-                              TestLibrary.REGISTRY_PORT +
+                              port +
                               "/RemoteExiter");
             try {
                 exiter.exit();
@@ -84,7 +85,7 @@
                 System.err.println("Usage: <port>");
                 System.exit(0);
             }
-            int port = TestLibrary.REGISTRY_PORT;
+            int port = -1;
             try {
                 port = Integer.parseInt(args[0]);
             } catch (NumberFormatException nfe) {
--- jdk/test/java/rmi/testlibrary/StreamPipe.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/testlibrary/StreamPipe.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,10 @@
  * questions.
  */
 
-/**
- *
- */
-
-import java.io.*;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.IOException;
+import java.io.OutputStream;
 
 /**
  * Pipe output of one stream into input of another.
@@ -34,47 +33,51 @@
 
     private InputStream in;
     private OutputStream out;
-    private String preamble;
-    private static Object lock = new Object();
+
+    private static Object countLock = new Object();
     private static int count = 0;
 
-    public StreamPipe(InputStream in, OutputStream out, String name) {
+    /**
+     * StreamPipe constructor : should only be called by plugTogether() method.
+     */
+    private StreamPipe(InputStream in, OutputStream out, String name) {
         super(name);
         this.in  = in;
         this.out = out;
-        this.preamble = "# ";
     }
 
-    public void run() {
-        BufferedReader r = new BufferedReader(new InputStreamReader(in), 1);
-        BufferedWriter w = new BufferedWriter(new OutputStreamWriter(out));
-        byte[] buf = new byte[256];
-        boolean bol = true;     // beginning-of-line
-        int count;
+    /**
+     * Creates a StreamPipe thread that copies in to out and returns
+     * the created instance.
+     */
+    public static StreamPipe plugTogether(InputStream in, OutputStream out) {
+        String name;
+
+        synchronized (countLock) {
+            name = "java.rmi.testlibrary.StreamPipe-" + (count++);
+        }
+
+        StreamPipe pipe = new StreamPipe(in, out, name);
+        pipe.setDaemon(true);
+        pipe.start();
+        return pipe;
+    }
 
+    // Starts redirection of streams.
+    public void run() {
         try {
-            String line;
-            while ((line = r.readLine()) != null) {
-                w.write(preamble);
-                w.write(line);
-                w.newLine();
-                w.flush();
+            byte[] buf = new byte[1024];
+
+            while (true) {
+                int nr = in.read(buf);
+                if (nr == -1)
+                    break;
+                out.write(buf, 0, nr);
             }
+
         } catch (IOException e) {
             System.err.println("*** IOException in StreamPipe.run:");
             e.printStackTrace();
         }
     }
-
-    public static void plugTogether(InputStream in, OutputStream out) {
-        String name = null;
-
-        synchronized (lock) {
-            name = "TestLibrary: StreamPipe-" + (count ++ );
-        }
-
-        Thread pipe = new StreamPipe(in, out, name);
-        pipe.setDaemon(true);
-        pipe.start();
-    }
 }
--- jdk/test/java/rmi/testlibrary/TestLibrary.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/testlibrary/TestLibrary.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,37 +36,64 @@
  * not make use of packages.
  */
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.PrintStream;
-import java.net.URL;
 import java.net.MalformedURLException;
-import java.rmi.activation.Activatable;
-import java.rmi.activation.ActivationID;
+import java.net.ServerSocket;
+import java.net.URL;
 import java.rmi.NoSuchObjectException;
-import java.rmi.registry.Registry;
 import java.rmi.Remote;
+import java.rmi.RemoteException;
+import java.rmi.registry.LocateRegistry;
+import java.rmi.registry.Registry;
+import java.rmi.server.RemoteRef;
 import java.rmi.server.UnicastRemoteObject;
 import java.util.Enumeration;
-import java.util.Hashtable;
 import java.util.Properties;
-import java.io.ByteArrayOutputStream;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
+
+import sun.rmi.registry.RegistryImpl;
+import sun.rmi.server.UnicastServerRef;
+import sun.rmi.transport.Endpoint;
+import sun.rmi.transport.LiveRef;
+import sun.rmi.transport.tcp.TCPEndpoint;
 
 /**
  * Class of utility/library methods (i.e. procedures) that assist with
  * the writing and maintainance of rmi regression tests.
  */
 public class TestLibrary {
-
-    /** standard test port number for registry */
-    public final static int REGISTRY_PORT = 2006;
-    /** port for rmid necessary: not used to actually start rmid */
-    public final static int RMID_PORT = 1098;
+    /**
+     *                       IMPORTANT!
+     *
+     * RMI tests are run concurrently and port conflicts result when a single
+     * port number is used by multiple tests.  When needing a port, use
+     * getUnusedRandomPort() wherever possible.  If getUnusedRandomPort() cannot
+     * be used, reserve and specify a port to use for your test here.   This
+     * will ensure there are no port conflicts amongst the RMI tests.  The
+     * port numbers specified here may also be specified in the respective
+     * tests.  Do not change the reserved port numbers here without also
+     * changing the port numbers in the respective tests.
+     *
+     * When needing an instance of the RMIRegistry, use
+     * createRegistryOnUnusedPort wherever possible to prevent port conflicts.
+     *
+     * Reserved port range: FIXED_PORT_MIN to FIXED_PORT_MAX (inclusive) for
+     * tests which cannot use a random port.  If new fixed ports are added below
+     * FIXED_PORT_MIN or above FIXED_PORT_MAX, then adjust
+     * FIXED_PORT_MIN/MAX appropriately.
+     */
+    public final static int FIXED_PORT_MIN = 64001;
+    public final static int FIXED_PORT_MAX = 64010;
+    public final static int RMIDVIAINHERITEDCHANNEL_ACTIVATION_PORT = 64001;
+    public final static int RMIDVIAINHERITEDCHANNEL_REGISTRY_PORT = 64002;
+    public final static int INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT = 64003;
+    public final static int INHERITEDCHANNELNOTSERVERSOCKET_REGISTRY_PORT = 64004;
+    public final static int READTEST_REGISTRY_PORT = 64005;
+    private final static int MAX_SERVER_SOCKET_TRIES = 2*(FIXED_PORT_MAX-FIXED_PORT_MIN+1);
 
     static void mesg(Object mesg) {
         System.err.println("TEST_LIBRARY: " + mesg.toString());
@@ -100,36 +127,15 @@
         bomb(null, e);
     }
 
-    /**
-     * Property accessors
-     */
-    private static boolean getBoolean(String name) {
-        return (new Boolean(getProperty(name, "false")).booleanValue());
-    }
-    private static Integer getInteger(String name) {
-        int val = 0;
-        Integer value = null;
-
-        String propVal = getProperty(name, null);
-        if (propVal == null) {
-            return null;
-        }
-
-        try {
-            value = new Integer(Integer.parseInt(propVal));
-        } catch (NumberFormatException nfe) {
-        }
-        return value;
-    }
     public static String getProperty(String property, String defaultVal) {
         final String prop = property;
         final String def = defaultVal;
-        return ((String) java.security.AccessController.doPrivileged
-            (new java.security.PrivilegedAction() {
-                public Object run() {
+        return java.security.AccessController.doPrivileged(
+            new java.security.PrivilegedAction<String>() {
+                public String run() {
                     return System.getProperty(prop, def);
                 }
-            }));
+            });
     }
 
     /**
@@ -144,9 +150,9 @@
     public static void setProperty(String property, String value) {
         final String prop = property;
         final String val = value;
-        java.security.AccessController.doPrivileged
-            (new java.security.PrivilegedAction() {
-                public Object run() {
+        java.security.AccessController.doPrivileged(
+            new java.security.PrivilegedAction<Void>() {
+                public Void run() {
                     System.setProperty(prop, val);
                     return null;
                 }
@@ -163,7 +169,7 @@
         out.println("-------------------Test environment----------" +
                     "---------");
 
-        for(Enumeration keys = System.getProperties().keys();
+        for(Enumeration<?> keys = System.getProperties().keys();
             keys.hasMoreElements();) {
 
             String property = (String) keys.nextElement();
@@ -227,7 +233,7 @@
         /*
          * Obtain the URL for the codebase.
          */
-        URL codebaseURL = dstDir.toURL();
+        URL codebaseURL = dstDir.toURI().toURL();
 
         /*
          * Specify where we will copy the class definition from, if
@@ -340,6 +346,103 @@
     }
 
     /**
+     * Creates an RMI {@link Registry} on a random, un-reserved port.
+     *
+     * @returns an RMI Registry, using a random port.
+     * @throws RemoteException if there was a problem creating a Registry.
+     */
+    public static Registry createRegistryOnUnusedPort() throws RemoteException {
+        return LocateRegistry.createRegistry(getUnusedRandomPort());
+    }
+
+    /**
+     * Returns the port number the RMI {@link Registry} is running on.
+     *
+     * @param registry the registry to find the port of.
+     * @return the port number the registry is using.
+     * @throws RuntimeException if there was a problem getting the port number.
+     */
+    public static int getRegistryPort(Registry registry) {
+        int port = -1;
+
+        try {
+            RemoteRef remoteRef = ((RegistryImpl)registry).getRef();
+            LiveRef liveRef = ((UnicastServerRef)remoteRef).getLiveRef();
+            Endpoint endpoint = liveRef.getChannel().getEndpoint();
+            TCPEndpoint tcpEndpoint = (TCPEndpoint) endpoint;
+            port = tcpEndpoint.getPort();
+        } catch (Exception ex) {
+            throw new RuntimeException("Error getting registry port.", ex);
+        }
+
+        return port;
+    }
+
+    /**
+     * Returns an unused random port number which is not a reserved port.  Will
+     * try up to 10 times to get a random port before giving up and throwing a
+     * RuntimeException.
+     *
+     * @return an unused random port number.
+     * @throws RuntimeException if there was a problem getting a port.
+     */
+    public static int getUnusedRandomPort() {
+        int numTries = 0;
+        IOException ex = null;
+
+        while (numTries++ < MAX_SERVER_SOCKET_TRIES) {
+            int unusedRandomPort = -1;
+            ex = null; //reset
+
+            try (ServerSocket ss = new ServerSocket(0)) {
+                unusedRandomPort = ss.getLocalPort();
+            } catch (IOException e) {
+                ex = e;
+                // temporarily print stack trace here until we find out why
+                // tests are failing.
+                System.err.println("TestLibrary.getUnusedRandomPort() caught "
+                        + "exception on iteration " + numTries
+                        + (numTries==MAX_SERVER_SOCKET_TRIES ? " (the final try)."
+                        : "."));
+                ex.printStackTrace();
+            }
+
+            if (unusedRandomPort >= 0) {
+                if (isReservedPort(unusedRandomPort)) {
+                    System.out.println("INFO: On try # " + numTries
+                        + (numTries==MAX_SERVER_SOCKET_TRIES ? ", the final try, ": ",")
+                        + " ServerSocket(0) returned the reserved port "
+                        + unusedRandomPort
+                        + " in TestLibrary.getUnusedRandomPort() ");
+                } else {
+                    return unusedRandomPort;
+                }
+            }
+        }
+
+        // If we're here, then either an exception was thrown or the port is
+        // a reserved port.
+        if (ex==null) {
+            throw new RuntimeException("Error getting unused random port. The"
+                    +" last port returned by ServerSocket(0) was a reserved port");
+        } else {
+            throw new RuntimeException("Error getting unused random port.", ex);
+        }
+    }
+
+    /**
+     * Determines if a port is one of the reserved port numbers.
+     *
+     * @param port the port to test.
+     * @return {@code true} if the port is a reserved port, otherwise
+     *         {@code false}.
+     */
+    public static boolean isReservedPort(int port) {
+        return ((port >= FIXED_PORT_MIN) && (port <= FIXED_PORT_MAX) ||
+                (port == 1099));
+    }
+
+    /**
      * Method to capture the stack trace of an exception and return it
      * as a string.
      */
--- jdk/test/java/rmi/transport/acceptLoop/CloseServerSocketOnTermination.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/transport/acceptLoop/CloseServerSocketOnTermination.java	2013-05-05 09:38:44.000000000 -0700
@@ -31,7 +31,6 @@
  * exception for which it doesn't even consult the RMIFailureHandler.
  * @author Peter Jones
  *
- * @build CloseServerSocketOnTermination
  * @run main/othervm CloseServerSocketOnTermination
  */
 
--- jdk/test/java/rmi/transport/checkFQDN/CheckFQDN.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/transport/checkFQDN/CheckFQDN.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build CheckFQDN CheckFQDNClient CheckFQDN_Stub TellServerName
+ * @build TestLibrary CheckFQDNClient CheckFQDN_Stub TellServerName
  * @run main/othervm/timeout=120 CheckFQDN
  */
 
@@ -63,7 +63,7 @@
  */
 public class CheckFQDN extends UnicastRemoteObject
     implements TellServerName {
-
+    public static int REGISTRY_PORT =-1;
     static String propertyBeingTested = null;
     static String propertyBeingTestedValue = null;
 
@@ -77,8 +77,8 @@
             System.err.println
                 ("\nRegression test for bug/rfe 4115683\n");
 
-            Registry registry = java.rmi.registry.LocateRegistry.
-                createRegistry(TestLibrary.REGISTRY_PORT);
+            Registry registry = TestLibrary.createRegistryOnUnusedPort();
+            REGISTRY_PORT = TestLibrary.getRegistryPort(registry);
             registry.bind("CheckFQDN", checkFQDN);
 
             /* test the host name scheme in different environments.*/
@@ -114,19 +114,19 @@
                 equal = "=";
             }
 
+            // create a client to tell checkFQDN what its rmi name is.
             JavaVM jvm = new JavaVM("CheckFQDNClient",
                                     propOption + property +
                                     equal +
-                                    propertyValue + extraProp,
+                                    propertyValue + extraProp +
+                                    " -Drmi.registry.port=" +
+                                    REGISTRY_PORT,
                                     "");
 
             propertyBeingTested=property;
             propertyBeingTestedValue=propertyValue;
 
-            // create a client to tell checkFQDN what its rmi name is. */
-            jvm.start();
-
-            if (jvm.getVM().waitFor() != 0 ) {
+            if (jvm.execute() != 0) {
                 TestLibrary.bomb("Test failed, error in client.");
             }
 
--- jdk/test/java/rmi/transport/checkFQDN/CheckFQDNClient.java	2012-08-10 10:34:46.000000000 -0700
+++ jdk/test/java/rmi/transport/checkFQDN/CheckFQDNClient.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -58,8 +58,9 @@
             System.err.println("Client host name: " +
                                hostname);
 
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
             tell = (TellServerName) Naming.lookup("rmi://:" +
-                                                  TestLibrary.REGISTRY_PORT
+                                                  registryPort
                                                   + "/CheckFQDN");
             tell.tellServerName(hostname);
             System.err.println("client has exited");
--- jdk/test/java/rmi/transport/checkLeaseInfoLeak/CheckLeaseLeak.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/checkLeaseInfoLeak/CheckLeaseLeak.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build CheckLeaseLeak CheckLeaseLeak_Stub LeaseLeakClient LeaseLeak
+ * @build TestLibrary CheckLeaseLeak_Stub LeaseLeakClient LeaseLeak
  * @run main/othervm/timeout=240 CheckLeaseLeak
  *
  */
@@ -57,7 +57,6 @@
 import java.rmi.registry.*;
 
 public class CheckLeaseLeak extends UnicastRemoteObject implements LeaseLeak {
-
     public CheckLeaseLeak() throws RemoteException { }
     public void ping () throws RemoteException { }
 
@@ -87,8 +86,8 @@
 
         try {
             Registry registry =
-                java.rmi.registry.LocateRegistry.
-                    createRegistry(TestLibrary.REGISTRY_PORT);
+                TestLibrary.createRegistryOnUnusedPort();
+            int registryPort = TestLibrary.getRegistryPort(registry);
 
             leakServer = new CheckLeaseLeak();
             registry.rebind("/LeaseLeak", leakServer);
@@ -99,10 +98,12 @@
 
                 JavaVM jvm = new JavaVM("LeaseLeakClient",
                                         " -Djava.security.policy=" +
-                                        TestParams.defaultPolicy, "");
-                jvm.start();
+                                        TestParams.defaultPolicy +
+                                        " -Drmi.registry.port=" +
+                                        registryPort,
+                                        "");
 
-                if (jvm.getVM().waitFor() == 1 ) {
+                if (jvm.execute() != 0) {
                     TestLibrary.bomb("Client process failed");
                 }
             }
--- jdk/test/java/rmi/transport/checkLeaseInfoLeak/LeaseLeakClient.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/checkLeaseInfoLeak/LeaseLeakClient.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,11 +31,11 @@
 
         try {
             LeaseLeak leaseLeak = null;
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
 
             // put a reference on a remote object.
             Registry registry =
-                java.rmi.registry.LocateRegistry.getRegistry(
-                    TestLibrary.REGISTRY_PORT);
+                java.rmi.registry.LocateRegistry.getRegistry(registryPort);
             leaseLeak = (LeaseLeak) registry.lookup("/LeaseLeak");
             leaseLeak.ping();
 
--- jdk/test/java/rmi/transport/checkLeaseInfoLeak/security.policy	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/checkLeaseInfoLeak/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -19,6 +19,7 @@
   permission java.util.PropertyPermission "user.dir", "read";
   permission java.util.PropertyPermission "java.home", "read";
 
+  permission java.util.PropertyPermission "rmi.registry.port", "read";
   permission java.util.PropertyPermission "java.security.policy", "read";
   permission java.util.PropertyPermission "java.security.manager", "read";
 
--- jdk/test/java/rmi/transport/closeServerSocket/CloseServerSocket.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/closeServerSocket/CloseServerSocket.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,7 +30,8 @@
  * the local port is released).
  * @author Peter Jones
  *
- * @build CloseServerSocket
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm CloseServerSocket
  */
 
@@ -44,8 +45,7 @@
 import java.rmi.server.UnicastRemoteObject;
 
 public class CloseServerSocket implements Remote {
-
-    private static final int PORT = 2020;
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
 
     private CloseServerSocket() { }
 
@@ -88,7 +88,7 @@
     }
 
     private static void verifyPortFree(int port) throws IOException {
-        ServerSocket ss = new ServerSocket(PORT);
+        ServerSocket ss = new ServerSocket(port);
         ss.close();
         System.err.println("- port " + port + " is free");
     }
--- jdk/test/java/rmi/transport/dgcDeadLock/DGCDeadLock.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/dgcDeadLock/DGCDeadLock.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,10 +28,7 @@
  * @author Laird Dornin
  *
  * @library ../../testlibrary
- * @build DGCDeadLock
- * @build Test
- * @build TestImpl
- * @build TestImpl_Stub
+ * @build TestLibrary Test TestImpl TestImpl_Stub
  * @run main/othervm/policy=security.policy/timeout=360 DGCDeadLock
  */
 
@@ -53,7 +50,7 @@
 import java.io.*;
 
 public class DGCDeadLock implements Runnable {
-
+    private static final int REGISTRY_PORT = TestLibrary.getUnusedRandomPort();
     final static public int HOLD_TARGET_TIME = 25000;
     public static int TEST_FAIL_TIME = HOLD_TARGET_TIME + 30000;
     public static boolean finished = false;
@@ -75,7 +72,9 @@
                 TestParams.defaultPolicy +
                 " -Djava.rmi.dgc.leaseValue=500000" +
                 "  -Dsun.rmi.dgc.checkInterval=" +
-                (HOLD_TARGET_TIME - 5000) + "";
+                (HOLD_TARGET_TIME - 5000) +
+                "   -Drmi.registry.port=" + REGISTRY_PORT +
+                "" ;
 
             testImplVM = new JavaVM("TestImpl", options, "");
             testImplVM.start();
@@ -112,7 +111,7 @@
 
             // create a test client
             Test foo = (Test) Naming.lookup("rmi://:" +
-                                            TestLibrary.REGISTRY_PORT +
+                                            REGISTRY_PORT +
                                             "/Foo");
             echo = foo.echo("Hello world");
             System.err.println("Test object created.");
@@ -131,7 +130,7 @@
 
             //import "Bar"
             Test bar = (Test) Naming.lookup("rmi://:" +
-                                            TestLibrary.REGISTRY_PORT +
+                                            REGISTRY_PORT +
                                             "/Bar");
 
             /* infinite loop to show the liveness of Client,
--- jdk/test/java/rmi/transport/dgcDeadLock/TestImpl.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/dgcDeadLock/TestImpl.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,7 +36,6 @@
 
 public class TestImpl extends UnicastRemoteObject
     implements Test {
-
     static Thread locker = null;
     static TestImpl foo = null;
     static TestImpl bar = null;
@@ -57,20 +56,21 @@
         Registry registry = null;
 
         try {
+            int registryPort = Integer.parseInt(System.getProperty("rmi.registry.port"));
             registry = java.rmi.registry.LocateRegistry.
-                createRegistry(TestLibrary.REGISTRY_PORT);
+                createRegistry(registryPort);
 
             //export "Foo"
             foo = new TestImpl();
             Naming.rebind("rmi://:" +
-                          TestLibrary.REGISTRY_PORT
+                          registryPort
                           + "/Foo", foo);
 
             try {
                 //export "Bar" after leases have been expired.
                 bar = new TestImpl();
                 Naming.rebind("rmi://localhost:" +
-                              TestLibrary.REGISTRY_PORT
+                              registryPort
                               + "/Bar", bar);
             } catch (Exception e) {
                 throw new RemoteException(e.getMessage());
--- jdk/test/java/rmi/transport/handshakeFailure/HandshakeFailure.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/handshakeFailure/HandshakeFailure.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,7 +30,8 @@
  * java.rmi.ConnectException or ConnectIOException, not a MarshalException.
  * @author Peter Jones
  *
- * @build HandshakeFailure
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm HandshakeFailure
  */
 
@@ -44,7 +45,7 @@
 
 public class HandshakeFailure {
 
-    private static final int PORT = 2020;
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
     private static final int TIMEOUT = 10000;
 
     public static void main(String[] args) throws Exception {
--- jdk/test/java/rmi/transport/handshakeTimeout/HandshakeTimeout.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/handshakeTimeout/HandshakeTimeout.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,8 @@
  * this point (because no data for the invocation has yet been written).
  * @author Peter Jones
  *
- * @build HandshakeTimeout
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm HandshakeTimeout
  */
 
@@ -46,7 +47,7 @@
 
 public class HandshakeTimeout {
 
-    private static final int PORT = 2020;
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
     private static final int TIMEOUT = 10000;
 
     public static void main(String[] args) throws Exception {
--- jdk/test/java/rmi/transport/httpSocket/HttpSocketTest.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/httpSocket/HttpSocketTest.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,7 +27,7 @@
  * @author Dana Burns
  *
  * @library ../../testlibrary
- * @build HttpSocketTest HttpSocketTest_Stub
+ * @build TestLibrary HttpSocketTest HttpSocketTest_Stub
  * @run main/othervm/policy=security.policy HttpSocketTest
  */
 
@@ -56,10 +56,7 @@
 public class HttpSocketTest extends UnicastRemoteObject
     implements MyRemoteInterface
 {
-
     private static final String NAME = "HttpSocketTest";
-    private static final String REGNAME =
-        "//:" + TestLibrary.REGISTRY_PORT + "/" + NAME;
 
     public HttpSocketTest() throws RemoteException{}
 
@@ -76,21 +73,20 @@
         // Set the socket factory.
         System.err.println("installing socket factory");
         RMISocketFactory.setSocketFactory(new RMIHttpToPortSocketFactory());
+        int registryPort = -1;
 
         try {
-
             System.err.println("Starting registry");
-            registry = LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
-
+            registry = TestLibrary.createRegistryOnUnusedPort();
+            registryPort = TestLibrary.getRegistryPort(registry);
         } catch (Exception e) {
             TestLibrary.bomb(e);
         }
 
         try {
-
             registry.rebind( NAME, new HttpSocketTest() );
             MyRemoteInterface httpTest =
-                (MyRemoteInterface)Naming.lookup( REGNAME );
+                (MyRemoteInterface)Naming.lookup("//:" + registryPort + "/" + NAME);
             httpTest.setRemoteObject( new HttpSocketTest() );
             Remote r = httpTest.getRemoteObject();
 
--- jdk/test/java/rmi/transport/httpSocket/security.policy	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/httpSocket/security.policy	2013-05-05 09:38:44.000000000 -0700
@@ -4,6 +4,10 @@
 
 grant {
     permission java.net.SocketPermission "*:1024-", "accept,connect,listen";
+    permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.registry";
+    permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.server";
+    permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport";
     permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.proxy";
+    permission java.lang.RuntimePermission "accessClassInPackage.sun.rmi.transport.tcp";
     permission java.lang.RuntimePermission "setFactory";
 };
--- jdk/test/java/rmi/transport/pinClientSocketFactory/PinClientSocketFactory.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/pinClientSocketFactory/PinClientSocketFactory.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,6 +31,8 @@
  * should become unreachable too (through the RMI implementation).
  * @author Peter Jones
  *
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm -Dsun.rmi.transport.connectionTimeout=2000
  *     PinClientSocketFactory
  */
@@ -56,7 +58,7 @@
 
 public class PinClientSocketFactory {
 
-    private static final int PORT = 2345;
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
     private static final int SESSIONS = 50;
 
     public interface Factory extends Remote {
--- jdk/test/java/rmi/transport/pinLastArguments/PinLastArguments.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/pinLastArguments/PinLastArguments.java	2013-05-05 09:38:44.000000000 -0700
@@ -78,10 +78,15 @@
         }
         impl = null;
 
-        System.gc();
-
-        if (ref.get() != null) {
-            throw new Error("TEST FAILED: impl not garbage collected");
+        // Might require multiple calls to System.gc() for weak-references
+        // processing to be complete. If the weak-reference is not cleared as
+        // expected we will hang here until timed out by the test harness.
+        while (true) {
+            System.gc();
+            Thread.sleep(20);
+            if (ref.get() == null) {
+                break;
+            }
         }
 
         System.err.println("TEST PASSED");
--- jdk/test/java/rmi/transport/rapidExportUnexport/RapidExportUnexport.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/rapidExportUnexport/RapidExportUnexport.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,8 @@
  * procedure (which sleeps 10 seconds after 10 rapid failures).
  * @author Peter Jones
  *
- * @build RapidExportUnexport
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm RapidExportUnexport
  */
 
@@ -39,9 +40,7 @@
 import java.rmi.server.UnicastRemoteObject;
 
 public class RapidExportUnexport {
-
-    private static final int PORT = 2055;
-
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
     private static final int REPS = 100;
     private static final long TIMEOUT = 60000;
 
--- jdk/test/java/rmi/transport/readTimeout/ReadTimeoutTest.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/readTimeout/ReadTimeoutTest.java	2013-05-05 09:38:44.000000000 -0700
@@ -27,12 +27,9 @@
  * @summary Incoming connections should be subject to timeout
  * @author Adrian Colley
  *
- * @library ../../testlibrary
- * @build TestIface
- * @build TestImpl
- * @build TestImpl_Stub
- * @build ReadTimeoutTest
- * @run main/othervm/policy=security.policy/timeout=60 -Dsun.rmi.transport.tcp.readTimeout=5000 ReadTimeoutTest
+ * @build TestIface TestImpl TestImpl_Stub
+ * @run main/othervm/policy=security.policy/timeout=60
+ *     -Dsun.rmi.transport.tcp.readTimeout=5000 ReadTimeoutTest
  */
 
 /* This test sets a very short read timeout, exports an object, and then
--- jdk/test/java/rmi/transport/reuseDefaultPort/ReuseDefaultPort.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/reuseDefaultPort/ReuseDefaultPort.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,8 @@
  * continue to work because existing applications might depend on it.
  * @author Peter Jones
  *
- * @build ReuseDefaultPort
+ * @library ../../testlibrary
+ * @build TestLibrary
  * @run main/othervm ReuseDefaultPort
  */
 
@@ -48,7 +49,7 @@
 
 public class ReuseDefaultPort implements Remote {
 
-    private static final int PORT = 2223;
+    private static final int PORT = TestLibrary.getUnusedRandomPort();
 
     private ReuseDefaultPort() { }
 
--- jdk/test/java/rmi/transport/runtimeThreadInheritanceLeak/RuntimeThreadInheritanceLeak.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/rmi/transport/runtimeThreadInheritanceLeak/RuntimeThreadInheritanceLeak.java	2013-05-05 09:38:44.000000000 -0700
@@ -38,7 +38,6 @@
  * subsystems also not holding on to the loader in their daemon threads.]
  * @author Peter Jones
  *
- * @build RuntimeThreadInheritanceLeak
  * @build RuntimeThreadInheritanceLeak_Stub
  * @run main/othervm RuntimeThreadInheritanceLeak
  */
--- jdk/test/java/security/BasicPermission/PermClass.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/security/BasicPermission/PermClass.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 4511601
+ * @bug 4511601 7054918
  * @summary BasicPermissionCollection does not set permClass
  *              during deserialization
  */
@@ -55,59 +55,66 @@
 
         // read in a 1.2.1 BasicPermissionCollection
         File sFile = new File(dir, "PermClass.1.2.1");
-        ObjectInputStream ois = new ObjectInputStream
-                (new FileInputStream(sFile));
-        PermissionCollection pc = (PermissionCollection)ois.readObject();
-        System.out.println("1.2.1 collection = " + pc);
-
-        if (pc.implies(mp)) {
-            System.out.println("JDK 1.2.1 test passed");
-        } else {
-            throw new Exception("JDK 1.2.1 test failed");
+        try (FileInputStream fis = new FileInputStream(sFile);
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection) ois.readObject();
+            System.out.println("1.2.1 collection = " + pc);
+
+            if (pc.implies(mp)) {
+                System.out.println("JDK 1.2.1 test passed");
+            } else {
+                throw new Exception("JDK 1.2.1 test failed");
+            }
         }
 
         // read in a 1.3.1 BasicPermissionCollection
         sFile = new File(dir, "PermClass.1.3.1");
-        ois = new ObjectInputStream(new FileInputStream(sFile));
-        pc = (PermissionCollection)ois.readObject();
-        System.out.println("1.3.1 collection = " + pc);
-
-        if (pc.implies(mp)) {
-            System.out.println("JDK 1.3.1 test passed");
-        } else {
-            throw new Exception("JDK 1.3.1 test failed");
+        try (FileInputStream fis = new FileInputStream(sFile);
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("1.3.1 collection = " + pc);
+
+            if (pc.implies(mp)) {
+                System.out.println("JDK 1.3.1 test passed");
+            } else {
+                throw new Exception("JDK 1.3.1 test failed");
+            }
         }
 
         // read in a 1.4 BasicPermissionCollection
         sFile = new File(dir, "PermClass.1.4");
-        ois = new ObjectInputStream(new FileInputStream(sFile));
-        pc = (PermissionCollection)ois.readObject();
-        System.out.println("1.4 collection = " + pc);
-
-        if (pc.implies(mp)) {
-            System.out.println("JDK 1.4 test 1 passed");
-        } else {
-            throw new Exception("JDK 1.4 test 1 failed");
+        try (FileInputStream fis = new FileInputStream(sFile);
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("1.4 collection = " + pc);
+
+            if (pc.implies(mp)) {
+                System.out.println("JDK 1.4 test 1 passed");
+            } else {
+                throw new Exception("JDK 1.4 test 1 failed");
+            }
         }
 
         // write out current BasicPermissionCollection
         PermissionCollection bpc = mp.newPermissionCollection();
         bpc.add(mp);
         sFile = new File(dir, "PermClass.current");
-        ObjectOutputStream oos = new ObjectOutputStream
-                (new FileOutputStream("PermClass.current"));
-        oos.writeObject(bpc);
-        oos.close();
+        try (FileOutputStream fos = new FileOutputStream("PermClass.current");
+                ObjectOutputStream oos = new ObjectOutputStream(fos)) {
+            oos.writeObject(bpc);
+        }
 
         // read in current BasicPermissionCollection
-        ois = new ObjectInputStream(new FileInputStream("PermClass.current"));
-        pc = (PermissionCollection)ois.readObject();
-        System.out.println("current collection = " + pc);
-
-        if (pc.implies(mp)) {
-            System.out.println("JDK 1.4 test 2 passed");
-        } else {
-            throw new Exception("JDK 1.4 test 2 failed");
+        try (FileInputStream fis = new FileInputStream("PermClass.current");
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("current collection = " + pc);
+
+            if (pc.implies(mp)) {
+                System.out.println("JDK 1.4 test 2 passed");
+            } else {
+                throw new Exception("JDK 1.4 test 2 failed");
+            }
         }
     }
 }
--- jdk/test/java/security/BasicPermission/SerialVersion.java	2012-08-10 10:34:47.000000000 -0700
+++ jdk/test/java/security/BasicPermission/SerialVersion.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 4502729
+ * @bug 4502729 7054918
  * @summary BasicPermissionCollection serial version UID incorrect
  */
 
@@ -36,40 +36,44 @@
         String dir = System.getProperty("test.src");
         File  sFile =  new File (dir,"SerialVersion.1.2.1");
         // read in a 1.2.1 BasicPermissionCollection
-        ObjectInputStream ois = new ObjectInputStream
-                (new FileInputStream(sFile));
-        PermissionCollection pc = (PermissionCollection)ois.readObject();
-        System.out.println("1.2.1 collection = " + pc);
+        try (FileInputStream fis = new FileInputStream(sFile);
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("1.2.1 collection = " + pc);
+        }
 
         // read in a 1.3.1 BasicPermissionCollection
         sFile =  new File (dir,"SerialVersion.1.3.1");
 
-        ois = new ObjectInputStream
-                (new FileInputStream(sFile));
-        pc = (PermissionCollection)ois.readObject();
-        System.out.println("1.3.1 collection = " + pc);
+        try (FileInputStream fis = new FileInputStream(sFile);
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("1.3.1 collection = " + pc);
+        }
 
         // read in a 1.4 BasicPermissionCollection
         sFile =  new File (dir,"SerialVersion.1.4");
-        ois = new ObjectInputStream
-                (new FileInputStream(sFile));
-        pc = (PermissionCollection)ois.readObject();
-        System.out.println("1.4 collection = " + pc);
+        try (FileInputStream fis = new FileInputStream(sFile);
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("1.4 collection = " + pc);
+        }
 
         // write out current BasicPermissionCollection
         MyPermission mp = new MyPermission("SerialVersionTest");
         PermissionCollection bpc = mp.newPermissionCollection();
         sFile =  new File (dir,"SerialVersion.current");
-        ObjectOutputStream oos = new ObjectOutputStream
-                (new FileOutputStream("SerialVersion.current"));
-        oos.writeObject(bpc);
-        oos.close();
+        try (FileOutputStream fos = new FileOutputStream("SerialVersion.current");
+                ObjectOutputStream oos = new ObjectOutputStream(fos)) {
+            oos.writeObject(bpc);
+        }
 
         // read in current BasicPermissionCollection
-        ois = new ObjectInputStream
-                (new FileInputStream("SerialVersion.current"));
-        pc = (PermissionCollection)ois.readObject();
-        System.out.println("current collection = " + pc);
+        try (FileInputStream fis = new FileInputStream("SerialVersion.current");
+                ObjectInputStream ois = new ObjectInputStream(fis)) {
+            PermissionCollection pc = (PermissionCollection)ois.readObject();
+            System.out.println("current collection = " + pc);
+        }
     }
 }
 
--- jdk/test/java/security/KeyFactory/Failover.java	2012-08-10 10:34:48.000000000 -0700
+++ jdk/test/java/security/KeyFactory/Failover.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /**
  * @test
- * @bug 4894125
+ * @bug 4894125 7054918
+ * @library ../testlibrary
  * @summary test that failover for KeyFactory works
  * @author Andreas Sterbenz
  */
@@ -37,6 +38,15 @@
 public class Failover {
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         Security.insertProviderAt(new ProviderFail(), 1);
         Security.addProvider(new ProviderPass());
         System.out.println(Arrays.asList(Security.getProviders()));
--- jdk/test/java/security/KeyPairGenerator/Failover.java	2012-08-10 10:34:48.000000000 -0700
+++ jdk/test/java/security/KeyPairGenerator/Failover.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /**
  * @test
- * @bug 4894125
+ * @bug 4894125 7054918
+ * @library ../testlibrary
  * @summary test that failover for KeyPairGenerator works
  * @author Andreas Sterbenz
  */
@@ -37,6 +38,15 @@
 public class Failover {
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         Security.insertProviderAt(new ProviderFail(), 1);
         Security.addProvider(new ProviderPass());
         System.out.println(Arrays.asList(Security.getProviders()));
--- jdk/test/java/security/Provider/ChangeProviders.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Provider/ChangeProviders.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /*
  * @test
- * @bug 4856968
+ * @bug 4856968 7054918
+ * @library ../testlibrary
  * @summary make sure add/insert/removeProvider() work correctly
  * @author Andreas Sterbenz
  */
@@ -43,6 +44,15 @@
     }
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         long start = System.currentTimeMillis();
         Provider p = new ChangeProviders();
 
--- jdk/test/java/security/Provider/GetInstance.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Provider/GetInstance.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /*
  * @test
- * @bug 4856968
+ * @bug 4856968 7054918
+ * @library ../testlibrary
  * @summary make sure getInstance() works correctly, including failover
  *   and delayed provider selection for Signatures
  * @author Andreas Sterbenz
@@ -43,6 +44,15 @@
     }
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         long start = System.currentTimeMillis();
 
         Provider foo = new FooProvider();
--- jdk/test/java/security/Provider/RemoveProvider.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Provider/RemoveProvider.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /*
  * @test
- * @bug 4190873
+ * @bug 4190873 7054918
+ * @library ../testlibrary
  * @summary Make sure provider instance can be removed from list of registered
  * providers, and "entrySet", "keySet", and "values" methods don't loop
  * indefinitely.
@@ -34,6 +35,15 @@
 public class RemoveProvider {
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
 
         // Add provider 1
         Provider p1 = new MyProvider("name1",1,"");
--- jdk/test/java/security/Provider/Turkish.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Provider/Turkish.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,9 +23,8 @@
 
 /**
  * @test
- * @bug 6220064
+ * @bug 6220064 7054918
  * @summary make sure everything works ok in the Turkish local (dotted/dotless i problem)
- * @run main/othervm Turkish
  * @author Andreas Sterbenz
  */
 
@@ -41,54 +40,59 @@
         Provider p1 = new TProvider("T1");
         System.out.println(p1.getServices()); // trigger service parsing
 
-        Locale.setDefault(new Locale("tr", "TR"));
-
-        Provider p2 = new TProvider("T2");
-        System.out.println(p2.getServices()); // trigger service parsing
-
-        System.out.println(Signature.getInstance("MD5withRSA"));
-        System.out.println(Signature.getInstance("md5withrsa"));
-        System.out.println(Signature.getInstance("MD5WITHRSA"));
-        Service s1, s2;
-        s1 = p1.getService("Signature", "MD5withRSA");
-        check(s1, null);
-        check(s1, p1.getService("Signature", "md5withrsa"));
-        check(s1, p1.getService("Signature", "MD5WITHRSA"));
-        check(s1, p1.getService("Signature", "MD5RSA"));
-        check(s1, p1.getService("Signature", "md5rsa"));
-        check(s1, p1.getService("Signature", "MD5rsa"));
-
-        s1 = p1.getService("Signature", "SHAwithRSA");
-        check(s1, null);
-        check(s1, p1.getService("Signature", "shawithrsa"));
-        check(s1, p1.getService("Signature", "SHAWITHRSA"));
-        check(s1, p1.getService("Signature", "SHARSA"));
-        check(s1, p1.getService("Signature", "sharsa"));
-        check(s1, p1.getService("Signature", "SHArsa"));
-        check(s1, p1.getService("Signature", "SHA1RSA"));
-        check(s1, p1.getService("Signature", "sha1rsa"));
-        check(s1, p1.getService("Signature", "SHA1rsa"));
-
-        s1 = p2.getService("Signature", "MD5withRSA");
-        check(s1, null);
-        check(s1, p2.getService("Signature", "md5withrsa"));
-        check(s1, p2.getService("Signature", "MD5WITHRSA"));
-        check(s1, p2.getService("Signature", "MD5RSA"));
-        check(s1, p2.getService("Signature", "md5rsa"));
-        check(s1, p2.getService("Signature", "MD5rsa"));
-
-        s1 = p2.getService("Signature", "SHAwithRSA");
-        check(s1, null);
-        check(s1, p2.getService("Signature", "shawithrsa"));
-        check(s1, p2.getService("Signature", "SHAWITHRSA"));
-        check(s1, p2.getService("Signature", "SHARSA"));
-        check(s1, p2.getService("Signature", "sharsa"));
-        check(s1, p2.getService("Signature", "SHArsa"));
-        check(s1, p2.getService("Signature", "SHA1RSA"));
-        check(s1, p2.getService("Signature", "sha1rsa"));
-        check(s1, p2.getService("Signature", "SHA1rsa"));
-
-        System.out.println("OK");
+        Locale loc = Locale.getDefault();
+        try {
+            Locale.setDefault(new Locale("tr", "TR"));
+
+            Provider p2 = new TProvider("T2");
+            System.out.println(p2.getServices()); // trigger service parsing
+
+            System.out.println(Signature.getInstance("MD5withRSA"));
+            System.out.println(Signature.getInstance("md5withrsa"));
+            System.out.println(Signature.getInstance("MD5WITHRSA"));
+            Service s1, s2;
+            s1 = p1.getService("Signature", "MD5withRSA");
+            check(s1, null);
+            check(s1, p1.getService("Signature", "md5withrsa"));
+            check(s1, p1.getService("Signature", "MD5WITHRSA"));
+            check(s1, p1.getService("Signature", "MD5RSA"));
+            check(s1, p1.getService("Signature", "md5rsa"));
+            check(s1, p1.getService("Signature", "MD5rsa"));
+
+            s1 = p1.getService("Signature", "SHAwithRSA");
+            check(s1, null);
+            check(s1, p1.getService("Signature", "shawithrsa"));
+            check(s1, p1.getService("Signature", "SHAWITHRSA"));
+            check(s1, p1.getService("Signature", "SHARSA"));
+            check(s1, p1.getService("Signature", "sharsa"));
+            check(s1, p1.getService("Signature", "SHArsa"));
+            check(s1, p1.getService("Signature", "SHA1RSA"));
+            check(s1, p1.getService("Signature", "sha1rsa"));
+            check(s1, p1.getService("Signature", "SHA1rsa"));
+
+            s1 = p2.getService("Signature", "MD5withRSA");
+            check(s1, null);
+            check(s1, p2.getService("Signature", "md5withrsa"));
+            check(s1, p2.getService("Signature", "MD5WITHRSA"));
+            check(s1, p2.getService("Signature", "MD5RSA"));
+            check(s1, p2.getService("Signature", "md5rsa"));
+            check(s1, p2.getService("Signature", "MD5rsa"));
+
+            s1 = p2.getService("Signature", "SHAwithRSA");
+            check(s1, null);
+            check(s1, p2.getService("Signature", "shawithrsa"));
+            check(s1, p2.getService("Signature", "SHAWITHRSA"));
+            check(s1, p2.getService("Signature", "SHARSA"));
+            check(s1, p2.getService("Signature", "sharsa"));
+            check(s1, p2.getService("Signature", "SHArsa"));
+            check(s1, p2.getService("Signature", "SHA1RSA"));
+            check(s1, p2.getService("Signature", "sha1rsa"));
+            check(s1, p2.getService("Signature", "SHA1rsa"));
+
+            System.out.println("OK");
+        } finally {
+            Locale.setDefault(loc);
+        }
     }
 
     private static void check(Service s1, Service s2) throws Exception {
--- jdk/test/java/security/Security/ClassLoaderDeadlock/ClassLoaderDeadlock.sh	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/ClassLoaderDeadlock/ClassLoaderDeadlock.sh	2013-05-05 09:38:44.000000000 -0700
@@ -46,15 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
@@ -89,6 +81,7 @@
 # run the test
 ${TESTJAVA}${FILESEP}bin${FILESEP}java \
         -classpath "${TESTCLASSES}${PATHSEP}${TESTSRC}${FILESEP}Deadlock.jar" \
+        -Djava.awt.headless=true \
         ClassLoaderDeadlock
 
 STATUS=$?
--- jdk/test/java/security/Security/ClassLoaderDeadlock/Deadlock.sh	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/ClassLoaderDeadlock/Deadlock.sh	2013-05-05 09:38:44.000000000 -0700
@@ -34,15 +34,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/java/security/Security/ClassLoaderDeadlock/Deadlock2.sh	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/ClassLoaderDeadlock/Deadlock2.sh	2013-05-05 09:38:44.000000000 -0700
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 #
-# Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -50,15 +50,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/java/security/Security/NoInstalledProviders.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/NoInstalledProviders.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /*
  * @test
- * @bug 4273454 7052537
+ * @bug 4273454 7054918 7052537
+ * @library ../testlibrary
  * @summary Make sure getProviders(filter) doesn't throw NPE
  * @run main/othervm NoInstalledProviders
  */
@@ -32,7 +33,16 @@
 
 public class NoInstalledProviders {
 
-    public static void main(String[] argv) {
+    public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
 
         Provider[] provs = Security.getProviders();
         // make sure there are no providers in the system
--- jdk/test/java/security/Security/SynchronizedAccess.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/SynchronizedAccess.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /*
  * @test
- * @bug 4162583
+ * @bug 4162583 7054918
+ * @library ../testlibrary
  * @summary Make sure Provider api implementations are synchronized properly
  */
 
@@ -31,7 +32,16 @@
 
 public class SynchronizedAccess {
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         AccessorThread[] acc = new AccessorThread[200];
         for (int i=0; i < acc.length; i++)
             acc[i] = new AccessorThread("thread"+i);
--- jdk/test/java/security/Security/removing/RemoveProviders.java	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/removing/RemoveProviders.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /**
  * @test
- * @bug 4963416
+ * @bug 4963416 7054918
+ * @library ../../testlibrary
  * @summary make sure removeProvider() always works correctly
  * @author Andreas Sterbenz
  */
@@ -35,6 +36,15 @@
 public class RemoveProviders {
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         Provider[] providers = Security.getProviders();
         System.out.println("Providers: " + Arrays.asList(providers));
 
--- jdk/test/java/security/Security/signedfirst/Dyn.sh	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/signedfirst/Dyn.sh	2013-05-05 09:38:44.000000000 -0700
@@ -46,15 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/java/security/Security/signedfirst/Static.sh	2012-08-10 10:34:51.000000000 -0700
+++ jdk/test/java/security/Security/signedfirst/Static.sh	2013-05-05 09:38:44.000000000 -0700
@@ -46,15 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/java/security/UnresolvedPermission/Equals.java	2012-08-10 10:34:52.000000000 -0700
+++ jdk/test/java/security/UnresolvedPermission/Equals.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,7 @@
 /*
  * @test
  * @bug 4513737
+ * @run main/othervm Equals
  * @summary UnresolvedPermission.equals() throws NullPointerException
  */
 
--- jdk/test/java/security/spec/EllipticCurveMatch.java	2012-08-10 10:34:53.000000000 -0700
+++ jdk/test/java/security/spec/EllipticCurveMatch.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,13 +25,12 @@
  * @test
  * @bug 6738532
  * @summary Check EllipticCurve.equals() does not compare seed value of curve.
- * @run main/othervm EllipticCurveMatch
  * @author Mike StJohns
  */
 
 import java.security.spec.*;
 import java.math.BigInteger;
-import java.security.SecureRandom;
+import java.util.Random;
 
 public class EllipticCurveMatch {
     static String primeP256 =
@@ -45,7 +44,7 @@
 
     private static EllipticCurve addSeedToCurve(EllipticCurve curve)
     {
-        SecureRandom rand = new SecureRandom();
+        Random rand = new Random();
         byte[] seed = new byte[12];
         rand.nextBytes(seed);
 
--- jdk/test/java/security/testlibrary/Providers.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/security/testlibrary/Providers.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.security.Provider;
+import java.security.Security;
+
+public class Providers {
+    public static void setAt(Provider p, int pos) throws Exception {
+        if (Security.getProvider(p.getName()) != null) {
+            Security.removeProvider(p.getName());
+        }
+        if (Security.insertProviderAt(p, pos) == -1) {
+            throw new Exception("cannot setAt");
+        }
+    }
+}
--- jdk/test/java/security/testlibrary/ProvidersSnapshot.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/security/testlibrary/ProvidersSnapshot.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.security.Provider;
+import java.security.Security;
+
+public class ProvidersSnapshot {
+
+    private Provider[] oldProviders;
+
+    private ProvidersSnapshot() {
+        oldProviders = Security.getProviders();
+    }
+
+    public static ProvidersSnapshot create() {
+        return new ProvidersSnapshot();
+    }
+
+    public void restore() {
+        Provider[] newProviders = Security.getProviders();
+        for (Provider p: newProviders) {
+            Security.removeProvider(p.getName());
+        }
+        for (Provider p: oldProviders) {
+            Security.addProvider(p);
+        }
+    }
+}
--- jdk/test/java/util/Currency/PropertiesTest.sh	2012-08-10 10:34:57.000000000 -0700
+++ jdk/test/java/util/Currency/PropertiesTest.sh	2013-05-05 09:38:44.000000000 -0700
@@ -30,7 +30,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/util/PluggableLocale/ExecTest.sh	2012-08-10 10:35:02.000000000 -0700
+++ jdk/test/java/util/PluggableLocale/ExecTest.sh	2013-05-05 09:38:44.000000000 -0700
@@ -58,7 +58,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/java/util/ResourceBundle/Bug6299235Test.sh	2012-08-10 10:35:04.000000000 -0700
+++ jdk/test/java/util/ResourceBundle/Bug6299235Test.sh	2013-05-05 09:38:44.000000000 -0700
@@ -31,7 +31,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/java/util/ResourceBundle/Control/ExpirationTest.sh	2012-08-10 10:35:05.000000000 -0700
+++ jdk/test/java/util/ResourceBundle/Control/ExpirationTest.sh	2013-05-05 09:38:44.000000000 -0700
@@ -72,10 +72,10 @@
 Windows* | CYGWIN* )
     DEL=";"
     ;;
-SunOS | Darwin)
+SunOS | Darwin )
     DEL=":"
     ;;
-Linux)
+Linux | *BSD )
     DEL=":"
     HAS_S=YES
     ;;
--- jdk/test/java/util/ServiceLoader/basic.sh	2012-08-10 10:35:06.000000000 -0700
+++ jdk/test/java/util/ServiceLoader/basic.sh	2013-05-05 09:38:44.000000000 -0700
@@ -42,9 +42,7 @@
 
 OS=`uname -s`
 case "$OS" in
-    SunOS | Darwin )
-      SEP=':' ;;
-    Linux )
+    SunOS | Linux | *BSD | Darwin )
       SEP=':' ;;
     * )
       SEP='\;' ;;
--- jdk/test/java/util/Timer/KillThread.java	2012-08-10 10:35:08.000000000 -0700
+++ jdk/test/java/util/Timer/KillThread.java	2013-05-05 09:38:44.000000000 -0700
@@ -32,20 +32,25 @@
 
 public class KillThread {
     public static void main (String[] args) throws Exception  {
+        final Thread[] tdThread = new Thread[1];
         Timer t = new Timer();
 
         // Start a mean event that kills the timer thread
         t.schedule(new TimerTask() {
             public void run() {
+                tdThread[0] = Thread.currentThread();
                 throw new ThreadDeath();
             }
         }, 0);
 
         // Wait for mean event to do the deed and thread to die.
         try {
-            Thread.sleep(100);
+            do {
+                Thread.sleep(100);
+            } while(tdThread[0] == null);
         } catch(InterruptedException e) {
         }
+        tdThread[0].join();
 
         // Try to start another event
         try {
--- jdk/test/java/util/concurrent/BlockingQueue/LastElement.java	2012-08-10 10:35:08.000000000 -0700
+++ jdk/test/java/util/concurrent/BlockingQueue/LastElement.java	2013-05-05 09:38:44.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 6215625 7161229
+ * @bug 6215625
  * @summary Check correct behavior when last element is removed.
  * @author Martin Buchholz
  */
@@ -38,7 +38,9 @@
         testQueue(new ArrayBlockingQueue<Integer>(10, true));
         testQueue(new ArrayBlockingQueue<Integer>(10, false));
         testQueue(new LinkedTransferQueue<Integer>());
-        testQueue(new PriorityBlockingQueue<Integer>());
+
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new Exception("Some tests failed");
     }
 
     void testQueue(BlockingQueue<Integer> q) throws Throwable {
@@ -57,7 +59,6 @@
         try {check(q.take() == three);}
         catch (Throwable t) {unexpected(t);}
         check(q.isEmpty() && q.size() == 0);
-        check(noRetention(q));
 
         // iterator().remove()
         q.clear();
@@ -76,26 +77,6 @@
         check(q.isEmpty() && q.size() == 0);
     }
 
-    boolean noRetention(BlockingQueue<?> q) {
-        if (q instanceof PriorityBlockingQueue) {
-            PriorityBlockingQueue<?> pbq = (PriorityBlockingQueue) q;
-            try {
-                java.lang.reflect.Field queue =
-                    PriorityBlockingQueue.class.getDeclaredField("queue");
-                queue.setAccessible(true);
-                Object[] a = (Object[]) queue.get(pbq);
-                return a[0] == null;
-            }
-            catch (NoSuchFieldException e) {
-                unexpected(e);
-            }
-            catch (IllegalAccessException e) {
-                // ignore - security manager must be installed
-            }
-        }
-        return true;
-    }
-
     //--------------------- Infrastructure ---------------------------
     volatile int passed = 0, failed = 0;
     void pass() {passed++;}
--- jdk/test/java/util/concurrent/Executors/AutoShutdown.java	2012-08-10 10:35:09.000000000 -0700
+++ jdk/test/java/util/concurrent/Executors/AutoShutdown.java	2013-05-05 09:38:44.000000000 -0700
@@ -67,6 +67,11 @@
         e1 = e2 = null;
         for (int i = 0; i < 10 && Thread.activeCount() > count0; i++)
             tryWaitForFinalizersToRun();
+        for (int i = 0; i < 10; ++i) { // give JVM a chance to settle.
+            if (Thread.activeCount() == count0)
+                return;
+            Thread.sleep(1000);
+        }
         equal(Thread.activeCount(), count0);
     }
 
--- jdk/test/java/util/concurrent/FutureTask/BlockingTaskExecutor.java	2012-08-10 10:35:09.000000000 -0700
+++ jdk/test/java/util/concurrent/FutureTask/BlockingTaskExecutor.java	2013-05-05 09:38:44.000000000 -0700
@@ -75,10 +75,10 @@
             throw new Error("Executor stuck");
 
         // Wait for the invocation thread to complete.
-        thread.join(1000);
+        thread.join(5000);
         if (thread.isAlive()) {
             thread.interrupt();
-            thread.join(1000);
+            thread.join(5000);
             throw new Error("invokeAll stuck");
         }
     }
--- jdk/test/java/util/concurrent/Phaser/Basic.java	2012-08-10 10:35:09.000000000 -0700
+++ jdk/test/java/util/concurrent/Phaser/Basic.java	2013-05-05 09:38:44.000000000 -0700
@@ -96,7 +96,7 @@
             int phase = atTheStartingGate.getPhase();
             equal(phase, atTheStartingGate.arrive());
             int awaitPhase = atTheStartingGate.awaitAdvanceInterruptibly
-                (phase, 10, SECONDS);
+                (phase, 30, SECONDS);
             if (expectNextPhase) check(awaitPhase == (phase + 1));
 
             pass();
@@ -188,7 +188,7 @@
                     case 2: case 6: case 7:
                         return awaiter(phaser, -1, SECONDS);
                     default:
-                        return awaiter(phaser, 10, SECONDS); }}
+                        return awaiter(phaser, 30, SECONDS); }}
             public void remove() {throw new UnsupportedOperationException();}};
     }
 
@@ -204,7 +204,7 @@
                     case 2: case 5:
                         return awaiter(phaser, -1, SECONDS);
                     default:
-                        return awaiter(phaser, 10, SECONDS); }}
+                        return awaiter(phaser, 30, SECONDS); }}
             public void remove() {throw new UnsupportedOperationException();}};
     }
 
@@ -251,9 +251,11 @@
             int phase = phaser.getPhase();
             for (int i = 0; i < 4; i++) {
                 check(phaser.getPhase() == phase);
-                Awaiter a1 = awaiter(phaser, 10, SECONDS); a1.start();
+                Awaiter a1 = awaiter(phaser, 30, SECONDS); a1.start();
                 Arriver a2 = arrivers.next(); a2.start();
                 toTheStartingGate();
+                // allow a1 to block in awaitAdvanceInterruptibly
+                Thread.sleep(2000);
                 a1.interrupt();
                 a1.join();
                 phaser.arriveAndAwaitAdvance();
--- jdk/test/java/util/concurrent/ThreadPoolExecutor/Custom.java	2012-08-10 10:35:10.000000000 -0700
+++ jdk/test/java/util/concurrent/ThreadPoolExecutor/Custom.java	2013-05-05 09:38:44.000000000 -0700
@@ -100,8 +100,8 @@
         equal(countExecutorThreads(), threadCount);
         equal(CustomTask.births.get(), threadCount);
         tpe.shutdown();
-        tpe.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
-        Thread.sleep(10);
+        tpe.awaitTermination(120, TimeUnit.SECONDS);
+        Thread.sleep(1000);
         equal(countExecutorThreads(), 0);
 
         CustomSTPE stpe = new CustomSTPE();
@@ -110,8 +110,8 @@
         equal(CustomSTPE.decorations.get(), threadCount);
         equal(countExecutorThreads(), threadCount);
         stpe.shutdown();
-        stpe.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
-        Thread.sleep(10);
+        stpe.awaitTermination(120, TimeUnit.SECONDS);
+        Thread.sleep(1000);
         equal(countExecutorThreads(), 0);
 
         System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
--- jdk/test/java/util/concurrent/locks/Lock/FlakyMutex.java	2012-08-10 10:35:10.000000000 -0700
+++ jdk/test/java/util/concurrent/locks/Lock/FlakyMutex.java	2013-05-05 09:38:44.000000000 -0700
@@ -86,7 +86,7 @@
                 } catch (Throwable t) { unexpected(t); }}});}
         barrier.await();
         es.shutdown();
-        check(es.awaitTermination(10, TimeUnit.SECONDS));
+        check(es.awaitTermination(30, TimeUnit.SECONDS));
     }
 
     private static class FlakySync extends AbstractQueuedLongSynchronizer {
--- jdk/test/java/util/logging/CustomLogManager.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/util/logging/CustomLogManager.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.*;
+import java.util.*;
+import java.util.logging.*;
+
+/*
+ * Custom LogManager implementation to verify that the implementation delegates
+ * to the LogManager subclass to register both system logger and user logger.
+ *
+ * The LogManager implementation is the one configuring the logger's property
+ * such as level, handler, etc.
+ */
+public class CustomLogManager extends LogManager {
+    static LogManager INSTANCE;
+    Map<String,Logger> namedLoggers = new HashMap<>();
+    Properties props = initConfig();
+    public CustomLogManager() {
+        if (INSTANCE != null) {
+            throw new RuntimeException("CustomLogManager already created");
+        }
+        INSTANCE = this;
+    }
+
+    public synchronized boolean addLogger(Logger logger) {
+        String name = logger.getName();
+        if (namedLoggers.containsKey(name)) {
+            return false;
+        }
+        namedLoggers.put(name, logger);
+        // set level
+        if (props.get(name + ".level") != null) {
+            logger.setLevel(Level.parse(props.getProperty(name + ".level")));
+        }
+        // add handlers
+        if (props.get(name + ".handlers") != null && logger.getHandlers().length == 0) {
+            logger.addHandler(new CustomHandler());
+        }
+        // add parent loggers
+        int ix = 1;
+        for (;;) {
+            int ix2 = name.indexOf(".", ix);
+            if (ix2 < 0) {
+                break;
+            }
+            String pname = name.substring(0, ix2);
+            if (props.get(pname + ".level") != null ||
+                props.get(pname + ".handlers") != null) {
+                // This pname has a level/handlers definition.
+                // Make sure it exists.
+                //
+                // The test doesn't set the parent for simplicity.
+                if (!namedLoggers.containsKey(pname)) {
+                    Logger.getLogger(pname);
+                }
+            }
+            ix = ix2 + 1;
+        }
+        return true;
+    }
+
+    public synchronized Logger getLogger(String name) {
+        return namedLoggers.get(name);
+    }
+
+    public synchronized Enumeration<String> getLoggerNames() {
+        return Collections.enumeration(namedLoggers.keySet());
+    }
+
+    public String getProperty(String name) {
+        return props.getProperty(name);
+    }
+
+    public void readConfiguration() {
+        // do nothing
+    }
+
+    public void readConfiguration(InputStream ins) {
+        // do nothing
+    }
+
+    private Properties initConfig() {
+        Properties props = new Properties();
+        props.put(".level", "CONFIG");
+        props.put("CustomLogManagerTest.level", "WARNING");
+        props.put("CustomLogManagerTest.handlers", "CustomLogManager$CustomHandler");
+        props.put("SimpleLogManager.level", "INFO");
+        props.put("SimpleLogManager.handlers", "CustomLogManager$CustomHandler");
+        props.put("CustomLogManager$CustomHandler.level", "WARNING");
+        props.put(".handlers", "CustomLogManager$CustomHandler");
+        props.put("org.foo.bar.level", "SEVERE");
+        props.put("org.foo.handlers", "CustomLogManager$CustomHandler");
+        props.put("org.openjdk.level", "SEVERE");
+        props.put("org.openjdk.handlers", "CustomLogManager$CustomHandler");
+        props.put("org.openjdk.core.level", "INFO");
+
+        return props;
+    }
+
+    public static void checkLogger(String name) {
+        checkLogger(name, null);
+    }
+
+    public static void checkLogger(String name, String resourceBundleName) {
+        Logger logger = INSTANCE.getLogger(name);
+        if (logger == null) {
+            throw new RuntimeException("Logger \"" + name + "\" not exist");
+        }
+        System.out.format("Logger \"%s\" level=%s handlers=%s resourcebundle=%s%n",
+            name, logger.getLevel(),
+            Arrays.toString(logger.getHandlers()),
+            logger.getResourceBundleName());
+        String rb = logger.getResourceBundleName();
+        if (rb != resourceBundleName && (rb == null || rb.equals(resourceBundleName))) {
+            throw new RuntimeException("Logger \"" + name +
+                "\" unexpected resource bundle: " + rb);
+        }
+
+        String value = INSTANCE.getProperty(name + ".level");
+        String level = logger.getLevel() != null ? logger.getLevel().getName() : null;
+        if (level != value && (level == null || level.equals(value))) {
+            throw new RuntimeException("Logger \"" + name + "\" unexpected level: " + level);
+        }
+
+        Handler[] handlers = logger.getHandlers();
+        String hdl = INSTANCE.getProperty(name + ".handlers");
+        if ((hdl == null && handlers.length != 0) ||
+            (hdl != null && handlers.length != 1)) {
+            throw new RuntimeException("Logger \"" + name + "\" unexpected handler: " +
+                Arrays.toString(handlers));
+        }
+        checkParents(name);
+    }
+
+    private static void checkParents(String name) {
+        int ix = 1;
+        for (;;) {
+            int ix2 = name.indexOf(".", ix);
+            if (ix2 < 0) {
+                break;
+            }
+            String pname = name.substring(0, ix2);
+            if (INSTANCE.getProperty(pname + ".level") != null ||
+                INSTANCE.getProperty(pname + ".handlers") != null) {
+                // This pname has a level/handlers definition.
+                // Make sure it exists.
+                checkLogger(pname);
+            }
+            ix = ix2 + 1;
+        }
+    }
+
+    // only CustomLogManager can create an instance of CustomHandler
+    private class CustomHandler extends StreamHandler {
+    }
+}
--- jdk/test/java/util/logging/CustomLogManagerTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/util/logging/CustomLogManagerTest.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.*;
+import java.util.*;
+
+import java.util.logging.*;
+import sun.util.logging.PlatformLogger;
+
+/*
+ * @test
+ * @bug 8005615
+ * @summary Add loggers to custom log manager
+ *
+ * @compile -XDignore.symbol.file CustomLogManagerTest.java CustomLogManager.java
+ * @run main/othervm -Djava.util.logging.manager=CustomLogManager CustomLogManagerTest
+ */
+public class CustomLogManagerTest {
+    private static final String RESOURCE_BUNDLE = "sun.util.logging.resources.logging";
+    public static void main(String[] args) {
+        String mgr = System.getProperty("java.util.logging.manager");
+        if (!mgr.equals("CustomLogManager")) {
+            throw new RuntimeException("java.util.logging.manager not set");
+        }
+
+        Logger.getLogger(CustomLogManagerTest.class.getName());
+        Logger.getLogger("org.foo.Foo");
+        Logger.getLogger("org.foo.bar.Foo", RESOURCE_BUNDLE);
+        // platform logger will be set with the default system resource bundle
+        PlatformLogger.getLogger("org.openjdk.core.logger");
+
+        if (LogManager.getLogManager() != CustomLogManager.INSTANCE) {
+             throw new RuntimeException(LogManager.getLogManager() + " not CustomLogManager");
+        }
+
+        CustomLogManager.checkLogger(CustomLogManagerTest.class.getName());
+        CustomLogManager.checkLogger("org.foo.Foo");
+        CustomLogManager.checkLogger("org.foo.bar.Foo", RESOURCE_BUNDLE);
+        CustomLogManager.checkLogger(Logger.GLOBAL_LOGGER_NAME);
+        CustomLogManager.checkLogger("");
+        CustomLogManager.checkLogger("org.openjdk.core.logger", RESOURCE_BUNDLE);
+    }
+}
--- jdk/test/java/util/logging/SimpleLogManager.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/java/util/logging/SimpleLogManager.java	2013-05-05 09:38:44.000000000 -0700
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.util.*;
+import java.util.logging.*;
+import sun.util.logging.PlatformLogger;
+
+/*
+ * @test
+ * @bug 8005615
+ * @summary A LogManager subclass overrides its own implementation of named
+ *          logger (see the subclassing information in the Logger class specification)
+ *
+ * @compile -XDignore.symbol.file CustomLogManager.java SimpleLogManager.java
+ * @run main/othervm -Djava.util.logging.manager=SimpleLogManager SimpleLogManager
+ */
+public class SimpleLogManager extends CustomLogManager {
+    public static void main(String[] args) {
+        String classname = System.getProperty("java.util.logging.manager");
+        if (!classname.equals("SimpleLogManager")) {
+            throw new RuntimeException("java.util.logging.manager not set");
+        }
+
+        Logger logger = Logger.getLogger(SimpleLogManager.class.getName());
+        Logger.getLogger("org.foo.bar.Foo");
+
+        // a platform logger used by the system code is just a Logger instance.
+        PlatformLogger.getLogger("org.openjdk.core.logger");
+
+        LogManager mgr = LogManager.getLogManager();
+        if (mgr != CustomLogManager.INSTANCE || !(mgr instanceof SimpleLogManager)) {
+             throw new RuntimeException(LogManager.getLogManager() + " not SimpleLogManager");
+        }
+
+        checkCustomLogger(SimpleLogManager.class.getName(), null);
+        checkCustomLogger("org.foo.bar.Foo", null);
+        checkCustomLogger("org.openjdk.core.logger", "sun.util.logging.resources.logging");
+
+        // ## The LogManager.demandLogger method does not handle custom log manager
+        // ## that overrides the getLogger method to return a custom logger
+        // ## (see the test case in 8005640).  Logger.getLogger may return
+        // ## a Logger instance but LogManager overrides it with a custom Logger
+        // ## instance like this case.
+        //
+        // However, the specification of LogManager and Logger subclassing is
+        // not clear whether this is supported or not.  The following check
+        // just captures the current behavior.
+        if (logger instanceof CustomLogger) {
+            throw new RuntimeException(logger + " not CustomLogger");
+        }
+    }
+
+    private static void checkCustomLogger(String name, String resourceBundleName) {
+        CustomLogManager.checkLogger(name, resourceBundleName);
+        Logger logger1 = Logger.getLogger(name);
+        Logger logger2 = LogManager.getLogManager().getLogger(name);
+        if (logger1 != logger2) {
+            throw new RuntimeException(logger1 + " != " + logger2);
+        }
+        if (!(logger1 instanceof CustomLogger)) {
+            throw new RuntimeException(logger1 + " not CustomLogger");
+        }
+    }
+
+    /*
+     * This SimpleLogManager overrides the addLogger method to replace
+     * the given logger with a custom logger.
+     *
+     * It's unclear what the recommended way to use custom logger is.
+     * A LogManager subclass might override the getLogger method to return
+     * a custom Logger and create a new custom logger if not exist so that
+     * Logger.getLogger() can return a custom Logger instance but that violates
+     * the LogManager.getLogger() spec which should return null if not found.
+     */
+    public synchronized boolean addLogger(Logger logger) {
+        String name = logger.getName();
+        if (namedLoggers.containsKey(name)) {
+            return false;
+        }
+        CustomLogger newLogger = new CustomLogger(logger);
+        super.addLogger(newLogger);
+        return true;
+    }
+
+    public class CustomLogger extends Logger {
+        CustomLogger(Logger logger) {
+            super(logger.getName(), logger.getResourceBundleName());
+        }
+        CustomLogger(String name) {
+            super(name, null);
+        }
+    }
+}
--- jdk/test/javax/crypto/EncryptedPrivateKeyInfo/GetKeySpecException.java	2012-08-10 10:35:14.000000000 -0700
+++ jdk/test/javax/crypto/EncryptedPrivateKeyInfo/GetKeySpecException.java	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /**
  * @test
- * @bug 4508341
+ * @bug 4508341 7055362
+ * @library ../../../java/security/testlibrary
  * @summary Test the error conditions of
  * EncryptedPrivateKeyInfo.getKeySpec(...) methods.
  * @author Valerie Peng
@@ -97,7 +98,16 @@
         }
     }
 
-    public static void main(String[] argv) throws Exception {
+    public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         if ((GOOD_PARAMS == null) || (BAD_PARAMS == null)) {
             throw new Exception("Static parameter generation failed");
         }
--- jdk/test/javax/crypto/JceSecurity/SunJCE_BC_LoadOrdering.java	2012-08-10 10:35:14.000000000 -0700
+++ jdk/test/javax/crypto/JceSecurity/SunJCE_BC_LoadOrdering.java	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,8 @@
 
 /*
  * @test
- * @bug 6377058
+ * @bug 6377058 7055362
+ * @library ../../../java/security/testlibrary
  * @summary SunJCE depends on sun.security.provider.SignatureImpl
  * behaviour, BC can't load into 1st slot.
  * @author Brad R. Wetmore
@@ -35,7 +36,16 @@
 
 public class SunJCE_BC_LoadOrdering {
 
-    public static void main(String args[]) throws Exception {
+    public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         /*
          * Generate a random key, and encrypt the data
          */
--- jdk/test/javax/crypto/SecretKeyFactory/FailOverTest.sh	2012-08-10 10:35:14.000000000 -0700
+++ jdk/test/javax/crypto/SecretKeyFactory/FailOverTest.sh	2013-05-05 09:38:47.000000000 -0700
@@ -51,7 +51,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- jdk/test/javax/crypto/sanity/CheckManifestForRelease.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/crypto/sanity/CheckManifestForRelease.java	2013-05-05 09:38:47.000000000 -0700
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7195931 7197071 7198146
+ * @summary UnsatisfiedLinkError on PKCS11.C_GetOperationState while
+ *          using NSS from jre7u6+
+ */
+import java.net.*;
+import java.io.*;
+import java.security.*;
+import java.lang.reflect.*;
+
+/**
+ * When the Java specification version is incremented, all of the providers
+ * must be recompiled with the proper implementation version to match.
+ */
+public class CheckManifestForRelease {
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) throws Exception {
+        checkP11MessageDigestClone();
+        checkFileManifests();
+    }
+
+    /*
+     * Iterate over the files of interest: JCE framework and providers
+     */
+    static private void checkFileManifests() throws Exception {
+        System.out.println("=============");
+        String libDirName = System.getProperty("java.home", ".") + "/lib";
+        String extDirName = libDirName + "/ext";
+
+        System.out.println("Checking Manifest in directory: \n    " +
+            extDirName);
+
+        /*
+         * Current list of JCE providers, all of which currently live in
+         * the extensions directory.  Add if more are created.
+         */
+        String[] providers = new String[]{
+            "sunjce_provider.jar",
+            "sunec.jar",
+            "sunmscapi.jar",
+            "sunpkcs11.jar",
+            "ucrypto.jar"
+        };
+
+        checkManifest(libDirName, "jce.jar");
+        for (String provider : providers) {
+            checkManifest(extDirName, provider);
+        }
+        System.out.println("Passed.");
+    }
+
+    // Helper method to format the URL properly.
+    static private String formatURL(String dir, String file) {
+        return "jar:file:///" + dir + "/" + file + "!/";
+    }
+
+    static private String specVersion =
+        System.getProperty("java.specification.version");
+
+    /*
+     * Test the root cause, which is that there were no manifest values
+     * for many of the providers, and for those that had them, there was
+     * no test to make sure that the impl version was appropriate for
+     * the spec version.
+     */
+    static private void checkManifest(String dir, String file)
+            throws Exception {
+
+        System.out.println("Checking: " + file);
+
+        String url = formatURL(dir, file);
+        JarURLConnection urlc =
+            (JarURLConnection) (new URL(url).openConnection());
+
+        String implVersion;
+        try {
+            implVersion = urlc.getManifest().getMainAttributes().getValue(
+                "Implementation-Version");
+        } catch (FileNotFoundException e) {
+            /*
+             * If the file doesn't exist (e.g. mscapi on solaris),
+             * skip it. If there are other problems, fail out.
+             */
+            System.out.println("    " + file + " not found, skipping...");
+            return;
+        }
+
+        if (implVersion == null) {
+            throw new Exception(
+                "Implementation-Version not found in Manifest");
+        }
+
+        if (!implVersion.startsWith(specVersion)) {
+            throw new Exception(
+                "Implementation-Version does not match " +
+                "Specification-Version");
+        }
+    }
+
+    /*
+     * Workaround for unfortunately generified forName() API
+     */
+    @SuppressWarnings("unchecked")
+    static private Class<Provider> getProviderClass(String name)
+            throws Exception {
+        return (Class<Provider>)Class.forName(name);
+    }
+
+    /*
+     * Check the symptom, an UnsatisfiedLinkError in MessageDigests.
+     */
+    static private void checkP11MessageDigestClone() throws Exception {
+
+        System.out.println("=============");
+        System.out.println("Checking for UnsatisfiedLinkError");
+        String os = System.getProperty("os.name");
+        // Only run on Solaris
+        if (!os.equals("SunOS")) {
+            return;
+        }
+
+        /*
+         * We have to do some gyrations here, since the code to exercise
+         * this is in the P11 MessageDigests, and most of those mechanisms
+         * are disabled by default.
+         */
+        String customP11File =
+            System.getProperty("TESTSRC", ".") + "/p11-solaris.txt";
+
+        /*
+         * In 7u, we don't have a 64 PKCS11 windows build yet, so we
+         * have to do some dynamic checking to determine if there is
+         * a PKCS11 library available to test against.  Otherwise, the
+         * windows 64 bit will throw a compilation error before the
+         * test is even run.
+         */
+        Constructor<Provider> cons;
+        Provider provider;
+        try {
+            Class<Provider> clazz =
+                getProviderClass("sun.security.pkcs11.SunPKCS11");
+            cons = clazz.getConstructor(new Class[]{String.class});
+            provider = cons.newInstance(new Object[]{customP11File});
+        } catch (Exception ex) {
+            System.out.println("Skipping test - no PKCS11 provider available");
+            return;
+        }
+
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA1", provider);
+            md.update((byte) 0x01);
+            System.out.println(md.getProvider());
+            md.clone();
+        } catch (Exception e) {
+            // These kinds of failure are ok.  We're testing the
+            // UnsatisfiedLinkError here.
+        }
+        System.out.println("Passed.");
+    }
+}
--- jdk/test/javax/crypto/sanity/p11-solaris.txt	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/crypto/sanity/p11-solaris.txt	2013-05-05 09:38:47.000000000 -0700
@@ -0,0 +1,21 @@
+#
+# Configuration file to allow the SunPKCS11 provider to utilize
+# the Solaris Cryptographic Framework, if it is available
+#
+# This is a temporary file only for testing.  It does not contain the
+# normal disabled PKCS11 mechanisms that we will use for this test.
+#
+
+name = MyProvider
+
+description = SunPKCS11 accessing Solaris Cryptographic Framework
+
+library = /usr/lib/$ISA/libpkcs11.so
+
+handleStartupErrors = ignoreAll
+
+attributes = compatibility
+
+disabledMechanisms = {
+  CKM_MD2
+}
--- jdk/test/javax/imageio/stream/StreamCloserLeak/run_test.sh	2012-08-10 10:35:15.000000000 -0700
+++ jdk/test/javax/imageio/stream/StreamCloserLeak/run_test.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,6 +1,6 @@
 #!/bin/ksh -p
 #
-# Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -78,28 +78,36 @@
 case "$OS" in
    SunOS )
       VAR="One value for Sun"
-      DEFAULT_JDK=/usr/local/java/jdk1.2/solaris
+      DEFAULT_JDK=/
       FILESEP="/"
       PATHSEP=":"
       TMP="/tmp"
       ;;
 
-   Linux | Darwin )
+   Linux | *BSD | Darwin )
       VAR="A different value for Linux"
-      DEFAULT_JDK=/usr/local/java/jdk1.4/linux-i386
+      DEFAULT_JDK=/
       FILESEP="/"
       PATHSEP=":"
       TMP="/tmp"
       ;;
 
-   Windows_95 | Windows_98 | Windows_NT | Windows_ME | CYGWIN* )
+   Windows* )
       VAR="A different value for Win32"
-      DEFAULT_JDK=/usr/local/java/jdk1.2/win32
+      DEFAULT_JDK="C:/Program Files/Java/jdk1.8.0"
       FILESEP="\\"
       PATHSEP=";"
       TMP=`cd "${SystemRoot}/Temp"; echo ${PWD}`
       ;;
 
+    CYGWIN* )
+      VAR="A different value for Cygwin"
+      DEFAULT_JDK="/cygdrive/c/Program\ Files/Java/jdk1.8.0"
+      FILESEP="/"
+      PATHSEP=";"
+      TMP=`cd "${SystemRoot}/Temp"; echo ${PWD}`
+      ;;
+
    # catch all other OSs
    * )
       echo "Unrecognized system!  $OS"
--- jdk/test/javax/management/remote/mandatory/subjectDelegation/SubjectDelegation2Test.java	2012-08-10 10:35:22.000000000 -0700
+++ jdk/test/javax/management/remote/mandatory/subjectDelegation/SubjectDelegation2Test.java	2013-05-05 09:38:47.000000000 -0700
@@ -119,9 +119,6 @@
             System.out.println("Create SimpleStandard MBean");
             SimpleStandard s = new SimpleStandard("monitorRole");
             mbs.registerMBean(s, new ObjectName("MBeans:type=SimpleStandard"));
-            // Set Security Manager
-            //
-            System.setSecurityManager(new SecurityManager());
             // Create Properties containing the username/password entries
             //
             Properties props = new Properties();
@@ -132,6 +129,9 @@
             HashMap env = new HashMap();
             env.put("jmx.remote.authenticator",
                     new JMXPluggableAuthenticator(props));
+            // Set Security Manager
+            //
+            System.setSecurityManager(new SecurityManager());
             // Create an RMI connector server
             //
             System.out.println("Create an RMI connector server");
--- jdk/test/javax/management/remote/mandatory/subjectDelegation/SubjectDelegation3Test.java	2012-08-10 10:35:22.000000000 -0700
+++ jdk/test/javax/management/remote/mandatory/subjectDelegation/SubjectDelegation3Test.java	2013-05-05 09:38:47.000000000 -0700
@@ -120,9 +120,6 @@
             System.out.println("Create SimpleStandard MBean");
             SimpleStandard s = new SimpleStandard("delegate");
             mbs.registerMBean(s, new ObjectName("MBeans:type=SimpleStandard"));
-            // Set Security Manager
-            //
-            System.setSecurityManager(new SecurityManager());
             // Create Properties containing the username/password entries
             //
             Properties props = new Properties();
@@ -133,6 +130,9 @@
             HashMap env = new HashMap();
             env.put("jmx.remote.authenticator",
                     new JMXPluggableAuthenticator(props));
+            // Set Security Manager
+            //
+            System.setSecurityManager(new SecurityManager());
             // Create an RMI connector server
             //
             System.out.println("Create an RMI connector server");
--- jdk/test/javax/rmi/ssl/SocketFactoryTest.java	2012-08-10 10:35:25.000000000 -0700
+++ jdk/test/javax/rmi/ssl/SocketFactoryTest.java	2013-05-05 09:38:47.000000000 -0700
@@ -26,8 +26,7 @@
  * @bug 4932837 6582235
  * @summary Test SslRMI[Client|Server]SocketFactory equals() and hashCode().
  * @author Daniel Fuchs
- * @run clean SocketFactoryTest
- * @run build SocketFactoryTest
+ *
  * @run main SocketFactoryTest
  */
 
--- jdk/test/javax/script/CommonSetup.sh	2012-08-10 10:35:25.000000000 -0700
+++ jdk/test/javax/script/CommonSetup.sh	2013-05-05 09:38:47.000000000 -0700
@@ -36,7 +36,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/javax/security/auth/Subject/doAs/Test.sh	2012-08-10 10:35:26.000000000 -0700
+++ jdk/test/javax/security/auth/Subject/doAs/Test.sh	2013-05-05 09:38:47.000000000 -0700
@@ -33,17 +33,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    RM="/bin/rm -f"
-    ;;
-  Linux )
-    PS=":"
-    FS="/"
-    RM="/bin/rm -f"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     RM="/bin/rm -f"
--- jdk/test/javax/security/auth/login/LoginContext/ResetConfigModule.java	2012-08-10 10:35:28.000000000 -0700
+++ jdk/test/javax/security/auth/login/LoginContext/ResetConfigModule.java	2013-05-05 09:38:47.000000000 -0700
@@ -25,7 +25,6 @@
  * @test
  * @bug 4633622
  * @summary  bug in LoginContext when Configuration is subclassed
- *
  * @build ResetConfigModule ResetModule
  * @run main ResetConfigModule
  */
@@ -40,32 +39,42 @@
 
     public static void main(String[] args) throws Exception {
 
-        Configuration.setConfiguration(new MyConfig());
+        Configuration previousConf = Configuration.getConfiguration();
+        ClassLoader previousCL = Thread.currentThread().getContextClassLoader();
 
-        LoginContext lc = new LoginContext("test");
         try {
-            lc.login();
-            throw new SecurityException("test 1 failed");
-        } catch (LoginException le) {
-            if (le.getCause() != null &&
-                le.getCause() instanceof SecurityException) {
-                System.out.println("good so far");
-            } else {
-                throw le;
+            Thread.currentThread().setContextClassLoader(
+                    ResetConfigModule.class.getClassLoader());
+            Configuration.setConfiguration(new MyConfig());
+
+            LoginContext lc = new LoginContext("test");
+            try {
+                lc.login();
+                throw new SecurityException("test 1 failed");
+            } catch (LoginException le) {
+                if (le.getCause() != null &&
+                    le.getCause() instanceof SecurityException) {
+                    System.out.println("good so far");
+                } else {
+                    throw le;
+                }
             }
-        }
 
-        LoginContext lc2 = new LoginContext("test2");
-        try {
-            lc2.login();
-            throw new SecurityException("test 2 failed");
-        } catch (LoginException le) {
-            if (le.getCause() != null &&
-                le.getCause()  instanceof SecurityException) {
-                System.out.println("test succeeded");
-            } else {
-                throw le;
+            LoginContext lc2 = new LoginContext("test2");
+            try {
+                lc2.login();
+                throw new SecurityException("test 2 failed");
+            } catch (LoginException le) {
+                if (le.getCause() != null &&
+                    le.getCause()  instanceof SecurityException) {
+                    System.out.println("test succeeded");
+                } else {
+                    throw le;
+                }
             }
+        } finally {
+            Configuration.setConfiguration(previousConf);
+            Thread.currentThread().setContextClassLoader(previousCL);
         }
     }
 }
--- jdk/test/javax/swing/AncestorNotifier/7193219/bug7193219.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/AncestorNotifier/7193219/bug7193219.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+   @bug 7193219
+   @summary JComboBox serialization fails in JDK 1.7
+   @author Anton Litvinov
+*/
+
+import java.io.*;
+
+import javax.swing.*;
+import javax.swing.plaf.metal.*;
+
+public class bug7193219 {
+    private static byte[] serializeGUI() {
+        // Create and set up the window.
+        JFrame frame = new JFrame("Serialization");
+        JPanel mainPanel = new JPanel();
+
+        /**
+         * If JComboBox is replaced with other component like JLabel
+         * The issue does not happen.
+         */
+        JComboBox status = new JComboBox();
+        status.addItem("123");
+        mainPanel.add(status);
+        frame.getContentPane().add(mainPanel);
+        frame.pack();
+
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            ObjectOutputStream oos = new ObjectOutputStream(baos);
+            oos.writeObject(mainPanel);
+            oos.flush();
+            frame.dispose();
+            return baos.toByteArray();
+        } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+        }
+    }
+
+    private static void deserializeGUI(byte[] serializedData) {
+        try {
+            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData));
+            JPanel mainPanel = (JPanel)ois.readObject();
+            JFrame frame = new JFrame("Deserialization");
+            frame.getContentPane().add(mainPanel);
+            frame.pack();
+            frame.dispose();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void main(String[] args) throws Exception {
+        UIManager.setLookAndFeel(new MetalLookAndFeel());
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                deserializeGUI(serializeGUI());
+            }
+        });
+    }
+}
--- jdk/test/javax/swing/JColorChooser/Test6827032.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/JColorChooser/Test6827032.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 6827032
+ * @summary Color chooser with drag enabled shouldn't throw NPE
+ * @author Peter Zhelezniakov
+ * @library ../regtesthelpers
+ */
+
+import sun.awt.SunToolkit;
+
+import java.awt.*;
+import java.awt.event.*;
+
+import javax.swing.*;
+import javax.swing.plaf.nimbus.NimbusLookAndFeel;
+
+
+public class Test6827032 {
+
+    private static volatile Point point;
+    private static JColorChooser cc;
+
+    public static void main(String[] args) throws Exception {
+        UIManager.setLookAndFeel(new NimbusLookAndFeel());
+
+        Robot robot = new Robot();
+        robot.setAutoDelay(50);
+
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        toolkit.realSync();
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                Component previewPanel = Util.findSubComponent(cc, "javax.swing.colorchooser.DefaultPreviewPanel");
+                point = previewPanel.getLocationOnScreen();
+            }
+        });
+
+        point.translate(5, 5);
+
+        robot.mouseMove(point.x, point.y);
+        robot.mousePress(InputEvent.BUTTON1_MASK);
+        robot.mouseRelease(InputEvent.BUTTON1_MASK);
+    }
+
+
+    private static void createAndShowGUI() {
+        JFrame frame = new JFrame(Test6827032.class.getName());
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        cc = new JColorChooser();
+        cc.setDragEnabled(true);
+        frame.add(cc);
+        frame.pack();
+        frame.setVisible(true);
+    }
+}
--- jdk/test/javax/swing/JComboBox/ShowPopupAfterHidePopupTest/ShowPopupAfterHidePopupTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/JComboBox/ShowPopupAfterHidePopupTest/ShowPopupAfterHidePopupTest.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+   @bug 8006417
+   @summary JComboBox.showPopup(), hidePopup() fails in JRE 1.7 on OS X
+   @author Anton Litvinov
+*/
+
+import java.awt.*;
+
+import javax.swing.*;
+import javax.swing.plaf.metal.*;
+
+import sun.awt.SunToolkit;
+
+public class ShowPopupAfterHidePopupTest {
+    private static JFrame frame = null;
+    private static JComboBox comboBox = null;
+    private static boolean popupIsVisible = false;
+
+    public static void main(String[] args) throws Exception {
+        UIManager.setLookAndFeel(new MetalLookAndFeel());
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                frame = new JFrame("Popup Menu of JComboBox");
+                comboBox = new JComboBox(new String[]{"Item1", "Item2", "Item3"});
+                frame.getContentPane().add(comboBox);
+                frame.pack();
+                frame.setVisible(true);
+            }
+        });
+        final SunToolkit toolkit = (SunToolkit)Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                comboBox.showPopup();
+                comboBox.hidePopup();
+                comboBox.showPopup();
+            }
+        });
+        toolkit.realSync();
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                popupIsVisible = comboBox.isPopupVisible();
+                frame.dispose();
+            }
+        });
+        if (!popupIsVisible) {
+            throw new RuntimeException("Calling hidePopup() affected the next call to showPopup().");
+        }
+    }
+}
--- jdk/test/javax/swing/JComponent/7154030/bug7154030.java	2012-08-10 10:36:00.000000000 -0700
+++ jdk/test/javax/swing/JComponent/7154030/bug7154030.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,169 +0,0 @@
-/*
- * Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Portions Copyright (c) 2012 IBM Corporation
- */
-
-import javax.swing.JButton;
-import javax.swing.JDesktopPane;
-import javax.swing.JFrame;
-import javax.swing.SwingUtilities;
-import sun.awt.SunToolkit;
-
-import java.awt.AWTException;
-import java.awt.AlphaComposite;
-import java.awt.Color;
-import java.awt.Graphics;
-import java.awt.Graphics2D;
-import java.awt.Rectangle;
-import java.awt.Robot;
-import java.awt.Toolkit;
-import java.awt.image.BufferedImage;
-
-/* @test 1.1 2012/04/12
- * @bug 7154030
- * @summary Swing components fail to hide after calling hide()
- * @author Jonathan Lu
- * @library ../../regtesthelpers/
- * @build Util
- * @run main bug7154030
- */
-
-public class bug7154030 {
-
-    private static JButton button = null;
-
-    public static void main(String[] args) throws Exception {
-        BufferedImage imageInit = null;
-
-        BufferedImage imageShow = null;
-
-        BufferedImage imageHide = null;
-
-        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
-
-        Robot robot = new Robot();
-
-        SwingUtilities.invokeAndWait(new Runnable() {
-
-            @Override
-            public void run() {
-                JDesktopPane desktop = new JDesktopPane();
-                button = new JButton("button");
-                JFrame frame = new JFrame();
-
-                button.setSize(200, 200);
-                button.setLocation(100, 100);
-                button.setForeground(Color.RED);
-                button.setBackground(Color.RED);
-                button.setOpaque(true);
-                button.setVisible(false);
-                desktop.add(button);
-
-                frame.setContentPane(desktop);
-                frame.setSize(300, 300);
-                frame.setLocation(0, 0);
-                frame.setVisible(true);
-                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
-            }
-        });
-
-        toolkit.realSync();
-        imageInit = robot.createScreenCapture(new Rectangle(0, 0, 300, 300));
-
-        SwingUtilities.invokeAndWait(new Runnable() {
-
-            @Override
-            public void run() {
-                button.show();
-            }
-        });
-
-        toolkit.realSync();
-        imageShow = robot.createScreenCapture(new Rectangle(0, 0, 300, 300));
-        if (Util.compareBufferedImages(imageInit, imageShow)) {
-            throw new Exception("Failed to show opaque button");
-        }
-
-        toolkit.realSync();
-
-        SwingUtilities.invokeAndWait(new Runnable() {
-
-            @Override
-            public void run() {
-                button.hide();
-            }
-        });
-
-        toolkit.realSync();
-        imageHide = robot.createScreenCapture(new Rectangle(0, 0, 300, 300));
-
-        if (!Util.compareBufferedImages(imageInit, imageHide)) {
-            throw new Exception("Failed to hide opaque button");
-        }
-
-        SwingUtilities.invokeAndWait(new Runnable() {
-
-            @Override
-            public void run() {
-                button.setOpaque(false);
-                button.setBackground(new Color(128, 128, 0));
-                button.setVisible(false);
-            }
-        });
-
-        toolkit.realSync();
-        imageInit = robot.createScreenCapture(new Rectangle(0, 0, 300, 300));
-
-        SwingUtilities.invokeAndWait(new Runnable() {
-
-            @Override
-            public void run() {
-                button.show();
-            }
-        });
-
-        toolkit.realSync();
-        imageShow = robot.createScreenCapture(new Rectangle(0, 0, 300, 300));
-
-        SwingUtilities.invokeAndWait(new Runnable() {
-
-            @Override
-            public void run() {
-                button.hide();
-            }
-        });
-
-        if (Util.compareBufferedImages(imageInit, imageShow)) {
-            throw new Exception("Failed to show non-opaque button");
-        }
-
-        toolkit.realSync();
-        imageHide = robot.createScreenCapture(new Rectangle(0, 0, 300, 300));
-
-        if (!Util.compareBufferedImages(imageInit, imageHide)) {
-            throw new Exception("Failed to hide non-opaque button");
-        }
-    }
-}
--- jdk/test/javax/swing/JFrame/4962534/bug4962534.html	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/JFrame/4962534/bug4962534.html	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,43 @@
+<html>
+<!--
+  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+  This code is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License version 2 only, as
+  published by the Free Software Foundation.
+
+  This code is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  version 2 for more details (a copy is included in the LICENSE file that
+  accompanied this code).
+
+  You should have received a copy of the GNU General Public License version
+  2 along with this work; if not, write to the Free Software Foundation,
+  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+  or visit www.oracle.com if you need additional information or have any
+  questions.
+ -->
+
+<!--
+  @test
+  @bug 4962534
+  @summary JFrame dances very badly
+  @author dav@sparc.spb.su area=
+  @run applet bug4962534.html
+  -->
+<head>
+<title>  </title>
+</head>
+<body>
+
+<h1>bug4962534<br>Bug ID: 4962534 </h1>
+
+<p> This is an AUTOMATIC test, simply wait for completion </p>
+
+<APPLET CODE="bug4962534.class" WIDTH=200 HEIGHT=200></APPLET>
+</body>
+</html>
--- jdk/test/javax/swing/JFrame/4962534/bug4962534.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/JFrame/4962534/bug4962534.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ test
+ @bug 4962534 7104594
+ @summary JFrame dances very badly
+ @author dav@sparc.spb.su area=
+ @run applet bug4962534.html
+ */
+import java.applet.Applet;
+import java.awt.*;
+import java.awt.event.*;
+import java.util.Random;
+import javax.swing.*;
+import sun.awt.SunToolkit;
+
+public class bug4962534 extends Applet {
+
+    Robot robot;
+    volatile Point framePosition;
+    volatile Point newFrameLocation;
+    JFrame frame;
+    Rectangle gcBounds;
+    Component titleComponent;
+    JLayeredPane lPane;
+    volatile boolean titleFound = false;
+    SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+    public static Object LOCK = new Object();
+
+    @Override
+    public void init() {
+        try {
+            SwingUtilities.invokeAndWait(new Runnable() {
+                @Override
+                public void run() {
+                    createAndShowGUI();
+                }
+            });
+        } catch (Exception ex) {
+            throw new RuntimeException("Init failed. " + ex.getMessage());
+        }
+    }//End  init()
+
+    @Override
+    public void start() {
+        validate();
+
+        try {
+            setJLayeredPaneEDT();
+            setTitleComponentEDT();
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException("Test failed. " + ex.getMessage());
+        }
+
+        if (!titleFound) {
+            throw new RuntimeException("Test Failed. Unable to determine title's size.");
+        }
+
+        Random r = new Random();
+
+        for (int iteration = 0; iteration < 10; iteration++) {
+            try {
+                setFramePosEDT();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                throw new RuntimeException("Test failed.");
+            }
+            try {
+                robot = new Robot();
+                robot.setAutoDelay(70);
+
+                toolkit.realSync();
+
+                robot.mouseMove(framePosition.x + getJFrameWidthEDT() / 2,
+                        framePosition.y + titleComponent.getHeight() / 2);
+                robot.mousePress(InputEvent.BUTTON1_MASK);
+
+                toolkit.realSync();
+
+                gcBounds =
+                        GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()[0].getConfigurations()[0].getBounds();
+
+                robot.mouseMove(framePosition.x + getJFrameWidthEDT() / 2,
+                        framePosition.y + titleComponent.getHeight() / 2);
+
+                toolkit.realSync();
+
+                int multier = gcBounds.height / 2 - 10; //we will not go out the borders
+                for (int i = 0; i < 10; i++) {
+                    robot.mouseMove(gcBounds.width / 2 - (int) (r.nextDouble() * multier), gcBounds.height / 2 - (int) (r.nextDouble() * multier));
+                }
+                robot.mouseRelease(InputEvent.BUTTON1_MASK);
+
+                toolkit.realSync();
+
+            } catch (AWTException e) {
+                throw new RuntimeException("Test Failed. AWTException thrown." + e.getMessage());
+            } catch (Exception e) {
+                e.printStackTrace();
+                throw new RuntimeException("Test Failed.");
+            }
+            System.out.println("Mouse  lies in " + MouseInfo.getPointerInfo().getLocation());
+            boolean frameIsOutOfScreen = false;
+            try {
+                setNewFrameLocationEDT();
+                System.out.println("Now Frame lies in " + newFrameLocation);
+                frameIsOutOfScreen = checkFrameIsOutOfScreenEDT();
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                throw new RuntimeException("Test Failed.");
+            }
+
+            if (frameIsOutOfScreen) {
+                throw new RuntimeException("Test failed. JFrame is out of screen.");
+            }
+
+        } //for iteration
+        System.out.println("Test passed.");
+    }// start()
+
+    private void createAndShowGUI() {
+        try {
+            UIManager.setLookAndFeel(
+                    "javax.swing.plaf.metal.MetalLookAndFeel");
+        } catch (Exception ex) {
+            throw new RuntimeException(ex.getMessage());
+        }
+        JFrame.setDefaultLookAndFeelDecorated(true);
+        frame = new JFrame("JFrame Dance Test");
+        frame.pack();
+        frame.setSize(450, 260);
+        frame.setVisible(true);
+    }
+
+    private void setJLayeredPaneEDT() throws Exception {
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                lPane = frame.getLayeredPane();
+                System.out.println("JFrame's LayeredPane " + lPane);
+            }
+        });
+    }
+
+    private void setTitleComponentEDT() throws Exception {
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                for (int j = 0; j < lPane.getComponentsInLayer(JLayeredPane.FRAME_CONTENT_LAYER.intValue()).length; j++) {
+                    titleComponent = lPane.getComponentsInLayer(JLayeredPane.FRAME_CONTENT_LAYER.intValue())[j];
+                    if (titleComponent.getClass().getName().equals("javax.swing.plaf.metal.MetalTitlePane")) {
+                        titleFound = true;
+                        break;
+                    }
+                }
+            }
+        });
+    }
+
+    private void setFramePosEDT() throws Exception {
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                framePosition = frame.getLocationOnScreen();
+            }
+        });
+    }
+
+    private boolean checkFrameIsOutOfScreenEDT() throws Exception {
+
+        final boolean[] result = new boolean[1];
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                if (newFrameLocation.x > gcBounds.width || newFrameLocation.x < 0
+                    || newFrameLocation.y > gcBounds.height || newFrameLocation.y
+                    < 0) {
+                result[0] = true;
+            }
+            }
+        });
+        return result[0];
+    }
+
+    private void setNewFrameLocationEDT() throws Exception {
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                newFrameLocation = new Point(frame.getLocationOnScreen().x
+                        + frame.getWidth() / 2, frame.getLocationOnScreen().y + titleComponent.getHeight() / 2);
+            }
+        });
+    }
+
+    private int getJFrameWidthEDT() throws Exception {
+
+        final int[] result = new int[1];
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                result[0] = frame.getWidth();
+            }
+        });
+
+        return result[0];
+    }
+}// class
--- jdk/test/javax/swing/JMenuItem/ActionListenerCalledTwice/ActionListenerCalledTwiceTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/JMenuItem/ActionListenerCalledTwice/ActionListenerCalledTwiceTest.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7160951
+ * @summary [macosx] ActionListener called twice for JMenuItem using ScreenMenuBar
+ * @author vera.akulova@oracle.com
+ * @run main ActionListenerCalledTwiceTest
+ */
+
+import sun.awt.*;
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+
+public class ActionListenerCalledTwiceTest {
+    static volatile int listenerCallCounter = 0;
+    public static void main(String[] args) throws Exception {
+        if (sun.awt.OSInfo.getOSType() != sun.awt.OSInfo.OSType.MACOSX) {
+            System.out.println("This test is for MacOS only. Automatically passed on other platforms.");
+            return;
+        }
+        System.setProperty("apple.laf.useScreenMenuBar", "true");
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        Robot robot = new Robot();
+        robot.setAutoDelay(100);
+        robot.keyPress(KeyEvent.VK_META);
+        robot.keyPress(KeyEvent.VK_E);
+        robot.keyRelease(KeyEvent.VK_E);
+        robot.keyRelease(KeyEvent.VK_META);
+        toolkit.realSync();
+        if (listenerCallCounter != 1) {
+            throw new Exception("Test failed: ActionListener called " + listenerCallCounter + " times instead of 1!");
+        }
+    }
+
+    private static void createAndShowGUI() {
+        JMenuItem newItem = new JMenuItem("Exit");
+        newItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, InputEvent.META_MASK));
+        newItem.addActionListener(
+            new ActionListener(){
+                public void actionPerformed(ActionEvent e) {
+                    listenerCallCounter++;
+                }
+            }
+        );
+        JMenu menu = new JMenu("Menu");
+        menu.add(newItem);
+        JMenuBar bar = new JMenuBar();
+        bar.add(menu);
+        JFrame frame = new JFrame("Test");
+        frame.setJMenuBar(bar);
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.pack();
+        frame.setVisible(true);
+    }
+}
--- jdk/test/javax/swing/JMenuItem/ShortcutNotDiplayed/ShortcutNotDisplayedTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/JMenuItem/ShortcutNotDiplayed/ShortcutNotDisplayedTest.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7186371
+ * @summary [macosx] Main menu shortcuts not displayed
+ * @author vera.akulova@oracle.com
+ * @run main/manual ShortcutNotDisplayedTest
+ */
+
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+
+public class ShortcutNotDisplayedTest {
+    static volatile boolean done = false;
+    static volatile boolean pass = false;
+    static final String PASS_COMMAND = "pass";
+
+    public static void main(String[] args) throws Exception {
+        if (sun.awt.OSInfo.getOSType() != sun.awt.OSInfo.OSType.MACOSX) {
+            System.out.println("This test is for MacOS only. Automatically passed on other platforms.");
+            return;
+        }
+        System.setProperty("apple.laf.useScreenMenuBar", "true");
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        do { try { Thread.sleep(300); } catch (Exception e) {} } while (!done) ;
+        if (!pass) {
+            throw new Exception("Shortcuts not displayed as expected in the screen menu bar.");
+        }
+    }
+
+    private static void createAndShowGUI() {
+        JMenuItem newItem = new JMenuItem("Exit");
+        newItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, java.awt.event.InputEvent.META_MASK));
+
+        JMenu menu = new JMenu("Test Frame Window Menu");
+        menu.setMnemonic(KeyEvent.VK_M);
+        menu.add(newItem);
+
+        JMenuBar bar = new JMenuBar();
+        bar.add(menu);
+        JTextArea text = new JTextArea(
+            "  Please follow instructions:\n" +
+            "  1. You should see \"Test Frame Window Menu\" menu on the screen menu bar.\n" +
+            "  2. Open \"Test Frame Window Menu\" menu. \n" +
+            "     Check that menu item \"Exit\" has a shortcut with image for Command Key and symbol \"E\". \n" +
+            "     If you see the shortcut press \"Passed\". Otherwise press \"Failed\".\n"
+        );
+        text.setEditable(false);
+
+        JScrollPane sp = new JScrollPane(text);
+        sp.setSize(300,200);
+
+        JButton passBtn = new JButton("Pass");
+        passBtn.setActionCommand(PASS_COMMAND);
+        JButton failBtn = new JButton("Fail");
+        ActionListener listener = new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                if (e.getActionCommand().equals(PASS_COMMAND)) {
+                    pass = true;
+                }
+                done = true;
+            }
+        };
+
+        JFrame testFrame = new JFrame("Test Frame Window");
+        testFrame.setLayout(new FlowLayout());
+        testFrame.setBounds(100, 100, 600, 180);
+        testFrame.setJMenuBar(bar);
+        testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        passBtn.addActionListener(listener);
+        failBtn.addActionListener(listener);
+        testFrame.getContentPane().add(sp);
+        testFrame.getContentPane().add(passBtn);
+        testFrame.getContentPane().add(failBtn);
+        testFrame.setVisible(true);
+    }
+}
--- jdk/test/javax/swing/JSlider/4252173/bug4252173.java	2012-08-10 10:36:08.000000000 -0700
+++ jdk/test/javax/swing/JSlider/4252173/bug4252173.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,11 +22,11 @@
  */
 
 /* @test
-   @bug 4252173
-   @summary Inability to reuse the HorizontalSliderThumbIcon
-   @author Pavel Porvatov
-   @run main bug4252173
-*/
+ * @bug 4252173 7077259
+ * @summary Inability to reuse the HorizontalSliderThumbIcon
+ * @author Pavel Porvatov
+ * @run main/othervm -Dswing.defaultlaf=javax.swing.plaf.metal.MetalLookAndFeel bug4252173
+ */
 
 import javax.swing.*;
 import javax.swing.plaf.metal.DefaultMetalTheme;
--- jdk/test/javax/swing/JSpinner/6532833/bug6532833.java	2012-08-10 10:36:10.000000000 -0700
+++ jdk/test/javax/swing/JSpinner/6532833/bug6532833.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,10 +22,11 @@
  */
 
 /* @test
-   @bug 6532833
-   @summary PIT: Metal LAF - The right side border is not shown for the Spinner after the removing the buttons
-   @author Pavel Porvatov
-*/
+ * @bug 6532833 7077259
+ * @summary PIT: Metal LAF - The right side border is not shown for the Spinner after the removing the buttons
+ * @author Pavel Porvatov
+ * @run main/othervm -Dswing.defaultlaf=javax.swing.plaf.metal.MetalLookAndFeel bug6532833
+ */
 
 import javax.swing.*;
 import java.awt.*;
--- jdk/test/javax/swing/plaf/metal/MetalSliderUI/Test6657026.java	2012-08-10 10:36:14.000000000 -0700
+++ jdk/test/javax/swing/plaf/metal/MetalSliderUI/Test6657026.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,22 +23,21 @@
 
 /*
  * @test
- * @bug 6657026
+ * @bug 6657026 7077259
  * @summary Tests shared MetalSliderUI in different application contexts
  * @author Sergey Malenkov
+ * @run main/othervm -Dswing.defaultlaf=javax.swing.plaf.metal.MetalLookAndFeel Test6657026
  */
 
-import sun.awt.SunToolkit;
-
 import javax.swing.JSlider;
 import javax.swing.UIManager;
 import javax.swing.plaf.metal.MetalLookAndFeel;
 import javax.swing.plaf.metal.MetalSliderUI;
+import sun.awt.SunToolkit;
 
 public class Test6657026 extends MetalSliderUI implements Runnable {
 
     public static void main(String[] args) throws Exception {
-        UIManager.setLookAndFeel(new MetalLookAndFeel());
         JSlider slider = new JSlider();
         test(slider);
 
--- jdk/test/javax/swing/text/DefaultCaret/6938583/bug6938583.java	2012-08-10 10:36:15.000000000 -0700
+++ jdk/test/javax/swing/text/DefaultCaret/6938583/bug6938583.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2011 Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * Portions Copyright (c) 2011 IBM Corporation
- */
-
-/*
- * @test
- * @bug 6938583
- * @summary Unexpected NullPointerException when use CodeIM demo on windows
- * @author LittleE
- */
-
-import javax.swing.*;
-import javax.swing.text.DefaultCaret;
-import java.awt.event.MouseEvent;
-
-public class bug6938583 {
-    public static void main(String[] args) throws Exception {
-        SwingUtilities.invokeAndWait(new Runnable() {
-            public void run() {
-                JTextArea jta = new JTextArea();
-                DefaultCaret dc = new DefaultCaret();
-                jta.setCaret(dc);
-                dc.deinstall(jta);
-                dc.mouseClicked(new MouseEvent(jta, MouseEvent.MOUSE_CLICKED, 0, 0, 0, 0, 0, false));
-            }
-        });
-    }
-}
--- jdk/test/javax/swing/text/StyledEditorKit/4506788/bug4506788.html	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/text/StyledEditorKit/4506788/bug4506788.html	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,28 @@
+<!--
+ Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+ This code is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License version 2 only, as
+ published by the Free Software Foundation.
+
+ This code is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ version 2 for more details (a copy is included in the LICENSE file that
+ accompanied this code).
+
+ You should have received a copy of the GNU General Public License version
+ 2 along with this work; if not, write to the Free Software Foundation,
+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ or visit www.oracle.com if you need additional information or have any
+ questions.
+-->
+
+<Html>
+<Body>
+<APPLET  code="bug4506788.class" WIDTH = 600 HEIGHT = 400></APPLET>
+</Body>
+</Html>
--- jdk/test/javax/swing/text/StyledEditorKit/4506788/bug4506788.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/javax/swing/text/StyledEditorKit/4506788/bug4506788.java	2013-05-05 09:38:48.000000000 -0700
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ @bug 4506788 7147408
+ @summary  Tests if cursor gets stuck after insertion a character
+ @author Denis Sharypov
+ @run applet bug4506788.html
+ */
+import java.awt.*;
+import java.awt.event.*;
+import java.lang.reflect.InvocationTargetException;
+import javax.swing.*;
+import javax.swing.event.*;
+import javax.swing.text.*;
+import sun.awt.SunToolkit;
+
+public class bug4506788 extends JApplet {
+
+    private volatile boolean passed = false;
+    private JEditorPane jep;
+    private SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+
+    @Override
+    public void init() {
+        try {
+            SwingUtilities.invokeAndWait(new Runnable() {
+                @Override
+                public void run() {
+                    createAndShowGUI();
+                }
+            });
+        } catch (InterruptedException | InvocationTargetException ex) {
+            ex.printStackTrace();
+            throw new RuntimeException("FAILED: SwingUtilities.invokeAndWait method failed then creating and showing GUI");
+        }
+    }
+
+    @Override
+    public void start() {
+        Robot robot;
+        try {
+            robot = new Robot();
+        } catch (AWTException e) {
+            throw new RuntimeException("Robot could not be created");
+        }
+
+        toolkit.realSync();
+
+        Point p;
+        try {
+            p = getJEPLocOnScreen();
+        } catch (Exception e) {
+            throw new RuntimeException("Could not get JEditorPane location on screen");
+        }
+
+        robot.setAutoDelay(50);
+        robot.mouseMove(p.x, p.y);
+        robot.mousePress(InputEvent.BUTTON1_MASK);
+        robot.mouseRelease(InputEvent.BUTTON1_MASK);
+        robot.keyPress(KeyEvent.VK_RIGHT);
+        robot.keyRelease(KeyEvent.VK_RIGHT);
+        robot.keyPress(KeyEvent.VK_X);
+        robot.keyRelease(KeyEvent.VK_X);
+        robot.keyPress(KeyEvent.VK_RIGHT);
+        robot.keyRelease(KeyEvent.VK_RIGHT);
+
+        toolkit.realSync();
+
+        if (!passed) {
+            throw new RuntimeException("Test failed.");
+        }
+    }
+
+    private Point getJEPLocOnScreen() throws Exception {
+
+        final Point[] result = new Point[1];
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                result[0] = jep.getLocationOnScreen();
+            }
+        });
+
+        return result[0];
+    }
+
+    private void createAndShowGUI() {
+        jep = new JEditorPane();
+        String text = "abc";
+        JFrame f = new JFrame();
+        jep.setEditorKit(new StyledEditorKit());
+        jep.setText(text);
+        jep.addCaretListener(new CaretListener() {
+            @Override
+            public void caretUpdate(CaretEvent e) {
+                passed = (e.getDot() == 3);
+            }
+        });
+
+        DefaultStyledDocument doc = (DefaultStyledDocument) jep.getDocument();
+        MutableAttributeSet atr = new SimpleAttributeSet();
+        StyleConstants.setBold(atr, true);
+        doc.setCharacterAttributes(1, 1, atr, false);
+
+        f.getContentPane().add(jep);
+        f.setSize(100, 100);
+        f.setVisible(true);
+    }
+}
--- jdk/test/javax/xml/crypto/dsig/SecurityManager/XMLDSigWithSecMgr.java	2012-08-10 10:36:16.000000000 -0700
+++ jdk/test/javax/xml/crypto/dsig/SecurityManager/XMLDSigWithSecMgr.java	2013-05-05 09:38:48.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,7 @@
  * @bug 6436919 6460930
  * @summary check that XML Signatures can be generated and validated with
  *  SecurityManager enabled and default policy
+ * @run main/othervm XMLDSigWithSecMgr
  * @author Sean Mullan
  */
 import java.io.*;
--- jdk/test/jprt.config	2012-08-10 10:36:17.000000000 -0700
+++ jdk/test/jprt.config	2013-05-05 09:38:49.000000000 -0700
@@ -71,8 +71,8 @@
 
 # Uses 'uname -s', but only expect SunOS or Linux, assume Windows otherwise.
 osname=`uname -s`
-if [ "${osname}" = SunOS ] ; then
-   
+case "${osname}" in
+  SunOS )
     # SOLARIS: Sparc or X86
     osarch=`uname -p`
     if [ "${osarch}" = sparc ] ; then
@@ -96,9 +96,9 @@
 
     # File creation mask
     umask 002
+    ;;
 
-elif [ "${osname}" = Linux ] ; then
-   
+  Linux | Darwin )
     # Add basic paths
     path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
@@ -107,8 +107,31 @@
     fileMustExist "${make}" make
 
     umask 002
+    ;;
+
+  FreeBSD | OpenBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
-else
+    # Find GNU make
+    make=/usr/local/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
+
+  NetBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
+
+    # Find GNU make
+    make=/usr/pkg/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
+
+  * )
 
     # Windows: Differs on CYGWIN vs. MKS.
    
@@ -150,8 +173,8 @@
     if [ "${unix_toolset}" = CYGWIN ] ; then
 	path4sdk="`/usr/bin/cygpath -p ${path4sdk}`"
     fi
-
-fi
+    ;;
+esac
 
 # Export PATH setting
 PATH="${path4sdk}"
--- jdk/test/lib/security/java.policy/Ext_AllPolicy.sh	2012-08-10 10:36:17.000000000 -0700
+++ jdk/test/lib/security/java.policy/Ext_AllPolicy.sh	2013-05-05 09:38:49.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2004, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4215035
+# @bug 4215035 7083664
 # @summary standard extensions path is hard-coded in default system policy file
 #
 # @build Ext_AllPolicy
@@ -50,23 +50,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
-    TMP=/tmp
     ;;
   Windows_95 | Windows_98 | Windows_NT )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/java2d/OpenGL/CustomCompositeTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/sun/java2d/OpenGL/CustomCompositeTest.java	2013-05-05 09:38:45.000000000 -0700
@@ -0,0 +1,266 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug     7124347
+ * @summary Verifies that rendering with XOR composite, and arbitraty
+ *          custom composite doesn not cause internal errors.
+ *
+ * @run     main/othervm -Dsun.java2d.opengl=True CustomCompositeTest
+ */
+
+import java.awt.AWTException;
+import java.awt.Color;
+import java.awt.Composite;
+import java.awt.CompositeContext;
+import java.awt.Dimension;
+import java.awt.GradientPaint;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
+import java.awt.ImageCapabilities;
+import java.awt.RenderingHints;
+import java.awt.image.BufferedImage;
+import java.awt.image.ColorModel;
+import java.awt.image.DataBufferInt;
+import java.awt.image.Raster;
+import java.awt.image.SinglePixelPackedSampleModel;
+import java.awt.image.VolatileImage;
+import java.awt.image.WritableRaster;
+import java.util.concurrent.CountDownLatch;
+import javax.swing.JComponent;
+import javax.swing.JFrame;
+import javax.swing.SwingUtilities;
+
+public class CustomCompositeTest {
+
+    private static JFrame frame;
+    private static CountDownLatch paintLatch;
+    private static Throwable paintError;
+
+    public static void main(String[] args) {
+
+        paintLatch = new CountDownLatch(1);
+        paintError = null;
+
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                initGUI();
+            }
+        });
+
+        try {
+            paintLatch.await();
+        } catch (InterruptedException e) {
+        };
+        System.out.println("Paint is done!");
+        if (paintError != null) {
+            frame.dispose();
+            throw new RuntimeException("Test FAILED.", paintError);
+        }
+
+        System.out.println("Phase 1: PASSED.");
+
+        // now resise the frame in order to cause re-paint with accelerated
+        // source images.
+        paintError = null;
+        paintLatch = new CountDownLatch(1);
+
+        SwingUtilities.invokeLater(new Runnable() {
+            @Override
+            public void run() {
+                Dimension size = frame.getSize();
+                size.width += 50;
+                size.height += 50;
+
+                frame.setSize(size);
+            }
+        });
+
+        try {
+            paintLatch.await();
+        } catch (InterruptedException e) {
+        };
+        if (paintError != null) {
+            frame.dispose();
+            throw new RuntimeException("Resize test FAILED.", paintError);
+        }
+        frame.dispose();
+        System.out.println("Phase 2: PASSED.");
+
+        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
+        GraphicsConfiguration cfg = env.getDefaultScreenDevice().getDefaultConfiguration();
+        // test rendering to accelerated volatile image
+        testVolatileImage(cfg, true);
+        System.out.println("Phase 3: PASSED.");
+
+        // test rendering to unaccelerated volatile image
+        testVolatileImage(cfg, false);
+        System.out.println("Phase 4: PASSED.");
+    }
+
+    private static void testVolatileImage(GraphicsConfiguration cfg,
+            boolean accelerated)
+    {
+        VolatileImage dst = null;
+        try {
+            dst = cfg.createCompatibleVolatileImage(640, 480,
+                new ImageCapabilities(accelerated));
+        } catch (AWTException e) {
+            System.out.println("Unable to create volatile image, skip the test.");
+            return;
+        }
+        renderToVolatileImage(dst);
+    }
+
+    private static void renderToVolatileImage(VolatileImage dst) {
+        Graphics2D g = dst.createGraphics();
+        do {
+            System.out.println("Render to volatile image..");
+            try {
+                MyComp.renderTest(g, dst.getHeight(), dst.getHeight());
+            } catch (Throwable e) {
+                throw new RuntimeException("Test FAILED.", e);
+            }
+        } while (dst.contentsLost());
+        System.out.println("Done.");
+    }
+
+    private static void initGUI() {
+        frame = new JFrame("Silly composite");
+        frame.getContentPane().add(new MyComp());
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.pack();
+        frame.setVisible(true);
+    }
+
+    private static class MyComp extends JComponent {
+
+        private static BufferedImage theImage;
+
+        public MyComp() {
+        }
+
+        private static BufferedImage getTestImage() {
+            if (theImage == null) {
+                theImage = new BufferedImage(256, 256, BufferedImage.TYPE_INT_ARGB);
+                Graphics2D g2d = theImage.createGraphics();
+                g2d.setColor(Color.red);
+                g2d.fillRect(0, 0, 256, 256);
+
+                g2d.setPaint(new GradientPaint(0, 0, Color.red, 256, 256, Color.blue));
+                g2d.fillRect(0, 100, 256, 256);
+                g2d.dispose();
+            }
+            return theImage;
+        }
+
+        public Dimension getPreferredSize() {
+            return new Dimension(640, 375);
+        }
+
+        public void paintComponent(Graphics g) {
+
+
+            Graphics2D g2d = (Graphics2D) g;
+            try {
+                renderTest(g2d, getWidth(), getHeight());
+            } catch (Throwable e) {
+                paintError = e;
+            }
+            if (paintLatch != null) {
+                paintLatch.countDown();
+            }
+        }
+
+        public static void renderTest(Graphics2D g2d, int w, int h) {
+            g2d.setColor(Color.yellow);
+            g2d.fillRect(0, 0, w, h);
+
+            BufferedImage image = getTestImage();
+            // draw original image
+            g2d.drawRenderedImage(image, null);
+
+            // draw image with custom composite
+            g2d.translate(175, 25);
+            Composite currentComposite = g2d.getComposite();
+            g2d.setComposite(new TestComposite());
+            g2d.drawRenderedImage(image, null);
+            g2d.setComposite(currentComposite);
+
+            // draw image with XOR
+            g2d.translate(175, 25);
+            g2d.setXORMode(Color.red);
+            g2d.drawRenderedImage(image, null);
+
+
+            System.out.println("Painting is done...");
+        }
+    }
+
+    // A silly custom Composite to demonstrate the problem - just inverts the RGB
+    private static class TestComposite implements Composite {
+
+        public CompositeContext createContext(ColorModel srcColorModel, ColorModel dstColorModel, RenderingHints hints) {
+            return new TestCompositeContext();
+        }
+    }
+
+    private static class TestCompositeContext implements CompositeContext {
+
+        public void dispose() {
+        }
+
+        public void compose(Raster src, Raster dstIn, WritableRaster dstOut) {
+            int w = src.getWidth();
+            int h = src.getHeight();
+
+            DataBufferInt srcDB = (DataBufferInt) src.getDataBuffer();
+            DataBufferInt dstOutDB = (DataBufferInt) dstOut.getDataBuffer();
+            int srcRGB[] = srcDB.getBankData()[0];
+            int dstOutRGB[] = dstOutDB.getBankData()[0];
+            int srcOffset = srcDB.getOffset();
+            int dstOutOffset = dstOutDB.getOffset();
+            int srcScanStride = ((SinglePixelPackedSampleModel) src.getSampleModel()).getScanlineStride();
+            int dstOutScanStride = ((SinglePixelPackedSampleModel) dstOut.getSampleModel()).getScanlineStride();
+            int srcAdjust = srcScanStride - w;
+            int dstOutAdjust = dstOutScanStride - w;
+
+            int si = srcOffset;
+            int doi = dstOutOffset;
+
+            for (int i = 0; i < h; i++) {
+                for (int j = 0; j < w; j++) {
+                    dstOutRGB[doi] = srcRGB[si] ^ 0x00ffffff;
+                    si++;
+                    doi++;
+                }
+
+                si += srcAdjust;
+                doi += dstOutAdjust;
+            }
+        }
+    }
+}
--- jdk/test/sun/java2d/OpenGL/bug7181438.java	2012-08-10 10:36:19.000000000 -0700
+++ jdk/test/sun/java2d/OpenGL/bug7181438.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-import java.awt.Color;
-import java.awt.Graphics;
-import java.awt.GraphicsConfiguration;
-import java.awt.GraphicsEnvironment;
-import java.awt.Transparency;
-import java.awt.image.BufferedImage;
-import java.awt.image.VolatileImage;
-
-/**
- * @test
- * @bug 7181438
- * @summary Verifies that we get correct alpha, when we draw opaque
- * BufferedImage to non opaque VolatileImage via intermediate opaque texture.
- * @author Sergey Bylokhov
- * @run main/othervm -Dsun.java2d.accthreshold=0 bug7181438
- */
-public final class bug7181438 {
-
-    private static final int SIZE = 500;
-
-    public static void main(final String[] args) {
-
-        final BufferedImage bi = createBufferedImage();
-        final VolatileImage vi = createVolatileImage();
-        final Graphics s2dVi = vi.getGraphics();
-
-        //sw->texture->surface blit
-        s2dVi.drawImage(bi, 0, 0, null);
-
-        final BufferedImage results = vi.getSnapshot();
-        for (int i = 0; i < SIZE; ++i) {
-            for (int j = 0; j < SIZE; ++j) {
-                //Image should be opaque: (black color and alpha = 255)
-                if (results.getRGB(i, j) != 0xFF000000) {
-                    throw new RuntimeException("Failed: Wrong alpha");
-                }
-            }
-        }
-        System.out.println("Passed");
-    }
-
-
-    private static VolatileImage createVolatileImage() {
-        final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
-        final GraphicsConfiguration gc = ge.getDefaultScreenDevice().getDefaultConfiguration();
-        return gc.createCompatibleVolatileImage(SIZE, SIZE,
-                                                Transparency.TRANSLUCENT);
-    }
-
-    private static BufferedImage createBufferedImage() {
-        final BufferedImage bi = new BufferedImage(SIZE, SIZE,
-                                                   BufferedImage.TYPE_INT_RGB);
-        final Graphics bg = bi.getGraphics();
-        //Black color and alpha = 0
-        bg.setColor(new Color(0, 0, 0, 0));
-        bg.fillRect(0, 0, SIZE, SIZE);
-        bg.dispose();
-        return bi;
-    }
-}
--- jdk/test/sun/management/jmxremote/bootstrap/CustomLauncherTest.sh	2012-08-10 10:36:21.000000000 -0700
+++ jdk/test/sun/management/jmxremote/bootstrap/CustomLauncherTest.sh	2013-05-05 09:38:45.000000000 -0700
@@ -45,37 +45,53 @@
 # has to locate libjvm.so. Also $! is not reliable on some releases of MKS.
 #{
 OS=`uname -s`
-if [ "$OS" != "Linux" -a "$OS" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${OS}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 #
 # Locate the custom launcher for this platform
 #
 PLATFORM=unknown
 ARCH=unknown
-if [ "$OS" = "SunOS" ]; then
-    PLATFORM=solaris
-    case "`uname -p`" in
-	i[3-9]86)
-	    ARCH=i586
-	    ;;
-	sparc)
-	    ARCH=sparc
-	    ;;
-    esac
-else
-    PLATFORM=linux
-    case "`uname -m`" in
-	i[3-6]86)
-	    ARCH=i586
-	    ;;
-	x86_64)
-	    ARCH=amd64
-	    ;;
-    esac
-fi
+case "${OS}" in
+    SunOS )
+        PLATFORM=solaris
+        case "`uname -p`" in
+            i[3-9]86)
+                ARCH=i586
+                ;;
+            sparc)
+                ARCH=sparc
+                ;;
+        esac
+        ;;
+    Linux )
+        PLATFORM=linux
+        case "`uname -m`" in
+            i[3-6]86)
+                ARCH=i586
+                ;;
+            x86_64)
+                ARCH=amd64
+                ;;
+        esac
+	;;
+    *BSD | Darwin )
+        PLATFORM=bsd
+        case "`uname -m`" in
+            i[3-6]86)
+                ARCH=i586
+                ;;
+            x86_64)
+                ARCH=amd64
+                ;;
+        esac
+	;;
+esac
 
 
 #
--- jdk/test/sun/management/jmxremote/bootstrap/GeneratePropertyPassword.sh	2012-08-10 10:36:21.000000000 -0700
+++ jdk/test/sun/management/jmxremote/bootstrap/GeneratePropertyPassword.sh	2013-05-05 09:38:45.000000000 -0700
@@ -35,7 +35,7 @@
 UMASK=`umask`
 
 case $OS in
-SunOS | Linux | Darwin)
+SunOS | Linux | *BSD | Darwin)
     PATHSEP=":"
     FILESEP="/"
     DFILESEP=$FILESEP
--- jdk/test/sun/management/jmxremote/bootstrap/LocalManagementTest.sh	2012-08-10 10:36:21.000000000 -0700
+++ jdk/test/sun/management/jmxremote/bootstrap/LocalManagementTest.sh	2013-05-05 09:38:45.000000000 -0700
@@ -86,10 +86,12 @@
 #    on Windows 98.
 
 os=`uname -s`
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 JAVA=${TESTJAVA}/bin/java
 CLASSPATH=${TESTCLASSES}
--- jdk/test/sun/management/jmxremote/bootstrap/PasswordFilePermissionTest.sh	2012-08-10 10:36:21.000000000 -0700
+++ jdk/test/sun/management/jmxremote/bootstrap/PasswordFilePermissionTest.sh	2013-05-05 09:38:45.000000000 -0700
@@ -70,10 +70,12 @@
 # security the password file.
 
 os=`uname -s`
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 
 # Create configuration file and dummy password file
--- jdk/test/sun/management/jmxremote/bootstrap/SSLConfigFilePermissionTest.sh	2012-08-10 10:36:22.000000000 -0700
+++ jdk/test/sun/management/jmxremote/bootstrap/SSLConfigFilePermissionTest.sh	2013-05-05 09:38:45.000000000 -0700
@@ -69,10 +69,12 @@
 # security the password file.
 
 os=`uname -s`
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 # Create management and SSL configuration files
 
--- jdk/test/sun/misc/URLClassPath/ClassnameCharTest.sh	2012-08-10 10:36:24.000000000 -0700
+++ jdk/test/sun/misc/URLClassPath/ClassnameCharTest.sh	2013-05-05 09:38:45.000000000 -0700
@@ -36,7 +36,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/misc/Version/Version.java	2012-08-10 10:36:25.000000000 -0700
+++ jdk/test/sun/misc/Version/Version.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,11 +29,13 @@
  * @run main Version
  */
 
+import java.util.regex.*;
 import static sun.misc.Version.*;
+
 public class Version {
 
     public static void main(String[] args) throws Exception {
-        VersionInfo jdk = newVersionInfo(System.getProperty("java.runtime.version"));
+        VersionInfo jdk = jdkVersionInfo(System.getProperty("java.runtime.version"));
         VersionInfo v1 = new VersionInfo(jdkMajorVersion(),
                                          jdkMinorVersion(),
                                          jdkMicroVersion(),
@@ -44,7 +46,7 @@
         if (!jdk.equals(v1)) {
             throw new RuntimeException("Unmatched version: " + jdk + " vs " + v1);
         }
-        VersionInfo jvm = newVersionInfo(System.getProperty("java.vm.version"));
+        VersionInfo jvm = jvmVersionInfo(System.getProperty("java.vm.version"));
         VersionInfo v2 = new VersionInfo(jvmMajorVersion(),
                                          jvmMinorVersion(),
                                          jvmMicroVersion(),
@@ -95,68 +97,68 @@
         }
     }
 
-    private static VersionInfo newVersionInfo(String version) throws Exception {
+    private static VersionInfo jdkVersionInfo(String version) throws Exception {
         // valid format of the version string is:
-        // n.n.n[_uu[c]][-<identifer>]-bxx
+        // <major>.<minor>[.<micro>][_uu[c]][-<identifier>]-bxx
         int major = 0;
         int minor = 0;
         int micro = 0;
         int update = 0;
         String special = "";
         int build = 0;
-        CharSequence cs = version;
-        if (cs.length() >= 5) {
-            if (Character.isDigit(cs.charAt(0)) && cs.charAt(1) == '.' &&
-                Character.isDigit(cs.charAt(2)) && cs.charAt(3) == '.' &&
-                Character.isDigit(cs.charAt(4))) {
-                major = Character.digit(cs.charAt(0), 10);
-                minor = Character.digit(cs.charAt(2), 10);
-                micro = Character.digit(cs.charAt(4), 10);
-                cs = cs.subSequence(5, cs.length());
-            } else if (Character.isDigit(cs.charAt(0)) &&
-                       Character.isDigit(cs.charAt(1)) && cs.charAt(2) == '.' &&
-                       Character.isDigit(cs.charAt(3))) {
-                // HSX has nn.n (major.minor) version
-                major = Integer.valueOf(version.substring(0, 2)).intValue();
-                minor = Character.digit(cs.charAt(3), 10);
-                cs = cs.subSequence(4, cs.length());
-            }
-            if (cs.charAt(0) == '_' && cs.length() >= 3 &&
-                Character.isDigit(cs.charAt(1)) &&
-                Character.isDigit(cs.charAt(2))) {
-                int nextChar = 3;
-                String uu = cs.subSequence(1, 3).toString();
-                update = Integer.valueOf(uu).intValue();
-                if (cs.length() >= 4) {
-                    char c = cs.charAt(3);
-                    if (c >= 'a' && c <= 'z') {
-                        special = Character.toString(c);
-                        nextChar++;
-                    }
-                }
-                cs = cs.subSequence(nextChar, cs.length());
-            }
-            if (cs.charAt(0) == '-') {
-                // skip the first character
-                // valid format: <identifier>-bxx or bxx
-                // non-product VM will have -debug|-release appended
-                cs = cs.subSequence(1, cs.length());
-                String[] res = cs.toString().split("-");
-                for (int i = res.length - 1; i >= 0; i--) {
-                    String s = res[i];
-                    if (s.charAt(0) == 'b') {
-                        try {
-                            build = Integer.parseInt(s.substring(1, s.length()));
-                            break;
-                        } catch (NumberFormatException nfe) {
-                            // ignore
-                        }
-                    }
-                }
-            }
-        }
+
+        String regex = "^([0-9]{1,2})";     // major
+        regex += "\\.";                     // separator
+        regex += "([0-9]{1,2})";            // minor
+        regex += "(\\.";                    // separator
+        regex +=   "([0-9]{1,2})";          // micro
+        regex += ")?";                      // micro is optional
+        regex += "(_";
+        regex +=   "([0-9]{2})";            // update
+        regex +=   "([a-z])?";              // special char (optional)
+        regex += ")?";                      // _uu[c] is optional
+        regex += ".*";                      // -<identifier>
+        regex += "(\\-b([0-9]{1,3}$))";     // JDK -bxx
+
+        Pattern p = Pattern.compile(regex);
+        Matcher m = p.matcher(version);
+        m.matches();
+
+        major = Integer.parseInt(m.group(1));
+        minor = Integer.parseInt(m.group(2));
+        micro = (m.group(4) == null) ? 0 : Integer.parseInt(m.group(4));
+        update = (m.group(6) == null) ? 0 : Integer.parseInt(m.group(6));
+        special = (m.group(7) == null) ? "" : m.group(7);
+        build = Integer.parseInt(m.group(9));
+
         VersionInfo vi = new VersionInfo(major, minor, micro, update, special, build);
         System.out.printf("newVersionInfo: input=%s output=%s\n", version, vi);
         return vi;
     }
+
+    private static VersionInfo jvmVersionInfo(String version) throws Exception {
+        // valid format of the version string is:
+        // <major>.<minor>-bxx[-<identifier>][-<debug_flavor>]
+        int major = 0;
+        int minor = 0;
+        int build = 0;
+
+        String regex = "^([0-9]{1,2})";     // major
+        regex += "\\.";                     // separator
+        regex += "([0-9]{1,2})";            // minor
+        regex += "(\\-b([0-9]{1,3}))";      // JVM -bxx
+        regex += ".*";
+
+        Pattern p = Pattern.compile(regex);
+        Matcher m = p.matcher(version);
+        m.matches();
+
+        major = Integer.parseInt(m.group(1));
+        minor = Integer.parseInt(m.group(2));
+        build = Integer.parseInt(m.group(4));
+
+        VersionInfo vi = new VersionInfo(major, minor, 0, 0, "", build);
+        System.out.printf("newVersionInfo: input=%s output=%s\n", version, vi);
+        return vi;
+    }
 }
--- jdk/test/sun/net/www/MarkResetTest.sh	2012-08-10 10:36:27.000000000 -0700
+++ jdk/test/sun/net/www/MarkResetTest.sh	2013-05-05 09:38:45.000000000 -0700
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/net/www/http/HttpClient/RetryPost.sh	2012-08-10 10:36:28.000000000 -0700
+++ jdk/test/sun/net/www/http/HttpClient/RetryPost.sh	2013-05-05 09:38:45.000000000 -0700
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/net/www/messageheader/HTest.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/sun/net/www/messageheader/HTest.java	2013-05-05 09:38:45.000000000 -0700
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8003948
+ * @run main HTest
+ */
+import java.io.*;
+import sun.net.www.MessageHeader;
+
+public class HTest {
+    public static void main (String[] args) throws Exception {
+        String prefix = System.getProperty("test.src");
+        System.out.println ("TEST.SRC = " + prefix);
+        for (int i=0; i<7; i++) {
+            File f = new File(prefix, Integer.toString(i));
+            FileInputStream fis = new FileInputStream(f);
+            MessageHeader h = new MessageHeader(fis);
+            String before = h.toString();
+            before = before.substring(before.indexOf('{'));
+            System.out.println ("Before");
+            System.out.println (before);
+            boolean result = h.filterNTLMResponses("WWW-Authenticate");
+            String after = h.toString();
+            after = after.substring(after.indexOf('{'));
+            System.out.println ("After");
+            System.out.println (after);
+            System.out.println ("Expected");
+            System.out.println (expected[i]);
+            if (!expected[i].equals(after)) {
+                throw new RuntimeException(Integer.toString(i) + " expected != after");
+            }
+            if (result != expectedResult[i]) {
+                throw new RuntimeException(Integer.toString(i) + " result != expectedResult");
+            }
+        }
+    }
+
+    static String expected[] = {
+        "{null: HTTP/1.1 200 Ok}{Foo: bar}{Bar: foo}{WWW-Authenticate: NTLM sdsds}",
+        "{null: HTTP/1.1 200 Ok}{Foo: bar}{Bar: foo}{WWW-Authenticate: }",
+        "{null: HTTP/1.1 200 Ok}{Foo: bar}{Bar: foo}{WWW-Authenticate: NTLM sdsds}",
+        "{null: HTTP/1.1 200 Ok}{Foo: bar}{Bar: foo}{WWW-Authenticate: NTLM sdsds}",
+        "{null: HTTP/1.1 200 Ok}{Foo: bar}{Bar: foo}{WWW-Authenticate: NTLM sdsds}{Bar: foo}",
+        "{null: HTTP/1.1 200 Ok}{WWW-Authenticate: Negotiate}{Foo: bar}{Bar: foo}{WWW-Authenticate: NTLM}{Bar: foo}{WWW-Authenticate: Kerberos}",
+        "{null: HTTP/1.1 200 Ok}{Foo: foo}{Bar: }{WWW-Authenticate: NTLM blob}{Bar: foo blob}"
+    };
+
+    static boolean[] expectedResult = {
+        false, false, true, true, true, false, false
+    };
+}
--- jdk/test/sun/net/www/protocol/http/StackTraceTest.java	2012-08-10 10:36:29.000000000 -0700
+++ jdk/test/sun/net/www/protocol/http/StackTraceTest.java	2013-05-05 09:38:45.000000000 -0700
@@ -32,26 +32,28 @@
 import java.io.IOException;
 
 public class StackTraceTest {
-    public static void main(String[] args) {
+    public static void main(String[] args) throws Exception {
+        URL url;
+        try (ServerSocket ss = new ServerSocket(0)) {  // refusing socket
+            url = new URL("http://localhost:" + ss.getLocalPort() + "/");
+        }
+        URLConnection uc = url.openConnection();
+
+        // Trigger implicit connection by trying to retrieve bogus
+        // response header, and force remembered exception
+        uc.getHeaderFieldKey(20);
+
         try {
-            URL url = new URL("http://localhost:8080/");
-            URLConnection uc = url.openConnection();
-            System.out.println("key = "+uc.getHeaderFieldKey(20));
-            uc.getInputStream();
+            uc.getInputStream();  // expect to throw
+            throw new RuntimeException("Expected getInputStream to throw");
         } catch (IOException ioe) {
-            ioe.printStackTrace();
-
-            if (!(ioe instanceof ConnectException)) {
-                throw new RuntimeException("Expect ConnectException, got "+ioe);
-            }
-            if (ioe.getMessage() == null) {
+            if (!(ioe instanceof ConnectException))
+                throw new RuntimeException("Expect ConnectException, got " + ioe);
+            if (ioe.getMessage() == null)
                 throw new RuntimeException("Exception message is null");
-            }
-
-            // this exception should be a chained exception
-            if (ioe.getCause() == null) {
-                throw new RuntimeException("Excepting a chained exception, but got: ", ioe);
-            }
+            if (ioe.getCause() == null)
+                throw new RuntimeException("Excepting a chained exception, but got: ",
+                                           ioe);
         }
     }
 }
--- jdk/test/sun/net/www/protocol/jar/B4957695.java	2012-08-10 10:36:29.000000000 -0700
+++ jdk/test/sun/net/www/protocol/jar/B4957695.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,8 +24,6 @@
 /**
  * @test
  * @bug 4957695
- * @library ../../httptest/
- * @build HttpCallback HttpServer ClosedChannelList HttpTransaction AbstractCallback
  * @summary URLJarFile.retrieve does not delete tmpFile on IOException
  */
 
@@ -34,43 +32,73 @@
 
 public class B4957695 {
 
-    static int count = 0;
-    static boolean error = false;
+    static Server server;
 
-    static void read (InputStream is) throws IOException {
-        int c,len=0;
-        while ((c=is.read()) != -1) {
-            len += c;
+    static class Server extends Thread {
+        final ServerSocket srv;
+        static final byte[] requestEnd = new byte[] {'\r', '\n', '\r', '\n'};
+
+        Server(ServerSocket s) {
+            srv = s;
+        }
+
+        void readOneRequest(InputStream is) throws IOException {
+            int requestEndCount = 0, r;
+            while ((r = is.read()) != -1) {
+                if (r == requestEnd[requestEndCount]) {
+                    requestEndCount++;
+                    if (requestEndCount == 4) {
+                        break;
+                    }
+                } else {
+                    requestEndCount = 0;
+                }
+            }
         }
-        System.out.println ("read " + len + " bytes");
-    }
 
-    static class CallBack extends AbstractCallback {
-
-        public void request (HttpTransaction req, int count) {
-            try {
-                System.out.println ("Request received");
-                req.setResponseEntityBody (new FileInputStream ("foo1.jar"));
-                System.out.println ("content length " + req.getResponseHeader (
-                        "Content-length"
-                ));
-                req.sendPartialResponse (200, "Ok");
-                req.abortiveClose();
+        public void run() {
+            try (Socket s = srv.accept()) {
+                // read HTTP request from client
+                readOneRequest(s.getInputStream());
+                try (OutputStreamWriter ow =
+                     new OutputStreamWriter((s.getOutputStream()))) {
+                    FileInputStream fin = new FileInputStream(new File(
+                        System.getProperty("test.src", "."), "foo1.jar"));
+                    int length = fin.available();
+                    byte[] b = new byte[length-10];
+                    fin.read(b, 0, length-10);
+                    ow.write("HTTP/1.0 200 OK\r\n");
+
+                    // Note: The client expects length bytes.
+                    ow.write("Content-Length: " + length + "\r\n");
+                    ow.write("Content-Type: text/html\r\n");
+                    ow.write("\r\n");
+
+                    // Note: The (buggy) server only sends length-10 bytes.
+                    ow.write(new String(b));
+                    ow.flush();
+                }
             } catch (IOException e) {
                 e.printStackTrace();
             }
         }
+    }
 
-    };
-
-    static HttpServer server;
+    static void read (InputStream is) throws IOException {
+        int c,len=0;
+        while ((c=is.read()) != -1) {
+            len += c;
+        }
+        System.out.println ("read " + len + " bytes");
+    }
 
     public static void main (String[] args) throws Exception {
         String tmpdir = System.getProperty("java.io.tmpdir");
         String[] list1 = listTmpFiles(tmpdir);
-        //server = new HttpServer (new CallBack(), 10, 1, 0);
-        server = new HttpServer (new CallBack(), 1, 5, 0);
-        int port = server.getLocalPort();
+        ServerSocket serverSocket = new ServerSocket(0);
+        server = new Server(serverSocket);
+        server.start();
+        int port = serverSocket.getLocalPort();
         System.out.println ("Server: listening on port: " + port);
         URL url = new URL ("jar:http://localhost:"+port+"!/COPYRIGHT");
         try {
@@ -81,14 +109,12 @@
         } catch (IOException e) {
             System.out.println ("Received IOException as expected");
         }
-        server.terminate();
         String[] list2 = listTmpFiles(tmpdir);
         if (!sameList (list1, list2)) {
             throw new RuntimeException ("some jar_cache files left behind");
         }
     }
 
-
     static String[] listTmpFiles (String d) {
         File dir = new File (d);
         return dir.list (new FilenameFilter () {
--- jdk/test/sun/net/www/protocol/jar/B5105410.sh	2012-08-10 10:36:29.000000000 -0700
+++ jdk/test/sun/net/www/protocol/jar/B5105410.sh	2013-05-05 09:38:45.000000000 -0700
@@ -31,7 +31,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/net/www/protocol/jar/jarbug/run.sh	2012-08-10 10:36:30.000000000 -0700
+++ jdk/test/sun/net/www/protocol/jar/jarbug/run.sh	2013-05-05 09:38:45.000000000 -0700
@@ -31,7 +31,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/nio/ch/SelProvider.java	2012-08-10 10:36:30.000000000 -0700
+++ jdk/test/sun/nio/ch/SelProvider.java	2013-05-05 09:38:44.000000000 -0700
@@ -39,6 +39,8 @@
             expected = "sun.nio.ch.DevPollSelectorProvider";
         } else if ("Linux".equals(osname)) {
             expected = "sun.nio.ch.EPollSelectorProvider";
+        } else if (osname.endsWith("BSD")) {
+            expected = "sun.nio.ch.KQueueSelectorProvider";
         } else if (osname.contains("OS X")) {
             expected = "sun.nio.ch.KQueueSelectorProvider";
         } else
--- jdk/test/sun/rmi/log/ReliableLog/LogAlignmentTest.java	2012-08-10 10:36:35.000000000 -0700
+++ jdk/test/sun/rmi/log/ReliableLog/LogAlignmentTest.java	2013-05-05 09:38:45.000000000 -0700
@@ -22,8 +22,10 @@
  */
 
 /* @test
-   @bug 4094889
-   @summary rmid can have a corrupted log
+ * @bug 4094889
+ * @summary rmid can have a corrupted log
+ *
+ * @run main LogAlignmentTest
  */
 
 /* Fault: ReliableLog used RandomAccessFile.skipBytes() to seek past the end
--- jdk/test/sun/rmi/log/ReliableLog/SnapshotSize.java	2012-08-10 10:36:35.000000000 -0700
+++ jdk/test/sun/rmi/log/ReliableLog/SnapshotSize.java	2013-05-05 09:38:45.000000000 -0700
@@ -25,6 +25,8 @@
  * @bug 4319866
  * @summary Verify that ReliableLog.snapshotSize() returns correct snapshot
  *          file size even if LogHandler doesn't flush.
+ *
+ * @run main SnapshotSize
  */
 
 import java.io.ByteArrayOutputStream;
--- jdk/test/sun/rmi/rmic/RMIGenerator/RmicDefault.java	2012-08-10 10:36:35.000000000 -0700
+++ jdk/test/sun/rmi/rmic/RMIGenerator/RmicDefault.java	2013-05-05 09:38:45.000000000 -0700
@@ -28,7 +28,6 @@
  * @library ../../../../java/rmi/testlibrary
  *
  * @build StreamPipe
- * @build RmicDefault
  * @run main RmicDefault
  */
 
--- jdk/test/sun/rmi/rmic/newrmic/equivalence/AppleUserImpl.java	2012-08-10 10:36:36.000000000 -0700
+++ jdk/test/sun/rmi/rmic/newrmic/equivalence/AppleUserImpl.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,7 @@
 import java.rmi.Naming;
 import java.rmi.server.UnicastRemoteObject;
 import java.rmi.registry.LocateRegistry;
+import java.rmi.registry.Registry;
 import java.util.Random;
 import java.util.ArrayList;
 import java.util.Date;
@@ -249,11 +250,12 @@
         }
 
         synchronized (user) {
+            int port = -1;
             // create new registry and bind new AppleUserImpl in registry
             try {
-                LocateRegistry.createRegistry(1099); //TestLibrary.REGISTRY_PORT);
-                Naming.rebind("rmi://localhost:1099/AppleUser",user);
-                              //TestLibrary.REGISTRY_PORT + "/AppleUser", user);
+                Registry registry = TestLibrary.createRegistryOnUnusedPort();
+                port = TestLibrary.getRegistryPort(registry);
+                Naming.rebind("rmi://localhost:" + port + "/AppleUser",user);
             } catch (RemoteException e) {
                 //TestLibrary.bomb("Failed to bind AppleUser", e);
             } catch (java.net.MalformedURLException e) {
@@ -263,10 +265,9 @@
             // start the other server if available
             try {
                 Class app = Class.forName("ApplicationServer");
-                server = new Thread((Runnable) app.newInstance());
-                logger.log(Level.INFO, "Starting application server " +
-                    "in same process");
-                server.start();
+                java.lang.reflect.Constructor appConstructor =
+                        app.getDeclaredConstructor(new Class[] {Integer.TYPE});
+                server = new Thread((Runnable) appConstructor.newInstance(port));
             } catch (ClassNotFoundException e) {
                 // assume the other server is running in a separate process
                 logger.log(Level.INFO, "Application server must be " +
--- jdk/test/sun/rmi/rmic/newrmic/equivalence/run.sh	2012-08-10 10:36:36.000000000 -0700
+++ jdk/test/sun/rmi/rmic/newrmic/equivalence/run.sh	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -28,18 +28,22 @@
 # of sample input classes.
 # @author Peter Jones
 #
-# @build AgentServerImpl
-# @build AppleImpl
-# @build AppleUserImpl
-# @build ComputeServerImpl
-# @build CountServerImpl
-# @build DayTimeServerImpl
-# @build G1Impl
-# @build MyObjectImpl
-# @build NotActivatableServerImpl
-# @build OrangeEchoImpl
-# @build OrangeImpl
-# @build ServerImpl
+# @library ../../../../../java/rmi/testlibrary
+#
+# @build TestLibrary
+#     AgentServerImpl
+#     AppleImpl
+#     AppleUserImpl
+#     ComputeServerImpl
+#     CountServerImpl
+#     DayTimeServerImpl
+#     G1Impl
+#     MyObjectImpl
+#     NotActivatableServerImpl
+#     OrangeEchoImpl
+#     OrangeImpl
+#     ServerImpl
+#
 # @run shell run.sh
 
 if [ "${TESTJAVA}" = "" ]
--- jdk/test/sun/rmi/runtime/Log/4504153/Test4504153.java	2012-08-10 10:36:36.000000000 -0700
+++ jdk/test/sun/rmi/runtime/Log/4504153/Test4504153.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -48,8 +48,7 @@
         ByteArrayOutputStream err = new ByteArrayOutputStream();
         JavaVM vm = new JavaVM(StartRegistry.class.getName(),
                                "-Dsun.rmi.transport.logLevel=v", "", out, err);
-        vm.start();
-        vm.getVM().waitFor();
+        vm.execute();
 
         String errString = err.toString();
 
--- jdk/test/sun/rmi/runtime/Log/6409194/NoConsoleOutput.java	2012-08-10 10:36:36.000000000 -0700
+++ jdk/test/sun/rmi/runtime/Log/6409194/NoConsoleOutput.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,8 +31,7 @@
  * @author Peter Jones
  *
  * @library ../../../../../java/rmi/testlibrary
- * @build JavaVM
- * @build NoConsoleOutput
+ * @build TestLibrary JavaVM
  * @run main/othervm NoConsoleOutput
  */
 
@@ -60,11 +59,13 @@
             File.separatorChar + "logging.properties";
         ByteArrayOutputStream out = new ByteArrayOutputStream();
         ByteArrayOutputStream err = new ByteArrayOutputStream();
+
+        // We instantiate a JavaVM that should not produce any console output
+        // (neither on standard output, nor on standard err streams).
         JavaVM vm = new JavaVM(DoRMIStuff.class.getName(),
             "-Djava.util.logging.config.file=" + loggingPropertiesFile,
                                "", out, err);
-        vm.start();
-        vm.getVM().waitFor();
+        vm.execute();
 
         /*
          * Verify that the subprocess had no System.out or System.err
@@ -87,7 +88,6 @@
     }
 
     public static class DoRMIStuff {
-        private static final int PORT = 2020;
         private interface Foo extends Remote {
             Object echo(Object obj) throws RemoteException;
         }
@@ -96,8 +96,9 @@
             public Object echo(Object obj) { return obj; }
         }
         public static void main(String[] args) throws Exception {
-            LocateRegistry.createRegistry(PORT);
-            Registry reg = LocateRegistry.getRegistry("", PORT);
+            Registry registry = TestLibrary.createRegistryOnUnusedPort();
+            int registryPort = TestLibrary.getRegistryPort(registry);
+            Registry reg = LocateRegistry.getRegistry("", registryPort);
             FooImpl fooimpl = new FooImpl();
             UnicastRemoteObject.exportObject(fooimpl, 0);
             reg.rebind("foo", fooimpl);
--- jdk/test/sun/rmi/runtime/Log/checkLogging/CheckLogStreams.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/runtime/Log/checkLogging/CheckLogStreams.java	2013-05-05 09:38:45.000000000 -0700
@@ -28,11 +28,7 @@
  * @author Laird Dornin
  *
  * @library ../../../../../java/rmi/testlibrary
- * @build TestLibrary
- * @build TestParams
- * @build TestFailedException
- * @build CheckLogging
- * @build CheckLogStreams
+ * @build TestLibrary CheckLogging
  * @run main/othervm -Dsun.rmi.log.useOld=true CheckLogStreams
  */
 
--- jdk/test/sun/rmi/runtime/Log/checkLogging/CheckLogging.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/runtime/Log/checkLogging/CheckLogging.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,9 +29,6 @@
  *
  * @library ../../../../../java/rmi/testlibrary
  * @build TestLibrary
- * @build TestParams
- * @build TestFailedException
- * @build CheckLogging
  * @run main/othervm CheckLogging
  */
 
@@ -77,8 +74,9 @@
  * logger output is non-null.
  */
 public class CheckLogging {
-    private static final String LOCATION =
-        "rmi://localhost:" + TestLibrary.REGISTRY_PORT + "/";
+    private static int REGISTRY_PORT = -1;
+    private static String LOCATION;
+
     private static final ByteArrayOutputStream clientCallOut =
         new ByteArrayOutputStream();
 
@@ -100,7 +98,9 @@
     private static Registry registry;
     static {
         try {
-            registry = LocateRegistry.createRegistry(TestLibrary.REGISTRY_PORT);
+            registry = TestLibrary.createRegistryOnUnusedPort();
+            REGISTRY_PORT = TestLibrary.getRegistryPort(registry);
+            LOCATION = "rmi://localhost:" + REGISTRY_PORT + "/";
         } catch (Exception e) {
             TestLibrary.bomb("could not create registry");
         }
--- jdk/test/sun/rmi/server/MarshalOutputStream/marshalForeignStub/MarshalForeignStub.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/server/MarshalOutputStream/marshalForeignStub/MarshalForeignStub.java	2013-05-05 09:38:45.000000000 -0700
@@ -31,11 +31,7 @@
  * @author Ann Wollrath
  *
  * @library ../../../../../java/rmi/testlibrary
- * @build TestLibrary
- * @build TestFailedException
- * @build MarshalForeignStub
- * @build Receiver
- * @build MarshalForeignStub_Stub
+ * @build TestLibrary Receiver MarshalForeignStub_Stub
  * @run main/othervm/policy=security.policy MarshalForeignStub
  */
 
--- jdk/test/sun/rmi/transport/proxy/EagerHttpFallback.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/transport/proxy/EagerHttpFallback.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,9 @@
  * @bug 4290727
  * @summary Verify that ConnectException will trigger HTTP fallback if
  *          sun.rmi.transport.proxy.eagerHttpFallback system property is set.
+ *
+ * @library ../../../../java/rmi/testlibrary
+ * @build TestLibrary
  * @run main/othervm EagerHttpFallback
  */
 
@@ -33,8 +36,8 @@
 
 public class EagerHttpFallback {
 
-    static final int INITIAL_PORT = 7070;
-    static final int FALLBACK_PORT = 7071;
+    static final int INITIAL_PORT = TestLibrary.getUnusedRandomPort();
+    static final int FALLBACK_PORT = TestLibrary.getUnusedRandomPort();
 
     public static void main(String[] args) throws Exception {
         System.setProperty("http.proxyHost", "127.0.0.1");
--- jdk/test/sun/rmi/transport/tcp/DeadCachedConnection.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/transport/tcp/DeadCachedConnection.java	2013-05-05 09:38:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,9 +25,7 @@
  * @bug 4094891
  * @summary unable to retry call if cached connection to server is used
  * @library ../../../../java/rmi/testlibrary
- * @build DeadCachedConnection
- * @build JavaVM
- * @build TestLibrary
+ * @build TestLibrary JavaVM
  * @run main/othervm DeadCachedConnection
  */
 
@@ -58,7 +56,7 @@
 import java.rmi.server.*;
 
 public class DeadCachedConnection {
-    static public final int regport = 17340;
+    static public final int regport = TestLibrary.getUnusedRandomPort();
 
     static public void main(String[] argv)
         throws Exception {
@@ -106,7 +104,7 @@
             JavaVM jvm =
                 new JavaVM("sun.rmi.registry.RegistryImpl", "", Integer.toString(p));
             jvm.start();
-            DeadCachedConnection.subreg = jvm.getVM();
+            DeadCachedConnection.subreg = jvm;
 
         } catch (IOException e) {
             // one of these is summarily dropped, can't remember which one
@@ -119,7 +117,7 @@
         } catch (Exception whatever) {
         }
     }
-    private static Process subreg = null;
+    private static JavaVM subreg = null;
 
     public static void killRegistry() {
         if (DeadCachedConnection.subreg != null) {
--- jdk/test/sun/rmi/transport/tcp/blockAccept/BlockAcceptTest.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/transport/tcp/blockAccept/BlockAcceptTest.java	2013-05-05 09:38:45.000000000 -0700
@@ -27,11 +27,8 @@
  * @summary RMI blocks in HttpAwareServerSocket.accept() if you telnet to it
  * @author Adrian Colley
  *
- * @library ../../../../../java/rmi/testlibrary/
- * @build TestIface
- * @build TestImpl
- * @build TestImpl_Stub
- * @build BlockAcceptTest
+ * @library ../../../../../java/rmi/testlibrary
+ * @build TestIface TestImpl TestImpl_Stub
  * @run main/othervm/policy=security.policy/timeout=60 BlockAcceptTest
  */
 
--- jdk/test/sun/rmi/transport/tcp/disableMultiplexing/DisableMultiplexing.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/rmi/transport/tcp/disableMultiplexing/DisableMultiplexing.java	2013-05-05 09:38:45.000000000 -0700
@@ -28,7 +28,6 @@
  * on that port, rather than engage in the deprecated "multiplexing protocol".
  * @author Peter Jones
  *
- * @build DisableMultiplexing
  * @build DisableMultiplexing_Stub
  * @run main/othervm DisableMultiplexing
  */
--- jdk/test/sun/security/ec/TestEC.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/security/ec/TestEC.java	2013-05-05 09:38:45.000000000 -0700
@@ -28,11 +28,13 @@
  * @library ../pkcs11
  * @library ../pkcs11/ec
  * @library ../pkcs11/sslecc
+ * @library ../../../java/security/testlibrary
  * @compile -XDignore.symbol.file TestEC.java
  * @run main TestEC
  */
 
 import java.security.Provider;
+import java.security.Security;
 
 /*
  * Leverage the collection of EC tests used by PKCS11
@@ -51,6 +53,15 @@
 public class TestEC {
 
     public static void main(String[] args) throws Exception {
+        ProvidersSnapshot snapshot = ProvidersSnapshot.create();
+        try {
+            main0(args);
+        } finally {
+            snapshot.restore();
+        }
+    }
+
+    public static void main0(String[] args) throws Exception {
         Provider p = new sun.security.ec.SunEC();
         System.out.println("Running tests with " + p.getName() +
             " provider...\n");
@@ -67,6 +78,11 @@
         new TestECGenSpec().main(p);
         new ReadPKCS12().main(p);
         new ReadCertificates().main(p);
+
+        // ClientJSSEServerJSSE fails on Solaris 11 when both SunEC and
+        // SunPKCS11-Solaris providers are enabled.
+        // Workaround:
+        // Security.removeProvider("SunPKCS11-Solaris");
         new ClientJSSEServerJSSE().main(p);
 
         long stop = System.currentTimeMillis();
--- jdk/test/sun/security/jgss/spnego/NoSpnegoAsDefMech.java	2012-08-10 10:36:37.000000000 -0700
+++ jdk/test/sun/security/jgss/spnego/NoSpnegoAsDefMech.java	2013-05-05 09:38:45.000000000 -0700
@@ -36,7 +36,7 @@
     public static void main(String[] argv) throws Exception {
         System.setProperty("sun.security.jgss.mechanism", GSSUtil.GSS_SPNEGO_MECH_OID.toString());
         try {
-            GSSManager.getInstance().createName("service@host", GSSName.NT_HOSTBASED_SERVICE, new Oid("1.3.6.1.5.5.2"));
+            GSSManager.getInstance().createName("service@localhost", GSSName.NT_HOSTBASED_SERVICE, new Oid("1.3.6.1.5.5.2"));
         } catch (GSSException e) {
             // This is OK, for example, krb5.conf is missing or other problems
         }
--- jdk/test/sun/security/krb5/auto/BadKdc.java	2012-08-10 10:36:38.000000000 -0700
+++ jdk/test/sun/security/krb5/auto/BadKdc.java	2013-05-05 09:38:45.000000000 -0700
@@ -67,7 +67,7 @@
      *       This is tough.
      *    c. Feed the KDC a UDP packet first. The current "solution".
      */
-    public static void go(int[]... expected)
+    public static void go(String... expected)
             throws Exception {
         try {
             go0(expected);
@@ -83,7 +83,7 @@
         }
     }
 
-    public static void go0(int[]... expected)
+    public static void go0(String... expected)
             throws Exception {
         System.setProperty("sun.security.krb5.debug", "true");
 
@@ -135,8 +135,9 @@
         return k;
     }
 
-    private static void test(int... expected) throws Exception {
+    private static void test(String expected) throws Exception {
         ByteArrayOutputStream bo = new ByteArrayOutputStream();
+        System.out.println("----------------- TEST -----------------");
         try {
             test0(bo, expected);
         } catch (Exception e) {
@@ -151,31 +152,34 @@
      * One round of test for max_retries and timeout.
      * @param expected the expected kdc# timeout kdc# timeout...
      */
-    private static void test0(ByteArrayOutputStream bo, int... expected)
+    private static void test0(ByteArrayOutputStream bo, String expected)
             throws Exception {
         PrintStream oldout = System.out;
+        boolean failed = false;
         System.setOut(new PrintStream(bo));
         try {
             Context.fromUserPass(OneKDC.USER, OneKDC.PASS, false);
+        } catch (Exception e) {
+            failed = true;
         } finally {
             System.setOut(oldout);
         }
 
         String[] lines = new String(bo.toByteArray()).split("\n");
-        System.out.println("----------------- TEST -----------------");
-        int count = 0;
+        StringBuilder sb = new StringBuilder();
         for (String line: lines) {
             Matcher m = re.matcher(line);
             if (m.find()) {
                 System.out.println(line);
-                if (Integer.parseInt(m.group(1)) != expected[count++] ||
-                        Integer.parseInt(m.group(2)) != expected[count++]) {
-                    throw new Exception("Fail here");
-                }
+                sb.append(m.group(1)).append(m.group(2));
             }
         }
-        if (count != expected.length) {
-            throw new Exception("Less rounds");
+        if (failed) sb.append('-');
+
+        String output = sb.toString();
+        System.out.println("Expected: " + expected + ", actual " + output);
+        if (!output.matches(expected)) {
+            throw new Exception("Does not match");
         }
     }
 }
--- jdk/test/sun/security/krb5/auto/BadKdc1.java	2012-08-10 10:36:38.000000000 -0700
+++ jdk/test/sun/security/krb5/auto/BadKdc1.java	2013-05-05 09:38:45.000000000 -0700
@@ -37,16 +37,16 @@
            throws Exception {
        Security.setProperty("krb5.kdc.bad.policy", "tryLess");
        BadKdc.go(
-               new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,2,2,2,3,2}, // 1, 2
-               // The above line means try kdc1 for 2 seconds, then kdc1
-               // for 2 seconds,..., finally kdc3 for 2 seconds.
-               new int[]{1,2,2,2,3,2,1,2,2,2,3,2}, // 1, 2
+               "121212222222(32){1,2}1222(32){1,2}", // 1 2
+               // The above line means try kdc1 for 2 seconds then kdc1
+               // for 2 seconds... finally kdc3 for 2 seconds.
+               "1222(32){1,2}1222(32){1,2}",    // 1 2
                // refresh
-               new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,2,2,2,3,2}, // 1, 2
-               // k3 off, k2 on
-               new int[]{1,2,2,2,1,2,2,2}, // 1
+               "121212222222(32){1,2}1222(32){1,2}",  // 1 2
+               // k3 off k2 on
+               "(122212(22){1,2}|1222323232-)", // 1
                // k1 on
-               new int[]{1,2,1,2}  // empty
+               "(12(12){1,2}|122232-)"  // empty
        );
    }
 }
--- jdk/test/sun/security/krb5/auto/BadKdc2.java	2012-08-10 10:36:38.000000000 -0700
+++ jdk/test/sun/security/krb5/auto/BadKdc2.java	2013-05-05 09:38:45.000000000 -0700
@@ -37,14 +37,14 @@
             throws Exception {
         Security.setProperty("krb5.kdc.bad.policy", "tryLess:2,1000");
         BadKdc.go(
-                new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,1,1,1,2,1,2,1,3,2}, // 1, 2
-                new int[]{1,1,1,1,2,1,2,1,3,2,1,1,1,1,2,1,2,1,3,2}, // 1, 2
+                "121212222222(32){1,2}11112121(32){1,2}", // 1 2
+                "11112121(32){1,2}11112121(32){1,2}", // 1 2
                 // refresh
-                new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,1,1,1,2,1,2,1,3,2}, // 1, 2
-                // k3 off, k2 on
-                new int[]{1,1,1,1,2,1,1,1,1,1,2,2}, // 1
+                "121212222222(32){1,2}11112121(32){1,2}", // 1 2
+                // k3 off k2 on
+                "1111(21){1,2}1111(22){1,2}", // 1
                 // k1 on
-                new int[]{1,1,1,2}  // empty
+                "(11){1,2}(12){1,2}"  // empty
         );
     }
 }
--- jdk/test/sun/security/krb5/auto/BadKdc3.java	2012-08-10 10:36:38.000000000 -0700
+++ jdk/test/sun/security/krb5/auto/BadKdc3.java	2013-05-05 09:38:45.000000000 -0700
@@ -37,14 +37,14 @@
             throws Exception {
         Security.setProperty("krb5.kdc.bad.policy", "tryLast");
         BadKdc.go(
-                new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,3,2}, // 1, 2
-                new int[]{3,2,3,2}, // 1, 2
+                "121212222222(32){2,4}", // 1 2
+                "(32){2,4}", // 1 2
                 // refresh
-                new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,3,2}, // 1, 2
-                // k3 off, k2 on
-                new int[]{3,2,3,2,3,2,1,2,1,2,1,2,2,2,2,2}, // 1, 3
+                "121212222222(32){2,4}", // 1 2
+                // k3 off k2 on
+                "323232121212(22){2,4}", // 1 3
                 // k1 on
-                new int[]{2,2,2,2}  // 1, 3
+                "(22){2,4}"  // 1 3
         );
     }
 }
--- jdk/test/sun/security/krb5/auto/BadKdc4.java	2012-08-10 10:36:38.000000000 -0700
+++ jdk/test/sun/security/krb5/auto/BadKdc4.java	2013-05-05 09:38:45.000000000 -0700
@@ -37,14 +37,14 @@
             throws Exception {
         Security.setProperty("krb5.kdc.bad.policy", "");
         BadKdc.go(
-            new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,2,1,2,1,2,2,2,2,2,2,2,3,2},
-            new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,2,1,2,1,2,2,2,2,2,2,2,3,2},
+            "121212222222(32){1,2}121212222222(32){1,2}",
+            "121212222222(32){1,2}121212222222(32){1,2}",
             // refresh
-            new int[]{1,2,1,2,1,2,2,2,2,2,2,2,3,2,1,2,1,2,1,2,2,2,2,2,2,2,3,2},
-            // k3 off, k2 on
-            new int[]{1,2,1,2,1,2,2,2,1,2,1,2,1,2,2,2},
+            "121212222222(32){1,2}121212222222(32){1,2}",
+            // k3 off k2 on
+            "121212(22){1,2}121212(22){1,2}",
             // k1 on
-            new int[]{1,2,1,2}
+            "(12){2,4}"
         );
     }
 }
--- jdk/test/sun/security/krb5/runNameEquals.sh	2012-08-10 10:36:39.000000000 -0700
+++ jdk/test/sun/security/krb5/runNameEquals.sh	2013-05-05 09:38:45.000000000 -0700
@@ -48,15 +48,11 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | Darwin | *BSD )
     PATHSEP=":"
     FILESEP="/"
     NATIVE=true
     ;;
-  Darwin )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
   CYGWIN* )
     PATHSEP=";"
     FILESEP="/"
--- jdk/test/sun/security/mscapi/ShortRSAKey1024.sh	2012-08-10 10:36:39.000000000 -0700
+++ jdk/test/sun/security/mscapi/ShortRSAKey1024.sh	2013-05-05 09:38:45.000000000 -0700
@@ -27,7 +27,9 @@
 # @test
 # @bug 7106773
 # @summary 512 bits RSA key cannot work with SHA384 and SHA512
-# @run shell ShortRSAKey1024.sh
+# @run shell ShortRSAKey1024.sh 1024
+# @run shell ShortRSAKey1024.sh 768
+# @run shell ShortRSAKey1024.sh 512
 
 # set a few environment variables so that the shell-script can run stand-alone
 # in the source directory
@@ -45,24 +47,39 @@
    exit 1
 fi
 
+BITS=$1
+
 OS=`uname -s`
 case "$OS" in
     Windows* | CYGWIN* )
 
+        echo "Removing the keypair if it already exists (for unknown reason)..."
+        ${TESTJAVA}/bin/keytool \
+            -delete \
+            -storetype Windows-My \
+            -debug \
+            -alias 7106773.$BITS
+
         echo "Creating a temporary RSA keypair in the Windows-My store..."
         ${TESTJAVA}/bin/keytool \
             -genkeypair \
             -storetype Windows-My \
             -keyalg RSA \
-            -alias 7106773.1024 \
-            -keysize 1024 \
+            -alias 7106773.$BITS \
+            -keysize $BITS \
             -dname "cn=localhost,c=US" \
+            -debug \
             -noprompt
 
+        if [ "$?" -ne "0" ]; then
+            echo "Unable to generate key pair in Windows-My keystore"
+            exit 1
+        fi
+
         echo
         echo "Running the test..."
         ${TESTJAVA}/bin/javac -d . ${TESTSRC}\\ShortRSAKeyWithinTLS.java
-        ${TESTJAVA}/bin/java ShortRSAKeyWithinTLS 7106773.1024 1024 \
+        ${TESTJAVA}/bin/java ShortRSAKeyWithinTLS 7106773.$BITS $BITS \
             TLSv1.2 TLS_DHE_RSA_WITH_AES_128_CBC_SHA
 
         rc=$?
@@ -72,7 +89,8 @@
         ${TESTJAVA}/bin/keytool \
             -delete \
             -storetype Windows-My \
-            -alias 7106773.1024
+            -debug \
+            -alias 7106773.$BITS
 
         echo done.
         exit $rc
--- jdk/test/sun/security/mscapi/ShortRSAKey512.sh	2012-08-10 10:36:39.000000000 -0700
+++ jdk/test/sun/security/mscapi/ShortRSAKey512.sh	1969-12-31 16:00:00.000000000 -0800
@@ -1,86 +0,0 @@
-#!/bin/sh
-
-#
-# Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-
-# @test
-# @bug 7106773
-# @summary 512 bits RSA key cannot work with SHA384 and SHA512
-# @run shell ShortRSAKey512.sh
-
-# set a few environment variables so that the shell-script can run stand-alone
-# in the source directory
-if [ "${TESTSRC}" = "" ] ; then
-   TESTSRC="."
-fi
-
-if [ "${TESTCLASSES}" = "" ] ; then
-   TESTCLASSES="."
-fi
-
-if [ "${TESTJAVA}" = "" ] ; then
-   echo "TESTJAVA not set.  Test cannot execute."
-   echo "FAILED!!!"
-   exit 1
-fi
-
-OS=`uname -s`
-case "$OS" in
-    Windows* | CYGWIN* )
-
-        echo "Creating a temporary RSA keypair in the Windows-My store..."
-        ${TESTJAVA}/bin/keytool \
-            -genkeypair \
-            -storetype Windows-My \
-            -keyalg RSA \
-            -alias 7106773.512 \
-            -keysize 512 \
-            -dname "cn=localhost,c=US" \
-            -noprompt
-
-        echo
-        echo "Running the test..."
-        ${TESTJAVA}/bin/javac -d . ${TESTSRC}\\ShortRSAKeyWithinTLS.java
-        ${TESTJAVA}/bin/java ShortRSAKeyWithinTLS 7106773.512 512 \
-            TLSv1.2 TLS_DHE_RSA_WITH_AES_128_CBC_SHA
-
-
-        rc=$?
-
-        echo
-        echo "Removing the temporary RSA keypair from the Windows-My store..."
-        ${TESTJAVA}/bin/keytool \
-            -delete \
-            -storetype Windows-My \
-            -alias 7106773.512
-
-        echo done.
-        exit $rc
-        ;;
-
-    * )
-        echo "This test is not intended for '$OS' - passing test"
-        exit 0
-        ;;
-esac
--- jdk/test/sun/security/mscapi/ShortRSAKey768.sh	2012-08-10 10:36:39.000000000 -0700
+++ jdk/test/sun/security/mscapi/ShortRSAKey768.sh	1969-12-31 16:00:00.000000000 -0800
@@ -1,85 +0,0 @@
-#!/bin/sh
-
-#
-# Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-
-# @test
-# @bug 7106773
-# @summary 512 bits RSA key cannot work with SHA384 and SHA512
-# @run shell ShortRSAKey768.sh
-
-# set a few environment variables so that the shell-script can run stand-alone
-# in the source directory
-if [ "${TESTSRC}" = "" ] ; then
-   TESTSRC="."
-fi
-
-if [ "${TESTCLASSES}" = "" ] ; then
-   TESTCLASSES="."
-fi
-
-if [ "${TESTJAVA}" = "" ] ; then
-   echo "TESTJAVA not set.  Test cannot execute."
-   echo "FAILED!!!"
-   exit 1
-fi
-
-OS=`uname -s`
-case "$OS" in
-    Windows* | CYGWIN* )
-
-        echo "Creating a temporary RSA keypair in the Windows-My store..."
-        ${TESTJAVA}/bin/keytool \
-            -genkeypair \
-            -storetype Windows-My \
-            -keyalg RSA \
-            -alias 7106773.768 \
-            -keysize 768 \
-            -dname "cn=localhost,c=US" \
-            -noprompt
-
-        echo
-        echo "Running the test..."
-        ${TESTJAVA}/bin/javac -d . ${TESTSRC}\\ShortRSAKeyWithinTLS.java
-        ${TESTJAVA}/bin/java ShortRSAKeyWithinTLS 7106773.768 768 \
-            TLSv1.2 TLS_DHE_RSA_WITH_AES_128_CBC_SHA
-
-        rc=$?
-
-        echo
-        echo "Removing the temporary RSA keypair from the Windows-My store..."
-        ${TESTJAVA}/bin/keytool \
-            -delete \
-            -storetype Windows-My \
-            -alias 7106773.768
-
-        echo done.
-        exit $rc
-        ;;
-
-    * )
-        echo "This test is not intended for '$OS' - passing test"
-        exit 0
-        ;;
-esac
--- jdk/test/sun/security/mscapi/ShortRSAKeyWithinTLS.java	2012-08-10 10:36:39.000000000 -0700
+++ jdk/test/sun/security/mscapi/ShortRSAKeyWithinTLS.java	2013-05-05 09:38:45.000000000 -0700
@@ -29,7 +29,7 @@
 import javax.net.ssl.*;
 import java.lang.reflect.*;
 
-import sun.security.util.KeyLength;
+import sun.security.util.KeyUtil;
 
 public class ShortRSAKeyWithinTLS {
 
@@ -175,13 +175,13 @@
             privateKey = (PrivateKey)ks.getKey(keyAlias, null);
             publicKey = (PublicKey)ks.getCertificate(keyAlias).getPublicKey();
 
-            int privateKeySize = KeyLength.getKeySize(privateKey);
+            int privateKeySize = KeyUtil.getKeySize(privateKey);
             if (privateKeySize != keySize) {
                 throw new Exception("Expected key size is " + keySize +
                         ", but the private key size is " + privateKeySize);
             }
 
-            int publicKeySize = KeyLength.getKeySize(publicKey);
+            int publicKeySize = KeyUtil.getKeySize(publicKey);
             if (publicKeySize != keySize) {
                 throw new Exception("Expected key size is " + keySize +
                         ", but the public key size is " + publicKeySize);
--- jdk/test/sun/security/pkcs11/KeyStore/Basic.sh	2012-08-10 10:36:40.000000000 -0700
+++ jdk/test/sun/security/pkcs11/KeyStore/Basic.sh	2013-05-05 09:38:45.000000000 -0700
@@ -131,6 +131,27 @@
 	;;
     esac
     ;;
+  *BSD | Darwin )
+    ARCH=`uname -m`
+    case "$ARCH" in
+      i[3-6]86 )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      amd64* | x86_64 )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      * )
+	echo "Unsupported System: ${OS} ${ARCH}"
+	exit 0;
+	;;
+    esac
+    ;;
   Windows* )  
     FS="\\"
     PS=";"
--- jdk/test/sun/security/pkcs11/KeyStore/ClientAuth.sh	2012-08-10 10:36:41.000000000 -0700
+++ jdk/test/sun/security/pkcs11/KeyStore/ClientAuth.sh	2013-05-05 09:38:45.000000000 -0700
@@ -93,6 +93,27 @@
 	;;
     esac
     ;;
+  *BSD | Darwin )
+    ARCH=`uname -m`
+    case "$ARCH" in
+      i[3-6]86 )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      amd64* | x86_64 )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      * )
+	echo "Unsupported System: ${OS} ${ARCH}"
+	exit 0;
+	;;
+    esac
+    ;;
   Windows* )
     FS="\\"
     PS=";"
--- jdk/test/sun/security/pkcs11/PKCS11Test.java	2012-08-10 10:36:41.000000000 -0700
+++ jdk/test/sun/security/pkcs11/PKCS11Test.java	2013-05-05 09:38:46.000000000 -0700
@@ -72,10 +72,33 @@
     }
 
     public static void main(PKCS11Test test) throws Exception {
-        System.out.println("Beginning test run " + test.getClass().getName() + "...");
-        testDefault(test);
-        testNSS(test);
-        testDeimos(test);
+        Provider[] oldProviders = Security.getProviders();
+        try {
+            System.out.println("Beginning test run " + test.getClass().getName() + "...");
+            testDefault(test);
+            testNSS(test);
+            testDeimos(test);
+        } finally {
+            Provider[] newProviders = Security.getProviders();
+            // Do not restore providers if nothing changed. This is especailly
+            // useful for ./Provider/Login.sh, where a SecurityManager exists.
+            if (oldProviders.length == newProviders.length) {
+                boolean found = false;
+                for (int i = 0; i<oldProviders.length; i++) {
+                    if (oldProviders[i] != newProviders[i]) {
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) return;
+            }
+            for (Provider p: newProviders) {
+                Security.removeProvider(p.getName());
+            }
+            for (Provider p: oldProviders) {
+                Security.addProvider(p);
+            }
+        }
     }
 
     public static void testDeimos(PKCS11Test test) throws Exception {
@@ -153,21 +176,21 @@
         return libdir;
     }
 
-    static boolean loadNSPR(String libdir) throws Exception {
-        // load NSS softoken dependencies in advance to avoid resolver issues
+    protected static void safeReload(String lib) throws Exception {
         try {
-            System.load(libdir + System.mapLibraryName(NSPR_PREFIX + "nspr4"));
+            System.load(lib);
         } catch (UnsatisfiedLinkError e) {
-            // GLIBC problem on older linux-amd64 machines
-            if (libdir.contains("linux-amd64")) {
-                System.out.println(e);
-                System.out.println("NSS does not work on this platform, skipping.");
-                return false;
+            if (e.getMessage().contains("already loaded")) {
+                return;
             }
-            throw e;
         }
-        System.load(libdir + System.mapLibraryName(NSPR_PREFIX + "plc4"));
-        System.load(libdir + System.mapLibraryName(NSPR_PREFIX + "plds4"));
+    }
+
+    static boolean loadNSPR(String libdir) throws Exception {
+        // load NSS softoken dependencies in advance to avoid resolver issues
+        safeReload(libdir + System.mapLibraryName(NSPR_PREFIX + "nspr4"));
+        safeReload(libdir + System.mapLibraryName(NSPR_PREFIX + "plc4"));
+        safeReload(libdir + System.mapLibraryName(NSPR_PREFIX + "plds4"));
         return true;
     }
 
--- jdk/test/sun/security/pkcs11/Provider/ConfigQuotedString.sh	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Provider/ConfigQuotedString.sh	2013-05-05 09:38:45.000000000 -0700
@@ -50,19 +50,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    PS=":"
-    CP="${FS}bin${FS}cp"
-    CHMOD="${FS}bin${FS}chmod"
-    ;;
-  Linux )
-    FS="/"
-    PS=":"
-    CP="${FS}bin${FS}cp"
-    CHMOD="${FS}bin${FS}chmod"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     PS=":"
     CP="${FS}bin${FS}cp"
--- jdk/test/sun/security/pkcs11/Provider/Login.sh	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Provider/Login.sh	2013-05-05 09:38:45.000000000 -0700
@@ -51,19 +51,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    PS=":"
-    CP="${FS}bin${FS}cp"
-    CHMOD="${FS}bin${FS}chmod"
-    ;;
-  Linux )
-    FS="/"
-    PS=":"
-    CP="${FS}bin${FS}cp"
-    CHMOD="${FS}bin${FS}chmod"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     PS=":"
     CP="${FS}bin${FS}cp"
--- jdk/test/sun/security/pkcs11/Secmod/AddPrivateKey.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Secmod/AddPrivateKey.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary Test that the PKCS#11 KeyStore handles RSA, DSA, and EC keys
  * @author Andreas Sterbenz
  * @library ..
+ * @run main/othervm AddPrivateKey
  */
 
 import java.io.*;
--- jdk/test/sun/security/pkcs11/Secmod/AddTrustedCert.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Secmod/AddTrustedCert.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary make sure we can add a trusted cert to the NSS KeyStore module
  * @author Andreas Sterbenz
  * @library ..
+ * @run main/othervm AddTrustedCert
  */
 
 import java.io.*;
--- jdk/test/sun/security/pkcs11/Secmod/Crypto.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Secmod/Crypto.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary verify that NSS no-db mode works correctly
  * @author Andreas Sterbenz
  * @library ..
+ * @run main/othervm Crypto
  */
 
 import java.util.*;
--- jdk/test/sun/security/pkcs11/Secmod/GetPrivateKey.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Secmod/GetPrivateKey.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary make sure we can access the NSS softtoken KeyStore and use a private key
  * @author Andreas Sterbenz
  * @library ..
+ * @run main/othervm GetPrivateKey
  */
 
 import java.util.*;
--- jdk/test/sun/security/pkcs11/Secmod/JksSetPrivateKey.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Secmod/JksSetPrivateKey.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary store a NSS PKCS11 PrivateKeyEntry to JKS KeyStore throws confusing NPE
  * @author Wang Weijun
  * @library ..
+ * @run main/othervm JksSetPrivateKey
  */
 
 import java.util.*;
--- jdk/test/sun/security/pkcs11/Secmod/TrustAnchors.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/Secmod/TrustAnchors.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary make sure we can access the NSS trust anchor module
  * @author Andreas Sterbenz
  * @library ..
+ * @run main/othervm TrustAnchors
  */
 
 import java.util.*;
--- jdk/test/sun/security/pkcs11/SecmodTest.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/SecmodTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -44,8 +44,8 @@
         if (loadNSPR(LIBPATH) == false) {
             return false;
         }
-        System.load(LIBPATH + System.mapLibraryName("softokn3"));
-        System.load(LIBPATH + System.mapLibraryName("nssckbi"));
+        safeReload(LIBPATH + System.mapLibraryName("softokn3"));
+        safeReload(LIBPATH + System.mapLibraryName("nssckbi"));
 
         DBDIR = System.getProperty("test.classes", ".") + SEP + "tmpdb";
         System.setProperty("pkcs11test.nss.db", DBDIR);
--- jdk/test/sun/security/pkcs11/ec/ReadCertificates.java	2012-08-10 10:36:42.000000000 -0700
+++ jdk/test/sun/security/pkcs11/ec/ReadCertificates.java	2013-05-05 09:38:46.000000000 -0700
@@ -28,6 +28,7 @@
  *   and verify their signatures
  * @author Andreas Sterbenz
  * @library ..
+ * @library ../../../../java/security/testlibrary
  */
 
 import java.io.*;
@@ -62,7 +63,7 @@
             System.out.println("Provider does not support ECDSA, skipping...");
             return;
         }
-        Security.insertProviderAt(p, 1);
+        Providers.setAt(p, 1);
 
         random = new SecureRandom();
         factory = CertificateFactory.getInstance("X.509");
--- jdk/test/sun/security/pkcs11/ec/ReadPKCS12.java	2012-08-10 10:36:43.000000000 -0700
+++ jdk/test/sun/security/pkcs11/ec/ReadPKCS12.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary Verify that we can parse ECPrivateKeys from PKCS#12 and use them
  * @author Andreas Sterbenz
  * @library ..
+ * @library ../../../../java/security/testlibrary
  */
 
 import java.io.*;
@@ -52,7 +53,7 @@
             System.out.println("Provider does not support ECDSA, skipping...");
             return;
         }
-        Security.insertProviderAt(p, 1);
+        Providers.setAt(p, 1);
 
         CertificateFactory factory = CertificateFactory.getInstance("X.509");
         try {
--- jdk/test/sun/security/pkcs11/ec/TestECDH.java	2012-08-10 10:36:43.000000000 -0700
+++ jdk/test/sun/security/pkcs11/ec/TestECDH.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary Basic known answer test for ECDH
  * @author Andreas Sterbenz
  * @library ..
+ * @library ../../../../java/security/testlibrary
  */
 
 import java.io.*;
@@ -59,7 +60,7 @@
             System.out.println("Provider does not support ECDH, skipping");
             return;
         }
-        Security.insertProviderAt(p, 1);
+        Providers.setAt(p, 1);
 
         if (false) {
             KeyPairGenerator kpg = KeyPairGenerator.getInstance("EC", p);
--- jdk/test/sun/security/pkcs11/ec/TestECDSA.java	2012-08-10 10:36:43.000000000 -0700
+++ jdk/test/sun/security/pkcs11/ec/TestECDSA.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary basic test of SHA1withECDSA and NONEwithECDSA signing/verifying
  * @author Andreas Sterbenz
  * @library ..
+ * @library ../../../../java/security/testlibrary
  */
 
 import java.io.*;
@@ -115,7 +116,7 @@
             System.out.println("ECDSA not supported, skipping");
             return;
         }
-        Security.insertProviderAt(provider, 1);
+        Providers.setAt(provider, 1);
 
         if (false) {
             KeyPairGenerator kpg = KeyPairGenerator.getInstance("EC", provider);
--- jdk/test/sun/security/pkcs11/fips/CipherTest.java	2012-08-10 10:36:43.000000000 -0700
+++ jdk/test/sun/security/pkcs11/fips/CipherTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -394,47 +394,52 @@
 
     public static void main(PeerFactory peerFactory, KeyStore keyStore,
             String[] args) throws Exception {
-
-        long time = System.currentTimeMillis();
-        String relPath;
-        if ((args != null) && (args.length > 0) && args[0].equals("sh")) {
-            relPath = pathToStoresSH;
-        } else {
-            relPath = pathToStores;
+        SSLContext reservedSSLContext = SSLContext.getDefault();
+        try {
+            long time = System.currentTimeMillis();
+            String relPath;
+            if ((args != null) && (args.length > 0) && args[0].equals("sh")) {
+                relPath = pathToStoresSH;
+            } else {
+                relPath = pathToStores;
+            }
+            PATH = new File(System.getProperty("test.src", "."), relPath);
+            CipherTest.peerFactory = peerFactory;
+            System.out.print(
+                "Initializing test '" + peerFactory.getName() + "'...");
+//          secureRandom = new SecureRandom();
+//          secureRandom.nextInt();
+//          trustStore = readKeyStore(trustStoreFile);
+            CipherTest.keyStore = keyStore;
+//          keyStore = readKeyStore(keyStoreFile);
+            KeyManagerFactory keyFactory =
+                KeyManagerFactory.getInstance(
+                    KeyManagerFactory.getDefaultAlgorithm());
+            keyFactory.init(keyStore, "test12".toCharArray());
+            keyManager = (X509ExtendedKeyManager)keyFactory.getKeyManagers()[0];
+
+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init(keyStore);
+            trustManager = (X509TrustManager)tmf.getTrustManagers()[0];
+
+//          trustManager = new AlwaysTrustManager();
+            SSLContext context = SSLContext.getInstance("TLS");
+            context.init(new KeyManager[] {keyManager},
+                    new TrustManager[] {trustManager}, null);
+            SSLContext.setDefault(context);
+
+            CipherTest cipherTest = new CipherTest(peerFactory);
+            Thread serverThread = new Thread(peerFactory.newServer(cipherTest),
+                "Server");
+            serverThread.setDaemon(true);
+            serverThread.start();
+            System.out.println("Done");
+            cipherTest.run();
+            time = System.currentTimeMillis() - time;
+            System.out.println("Done. (" + time + " ms)");
+        } finally {
+            SSLContext.setDefault(reservedSSLContext);
         }
-        PATH = new File(System.getProperty("test.src", "."), relPath);
-        CipherTest.peerFactory = peerFactory;
-        System.out.print(
-            "Initializing test '" + peerFactory.getName() + "'...");
-//      secureRandom = new SecureRandom();
-//      secureRandom.nextInt();
-//      trustStore = readKeyStore(trustStoreFile);
-        CipherTest.keyStore = keyStore;
-//      keyStore = readKeyStore(keyStoreFile);
-        KeyManagerFactory keyFactory =
-            KeyManagerFactory.getInstance(
-                KeyManagerFactory.getDefaultAlgorithm());
-        keyFactory.init(keyStore, "test12".toCharArray());
-        keyManager = (X509ExtendedKeyManager)keyFactory.getKeyManagers()[0];
-
-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-        tmf.init(keyStore);
-        trustManager = (X509TrustManager)tmf.getTrustManagers()[0];
-
-//      trustManager = new AlwaysTrustManager();
-        SSLContext context = SSLContext.getInstance("TLS");
-        context.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager}, null);
-        SSLContext.setDefault(context);
-
-        CipherTest cipherTest = new CipherTest(peerFactory);
-        Thread serverThread = new Thread(peerFactory.newServer(cipherTest),
-            "Server");
-        serverThread.setDaemon(true);
-        serverThread.start();
-        System.out.println("Done");
-        cipherTest.run();
-        time = System.currentTimeMillis() - time;
-        System.out.println("Done. (" + time + " ms)");
     }
 
     static abstract class PeerFactory {
--- jdk/test/sun/security/pkcs11/fips/ClientJSSEServerJSSE.java	2012-08-10 10:36:43.000000000 -0700
+++ jdk/test/sun/security/pkcs11/fips/ClientJSSEServerJSSE.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,10 +25,11 @@
  * @test
  * @bug 6313675 6323647
  * @summary Verify that all ciphersuites work in FIPS mode
+ * @library ..
  * @ignore JSSE supported cipher suites are changed with CR 6916074,
  *     need to update this test case in JDK 7 soon
+ * @run main/othervm ClientJSSEServerJSSE
  * @author Andreas Sterbenz
- * @library ..
  */
 
 import java.security.*;
--- jdk/test/sun/security/pkcs11/fips/TrustManagerTest.java	2012-08-10 10:36:43.000000000 -0700
+++ jdk/test/sun/security/pkcs11/fips/TrustManagerTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary Verify that the SunJSSE trustmanager works correctly in FIPS mode
  * @author Andreas Sterbenz
  * @library ..
+ * @run main/othervm TrustManagerTest
  */
 
 import java.io.*;
--- jdk/test/sun/security/pkcs11/rsa/TestCACerts.java	2012-08-10 10:36:53.000000000 -0700
+++ jdk/test/sun/security/pkcs11/rsa/TestCACerts.java	2013-05-05 09:38:46.000000000 -0700
@@ -48,32 +48,35 @@
     public void main(Provider p) throws Exception {
         long start = System.currentTimeMillis();
         Security.addProvider(p);
-        String PROVIDER = p.getName();
-        String javaHome = System.getProperty("java.home");
-        String caCerts = javaHome + SEP + "lib" + SEP + "security" + SEP + "cacerts";
-        InputStream in = new FileInputStream(caCerts);
-        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
-        ks.load(in, null);
-        in.close();
-        for (Enumeration e = ks.aliases(); e.hasMoreElements(); ) {
-            String alias = (String)e.nextElement();
-            if (ks.isCertificateEntry(alias)) {
-                System.out.println("* Testing " + alias + "...");
-                X509Certificate cert = (X509Certificate)ks.getCertificate(alias);
-                PublicKey key = cert.getPublicKey();
-                String alg = key.getAlgorithm();
-                if (alg.equals("RSA")) {
-                    System.out.println("Signature algorithm: " + cert.getSigAlgName());
-                    cert.verify(key, PROVIDER);
+        try {
+            String PROVIDER = p.getName();
+            String javaHome = System.getProperty("java.home");
+            String caCerts = javaHome + SEP + "lib" + SEP + "security" + SEP + "cacerts";
+            InputStream in = new FileInputStream(caCerts);
+            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
+            ks.load(in, null);
+            in.close();
+            for (Enumeration e = ks.aliases(); e.hasMoreElements(); ) {
+                String alias = (String)e.nextElement();
+                if (ks.isCertificateEntry(alias)) {
+                    System.out.println("* Testing " + alias + "...");
+                    X509Certificate cert = (X509Certificate)ks.getCertificate(alias);
+                    PublicKey key = cert.getPublicKey();
+                    String alg = key.getAlgorithm();
+                    if (alg.equals("RSA")) {
+                        System.out.println("Signature algorithm: " + cert.getSigAlgName());
+                        cert.verify(key, PROVIDER);
+                    } else {
+                        System.out.println("Skipping cert with key: " + alg);
+                    }
                 } else {
-                    System.out.println("Skipping cert with key: " + alg);
+                    System.out.println("Skipping alias " + alias);
                 }
-            } else {
-                System.out.println("Skipping alias " + alias);
             }
+            long stop = System.currentTimeMillis();
+            System.out.println("All tests passed (" + (stop - start) + " ms).");
+        } finally {
+            Security.removeProvider(p.getName());
         }
-        long stop = System.currentTimeMillis();
-        System.out.println("All tests passed (" + (stop - start) + " ms).");
     }
-
 }
--- jdk/test/sun/security/pkcs11/sslecc/ClientJSSEServerJSSE.java	2012-08-10 10:36:53.000000000 -0700
+++ jdk/test/sun/security/pkcs11/sslecc/ClientJSSEServerJSSE.java	2013-05-05 09:38:45.000000000 -0700
@@ -27,6 +27,7 @@
  * @summary Verify that all ciphersuites work (incl. ECC using NSS crypto)
  * @author Andreas Sterbenz
  * @library ..
+ * @library ../../../../java/security/testlibrary
  */
 
 import java.security.*;
@@ -45,7 +46,7 @@
             System.out.println("Provider does not support EC, skipping");
             return;
         }
-        Security.insertProviderAt(p, 1);
+        Providers.setAt(p, 1);
         CipherTest.main(new JSSEFactory(), cmdArgs);
         Security.removeProvider(p.getName());
     }
--- jdk/test/sun/security/pkcs12/PKCS12SameKeyId.java	2012-08-10 10:36:53.000000000 -0700
+++ jdk/test/sun/security/pkcs12/PKCS12SameKeyId.java	2013-05-05 09:38:45.000000000 -0700
@@ -86,7 +86,9 @@
 
         // Reads from JKS keystore and pre-calculate
         KeyStore ks = KeyStore.getInstance("jks");
-        ks.load(new FileInputStream(JKSFILE), PASSWORD);
+        try (FileInputStream fis = new FileInputStream(JKSFILE)) {
+            ks.load(fis, PASSWORD);
+        }
         for (int i=0; i<SIZE; i++) {
             aliases[i] = "p" + i;
             byte[] enckey = cipher.doFinal(
@@ -103,11 +105,15 @@
         for (int i=0; i<SIZE; i++) {
             p12.setKeyEntry(aliases[i], keys[i], certChains[i]);
         }
-        p12.store(new FileOutputStream(P12FILE), PASSWORD);
+        try (FileOutputStream fos = new FileOutputStream(P12FILE)) {
+            p12.store(fos, PASSWORD);
+        }
 
         // Check private keys still match certs
         p12 = KeyStore.getInstance("pkcs12");
-        p12.load(new FileInputStream(P12FILE), PASSWORD);
+        try (FileInputStream fis = new FileInputStream(P12FILE)) {
+            p12.load(fis, PASSWORD);
+        }
         for (int i=0; i<SIZE; i++) {
             String a = "p" + i;
             X509Certificate x = (X509Certificate)p12.getCertificate(a);
--- jdk/test/sun/security/provider/PolicyFile/Comparator.java	2012-08-10 10:36:53.000000000 -0700
+++ jdk/test/sun/security/provider/PolicyFile/Comparator.java	2013-05-05 09:38:46.000000000 -0700
@@ -24,6 +24,7 @@
 /*
  * @test
  * @bug 5037004
+ * @run main/othervm Comparator
  * @summary Frivolous ClassCastExceptions thrown by SubjectCodeSource.implies
  *
  * Note:  if you want to see the java.security.debug output,
--- jdk/test/sun/security/provider/PolicyFile/GrantAllPermToExtWhenNoPolicy.sh	2012-08-10 10:36:53.000000000 -0700
+++ jdk/test/sun/security/provider/PolicyFile/GrantAllPermToExtWhenNoPolicy.sh	2013-05-05 09:38:46.000000000 -0700
@@ -44,11 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/sun/security/provider/PolicyFile/getinstance/getinstance.sh	2012-08-10 10:36:55.000000000 -0700
+++ jdk/test/sun/security/provider/PolicyFile/getinstance/getinstance.sh	2013-05-05 09:38:46.000000000 -0700
@@ -47,15 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
-    PS=":"
-    FS="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/SSLSecurity/ProviderTest.java	2012-08-10 10:36:57.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/SSLSecurity/ProviderTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -40,28 +40,32 @@
         TrustManagerFactory tmf;
         KeyManagerFactory kmf;
 
-        Security.addProvider(new MyProvider());
-
-        System.out.println("getting a javax SSLContext");
-        sslc = SSLContext.getInstance("javax");
-        sslc.init(null, null, null);
-        System.out.println("\ngetting a com SSLContext");
-        sslc = SSLContext.getInstance("com");
-        sslc.init(null, null, null);
-
-        System.out.println("\ngetting a javax TrustManagerFactory");
-        tmf = TrustManagerFactory.getInstance("javax");
-        tmf.init((KeyStore) null);
-        System.out.println("\ngetting a com TrustManagerFactory");
-        tmf = TrustManagerFactory.getInstance("com");
-        tmf.init((KeyStore) null);
-
-        System.out.println("\ngetting a javax KeyManagerFactory");
-        kmf = KeyManagerFactory.getInstance("javax");
-        kmf.init((KeyStore) null, null);
-        System.out.println("\ngetting a com KeyManagerFactory");
-        kmf = KeyManagerFactory.getInstance("com");
-        kmf.init((KeyStore) null, null);
+        Provider extraProvider = new MyProvider();
+        Security.addProvider(extraProvider);
+        try {
+            System.out.println("getting a javax SSLContext");
+            sslc = SSLContext.getInstance("javax");
+            sslc.init(null, null, null);
+            System.out.println("\ngetting a com SSLContext");
+            sslc = SSLContext.getInstance("com");
+            sslc.init(null, null, null);
+
+            System.out.println("\ngetting a javax TrustManagerFactory");
+            tmf = TrustManagerFactory.getInstance("javax");
+            tmf.init((KeyStore) null);
+            System.out.println("\ngetting a com TrustManagerFactory");
+            tmf = TrustManagerFactory.getInstance("com");
+            tmf.init((KeyStore) null);
+
+            System.out.println("\ngetting a javax KeyManagerFactory");
+            kmf = KeyManagerFactory.getInstance("javax");
+            kmf.init((KeyStore) null, null);
+            System.out.println("\ngetting a com KeyManagerFactory");
+            kmf = KeyManagerFactory.getInstance("com");
+            kmf.init((KeyStore) null, null);
+        } finally {
+            Security.removeProvider(extraProvider.getName());
+        }
     }
 }
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/ReadBlocksClose.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/ReadBlocksClose.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to
+// re-use system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4814140
  * @summary AppInputStream: read can block a close
+ * @run main/othervm ReadBlocksClose
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/ReadHandshake.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/ReadHandshake.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4514971
  * @summary Verify applications do not read handshake data after failure
+ * @run main/othervm ReadHandshake
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/ReadZeroBytes.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/ReadZeroBytes.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6697270
  * @summary Inputstream dosent behave correct
+ * @run main/othervm ReadZeroBytes
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/RemoveMarkReset.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppInputStream/RemoveMarkReset.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4413664
  * @summary remove mark/reset functionality from AppInputStream
+ * @run main/othervm RemoveMarkReset
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppOutputStream/NoExceptionOnClose.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/AppOutputStream/NoExceptionOnClose.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test 1.3 01/03/08
  * @bug 4378397
  * @summary  JSSE socket output stream doesn't throw after socket is closed
+ * @run main/othervm NoExceptionOnClose
  * @author Jaya Hangal
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ClientHandshaker/CipherSuiteOrder.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ClientHandshaker/CipherSuiteOrder.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test 1.3 01/03/08
  * @bug 4330535
  * @summary  Client should follow suite order in
  *           SSLSocket.setEnabledCipherSuites()
+ * @run main/othervm CipherSuiteOrder
  * @author Jaya Hangal
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ClientHandshaker/RSAExport.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ClientHandshaker/RSAExport.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6690018
  * @summary RSAClientKeyExchange NullPointerException
+ * @run main/othervm RSAExport
  */
 
 /*
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/EngineArgs/DebugReportsOneExtraByte.sh	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/EngineArgs/DebugReportsOneExtraByte.sh	2013-05-05 09:38:46.000000000 -0700
@@ -33,7 +33,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/GenSSLConfigs/main.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/GenSSLConfigs/main.java	2013-05-05 09:38:46.000000000 -0700
@@ -5,8 +5,13 @@
  * @summary Make sure that different configurations of SSL sockets work
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/HandshakeOutStream/NullCerts.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/HandshakeOutStream/NullCerts.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4453053
- * @summary If a server shuts down correctly during handshaking, the client doesn't see it.
+ * @summary If a server shuts down correctly during handshaking, the client
+ *     doesn't see it.
+ * @run main/othervm NullCerts
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/InputRecord/ClientHelloRead.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/InputRecord/ClientHelloRead.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4432868
  * @summary A client-hello message may not always be read correctly
+ * @run main/othervm ClientHelloRead
  */
 
 import java.io.*;
@@ -154,23 +160,29 @@
          * we want to avoid URLspoofCheck failures in cases where the cert
          * DN name does not match the hostname in the URL.
          */
-        HttpsURLConnection.setDefaultHostnameVerifier(
-                                      new NameVerifier());
-        URL url = new URL("https://" + "localhost:" + serverPort
-                                + "/index.html");
-        BufferedReader in = null;
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            in = new BufferedReader(new InputStreamReader(
-                               url.openStream()));
-            String inputLine;
-            System.out.print("Client recieved from the server: ");
-            while ((inputLine = in.readLine()) != null)
-                System.out.println(inputLine);
-            in.close();
-        } catch (SSLException e) {
-            if (in != null)
+            HttpsURLConnection.setDefaultHostnameVerifier(
+                                          new NameVerifier());
+            URL url = new URL("https://" + "localhost:" + serverPort
+                                    + "/index.html");
+            BufferedReader in = null;
+            try {
+                in = new BufferedReader(new InputStreamReader(
+                                   url.openStream()));
+                String inputLine;
+                System.out.print("Client recieved from the server: ");
+                while ((inputLine = in.readLine()) != null)
+                    System.out.println(inputLine);
                 in.close();
-            throw e;
+            } catch (SSLException e) {
+                if (in != null)
+                    in.close();
+                throw e;
+            }
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/InputRecord/SSLSocketTimeoutNulls.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/InputRecord/SSLSocketTimeoutNulls.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,13 +21,18 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4456039
  * @summary Setting timeouts on SSLSockets immediately return null
  *      after timeout occurs.  This bug was fixed as part of 4393337,
  *      but this is another bug we want to check regressions against.
- * @run main/timeout=140 SSLSocketTimeoutNulls
+ * @run main/othervm/timeout=140 SSLSocketTimeoutNulls
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ProtocolVersion/HttpsProtocols.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ProtocolVersion/HttpsProtocols.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -147,12 +147,18 @@
             Thread.sleep(50);
         }
 
-        HttpsURLConnection.setDefaultHostnameVerifier(this);
-
-        URL url = new URL("https://localhost:" + serverPort + "/");
-        HttpURLConnection urlc = (HttpURLConnection) url.openConnection();
-
-        System.out.println("response is " + urlc.getResponseCode());
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
+        try {
+            HttpsURLConnection.setDefaultHostnameVerifier(this);
+
+            URL url = new URL("https://localhost:" + serverPort + "/");
+            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();
+
+            System.out.println("response is " + urlc.getResponseCode());
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
+        }
     }
 
     public boolean verify(String hostname, SSLSession session) {
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLContextImpl/BadKSProvider.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLContextImpl/BadKSProvider.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4919147
  * @summary Support for token-based KeyStores
+ * @run main/othervm BadKSProvider
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLContextImpl/BadTSProvider.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLContextImpl/BadTSProvider.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4919147
  * @summary Support for token-based KeyStores
+ * @run main/othervm BadTSProvider
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLContextImpl/GoodProvider.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLContextImpl/GoodProvider.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4919147
  * @summary Support for token-based KeyStores
+ * @run main/othervm GoodProvider
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLEngineImpl/RehandshakeFinished.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLEngineImpl/RehandshakeFinished.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,24 +21,31 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6207322
  * @summary SSLEngine is returning a premature FINISHED message when doing
  * an abbreviated handshake.
- *
+ * @run main/othervm RehandshakeFinished
+ * @author Brad Wetmore
+ */
+
+/*
  * This test may need some updating if the messages change order.
  * Currently I'm expecting that there is a simple renegotiation, with
  * each message being contained in a single SSL packet.
  *
- *      ClientHello
- *                              Server Hello
- *                              CCS
- *                              FINISHED
- *      CCS
- *      FINISHED
- *
- * @author Brad Wetmore
+ *     ClientHello
+ *                             Server Hello
+ *                             CCS
+ *                             FINISHED
+ *     CCS
+ *     FINISHED
  */
 
 /**
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLEngineImpl/SSLEngineDeadlock.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLEngineImpl/SSLEngineDeadlock.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6492872
  * @summary Deadlock in SSLEngine
- *
+ * @run main/othervm SSLEngineDeadlock
  * @author Brad R. Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSessionImpl/HashCodeMissing.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSessionImpl/HashCodeMissing.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4910892
  * @summary 4518403 was not properly fixed.   hashcode should be hashCode.
+ * @run main/othervm HashCodeMissing
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/AsyncSSLSocketClose.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/AsyncSSLSocketClose.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6447412
  * @summary Issue with socket.close() for ssl sockets when poweroff on
  *          other system
+ * @run main/othervm AsyncSSLSocketClose
  */
 
 import javax.net.ssl.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ClientModeClientAuth.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ClientModeClientAuth.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4390659
- * @run main/othervm -Djavax.net.debug=all ClientModeClientAuth
  * @summary setNeedClientAuth() isn't working after a handshaker is established
+ * @run main/othervm ClientModeClientAuth
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ClientTimeout.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ClientTimeout.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4836493
  * @summary Socket timeouts for SSLSockets causes data corruption.
+ * @run main/othervm ClientTimeout
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/CloseSocketException.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/CloseSocketException.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,16 +21,23 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4969799
  * @summary javax.net.ssl.SSLSocket.SSLSocket(InetAddress,int) shouldn't
  *              throw exception
- *
+ * @run main/othervm CloseSocketException
+ * @author Brad Wetmore
+ */
+
+/*
  * This is making sure that starting a new handshake throws the right
  * exception.  There is a similar test for SSLEngine.
- *
- * @author Brad Wetmore
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/InvalidateServerSessionRenegotiate.java	2012-08-10 10:36:58.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/InvalidateServerSessionRenegotiate.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4403428
  * @summary Invalidating JSSE session on server causes SSLProtocolException
+ * @run main/othervm InvalidateServerSessionRenegotiate
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NewSocketMethods.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NewSocketMethods.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4429176
  * @summary need to sync up SSL sockets with merlin java.net changes
+ * @run main/othervm NewSocketMethods
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NonAutoClose.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NonAutoClose.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4404399
  * @summary When a layered SSL socket is closed, it should wait for close_notify
+ * @run main/othervm NonAutoClose
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NotifyHandshakeTest.sh	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NotifyHandshakeTest.sh	2013-05-05 09:38:46.000000000 -0700
@@ -42,7 +42,7 @@
 
 OS=`uname -s`
 case "$OS" in
-    SunOS | Linux | Darwin )
+    SunOS | Linux | *BSD | Darwin )
         FILESEP="/"
         PATHSEP=":"
         ;;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ReuseAddr.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ReuseAddr.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4482446
  * @summary java.net.SocketTimeoutException on 98, NT, 2000 for JSSE
+ * @run main/othervm ReuseAddr
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ReverseNameLookup.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ReverseNameLookup.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4748292
  * @summary Prevent/Disable reverse name lookups with JSSE SSL sockets
+ * @run main/othervm ReverseNameLookup
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/SSLSocketImplThrowsWrongExceptions.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/SSLSocketImplThrowsWrongExceptions.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4361124 4325806
  * @summary SSLServerSocket isn't throwing exceptions when negotiations are
  *      failing & java.net.SocketException: occures in Auth and clientmode
+ * @run main/othervm SSLSocketImplThrowsWrongExceptions
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ServerTimeout.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/ServerTimeout.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4836493
  * @summary Socket timeouts for SSLSockets causes data corruption.
+ * @run main/othervm ServerTimeout
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/SetClientMode.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/SetClientMode.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6223624
  * @summary SSLSocket.setUseClientMode() fails to throw expected
  *        IllegalArgumentException
+ * @run main/othervm SetClientMode
  */
 
 /*
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/UnconnectedSocketWrongExceptions.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/UnconnectedSocketWrongExceptions.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4480441
  * @summary startHandshake giving wrong message when unconnected.
+ * @run main/othervm UnconnectedSocketWrongExceptions
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ServerHandshaker/AnonCipherWithWantClientAuth.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ServerHandshaker/AnonCipherWithWantClientAuth.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4392475
  * @summary Calling setWantClientAuth(true) disables anonymous suites
- * @run main/timeout=180 AnonCipherWithWantClientAuth
+ * @run main/othervm/timeout=180 AnonCipherWithWantClientAuth
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ServerHandshaker/GetPeerHost.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/ServerHandshaker/GetPeerHost.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /**
- *@test
- *@bug 4302026
- *@run main GetPeerHost
- *@summary make sure the server side doesn't do DNS lookup.
+ * @test
+ * @bug 4302026
+ * @run main/othervm GetPeerHost
+ * @summary make sure the server side doesn't do DNS lookup.
  */
 import javax.net.*;
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SocketCreation/SocketCreation.java	2012-08-10 10:36:59.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SocketCreation/SocketCreation.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,13 +21,18 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4414843
  * @summary This test tries all the different ways in which an SSL
  * connection can be established to exercise different SSLSocketImpl
  * constructors.
- * @run main/timeout=300 SocketCreation
+ * @run main/othervm/timeout=300 SocketCreation
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/ClientServer.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/ClientServer.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4717766
  * @summary 1.0.3 JsseX509TrustManager erroneously calls isClientTrusted()
+ * @run main/othervm ClientServer
  * @ignore JSSE supports algorithm constraints with CR 6916074,
  *     need to update this test case in JDK 7 soon
  * @author Brad Wetmore
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/PKIXExtendedTM.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/PKIXExtendedTM.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
 
 /*
  * @test
  * @bug 6916074
  * @summary Add support for TLS 1.2
+ * @run main/othervm PKIXExtendedTM
  */
 
 import java.net.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/SelfIssuedCert.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/SelfIssuedCert.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6822460
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/SunX509ExtendedTM.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/SunX509ExtendedTM.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6916074
- * @run main/othervm -Djavax.net.debug=all SunX509ExtendedTM
  * @summary Add support for TLS 1.2
+ * @run main/othervm SunX509ExtendedTM
  */
 
 import java.net.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/X509ExtendedTMEnabled.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/X509TrustManagerImpl/X509ExtendedTMEnabled.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,12 +21,18 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+// Ensure that the SunJSSE provider enables the X509ExtendedTrustManager.
+//
+
 /*
  * @test
  * @bug 6916074
  * @summary Add support for TLS 1.2
- *
- * Ensure that the SunJSSE provider enables the X509ExtendedTrustManager.
+ * @run main/othervm X509ExtendedTMEnabled
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/spi/ProviderInit.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/spi/ProviderInit.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test 1.3 01/03/08
  * @bug 4522550
  * @summary SSLContext TrustMananagerFactory and KeyManagerFactory
  *              should throw if not init
+ * @run main/othervm ProviderInit
  * @author Jaya Hangal
  */
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsClient/ProxyAuthTest.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsClient/ProxyAuthTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,11 @@
  * @test
  * @bug 4323990 4413069
  * @summary HttpsURLConnection doesn't send Proxy-Authorization on CONNECT
- * Incorrect checking of proxy server response
+ *     Incorrect checking of proxy server response
+ * @run main/othervm ProxyAuthTest
+ *
+ *     No way to reserve and restore java.lang.Authenticator, need to run this
+ *     test in othervm mode.
  */
 
 import java.io.*;
@@ -77,8 +81,7 @@
     /*
      * Main method to create the server and the client
      */
-    public static void main(String args[]) throws Exception
-    {
+    public static void main(String args[]) throws Exception {
         String keyFilename =
             System.getProperty("test.src", "./") + "/" + pathToStores +
                 "/" + keyStoreFile;
@@ -110,10 +113,9 @@
         try {
             doClientSide();
         } catch (Exception e) {
-            System.out.println("Client side failed: " +
-                                e.getMessage());
+            System.out.println("Client side failed: " + e.getMessage());
             throw e;
-          }
+        }
     }
 
     private static ServerSocketFactory getServerSocketFactory
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsClient/ServerIdentityTest.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsClient/ServerIdentityTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4328195
  * @summary Need to include the alternate subject DN for certs,
  *          https should check for this
+ * @run main/othervm ServerIdentityTest
  * @author Yingxian Wang
  */
 
@@ -136,39 +142,45 @@
     volatile Exception clientException = null;
 
     public static void main(String[] args) throws Exception {
-        for (int i = 0; i < keyStoreFiles.length; i++) {
-            String keyFilename =
-                System.getProperty("test.src", ".") + "/" + pathToStores +
-                "/" + keyStoreFiles[i];
-            String trustFilename =
-                System.getProperty("test.src", ".") + "/" + pathToStores +
-                "/" + trustStoreFiles[i];
-
-            System.setProperty("javax.net.ssl.keyStore", keyFilename);
-            System.setProperty("javax.net.ssl.keyStorePassword", passwd);
-            System.setProperty("javax.net.ssl.trustStore", trustFilename);
-            System.setProperty("javax.net.ssl.trustStorePassword", passwd);
-
-            if (debug)
-                System.setProperty("javax.net.debug", "all");
-            SSLContext context = SSLContext.getInstance("SSL");
-
-            KeyManager[] kms = new KeyManager[1];
-            KeyStore ks = KeyStore.getInstance("JKS");
-            FileInputStream fis = new FileInputStream(keyFilename);
-            ks.load(fis, passwd.toCharArray());
-            fis.close();
-            KeyManager km = new MyKeyManager(ks, passwd.toCharArray());
-            kms[0] = km;
-            context.init(kms, null, null);
-            HttpsURLConnection.setDefaultSSLSocketFactory(
-                 context.getSocketFactory());
-
-            /*
-             * Start the tests.
-             */
-            System.out.println("Testing " + keyFilename);
-            new ServerIdentityTest(context, keyStoreFiles[i]);
+        SSLSocketFactory reservedSFactory =
+                HttpsURLConnection.getDefaultSSLSocketFactory();
+        try {
+            for (int i = 0; i < keyStoreFiles.length; i++) {
+                String keyFilename =
+                    System.getProperty("test.src", ".") + "/" + pathToStores +
+                    "/" + keyStoreFiles[i];
+                String trustFilename =
+                    System.getProperty("test.src", ".") + "/" + pathToStores +
+                    "/" + trustStoreFiles[i];
+
+                System.setProperty("javax.net.ssl.keyStore", keyFilename);
+                System.setProperty("javax.net.ssl.keyStorePassword", passwd);
+                System.setProperty("javax.net.ssl.trustStore", trustFilename);
+                System.setProperty("javax.net.ssl.trustStorePassword", passwd);
+
+                if (debug)
+                    System.setProperty("javax.net.debug", "all");
+                SSLContext context = SSLContext.getInstance("SSL");
+
+                KeyManager[] kms = new KeyManager[1];
+                KeyStore ks = KeyStore.getInstance("JKS");
+                FileInputStream fis = new FileInputStream(keyFilename);
+                ks.load(fis, passwd.toCharArray());
+                fis.close();
+                KeyManager km = new MyKeyManager(ks, passwd.toCharArray());
+                kms[0] = km;
+                context.init(kms, null, null);
+                HttpsURLConnection.setDefaultSSLSocketFactory(
+                     context.getSocketFactory());
+
+                /*
+                 * Start the tests.
+                 */
+                System.out.println("Testing " + keyFilename);
+                new ServerIdentityTest(context, keyStoreFiles[i]);
+            }
+        } finally {
+            HttpsURLConnection.setDefaultSSLSocketFactory(reservedSFactory);
         }
     }
 
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsURLConnection/CriticalSubjectAltName.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsURLConnection/CriticalSubjectAltName.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6668231
  * @summary Presence of a critical subjectAltName causes JSSE's SunX509 to
  *          fail trusted checks
+ * @run main/othervm CriticalSubjectAltName
  * @author Xuelei Fan
  *
  * This test depends on binary keystore, crisubn.jks and trusted.jks. Because
--- jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsURLConnection/GetResponseCode.java	2012-08-10 10:37:00.000000000 -0700
+++ jdk/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsURLConnection/GetResponseCode.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4482187
  * @summary HttpsClient tests are failing for build 71
+ * @run main/othervm GetResponseCode
  * @author Yingxian Wang
  */
 import java.io.*;
--- jdk/test/sun/security/ssl/javax/net/ssl/Fix5070632.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/Fix5070632.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 5070632
  * @summary Default SSLSockeFactory override createSocket() now
+ * @run main/othervm Fix5070632
  * @author Weijun Wang
  */
 
@@ -35,8 +41,13 @@
 
 public class Fix5070632 {
     public static void main(String[] args) throws Exception {
+        // reserve the security properties
+        String reservedSFacProvider =
+            Security.getProperty("ssl.SocketFactory.provider");
+
         // use a non-existing provider so that the DefaultSSLSocketFactory
         // will be used, and then test against it.
+
         Security.setProperty("ssl.SocketFactory.provider", "foo.NonExistant");
         SSLSocketFactory fac = (SSLSocketFactory)SSLSocketFactory.getDefault();
         try {
@@ -46,8 +57,16 @@
             System.out.println("Throw SocketException");
             se.printStackTrace();
             return;
+        } finally {
+            // restore the security properties
+            if (reservedSFacProvider == null) {
+                reservedSFacProvider = "";
+            }
+            Security.setProperty("ssl.SocketFactory.provider",
+                                                reservedSFacProvider);
         }
-        throw new Exception("should throw SocketException");
+
         // if not caught, or other exception caught, then it's error
+        throw new Exception("should throw SocketException");
     }
 }
--- jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/ComURLNulls.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/ComURLNulls.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,12 +21,18 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4387882 4451038
  * @summary Need to revisit the javadocs for JSSE, especially the
  *      promoted classes, and HttpsURLConnection.getCipherSuite throws
  *      NullPointerException
+ * @run main/othervm ComURLNulls
  * @author Brad Wetmore
  */
 
@@ -34,6 +40,7 @@
 import java.io.*;
 import javax.net.ssl.*;
 import com.sun.net.ssl.HttpsURLConnection;
+import com.sun.net.ssl.HostnameVerifier;
 
 /*
  * Tests that the com null argument changes made it in ok.
@@ -42,59 +49,64 @@
 public class ComURLNulls {
 
     public static void main(String[] args) throws Exception {
-
-        System.setProperty("java.protocol.handler.pkgs",
-                                "com.sun.net.ssl.internal.www.protocol");
-        /**
-         * This test does not establish any connection to the specified
-         * URL, hence a dummy URL is used.
-         */
-        URL foobar = new URL("https://example.com/");
-
-        HttpsURLConnection urlc =
-            (HttpsURLConnection) foobar.openConnection();
-
-        try {
-            urlc.getCipherSuite();
-        } catch (IllegalStateException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.getServerCertificateChain();
-        } catch (IllegalStateException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.setDefaultHostnameVerifier(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.setHostnameVerifier(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.setDefaultSSLSocketFactory(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            urlc.setSSLSocketFactory(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception");
-            System.out.println(e.getMessage());
+            System.setProperty("java.protocol.handler.pkgs",
+                                    "com.sun.net.ssl.internal.www.protocol");
+            /**
+             * This test does not establish any connection to the specified
+             * URL, hence a dummy URL is used.
+             */
+            URL foobar = new URL("https://example.com/");
+
+            HttpsURLConnection urlc =
+                (HttpsURLConnection) foobar.openConnection();
+
+            try {
+                urlc.getCipherSuite();
+            } catch (IllegalStateException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.getServerCertificateChain();
+            } catch (IllegalStateException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setDefaultHostnameVerifier(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setHostnameVerifier(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setDefaultSSLSocketFactory(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setSSLSocketFactory(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception");
+                System.out.println(e.getMessage());
+            }
+            System.out.println("TESTS PASSED");
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
-        System.out.println("TESTS PASSED");
     }
 }
--- jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/ImplicitHandshake.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/ImplicitHandshake.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4387882
  * @summary Need to revisit the javadocs for JSSE, especially the
  *      promoted classes.
+ * @run main/othervm ImplicitHandshake
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/JavaxURLNulls.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/JavaxURLNulls.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,63 +42,69 @@
 
     public static void main(String[] args) throws Exception {
 
-        /**
-         * This test does not establish any connection to the specified
-         * URL, hence a dummy URL is used.
-         */
-        URL foobar = new URL("https://example.com/");
-
-        HttpsURLConnection urlc =
-            (HttpsURLConnection) foobar.openConnection();
-
-        try {
-            urlc.getCipherSuite();
-        } catch (IllegalStateException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.getLocalCertificates();
-        } catch (IllegalStateException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.getServerCertificates();
-        } catch (IllegalStateException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.setDefaultHostnameVerifier(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.setHostnameVerifier(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
-        try {
-            urlc.setDefaultSSLSocketFactory(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
-        }
-
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            urlc.setSSLSocketFactory(null);
-        } catch (IllegalArgumentException e) {
-            System.out.print("Caught proper exception: ");
-            System.out.println(e.getMessage());
+            /**
+             * This test does not establish any connection to the specified
+             * URL, hence a dummy URL is used.
+             */
+            URL foobar = new URL("https://example.com/");
+
+            HttpsURLConnection urlc =
+                (HttpsURLConnection) foobar.openConnection();
+
+            try {
+                urlc.getCipherSuite();
+            } catch (IllegalStateException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.getLocalCertificates();
+            } catch (IllegalStateException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.getServerCertificates();
+            } catch (IllegalStateException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setDefaultHostnameVerifier(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setHostnameVerifier(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setDefaultSSLSocketFactory(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+
+            try {
+                urlc.setSSLSocketFactory(null);
+            } catch (IllegalArgumentException e) {
+                System.out.print("Caught proper exception: ");
+                System.out.println(e.getMessage());
+            }
+            System.out.println("TESTS PASSED");
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
-        System.out.println("TESTS PASSED");
     }
 }
--- jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/SSLSessionNulls.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/SSLSessionNulls.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4387882
  * @summary Need to revisit the javadocs for JSSE, especially the
  *      promoted classes.
+ * @run main/othervm SSLSessionNulls
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/SSLSocketInherit.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/FixingJavadocs/SSLSocketInherit.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,12 +21,18 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4387882
  * @summary Need to revisit the javadocs for JSSE, especially the
  *      promoted classes.  This test checks to see if the settings
  *      on the server sockets get propagated to the sockets.
+ * @run main/othervm SSLSocketInherit
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/CheckMyTrustedKeystore.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/CheckMyTrustedKeystore.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4329114
  * @summary Need better way of reflecting the reason when a chain is
  *      rejected as untrusted.
+ * @run main/othervm CheckMyTrustedKeystore
  * @ignore JSSE supports algorithm constraints with CR 6916074,
  *     need to update this test case in JDK 7 soon
  * This is a serious hack job!
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/HttpsURLConnectionLocalCertificateChain.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/HttpsURLConnectionLocalCertificateChain.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4395238 4354003 4387961 4395266
@@ -30,6 +35,7 @@
  *      Fixed 4354003: Need API to get client certificate chain
  *      Fixed 4387961: HostnameVerifier needs to pass various hostnames
  *      Fixed 4395266: HttpsURLConnection should be made protected
+ * @run main/othervm HttpsURLConnectionLocalCertificateChain
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/JSSERenegotiate.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/JSSERenegotiate.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,12 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4280338
  * @summary "Unsupported SSL message version" SSLProtocolException
  *      w/SSL_RSA_WITH_NULL_MD5
- *
+ * @run main/othervm JSSERenegotiate
  * @author Ram Marti
  * @author Brad Wetmore
  */
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/KeyManagerTrustManager.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/KeyManagerTrustManager.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4387949 4302197 4396290 4395286
@@ -35,6 +40,7 @@
  * 4396290: Need a way to pass algorithm specific parameters to TM's and KM's
  * 4395286: The property for setting the default
  *      KeyManagerFactory/TrustManagerFactory algorithms needs real name
+ * @run main/othervm KeyManagerTrustManager
  * @author Brad Wetmore
  */
 
@@ -77,17 +83,40 @@
         String kmfAlg = null;
         String tmfAlg = null;
 
-        Security.setProperty("ssl.KeyManagerFactory.algorithm", "hello");
-        Security.setProperty("ssl.TrustManagerFactory.algorithm", "goodbye");
-
-        kmfAlg = KeyManagerFactory.getDefaultAlgorithm();
-        tmfAlg = TrustManagerFactory.getDefaultAlgorithm();
-
-        if (!kmfAlg.equals("hello")) {
-            throw new Exception("ssl.KeyManagerFactory.algorithm not set");
-        }
-        if (!tmfAlg.equals("goodbye")) {
-            throw new Exception("ssl.TrustManagerFactory.algorithm not set");
+        // reserve the security properties
+        String reservedKMFacAlg =
+            Security.getProperty("ssl.KeyManagerFactory.algorithm");
+        String reservedTMFacAlg =
+            Security.getProperty("ssl.TrustManagerFactory.algorithm");
+
+        try {
+            Security.setProperty("ssl.KeyManagerFactory.algorithm", "hello");
+            Security.setProperty("ssl.TrustManagerFactory.algorithm",
+                                                                "goodbye");
+
+            kmfAlg = KeyManagerFactory.getDefaultAlgorithm();
+            tmfAlg = TrustManagerFactory.getDefaultAlgorithm();
+
+            if (!kmfAlg.equals("hello")) {
+                throw new Exception("ssl.KeyManagerFactory.algorithm not set");
+            }
+            if (!tmfAlg.equals("goodbye")) {
+                throw new Exception(
+                        "ssl.TrustManagerFactory.algorithm not set");
+            }
+        } finally {
+            // restore the security properties
+            if (reservedKMFacAlg == null) {
+                reservedKMFacAlg = "";
+            }
+
+            if (reservedTMFacAlg == null) {
+                reservedTMFacAlg = "";
+            }
+            Security.setProperty("ssl.KeyManagerFactory.algorithm",
+                                                            reservedKMFacAlg);
+            Security.setProperty("ssl.TrustManagerFactory.algorithm",
+                                                            reservedTMFacAlg);
         }
     }
 }
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLCtxAccessToSessCtx.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLCtxAccessToSessCtx.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4473210
  * @summary SSLSessionContext should be accessible from SSLContext
+ * @run main/othervm SSLCtxAccessToSessCtx
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/AcceptLargeFragments.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/AcceptLargeFragments.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,17 +21,24 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6388456
  * @summary Need adjustable TLS max record size for interoperability
  *      with non-compliant stacks
- *
- * Check the system property "jsse.SSLEngine.acceptLargeFragments"
- *
+ * @run main/othervm AcceptLargeFragments
  * @author xuelei fan
  */
 
+/*
+ * Check the system property "jsse.SSLEngine.acceptLargeFragments"
+ */
+
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLSession;
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/ExtendedKeySocket.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/ExtendedKeySocket.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4981697
  * @summary Rework the X509KeyManager to avoid incompatibility issues
+ * @run main/othervm ExtendedKeySocket
  * @author Brad R. Wetmore
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/LargePacket.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/LargePacket.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,13 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  *
  * @bug 6388456
  * @summary Need adjustable TLS max record size for interoperability
  *      with non-compliant
- *
  * @run main/othervm -Djsse.enableCBCProtection=false LargePacket
  *
  * @author Xuelei Fan
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/NoAuthClientAuth.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SSLEngine/NoAuthClientAuth.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4495742
  * @summary Demonstrate SSLEngine switch from no client auth to client auth.
- *
+ * @run main/othervm NoAuthClientAuth
  * @author Brad R. Wetmore
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SessionCacheSizeTests.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SessionCacheSizeTests.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug   4366807
  * @summary Need new APIs to get/set session timeout and session cache size.
+ * @run main/othervm SessionCacheSizeTests
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SessionTimeOutTests.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/SessionTimeOutTests.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug   4366807
  * @summary Need new APIs to get/set session timeout and session cache size.
+ * @run main/othervm SessionTimeOutTests
  */
 
 import java.io.*;
@@ -207,7 +213,7 @@
                 timeout = sessCtx.getSessionTimeout();
                 System.out.println("timeout is changed to: " + timeout);
                 System.out.println();
-            }
+           }
         }
 
         // check the ids returned by the enumerator
--- jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/testEnabledProtocols.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/NewAPIs/testEnabledProtocols.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4416068 4478803 4479736
@@ -30,6 +35,7 @@
  *                  session
  *          4701722 protocol mismatch exceptions should be consistent between
  *                  SSLv3 and TLSv1
+ * @run main/othervm testEnabledProtocols
  * @author Ram Marti
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/SSLServerSocket/DefaultSSLServSocketFac.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/SSLServerSocket/DefaultSSLServSocketFac.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /**
  * @test
  * @bug 6449579
  * @summary DefaultSSLServerSocketFactory does not override createServerSocket()
+ * @run main/othervm DefaultSSLServSocketFac
  */
 import java.security.Security;
 import javax.net.ServerSocketFactory;
@@ -33,6 +39,10 @@
 
 public class DefaultSSLServSocketFac {
     public static void main(String[] args) throws Exception {
+        // reserve the security properties
+        String reservedSSFacProvider =
+            Security.getProperty("ssl.ServerSocketFactory.provider");
+
         try {
             Security.setProperty("ssl.ServerSocketFactory.provider", "oops");
             ServerSocketFactory ssocketFactory =
@@ -44,6 +54,13 @@
                 throw e;
             }
             // get the expected exception
+        } finally {
+            // restore the security properties
+            if (reservedSSFacProvider == null) {
+                reservedSSFacProvider = "";
+            }
+            Security.setProperty("ssl.ServerSocketFactory.provider",
+                                                    reservedSSFacProvider);
         }
     }
 }
--- jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/EmptyCertificateAuthorities.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/EmptyCertificateAuthorities.java	2013-05-05 09:38:46.000000000 -0700
@@ -23,12 +23,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4873188
  * @summary Support TLS 1.1
- * @run main/othervm -Djavax.net.debug=all EmptyCertificateAuthorities
- *
+ * @run main/othervm EmptyCertificateAuthorities
  * @author Xuelei Fan
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/ExportableBlockCipher.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/ExportableBlockCipher.java	2013-05-05 09:38:46.000000000 -0700
@@ -23,12 +23,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4873188
  * @summary Support TLS 1.1
- * @run main/othervm -Djavax.net.debug=all ExportableBlockCipher
- *
+ * @run main/othervm ExportableBlockCipher
  * @author Xuelei Fan
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/ExportableStreamCipher.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/ExportableStreamCipher.java	2013-05-05 09:38:46.000000000 -0700
@@ -23,12 +23,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4873188
  * @summary Support TLS 1.1
- * @run main/othervm -Djavax.net.debug=all ExportableStreamCipher
- *
+ * @run main/othervm ExportableStreamCipher
  * @author Xuelei Fan
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/GenericBlockCipher.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/GenericBlockCipher.java	2013-05-05 09:38:46.000000000 -0700
@@ -23,12 +23,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4873188
  * @summary Support TLS 1.1
- * @run main/othervm -Djavax.net.debug=all GenericBlockCipher
- *
+ * @run main/othervm GenericBlockCipher
  * @author Xuelei Fan
  */
 
--- jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/GenericStreamCipher.java	2012-08-10 10:37:01.000000000 -0700
+++ jdk/test/sun/security/ssl/javax/net/ssl/TLSv11/GenericStreamCipher.java	2013-05-05 09:38:46.000000000 -0700
@@ -23,12 +23,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4873188
  * @summary Support TLS 1.1
- * @run main/othervm -Djavax.net.debug=all GenericStreamCipher
- *
+ * @run main/othervm GenericStreamCipher
  * @author Xuelei Fan
  */
 
--- jdk/test/sun/security/ssl/sanity/pluggability/CheckSSLContextExport.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sanity/pluggability/CheckSSLContextExport.java	2013-05-05 09:38:46.000000000 -0700
@@ -64,8 +64,8 @@
             default:
                 throw new Exception("Internal Test Error!");
             }
-            System.out.println("Testing with " + (standardCiphers ? "standard" : "custom") +
-                               " cipher suites");
+            System.out.println("Testing with " +
+                (standardCiphers ? "standard" : "custom") + " cipher suites");
             for (int j = 0; j < 4; j++) {
                 String clsName = null;
                 try {
@@ -107,11 +107,16 @@
 
     public static void main(String[] argv) throws Exception {
         String protocols[] = { "SSL", "TLS" };
-        Security.insertProviderAt(new CheckSSLContextExport(protocols), 1);
-        for (int i = 0; i < protocols.length; i++) {
-            System.out.println("Testing " + protocols[i] + "'s SSLContext");
-            test(protocols[i]);
+        Provider extraProvider = new CheckSSLContextExport(protocols);
+        Security.insertProviderAt(extraProvider, 1);
+        try {
+            for (int i = 0; i < protocols.length; i++) {
+                System.out.println("Testing " + protocols[i] + "'s SSLContext");
+                test(protocols[i]);
+            }
+            System.out.println("Test Passed");
+        } finally {
+            Security.removeProvider(extraProvider.getName());
         }
-        System.out.println("Test Passed");
     }
 }
--- jdk/test/sun/security/ssl/sanity/pluggability/CheckSockFacExport1.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sanity/pluggability/CheckSockFacExport1.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4635454 6208022
  * @summary Check pluggability of SSLSocketFactory and
  * SSLServerSocketFactory classes.
+ * @run main/othervm CheckSockFacExport1
  */
 
 import java.util.*;
@@ -37,36 +43,57 @@
 public class CheckSockFacExport1 {
 
     public static void main(String argv[]) throws Exception {
-        Security.setProperty("ssl.SocketFactory.provider",
-                             "MySSLSocketFacImpl");
-        MySSLSocketFacImpl.useCustomCipherSuites();
-        Security.setProperty("ssl.ServerSocketFactory.provider",
-            "MySSLServerSocketFacImpl");
-        MySSLServerSocketFacImpl.useCustomCipherSuites();
-
-        String[] supportedCS = null;
-        for (int i = 0; i < 2; i++) {
-            switch (i) {
-            case 0:
-                System.out.println("Testing SSLSocketFactory:");
-                SSLSocketFactory sf = (SSLSocketFactory)
-                    SSLSocketFactory.getDefault();
-                supportedCS = sf.getSupportedCipherSuites();
-                break;
-            case 1:
-                System.out.println("Testing SSLServerSocketFactory:");
-                SSLServerSocketFactory ssf = (SSLServerSocketFactory)
-                    SSLServerSocketFactory.getDefault();
-                supportedCS = ssf.getSupportedCipherSuites();
-                break;
-            default:
-                throw new Exception("Internal Test Error");
+        // reserve the security properties
+        String reservedSFacAlg =
+            Security.getProperty("ssl.SocketFactory.provider");
+        String reservedSSFacAlg =
+            Security.getProperty("ssl.ServerSocketFactory.provider");
+
+        try {
+            Security.setProperty("ssl.SocketFactory.provider",
+                                 "MySSLSocketFacImpl");
+            MySSLSocketFacImpl.useCustomCipherSuites();
+            Security.setProperty("ssl.ServerSocketFactory.provider",
+                "MySSLServerSocketFacImpl");
+            MySSLServerSocketFacImpl.useCustomCipherSuites();
+
+            String[] supportedCS = null;
+            for (int i = 0; i < 2; i++) {
+                switch (i) {
+                case 0:
+                    System.out.println("Testing SSLSocketFactory:");
+                    SSLSocketFactory sf = (SSLSocketFactory)
+                        SSLSocketFactory.getDefault();
+                    supportedCS = sf.getSupportedCipherSuites();
+                    break;
+                case 1:
+                    System.out.println("Testing SSLServerSocketFactory:");
+                    SSLServerSocketFactory ssf = (SSLServerSocketFactory)
+                        SSLServerSocketFactory.getDefault();
+                    supportedCS = ssf.getSupportedCipherSuites();
+                    break;
+                default:
+                    throw new Exception("Internal Test Error");
+                }
+                System.out.println(Arrays.asList(supportedCS));
+                if (supportedCS.length == 0) {
+                    throw new Exception("supported ciphersuites are empty");
+                }
+            }
+            System.out.println("Test Passed");
+        } finally {
+            // restore the security properties
+            if (reservedSFacAlg == null) {
+                reservedSFacAlg = "";
             }
-            System.out.println(Arrays.asList(supportedCS));
-            if (supportedCS.length == 0) {
-                throw new Exception("supported ciphersuites are empty");
+
+            if (reservedSSFacAlg == null) {
+                reservedSSFacAlg = "";
             }
+            Security.setProperty("ssl.SocketFactory.provider",
+                                                            reservedSFacAlg);
+            Security.setProperty("ssl.ServerSocketFactory.provider",
+                                                            reservedSSFacAlg);
         }
-        System.out.println("Test Passed");
     }
 }
--- jdk/test/sun/security/ssl/sanity/pluggability/CheckSockFacExport2.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sanity/pluggability/CheckSockFacExport2.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4635454
  * @summary Check pluggability of SSLSocketFactory and
- * SSLServerSocketFactory classes.
+ *     SSLServerSocketFactory classes.
+ * @run main/othervm CheckSockFacExport2
  */
 import java.security.*;
 import java.net.*;
@@ -34,38 +40,59 @@
 public class CheckSockFacExport2 {
 
     public static void main(String argv[]) throws Exception {
-        Security.setProperty("ssl.SocketFactory.provider",
-            "MySSLSocketFacImpl");
-        MySSLSocketFacImpl.useStandardCipherSuites();
-        Security.setProperty("ssl.ServerSocketFactory.provider",
-            "MySSLServerSocketFacImpl");
-        MySSLServerSocketFacImpl.useStandardCipherSuites();
-
-        boolean result = false;
-        for (int i = 0; i < 2; i++) {
-            switch (i) {
-            case 0:
-                System.out.println("Testing SSLSocketFactory:");
-                SSLSocketFactory sf = (SSLSocketFactory)
-                    SSLSocketFactory.getDefault();
-                result = (sf instanceof MySSLSocketFacImpl);
-                break;
-
-            case 1:
-                System.out.println("Testing SSLServerSocketFactory:");
-                SSLServerSocketFactory ssf = (SSLServerSocketFactory)
-                    SSLServerSocketFactory.getDefault();
-                result = (ssf instanceof MySSLServerSocketFacImpl);
-                break;
-            default:
-                throw new Exception("Internal Test Error");
+        // reserve the security properties
+        String reservedSFacAlg =
+            Security.getProperty("ssl.SocketFactory.provider");
+        String reservedSSFacAlg =
+            Security.getProperty("ssl.ServerSocketFactory.provider");
+
+        try {
+            Security.setProperty("ssl.SocketFactory.provider",
+                "MySSLSocketFacImpl");
+            MySSLSocketFacImpl.useStandardCipherSuites();
+            Security.setProperty("ssl.ServerSocketFactory.provider",
+                "MySSLServerSocketFacImpl");
+            MySSLServerSocketFacImpl.useStandardCipherSuites();
+
+            boolean result = false;
+            for (int i = 0; i < 2; i++) {
+                switch (i) {
+                case 0:
+                    System.out.println("Testing SSLSocketFactory:");
+                    SSLSocketFactory sf = (SSLSocketFactory)
+                        SSLSocketFactory.getDefault();
+                    result = (sf instanceof MySSLSocketFacImpl);
+                    break;
+
+                case 1:
+                    System.out.println("Testing SSLServerSocketFactory:");
+                    SSLServerSocketFactory ssf = (SSLServerSocketFactory)
+                        SSLServerSocketFactory.getDefault();
+                    result = (ssf instanceof MySSLServerSocketFacImpl);
+                    break;
+                default:
+                    throw new Exception("Internal Test Error");
+                }
+                if (result) {
+                    System.out.println("...accepted valid SFs");
+                } else {
+                    throw new Exception("...wrong SF is used");
+                }
+            }
+            System.out.println("Test Passed");
+        } finally {
+            // restore the security properties
+            if (reservedSFacAlg == null) {
+                reservedSFacAlg = "";
             }
-            if (result) {
-                System.out.println("...accepted valid SFs");
-            } else {
-                throw new Exception("...wrong SF is used");
+
+            if (reservedSSFacAlg == null) {
+                reservedSSFacAlg = "";
             }
+            Security.setProperty("ssl.SocketFactory.provider",
+                                                            reservedSFacAlg);
+            Security.setProperty("ssl.ServerSocketFactory.provider",
+                                                            reservedSSFacAlg);
         }
-        System.out.println("Test Passed");
     }
 }
--- jdk/test/sun/security/ssl/sun/net/www/http/ChunkedOutputStream/Test.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/http/ChunkedOutputStream/Test.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /**
  * @test
  * @bug 5026745
@@ -283,31 +288,37 @@
             System.getProperty("test.src", "./") + "/" + pathToStores +
                 "/" + trustStoreFile;
 
-        System.setProperty("javax.net.ssl.keyStore", keyFilename);
-        System.setProperty("javax.net.ssl.keyStorePassword", passwd);
-        System.setProperty("javax.net.ssl.trustStore", trustFilename);
-        System.setProperty("javax.net.ssl.trustStorePassword", passwd);
-        HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
-
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            server = new HttpServer (new Test(), 1, 10, 0);
-            System.out.println ("Server started: listening on port: " + server.getLocalPort());
-            // the test server doesn't support keep-alive yet
-            // test1("http://localhost:"+server.getLocalPort()+"/d0");
-            test1("https://localhost:"+server.getLocalPort()+"/d01");
-            test3("https://localhost:"+server.getLocalPort()+"/d3");
-            test4("https://localhost:"+server.getLocalPort()+"/d4");
-            test5("https://localhost:"+server.getLocalPort()+"/d5");
-            test6("https://localhost:"+server.getLocalPort()+"/d6");
-            test7("https://localhost:"+server.getLocalPort()+"/d7");
-            test8("https://localhost:"+server.getLocalPort()+"/d8");
-        } catch (Exception e) {
-            if (server != null) {
-                server.terminate();
+            System.setProperty("javax.net.ssl.keyStore", keyFilename);
+            System.setProperty("javax.net.ssl.keyStorePassword", passwd);
+            System.setProperty("javax.net.ssl.trustStore", trustFilename);
+            System.setProperty("javax.net.ssl.trustStorePassword", passwd);
+            HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
+
+            try {
+                server = new HttpServer (new Test(), 1, 10, 0);
+                System.out.println ("Server started: listening on port: " + server.getLocalPort());
+                // the test server doesn't support keep-alive yet
+                // test1("http://localhost:"+server.getLocalPort()+"/d0");
+                test1("https://localhost:"+server.getLocalPort()+"/d01");
+                test3("https://localhost:"+server.getLocalPort()+"/d3");
+                test4("https://localhost:"+server.getLocalPort()+"/d4");
+                test5("https://localhost:"+server.getLocalPort()+"/d5");
+                test6("https://localhost:"+server.getLocalPort()+"/d6");
+                test7("https://localhost:"+server.getLocalPort()+"/d7");
+                test8("https://localhost:"+server.getLocalPort()+"/d8");
+            } catch (Exception e) {
+                if (server != null) {
+                    server.terminate();
+                }
+                throw e;
             }
-            throw e;
+            server.terminate();
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
-        server.terminate();
     }
 
     static class NameVerifier implements HostnameVerifier {
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/B6216082.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/B6216082.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,14 +21,19 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6216082
  * @library ../../../httpstest/
  * @build HttpCallback HttpServer ClosedChannelList HttpTransaction TunnelProxy
- * @run main/othervm B6216082
  * @summary  Redirect problem with HttpsURLConnection using a proxy
-*/
+ * @run main/othervm B6216082
+ */
 
 import java.io.*;
 import java.net.*;
@@ -46,20 +51,27 @@
     static InetAddress firstNonLoAddress = null;
 
     public static void main(String[] args) throws Exception {
-        // XXX workaround for CNFE
-        Class.forName("java.nio.channels.ClosedByInterruptException");
-        setupEnv();
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
+        try {
+            // XXX workaround for CNFE
+            Class.forName("java.nio.channels.ClosedByInterruptException");
+            setupEnv();
 
-        startHttpServer();
+            startHttpServer();
 
-        // https.proxyPort can only be set after the TunnelProxy has been
-        // created as it will use an ephemeral port.
-        System.setProperty( "https.proxyPort", (new Integer(proxy.getLocalPort())).toString() );
+            // https.proxyPort can only be set after the TunnelProxy has been
+            // created as it will use an ephemeral port.
+            System.setProperty("https.proxyPort",
+                        (new Integer(proxy.getLocalPort())).toString() );
 
-        makeHttpCall();
+            makeHttpCall();
 
-        if (httpTrans.hasBadRequest) {
-            throw new RuntimeException("Test failed : bad http request");
+            if (httpTrans.hasBadRequest) {
+                throw new RuntimeException("Test failed : bad http request");
+            }
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/CloseKeepAliveCached.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/CloseKeepAliveCached.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,13 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6618387
  * @summary SSL client sessions do not close cleanly. A TCP reset occurs
  *      instead of a close_notify alert.
- * @run main/othervm -Djavax.net.debug=ssl CloseKeepAliveCached
- *
+ * @run main/othervm CloseKeepAliveCached
  * @ignore
  *    After run the test manually, at the end of the debug output,
  *    if "MainThread, called close()" found, the test passed. Otherwise,
@@ -140,13 +144,15 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-
         /*
          * Wait for server to get started.
          */
         while (!serverReady) {
             Thread.sleep(50);
         }
+
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
             HttpsURLConnection http = null;
 
@@ -180,6 +186,8 @@
             if (sslServerSocket != null)
                 sslServerSocket.close();
             throw ioex;
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/CookieHandlerTest.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/CookieHandlerTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
- * @summary Unit test for java.net.CookieHandler
  * @bug 4696506 4942650
+ * @summary Unit test for java.net.CookieHandler
+ * @run main/othervm CookieHandlerTest
  * @author Yingxian Wang
  */
 
@@ -182,26 +188,34 @@
             System.getProperty("test.src", "./") + "/" + pathToStores +
                 "/" + trustStoreFile;
 
-        System.setProperty("javax.net.ssl.keyStore", keyFilename);
-        System.setProperty("javax.net.ssl.keyStorePassword", passwd);
-        System.setProperty("javax.net.ssl.trustStore", trustFilename);
-        System.setProperty("javax.net.ssl.trustStorePassword", passwd);
-
-        if (debug)
-            System.setProperty("javax.net.debug", "all");
-
-        /*
-         * Start the tests.
-         */
-        cookies = new HashMap<String, String>();
-        cookies.put("Cookie",
-              "$Version=\"1\"; Customer=\"WILE_E_COYOTE\"; $Path=\"/acme\"");
-        cookies.put("Set-Cookie2",
-          "$Version=\"1\"; Part_Number=\"Riding_Rocket_0023\"; " +
-          "$Path=\"/acme/ammo\"; Part_Number=\"Rocket_Launcher_0001\"; "+
-          "$Path=\"/acme\"");
-        CookieHandler.setDefault(new MyCookieHandler());
-        new CookieHandlerTest();
+        CookieHandler reservedCookieHandler = CookieHandler.getDefault();
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
+        try {
+            System.setProperty("javax.net.ssl.keyStore", keyFilename);
+            System.setProperty("javax.net.ssl.keyStorePassword", passwd);
+            System.setProperty("javax.net.ssl.trustStore", trustFilename);
+            System.setProperty("javax.net.ssl.trustStorePassword", passwd);
+
+            if (debug)
+                System.setProperty("javax.net.debug", "all");
+
+            /*
+             * Start the tests.
+             */
+            cookies = new HashMap<String, String>();
+            cookies.put("Cookie",
+                "$Version=\"1\"; Customer=\"WILE_E_COYOTE\"; $Path=\"/acme\"");
+            cookies.put("Set-Cookie2",
+              "$Version=\"1\"; Part_Number=\"Riding_Rocket_0023\"; " +
+              "$Path=\"/acme/ammo\"; Part_Number=\"Rocket_Launcher_0001\"; "+
+              "$Path=\"/acme\"");
+            CookieHandler.setDefault(new MyCookieHandler());
+            new CookieHandlerTest();
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
+            CookieHandler.setDefault(reservedCookieHandler);
+        }
     }
 
     Thread clientThread = null;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/CookieHttpsClientTest.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/CookieHttpsClientTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -26,6 +26,7 @@
  * @bug 7129083
  * @summary Cookiemanager does not store cookies if url is read
  *          before setting cookiemanager
+ * @run main/othervm CookieHttpsClientTest
  */
 
 import java.net.CookieHandler;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/DNSIdentities.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/DNSIdentities.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
- * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
  * @bug 6766775
+ * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
+ * @run main/othervm DNSIdentities
  * @author Xuelei Fan
  */
 
@@ -691,34 +697,39 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-        SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
-            clientModulus, clientPrivateExponent, passphrase);
-
-        SSLContext.setDefault(context);
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
+        SSLContext reservedSSLContext = SSLContext.getDefault();
+        try {
+            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
+                clientModulus, clientPrivateExponent, passphrase);
 
-        HttpsURLConnection http = null;
+            SSLContext.setDefault(context);
 
-        /* establish http connection to server */
-        URL url = new URL("https://localhost:" + serverPort+"/");
-        System.out.println("url is "+url.toString());
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-        try {
-            http = (HttpsURLConnection)url.openConnection();
+            HttpsURLConnection http = null;
 
-            int respCode = http.getResponseCode();
-            System.out.println("respCode = "+respCode);
-        } finally {
-            if (http != null) {
-                http.disconnect();
+            /* establish http connection to server */
+            URL url = new URL("https://localhost:" + serverPort+"/");
+            System.out.println("url is "+url.toString());
+
+            try {
+                http = (HttpsURLConnection)url.openConnection();
+
+                int respCode = http.getResponseCode();
+                System.out.println("respCode = "+respCode);
+            } finally {
+                if (http != null) {
+                    http.disconnect();
+                }
+                closeReady = true;
             }
-            closeReady = true;
+        } finally {
+            SSLContext.setDefault(reservedSSLContext);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsCreateSockTest.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsCreateSockTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /**
  * @test
  * @bug 6771432
- * @summary createSocket() - smpatch fails using 1.6.0_10 because of "Unconnected sockets not implemented"
+ * @summary createSocket() - smpatch fails using 1.6.0_10 because of
+ *     "Unconnected sockets not implemented"
+ * @run main/othervm HttpsCreateSockTest
  */
 
 import javax.net.SocketFactory;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsPost.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsPost.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4423074
  * @summary Need to rebase all the duplicated classes from Merlin.
  *          This test will check out http POST
+ * @run main/othervm HttpsPost
  */
 
 import java.io.*;
@@ -140,34 +146,38 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
+        try {
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
-
-        // Send HTTP POST request to server
-        URL url = new URL("https://localhost:"+serverPort);
-
-        HttpsURLConnection.setDefaultHostnameVerifier(
-                                      new NameVerifier());
-        HttpsURLConnection http = (HttpsURLConnection)url.openConnection();
-        http.setDoOutput(true);
+            // Send HTTP POST request to server
+            URL url = new URL("https://localhost:"+serverPort);
 
-        http.setRequestMethod("POST");
-        PrintStream ps = new PrintStream(http.getOutputStream());
-        try {
-            ps.println(postMsg);
-            ps.flush();
-            if (http.getResponseCode() != 200) {
-                throw new RuntimeException("test Failed");
+            HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
+            HttpsURLConnection http = (HttpsURLConnection)url.openConnection();
+            http.setDoOutput(true);
+
+            http.setRequestMethod("POST");
+            PrintStream ps = new PrintStream(http.getOutputStream());
+            try {
+                ps.println(postMsg);
+                ps.flush();
+                if (http.getResponseCode() != 200) {
+                    throw new RuntimeException("test Failed");
+                }
+            } finally {
+                ps.close();
+                http.disconnect();
+                closeReady = true;
             }
         } finally {
-            ps.close();
-            http.disconnect();
-            closeReady = true;
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsProxyStackOverflow.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsProxyStackOverflow.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,13 @@
  * questions.
  */
 
+// No way to reserve default Authenticator, need to run in othervm mode.
+
 /*
  * @test
  * @bug 6670868
  * @summary StackOverFlow with bad authenticated Proxy tunnels
+ * @run main/othervm HttpsProxyStackOverflow
  */
 
 import java.io.IOException;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsSocketFacTest.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/HttpsSocketFacTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 6614957
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/IPAddressDNSIdentities.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/IPAddressDNSIdentities.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
- * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
  * @bug 6766775
+ * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
+ * @run main/othervm IPAddressDNSIdentities
  * @author Xuelei Fan
  */
 
@@ -691,43 +697,48 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-        SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
-            clientModulus, clientPrivateExponent, passphrase);
-
-        SSLContext.setDefault(context);
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
-
-        HttpsURLConnection http = null;
+        SSLContext reservedSSLContext = SSLContext.getDefault();
+        try {
+            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
+                clientModulus, clientPrivateExponent, passphrase);
 
-        /* establish http connection to server */
-        URL url = new URL("https://127.0.0.1:" + serverPort+"/");
-        System.out.println("url is "+url.toString());
+            SSLContext.setDefault(context);
 
-        try {
-            http = (HttpsURLConnection)url.openConnection();
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-            int respCode = http.getResponseCode();
-            System.out.println("respCode = " + respCode);
+            HttpsURLConnection http = null;
 
-            throw new Exception("Unexpectly found subject alternative name " +
-                                "matching IP address");
-        } catch (SSLHandshakeException sslhe) {
-            // no subject alternative names matching IP address 127.0.0.1 found
-            // that's the expected exception, ignore it.
-        } catch (IOException ioe) {
-            // HttpsClient may throw IOE during checking URL spoofing,
-            // that's the expected exception, ignore it.
-        } finally {
-            if (http != null) {
-                http.disconnect();
+            /* establish http connection to server */
+            URL url = new URL("https://127.0.0.1:" + serverPort+"/");
+            System.out.println("url is "+url.toString());
+
+            try {
+                http = (HttpsURLConnection)url.openConnection();
+
+                int respCode = http.getResponseCode();
+                System.out.println("respCode = " + respCode);
+
+                throw new Exception("Unexpectly found " +
+                        "subject alternative name matching IP address");
+            } catch (SSLHandshakeException sslhe) {
+                // no subject alternative names matching IP address 127.0.0.1
+                // found that's the expected exception, ignore it.
+            } catch (IOException ioe) {
+                // HttpsClient may throw IOE during checking URL spoofing,
+                // that's the expected exception, ignore it.
+            } finally {
+                if (http != null) {
+                    http.disconnect();
+                }
+                closeReady = true;
             }
-            closeReady = true;
+        } finally {
+            SSLContext.setDefault(reservedSSLContext);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/IPAddressIPIdentities.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/IPAddressIPIdentities.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
  * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
  * @bug 6766775
+ * @run main/othervm IPAddressIPIdentities
  * @author Xuelei Fan
  */
 
@@ -692,34 +698,39 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-        SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
-            clientModulus, clientPrivateExponent, passphrase);
-
-        SSLContext.setDefault(context);
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
+        SSLContext reservedSSLContext = SSLContext.getDefault();
+        try {
+            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
+                clientModulus, clientPrivateExponent, passphrase);
 
-        HttpsURLConnection http = null;
+            SSLContext.setDefault(context);
 
-        /* establish http connection to server */
-        URL url = new URL("https://127.0.0.1:" + serverPort+"/");
-        System.out.println("url is "+url.toString());
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-        try {
-            http = (HttpsURLConnection)url.openConnection();
+            HttpsURLConnection http = null;
 
-            int respCode = http.getResponseCode();
-            System.out.println("respCode = "+respCode);
-        } finally {
-            if (http != null) {
-                http.disconnect();
+            /* establish http connection to server */
+            URL url = new URL("https://127.0.0.1:" + serverPort+"/");
+            System.out.println("url is "+url.toString());
+
+            try {
+                http = (HttpsURLConnection)url.openConnection();
+
+                int respCode = http.getResponseCode();
+                System.out.println("respCode = "+respCode);
+            } finally {
+                if (http != null) {
+                    http.disconnect();
+                }
+                closeReady = true;
             }
-            closeReady = true;
+        } finally {
+            SSLContext.setDefault(reservedSSLContext);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/IPIdentities.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/IPIdentities.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
  * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
  * @bug 6766775
+ * @run main/othervm IPIdentities
  * @author Xuelei Fan
  */
 
@@ -692,34 +698,38 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-        SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
-            clientModulus, clientPrivateExponent, passphrase);
-
-        SSLContext.setDefault(context);
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
-
-        HttpsURLConnection http = null;
-
-        /* establish http connection to server */
-        URL url = new URL("https://localhost:" + serverPort+"/");
-        System.out.println("url is "+url.toString());
-
+        SSLContext reservedSSLContext = SSLContext.getDefault();
         try {
-            http = (HttpsURLConnection)url.openConnection();
+            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
+                clientModulus, clientPrivateExponent, passphrase);
+            SSLContext.setDefault(context);
+
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-            int respCode = http.getResponseCode();
-            System.out.println("respCode = "+respCode);
-        } finally {
-            if (http != null) {
-                http.disconnect();
+            HttpsURLConnection http = null;
+
+            /* establish http connection to server */
+            URL url = new URL("https://localhost:" + serverPort+"/");
+            System.out.println("url is "+url.toString());
+
+            try {
+                http = (HttpsURLConnection)url.openConnection();
+
+                int respCode = http.getResponseCode();
+                System.out.println("respCode = "+respCode);
+            } finally {
+                if (http != null) {
+                    http.disconnect();
+                }
+                closeReady = true;
             }
-            closeReady = true;
+        } finally {
+            SSLContext.setDefault(reservedSSLContext);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/Identities.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/Identities.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
- * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
  * @bug 6766775
+ * @summary X509 certificate hostname checking is broken in JDK1.6.0_10
+ * @run main/othervm Identities
  * @author Xuelei Fan
  */
 
@@ -691,34 +697,39 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-        SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
-            clientModulus, clientPrivateExponent, passphrase);
-
-        SSLContext.setDefault(context);
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
+        SSLContext reservedSSLContext = SSLContext.getDefault();
+        try {
+            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,
+                clientModulus, clientPrivateExponent, passphrase);
 
-        HttpsURLConnection http = null;
+            SSLContext.setDefault(context);
 
-        /* establish http connection to server */
-        URL url = new URL("https://localhost:" + serverPort+"/");
-        System.out.println("url is "+url.toString());
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-        try {
-            http = (HttpsURLConnection)url.openConnection();
+            HttpsURLConnection http = null;
 
-            int respCode = http.getResponseCode();
-            System.out.println("respCode = "+respCode);
-        } finally {
-            if (http != null) {
-                http.disconnect();
+            /* establish http connection to server */
+            URL url = new URL("https://localhost:" + serverPort+"/");
+            System.out.println("url is "+url.toString());
+
+            try {
+                http = (HttpsURLConnection)url.openConnection();
+
+                int respCode = http.getResponseCode();
+                System.out.println("respCode = "+respCode);
+            } finally {
+                if (http != null) {
+                    http.disconnect();
+                }
+                closeReady = true;
             }
-            closeReady = true;
+        } finally {
+            SSLContext.setDefault(reservedSSLContext);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxy.java	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxy.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -147,44 +147,51 @@
     static String postMsg = "Testing HTTP post on a https server";
 
     static void doClientSide(String hostname) throws Exception {
-        /*
-         * setup up a proxy
-         */
-        setupProxy();
-
-        /*
-         * we want to avoid URLspoofCheck failures in cases where the cert
-         * DN name does not match the hostname in the URL.
-         */
-        HttpsURLConnection.setDefaultHostnameVerifier(
-                                      new NameVerifier());
-        URL url = new URL("https://" + hostname+ ":" + serverPort);
-
-        HttpsURLConnection https = (HttpsURLConnection)url.openConnection();
-        https.setDoOutput(true);
-        https.setRequestMethod("POST");
-        PrintStream ps = null;
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-           ps = new PrintStream(https.getOutputStream());
-           ps.println(postMsg);
-           ps.flush();
-           if (https.getResponseCode() != 200) {
-                throw new RuntimeException("test Failed");
-           }
-           ps.close();
-
-           // clear the pipe
-           BufferedReader in = new BufferedReader(
-                                new InputStreamReader(
-                                https.getInputStream()));
-           String inputLine;
-           while ((inputLine = in.readLine()) != null)
-                System.out.println("Client received: " + inputLine);
-           in.close();
-        } catch (SSLException e) {
-            if (ps != null)
-                ps.close();
-            throw e;
+            /*
+             * setup up a proxy
+             */
+            SocketAddress pAddr = setupProxy();
+
+            /*
+             * we want to avoid URLspoofCheck failures in cases where the cert
+             * DN name does not match the hostname in the URL.
+             */
+            HttpsURLConnection.setDefaultHostnameVerifier(
+                                          new NameVerifier());
+            URL url = new URL("https://" + hostname+ ":" + serverPort);
+
+            Proxy p = new Proxy(Proxy.Type.HTTP, pAddr);
+            HttpsURLConnection https = (HttpsURLConnection)url.openConnection(p);
+            https.setDoOutput(true);
+            https.setRequestMethod("POST");
+            PrintStream ps = null;
+            try {
+               ps = new PrintStream(https.getOutputStream());
+               ps.println(postMsg);
+               ps.flush();
+               if (https.getResponseCode() != 200) {
+                    throw new RuntimeException("test Failed");
+               }
+               ps.close();
+
+               // clear the pipe
+               BufferedReader in = new BufferedReader(
+                                    new InputStreamReader(
+                                    https.getInputStream()));
+               String inputLine;
+               while ((inputLine = in.readLine()) != null)
+                    System.out.println("Client received: " + inputLine);
+               in.close();
+            } catch (SSLException e) {
+                if (ps != null)
+                    ps.close();
+                throw e;
+            }
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
@@ -194,14 +201,12 @@
         }
     }
 
-    static void setupProxy() throws IOException {
+    static SocketAddress setupProxy() throws IOException {
         ProxyTunnelServer pserver = new ProxyTunnelServer();
 
         // disable proxy authentication
         pserver.needUserAuth(false);
         pserver.start();
-        System.setProperty("https.proxyHost", "localhost");
-        System.setProperty("https.proxyPort", String.valueOf(
-                                        pserver.getPort()));
+        return new InetSocketAddress("localhost", pserver.getPort());
     }
 }
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxy.sh	2012-08-10 10:37:02.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxy.sh	2013-05-05 09:38:46.000000000 -0700
@@ -32,7 +32,7 @@
 HOSTNAME=`uname -n`
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxyWithAuth.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxyWithAuth.java	2013-05-05 09:38:46.000000000 -0700
@@ -152,7 +152,7 @@
         /*
          * setup up a proxy
          */
-        setupProxy();
+        SocketAddress pAddr = setupProxy();
 
         /*
          * we want to avoid URLspoofCheck failures in cases where the cert
@@ -162,7 +162,8 @@
                                       new NameVerifier());
         URL url = new URL("https://" + hostname + ":" + serverPort);
 
-        HttpsURLConnection https = (HttpsURLConnection)url.openConnection();
+        Proxy p = new Proxy(Proxy.Type.HTTP, pAddr);
+        HttpsURLConnection https = (HttpsURLConnection)url.openConnection(p);
         https.setDoOutput(true);
         https.setRequestMethod("POST");
         PrintStream ps = null;
@@ -195,7 +196,7 @@
         }
     }
 
-    static void setupProxy() throws IOException {
+    static SocketAddress setupProxy() throws IOException {
         ProxyTunnelServer pserver = new ProxyTunnelServer();
 
         /*
@@ -209,9 +210,8 @@
         pserver.setUserAuth("Test", "test123");
 
         pserver.start();
-        System.setProperty("https.proxyHost", "localhost");
-        System.setProperty("https.proxyPort", String.valueOf(
-                                        pserver.getPort()));
+
+        return new InetSocketAddress("localhost", pserver.getPort());
     }
 
     public static class TestAuthenticator extends Authenticator {
@@ -220,6 +220,4 @@
                                          "test123".toCharArray());
         }
     }
-
-
 }
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxyWithAuth.sh	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxyWithAuth.sh	2013-05-05 09:38:46.000000000 -0700
@@ -32,7 +32,7 @@
 HOSTNAME=`uname -n`
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/ReadTimeout.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/ReadTimeout.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,10 +21,18 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4811482 4700777 4905410
- * @summary sun.net.client.defaultConnectTimeout should work with HttpsURLConnection; HTTP client: Connect and read timeouts; Https needs to support new tiger features that went into http
+ * @summary sun.net.client.defaultConnectTimeout should work with
+ *     HttpsURLConnection; HTTP client: Connect and read timeouts;
+ *     Https needs to support new tiger features that went into http
+ * @run main/othervm ReadTimeout
  */
 
 import java.io.*;
@@ -143,44 +151,48 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
-        HttpsURLConnection http = null;
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            URL url = new URL("https://localhost:"+serverPort);
-
-            // set read timeout through system property
-            System.setProperty("sun.net.client.defaultReadTimeout", "2000");
-            HttpsURLConnection.setDefaultHostnameVerifier(
-                                      new NameVerifier());
-            http = (HttpsURLConnection)url.openConnection();
-
-            InputStream is = http.getInputStream ();
-        } catch (SocketTimeoutException stex) {
-            done();
-            http.disconnect();
-        }
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
+            HttpsURLConnection http = null;
+            try {
+                URL url = new URL("https://localhost:"+serverPort);
+
+                // set read timeout through system property
+                System.setProperty("sun.net.client.defaultReadTimeout", "2000");
+                HttpsURLConnection.setDefaultHostnameVerifier(
+                                          new NameVerifier());
+                http = (HttpsURLConnection)url.openConnection();
+
+                InputStream is = http.getInputStream ();
+            } catch (SocketTimeoutException stex) {
+                done();
+                http.disconnect();
+            }
 
-        try {
-            URL url = new URL("https://localhost:"+serverPort);
+            try {
+                URL url = new URL("https://localhost:"+serverPort);
 
-            HttpsURLConnection.setDefaultHostnameVerifier(
-                                      new NameVerifier());
-            http = (HttpsURLConnection)url.openConnection();
-            // set read timeout through API
-            http.setReadTimeout(2000);
-
-            InputStream is = http.getInputStream ();
-        } catch (SocketTimeoutException stex) {
-            done();
-            http.disconnect();
+                HttpsURLConnection.setDefaultHostnameVerifier(
+                                          new NameVerifier());
+                http = (HttpsURLConnection)url.openConnection();
+                // set read timeout through API
+                http.setReadTimeout(2000);
+
+                InputStream is = http.getInputStream ();
+            } catch (SocketTimeoutException stex) {
+                done();
+                http.disconnect();
+            }
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
-
     }
 
     static class NameVerifier implements HostnameVerifier {
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/Redirect.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/Redirect.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,17 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4423074
  * @summary Need to rebase all the duplicated classes from Merlin.
  *          This test will check out http POST
+ * @run main/othervm Redirect
  */
 
 import java.io.*;
@@ -139,28 +145,33 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
+        try {
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
 
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
-
-        // Send HTTP POST request to server
-        URL url = new URL("https://localhost:"+serverPort);
+            // Send HTTP POST request to server
+            URL url = new URL("https://localhost:"+serverPort);
 
-        HttpsURLConnection.setDefaultHostnameVerifier(
-                                      new NameVerifier());
-        HttpsURLConnection http = (HttpsURLConnection)url.openConnection();
-        try {
-            System.out.println("response header: "+http.getHeaderField(0));
-            if (http.getResponseCode() != 200) {
-                throw new RuntimeException("test Failed");
+            HttpsURLConnection.setDefaultHostnameVerifier(
+                                          new NameVerifier());
+            HttpsURLConnection http = (HttpsURLConnection)url.openConnection();
+            try {
+                System.out.println("response header: "+http.getHeaderField(0));
+                if (http.getResponseCode() != 200) {
+                    throw new RuntimeException("test Failed");
+                }
+            } finally {
+                http.disconnect();
+                closeReady = true;
             }
         } finally {
-            http.disconnect();
-            closeReady = true;
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/RetryHttps.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/RetryHttps.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,9 +21,15 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /* @test
- * @summary Https can not retry request
  * @bug 4799427
+ * @summary Https can not retry request
+ * @run main/othervm RetryHttps
  * @author Yingxian Wang
  */
 
@@ -129,36 +135,41 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-        HttpsURLConnection http = null;
-        /* establish http connection to server */
-        URL url = new URL("https://localhost:" + serverPort+"/file1");
-        System.out.println("url is "+url.toString());
-        HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
-        http = (HttpsURLConnection)url.openConnection();
-        int respCode = http.getResponseCode();
-        int cl = http.getContentLength();
-        InputStream is = http.getInputStream ();
-        int count = 0;
-        while (is.read() != -1 && count++ < cl);
-        System.out.println("respCode1 = "+respCode);
-        Thread.sleep(2000);
-        url = new URL("https://localhost:" + serverPort+"/file2");
-        http = (HttpsURLConnection)url.openConnection();
-        respCode = http.getResponseCode();
-        System.out.println("respCode2 = "+respCode);
-
-        } catch (IOException ioex) {
-            if (sslServerSocket != null)
-                sslServerSocket.close();
-            throw ioex;
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
+            try {
+                HttpsURLConnection http = null;
+                /* establish http connection to server */
+                URL url = new URL("https://localhost:" + serverPort+"/file1");
+                System.out.println("url is "+url.toString());
+                HttpsURLConnection.setDefaultHostnameVerifier(
+                                                        new NameVerifier());
+                http = (HttpsURLConnection)url.openConnection();
+                int respCode = http.getResponseCode();
+                int cl = http.getContentLength();
+                InputStream is = http.getInputStream ();
+                int count = 0;
+                while (is.read() != -1 && count++ < cl);
+                System.out.println("respCode1 = "+respCode);
+                Thread.sleep(2000);
+                url = new URL("https://localhost:" + serverPort+"/file2");
+                http = (HttpsURLConnection)url.openConnection();
+                respCode = http.getResponseCode();
+                System.out.println("respCode2 = "+respCode);
+            } catch (IOException ioex) {
+                if (sslServerSocket != null)
+                    sslServerSocket.close();
+                throw ioex;
+            }
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
     }
 
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/ComHTTPSConnection.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/ComHTTPSConnection.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4474255
  * @summary Can no longer obtain a com.sun.net.ssl.HttpsURLConnection
+ * @run main/othervm ComHTTPSConnection
  * @author Brad Wetmore
  */
 
@@ -198,44 +204,50 @@
             Thread.sleep(50);
         }
 
-        System.setProperty("java.protocol.handler.pkgs",
-            "com.sun.net.ssl.internal.www.protocol");
-        HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
-
-        URL url = new URL("https://" + "localhost:" + serverPort +
-                                "/etc/hosts");
-        URLConnection urlc = url.openConnection();
-
-        if (!(urlc instanceof com.sun.net.ssl.HttpsURLConnection)) {
-            throw new Exception(
-                "URLConnection ! instanceof " +
-                "com.sun.net.ssl.HttpsURLConnection");
-        }
-
-        BufferedReader in = null;
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            in = new BufferedReader(new InputStreamReader(
-                               urlc.getInputStream()));
-            String inputLine;
-            System.out.print("Client reading... ");
-            while ((inputLine = in.readLine()) != null)
-                System.out.println(inputLine);
-
-            System.out.println("Cipher Suite: " +
-                ((HttpsURLConnection)urlc).getCipherSuite());
-            X509Certificate[] certs =
-                ((HttpsURLConnection)urlc).getServerCertificateChain();
-            for (int i = 0; i < certs.length; i++) {
-                System.out.println(certs[0]);
+            System.setProperty("java.protocol.handler.pkgs",
+                "com.sun.net.ssl.internal.www.protocol");
+            HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
+
+            URL url = new URL("https://" + "localhost:" + serverPort +
+                                    "/etc/hosts");
+            URLConnection urlc = url.openConnection();
+
+            if (!(urlc instanceof com.sun.net.ssl.HttpsURLConnection)) {
+                throw new Exception(
+                    "URLConnection ! instanceof " +
+                    "com.sun.net.ssl.HttpsURLConnection");
             }
 
-            in.close();
-        } catch (SSLException e) {
-            if (in != null)
+            BufferedReader in = null;
+            try {
+                in = new BufferedReader(new InputStreamReader(
+                                   urlc.getInputStream()));
+                String inputLine;
+                System.out.print("Client reading... ");
+                while ((inputLine = in.readLine()) != null)
+                    System.out.println(inputLine);
+
+                System.out.println("Cipher Suite: " +
+                    ((HttpsURLConnection)urlc).getCipherSuite());
+                X509Certificate[] certs =
+                    ((HttpsURLConnection)urlc).getServerCertificateChain();
+                for (int i = 0; i < certs.length; i++) {
+                    System.out.println(certs[0]);
+                }
+
                 in.close();
-            throw e;
+            } catch (SSLException e) {
+                if (in != null)
+                    in.close();
+                throw e;
+            }
+            System.out.println("Client reports:  SUCCESS");
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
-        System.out.println("Client reports:  SUCCESS");
     }
 
     static class NameVerifier implements HostnameVerifier {
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/ComHostnameVerifier.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/ComHostnameVerifier.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4474255
@@ -28,6 +33,7 @@
  * @bug 4484246
  * @summary When an application enables anonymous SSL cipher suite,
  *        Hostname verification is not required
+ * @run main/othervm ComHostnameVerifier
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/JavaxHTTPSConnection.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/JavaxHTTPSConnection.java	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4474255
  * @summary Can no longer obtain a com.sun.net.ssl.HttpsURLConnection
+ * @run main/othervm JavaxHTTPSConnection
  * @author Brad Wetmore
  */
 
@@ -189,47 +195,53 @@
      * to avoid infinite hangs.
      */
     void doClientSide() throws Exception {
-        /*
-         * Wait for server to get started.
-         */
-        while (!serverReady) {
-            Thread.sleep(50);
-        }
-
-        HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
-        URL url = new URL("https://" + "localhost:" + serverPort +
-                                "/etc/hosts");
-        URLConnection urlc = url.openConnection();
-
-        if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
-            throw new Exception(
-                "URLConnection ! instanceof javax.net.ssl.HttpsURLConnection");
-        }
-
-        BufferedReader in = null;
+        HostnameVerifier reservedHV =
+            HttpsURLConnection.getDefaultHostnameVerifier();
         try {
-            in = new BufferedReader(new InputStreamReader(
-                               urlc.getInputStream()));
-            String inputLine;
-            System.out.print("Client reading... ");
-            while ((inputLine = in.readLine()) != null)
-                System.out.println(inputLine);
-
-            System.out.println("Cipher Suite: " +
-                ((HttpsURLConnection)urlc).getCipherSuite());
-            Certificate[] certs =
-                ((HttpsURLConnection)urlc).getServerCertificates();
-            for (int i = 0; i < certs.length; i++) {
-                System.out.println(certs[0]);
+            /*
+             * Wait for server to get started.
+             */
+            while (!serverReady) {
+                Thread.sleep(50);
+            }
+
+            HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());
+            URL url = new URL("https://" + "localhost:" + serverPort +
+                                    "/etc/hosts");
+            URLConnection urlc = url.openConnection();
+
+            if (!(urlc instanceof javax.net.ssl.HttpsURLConnection)) {
+                throw new Exception("URLConnection ! instanceof " +
+                                    "javax.net.ssl.HttpsURLConnection");
             }
 
-            in.close();
-        } catch (SSLException e) {
-            if (in != null)
+            BufferedReader in = null;
+            try {
+                in = new BufferedReader(new InputStreamReader(
+                                   urlc.getInputStream()));
+                String inputLine;
+                System.out.print("Client reading... ");
+                while ((inputLine = in.readLine()) != null)
+                    System.out.println(inputLine);
+
+                System.out.println("Cipher Suite: " +
+                    ((HttpsURLConnection)urlc).getCipherSuite());
+                Certificate[] certs =
+                    ((HttpsURLConnection)urlc).getServerCertificates();
+                for (int i = 0; i < certs.length; i++) {
+                    System.out.println(certs[0]);
+                }
+
                 in.close();
-            throw e;
+            } catch (SSLException e) {
+                if (in != null)
+                    in.close();
+                throw e;
+            }
+            System.out.println("Client reports:  SUCCESS");
+        } finally {
+            HttpsURLConnection.setDefaultHostnameVerifier(reservedHV);
         }
-        System.out.println("Client reports:  SUCCESS");
     }
 
     static class NameVerifier implements HostnameVerifier {
--- jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/JavaxHostnameVerifier.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/sun/net/www/protocol/https/NewImpl/JavaxHostnameVerifier.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,6 +21,11 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 4474255
@@ -28,6 +33,7 @@
  * @bug 4484246
  * @summary When an application enables anonymous SSL cipher suite,
  *        Hostname verification is not required
+ * @run main/othervm JavaxHostnameVerifier
  */
 
 import java.io.*;
--- jdk/test/sun/security/ssl/templates/SSLEngineTemplate.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/templates/SSLEngineTemplate.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,11 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 1234567
  * @summary SSLEngine has not yet caused Solaris kernel to panic
- *
+ * @run main/othervm SSLEngineTemplate
  */
 
 /**
--- jdk/test/sun/security/ssl/templates/SSLSocketTemplate.java	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/ssl/templates/SSLSocketTemplate.java	2013-05-05 09:38:46.000000000 -0700
@@ -21,10 +21,16 @@
  * questions.
  */
 
+//
+// SunJSSE does not support dynamic system properties, no way to re-use
+// system properties in samevm/agentvm mode.
+//
+
 /*
  * @test
  * @bug 1234567
  * @summary Use this template to help speed your client/server tests.
+ * @run main/othervm SSLSocketTemplate
  * @author Brad Wetmore
  */
 
--- jdk/test/sun/security/tools/jarsigner/AlgOptions.sh	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/tools/jarsigner/AlgOptions.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 5094028 6219522
+# @bug 5094028 6219522 7083664
 # @summary test new jarsigner -sigalg and -digestalg options
 # @author Sean Mullan
 #
@@ -46,26 +46,23 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
     CP="${FS}bin${FS}cp -f"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
     CP="cp -f"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
     CP="cp -f"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/jarsigner/PercentSign.sh	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/tools/jarsigner/PercentSign.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 6522933
+# @bug 6522933 7083664
 # @summary jarsigner fails in a directory with a path contianing a % sign
 # @author Wang Weijun
 #
@@ -46,26 +46,23 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
     CP="${FS}bin${FS}cp -f"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
     CP="cp -f"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
     CP="cp -f"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/jarsigner/diffend.sh	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/tools/jarsigner/diffend.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 6948909
+# @bug 6948909 7083664
 # @summary Jarsigner removes MANIFEST.MF info for badly packages jar's
 #
 
@@ -41,26 +41,23 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
     CP="${FS}bin${FS}cp -f"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
     CP="cp -f"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
     CP="cp -f"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/jarsigner/oldsig.sh	2012-08-10 10:37:03.000000000 -0700
+++ jdk/test/sun/security/tools/jarsigner/oldsig.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 6543940 6868865
+# @bug 6543940 6868865 7083664
 # @summary Exception thrown when signing a jarfile in java 1.5
 #
 # @run shell oldsig.sh
@@ -42,26 +42,23 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
     CP="${FS}bin${FS}cp -f"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
     CP="cp -f"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
     CP="cp -f"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/keytool/AltProviderPath.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/AltProviderPath.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4906940
+# @bug 4906940 7083664
 # @summary Add -providerPath option for keytool allowing one to specify
 #          an additional classpath to search for providers.
 # @author Andrew Fan
@@ -46,23 +46,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/keytool/CloneKeyAskPassword.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/CloneKeyAskPassword.sh	2013-05-05 09:38:46.000000000 -0700
@@ -47,15 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- jdk/test/sun/security/tools/keytool/NoExtNPE.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/NoExtNPE.sh	2013-05-05 09:38:46.000000000 -0700
@@ -42,13 +42,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FILESEP="/"
-    ;;
-  Linux )
-    FILESEP="/"
-    ;;
-  Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FILESEP="/"
     ;;
   CYGWIN* )
--- jdk/test/sun/security/tools/keytool/SecretKeyKS.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/SecretKeyKS.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4694076
+# @bug 4694076 7083664
 # @summary KeyTool throws ArrayIndexOutOfBoundsException for listing
 #          SecretKey entries in non-verbose mode.
 # @author Valerie Peng
@@ -45,23 +45,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/keytool/StandardAlgName.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/StandardAlgName.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test 1.1 04/11/12
-# @bug 4909889
+# @bug 4909889 7083664
 # @summary KeyTool accepts any input that user make as long as we can make some
 #          sense out of it, but when comes to present the info the user, it
 #          promotes a standard look.
@@ -46,23 +46,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
--- jdk/test/sun/security/tools/keytool/StartDateTest.java	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/StartDateTest.java	2013-05-05 09:38:46.000000000 -0700
@@ -132,7 +132,9 @@
 
     static Date getIssueDate() throws Exception {
         KeyStore ks = KeyStore.getInstance("jks");
-        ks.load(new FileInputStream("jks"), "changeit".toCharArray());
+        try (FileInputStream fis = new FileInputStream("jks")) {
+            ks.load(fis, "changeit".toCharArray());
+        }
         X509Certificate cert = (X509Certificate)ks.getCertificate("me");
         return cert.getNotBefore();
     }
--- jdk/test/sun/security/tools/keytool/autotest.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/autotest.sh	2013-05-05 09:38:46.000000000 -0700
@@ -72,6 +72,27 @@
         ;;
     esac
     ;;
+  *BSD | Darwin )
+    case "${OS}" in
+      *BSD )
+        LIBNAME=libsoftokn3.so
+        ;;
+      Darwin )
+        LIBNAME=libsoftokn3.dylib
+        ;;
+    esac
+    ARCH=`uname -m`
+    FS="/"
+    case "$ARCH" in
+      i[3-6]86 )
+        PF="bsd-i586"
+        ;;
+      * )
+        echo "Will not run test on: ${OS} ${ARCH}"
+        exit 0;
+        ;;
+    esac
+    ;;
   * )
     echo "Will not run test on: ${OS}"
     exit 0;
--- jdk/test/sun/security/tools/keytool/i18n.sh	2012-08-10 10:37:04.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/i18n.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4348369
+# @bug 4348369 7083664
 # @summary keytool not i18n compliant
 # @author charlie lai
 #
@@ -46,23 +46,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     PS=";"
     FS="/"
-    TMP=/tmp
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/keytool/printssl.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/printssl.sh	2013-05-05 09:38:46.000000000 -0700
@@ -37,7 +37,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- jdk/test/sun/security/tools/keytool/resource.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/resource.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 6239297
+# @bug 6239297 7083664
 # @summary keytool usage is broken after changing Resources.java
 # @author Max Wang
 #
@@ -43,20 +43,17 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     FS="/"
-    TMP=/tmp
     ;;
   CYGWIN* )
     NULL=/dev/null
     FS="/"
-    TMP=/tmp
     ;;
   Windows_* )
     NULL=NUL
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized operating system!"
@@ -65,13 +62,11 @@
 esac
 
 # the test code
-${TESTJAVA}${FS}bin${FS}keytool > ${TMP}${FS}temp_file_40875602475 2> ${NULL}
-grep MissingResourceException ${TMP}${FS}temp_file_40875602475
+${TESTJAVA}${FS}bin${FS}keytool > temp_file_40875602475 2> ${NULL}
+grep MissingResourceException temp_file_40875602475
 
 if [ $? -eq 0 ]; then
-    rm ${TMP}${FS}temp_file_40875602475
     exit 1
 fi
 
-rm ${TMP}${FS}temp_file_40875602475
 exit 0
--- jdk/test/sun/security/tools/keytool/standard.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/keytool/standard.sh	2013-05-05 09:38:46.000000000 -0700
@@ -44,7 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows_* )
--- jdk/test/sun/security/tools/policytool/Alias.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/Alias.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4449491
+# @bug 4449491 7083664
 # @summary policytool should allow principal type to be empty
 #               (keystore alias substitution)
 #
@@ -47,17 +47,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
     ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
+    ;;	
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/policytool/ChangeUI.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/ChangeUI.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug  6296772 6293981 6290216
+# @bug  6296772 6293981 6290216 7083664
 # @summary FilePermission and DelegationPermission, and cancel button
 #
 # @run applet/manual=done ChangeUI.html
@@ -46,17 +46,20 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/policytool/OpenPolicy.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/OpenPolicy.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4224186
+# @bug 4224186 7083664
 # @summary missing File.separatorChar when initially opening policy file
 #
 # @run applet/manual=done OpenPolicy.html
@@ -46,17 +46,21 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
+    CP="cp -f"
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/policytool/SaveAs.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/SaveAs.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4252583
+# @bug 4252583 7083664
 # @summary policytool throws FileNotFoundException when user tries to
 #               save new policy file
 #
@@ -47,17 +47,21 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
+    CP="cp -f"
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/policytool/UpdatePermissions.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/UpdatePermissions.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4218206
+# @bug 4218206 7083664
 # @summary missing or invalid permission target names in policy tool
 #
 # @run applet/manual=done UpdatePermissions.html
@@ -46,17 +46,21 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
+    CP="cp -f"
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/policytool/UsePolicy.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/UsePolicy.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4273771
+# @bug 4273771 7083664
 # @summary Need to add "usePolicy" RuntimePermission to policytool
 #
 # @run applet/manual=done UsePolicy.html
@@ -46,17 +46,21 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
+    CP="cp -f"
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/tools/policytool/i18n.sh	2012-08-10 10:37:05.000000000 -0700
+++ jdk/test/sun/security/tools/policytool/i18n.sh	2013-05-05 09:38:46.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 4348370
+# @bug 4348370 7083664
 # @summary policytool not i18n compliant
 #
 # @run applet/manual=done i18n.html
@@ -46,17 +46,21 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
-    TMP=/tmp
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=";"
+    FS="/"
+    CP="cp -f"
     ;;
   Windows* )
     NULL=NUL
     PS=";"
     FS="\\"
-    TMP="c:/temp"
     ;;
   * )
     echo "Unrecognized system!"
--- jdk/test/sun/security/util/Oid/S11N.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/sun/security/util/Oid/S11N.java	2013-05-05 09:38:46.000000000 -0700
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 4811968 6908628 8006564
+ * @run main S11N check
+ * @summary Serialization compatibility with old versions (and fixes)
+ */
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.HashMap;
+import java.util.Map;
+import sun.misc.BASE64Encoder;
+import sun.security.util.ObjectIdentifier;
+
+public class S11N {
+    static String[] SMALL= {
+        "0.0",
+        "1.1",
+        "2.2",
+        "1.2.3456",
+        "1.2.2147483647.4",
+        "1.2.268435456.4",
+    };
+
+    static String[] HUGE = {
+        "2.16.764.1.3101555394.1.0.100.2.1",
+        "1.2.2147483648.4",
+        "2.3.4444444444444444444444",
+        "1.2.8888888888888888.33333333333333333.44444444444444",
+    };
+
+    // Do not use j.u.Base64, the test needs to run in jdk6
+    static BASE64Encoder encoder = new BASE64Encoder() {
+        @Override
+        protected int bytesPerLine() {
+            return 48;
+        }
+    };
+
+    public static void main(String[] args) throws Exception {
+        if (args[0].equals("check")) {
+            int version = Integer.valueOf(System.getProperty("java.version")
+                    .split("\\.")[1]);
+            System.out.println("version is " + version);
+            if (version >= 7) {
+                for (String oid: SMALL) {
+                    // 7 -> 7
+                    check(out(oid), oid);
+                    // 6 -> 7
+                    check(out6(oid), oid);
+                }
+                for (String oid: HUGE) {
+                    // 7 -> 7
+                    check(out(oid), oid);
+                }
+            } else {
+                for (String oid: SMALL) {
+                    // 6 -> 6
+                    check(out(oid), oid);
+                    // 7 -> 6
+                    check(out7(oid), oid);
+                }
+                for (String oid: HUGE) {
+                    // 7 -> 6 fails for HUGE oids
+                    boolean ok = false;
+                    try {
+                        check(out7(oid), oid);
+                        ok = true;
+                    } catch (Exception e) {
+                        System.out.println(e);
+                    }
+                    if (ok) {
+                        throw new Exception();
+                    }
+                }
+            }
+        } else {
+            // Generates the JDK6 serialized string inside this test, call
+            //      $JDK7/bin/java S11N dump7
+            //      $JDK6/bin/java S11N dump6
+            // and paste the output at the end of this test.
+            dump(args[0], SMALL);
+            // For jdk6, the following line will throw an exception, ignore it
+            dump(args[0], HUGE);
+        }
+    }
+
+    // Gets the serialized form for jdk6
+    private static byte[] out6(String oid) throws Exception {
+        return new sun.misc.BASE64Decoder().decodeBuffer(dump6.get(oid));
+    }
+
+    // Gets the serialized form for jdk7
+    private static byte[] out7(String oid) throws Exception {
+        return new sun.misc.BASE64Decoder().decodeBuffer(dump7.get(oid));
+    }
+
+    // Gets the serialized form for this java
+    private static byte[] out(String oid) throws Exception {
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        new ObjectOutputStream(bout).writeObject(new ObjectIdentifier(oid));
+        return bout.toByteArray();
+    }
+
+    // Makes sure serialized form can be deserialized
+    private static void check(byte[] in, String oid) throws Exception {
+        ObjectIdentifier o = (ObjectIdentifier) (
+                new ObjectInputStream(new ByteArrayInputStream(in)).readObject());
+        if (!o.toString().equals(oid)) {
+            throw new Exception("Read Fail " + o + ", not " + oid);
+        }
+    }
+
+    // dump serialized form to java code style text
+    private static void dump(String title, String[] oids) throws Exception {
+        for (String oid: oids) {
+            String[] base64 = encoder.encodeBuffer(out(oid)).split("\n");
+            System.out.println("        " + title + ".put(\"" + oid + "\",");
+            for (int i = 0; i<base64.length; i++) {
+                System.out.print("            \"" + base64[i] + "\"");
+                if (i == base64.length - 1) {
+                    System.out.println(");");
+                } else {
+                    System.out.println(" +");
+                }
+            }
+        }
+    }
+
+    // Do not use diamond operator, this test is also meant to run in jdk6
+    private static Map<String,String> dump7 = new HashMap<String,String>();
+    private static Map<String,String> dump6 = new HashMap<String,String>();
+
+    static {
+        //////////////  PASTE BEGIN //////////////
+        dump7.put("0.0",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhwAAAAAnVyAAJbSU26YCZ26rKlAgAAeHAA" +
+            "AAACAAAAAAAAAAB1cgACW0Ks8xf4BghU4AIAAHhwAAAAAQB4");
+        dump7.put("1.1",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhwAAAAAnVyAAJbSU26YCZ26rKlAgAAeHAA" +
+            "AAACAAAAAQAAAAF1cgACW0Ks8xf4BghU4AIAAHhwAAAAASl4");
+        dump7.put("2.2",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhwAAAAAnVyAAJbSU26YCZ26rKlAgAAeHAA" +
+            "AAACAAAAAgAAAAJ1cgACW0Ks8xf4BghU4AIAAHhwAAAAAVJ4");
+        dump7.put("1.2.3456",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhwAAAAA3VyAAJbSU26YCZ26rKlAgAAeHAA" +
+            "AAADAAAAAQAAAAIAAA2AdXIAAltCrPMX+AYIVOACAAB4cAAAAAMqmwB4");
+        dump7.put("1.2.2147483647.4",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhwAAAABHVyAAJbSU26YCZ26rKlAgAAeHAA" +
+            "AAAEAAAAAQAAAAJ/////AAAABHVyAAJbQqzzF/gGCFTgAgAAeHAAAAAHKof///9/" +
+            "BHg=");
+        dump7.put("1.2.268435456.4",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhwAAAABHVyAAJbSU26YCZ26rKlAgAAeHAA" +
+            "AAAEAAAAAQAAAAIQAAAAAAAABHVyAAJbQqzzF/gGCFTgAgAAeHAAAAAHKoGAgIAA" +
+            "BHg=");
+        dump7.put("2.16.764.1.3101555394.1.0.100.2.1",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhw/////3NyAD5zdW4uc2VjdXJpdHkudXRp" +
+            "bC5PYmplY3RJZGVudGlmaWVyJEh1Z2VPaWROb3RTdXBwb3J0ZWRCeU9sZEpESwAA" +
+            "AAAAAAABAgAAeHB1cgACW0Ks8xf4BghU4AIAAHhwAAAADmCFfAGLxvf1QgEAZAIB" +
+            "eA==");
+        dump7.put("1.2.2147483648.4",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhw/////3NyAD5zdW4uc2VjdXJpdHkudXRp" +
+            "bC5PYmplY3RJZGVudGlmaWVyJEh1Z2VPaWROb3RTdXBwb3J0ZWRCeU9sZEpESwAA" +
+            "AAAAAAABAgAAeHB1cgACW0Ks8xf4BghU4AIAAHhwAAAAByqIgICAAAR4");
+        dump7.put("2.3.4444444444444444444444",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhw/////3NyAD5zdW4uc2VjdXJpdHkudXRp" +
+            "bC5PYmplY3RJZGVudGlmaWVyJEh1Z2VPaWROb3RTdXBwb3J0ZWRCeU9sZEpESwAA" +
+            "AAAAAAABAgAAeHB1cgACW0Ks8xf4BghU4AIAAHhwAAAADFOD4e+HpNG968eOHHg=");
+        dump7.put("1.2.8888888888888888.33333333333333333.44444444444444",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4DAANJAAxjb21wb25lbnRMZW5MAApjb21wb25lbnRzdAASTGphdmEvbGFuZy9P" +
+            "YmplY3Q7WwAIZW5jb2Rpbmd0AAJbQnhw/////3NyAD5zdW4uc2VjdXJpdHkudXRp" +
+            "bC5PYmplY3RJZGVudGlmaWVyJEh1Z2VPaWROb3RTdXBwb3J0ZWRCeU9sZEpESwAA" +
+            "AAAAAAABAgAAeHB1cgACW0Ks8xf4BghU4AIAAHhwAAAAGCqP5Yzbxa6cOLubj9ek" +
+            "japVio3AusuOHHg=");
+
+        dump6.put("0.0",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4CAAJJAAxjb21wb25lbnRMZW5bAApjb21wb25lbnRzdAACW0l4cAAAAAJ1cgAC" +
+            "W0lNumAmduqypQIAAHhwAAAAAgAAAAAAAAAA");
+        dump6.put("1.1",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4CAAJJAAxjb21wb25lbnRMZW5bAApjb21wb25lbnRzdAACW0l4cAAAAAJ1cgAC" +
+            "W0lNumAmduqypQIAAHhwAAAAAgAAAAEAAAAB");
+        dump6.put("2.2",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4CAAJJAAxjb21wb25lbnRMZW5bAApjb21wb25lbnRzdAACW0l4cAAAAAJ1cgAC" +
+            "W0lNumAmduqypQIAAHhwAAAAAgAAAAIAAAAC");
+        dump6.put("1.2.3456",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4CAAJJAAxjb21wb25lbnRMZW5bAApjb21wb25lbnRzdAACW0l4cAAAAAN1cgAC" +
+            "W0lNumAmduqypQIAAHhwAAAAAwAAAAEAAAACAAANgA==");
+        dump6.put("1.2.2147483647.4",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4CAAJJAAxjb21wb25lbnRMZW5bAApjb21wb25lbnRzdAACW0l4cAAAAAR1cgAC" +
+            "W0lNumAmduqypQIAAHhwAAAABAAAAAEAAAACf////wAAAAQ=");
+        dump6.put("1.2.268435456.4",
+            "rO0ABXNyACJzdW4uc2VjdXJpdHkudXRpbC5PYmplY3RJZGVudGlmaWVyeLIO7GQX" +
+            "fy4CAAJJAAxjb21wb25lbnRMZW5bAApjb21wb25lbnRzdAACW0l4cAAAAAR1cgAC" +
+            "W0lNumAmduqypQIAAHhwAAAABAAAAAEAAAACEAAAAAAAAAQ=");
+        //////////////  PASTE END //////////////
+    }
+}
--- jdk/test/sun/security/util/Oid/S11N.sh	2012-08-10 10:37:06.000000000 -0700
+++ jdk/test/sun/security/util/Oid/S11N.sh	1969-12-31 16:00:00.000000000 -0800
@@ -1,185 +0,0 @@
-#
-# Copyright (c) 2004, 2009, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-# @test
-# @bug 4811968 6908628
-# @summary Serialization compatibility with old versions (and fix)
-# @author Weijun Wang
-#
-# set a few environment variables so that the shell-script can run stand-alone
-# in the source directory
-
-if [ "${TESTSRC}" = "" ] ; then
-  TESTSRC="."
-fi
-if [ "${TESTCLASSES}" = "" ] ; then
-  TESTCLASSES="."
-fi
-if [ "${TESTJAVA}" = "" ] ; then
-  echo "TESTJAVA not set.  Test cannot execute."
-  echo "FAILED!!!"
-  exit 1
-fi
-
-# set platform-dependent variables
-PF=""
-
-OS=`uname -s`
-case "$OS" in
-  SunOS )
-    FS="/"
-    ARCH=`isainfo`
-    case "$ARCH" in
-      sparc* )
-        PF="solaris-sparc"
-        ;;
-      i[3-6]86 )
-        PF="solaris-i586"
-        ;;
-      amd64* )
-        PF="solaris-amd64"
-        ;;
-      * )
-        echo "Unsupported System: Solaris ${ARCH}"
-        exit 0;
-        ;;
-    esac
-    ;;
-  Linux )
-    ARCH=`uname -m`
-    FS="/"
-    case "$ARCH" in
-      i[3-6]86 )
-        PF="linux-i586"
-        ;;
-      amd64* | x86_64 )
-        PF="linux-amd64"
-        ;;
-      * )
-        echo "Unsupported System: Linux ${ARCH}"
-        exit 0;
-        ;;
-    esac
-    ;;
-  Windows* )
-    FS="\\"
-    PF="windows-i586"
-
-    # 'uname -m' does not give us enough information -
-    #  should rely on $PROCESSOR_IDENTIFIER (as is done in Defs-windows.gmk),
-    #  but JTREG does not pass this env variable when executing a shell script.
-    #
-    #  execute test program - rely on it to exit if platform unsupported
-
-    ;;
-  * )
-    echo "Unsupported System: ${OS}"
-    exit 0;
-    ;;
-esac
-
-echo "==================================================="
-echo "Try to set ALT_JAVA_RE_JDK if you see timeout error"
-echo "==================================================="
-
-# the test code
-
-${TESTJAVA}${FS}bin${FS}javac -target 1.4 -source 1.4 \
-        -d . ${TESTSRC}${FS}SerialTest.java || exit 10
-
-# You can set ALT_JAVA_RE_JDK to another location that contains the
-# binaries for older JDK releases. You can set it to a non-existent
-# directory to skip the interop tests between different versions.
-
-if [ "$ALT_JAVA_RE_JDK" = "" ]; then
-    JAVA_RE_JDK=/java/re/j2se
-else
-    JAVA_RE_JDK=$ALT_JAVA_RE_JDK
-fi
-
-OLDJAVA="
-    $JAVA_RE_JDK/1.6.0/latest/binaries/${PF}
-    $JAVA_RE_JDK/1.5.0/latest/binaries/${PF}
-    $JAVA_RE_JDK/1.4.2/latest/binaries/${PF}
-"
-
-SMALL="
-    0.0
-    1.1
-    2.2
-    1.2.3456
-    1.2.2147483647.4
-    1.2.268435456.4
-"
-
-HUGE="
-    2.16.764.1.3101555394.1.0.100.2.1
-    1.2.2147483648.4
-    2.3.4444444444444444444444
-    1.2.888888888888888888.111111111111111.2222222222222.33333333333333333.44444444444444
-"
-
-for oid in ${SMALL}; do
-    echo ${oid}
-    # new ->
-    ${TESTJAVA}${FS}bin${FS}java SerialTest out ${oid} > tmp.oid.serial || exit 1
-    # -> new
-    ${TESTJAVA}${FS}bin${FS}java SerialTest in ${oid} < tmp.oid.serial || exit 2
-    for oldj in ${OLDJAVA}; do
-        if [ -d ${oldj} ]; then
-            echo ${oldj}
-            # -> old
-            ${oldj}${FS}bin${FS}java SerialTest in ${oid} < tmp.oid.serial || exit 3
-            # old ->
-            ${oldj}${FS}bin${FS}java SerialTest out ${oid} > tmp.oid.serial.old || exit 4
-            # -> new
-            ${TESTJAVA}${FS}bin${FS}java SerialTest in ${oid} < tmp.oid.serial.old || exit 5
-        fi
-    done
-done
-
-for oid in ${HUGE}; do
-    echo ${oid}
-    # new ->
-    ${TESTJAVA}${FS}bin${FS}java SerialTest out ${oid} > tmp.oid.serial || exit 1
-    # -> new
-    ${TESTJAVA}${FS}bin${FS}java SerialTest in ${oid} < tmp.oid.serial || exit 2
-    for oldj in ${OLDJAVA}; do
-        if [ -d ${oldj} ]; then
-            echo ${oldj}
-            # -> old
-            ${oldj}${FS}bin${FS}java SerialTest badin < tmp.oid.serial || exit 3
-        fi
-    done
-done
-
-rm -f tmp.oid.serial
-rm -f tmp.oid.serial.old
-rm -f SerialTest.class
-
-for oldj in ${OLDJAVA}; do
-    if [ ! -d ${oldj} ]; then
-        echo WARNING: ${oldj} is missing. Test incomplete! > /dev/stderr
-    fi
-done
-
-exit 0
--- jdk/test/sun/security/util/Oid/SerialTest.java	2012-08-10 10:37:06.000000000 -0700
+++ jdk/test/sun/security/util/Oid/SerialTest.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * read S11.sh
- */
-import java.io.*;
-import sun.security.util.*;
-
-/**
- * Test OID serialization between versions
- *
- * java SerialTest out oid  // write a OID into System.out
- * java SerialTest in oid   // read from System.in and compare it with oid
- * java SerialTest badin    // make sure *cannot* read from System.in
- */
-class SerialTest {
-    public static void main(String[] args) throws Exception {
-        if (args[0].equals("out"))
-            out(args[1]);
-        else if (args[0].equals("in"))
-            in(args[1]);
-        else
-            badin();
-    }
-
-    static void in(String oid) throws Exception {
-        ObjectIdentifier o = (ObjectIdentifier) (new ObjectInputStream(System.in).readObject());
-        if (!o.toString().equals(oid))
-            throw new Exception("Read Fail " + o + ", not " + oid);
-    }
-
-    static void badin() throws Exception {
-        boolean pass = true;
-        try {
-            new ObjectInputStream(System.in).readObject();
-        } catch (Exception e) {
-            pass = false;
-        }
-        if (pass) throw new Exception("Should fail but not");
-    }
-
-    static void out(String oid) throws Exception {
-        new ObjectOutputStream(System.out).writeObject(new ObjectIdentifier(oid));
-    }
-}
--- jdk/test/sun/security/x509/AlgorithmId/ExtensibleAlgorithmId.java	2012-08-10 10:37:06.000000000 -0700
+++ jdk/test/sun/security/x509/AlgorithmId/ExtensibleAlgorithmId.java	2013-05-05 09:38:46.000000000 -0700
@@ -24,9 +24,12 @@
 /*
  * @test
  * @bug 4162868
+ * @run main/othervm ExtensibleAlgorithmId
  * @summary Algorithm Name-to-OID mapping needs to be made extensible.
  */
 
+// Run in othervm, coz AlgorithmId.oidTable is only initialized once
+
 import java.security.*;
 import sun.security.x509.AlgorithmId;
 
--- jdk/test/sun/tools/common/ApplicationSetup.sh	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/common/ApplicationSetup.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 #
-# Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -43,7 +43,7 @@
 {
   appOutput="${TESTCLASSES}/Application.out"
 
-  ${JAVA} -XX:+UsePerfData -classpath "${TESTCLASSES}" "$@" > "$appOutput" 2>&1 &
+  ${JAVA} -XX:+UsePerfData -classpath "${TESTCLASSPATH:-${TESTCLASSES}}" "$@" > "$appOutput" 2>&1 &
   appJavaPid="$!"
   appOtherPid=
   appPidList="$appJavaPid"
@@ -131,7 +131,7 @@
 #
 stopApplication()
 {
-  $JAVA -XX:+UsePerfData -classpath "${TESTCLASSES}" ShutdownSimpleApplication $1
+  $JAVA -XX:+UsePerfData -classpath "${TESTCLASSPATH:-${TESTCLASSES}}" ShutdownSimpleApplication $1
 }
 
 
--- jdk/test/sun/tools/jcmd/help_help.out	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/help_help.out	2013-05-05 09:38:47.000000000 -0700
@@ -1,7 +1,7 @@
 help
 For more information about a specific command use 'help <command>'. With no argument this will show a list of available commands. 'help all' will show help for all commands.
 
-Impact: Low: 
+Impact: Low 
 
 Syntax : help [options] [<command name>]
 
--- jdk/test/sun/tools/jcmd/jcmd-Defaults.sh	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/jcmd-Defaults.sh	2013-05-05 09:38:47.000000000 -0700
@@ -28,6 +28,6 @@
 
 JCMD="${TESTJAVA}/bin/jcmd"
 
-${JCMD} 2>&1 | awk -f ${TESTSRC}/jcmd_Output1.awk
+${JCMD} -J-XX:+UsePerfData 2>&1 | awk -f ${TESTSRC}/jcmd_Output1.awk
 
-${JCMD} -l 2>&1 | awk -f ${TESTSRC}/jcmd_Output1.awk
+${JCMD} -J-XX:+UsePerfData -l 2>&1 | awk -f ${TESTSRC}/jcmd_Output1.awk
--- jdk/test/sun/tools/jcmd/jcmd-f.sh	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/jcmd-f.sh	2013-05-05 09:38:47.000000000 -0700
@@ -46,7 +46,7 @@
 
 # -f <script>
 rm -f jcmd.out 2>/dev/null
-${JCMD} $appJavaPid -f ${TESTSRC}/dcmd-script.txt | awk '{ if (NR>1) print $0;}' > jcmd.out 2>&1
+${JCMD} -J-XX:+UsePerfData $appJavaPid -f ${TESTSRC}/dcmd-script.txt | awk '{ if (NR>1) print $0;}' > jcmd.out 2>&1
 echo jcmd.out
 diff -w jcmd.out ${TESTSRC}/help_help.out
 if [ $? != 0 ]; then
--- jdk/test/sun/tools/jcmd/jcmd-help-help.sh	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/jcmd-help-help.sh	2013-05-05 09:38:47.000000000 -0700
@@ -46,7 +46,7 @@
 
 # help help
 rm -f jcmd.out 2>/dev/null
-${JCMD} $appJavaPid help help | awk '{ if (NR>1) print $0;}' > jcmd.out 2>&1
+${JCMD} -J-XX:+UsePerfData $appJavaPid help help | awk '{ if (NR>1) print $0;}' > jcmd.out 2>&1
 echo jcmd.out
 diff -w jcmd.out ${TESTSRC}/help_help.out
 if [ $? != 0 ]; then
--- jdk/test/sun/tools/jcmd/jcmd-help.sh	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/jcmd-help.sh	2013-05-05 09:38:47.000000000 -0700
@@ -29,7 +29,7 @@
 JCMD="${TESTJAVA}/bin/jcmd"
 
 rm -f jcmd.out 2>/dev/null
-${JCMD} -h > jcmd.out 2>&1
+${JCMD} -J-XX:+UsePerfData -h > jcmd.out 2>&1
 
 diff -w jcmd.out ${TESTSRC}/usage.out
 if [ $? != 0 ]
@@ -40,7 +40,7 @@
 fi
 
 rm -f jcmd.out 2>/dev/null
-${JCMD} -help > jcmd.out 2>&1
+${JCMD} -J-XX:+UsePerfData -help > jcmd.out 2>&1
 
 diff -w jcmd.out ${TESTSRC}/usage.out
 if [ $? != 0 ]
--- jdk/test/sun/tools/jcmd/jcmd-pid.sh	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/jcmd-pid.sh	2013-05-05 09:38:47.000000000 -0700
@@ -45,11 +45,11 @@
 failed=0
 
 # help command 
-${JCMD} $appJavaPid help 2>&1 | awk -f ${TESTSRC}/jcmd_pid_Output1.awk
+${JCMD} -J-XX:+UsePerfData $appJavaPid help 2>&1 | awk -f ${TESTSRC}/jcmd_pid_Output1.awk
 if [ $? != 0 ]; then failed=1; fi
 
 # PerfCounter.list option
-${JCMD} $appJavaPid PerfCounter.print 2>&1 | awk -f ${TESTSRC}/jcmd_pid_Output2.awk
+${JCMD} -J-XX:+UsePerfData $appJavaPid PerfCounter.print 2>&1 | awk -f ${TESTSRC}/jcmd_pid_Output2.awk
 if [ $? != 0 ]; then failed=1; fi
 
 set -e
--- jdk/test/sun/tools/jcmd/jcmd_Output1.awk	2012-08-10 10:37:07.000000000 -0700
+++ jdk/test/sun/tools/jcmd/jcmd_Output1.awk	2013-05-05 09:38:47.000000000 -0700
@@ -1,26 +1,31 @@
 #
 BEGIN	{
-	    totallines=0; matched=0
+            totallines=0; matched=0; current=0
 	}
 
 # match on a main class name followed by arbitrary arguments
 /^[0-9]+ [a-z|A-Z][a-z|A-Z|0-9|\.]*($| .*$)/	{
-	    matched++;
+	    current=1;
 	}
 
 # or match on a path name to a jar file followed by arbitraty arguments
 # - note, jar files ending with ".jar" is only a convention, not a requirement.
 #Theoretically, any valid file name could occur here.
 /^[0-9]+ .*\.jar($| .*$)/	{
-	    matched++;
+	    current=1;
 }
 
 # or match on the condition that the class name is not available
-/^[0-9]+ -- process information unavailable$/	{
-	    matched++;
+/^[0-9]+ -- .*$/	{
+	    current=1;
 	}
 
-	{ totallines++; print $0 }
+# or match an empty class name
+/^[0-9]+ $/	{
+	    current=1;
+	}
+
+	{ totallines++; matched+=current; current=0; print $0 }
 
 END	{
 	    if ((totallines > 0) && (matched == totallines)) {
--- jdk/test/sun/tools/jconsole/ImmutableResourceTest.sh	2012-08-10 10:37:09.000000000 -0700
+++ jdk/test/sun/tools/jconsole/ImmutableResourceTest.sh	2013-05-05 09:38:47.000000000 -0700
@@ -53,7 +53,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux | Darwin )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- jdk/test/sun/tools/jconsole/ResourceCheckTest.sh	2012-08-10 10:37:09.000000000 -0700
+++ jdk/test/sun/tools/jconsole/ResourceCheckTest.sh	2013-05-05 09:38:47.000000000 -0700
@@ -54,7 +54,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- jdk/test/sun/tools/jinfo/Basic.sh	2012-08-10 10:37:09.000000000 -0700
+++ jdk/test/sun/tools/jinfo/Basic.sh	2013-05-05 09:38:47.000000000 -0700
@@ -44,7 +44,20 @@
 
 failed=0
 
-if [ $isWindows = false ]; then
+# Skip SA options for now, see 7175133
+runSA=false
+
+if [ $isLinux = true ]; then
+    # Some Linux systems disable non-child ptrace (see 7050524)
+    ptrace_scope=`/sbin/sysctl -n kernel.yama.ptrace_scope`
+    if [ $? = 0 ]; then
+        if [ $ptrace_scope = 1 ]; then
+            runSA=false
+        fi
+    fi
+fi
+
+if [ $runSA = true ]; then
     # -sysprops option
     ${JINFO} -J-XX:+UsePerfData -sysprops $appJavaPid
     if [ $? != 0 ]; then failed=1; fi
--- jdk/test/sun/tools/jps/jps-Vvml_2.sh	2012-08-10 10:37:09.000000000 -0700
+++ jdk/test/sun/tools/jps/jps-Vvml_2.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -51,7 +51,7 @@
 # and we can not set -XX:+UsePerfData as that invalidates the test premise of
 # there being no jvm flags
 
-${JAVA} -cp ${TESTCLASSES} Sleeper &
+${JAVA} -cp ${TESTCLASSPATH:-${TESTCLASSES}} Sleeper &
 SLEEPER_PID=$!
 
 ${JPS} -J-XX:Flags=${TESTSRC}/vmflags -Vvml | awk -f ${TESTSRC}/jps-Vvml_Output2.awk
--- jdk/test/sun/tools/jps/jps-l_Output1.awk	2012-08-10 10:37:09.000000000 -0700
+++ jdk/test/sun/tools/jps/jps-l_Output1.awk	2013-05-05 09:38:47.000000000 -0700
@@ -16,7 +16,12 @@
 }
 
 # or match on the condition that the class name is not available
-/^[0-9]+ -- process information unavailable$/	{
+/^[0-9]+ -- .*$/	{
+	    matched++;
+	}
+
+# or match an empty class name
+/^[0-9]+ $/	{
 	    matched++;
 	}
 
--- jdk/test/sun/tools/jps/jps-m_2.sh	2012-08-10 10:37:10.000000000 -0700
+++ jdk/test/sun/tools/jps/jps-m_2.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -46,7 +46,7 @@
 # any args to Sleeper.main(), as we need to inspect jps output
 # for the no args condition.
 #
-${JAVA} -XX:+UsePerfData -cp ${TESTCLASSES} Sleeper &
+${JAVA} -XX:+UsePerfData -cp ${TESTCLASSPATH:-${TESTCLASSES}} Sleeper &
 SLEEPER_PID=$!
 
 ${JPS} -J-XX:+UsePerfData -m | awk -f ${TESTSRC}/jps-m_Output2.awk
--- jdk/test/sun/tools/jps/jps_Output1.awk	2012-08-10 10:37:10.000000000 -0700
+++ jdk/test/sun/tools/jps/jps_Output1.awk	2013-05-05 09:38:47.000000000 -0700
@@ -16,7 +16,12 @@
 }
 
 # or match on the condition that the class name is not available
-/^[0-9]+ -- process information unavailable$/	{
+/^[0-9]+ -- .*$/	{
+	    matched++;
+	}
+
+# or match an empty class name
+/^[0-9]+ $/	{
 	    matched++;
 	}
 
--- jdk/test/sun/tools/jstat/jstatClassOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatClassOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -class 0 2>&1 | awk -f ${TESTSRC}/classOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -class 0 2>&1 | awk -f ${TESTSRC}/classOutput1.awk
--- jdk/test/sun/tools/jstat/jstatClassloadOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatClassloadOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -classload -J-Djstat.showUnsupported=true 0 2>&1 | awk -f ${TESTSRC}/classloadOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -classload -J-Djstat.showUnsupported=true 0 2>&1 | awk -f ${TESTSRC}/classloadOutput1.awk
--- jdk/test/sun/tools/jstat/jstatCompilerOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatCompilerOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -compiler 0 2>&1 | awk -f ${TESTSRC}/compilerOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -compiler 0 2>&1 | awk -f ${TESTSRC}/compilerOutput1.awk
--- jdk/test/sun/tools/jstat/jstatFileURITest1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatFileURITest1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -40,12 +40,12 @@
     # characters into forward slash characters in an effort to convert
     # TESTSRC into a canonical form useable as URI path.
     cp ${TESTSRC}/hsperfdata_3433 .
-    ${JSTAT} -J-XX:+UsePerfData -gcutil file:/`pwd`/hsperfdata_3433 2>&1 | awk -f ${TESTSRC}/fileURITest1.awk
+    ${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil file:/`pwd`/hsperfdata_3433 2>&1 | awk -f ${TESTSRC}/fileURITest1.awk
     RC=$?
     rm -f hsperfdata_3433 2>&1 > /dev/null
     ;;
 *)
-    ${JSTAT} -J-XX:+UsePerfData -gcutil file:${TESTSRC}/hsperfdata_3433 2>&1 | awk -f ${TESTSRC}/fileURITest1.awk
+    ${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil file:${TESTSRC}/hsperfdata_3433 2>&1 | awk -f ${TESTSRC}/fileURITest1.awk
     RC=$?
     ;;
 esac
--- jdk/test/sun/tools/jstat/jstatGcCapacityOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcCapacityOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gccapacity 0 2>&1 | awk -f ${TESTSRC}/gcCapacityOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gccapacity 0 2>&1 | awk -f ${TESTSRC}/gcCapacityOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcCauseOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcCauseOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -37,4 +37,4 @@
 # class machine, ergonomics will automatically use UseParallelGC.
 # The UseParallelGC collector does not currently update the gc cause counters.
 
-${JSTAT} -J-XX:+UsePerfData -J-XX:+UseSerialGC -gccause 0 2>&1 | awk -f ${TESTSRC}/gcCauseOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -J-XX:+UseSerialGC -gccause 0 2>&1 | awk -f ${TESTSRC}/gcCauseOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcNewCapacityOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcNewCapacityOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcnewcapacity 0 2>&1 | awk -f ${TESTSRC}/gcNewCapacityOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcnewcapacity 0 2>&1 | awk -f ${TESTSRC}/gcNewCapacityOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcNewOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcNewOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcnew 0 2>&1 | awk -f ${TESTSRC}/gcNewOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcnew 0 2>&1 | awk -f ${TESTSRC}/gcNewOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcOldCapacityOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcOldCapacityOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcoldcapacity 0 2>&1 | awk -f ${TESTSRC}/gcOldCapacityOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcoldcapacity 0 2>&1 | awk -f ${TESTSRC}/gcOldCapacityOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcOldOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcOldOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcold 0 2>&1 | awk -f ${TESTSRC}/gcOldOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcold 0 2>&1 | awk -f ${TESTSRC}/gcOldOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gc 0 2>&1 | awk -f ${TESTSRC}/gcOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gc 0 2>&1 | awk -f ${TESTSRC}/gcOutput1.awk
--- jdk/test/sun/tools/jstat/jstatGcPermCapacityOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatGcPermCapacityOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcpermcapacity 0 2>&1 | awk -f ${TESTSRC}/gcPermCapacityOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcpermcapacity 0 2>&1 | awk -f ${TESTSRC}/gcPermCapacityOutput1.awk
--- jdk/test/sun/tools/jstat/jstatLineCounts1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatLineCounts1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcutil 0 250 5 2>&1 | awk -f ${TESTSRC}/lineCounts1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil 0 250 5 2>&1 | awk -f ${TESTSRC}/lineCounts1.awk
--- jdk/test/sun/tools/jstat/jstatLineCounts2.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatLineCounts2.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcutil 0 2>&1 | awk -f ${TESTSRC}/lineCounts2.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil 0 2>&1 | awk -f ${TESTSRC}/lineCounts2.awk
--- jdk/test/sun/tools/jstat/jstatLineCounts3.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatLineCounts3.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcutil -h 10 0 250 10 2>&1 | awk -f ${TESTSRC}/lineCounts3.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil -h 10 0 250 10 2>&1 | awk -f ${TESTSRC}/lineCounts3.awk
--- jdk/test/sun/tools/jstat/jstatLineCounts4.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatLineCounts4.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcutil -h 10 0 250 11 2>&1 | awk -f ${TESTSRC}/lineCounts4.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil -h 10 0 250 11 2>&1 | awk -f ${TESTSRC}/lineCounts4.awk
--- jdk/test/sun/tools/jstat/jstatOptions1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatOptions1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,8 +33,8 @@
 JSTAT="${TESTJAVA}/bin/jstat"
 
 rm -f jstat.out1 jstat.out2 2>/dev/null
-${JSTAT} -J-XX:+UsePerfData -options > jstat.out1 2>&1
-${JSTAT} -J-XX:+UsePerfData -options -J-Djstat.showUnsupported=true > jstat.out2 2>&1
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -options > jstat.out1 2>&1
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -options -J-Djstat.showUnsupported=true > jstat.out2 2>&1
 
 diff -w jstat.out1 ${TESTSRC}/options1.out
 diff -w jstat.out2 ${TESTSRC}/options2.out
--- jdk/test/sun/tools/jstat/jstatPrintCompilationOutput1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatPrintCompilationOutput1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -35,4 +35,4 @@
 
 # run with -Xcomp as jstat may complete too quickly to assure
 # that compilation occurs.
-${JSTAT} -J-XX:+UsePerfData -J-Xcomp -printcompilation 0 2>&1 | awk -f ${TESTSRC}/printCompilationOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -J-Xcomp -printcompilation 0 2>&1 | awk -f ${TESTSRC}/printCompilationOutput1.awk
--- jdk/test/sun/tools/jstat/jstatSnap1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatSnap1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -snap 0 2>&1 | awk -f ${TESTSRC}/snap1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -snap 0 2>&1 | awk -f ${TESTSRC}/snap1.awk
--- jdk/test/sun/tools/jstat/jstatSnap2.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatSnap2.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -J-Djstat.showUnsupported=true -snap 0 2>&1 | awk -f ${TESTSRC}/snap2.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -J-Djstat.showUnsupported=true -snap 0 2>&1 | awk -f ${TESTSRC}/snap2.awk
--- jdk/test/sun/tools/jstat/jstatTimeStamp1.sh	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstat/jstatTimeStamp1.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -33,4 +33,4 @@
 
 JSTAT="${TESTJAVA}/bin/jstat"
 
-${JSTAT} -J-XX:+UsePerfData -gcutil -t 0 2>&1 | awk -f ${TESTSRC}/timeStamp1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil -t 0 2>&1 | awk -f ${TESTSRC}/timeStamp1.awk
--- jdk/test/sun/tools/jstatd/jpsOutput1.awk	2012-08-10 10:37:11.000000000 -0700
+++ jdk/test/sun/tools/jstatd/jpsOutput1.awk	2013-05-05 09:38:47.000000000 -0700
@@ -7,7 +7,11 @@
 	    matched++;
 	}
 
-/^[0-9]+ -- process information unavailable$/	{
+/^[0-9]+ -- .*$/	{
+	    matched++;
+	}
+
+/^[0-9]+ $/	{
 	    matched++;
 	}
 
--- jdk/test/sun/tools/jstatd/jstatdDefaults.sh	2012-08-10 10:37:12.000000000 -0700
+++ jdk/test/sun/tools/jstatd/jstatdDefaults.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -60,7 +60,7 @@
     exit 1
 fi
 
-${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_PID}@${HOSTNAME} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_PID}@${HOSTNAME} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
 RC=$?
 
 if [ ${RC} -ne 0 ]
--- jdk/test/sun/tools/jstatd/jstatdExternalRegistry.sh	2012-08-10 10:37:12.000000000 -0700
+++ jdk/test/sun/tools/jstatd/jstatdExternalRegistry.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -73,7 +73,7 @@
     exit 1
 fi
 
-${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_PID}@${HOSTNAME}:${PORT} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_PID}@${HOSTNAME}:${PORT} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
 RC=$?
 
 if [ ${RC} -ne 0 ]
--- jdk/test/sun/tools/jstatd/jstatdPort.sh	2012-08-10 10:37:12.000000000 -0700
+++ jdk/test/sun/tools/jstatd/jstatdPort.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -65,7 +65,7 @@
     exit 1
 fi
 
-${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_PID}@${HOSTNAME}:${PORT} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_PID}@${HOSTNAME}:${PORT} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
 RC=$?
 
 if [ ${RC} -ne 0 ]
--- jdk/test/sun/tools/jstatd/jstatdServerName.sh	2012-08-10 10:37:12.000000000 -0700
+++ jdk/test/sun/tools/jstatd/jstatdServerName.sh	2013-05-05 09:38:47.000000000 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -86,8 +86,8 @@
     exit 1
 fi
 
-echo "running: ${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_1} 250 5"
-${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_1} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
+echo "running: ${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_1} 250 5"
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_1} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
 RC=$?
 
 if [ ${RC} -ne 0 ]
@@ -95,8 +95,8 @@
     echo "jstat output differs from expected output"
 fi
 
-echo "running: ${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_2}/${SERVERNAME} 250 5"
-${JSTAT} -J-XX:+UsePerfData -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_2}/${SERVERNAME} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
+echo "running: ${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_2}/${SERVERNAME} 250 5"
+${JSTAT} -J-XX:+UsePerfData -J-Duser.language=en -gcutil ${JSTATD_1_PID}@${HOSTNAME}:${PORT_2}/${SERVERNAME} 250 5 2>&1 | awk -f ${TESTSRC}/jstatGcutilOutput1.awk
 RC=$?
 
 if [ ${RC} -ne 0 ]
--- jdk/test/sun/tools/native2ascii/Native2AsciiTests.sh	2012-08-10 10:37:12.000000000 -0700
+++ jdk/test/sun/tools/native2ascii/Native2AsciiTests.sh	2013-05-05 09:38:47.000000000 -0700
@@ -33,7 +33,7 @@
 
 case `uname -s` in
   Windows* | CYGWIN*) OS=Windows;;
-  SunOS|Linux) OS=Unix;;
+  SunOS|Linux|*BSD|Darwin) OS=Unix;;
 esac
 
 N2A=$TESTJAVA/bin/native2ascii
--- jdk/test/sun/tools/native2ascii/resources/ImmutableResourceTest.sh	2012-08-10 10:37:12.000000000 -0700
+++ jdk/test/sun/tools/native2ascii/resources/ImmutableResourceTest.sh	2013-05-05 09:38:47.000000000 -0700
@@ -56,7 +56,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux | Darwin )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- jdk/test/tools/launcher/Arrrghs.java	2012-08-10 10:37:13.000000000 -0700
+++ jdk/test/tools/launcher/Arrrghs.java	2013-05-05 09:38:41.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,7 +36,13 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 public class Arrrghs extends TestHelper {
     private Arrrghs(){}
@@ -75,7 +81,7 @@
     /*
      * This method detects the cookie in the output stream of the process.
      */
-    private static boolean detectCookie(InputStream istream,
+    private boolean detectCookie(InputStream istream,
             String expectedArguments) throws IOException {
         BufferedReader rd = new BufferedReader(new InputStreamReader(istream));
         boolean retval = false;
@@ -105,7 +111,7 @@
         return retval;
     }
 
-    private static boolean doTest0(ProcessBuilder pb, String expectedArguments) {
+    private boolean doReExecTest0(ProcessBuilder pb, String expectedArguments) {
         boolean retval = false;
         try {
             pb.redirectErrorStream(true);
@@ -121,26 +127,27 @@
     }
 
     /**
-     * This method return true  if the expected and detected arguments are the same.
+     * This method returns true  if the expected and detected arguments are the same.
      * Quoting could cause dissimilar testArguments and expected arguments.
      */
-    static int doTest(String testArguments, String expectedPattern) {
+    int doReExecTest(String testArguments, String expectedPattern) {
         ProcessBuilder pb = new ProcessBuilder(javaCmd,
                 VersionStr, testArguments);
 
         Map<String, String> env = pb.environment();
-        env.put("_JAVA_LAUNCHER_DEBUG", "true");
-        return doTest0(pb, testArguments) ? 0 : 1;
+        env.put(JLDEBUG_KEY, "true");
+        return doReExecTest0(pb, testArguments) ? 0 : 1;
     }
 
     /**
      * A convenience method for identical test pattern and expected arguments
      */
-    static int doTest(String testPattern) {
-        return doTest(testPattern, testPattern);
+    int doReExecTest(String testPattern) {
+        return doReExecTest(testPattern, testPattern);
     }
 
-    static void quoteParsingTests() {
+    @Test
+    void testQuoteParsingThroughReExec() {
         /*
          * Tests for 6214916
          * These tests require that a JVM (any JVM) be installed in the system registry.
@@ -155,96 +162,426 @@
 
 
         // Basic test
-        testExitValue += doTest("-a -b -c -d");
+        testExitValue += doReExecTest("-a -b -c -d");
 
         // Basic test with many spaces
-        testExitValue += doTest("-a    -b      -c       -d");
+        testExitValue += doReExecTest("-a    -b      -c       -d");
 
         // Quoted whitespace does matter ?
-        testExitValue += doTest("-a \"\"-b      -c\"\" -d");
+        testExitValue += doReExecTest("-a \"\"-b      -c\"\" -d");
 
 
         // Escaped quotes outside of quotes as literals
-        testExitValue += doTest("-a \\\"-b -c\\\" -d");
+        testExitValue += doReExecTest("-a \\\"-b -c\\\" -d");
 
         // Check for escaped quotes inside of quotes as literal
-        testExitValue += doTest("-a \"-b \\\"stuff\\\"\" -c -d");
+        testExitValue += doReExecTest("-a \"-b \\\"stuff\\\"\" -c -d");
 
         // A quote preceeded by an odd number of slashes is a literal quote
-        testExitValue += doTest("-a -b\\\\\\\" -c -d");
+        testExitValue += doReExecTest("-a -b\\\\\\\" -c -d");
 
         // A quote preceeded by an even number of slashes is a literal quote
         // see 6214916.
-        testExitValue += doTest("-a -b\\\\\\\\\" -c -d");
+        testExitValue += doReExecTest("-a -b\\\\\\\\\" -c -d");
 
         // Make sure that whitespace doesn't interfere with the removal of the
         // appropriate tokens. (space-tab-space preceeds -jre-restict-search).
-        testExitValue += doTest("-a -b  \t -jre-restrict-search -c -d","-a -b -c -d");
+        testExitValue += doReExecTest("-a -b  \t -jre-restrict-search -c -d", "-a -b -c -d");
 
         // Make sure that the mJRE tokens being stripped, aren't stripped if
         // they happen to appear as arguments to the main class.
-        testExitValue += doTest("foo -version:1.1+");
+        testExitValue += doReExecTest("foo -version:1.1+");
 
-        System.out.println("Completed arguments quoting tests with " +
-                testExitValue + " errors");
+        System.out.println("Completed arguments quoting tests with "
+                + testExitValue + " errors");
+    }
+    // the pattern we hope to see in the output
+    static final Pattern ArgPattern = Pattern.compile("\\s*argv\\[[0-9]*\\].*=.*");
+
+    void checkArgumentParsing(String inArgs, String... expArgs) throws IOException {
+        List<String> scratchpad = new ArrayList<>();
+        scratchpad.add("set " + JLDEBUG_KEY + "=true");
+        // GAK, -version needs to be added so that windows can flush its stderr
+        // exiting the process prematurely can terminate the stderr.
+        scratchpad.add(javaCmd + " -version " + inArgs);
+        File batFile = new File("atest.bat");
+        java.nio.file.Files.deleteIfExists(batFile.toPath());
+        createFile(batFile, scratchpad);
+
+        TestResult tr = doExec(batFile.getName());
+
+        ArrayList<String> expList = new ArrayList<>();
+        expList.add(javaCmd);
+        expList.add("-version");
+        expList.addAll(Arrays.asList(expArgs));
+
+        List<String> gotList = new ArrayList<>();
+        for (String x : tr.testOutput) {
+            Matcher m = ArgPattern.matcher(x);
+            if (m.matches()) {
+                String a[] = x.split("=");
+                gotList.add(a[a.length - 1].trim());
+            }
+        }
+        if (!gotList.equals(expList)) {
+            System.out.println(tr);
+            System.out.println("Expected args:");
+            System.out.println(expList);
+            System.out.println("Obtained args:");
+            System.out.println(gotList);
+            throw new RuntimeException("Error: args do not match");
+        }
+        System.out.println("\'" + inArgs + "\'" + " - Test passed");
+    }
+
+    /*
+     * This tests general quoting and are specific to Windows, *nixes
+     * need not worry about this, these have been tested with Windows
+     * implementation and those that are known to work are used against
+     * the java implementation. Note that the ProcessBuilder gets in the
+     * way when testing some of these arguments, therefore we need to
+     * create and execute a .bat file containing the arguments.
+     */
+    @Test
+    void testArgumentParsing() throws IOException {
+        if (!isWindows)
+            return;
+        // no quotes
+        checkArgumentParsing("a b c d", "a", "b", "c", "d");
+
+        // single quotes
+        checkArgumentParsing("\"a b c d\"", "a b c d");
+
+        //double quotes
+        checkArgumentParsing("\"\"a b c d\"\"", "a", "b", "c", "d");
+
+        // triple quotes
+        checkArgumentParsing("\"\"\"a b c d\"\"\"", "\"a b c d\"");
+
+        // a literal within single quotes
+        checkArgumentParsing("\"a\"b c d\"e\"", "ab", "c", "de");
+
+        // a literal within double quotes
+        checkArgumentParsing("\"\"a\"b c d\"e\"\"", "ab c de");
+
+        // a literal quote
+        checkArgumentParsing("a\\\"b", "a\"b");
+
+        // double back-slash
+        checkArgumentParsing("\"a b c d\\\\\"", "a b c d\\");
+
+        // triple back-slash
+        checkArgumentParsing("a\\\\\\\"b", "a\\\"b");
+
+        // dangling quote
+        checkArgumentParsing("\"a b c\"\"", "a b c\"");
+
+        // expansions of white space separators
+        checkArgumentParsing("a b", "a", "b");
+        checkArgumentParsing("a\tb", "a", "b");
+        checkArgumentParsing("a \t b", "a", "b");
+
+        checkArgumentParsing("\"C:\\TEST A\\\\\"", "C:\\TEST A\\");
+        checkArgumentParsing("\"\"C:\\TEST A\\\\\"\"", "C:\\TEST", "A\\");
+
+        // MS Windows tests
+        // triple back-slash
+        checkArgumentParsing("a\\\\\\d", "a\\\\\\d");
+
+        // triple back-slash in quotes
+        checkArgumentParsing("\"a\\\\\\d\"", "a\\\\\\d");
+
+        // slashes separating characters
+        checkArgumentParsing("X\\Y\\Z", "X\\Y\\Z");
+        checkArgumentParsing("\\X\\Y\\Z", "\\X\\Y\\Z");
+
+        // literals within dangling quotes, etc.
+        checkArgumentParsing("\"a b c\" d e", "a b c", "d", "e");
+        checkArgumentParsing("\"ab\\\"c\"  \"\\\\\"  d", "ab\"c", "\\", "d");
+        checkArgumentParsing("a\\\\\\c d\"e f\"g h", "a\\\\\\c", "de fg", "h");
+        checkArgumentParsing("a\\\\\\\"b c d", "a\\\"b", "c", "d");
+        checkArgumentParsing("a\\\\\\\\\"g c\" d e", "a\\\\g c", "d", "e");
+
+        // treatment of back-slashes
+        checkArgumentParsing("*\\", "*\\");
+        checkArgumentParsing("*/", "*/");
+        checkArgumentParsing(".\\*", ".\\*");
+        checkArgumentParsing("./*", "./*");
+        checkArgumentParsing("..\\..\\*", "..\\..\\*");
+        checkArgumentParsing("../../*", "../../*");
+        checkArgumentParsing("..\\..\\", "..\\..\\");
+        checkArgumentParsing("../../", "../../");
+        checkArgumentParsing("a b\\ c", "a", "b\\", "c");
+    }
+
+    private void initEmptyDir(File emptyDir) throws IOException {
+        if (emptyDir.exists()) {
+            recursiveDelete(emptyDir);
+        }
+        emptyDir.mkdir();
+    }
+
+    private void initDirWithJavaFiles(File libDir) throws IOException {
+
+        if (libDir.exists()) {
+            recursiveDelete(libDir);
+        }
+        libDir.mkdirs();
+        ArrayList<String> scratchpad = new ArrayList<>();
+        scratchpad.add("package lib;");
+        scratchpad.add("public class Fbo {");
+        scratchpad.add("public static void main(String... args){Foo.f();}");
+        scratchpad.add("public static void f(){}");
+        scratchpad.add("}");
+        createFile(new File(libDir, "Fbo.java"), scratchpad);
+
+        scratchpad.clear();
+        scratchpad.add("package lib;");
+        scratchpad.add("public class Foo {");
+        scratchpad.add("public static void main(String... args){");
+        scratchpad.add("for (String x : args) {");
+        scratchpad.add("System.out.println(x);");
+        scratchpad.add("}");
+        scratchpad.add("Fbo.f();");
+        scratchpad.add("}");
+        scratchpad.add("public static void f(){}");
+        scratchpad.add("}");
+        createFile(new File(libDir, "Foo.java"), scratchpad);
+    }
+
+    void checkArgumentWildcard(String inArgs, String... expArgs) throws IOException {
+        String[] in = {inArgs};
+        checkArgumentWildcard(in, expArgs);
+
+        // now add arbitrary arguments before and after
+        String[] outInArgs = { "-Q", inArgs, "-R"};
+
+        String[] outExpArgs = new String[expArgs.length + 2];
+        outExpArgs[0] = "-Q";
+        System.arraycopy(expArgs, 0, outExpArgs, 1, expArgs.length);
+        outExpArgs[expArgs.length + 1] = "-R";
+        checkArgumentWildcard(outInArgs, outExpArgs);
+    }
+
+    void checkArgumentWildcard(String[] inArgs, String[] expArgs) throws IOException {
+        ArrayList<String> argList = new ArrayList<>();
+        argList.add(javaCmd);
+        argList.add("-cp");
+        argList.add("lib" + File.separator + "*");
+        argList.add("lib.Foo");
+        argList.addAll(Arrays.asList(inArgs));
+        String[] cmds = new String[argList.size()];
+        argList.toArray(cmds);
+        TestResult tr = doExec(cmds);
+        if (!tr.isOK()) {
+            System.out.println(tr);
+            throw new RuntimeException("Error: classpath single entry wildcard entry");
+        }
+
+        ArrayList<String> expList = new ArrayList<>();
+        expList.addAll(Arrays.asList(expArgs));
+
+        List<String> gotList = new ArrayList<>();
+        for (String x : tr.testOutput) {
+            gotList.add(x.trim());
+        }
+        if (!gotList.equals(expList)) {
+            System.out.println(tr);
+            System.out.println("Expected args:");
+            System.out.println(expList);
+            System.out.println("Obtained args:");
+            System.out.println(gotList);
+            throw new RuntimeException("Error: args do not match");
+        }
+        System.out.print("\'");
+        for (String x : inArgs) {
+            System.out.print(x + " ");
+        }
+        System.out.println("\'" + " - Test passed");
     }
 
     /*
+     * These tests are not expected to work on *nixes, and are ignored.
+     */
+    @Test
+    void testWildCardArgumentProcessing() throws IOException {
+        if (!isWindows)
+            return;
+        File cwd = new File(".");
+        File libDir = new File(cwd, "lib");
+        initDirWithJavaFiles(libDir);
+        initEmptyDir(new File(cwd, "empty"));
+
+        // test if javac (the command) can compile *.java
+        TestResult tr = doExec(javacCmd, libDir.getName() + File.separator + "*.java");
+        if (!tr.isOK()) {
+            System.out.println(tr);
+            throw new RuntimeException("Error: compiling java wildcards");
+        }
+
+        // use the jar cmd to create jars using the ? wildcard
+        File jarFoo = new File(libDir, "Foo.jar");
+        tr = doExec(jarCmd, "cvf", jarFoo.getAbsolutePath(), "lib" + File.separator + "F?o.class");
+        if (!tr.isOK()) {
+            System.out.println(tr);
+            throw new RuntimeException("Error: creating jar with wildcards");
+        }
+
+        // now the litmus test!, this should work
+        checkArgumentWildcard("a", "a");
+
+        // test for basic expansion
+        checkArgumentWildcard("lib\\F*java", "lib\\Fbo.java", "lib\\Foo.java");
+
+        // basic expansion in quotes
+        checkArgumentWildcard("\"lib\\F*java\"", "lib\\F*java");
+
+        checkArgumentWildcard("lib\\**", "lib\\Fbo.class", "lib\\Fbo.java",
+                              "lib\\Foo.class", "lib\\Foo.jar", "lib\\Foo.java");
+
+        checkArgumentWildcard("lib\\*?", "lib\\Fbo.class", "lib\\Fbo.java",
+                              "lib\\Foo.class", "lib\\Foo.jar", "lib\\Foo.java");
+
+        checkArgumentWildcard("lib\\?*", "lib\\Fbo.class", "lib\\Fbo.java",
+                "lib\\Foo.class", "lib\\Foo.jar", "lib\\Foo.java");
+
+        checkArgumentWildcard("lib\\?", "lib\\?");
+
+        // test for basic expansion
+        checkArgumentWildcard("lib\\*java", "lib\\Fbo.java", "lib\\Foo.java");
+
+        // basic expansion in quotes
+        checkArgumentWildcard("\"lib\\*.java\"", "lib\\*.java");
+
+        // suffix expansion
+        checkArgumentWildcard("lib\\*.class", "lib\\Fbo.class", "lib\\Foo.class");
+
+        // suffix expansion in quotes
+        checkArgumentWildcard("\"lib\\*.class\"", "lib\\*.class");
+
+        // check for ? expansion now
+        checkArgumentWildcard("lib\\F?o.java", "lib\\Fbo.java", "lib\\Foo.java");
+
+        // check ? in quotes
+        checkArgumentWildcard("\"lib\\F?o.java\"", "lib\\F?o.java");
+
+        // check ? as suffixes
+        checkArgumentWildcard("lib\\F?o.????", "lib\\Fbo.java", "lib\\Foo.java");
+
+        // check ? in a leading role
+        checkArgumentWildcard("lib\\???.java", "lib\\Fbo.java", "lib\\Foo.java");
+        checkArgumentWildcard("\"lib\\???.java\"", "lib\\???.java");
+
+        // check ? prefixed with -
+        checkArgumentWildcard("-?", "-?");
+
+        // check * prefixed with -
+        checkArgumentWildcard("-*", "-*");
+
+        // check on empty directory
+        checkArgumentWildcard("empty\\*", "empty\\*");
+        checkArgumentWildcard("empty\\**", "empty\\**");
+        checkArgumentWildcard("empty\\?", "empty\\?");
+        checkArgumentWildcard("empty\\??", "empty\\??");
+        checkArgumentWildcard("empty\\*?", "empty\\*?");
+        checkArgumentWildcard("empty\\?*", "empty\\?*");
+
+    }
+
+    void doArgumentCheck(String inArgs, String... expArgs) {
+        Map<String, String> env = new HashMap<>();
+        env.put(JLDEBUG_KEY, "true");
+        TestResult tr = doExec(env, javaCmd, inArgs);
+        System.out.println(tr);
+        int sindex = tr.testOutput.indexOf("Command line args:");
+        if (sindex < 0) {
+            System.out.println(tr);
+            throw new RuntimeException("Error: no output");
+        }
+        sindex++; // skip over the tag
+        List<String> gotList = new ArrayList<>();
+        for (String x : tr.testOutput.subList(sindex, sindex + expArgs.length)) {
+            String a[] = x.split("=");
+            gotList.add(a[a.length - 1].trim());
+        }
+        List<String> expList = Arrays.asList(expArgs);
+        if (!gotList.equals(expList)) {
+            System.out.println(tr);
+            System.out.println("Expected args:");
+            System.out.println(expList);
+            System.out.println("Obtained args:");
+            System.out.println(gotList);
+            throw new RuntimeException("Error: args do not match");
+        }
+    }
+
+
+    /*
      * These tests are usually run on non-existent targets to check error results
      */
-    static void runBasicErrorMessageTests() {
+    @Test
+    void testBasicErrorMessages() {
         // Tests for 5030233
         TestResult tr = doExec(javaCmd, "-cp");
         tr.checkNegative();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         tr = doExec(javaCmd, "-classpath");
         tr.checkNegative();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         tr = doExec(javaCmd, "-jar");
         tr.checkNegative();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         tr = doExec(javacCmd, "-cp");
         tr.checkNegative();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // Test for 6356475 "REGRESSION:"java -X" from cmdline fails"
         tr = doExec(javaCmd, "-X");
         tr.checkPositive();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         tr = doExec(javaCmd, "-help");
         tr.checkPositive();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // 6753938, test for non-negative exit value for an incorrectly formed
         // command line,  '% java'
         tr = doExec(javaCmd);
         tr.checkNegative();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // 6753938, test for non-negative exit value for an incorrectly formed
         // command line,  '% java -Xcomp'
         tr = doExec(javaCmd, "-Xcomp");
         tr.checkNegative();
         tr.isNotZeroOutput();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
     }
 
     /*
      * Tests various dispositions of the main method, these tests are limited
      * to English locales as they check for error messages that are localized.
      */
-    static void runMainMethodTests() throws FileNotFoundException {
+    @Test
+    void testMainMethod() throws FileNotFoundException {
         if (!isEnglishLocale()) {
             return;
         }
@@ -256,55 +593,65 @@
                 (String[])null);
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.contains("Error: Could not find or load main class MIA");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
         // use classpath to check
         tr = doExec(javaCmd, "-cp", "some.jar", "MIA");
         tr.contains("Error: Could not find or load main class MIA");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // incorrect method access
         createJar(new File("some.jar"), new File("Foo"),
                 "private static void main(String[] args){}");
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.contains("Error: Main method not found in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
         // use classpath to check
         tr = doExec(javaCmd, "-cp", "some.jar", "Foo");
         tr.contains("Error: Main method not found in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // incorrect return type
         createJar(new File("some.jar"), new File("Foo"),
                 "public static int main(String[] args){return 1;}");
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.contains("Error: Main method must return a value of type void in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
         // use classpath to check
         tr = doExec(javaCmd, "-cp", "some.jar", "Foo");
         tr.contains("Error: Main method must return a value of type void in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // incorrect parameter type
         createJar(new File("some.jar"), new File("Foo"),
                 "public static void main(Object[] args){}");
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.contains("Error: Main method not found in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
         // use classpath to check
         tr = doExec(javaCmd, "-cp", "some.jar", "Foo");
         tr.contains("Error: Main method not found in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // incorrect method type - non-static
          createJar(new File("some.jar"), new File("Foo"),
                 "public void main(String[] args){}");
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.contains("Error: Main method is not static in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
         // use classpath to check
         tr = doExec(javaCmd, "-cp", "some.jar", "Foo");
         tr.contains("Error: Main method is not static in class Foo");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // amongst a potpourri of kindred main methods, is the right one chosen ?
         createJar(new File("some.jar"), new File("Foo"),
@@ -316,25 +663,29 @@
             "public static void main(String[] args) {System.out.println(\"THE_CHOSEN_ONE\");}");
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.contains("THE_CHOSEN_ONE");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
         // use classpath to check
         tr = doExec(javaCmd, "-cp", "some.jar", "Foo");
         tr.contains("THE_CHOSEN_ONE");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // test for extraneous whitespace in the Main-Class attribute
         createJar(" Foo ", new File("some.jar"), new File("Foo"),
                 "public static void main(String... args){}");
         tr = doExec(javaCmd, "-jar", "some.jar");
         tr.checkPositive();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
     }
     /*
      * tests 6968053, ie. we turn on the -Xdiag (for now) flag and check if
      * the suppressed stack traces are exposed, ignore these tests for localized
      * locales, limiting to English only.
      */
-    static void runDiagOptionTests() throws FileNotFoundException {
+    @Test
+    void testDiagOptions() throws FileNotFoundException {
         if (!isEnglishLocale()) { // only english version
             return;
         }
@@ -345,48 +696,51 @@
         tr = doExec(javaCmd, "-Xdiag", "-jar", "some.jar");
         tr.contains("Error: Could not find or load main class MIA");
         tr.contains("java.lang.ClassNotFoundException: MIA");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // use classpath to check
         tr = doExec(javaCmd,  "-Xdiag", "-cp", "some.jar", "MIA");
         tr.contains("Error: Could not find or load main class MIA");
         tr.contains("java.lang.ClassNotFoundException: MIA");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         // a missing class on the classpath
         tr = doExec(javaCmd, "-Xdiag", "NonExistentClass");
         tr.contains("Error: Could not find or load main class NonExistentClass");
         tr.contains("java.lang.ClassNotFoundException: NonExistentClass");
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
     }
 
-    static void test6894719() {
+    @Test
+    static void testJreRestrictSearchFlag() {
         // test both arguments to ensure they exist
         TestResult tr = null;
         tr = doExec(javaCmd,
                 "-no-jre-restrict-search", "-version");
         tr.checkPositive();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
 
         tr = doExec(javaCmd,
                 "-jre-restrict-search", "-version");
         tr.checkPositive();
-        System.out.println(tr);
+        if (!tr.testStatus)
+            System.out.println(tr);
     }
 
     /**
      * @param args the command line arguments
      * @throws java.io.FileNotFoundException
      */
-    public static void main(String[] args) throws FileNotFoundException {
+    public static void main(String[] args) throws Exception {
         if (debug) {
             System.out.println("Starting Arrrghs tests");
         }
-        quoteParsingTests();
-        runBasicErrorMessageTests();
-        runMainMethodTests();
-        test6894719();
-        runDiagOptionTests();
+        Arrrghs a = new Arrrghs();
+        a.run(args);
         if (testExitValue > 0) {
             System.out.println("Total of " + testExitValue + " failed");
             System.exit(1);
--- jdk/test/tools/launcher/TestHelper.java	2012-08-10 10:37:13.000000000 -0700
+++ jdk/test/tools/launcher/TestHelper.java	2013-05-05 09:38:41.000000000 -0700
@@ -21,6 +21,14 @@
  * questions.
  */
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.reflect.Method;
+import java.util.regex.Pattern;
+import java.io.StringWriter;
+import java.io.PrintWriter;
 import java.util.Set;
 import java.io.BufferedReader;
 import java.io.File;
@@ -55,11 +63,14 @@
     static final File TEST_SOURCES_DIR;
 
     static final String JAVAHOME = System.getProperty("java.home");
+    static final String JAVA_BIN;
     static final boolean isSDK = JAVAHOME.endsWith("jre");
     static final String javaCmd;
     static final String javawCmd;
     static final String java64Cmd;
     static final String javacCmd;
+    static final String jarCmd;
+
     static final JavaCompiler compiler;
 
     static final boolean debug = Boolean.getBoolean("TestHelper.Debug");
@@ -84,8 +95,10 @@
     static final String JAVA_FILE_EXT  = ".java";
     static final String CLASS_FILE_EXT = ".class";
     static final String JAR_FILE_EXT   = ".jar";
+    static final String EXE_FILE_EXT   = ".exe";
     static final String JLDEBUG_KEY     = "_JAVA_LAUNCHER_DEBUG";
     static final String EXPECTED_MARKER = "TRACER_MARKER:About to EXEC";
+    static final String TEST_PREFIX     = "###TestError###: ";
 
     static int testExitValue = 0;
 
@@ -111,6 +124,7 @@
         compiler = ToolProvider.getSystemJavaCompiler();
         File binDir = (isSDK) ? new File((new File(JAVAHOME)).getParentFile(), "bin")
             : new File(JAVAHOME, "bin");
+        JAVA_BIN = binDir.getAbsolutePath();
         File javaCmdFile = (isWindows)
                 ? new File(binDir, "java.exe")
                 : new File(binDir, "java");
@@ -125,6 +139,15 @@
                 : new File(binDir, "javac");
         javacCmd = javacCmdFile.getAbsolutePath();
 
+        File jarCmdFile = (isWindows)
+                ? new File(binDir, "jar.exe")
+                : new File(binDir, "jar");
+        jarCmd = jarCmdFile.getAbsolutePath();
+        if (!jarCmdFile.canExecute()) {
+            throw new RuntimeException("java <" + TestHelper.jarCmd +
+                    "> must exist and should be executable");
+        }
+
         if (isWindows) {
             File javawCmdFile = new File(binDir, "javaw.exe");
             javawCmd = javawCmdFile.getAbsolutePath();
@@ -152,6 +175,35 @@
             java64Cmd = null;
         }
     }
+    void run(String[] args) throws Exception {
+        int passed = 0, failed = 0;
+        final Pattern p = (args != null && args.length > 0)
+                ? Pattern.compile(args[0])
+                : null;
+        for (Method m : this.getClass().getDeclaredMethods()) {
+            boolean selected = (p == null)
+                    ? m.isAnnotationPresent(Test.class)
+                    : p.matcher(m.getName()).matches();
+            if (selected) {
+                try {
+                    m.invoke(this, (Object[]) null);
+                    System.out.println(m.getName() + ": OK");
+                    passed++;
+                } catch (Throwable ex) {
+                    System.out.printf("Test %s failed: %s %n", m, ex.getCause());
+                    failed++;
+                }
+            }
+        }
+        System.out.printf("Passed: %d, Failed %d%n", passed, failed);
+        if (failed > 0) {
+            throw new RuntimeException("Tests failed: " + failed);
+        }
+        if (passed == 0 && failed == 0) {
+            throw new AssertionError("No test(s) selected: passed = " +
+                    passed + ", failed = " + failed + " ??????????");
+        }
+    }
 
     /*
      * is a dual mode available in the test jdk
@@ -383,35 +435,46 @@
      * of use methods to check the test results.
      */
     static class TestResult {
-        StringBuilder status;
+        PrintWriter status;
+        StringWriter sw;
         int exitValue;
         List<String> testOutput;
         Map<String, String> env;
         Throwable t;
+        boolean testStatus;
 
         public TestResult(String str, int rv, List<String> oList,
                 Map<String, String> env, Throwable t) {
-            status = new StringBuilder("Executed command: " + str + "\n");
+            sw = new StringWriter();
+            status = new PrintWriter(sw);
+            status.println("Executed command: " + str + "\n");
             exitValue = rv;
             testOutput = oList;
             this.env = env;
             this.t = t;
+            testStatus = true;
+        }
+
+        void appendError(String x) {
+            status.println(TEST_PREFIX + x);
         }
 
-        void appendStatus(String x) {
-            status = status.append("  " + x + "\n");
+        void indentStatus(String x) {
+            status.println("  " + x);
         }
 
         void checkNegative() {
             if (exitValue == 0) {
-                appendStatus("Error: test must not return 0 exit value");
+                appendError("test must not return 0 exit value");
+                testStatus = false;
                 testExitValue++;
             }
         }
 
         void checkPositive() {
             if (exitValue != 0) {
-                appendStatus("Error: test did not return 0 exit value");
+                testStatus = false;
+                appendError("test did not return 0 exit value");
                 testExitValue++;
             }
         }
@@ -422,7 +485,8 @@
 
         boolean isZeroOutput() {
             if (!testOutput.isEmpty()) {
-                appendStatus("Error: No message from cmd please");
+                testStatus = false;
+                appendError("No message from cmd please");
                 testExitValue++;
                 return false;
             }
@@ -431,7 +495,8 @@
 
         boolean isNotZeroOutput() {
             if (testOutput.isEmpty()) {
-                appendStatus("Error: Missing message");
+                testStatus = false;
+                appendError("Missing message");
                 testExitValue++;
                 return false;
             }
@@ -440,22 +505,26 @@
 
         @Override
         public String toString() {
-            status.append("++++Begin Test Info++++\n");
-            status.append("++++Test Environment++++\n");
+            status.println("++++Begin Test Info++++");
+            status.println("Test Status: " + (testStatus ? "PASS" : "FAIL"));
+            status.println("++++Test Environment++++");
             for (String x : env.keySet()) {
-                status.append(x).append("=").append(env.get(x)).append("\n");
+                indentStatus(x + "=" + env.get(x));
             }
-            status.append("++++Test Output++++\n");
+            status.println("++++Test Output++++");
             for (String x : testOutput) {
-                appendStatus(x);
+                indentStatus(x);
             }
-            status.append("++++Test Stack Trace++++\n");
-            status.append(t.toString());
+            status.println("++++Test Stack Trace++++");
+            status.println(t.toString());
             for (StackTraceElement e : t.getStackTrace()) {
-                status.append(e.toString());
+                indentStatus(e.toString());
             }
-            status.append("++++End of Test Info++++\n");
-            return status.toString();
+            status.println("++++End of Test Info++++");
+            status.flush();
+            String out = sw.toString();
+            status.close();
+            return out;
         }
 
         boolean contains(String str) {
@@ -464,7 +533,7 @@
                     return true;
                 }
             }
-            appendStatus("Error: string <" + str + "> not found");
+            appendError("string <" + str + "> not found");
             testExitValue++;
             return false;
         }
@@ -475,9 +544,15 @@
                     return true;
                 }
             }
-            appendStatus("Error: string <" + stringToMatch + "> not found");
+            appendError("string <" + stringToMatch + "> not found");
             testExitValue++;
             return false;
         }
     }
+    /**
+    * Indicates that the annotated method is a test method.
+    */
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.METHOD)
+    public @interface Test {}
 }
--- jdk/test/tools/launcher/ToolsOpts.java	1969-12-31 16:00:00.000000000 -0800
+++ jdk/test/tools/launcher/ToolsOpts.java	2013-05-05 09:38:41.000000000 -0700
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8002091
+ * @summary Test options patterns for javac,javah,javap and javadoc using
+ * javac as a test launcher. Create a dummy javac and intercept options to check
+ * reception of options as passed through the launcher without having to launch
+ * javac. Only -J and -cp ./* options should be consumed by the launcher.
+ * @run main ToolsOpts
+ * @author ssides
+ */
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class ToolsOpts extends TestHelper {
+    static final String JBCP_PREPEND = "-J-Xbootclasspath/p:";
+    private static File testJar = null;
+    static String[][] optionPatterns = {
+        {"-J-Xmx128m"},
+        {"-J-version"},
+        {"-J-XshowSettings:vm"},
+        {"-J-Xdiag"},
+        {"-J-showversion"},
+        {"-J-version", "-option"},
+        {"-option"},
+        {"-option:sub"},
+        {"-option:sub-"},
+        {"-option:sub1,sub2"}, // -option:list
+        {"-option:{sub1,sub2,sub3}"}, // -option:{list}
+        {"-option:{{sub1,sub2,sub3}}"},// -option:{{list}}
+        {"-option/c:/export/date/tmp"},
+        {"-option=value"},
+        {"-Dpk1.pk2.pk3"}, // dot in option
+        {"-Dpk1.pk2=value"}, // dot in option followed by =value
+        {"@<filename>"},
+        {"-option", "http://site.com", "http://site.org"},
+        {"-option", "name", "p1:p2.."},
+        {"-All these non-options show launchers pass options as is to tool."},
+        {"-option"},
+        {"-option:sub"},
+        {"-option:sub-"},
+        {"-option", "<path>"},
+        {"-option", "<file>"},
+        {"-option", "<dir>"},
+        {"-option", "http://a/b/c/g;x?y#s"},
+        {"-option", "<html code>"},
+        {"-option", "name1:name2"},
+        {"-option", "3"},
+        {"option1", "-J-version", "option2"},
+        {"option1", "-J-version", "-J-XshowSettings:vm", "option2"},};
+
+    static void init() throws IOException {
+        if (testJar != null) {
+            return;
+        }
+
+        // A tool which simulates com.sun.tools.javac.Main argument processing,
+        // intercepts options passed via the javac launcher.
+        final String mainJava = "Main" + JAVA_FILE_EXT;
+        testJar = new File("test" + JAR_FILE_EXT);
+        List<String> contents = new ArrayList<>();
+        contents.add("package com.sun.tools.javac;");
+        contents.add("public class Main {");
+        contents.add("    public static void main(String... args) {\n");
+        contents.add("       for (String x : args) {\n");
+        contents.add("           if(x.compareTo(\" \")!=0)\n");
+        contents.add("               System.out.println(x);\n");
+        contents.add("       }\n");
+        contents.add("    }\n");
+        contents.add("}\n");
+        createFile(new File(mainJava), contents);
+
+        // compile and jar Main.java into test.jar
+        compile("-d", ".", mainJava);
+            createJar("cvf", testJar.getAbsolutePath(), "com");
+        }
+
+    static void pass(String msg) {
+        System.out.println("pass: " + msg);
+    }
+
+    static void errout(String msg) {
+        System.err.println(msg);
+    }
+
+    // Return position of -J option or -1 is does not contain a -J option.
+    static int indexOfJoption(String[] opts) {
+        for (int i = 0; i < opts.length; i++) {
+            if (opts[i].startsWith("-J")) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    /*
+     * Check that J options a) are not passed to tool, and b) do the right thing,
+     * that is, they should be passed to java launcher and work as expected.
+     */
+    static void checkJoptionOutput(TestResult tr, String[] opts) throws IOException {
+        // Check -J-version options are not passed but do what they should.
+        String jopts = "";
+        for (String pat : opts) {
+            jopts = jopts.concat(pat + " ");
+            if (tr.contains("-J")) {
+                throw new RuntimeException(
+                        "failed: output should not contain option " + pat);
+            }
+            if (pat.compareTo("-J-version") == 0 ||
+                    pat.compareTo("-J-showversion") == 0) {
+                if (!tr.contains("java version") &&
+                        !tr.contains("openjdk version")) {
+                    throw new RuntimeException("failed: " + pat +
+                            " should display a version string.");
+                }
+            } else if (pat.compareTo("-J-XshowSettings:VM") == 0) {
+                if (!tr.contains("VM settings")) {
+                    throw new RuntimeException("failed: " + pat +
+                            " should have display VM settings.");
+                }
+            }
+        }
+        pass("Joption check: " + jopts);
+    }
+
+    /*
+     * Feed each option pattern in optionPatterns array to javac launcher with
+     * checking program preempting javac. Check that option received by 'dummy'
+     * javac is the one passed on the command line.
+     */
+    static void runTestOptions() throws IOException {
+        init();
+        TestResult tr = null;
+        String sTestJar = testJar.getAbsolutePath();
+        int jpos = -1;
+        for (String arg[] : optionPatterns) {
+            jpos = indexOfJoption(arg);
+            //Build a cmd string for output in results reporting.
+            String cmdString = javacCmd + " " + JBCP_PREPEND + sTestJar;
+            for (String opt : arg) {
+                cmdString = cmdString.concat(" " + opt);
+            }
+            switch (arg.length) {
+                case 1:
+                    tr = doExec(javacCmd, JBCP_PREPEND + sTestJar,
+                            arg[0]);
+                    break;
+                case 2:
+                    tr = doExec(javacCmd, JBCP_PREPEND + sTestJar,
+                            arg[0], arg[1]);
+                    break;
+                case 3:
+                    tr = doExec(javacCmd, JBCP_PREPEND + sTestJar,
+                            arg[0], arg[1], arg[2]);
+                    break;
+                case 4:
+                    tr = doExec(javacCmd, JBCP_PREPEND + sTestJar,
+                            arg[0], arg[1], arg[2], arg[3]);
+                    break;
+                default:
+                    tr = null;
+                    break;
+            }
+
+            String[] output = tr.testOutput.toArray(new String[tr.testOutput.size()]);
+            //-Joptions should not be passed to tool
+            if (jpos > -1) {
+                checkJoptionOutput(tr, arg);
+                if (tr.contains(arg[jpos])) {
+                    throw new RuntimeException(
+                            "failed! Should not have passed -J option to tool.\n"
+                            + "CMD: " + cmdString);
+                }
+            } else {
+                //check that each non -J option was passed to tool.
+                for (int i = 0; i < arg.length; i++) {
+                    if (output[i].compareTo(arg[i]) != 0) {
+                        throw new RuntimeException(
+                                "failed! CMD: " + cmdString + "\n   case:" +
+                                output[i] + " != " + arg[i]);
+                    } else {
+                        pass("check " + output[i] + " == " + arg[i]);
+                    }
+                }
+            }
+            pass(cmdString);
+        }
+    }
+
+    public static void main(String... args) throws IOException {
+        runTestOptions();
+    }
+}
--- langtools/.hgtags	2012-08-10 10:39:19.000000000 -0700
+++ langtools/.hgtags	2013-05-05 09:38:26.000000000 -0700
@@ -123,6 +123,7 @@
 9425dd4f53d5bfcd992d9aecea0eb7d8b2d4f62b jdk7-b146
 d34578643d1c6c752d4a6b5e79c6ab1b60850b4a jdk7u1-b01
 58bc532d63418ac3c9b42460d89cdaf595c6f3e1 jdk7-b147
+23aadf169f085b180803bcdc53baad4ae870f75b 7u0
 cd2cc8b5edb045b950aed46d159b4fb8fc2fd1df jdk7u1-b02
 82820a30201dbf4b80f1916f3d0f4a92ad21b61a jdk7u1-b03
 baa2c13c70fea3d6e259a34f0903197fdceb64b5 jdk7u1-b04
@@ -197,5 +198,69 @@
 a35ca56cf8d09b92511f0cd71208a2ea05c8a338 jdk7u6-b21
 4f3aafa690d1fcb18693fc4085049eeffe4778f7 jdk7u6-b22
 dd3e29d8892fcaba6d76431d5fa9d49e7c088f76 jdk7u6-b23
-a35ca56cf8d09b92511f0cd71208a2ea05c8a338 jdk7u8-b01
-41bc8da868e58f7182d26b2ab9b6f8a4b09894ed jdk7u8-b02
+6aac89e84fc96d15bb78b13aa71c9e6b73d7237e jdk7u6-b24
+bcd1d067d525065630deb98b678bc00b499adbe1 jdk7u6-b30
+2d6017454236d4e95aad7feaff5fc92a612598f4 jdk7u6-b31
+2d6017454236d4e95aad7feaff5fc92a612598f4 jdk7u7-b10
+27041587508dbc4e08c956ba98a11ce0d5608dc4 jdk7u7-b30
+b92a9f4f6bce4ec500ed3adb8203e6424b579f94 jdk7u7-b11
+f0fd7463f02ea681ca53022d6d0d425ec1584b34 jdk7u7-b31
+6bfc26fc14a0650805dd6583048db0b4f8669844 jdk7u7-b01
+0d4cb328938002fa9a2efc8190ea97beae3230a9 jdk7u7-b02
+04848e261e42c697cb70401f8059186434855f33 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+6bfc26fc14a0650805dd6583048db0b4f8669844 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+0d4cb328938002fa9a2efc8190ea97beae3230a9 jdk7u9-b02
+9148cdb9a18b55ad7d51bb9644b6db812de34eea jdk7u9-b04
+1de4a0865a714076b4922a9a7119adb98aee23f2 jdk7u9-b05
+5d1a6a593fa17933683b34ea3a55c7d13c028a13 jdk7u9-b31
+acd27fc7fcf3e9dc0a1ae7e101cc036e960b6295 jdk7u9-b32
+8dfbebb98865d822ddd9e0b9641d21e8bdb8a866 jdk7u10-b10
+01c6dde274bd520067264231b3015c37e8e62d24 jdk7u10-b11
+1fb02747d3bce646374c2cab95048c516cec6b01 jdk7u10-b12
+14735b3d8bdffc7892f1db04b6262bdaad2eb9d7 jdk7u10-b13
+f555fcdbd07156ee11b25fb4ac106065bbf496b4 jdk7u10-b14
+dfcd16ac3fbcabed815b8ef4e792716cce0bce21 jdk7u10-b15
+eaa8a0141c35edc382d7ce0b1148912db8422b16 jdk7u10-b16
+7101b3e80e96b000b0b4f0bd7fe4dd7910d02f74 jdk7u10-b17
+4f529e320d83f517a55065b4710c7f1e5ff692c9 jdk7u10-b18
+1e5aed8511b9bea5c2ebe51a2d9094be8bac73cc jdk7u10-b30
+db426c20b06918feeeaa036d52a5096c2bb646b0 jdk7u10-b31
+b01338429ab6821f44d19601de433b538942b53d jdk7u11-b20
+aeef1c7e43bc2d4a0960ebf42b642f7a34ec8afc jdk7u11-b21
+92de02b43596ea1d01c87d56dbc9acc0960a90c3 jdk7u11-b32
+309b5ccd0501d48fa7eed29e45197b4101de4683 jdk7u11-b33
+eaa8a0141c35edc382d7ce0b1148912db8422b16 jdk7u11-b03
+e8071ede35dc5948f5ed127941be192a4a8c1ebd jdk7u11-b04
+17b9bb22f3fd6a624879a29a3fc4b252327c113d jdk7u11-b05
+96c8b3b817aa3e672f78f1d5006616104378ff29 jdk7u11-b06
+c5d3dabddff76c92425cbf6a99ed4e066d16b4fd jdk7u11-b07
+a0d9abc405580d6fa0ae217fab96608285a38c41 jdk7u11-b08
+a778aaf53c52f78c92f29a1220d9f46de94c9247 jdk7u13-b09
+761b933e269693fd689c2af5d8317201b2172dbb jdk7u13-b10
+8a12629ea21378f96666628f472cd9a6936a4933 jdk7u13-b30
+761b933e269693fd689c2af5d8317201b2172dbb jdk7u13-b20
+1298307076c2f0c2a4acd3a2a132cbe98d399009 jdk7u15-b01
+8db0105f00ce9fe6899ece52d46d78995111c456 jdk7u15-b02
+b00c1580ffa95d9edd567835e1b9a77cf8ca2af6 jdk7u15-b30
+2c82a733594aef14f7a91a910c6b7b20e6220078 jdk7u15-b31
+5639dfc55f771823fab02438e5c89c6b18f57d07 jdk7u15-b33
+c160d7d1616d099afad0986b7d06aee2d9405e57 jdk7u15-b03
+a778aaf53c52f78c92f29a1220d9f46de94c9247 jdk7u15-b32
+edfcf07c2877af8efa649e514167b22b7f6fc0b4 jdk7u17-b01
+2782a1c60faf7585dee0af0ef585aeed3288e521 jdk7u17-b02
+0abc443a68676c7231b274a324d27204c735acac jdk7u17-b30
+1a9b32d36ff86136549f20156cf3e821295228a0 jdk7u17-b31
+8a12629ea21378f96666628f472cd9a6936a4933 jdk7u21-b01
+82103a284427a2512fe884d8f232f1a83d46beb6 jdk7u21-b02
+9adfe6a84c3884d5c24f6655e89546a6e0a80129 jdk7u21-b03
+71704143744ee46f105bf1bf3e4b7aecaf9c1003 jdk7u21-b04
+0970c229028499d5348d77712edf42d712538441 jdk7u21-b05
+5e0127eb56c3f70bdf67a5b2c57cf218838371ae jdk7u21-b06
+08034557136e484b3a7c4d0ec9b21e57ea9cd30b jdk7u21-b07
+f3c75c441d5623186e43de0b5a645e12fc360c29 jdk7u21-b08
+b6c7a18b668b85bdc41914b2b354c1928deb659e jdk7u21-b09
+de06078efe709392d7faf44803d54b74599f6bda jdk7u21-b10
+e120818fc321b5d9d8573a58bf5f6a6eb7471229 jdk7u21-b11
+ff6f8ab2635c6e0b0f6bb1a68dca48b4fc31b107 jdk7u21-b30
--- langtools/test/Makefile	2012-08-10 10:39:30.000000000 -0700
+++ langtools/test/Makefile	2013-05-05 09:38:21.000000000 -0700
@@ -42,6 +42,14 @@
     ARCH=i586
   endif
 endif
+ifeq ($(findstring BSD,$(OSNAME)), BSD)
+  PLATFORM = bsd
+  JT_PLATFORM = linux
+  ARCH = $(shell uname -m)
+  ifeq ($(ARCH), i386)
+    ARCH=i586
+  endif
+endif
 ifeq ($(OSNAME), Windows_NT)
   PLATFORM = windows
   JT_PLATFORM = win32
@@ -101,7 +109,7 @@
 ifdef JPRT_JAVA_HOME
   JT_JAVA = $(JPRT_JAVA_HOME)
 else
-  JT_JAVA = $(SLASH_JAVA)/re/jdk/1.6.0/archive/fcs/binaries/$(PLATFORM)-$(ARCH)
+  JT_JAVA = $(TEST_ROOT)/../../build/$(PLATFORM)-$(ARCH)
 endif
 
 # Default JDK to test
@@ -196,7 +204,9 @@
 
 # The test directories to run
 DEFAULT_TESTDIRS = .
-TESTDIRS = $(DEFAULT_TESTDIRS)
+ifndef TESTDIRS
+  TESTDIRS = $(DEFAULT_TESTDIRS)
+endif
 
 # Root of all test results
 TEST_OUTPUT_DIR = $(TEST_ROOT)/../build/$(PLATFORM)-$(ARCH)/test/langtools
--- langtools/test/tools/javac/4846262/Test.sh	2012-08-10 10:39:38.000000000 -0700
+++ langtools/test/tools/javac/4846262/Test.sh	2013-05-05 09:38:19.000000000 -0700
@@ -44,7 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- langtools/test/tools/javac/6302184/T6302184.sh	2012-08-10 10:39:38.000000000 -0700
+++ langtools/test/tools/javac/6302184/T6302184.sh	2013-05-05 09:38:19.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- langtools/test/tools/javac/ClassPathTest/ClassPathTest.sh	2012-08-10 10:39:41.000000000 -0700
+++ langtools/test/tools/javac/ClassPathTest/ClassPathTest.sh	2013-05-05 09:38:19.000000000 -0700
@@ -56,7 +56,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows* )
--- langtools/test/tools/javac/ExtDirs/ExtDirs.sh	2012-08-10 10:39:43.000000000 -0700
+++ langtools/test/tools/javac/ExtDirs/ExtDirs.sh	2013-05-05 09:38:19.000000000 -0700
@@ -54,7 +54,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javac/MissingInclude.sh	2012-08-10 10:39:44.000000000 -0700
+++ langtools/test/tools/javac/MissingInclude.sh	2013-05-05 09:38:21.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows* )
--- langtools/test/tools/javac/ProtectedInnerClass/ProtectedInnerClass.sh	2012-08-10 10:39:45.000000000 -0700
+++ langtools/test/tools/javac/ProtectedInnerClass/ProtectedInnerClass.sh	2013-05-05 09:38:19.000000000 -0700
@@ -52,7 +52,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javac/T5090006/compiler.sh	2012-08-10 10:39:47.000000000 -0700
+++ langtools/test/tools/javac/T5090006/compiler.sh	2013-05-05 09:38:19.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows* )
--- langtools/test/tools/javac/apt.sh	2012-08-10 10:39:53.000000000 -0700
+++ langtools/test/tools/javac/apt.sh	2013-05-05 09:38:21.000000000 -0700
@@ -38,7 +38,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- langtools/test/tools/javac/constDebug/ConstDebug.sh	2012-08-10 10:39:55.000000000 -0700
+++ langtools/test/tools/javac/constDebug/ConstDebug.sh	2013-05-05 09:38:19.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javac/fatalErrors/NoJavaLang.sh	2012-08-10 10:40:03.000000000 -0700
+++ langtools/test/tools/javac/fatalErrors/NoJavaLang.sh	2013-05-05 09:38:20.000000000 -0700
@@ -48,7 +48,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- langtools/test/tools/javac/innerClassFile/Driver.sh	2012-08-10 10:40:14.000000000 -0700
+++ langtools/test/tools/javac/innerClassFile/Driver.sh	2013-05-05 09:38:21.000000000 -0700
@@ -53,7 +53,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows* )
--- langtools/test/tools/javac/javazip/Test.sh	2012-08-10 10:40:14.000000000 -0700
+++ langtools/test/tools/javac/javazip/Test.sh	2013-05-05 09:38:21.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     SCR=`pwd`
     ;;
--- langtools/test/tools/javac/links/links.sh	2012-08-10 10:40:15.000000000 -0700
+++ langtools/test/tools/javac/links/links.sh	2013-05-05 09:38:21.000000000 -0700
@@ -53,7 +53,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- langtools/test/tools/javac/newlines/Newlines.sh	2012-08-10 10:40:17.000000000 -0700
+++ langtools/test/tools/javac/newlines/Newlines.sh	2013-05-05 09:38:21.000000000 -0700
@@ -50,7 +50,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows* )
--- langtools/test/tools/javac/processing/6348499/T6348499.java	2012-08-10 10:40:18.000000000 -0700
+++ langtools/test/tools/javac/processing/6348499/T6348499.java	2013-05-05 09:38:21.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -47,6 +47,7 @@
     public static void main(String... args) {
         String testSrc = System.getProperty("test.src", ".");
         String testClasses = System.getProperty("test.classes");
+        String testClassPath = System.getProperty("test.class.path", testClasses);
         String A_java = new File(testSrc, "A.java").getPath();
         JavacTool tool = JavacTool.create();
         MyDiagListener dl = new MyDiagListener();
@@ -55,7 +56,7 @@
             fm.getJavaFileObjectsFromFiles(Arrays.asList(new File(testSrc, "A.java")));
         Iterable<String> opts = Arrays.asList("-proc:only",
                                               "-processor", "A",
-                                              "-processorpath", testClasses);
+                                              "-processorpath", testClassPath);
         StringWriter out = new StringWriter();
         JavacTask task = tool.getTask(out, fm, dl, opts, null, files);
         task.call();
--- langtools/test/tools/javac/processing/6414633/T6414633.java	2012-08-10 10:40:18.000000000 -0700
+++ langtools/test/tools/javac/processing/6414633/T6414633.java	2013-05-05 09:38:21.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,20 +43,20 @@
     public static void main(String... args) {
         String testSrc = System.getProperty("test.src", ".");
         String testClasses = System.getProperty("test.classes", ".");
+        String testClassPath = System.getProperty("test.class.path", testClasses);
 
         JavacTool tool = JavacTool.create();
         MyDiagListener dl = new MyDiagListener();
         StandardJavaFileManager fm = tool.getStandardFileManager(dl, null, null);
         try {
-            fm.setLocation(StandardLocation.CLASS_PATH, Arrays.asList(new File(testClasses)));
+            fm.setLocation(StandardLocation.CLASS_PATH, pathToFiles(testClassPath));
         } catch (IOException e) {
             throw new AssertionError(e);
         }
         Iterable<? extends JavaFileObject> files =
             fm.getJavaFileObjectsFromFiles(Arrays.asList(new File(testSrc, A.class.getName()+".java")));
         String[] opts = { "-proc:only",
-                          "-processor", A.class.getName(),
-                          "-classpath", testClasses + System.getProperty("path.separator") + "../../lib" };
+                          "-processor", A.class.getName() };
         JavacTask task = tool.getTask(null, fm, dl, Arrays.asList(opts), null, files);
         task.call();
 
@@ -65,6 +65,15 @@
             throw new AssertionError(dl.diags + " diagnostics reported");
     }
 
+    private static List<File> pathToFiles(String path) {
+        List<File> list = new ArrayList<File>();
+        for (String s: path.split(File.pathSeparator)) {
+            if (!s.isEmpty())
+                list.add(new File(s));
+        }
+        return list;
+    }
+
     private static class MyDiagListener implements DiagnosticListener<JavaFileObject>
     {
         public void report(Diagnostic d) {
--- langtools/test/tools/javac/processing/6430209/T6430209.java	2012-08-10 10:40:18.000000000 -0700
+++ langtools/test/tools/javac/processing/6430209/T6430209.java	2013-05-05 09:38:21.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,6 +56,7 @@
         // -proc:only -processor b6341534 -cp . ./src/*.java
         String testSrc = System.getProperty("test.src", ".");
         String testClasses = System.getProperty("test.classes") + System.getProperty("path.separator") + "../../lib";
+        String testClassPath = System.getProperty("test.class.path", testClasses);
         JavacTool tool = JavacTool.create();
         MyDiagListener dl = new MyDiagListener();
         StandardJavaFileManager fm = tool.getStandardFileManager(dl, null, null);
@@ -64,7 +65,7 @@
             new File(testSrc, "test0.java"), new File(testSrc, "test1.java")));
         Iterable<String> opts = Arrays.asList("-proc:only",
                                               "-processor", "b6341534",
-                                              "-processorpath", testClasses);
+                                              "-processorpath", testClassPath);
         StringWriter out = new StringWriter();
         JavacTask task = tool.getTask(out, fm, dl, opts, null, files);
         task.call();
--- langtools/test/tools/javac/processing/T6920317.java	2012-08-10 10:40:19.000000000 -0700
+++ langtools/test/tools/javac/processing/T6920317.java	2013-05-05 09:38:21.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -156,7 +156,9 @@
         String expect = null;
 
         opts.add("-processorpath");
-        opts.add(System.getProperty("test.classes"));
+        String testClasses = System.getProperty("test.classes");
+        String testClassPath = System.getProperty("test.class.path", testClasses);
+        opts.add(testClassPath);
         opts.add("-processor");
         opts.add(Processor.class.getName());
         opts.add("-proc:only");
--- langtools/test/tools/javac/stackmap/T4955930.sh	2012-08-10 10:40:22.000000000 -0700
+++ langtools/test/tools/javac/stackmap/T4955930.sh	2013-05-05 09:38:21.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows_95 | Windows_98 | Windows_NT )
--- langtools/test/tools/javac/unicode/SupplementaryJavaID6.sh	2012-08-10 10:40:25.000000000 -0700
+++ langtools/test/tools/javac/unicode/SupplementaryJavaID6.sh	2013-05-05 09:38:21.000000000 -0700
@@ -55,7 +55,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | Darwin | *BSD )
     if [ -d /usr/lib/locale/en_US.UTF-8 -o -d /usr/lib/locale/en_US.utf8 ]
     then
         ENV="env LANG=en_US.UTF-8"
--- langtools/test/tools/javah/6257087/foo.sh	2012-08-10 10:40:28.000000000 -0700
+++ langtools/test/tools/javah/6257087/foo.sh	2013-05-05 09:38:21.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javah/ConstMacroTest.sh	2012-08-10 10:40:28.000000000 -0700
+++ langtools/test/tools/javah/ConstMacroTest.sh	2013-05-05 09:38:21.000000000 -0700
@@ -56,7 +56,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javah/MissingParamClassTest.sh	2012-08-10 10:40:28.000000000 -0700
+++ langtools/test/tools/javah/MissingParamClassTest.sh	2013-05-05 09:38:21.000000000 -0700
@@ -58,7 +58,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javah/ReadOldClass.sh	2012-08-10 10:40:28.000000000 -0700
+++ langtools/test/tools/javah/ReadOldClass.sh	2013-05-05 09:38:21.000000000 -0700
@@ -43,7 +43,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     PS=":"
     FS="/"
     ;;
--- langtools/test/tools/javap/pathsep.sh	2012-08-10 10:40:29.000000000 -0700
+++ langtools/test/tools/javap/pathsep.sh	2013-05-05 09:38:21.000000000 -0700
@@ -40,7 +40,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | Darwin | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin | CYGWIN* )
     FS="/"
     ;;
   Windows* )
--- make/scripts/normalizer.pl	2012-08-10 09:07:04.000000000 -0700
+++ make/scripts/normalizer.pl	1969-12-31 16:00:00.000000000 -0800
@@ -1,208 +0,0 @@
-#!/usr/bin/perl
-
-#
-# Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-#
-
-#
-# Parses java files:
-#   1. Removes from the end of lines spaces and TABs
-#   2. Replaces TABs by spaces
-#   3. Replaces all NewLine separators by Unix NewLine separators
-#   4. Makes one and only one empty line at the end of each file
-
-if ($#ARGV < 0) {
-    &usage;
-    
-    die;
-}
-
-use Cwd 'abs_path';
-
-my @extensions = ("java");
-
-# Read options
-my $dirpos = 0;
-
-while ($dirpos < $#ARGV) {
-    if ($ARGV[$dirpos] eq "-e") {
-        @extensions = split(/,/, $ARGV[$dirpos + 1]);
-    } else {
-        last;
-    }
-
-    $dirpos += 2;
-}
-
-if ($dirpos > $#ARGV) {
-    &usage;
-
-    die;
-}
-
-use Cwd;
-my $currdir = getcwd;
-
-my $allfiles = 0;
-
-my $filecount = 0;
-
-my @tabvalues;
-
-# Init tabvalues
-push (@tabvalues, " ");
-
-for (my $i = 1; $i < 8; $i++) {
-    push(@tabvalues, $tabvalues[$i - 1] . " ");
-}
-
-open(FILELIST, ">$currdir/filelist") or die "Failed while open $currdir/filelist: $!\n";
-
-while ($dirpos <= $#ARGV) {
-    use File::Find;
-
-    find(\&parse_file, abs_path($ARGV[$dirpos]));
-
-    $dirpos += 1;
-}
-
-close(FILELIST);
-
-use Cwd 'chdir';
-chdir $currdir;
-
-print "Checked $allfiles file(s)\n";
-print "Modified $filecount file(s)\n";
-print "See results in the file $currdir/filelist\n";
-
-sub parse_file {
-    my $filename = $File::Find::name;
-
-    # Skip directories
-    return if -d;
-    
-    # Skip SCCS files
-    return if ($filename =~ /\/SCCS\//);
-
-    # Skip files with invalid extensions
-    my $accepted = 0;
-    foreach my $ext (@extensions) {
-        if ($_ =~ /\.$ext$/i) {
-            $accepted = 1;
-
-            last;
-        }
-    }
-    return if ($accepted == 0);
-
-    use File::Basename;
-    my $dirname = dirname($filename);
-
-    use Cwd 'chdir';
-    chdir $dirname;
-
-    open(FILE, $filename) or die "Failed while open $filename: $!\n";
-    
-    # Read file
-    my @content;
-    my $line;
-    my $emptylinescount = 0;
-    my $modified = 0;
-    
-    while ($line = <FILE>) {
-        my $originalline = $line;
-
-        # Process line
-        
-        # Remove from the end of the line spaces and return character
-        while ($line =~ /\s$/) {
-            chop($line);
-        }
-
-        # Replace TABs
-        for (my $i = 0; $i < length($line); $i++) {
-            if (substr($line, $i, 1) =~ /\t/) {
-                $line = substr($line, 0, $i) . $tabvalues[7 - ($i % 8)] . substr($line, $i + 1);
-            }
-        }
-        
-        if (length($line) == 0) {
-            $emptylinescount++;
-        } else {
-            while ($emptylinescount > 0) {
-                push(@content, "");
-                
-                $emptylinescount--;
-            }
-            
-            push(@content, $line);
-        }
-
-        if ($originalline ne ($line . "\n")) {
-            $modified = 1;
-        }
-
-    }
-    
-    $allfiles++;
-    
-    if ($emptylinescount > 0) {
-        $modified = 1;
-    }
-
-    close(FILE);
-    
-    if ($modified != 0) {
-        # Write file
-        open(FILE, ">$filename") or die "Failed while open $filename: $!\n";
-    
-        for (my $i = 0; $i <= $#content; $i++) {
-            print FILE "$content[$i]\n";
-        }
-    
-        close(FILE);
-
-        # Print name from current dir
-        if (index($filename, $currdir) == 0) {
-           print FILELIST substr($filename, length($currdir) + 1);
-        } else {
-           print FILELIST $filename;
-        }
-        print FILELIST "\n";
-
-        $filecount++;
-
-        print "$filename: modified\n";
-    }
-}
-
-sub usage {
-    print "Usage:\n";
-    print "  normalizer.pl [-options] <dir> [dir2 dir3 ...]\n";
-    print "  Available options:\n";
-    print "    -e    comma separated files extensions. By default accepts only java files\n";
-    print "\n";
-    print "Examples:\n";
-    print "  normalizer.pl -e c,cpp,h,hpp .\n";
-}
-
-
