patches for server2.2-pl2
--- server2.2-pl2/daemon.c.orig	Sat Jan 31 09:53:47 1998
+++ server2.2-pl2/daemon.c	Sat Jan 31 09:53:20 1998
@@ -13,6 +13,11 @@
 #include <sys/time.h>
 #include <ctype.h>
 
+#ifdef __FreeBSD__
+#include <stdlib.h>
+#include <string.h>
+#endif
+
 #ifdef linux
 #include <string.h>
 #include <stdlib.h>
@@ -34,7 +39,6 @@
 #include "ndtp.h"
 #include "misc.h"
 
-
 #ifdef DEBUG
 extern int debug;
 #endif
@@ -104,8 +108,11 @@
 #endif
 		exit(1);
 	}
-
+#ifdef __FreeBSD__
+	if( bind(ls, (struct sockaddr *)&myaddr_in, sizeof(struct sockaddr_in)) == -1)  {
+#else
 	if( bind(ls, &myaddr_in, sizeof(struct sockaddr_in)) == -1)  {
+#endif
 #ifdef SYSLOG
 		syslog(LOG_ERR,"Unable to bind address /iserver_init\n");
 #endif
--- server2.2-pl2/lookup.c.orig	Fri Aug  9 19:10:32 1996
+++ server2.2-pl2/lookup.c	Sat Jan 31 11:29:09 1998
@@ -267,13 +267,25 @@
 	}
 }
 
-dict_read(dict,ptr,size,count)
+static int
+dict_read_new(Dict *dict,char *ptr,int size,int count)
+/* dict_read only for showhonmon function */
+{
+  int	i;
+  size *= count;
+  for( i=0; i<size; i++,ptr++ ) {
+    *ptr = dic_getc(dict);
+  }
+}
+
+static int
+dict_read_old(dict,ptr,size,count)
 Dict *dict;
 char *ptr;
 {
 	int s;
 #ifdef DEBUG
-  printf( "dict_read size[%d] mode[%d]\n", size, dict->compress_type );
+  printf( "dict_read_old size[%d] mode[%d]\n", size, dict->compress_type );
 #endif
 	if (dict->compress_type == COMPRESS_TYPE_EDIC) {
 		size *= count;
@@ -374,12 +386,12 @@
 
 	} else {
 		dict_seekframe(dict,1);
-		if(dict_read(dict,index[0],BS,1)!=1) return -1;
+		if(dict_read_old(dict,index[0],BS,1)!=1) return -1;
 		e = TWOBYTEUINT(index[0]);
 		dict->index = NULL;
 
 		for(; e>0; e--) {
-		    if(dict_read(dict,index[0],BS,1)!=1) return -1;
+		    if(dict_read_old(dict,index[0],BS,1)!=1) return -1;
 		    if(!bcmp(index[0],null,BS)) break;
 
 		    new = (Index *)calloc(1,sizeof(Index));
@@ -501,6 +513,55 @@
 	else return q+6;
 }
 
+#ifdef HALF
+reg_jisstrnsub_(s,t,r,n,CODE)
+unsigned char *s, *t;
+int r,n;
+int CODE;
+{
+	unsigned int ss,tt;
+	if (CODE == FULL) {
+	  for(; ; s+=2,t+=2,n-=2) {
+	    ss = (*s&0x7f)<<8|*(s+1)&0x7f;
+	    tt = (*t&0x7f)<<8|*(t+1)&0x7f;
+	    if (n <= 0)  tt = 0; /* string terminate 95.2.8 by T.Motoda */
+	    
+		if(r==SHORT && (ss=='*' || ss=='?')) {
+			return 0;
+		}
+		if(r==WHOLE && (ss=='*')) {
+			return 0;
+		}
+		if(!ss || !tt) break;
+		if(r==WHOLE && (ss=='?')) {
+			continue;
+		}
+		if(ss!=tt) break;
+	  }
+	} else {
+	  for(; ; s++,t++,n--) {
+	    ss = (*s);
+	    tt = (*t);
+	    if (n <= 0)  tt = 0; /* string terminate 95.2.8 by T.Motoda */
+	    if(tt==0x20 && *(t+1)==0)tt=0; /* Delete last ' ' */
+	    
+		if(r==SHORT && (ss=='*' || ss=='?')) {
+			return 0;
+		}
+		if(r==WHOLE && (ss=='*')) {
+			return 0;
+		}
+		if(!ss || !tt) break;
+		if(r==WHOLE && (ss=='?')) {
+			continue;
+		}
+		if(ss!=tt) break;
+	  }
+	}
+	return ss-tt;
+}
+#endif
+
 findentry_int(key,realkey,frm,env_p)
 unsigned char *key,*realkey;
 ENV *env_p;
@@ -509,6 +570,9 @@
 	unsigned char frame[FRAMESIZE+2];
 	static char msg[32];
 	Dict *dict;
+#ifdef HALF
+	int CODE=dict_set[env_p->dict_num].code; /* FULL or HALF */
+#endif
 
 	dict=env_p->dict;
 
@@ -542,12 +606,21 @@
 				putnstr(q,s);
 				printf("\n");
 #endif
+#ifdef HALF
+				if(reg_jisstrnsub_(key,q,SHORT,s,CODE)<=0) {
+					findentry_int(key,realkey,FOURBYTEUINT(q+s),env_p);
+				}
+				if(reg_jisstrnsub_(key,q,SHORT,s,CODE)<0) {
+					return;
+				}
+#else
 				if(reg_jisstrnsub(key,q,SHORT,s)<=0) {
 					findentry_int(key,realkey,FOURBYTEUINT(q+s),env_p);
 				}
 				if(reg_jisstrnsub(key,q,SHORT,s)<0) {
 					return;
 				}
+#endif
 			}
 		}
 		else if(frame[1]==0) {
@@ -625,7 +698,11 @@
 						putnstr(q,s);
 #endif
 						if(!match) {
+#ifdef HALF
+							match=!reg_jisstrnsub_(realkey,q,WHOLE,s,CODE);
+#else
 							match=!reg_jisstrnsub(realkey,q,WHOLE,s);
+#endif
 						}
 						q+=s;
 #ifdef DEBUG
@@ -644,7 +721,11 @@
 					putnstr(q,s);
 #endif
 					if(!match) {
+#ifdef HALF
+						match=!reg_jisstrnsub_(realkey,q,WHOLE,s,CODE);
+#else
 						match=!reg_jisstrnsub(realkey,q,WHOLE,s);
+#endif
 					}
 #ifdef DEBUG
 					putchar('\n');
@@ -722,6 +803,28 @@
 #endif
 }
 
+static void myGetHiLo( dict, env_p, hi, lo )
+Dict *dict;
+ENV *env_p;
+int *hi;	/*(out)*/
+int *lo;	/*(out)*/
+{
+  int	c;
+
+  c = dic_getc(dict);
+  if( c == 0x1f ||
+      dict_set[env_p->dict_num].code == FULL) {
+    *hi = c;
+    *lo = dic_getc(dict);
+  } else {
+    *lo = c;
+    if ( *lo < 32) {
+       *hi = *lo;
+       *lo = dic_getc(dict);
+    } else *hi = 0x23;
+  }
+}
+
 showhonmon(frm,ofs,raw,env_p)
 ENV *env_p;
 {
@@ -742,7 +845,6 @@
 	int half, height,width ,ref, count, fig,size;
 	int i,j;
 	char c;
-
 	fig = FALSE;
 	half= dict_set[env_p->dict_num].code ? 1 : 0;
 	dict=env_p->dict;
@@ -774,17 +876,20 @@
 
 	  if( dic_seek(dict,frm,ofs) ) return;
 
-	  hi = dic_getc(dict);            /* Fetch */
-          lo = dic_getc(dict);
+	/*hi = dic_getc(dict);            ** Fetch */
+	/*lo = dic_getc(dict);*/
+	  myGetHiLo( dict, env_p, &hi, &lo );
 	  while(!(hi==0x1f && lo==0x02) && 	/* if Doc start */
 	        !(hi==0x1f && lo==0x41) && 	/* if Key start */
 	        !(hi==0x1f && lo==0x45)) {	/* if Fig start */
+		if( hi!=0x1f ) { goto loop1; }
 		if(hi==0x1f && lo==0x09){        /* if not  /* if TAB  skip 2byte */
                        	hi = dic_getc(dict);
                        	lo = dic_getc(dict);
                 }
-		hi = dic_getc(dict);
-		lo = dic_getc(dict);
+	      /*hi = dic_getc(dict);*/
+	      /*lo = dic_getc(dict);*/
+		myGetHiLo( dict, env_p, &hi, &lo );
 	  }
 	 /* Doc ,Key or Fig start */
 	  /* if Key start */
@@ -799,7 +904,7 @@
 	     fig=TRUE;
 	  }
 
-	    if (dict_set[env_p->dict_num].code == FULL) {
+	  /*if (dict_set[env_p->dict_num].code == FULL) {
                 hi = dic_getc(dict);
                 lo = dic_getc(dict);
             } else {
@@ -808,8 +913,9 @@
                      hi = lo;
                      lo = dic_getc(dict);
                 } else hi = 0x23;
-            }
-	  
+            }*/
+	    myGetHiLo( dict, env_p, &hi, &lo );
+loop1:
 	  while(!(hi==0x00 && 
 		   lo==dict_set[env_p->dict_num].endcode &&
 		    TAB ) /* 1f09(tab)+0001 -> end */ 
@@ -867,7 +973,7 @@
 	      case 0x31:	/* fig start */
 	 	hi = dic_getc(dict);
 	 	lo = dic_getc(dict);
-		dict_read(dict,rbuf,4,1);
+		dict_read_new(dict,rbuf,4,1);
 		/* fread(rbuf,4,1,dict->stream); */
 		height = TWOBCDUINT(rbuf);
 		width  = TWOBCDUINT(rbuf+2);
@@ -877,7 +983,7 @@
 	 		hi = dic_getc(dict);
 	 		lo = dic_getc(dict);
 	        } while(!(hi==0x1f && lo==0x51 ));
-		dict_read(dict,rbuf,6,1);
+		dict_read_new(dict,rbuf,6,1);
 		/*fread(rbuf,6,1,dict->stream); */
 		frmtmp = FOURBCDUINT(rbuf);
 		ofstmp  = TWOBCDUINT(rbuf+4);
@@ -903,7 +1009,7 @@
 	       case 0x44:	/* fig start */
 	 	hi = dic_getc(dict);
 	 	lo = dic_getc(dict);
-		dict_read(dict,rbuf,8,1);
+		dict_read_new(dict,rbuf,8,1);
 		/* fread(rbuf,8,1,dict->stream); */
 		height = FOURBCDUINT(rbuf);
 		width  = FOURBCDUINT(rbuf+4);
@@ -916,21 +1022,21 @@
 		  lo = dic_getc(dict);
 		break;
 	      case 0x48:	/*  music ref start */
-		dict_read(dict,rbuf,10,1);
+		dict_read_new(dict,rbuf,10,1);
 		/*fread(rbuf,10,1,dict->stream); */
 		frmtmp=(unsigned long int)SIXBCDUINT(rbuf);
 		ofstmp=FOURBCDUINT(rbuf+6);
 		write(cur_s,buf,strlen(buf));
 		break;
 	      case 0x51:	/* pointer to fig page:offset(BCD)*/
-		dict_read(dict,rbuf,6,1);
+		dict_read_new(dict,rbuf,6,1);
 		frmtmp=FOURBCDUINT(rbuf);
 		ofstmp=TWOBCDUINT(rbuf+4);
 		sprintf(buf,"<%x:%x>",frmtmp,ofstmp);
 		write(cur_s,buf,strlen(buf));
 		break;
 	      case 0x52:	/* picture end with page:offset(BCD)*/
-		dict_read(dict,rbuf,6,1);
+		dict_read_new(dict,rbuf,6,1);
 		frmtmp=FOURBCDUINT(rbuf);
 		ofstmp=TWOBCDUINT(rbuf+4);
 		sprintf(buf,"<%x:%x>",frmtmp,ofstmp);
@@ -939,7 +1045,7 @@
 	      case 0x53:	/* end with page:offset(BCD)*/
 		ref   = FALSE;
 		if(fig==FALSE){ 
-		  dict_read(dict,rbuf,8,1);
+		  dict_read_new(dict,rbuf,8,1);
 		  frmtmp=FOURBCDUINT(rbuf);
 		  ofstmp=FOURBCDUINT(rbuf+4);
 		  sprintf(buf,"<%x:%x>",frmtmp,ofstmp);
@@ -958,7 +1064,7 @@
 	      case 0x62:	/* refrence end with page:offset(BCD) */
 	      case 0x63:	/* menu end with page:offset(BCD) */
 		ref   = FALSE;
-		dict_read(dict,rbuf,6,1);
+		dict_read_new(dict,rbuf,6,1);
 		frmtmp=FOURBCDUINT(rbuf);
 		ofstmp=TWOBCDUINT(rbuf+4);
 		sprintf(buf,"<%x:%x>",frmtmp,ofstmp);
@@ -966,7 +1072,7 @@
 		break;
 	      case 0x64:	/* fig ref  end with page:offset(BCD) */
 		honmon = TRUE;
-		dict_read(dict,rbuf,6,1);
+		dict_read_new(dict,rbuf,6,1);
 		frmtmp=FOURBCDUINT(rbuf);
 		ofstmp=TWOBCDUINT(rbuf+4);
 		sprintf(buf,"<%x:%x>",frmtmp,ofstmp);
@@ -998,7 +1104,7 @@
 	       puteucz2h(cur_s,hi,lo,env_p->dict_num);
 	    }
 
-	    if (dict_set[env_p->dict_num].code == FULL) {
+	  /*if (dict_set[env_p->dict_num].code == FULL) {
                 hi = dic_getc(dict);
                 lo = dic_getc(dict);
             } else {
@@ -1007,7 +1113,8 @@
                      hi = lo;
                      lo = dic_getc(dict);
                 } else hi = 0x23;
-            }
+            }*/
+	    myGetHiLo( dict, env_p, &hi, &lo );
 	  }
 	}
 	write(cur_s,"\n",1);
@@ -1108,7 +1215,7 @@
     }
   } else {
     dict_seekframe(dict,frm);
-    dict_read(dict, buff, FRAMESIZE, 1);
+    dict_read_old(dict, buff, FRAMESIZE, 1);
   }
   return 1;
 
--- server2.2-pl2/Makefile.orig	Sat Jan 31 09:53:35 1998
+++ server2.2-pl2/Makefile	Sat Jan 31 09:53:20 1998
@@ -2,33 +2,39 @@
 #CC=cc
 CC=gcc
 
-DSERVERTOPDIR=/usr/local/etc/dserverdir
+DSERVERTOPDIR=${PREFIX}/lib/dserver
 #DSERVERTOPDIR=/nfs/home40/usui/dserver/server2.2-current/table
-DICTROOT=/usr/local/dict
+DICTROOT=${PREFIX}/share/dict
 ACCESSFILE=${DSERVERTOPDIR}/dserver_access
 
-BINDIR=/usr/local/lib
+BINDIR=${PREFIX}/lib/dserver
+DOCDIR=${DSERVERTOPDIR}/doc
+LISPLIB=${PREFIX}/lib/mule/site-lisp
 #LISPLIB=/usr/local/lib/Nemacs/lisp #usui
 
 DEFS=-D'ACCESSFILE="$(ACCESSFILE)"' \
--D'DSERVERTOPDIR="$(DSERVERTOPDIR)"'
+-D'DSERVERTOPDIR="$(DSERVERTOPDIR)"' -DHALF
 
 # define AUTH for auth
 # define DICLOOKUPMULE for mule
-OFLAG=
-CFLAGS= $(OFLAG) -DSTANDALONE $(DEFS) -DDEBUG -DSYSLOG
-CFLAGS=-Dsparc $(OFLAG) -DSYSLOG -DSTANDALONE $(DEFS)
+OFLAG= -O2
+#CFLAGS= $(OFLAG) -DSTANDALONE $(DEFS) -DDEBUG -DSYSLOG
+#CFLAGS=-Dsparc $(OFLAG) -DSYSLOG -DSTANDALONE $(DEFS)
 #CFLAGS=-Dsparc $(OFLAG) -DSYSLOG -DAUTH -DDICLOOKUPMULE -DSTANDALONE $(DEFS)
-CFLAGS=-Dsparc $(OFLAG) -DSYSLOG -DSTANDALONE $(DEFS) -DDEBUG
+#CFLAGS=-Dsparc $(OFLAG) -DSYSLOG -DSTANDALONE $(DEFS) -DDEBUG
+CFLAGS= $(OFLAG) -DSTANDALONE -DSYSLOG $(DEFS)
 
 #for solaris
 #CFLAGS=-Dsolaris -Dsparc $(OFLAG) -DSYSLOG -DSTANDALONE $(DEFS)
 #DFLAGS =-lsocket -lnsl -R/usr/ucblib -L/usr/ucblib -lucb
 
-all: dserver
+all: dserver compress/makedic
 dserver: $(OBJ)
 	$(CC) $(CFLAGS) -o dserver $(OBJ)
 
+compress/makedic:
+	(cd compress ; ${MAKE} all)
+
 #dserver: $(OBJ)
 #	$(CC) $(CFLAGS) -o dserver $(OBJ) $(DFLAGS)
 
@@ -39,4 +45,12 @@
 	lint -Dsparc -DSTANDALONE -DSYSLOG $(DEFS) *.c
 
 install:
-	install -m 755 dserver $(BINDIR)
+	if  [ ! -d ${DOCDIR} ] ; then mkdir -p ${DOCDIR} ; fi
+	if  [ ! -d ${DICTROOT}/cdrom ] ; then mkdir -p ${DICTROOT}/cdrom ; fi
+	install -c -s -m 755 dserver $(BINDIR)
+	(cd compress ; ${MAKE} install)
+	cp table/*.tbl table/dserver_access ${DSERVERTOPDIR}
+	cat table/dserver_access | sed -e 's!PREFIX_DIR!${PREFIX}!g'  > ${DSERVERTOPDIR}/dserver_access
+	cp CHANGES newfeature.doc ${DOCDIR}
+	cp README ${DOCDIR}/README.dserver
+	cp table/README ${DOCDIR}/README.table
--- server2.2-pl2/subnet.c.orig	Sat Aug 10 02:10:30 1996
+++ server2.2-pl2/subnet.c	Tue Jan 28 08:22:43 1997
@@ -1,6 +1,7 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
+#include <sys/time.h>
 #include <net/if.h>
 #include <sys/ioctl.h>
 
--- server2.2-pl2/table/dserver_access.orig	Sat Jan 31 09:53:59 1998
+++ server2.2-pl2/table/dserver_access	Sat Jan 31 09:53:20 1998
@@ -1,14 +1,22 @@
-#DICT kojien /usr/local/etc/CDdict/yrrs096/koujien/start. "広辞苑第４版" 1  600
-##DICT eiwa /usr/local/etc/CDdict/yrrs118/chujiten/start. "研究社中英和" 25 600
-##DICT eiwa /usr/local/etc/CDdict/yrrs118/chujiten/start.comp "研究社中英和" 25 600
-##DICT eiwa /usr/local/etc/CDdict/yrrs009/eiwa/start.comp "研究社中英和" 25 600
-##DICT waei /usr/local/etc/CDdict/yrrs118/chujiten/start.comp "研究社中和英" 25 600
-#DICT waei /usr/local/etc/CDdict/cdchujiten/chujiten/data/honmon. "研究社中和英" 25 600
-#DICT eiwa /usr/local/etc/CDdict/cdchujiten/chujiten/data/honmon. "研究社中和英" 25 600
-#DICT CDkojien /usr/local/etc/CDdict/cdkouji/koujien/data/honmon. "広辞苑ＣＤ版" 1  600
-#DICT readers /usr/local/etc/CDdict/yrrs172/readers/start. "リーダーズ英和" 1  600
-#DICTROOT /usr/local/etc/CDdict 2 500
+#DICT kojien PREFIX_DIR/share/dict/cdrom/yrrs096/koujien/start "広辞苑第４版" 1  600
+##DICT kojien-furoku PREFIX_DIR/share/dict/cdrom/yrrs096/furoku/start "広辞苑第４版付録" 1  600
+##DICT waei PREFIX_DIR/share/dict/cdrom/cdchujiten/chujiten/data/honmon "研究社中和英" 25 600
+##DICT eiwa PREFIX_DIR/share/dict/cdrom/cdchujiten/chujiten/data/honmon "研究社中和英" 25 600
+##DICT readers PREFIX_DIR/share/dict/cdrom/yrrs172/readers/start "リーダーズ英和" 1  600
+##DICT crfre PREFIX_DIR/share/dict/cdrom/yrrs091/crfre/start "三省堂クラウン仏和" 1  600
+##DICT crger PREFIX_DIR/share/dict/cdrom/yrrs092/crger/start "三省堂クラウン独和" 1  600
+##DICT italian /usr/local/share/dict/cdrom/yrrs214/jiten/start "現代イタリア語表現辞典" 1  600
+##DICT italian-j /usr/local/share/dict/cdrom/yrrs214/jiten/start "現代イタリア語表現辞典" 1  600
+##DICT oxford /usr/local/share/dict/cdrom/san042/oxford/start "OxfordEnglishDictionary" 1  600
+##DICT CDkojien PREFIX_DIR/share/dict/cdrom/cdkouji/koujien/data/honmon "広辞苑ＣＤ版" 1  600
+##DICT eiwa PREFIX_DIR/share/dict/cdrom/yrrs118/chujiten/start "研究社中英和" 25 600
+##DICT waei PREFIX_DIR/share/dict/cdrom/yrrs118/chujiten/start "研究社中英和" 25 600
+##DICT eiwa PREFIX_DIR/share/dict/cdrom/yrrs118/chujiten/start.comp "研究社中英和" 25 600
+##DICT waei PREFIX_DIR/share/dict/cdrom/yrrs118/chujiten/start.comp "研究社中和英" 25 600
+##DICT daijirin PREFIX_DIR/share/dict/cdrom/yrrs082/dgx01/start "大辞林" 1 600
+#
+#DICTROOT PREFIX_DIR/share/dict/cdrom 2 500
 ## access controle
 #
-topics
+localhost
 #
--- server2.2-pl2/compress/Makefile.orig	Sat Aug 10 02:10:29 1996
+++ server2.2-pl2/compress/Makefile	Tue Jan 28 08:22:43 1997
@@ -11,11 +11,15 @@
 CFLAGS = -O -Wall
 LFLAGS =
 
+
 OBJ1 = main.o compress.o
 
 
 OBJS = $(OBJ1)
 PROG = makedic
+BINDIR = ${PREFIX}/bin
+
+all: $(PROG)
 
 $(PROG)		:	$(OBJS)
 	$(CC) $(OBJS) $(LFLAGS) -o $(PROG)
@@ -26,5 +30,8 @@
 main.o : defs.h
 comp.o : defs.h
 
+install: $(PROG)
+	install -s $(PROG) $(BINDIR)
+
 clean:
-	rm -f *.o core makedic *~
+	rm -f *.o core makedic *~
--- server2.2-pl2/misc.h.orig	Sun Dec  5 21:43:26 2004
+++ server2.2-pl2/misc.h	Sun Dec  5 21:44:19 2004
@@ -1,4 +1,5 @@
 /* external variable controle */
+#include<sys/types.h>
 
 #ifdef DSERVER_MAIN
 #define Extern 
--- server2.2-pl2/compress/main.c.orig	Sat Aug 10 02:10:30 1996
+++ server2.2-pl2/compress/main.c	Sun Dec  5 21:48:36 2004
@@ -3,6 +3,21 @@
 					by toshioji@darkover.iijnet.or.jp
 
 	dic version 0.24 cdio.c by kmiya さんを元に作成
+
+========== dic.man より引用開始 ==========
+DIC(1)                   Dic Users Manual                  DIC(1)
+
+
+DISTRIBUTION
+       このプログラムの改良 移植 転載 などは、 自由に行っても らっ
+       て結構です。 また、 作者に報告する必要もありません。
+
+       で き れば、改変された物であることの明記（どのバ−ジョンの
+       Dic をどのように変更したか）をしていただければ幸いです。
+
+       さらにソ−スコ−ドも同時に公開していただいてさらなる改良 が
+       自由に 行われるようにすることを希望します。
+========== dic.man より引用終了 ==========
  */
 
 #include    "defs.h"
@@ -36,10 +51,47 @@
   return 0;
 }
 
+char ok(char *string)
+{
+  char key_buf[2];
+
+  fputs( string, stdout );
+  fgets( key_buf, 2, stdin );
+  return key_buf[0];
+}
+
+void caution(void)
+{
+
+  puts("<<<<<<<<< makedic を使われる前に※必ず※以下の内容を確認下さい。>>>>>>>>>\nこれは dserver/server2.1/README「執筆   臼井 義比古＠環境システム研究所」\nからライセンス関係の記述を抜きだしたものです。\n==================== dserver/server2.1/README ====================\n  ライセンスはちゃんと守って下さい,以下に三田吉郎<mita@jp.FreeBSD.org>\n  さんが調べて下さった文章を添付します.\n------------------------------------------------------------------------" );
+  ok( "<改行キーを押して下さい>" );
+
+  puts("ライセンスについて   三田吉郎 <mita@jp.FreeBSD.org>\n dserverは、8cmCDROM版研究社新英和・和英中辞典、岩波書店広辞苑を\n 始めとする、電子ブックを読むことが出来ます。使用のたびにCDROMを\nマウントすればよいのですが、例えばCDROM分離型のノートパソコンで\n辞書を使いたいなど、ハードディスクにデータをコピーして使いたいと\n思うかも知れません。市販の\n辞書をハードディスクにコピーすること、または圧縮された辞書としての使用\nに関して問題があるかどうか、研究社と岩波書店とにお伺いしてみました(平成8年6月20日)。\n");
+  ok( "<改行キーを押して下さい>" );
+  puts("研究社の回答(電話03-3288-7777)\n個人として使用するかぎりにおいては、ハードディスクへのコピー、また\nそのデータが圧縮されてたとしても使用して良い。ただし、LAN上で\n複数の端末で使用する場合は、別途端末の台数を申告していただき、\n端末台数×(CDROM一枚の価格−α)の値段を払う契約をしていただく。");
+  ok( "<改行キーを押して下さい>" );
+  puts("岩波書店辞典部の回答  (電話03-5210-4171)\nCD-ROMドライブから読み出して使用することを前提としている。\n ハードディスクへのコピーは避けていただきたい。\n LAN上での使用の場合は、別途契約をしていただき、\n ハードディスクへのコピーを許可している。ただしUNIX上の\n サーバソフトに関しては把握していない。");
+  ok( "<改行キーを押して下さい>" );
+  puts("dserverは、この他にもOEDや、科学技術用語辞典など、外字テーブルさえ\n 用意すればほとんどのCDROMを読むことが出来ます。そのとき自分のローカル\n ディスクにデータをコピーして使用して良いかは、各社対応が異なります。\n 新しい辞書を使用する場合はまずライセンスを確認した後に使用することを\n お勧めします。\nということですので、例えば新英和・和英中辞典に関しては個人のマシンの\nハードディスクにコピーすることは可能ですが、広辞苑に関してはLAN契約を\n結ばない限りハードディスクへのコピーをさけるのが良いようです。\n");
+  puts("-----------------------------------------------------------------------\n 以上");
+  switch( ok( "辞書を圧縮してハードディスクにコピーすることに\nライセンス上の問題はありませんね[y/n] " ) ) {
+  case 'y':
+  case 'Y':
+	puts( "\n圧縮を開始します。\n" );
+	break;
+  default:
+	puts( "\nライセンス上の問題があるので中断しました\n" );
+	exit( -1 );
+	break;	
+  }
+}
+
 int	main(int argc, char *argv[])
 {
+  caution();
+
   if( argc < 3 ) {
-    fprintf( stderr, "%s soce_filename dest_filename\n", argv[ 0 ] );
+    fprintf( stderr, "Usage: %s soce_filename dest_filename\n", argv[ 0 ] );
     exit( -1 );
   }
 
